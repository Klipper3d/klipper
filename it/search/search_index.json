{"config":{"indexing":"full","lang":["it"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Klipper \u00e8 un firmware per stampanti 3D. Combina la potenza di un computer con uno o pi\u00f9 microntrollori. Leggi la pagina sulle funzionalit\u00e0 per avere pi\u00f9 informazioni sul perch\u00e9 usare Klipper. Per iniziare ad usare Klipper comincia con la sua installazione . Klipper \u00e8 un software libero. Leggi la documentazione o visualizza il codice Klipper su github . Dipendiamo dal generoso supporto dei nostri sponsor .","title":"Benvenuto"},{"location":"API_Server.html","text":"Server API \u00b6 Questo documento descrive l'Application Programmer Interface (API) di Klipper. Questa interfaccia consente alle applicazioni esterne di interrogare e controllare il software host Klipper. Abilitazione del socket API \u00b6 Per utilizzare il server API, il software host klippy.py deve essere avviato con il parametro -a . Per esempio: ~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer.cfg -a /tmp/klippy_uds -l /tmp/klippy.log Ci\u00f2 fa s\u00ec che il software host crei un socket di dominio Unix. Un client pu\u00f2 quindi aprire una connessione su quel socket e inviare comandi a Klipper. Consulta il progetto Moonraker per uno strumento popolare in grado di inoltrare richieste HTTP all'API Server Unix Domain Socket di Klipper. Formato richiesta \u00b6 I messaggi inviati e ricevuti sul socket sono stringhe codificate JSON terminate da un carattere ASCII 0x03: <json_object_1><0x03><json_object_2><0x03>... Klipper contiene uno strumento scripts/whconsole.py che pu\u00f2 eseguire il framing dei messaggi sopra. Per esempio: ~/klipper/scripts/whconsole.py /tmp/klippy_uds Questo strumento pu\u00f2 leggere una serie di comandi JSON da stdin, inviarli a Klipper e riportare i risultati. Lo strumento prevede che ogni comando JSON si trovi su una singola riga e aggiunger\u00e0 automaticamente il terminatore 0x03 durante la trasmissione di una richiesta. (Il server dell'API Klipper non ha un requisito di newline.) Protocollo API \u00b6 Il protocollo dei comandi utilizzato sul socket di comunicazione \u00e8 ispirato a json-rpc . Una richiesta potrebbe essere simile a: {\"id\": 123, \"method\": \"info\", \"params\": {}} e una risposta potrebbe essere simile a: {\"id\": 123, \"result\": {\"state_message\": \"Printer is ready\", \"klipper_path\": \"/home/pi/klipper\", \"config_file\": \"/home/pi/printer.cfg\", \"software_version\": \"v0.8.0-823-g883b1cb6\", \"hostname\": \"octopi\", \"cpu_info\": \"4 core ARMv7 Processor rev 4 (v7l)\", \"state\": \"ready\", \"python_path\": \"/home/pi/klippy-env/bin/python\", \"log_file\": \"/tmp/klippy.log\"}} Ogni richiesta deve essere un dizionario JSON. (Questo documento usa il termine Python \"dizionario\" per descrivere un \"oggetto JSON\" - una mappatura di coppie chiave/valore contenute in {} .) Il dizionario di richiesta deve contenere un parametro \"method\" che \u00e8 il nome stringa di un \"endpoint\" di Klipper disponibile. Il dizionario della richiesta pu\u00f2 contenere un parametro \"params\" che deve essere di tipo dizionario. I \"parametri\" forniscono ulteriori informazioni sui parametri all'\"endpoint\" di Klipper che gestisce la richiesta. Il suo contenuto \u00e8 specifico dell'\"endpoint\". Il dizionario delle richieste pu\u00f2 contenere un parametro \"id\" che pu\u00f2 essere di qualsiasi tipo JSON. Se \u00e8 presente \"id\", Klipper risponder\u00e0 alla richiesta con un messaggio di risposta contenente tale \"id\". Se \"id\" viene omesso (o impostato su un valore JSON \"null\"), Klipper non fornir\u00e0 alcuna risposta alla richiesta. Un messaggio di risposta \u00e8 un dizionario JSON contenente \"id\" e \"result\". Il \"risultato\" \u00e8 sempre un dizionario: i suoi contenuti sono specifici dell'\"endpoint\" che gestisce la richiesta. Se l'elaborazione di una richiesta genera un errore, il messaggio di risposta conterr\u00e0 un campo \"errore\" anzich\u00e9 un campo \"risultato\". Ad esempio, la richiesta: {\"id\": 123, \"method\": \"gcode/script\", \"params\": {\"script\": \"G1 X200\"}} potrebbe generare una risposta di errore come: {\"id\": 123, \"error\": {\"message\": \"Deve prima posizionare l'asse: 200.000 0.000 0.000 [0.000]\", \"error\": \"WebRequestError\"}} Klipper inizier\u00e0 sempre a elaborare le richieste nell'ordine in cui sono state ricevute. Tuttavia, alcune richieste potrebbero non essere completate immediatamente, il che potrebbe causare l'invio di una risposta associata non conforme rispetto alle risposte di altre richieste. Una richiesta JSON non sospender\u00e0 mai l'elaborazione di future richieste JSON. Sottoscrizioni \u00b6 Alcune richieste di \"endpoint\" di Klipper consentono di \"iscriversi\" a futuri messaggi di aggiornamento asincrono. Per esempio: {\"id\": 123, \"method\": \"gcode/subscribe_output\", \"params\": {\"response_template\":{\"key\": 345}}} inizialmente pu\u00f2 rispondere con: {\"id\": 123, \"result\": {}} e fare in modo che Klipper invii messaggi futuri simili a: {\"params\": {\"response\": \"ok B:22.8 /0.0 T0:22.4 /0.0\"}, \"key\": 345} Una richiesta di sottoscrizione accetta un dizionario \"response_template\" nel campo \"params\" della richiesta. Quel dizionario \"response_template\" viene utilizzato come modello per futuri messaggi asincroni: pu\u00f2 contenere coppie chiave/valore arbitrarie. Quando invier\u00e0 questi futuri messaggi asincroni, Klipper aggiunger\u00e0 un campo \"params\" contenente un dizionario con contenuti specifici per \"endpoint\" al modello di risposta e quindi invier\u00e0 quel modello. Se non viene fornito un campo \"response_template\", il valore predefinito \u00e8 un dizionario vuoto ( {} ). \"endpoint\" disponibili \u00b6 Per convenzione, gli \"endpoint\" di Klipper sono nella forma <module_name>/<some_name> . Quando si effettua una richiesta a un \"endpoint\", il nome completo deve essere impostato nel parametro \"method\" del dizionario di richiesta (ad esempio, {\"method\"=\"gcode/restart\"} ). info \u00b6 L'endpoint \"info\" viene utilizzato per ottenere informazioni sul sistema e sulla versione da Klipper. Viene anche utilizzato per fornire a Klipper le informazioni sulla versione del client. Ad esempio: {\"id\": 123, \"method\": \"info\", \"params\": { \"client_info\": { \"version\": \"v1\"}}} Se presente, il parametro \"client_info\" deve essere un dizionario, ma quel dizionario potrebbe avere contenuti arbitrari. I clienti sono incoraggiati a fornire il nome del client e la sua versione del software quando si connettono per la prima volta al server dell'API Klipper. emergency_stop \u00b6 L'endpoint \"emergency_stop\" viene utilizzato per indicare a Klipper di passare allo stato di \"spegnimento\". Si comporta in modo simile al comando G-Code M112 . Ad esempio: {\"id\": 123, \"method\": \"emergency_stop\"} register_remote_method \u00b6 Questo endpoint consente ai client di registrare metodi che possono essere chiamati da klipper. Restituir\u00e0 un oggetto vuoto in caso di successo. Per esempio: {\"id\": 123, \"method\": \"register_remote_method\", \"params\": {\"response_template\": {\"action\": \"run_paneldue_beep\"}, \"remote_method\": \"paneldue_beep\"}} will return: {\"id\": 123, \"result\": {}} Il metodo remoto paneldue_beep ora pu\u00f2 essere chiamato da Klipper. Nota che se il metodo accetta parametri, dovrebbero essere forniti come argomenti di parole chiave. Di seguito \u00e8 riportato un esempio di come pu\u00f2 essere chiamato da una gcode_macro: [gcode_macro PANELDUE_BEEP] gcode: {action_call_remote_method(\"paneldue_beep\", frequency=300, duration=1.0)} Quando viene eseguita la macro gcode PANELDUE_BEEP, Klipper invia qualcosa di simile al seguente tramite il socket: {\"action\": \"run_paneldue_beep\", \"params\": {\"frequency\": 300, \"duration\": 1.0}} oggetti/elenco \u00b6 Questo endpoint interroga l'elenco degli \"oggetti\" della stampante disponibili che \u00e8 possibile interrogare (tramite l'endpoint \"objects/query\"). Ad esempio: {\"id\": 123, \"method\": \"objects/list\"} potrebbe restituire: {\"id\": 123, \"result\": {\"objects\": [\"webhooks\", \"configfile\" , \"heaters\", \"gcode_move\", \"query_endstops\", \"idle_timeout\", \"toolhead\", \"extruder\"]}} oggetti/interrogazione \u00b6 Questo endpoint consente di interrogare informazioni da oggetti. Ad esempio: {\"id\": 123, \"method\": \"objects/query\", \"params\": {\"objects\": {\"toolhead\": [\"position\"], \"webhooks\": null}}} potrebbe restituire: {\"id\": 123, \"result\": {\"status\": {\"webhooks\": {\"state\": \"ready\", \"state_message\": \"Printer is ready\"}, \"toolhead\": { \"position\": [0.0, 0.0, 0.0, 0.0]}}, \"eventtime\": 3051555.377933684}} Il parametro \"objects\" nella richiesta deve essere un dizionario contenente gli oggetti stampante che devono essere interrogati - la chiave contiene il nome dell'oggetto stampante e il valore \u00e8 \"null\" (per interrogare tutti i campi) o un elenco di nomi di campo. Il messaggio di risposta conterr\u00e0 un campo \"status\" contenente un dizionario con le informazioni richieste: la chiave contiene il nome dell'oggetto stampante e il valore \u00e8 un dizionario contenente i suoi campi. Il messaggio di risposta conterr\u00e0 anche un campo \"eventtime\" contenente il timestamp da quando \u00e8 stata eseguita la query. I campi disponibili sono documentati nel documento Status Reference . oggetti/subscribe \u00b6 Questo endpoint consente di eseguire query e quindi iscriversi alle informazioni dagli oggetti stampante. La richiesta e la risposta dell'endpoint sono identiche all'endpoint \"objects/query\". Ad esempio: {\"id\": 123, \"method\": \"objects/subscribe\", \"params\": {\"objects\":{\"toolhead\": [\"position\"], \"webhooks\": [\"state\"] }, \"response_template\":{}}} potrebbe restituire: {\"id\": 123, \"result\": {\"status\": {\"webhooks\": {\"state\": \"ready\"}, \"toolhead\": {\"position\": [0.0, 0.0, 0.0, 0.0]}}, \"eventtime\": 3052153.382083195}} e generare messaggi asincroni successivi come: {\"params\": {\"status\": {\"webhooks\": {\"state\": \"shutdown\"}}, \"eventtime\": 3052165.418815847}} gcode/help \u00b6 Questo endpoint consente di interrogare i comandi G-Code disponibili che hanno una stringa di aiuto definita. Ad esempio: {\"id\": 123, \"method\": \"gcode/help\"} potrebbe restituire: {\"id\": 123, \"result\": {\"RESTORE_GCODE_STATE\": \"Restore a previously saved G-Code state\", \"PID_CALIBRATE\": \"Run PID calibration test\", \"QUERY_ADC\": \"Report the last value of an analog pin\", ...}} gcode/script \u00b6 Questo endpoint consente di eseguire una serie di comandi G-Code. Ad esempio: {\"id\": 123, \"method\": \"gcode/script\", \"params\": {\"script\": \"G90\"}} Se lo script G-Code fornito genera un errore, allora viene generata una risposta di errore. Tuttavia, se il comando G-Code produce un output del terminale, tale output del terminale non viene fornito nella risposta. (Utilizzare l'endpoint \"gcode/subscribe_output\" per ottenere l'output del terminale G-Code.) Se c'\u00e8 un comando G-Code in elaborazione quando viene ricevuta questa richiesta, lo script fornito verr\u00e0 messo in coda. Questo ritardo potrebbe essere significativo (ad esempio, se \u00e8 in esecuzione un comando di attesa del codice G per la temperatura). Il messaggio di risposta JSON viene inviato al completamento dell'elaborazione dello script. gcode/restart \u00b6 Questo endpoint consente di richiedere un riavvio: \u00e8 simile all'esecuzione del comando \"RESTART\" del codice G. Ad esempio: {\"id\": 123, \"method\": \"gcode/restart\"} Come con l'endpoint \"gcode/script\", questo endpoint viene completato solo dopo il completamento di tutti i comandi G-Code in sospeso. gcode/firmware_restart \u00b6 Questo \u00e8 simile all'endpoint \"gcode/restart\": implementa il comando G-Code \"FIRMWARE_RESTART\". Ad esempio: {\"id\": 123, \"method\": \"gcode/firmware_restart\"} Come con l'endpoint \"gcode/script\", questo endpoint viene completato solo dopo il completamento di tutti i comandi G-Code in sospeso. gcode/subscribe_output \u00b6 Questo endpoint viene utilizzato per iscriversi ai messaggi del terminale G-Code generati da Klipper. Ad esempio: {\"id\": 123, \"method\": \"gcode/subscribe_output\", \"params\": {\"response_template\":{}}} potrebbe in seguito produrre messaggi asincroni come: {\"params\": { \"response\": \"// Klipper state: Shutdown\"}} Questo endpoint ha lo scopo di supportare l'interazione umana tramite un'interfaccia \"finestra di terminale\". L'analisi del contenuto dall'output del terminale G-Code \u00e8 sconsigliata. Usa l'endpoint \"objects/subscribe\" per ottenere aggiornamenti sullo stato di Klipper. motion_report/dump_stepper \u00b6 Questo endpoint viene utilizzato per iscriversi al flusso di comandi queue_step interno di Klipper per uno stepper. L'ottenimento di questi aggiornamenti di movimento di basso livello pu\u00f2 essere utile per scopi diagnostici e di debug. L'utilizzo di questo endpoint pu\u00f2 aumentare il carico di sistema di Klipper. Una richiesta pu\u00f2 essere simile a: {\"id\": 123, \"method\":\"motion_report/dump_stepper\", \"params\": {\"name\": \"stepper_x\", \"response_template\": {}}} e potrebbe restituire: {\"id\": 123, \"result\": {\"header\": [\"interval\", \"count\", \"add\"]}} e potrebbe in seguito produrre messaggi asincroni come: {\"params\": {\" first_clock\": 179601081, \"first_time\": 8.98, \"first_position\": 0, \"last_clock\": 219686097, \"last_time\": 10.984, \"data\": [[179601081, 1, 0], [29573, 2, -8685] , [16230, 4, -1525], [10559, 6, -160], [10000, 976, 0], [10000, 1000, 0], [10000, 1000, 0], [10000, 1000, 0] , [9855, 5, 187], [11632, 4, 1534], [20756, 2, 9442]]}} Il campo \"intestazione\" nella risposta alla query iniziale viene utilizzato per descrivere i campi trovati nelle risposte \"dati\" successive. motion_report/dump_trapq \u00b6 Questo endpoint viene utilizzato per iscriversi alla \"coda di movimento trapezoidale\" interna di Klipper. L'ottenimento di questi aggiornamenti di movimento di basso livello pu\u00f2 essere utile per scopi diagnostici e di debug. L'utilizzo di questo endpoint pu\u00f2 aumentare il carico di sistema di Klipper. Una richiesta pu\u00f2 essere simile a: {\"id\": 123, \"method\": \"motion_report/dump_trapq\", \"params\": {\"name\": \"toolhead\", \"response_template\":{}}} e potrebbe restituire: {\"id\": 1, \"result\": {\"header\": [\"time\", \"duration\", \"start_velocity\", \"acceleration\", \"start_position\", \"direction\"]}} e potrebbero in seguito produrre messaggi asincroni quali: {\"params\": {\"data\": [[4.05, 1.0, 0.0, 0.0, [300.0, 0.0, 0.0], [0.0, 0.0, 0.0]], [5.054, 0.001, 0.0, 3000.0 , [300.0, 0.0, 0.0], [-1.0, 0.0, 0.0]]]}} Il campo \"intestazione\" nella risposta alla query iniziale viene utilizzato per descrivere i campi trovati nelle risposte \"dati\" successive. adxl345/dump_adxl345 \u00b6 Questo endpoint viene utilizzato per la sottoscrizione ai dati dell'accelerometro ADXL345. L'ottenimento di questi aggiornamenti di movimento di basso livello pu\u00f2 essere utile per scopi diagnostici e di debug. L'utilizzo di questo endpoint pu\u00f2 aumentare il carico di sistema di Klipper. Una richiesta pu\u00f2 essere simile a: {\"id\": 123, \"method\":\"adxl345/dump_adxl345\", \"params\": {\"sensor\": \"adxl345\", \"response_template\": {}}} e potrebbe restituire: {\"id\": 123,\"result\":{\"header\":[\"time\",\"x_acceleration\",\"y_acceleration\", \"z_acceleration\"]}} e potrebbe in seguito produrre messaggi asincroni come: {\"params \":{\"overflow\":0,\"data\":[[3292.432935,-535.44309,-1529.8374,9561.4], [3292.433256,-382.45935,-1606.32927,9561.48375]]}} Il campo \"intestazione\" nella risposta alla query iniziale viene utilizzato per descrivere i campi trovati nelle risposte \"dati\" successive. angle/dump_angle \u00b6 Questo endpoint viene utilizzato per iscriversi a dati del sensore angolare . L'ottenimento di questi aggiornamenti di movimento di basso livello pu\u00f2 essere utile per scopi diagnostici e di debug. L'utilizzo di questo endpoint pu\u00f2 aumentare il carico di sistema di Klipper. Una richiesta pu\u00f2 essere simile a: {\"id\": 123, \"method\":\"angle/dump_angle\", \"params\": {\"sensor\": \"my_angle_sensor\", \"response_template\": {}}} e potrebbe restituire: {\"id\": 123,\"result\":{\"header\":[\"time\",\"angle\"]}} e potrebbe in seguito produrre messaggi asincroni come: {\"params\":{\"position_offset\":3.151562 ,\"errori\":0, \"dati\":[[1290.951905,-5063],[1290.952321,-5065]]}} Il campo \"intestazione\" nella risposta alla query iniziale viene utilizzato per descrivere i campi trovati nelle risposte \"dati\" successive. hx71x/dump_hx71x \u00b6 This endpoint is used to subscribe to raw HX711 and HX717 ADC data. Obtaining these low-level ADC updates may be useful for diagnostic and debugging purposes. Using this endpoint may increase Klipper's system load. A request may look like: {\"id\": 123, \"method\":\"hx71x/dump_hx71x\", \"params\": {\"sensor\": \"load_cell\", \"response_template\": {}}} and might return: {\"id\": 123,\"result\":{\"header\":[\"time\",\"counts\",\"value\"]}} and might later produce asynchronous messages such as: {\"params\":{\"data\":[[3292.432935, 562534, 0.067059278], [3292.4394937, 5625322, 0.670590639]]}} ads1220/dump_ads1220 \u00b6 This endpoint is used to subscribe to raw ADS1220 ADC data. Obtaining these low-level ADC updates may be useful for diagnostic and debugging purposes. Using this endpoint may increase Klipper's system load. A request may look like: {\"id\": 123, \"method\":\"ads1220/dump_ads1220\", \"params\": {\"sensor\": \"load_cell\", \"response_template\": {}}} and might return: {\"id\": 123,\"result\":{\"header\":[\"time\",\"counts\",\"value\"]}} and might later produce asynchronous messages such as: {\"params\":{\"data\":[[3292.432935, 562534, 0.067059278], [3292.4394937, 5625322, 0.670590639]]}} pause_resume/cancel \u00b6 Questo endpoint \u00e8 simile all'esecuzione del comando G-Code \"PRINT_CANCEL\". Ad esempio: {\"id\": 123, \"method\": \"pause_resume/cancel\"} Come con l'endpoint \"gcode/script\", questo endpoint viene completato solo dopo il completamento di tutti i comandi G-Code in sospeso. pause_resume/pause \u00b6 Questo endpoint \u00e8 simile all'esecuzione del comando G-Code \"PAUSE\". Ad esempio: {\"id\": 123, \"method\": \"pause_resume/pause\"} Come con l'endpoint \"gcode/script\", questo endpoint viene completato solo dopo il completamento di tutti i comandi G-Code in sospeso. pause_resume/resume \u00b6 Questo endpoint \u00e8 simile all'esecuzione del comando G-Code \"RESUME\". Ad esempio: {\"id\": 123, \"method\": \"pause_resume/resume\"} Come con l'endpoint \"gcode/script\", questo endpoint viene completato solo dopo il completamento di tutti i comandi G-Code in sospeso. query_endstops/status \u00b6 Questo endpoint eseguir\u00e0 una query sugli endpoint attivi e restituir\u00e0 il loro stato. Ad esempio: {\"id\": 123, \"method\": \"query_endstops/status\"} potrebbe restituire: {\"id\": 123, \"result\": {\"y\": \"open\", \"x\": \"aperto\", \"z\": \"TRIGGERED\"}} Come con l'endpoint \"gcode/script\", questo endpoint viene completato solo dopo il completamento di tutti i comandi G-Code in sospeso. bed_mesh/dump_mesh \u00b6 Dumps the configuration and state for the current mesh and all saved profiles. For example: {\"id\": 123, \"method\": \"bed_mesh/dump_mesh\"} might return: { \"current_mesh\": { \"name\": \"eddy-scan-test\", \"probed_matrix\": [...], \"mesh_matrix\": [...], \"mesh_params\": { \"x_count\": 9, \"y_count\": 9, \"mesh_x_pps\": 2, \"mesh_y_pps\": 2, \"algo\": \"bicubic\", \"tension\": 0.5, \"min_x\": 20, \"max_x\": 330, \"min_y\": 30, \"max_y\": 320 } }, \"profiles\": { \"default\": { \"points\": [...], \"mesh_params\": { \"min_x\": 20, \"max_x\": 330, \"min_y\": 30, \"max_y\": 320, \"x_count\": 9, \"y_count\": 9, \"mesh_x_pps\": 2, \"mesh_y_pps\": 2, \"algo\": \"bicubic\", \"tension\": 0.5 } }, \"eddy-scan-test\": { \"points\": [...], \"mesh_params\": { \"x_count\": 9, \"y_count\": 9, \"mesh_x_pps\": 2, \"mesh_y_pps\": 2, \"algo\": \"bicubic\", \"tension\": 0.5, \"min_x\": 20, \"max_x\": 330, \"min_y\": 30, \"max_y\": 320 } }, \"eddy-rapid-test\": { \"points\": [...], \"mesh_params\": { \"x_count\": 9, \"y_count\": 9, \"mesh_x_pps\": 2, \"mesh_y_pps\": 2, \"algo\": \"bicubic\", \"tension\": 0.5, \"min_x\": 20, \"max_x\": 330, \"min_y\": 30, \"max_y\": 320 } } }, \"calibration\": { \"points\": [...], \"config\": { \"x_count\": 9, \"y_count\": 9, \"mesh_x_pps\": 2, \"mesh_y_pps\": 2, \"algo\": \"bicubic\", \"tension\": 0.5, \"mesh_min\": [ 20, 30 ], \"mesh_max\": [ 330, 320 ], \"origin\": null, \"radius\": null }, \"probe_path\": [...], \"rapid_path\": [...] }, \"probe_offsets\": [ 0, 25, 0.5 ], \"axis_minimum\": [ 0, 0, -5, 0 ], \"axis_maximum\": [ 351, 358, 330, 0 ] } The dump_mesh endpoint takes one optional parameter, mesh_args . This parameter must be an object, where the keys and values are parameters available to BED_MESH_CALIBRATE . This will update the mesh configuration and probe points using the supplied parameters prior to returning the result. It is recommended to omit mesh parameters unless it is desired to visualize the probe points and/or travel path before performing BED_MESH_CALIBRATE .","title":"Server API"},{"location":"API_Server.html#server-api","text":"Questo documento descrive l'Application Programmer Interface (API) di Klipper. Questa interfaccia consente alle applicazioni esterne di interrogare e controllare il software host Klipper.","title":"Server API"},{"location":"API_Server.html#abilitazione-del-socket-api","text":"Per utilizzare il server API, il software host klippy.py deve essere avviato con il parametro -a . Per esempio: ~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer.cfg -a /tmp/klippy_uds -l /tmp/klippy.log Ci\u00f2 fa s\u00ec che il software host crei un socket di dominio Unix. Un client pu\u00f2 quindi aprire una connessione su quel socket e inviare comandi a Klipper. Consulta il progetto Moonraker per uno strumento popolare in grado di inoltrare richieste HTTP all'API Server Unix Domain Socket di Klipper.","title":"Abilitazione del socket API"},{"location":"API_Server.html#formato-richiesta","text":"I messaggi inviati e ricevuti sul socket sono stringhe codificate JSON terminate da un carattere ASCII 0x03: <json_object_1><0x03><json_object_2><0x03>... Klipper contiene uno strumento scripts/whconsole.py che pu\u00f2 eseguire il framing dei messaggi sopra. Per esempio: ~/klipper/scripts/whconsole.py /tmp/klippy_uds Questo strumento pu\u00f2 leggere una serie di comandi JSON da stdin, inviarli a Klipper e riportare i risultati. Lo strumento prevede che ogni comando JSON si trovi su una singola riga e aggiunger\u00e0 automaticamente il terminatore 0x03 durante la trasmissione di una richiesta. (Il server dell'API Klipper non ha un requisito di newline.)","title":"Formato richiesta"},{"location":"API_Server.html#protocollo-api","text":"Il protocollo dei comandi utilizzato sul socket di comunicazione \u00e8 ispirato a json-rpc . Una richiesta potrebbe essere simile a: {\"id\": 123, \"method\": \"info\", \"params\": {}} e una risposta potrebbe essere simile a: {\"id\": 123, \"result\": {\"state_message\": \"Printer is ready\", \"klipper_path\": \"/home/pi/klipper\", \"config_file\": \"/home/pi/printer.cfg\", \"software_version\": \"v0.8.0-823-g883b1cb6\", \"hostname\": \"octopi\", \"cpu_info\": \"4 core ARMv7 Processor rev 4 (v7l)\", \"state\": \"ready\", \"python_path\": \"/home/pi/klippy-env/bin/python\", \"log_file\": \"/tmp/klippy.log\"}} Ogni richiesta deve essere un dizionario JSON. (Questo documento usa il termine Python \"dizionario\" per descrivere un \"oggetto JSON\" - una mappatura di coppie chiave/valore contenute in {} .) Il dizionario di richiesta deve contenere un parametro \"method\" che \u00e8 il nome stringa di un \"endpoint\" di Klipper disponibile. Il dizionario della richiesta pu\u00f2 contenere un parametro \"params\" che deve essere di tipo dizionario. I \"parametri\" forniscono ulteriori informazioni sui parametri all'\"endpoint\" di Klipper che gestisce la richiesta. Il suo contenuto \u00e8 specifico dell'\"endpoint\". Il dizionario delle richieste pu\u00f2 contenere un parametro \"id\" che pu\u00f2 essere di qualsiasi tipo JSON. Se \u00e8 presente \"id\", Klipper risponder\u00e0 alla richiesta con un messaggio di risposta contenente tale \"id\". Se \"id\" viene omesso (o impostato su un valore JSON \"null\"), Klipper non fornir\u00e0 alcuna risposta alla richiesta. Un messaggio di risposta \u00e8 un dizionario JSON contenente \"id\" e \"result\". Il \"risultato\" \u00e8 sempre un dizionario: i suoi contenuti sono specifici dell'\"endpoint\" che gestisce la richiesta. Se l'elaborazione di una richiesta genera un errore, il messaggio di risposta conterr\u00e0 un campo \"errore\" anzich\u00e9 un campo \"risultato\". Ad esempio, la richiesta: {\"id\": 123, \"method\": \"gcode/script\", \"params\": {\"script\": \"G1 X200\"}} potrebbe generare una risposta di errore come: {\"id\": 123, \"error\": {\"message\": \"Deve prima posizionare l'asse: 200.000 0.000 0.000 [0.000]\", \"error\": \"WebRequestError\"}} Klipper inizier\u00e0 sempre a elaborare le richieste nell'ordine in cui sono state ricevute. Tuttavia, alcune richieste potrebbero non essere completate immediatamente, il che potrebbe causare l'invio di una risposta associata non conforme rispetto alle risposte di altre richieste. Una richiesta JSON non sospender\u00e0 mai l'elaborazione di future richieste JSON.","title":"Protocollo API"},{"location":"API_Server.html#sottoscrizioni","text":"Alcune richieste di \"endpoint\" di Klipper consentono di \"iscriversi\" a futuri messaggi di aggiornamento asincrono. Per esempio: {\"id\": 123, \"method\": \"gcode/subscribe_output\", \"params\": {\"response_template\":{\"key\": 345}}} inizialmente pu\u00f2 rispondere con: {\"id\": 123, \"result\": {}} e fare in modo che Klipper invii messaggi futuri simili a: {\"params\": {\"response\": \"ok B:22.8 /0.0 T0:22.4 /0.0\"}, \"key\": 345} Una richiesta di sottoscrizione accetta un dizionario \"response_template\" nel campo \"params\" della richiesta. Quel dizionario \"response_template\" viene utilizzato come modello per futuri messaggi asincroni: pu\u00f2 contenere coppie chiave/valore arbitrarie. Quando invier\u00e0 questi futuri messaggi asincroni, Klipper aggiunger\u00e0 un campo \"params\" contenente un dizionario con contenuti specifici per \"endpoint\" al modello di risposta e quindi invier\u00e0 quel modello. Se non viene fornito un campo \"response_template\", il valore predefinito \u00e8 un dizionario vuoto ( {} ).","title":"Sottoscrizioni"},{"location":"API_Server.html#endpoint-disponibili","text":"Per convenzione, gli \"endpoint\" di Klipper sono nella forma <module_name>/<some_name> . Quando si effettua una richiesta a un \"endpoint\", il nome completo deve essere impostato nel parametro \"method\" del dizionario di richiesta (ad esempio, {\"method\"=\"gcode/restart\"} ).","title":"\"endpoint\" disponibili"},{"location":"API_Server.html#info","text":"L'endpoint \"info\" viene utilizzato per ottenere informazioni sul sistema e sulla versione da Klipper. Viene anche utilizzato per fornire a Klipper le informazioni sulla versione del client. Ad esempio: {\"id\": 123, \"method\": \"info\", \"params\": { \"client_info\": { \"version\": \"v1\"}}} Se presente, il parametro \"client_info\" deve essere un dizionario, ma quel dizionario potrebbe avere contenuti arbitrari. I clienti sono incoraggiati a fornire il nome del client e la sua versione del software quando si connettono per la prima volta al server dell'API Klipper.","title":"info"},{"location":"API_Server.html#emergency_stop","text":"L'endpoint \"emergency_stop\" viene utilizzato per indicare a Klipper di passare allo stato di \"spegnimento\". Si comporta in modo simile al comando G-Code M112 . Ad esempio: {\"id\": 123, \"method\": \"emergency_stop\"}","title":"emergency_stop"},{"location":"API_Server.html#register_remote_method","text":"Questo endpoint consente ai client di registrare metodi che possono essere chiamati da klipper. Restituir\u00e0 un oggetto vuoto in caso di successo. Per esempio: {\"id\": 123, \"method\": \"register_remote_method\", \"params\": {\"response_template\": {\"action\": \"run_paneldue_beep\"}, \"remote_method\": \"paneldue_beep\"}} will return: {\"id\": 123, \"result\": {}} Il metodo remoto paneldue_beep ora pu\u00f2 essere chiamato da Klipper. Nota che se il metodo accetta parametri, dovrebbero essere forniti come argomenti di parole chiave. Di seguito \u00e8 riportato un esempio di come pu\u00f2 essere chiamato da una gcode_macro: [gcode_macro PANELDUE_BEEP] gcode: {action_call_remote_method(\"paneldue_beep\", frequency=300, duration=1.0)} Quando viene eseguita la macro gcode PANELDUE_BEEP, Klipper invia qualcosa di simile al seguente tramite il socket: {\"action\": \"run_paneldue_beep\", \"params\": {\"frequency\": 300, \"duration\": 1.0}}","title":"register_remote_method"},{"location":"API_Server.html#oggettielenco","text":"Questo endpoint interroga l'elenco degli \"oggetti\" della stampante disponibili che \u00e8 possibile interrogare (tramite l'endpoint \"objects/query\"). Ad esempio: {\"id\": 123, \"method\": \"objects/list\"} potrebbe restituire: {\"id\": 123, \"result\": {\"objects\": [\"webhooks\", \"configfile\" , \"heaters\", \"gcode_move\", \"query_endstops\", \"idle_timeout\", \"toolhead\", \"extruder\"]}}","title":"oggetti/elenco"},{"location":"API_Server.html#oggettiinterrogazione","text":"Questo endpoint consente di interrogare informazioni da oggetti. Ad esempio: {\"id\": 123, \"method\": \"objects/query\", \"params\": {\"objects\": {\"toolhead\": [\"position\"], \"webhooks\": null}}} potrebbe restituire: {\"id\": 123, \"result\": {\"status\": {\"webhooks\": {\"state\": \"ready\", \"state_message\": \"Printer is ready\"}, \"toolhead\": { \"position\": [0.0, 0.0, 0.0, 0.0]}}, \"eventtime\": 3051555.377933684}} Il parametro \"objects\" nella richiesta deve essere un dizionario contenente gli oggetti stampante che devono essere interrogati - la chiave contiene il nome dell'oggetto stampante e il valore \u00e8 \"null\" (per interrogare tutti i campi) o un elenco di nomi di campo. Il messaggio di risposta conterr\u00e0 un campo \"status\" contenente un dizionario con le informazioni richieste: la chiave contiene il nome dell'oggetto stampante e il valore \u00e8 un dizionario contenente i suoi campi. Il messaggio di risposta conterr\u00e0 anche un campo \"eventtime\" contenente il timestamp da quando \u00e8 stata eseguita la query. I campi disponibili sono documentati nel documento Status Reference .","title":"oggetti/interrogazione"},{"location":"API_Server.html#oggettisubscribe","text":"Questo endpoint consente di eseguire query e quindi iscriversi alle informazioni dagli oggetti stampante. La richiesta e la risposta dell'endpoint sono identiche all'endpoint \"objects/query\". Ad esempio: {\"id\": 123, \"method\": \"objects/subscribe\", \"params\": {\"objects\":{\"toolhead\": [\"position\"], \"webhooks\": [\"state\"] }, \"response_template\":{}}} potrebbe restituire: {\"id\": 123, \"result\": {\"status\": {\"webhooks\": {\"state\": \"ready\"}, \"toolhead\": {\"position\": [0.0, 0.0, 0.0, 0.0]}}, \"eventtime\": 3052153.382083195}} e generare messaggi asincroni successivi come: {\"params\": {\"status\": {\"webhooks\": {\"state\": \"shutdown\"}}, \"eventtime\": 3052165.418815847}}","title":"oggetti/subscribe"},{"location":"API_Server.html#gcodehelp","text":"Questo endpoint consente di interrogare i comandi G-Code disponibili che hanno una stringa di aiuto definita. Ad esempio: {\"id\": 123, \"method\": \"gcode/help\"} potrebbe restituire: {\"id\": 123, \"result\": {\"RESTORE_GCODE_STATE\": \"Restore a previously saved G-Code state\", \"PID_CALIBRATE\": \"Run PID calibration test\", \"QUERY_ADC\": \"Report the last value of an analog pin\", ...}}","title":"gcode/help"},{"location":"API_Server.html#gcodescript","text":"Questo endpoint consente di eseguire una serie di comandi G-Code. Ad esempio: {\"id\": 123, \"method\": \"gcode/script\", \"params\": {\"script\": \"G90\"}} Se lo script G-Code fornito genera un errore, allora viene generata una risposta di errore. Tuttavia, se il comando G-Code produce un output del terminale, tale output del terminale non viene fornito nella risposta. (Utilizzare l'endpoint \"gcode/subscribe_output\" per ottenere l'output del terminale G-Code.) Se c'\u00e8 un comando G-Code in elaborazione quando viene ricevuta questa richiesta, lo script fornito verr\u00e0 messo in coda. Questo ritardo potrebbe essere significativo (ad esempio, se \u00e8 in esecuzione un comando di attesa del codice G per la temperatura). Il messaggio di risposta JSON viene inviato al completamento dell'elaborazione dello script.","title":"gcode/script"},{"location":"API_Server.html#gcoderestart","text":"Questo endpoint consente di richiedere un riavvio: \u00e8 simile all'esecuzione del comando \"RESTART\" del codice G. Ad esempio: {\"id\": 123, \"method\": \"gcode/restart\"} Come con l'endpoint \"gcode/script\", questo endpoint viene completato solo dopo il completamento di tutti i comandi G-Code in sospeso.","title":"gcode/restart"},{"location":"API_Server.html#gcodefirmware_restart","text":"Questo \u00e8 simile all'endpoint \"gcode/restart\": implementa il comando G-Code \"FIRMWARE_RESTART\". Ad esempio: {\"id\": 123, \"method\": \"gcode/firmware_restart\"} Come con l'endpoint \"gcode/script\", questo endpoint viene completato solo dopo il completamento di tutti i comandi G-Code in sospeso.","title":"gcode/firmware_restart"},{"location":"API_Server.html#gcodesubscribe_output","text":"Questo endpoint viene utilizzato per iscriversi ai messaggi del terminale G-Code generati da Klipper. Ad esempio: {\"id\": 123, \"method\": \"gcode/subscribe_output\", \"params\": {\"response_template\":{}}} potrebbe in seguito produrre messaggi asincroni come: {\"params\": { \"response\": \"// Klipper state: Shutdown\"}} Questo endpoint ha lo scopo di supportare l'interazione umana tramite un'interfaccia \"finestra di terminale\". L'analisi del contenuto dall'output del terminale G-Code \u00e8 sconsigliata. Usa l'endpoint \"objects/subscribe\" per ottenere aggiornamenti sullo stato di Klipper.","title":"gcode/subscribe_output"},{"location":"API_Server.html#motion_reportdump_stepper","text":"Questo endpoint viene utilizzato per iscriversi al flusso di comandi queue_step interno di Klipper per uno stepper. L'ottenimento di questi aggiornamenti di movimento di basso livello pu\u00f2 essere utile per scopi diagnostici e di debug. L'utilizzo di questo endpoint pu\u00f2 aumentare il carico di sistema di Klipper. Una richiesta pu\u00f2 essere simile a: {\"id\": 123, \"method\":\"motion_report/dump_stepper\", \"params\": {\"name\": \"stepper_x\", \"response_template\": {}}} e potrebbe restituire: {\"id\": 123, \"result\": {\"header\": [\"interval\", \"count\", \"add\"]}} e potrebbe in seguito produrre messaggi asincroni come: {\"params\": {\" first_clock\": 179601081, \"first_time\": 8.98, \"first_position\": 0, \"last_clock\": 219686097, \"last_time\": 10.984, \"data\": [[179601081, 1, 0], [29573, 2, -8685] , [16230, 4, -1525], [10559, 6, -160], [10000, 976, 0], [10000, 1000, 0], [10000, 1000, 0], [10000, 1000, 0] , [9855, 5, 187], [11632, 4, 1534], [20756, 2, 9442]]}} Il campo \"intestazione\" nella risposta alla query iniziale viene utilizzato per descrivere i campi trovati nelle risposte \"dati\" successive.","title":"motion_report/dump_stepper"},{"location":"API_Server.html#motion_reportdump_trapq","text":"Questo endpoint viene utilizzato per iscriversi alla \"coda di movimento trapezoidale\" interna di Klipper. L'ottenimento di questi aggiornamenti di movimento di basso livello pu\u00f2 essere utile per scopi diagnostici e di debug. L'utilizzo di questo endpoint pu\u00f2 aumentare il carico di sistema di Klipper. Una richiesta pu\u00f2 essere simile a: {\"id\": 123, \"method\": \"motion_report/dump_trapq\", \"params\": {\"name\": \"toolhead\", \"response_template\":{}}} e potrebbe restituire: {\"id\": 1, \"result\": {\"header\": [\"time\", \"duration\", \"start_velocity\", \"acceleration\", \"start_position\", \"direction\"]}} e potrebbero in seguito produrre messaggi asincroni quali: {\"params\": {\"data\": [[4.05, 1.0, 0.0, 0.0, [300.0, 0.0, 0.0], [0.0, 0.0, 0.0]], [5.054, 0.001, 0.0, 3000.0 , [300.0, 0.0, 0.0], [-1.0, 0.0, 0.0]]]}} Il campo \"intestazione\" nella risposta alla query iniziale viene utilizzato per descrivere i campi trovati nelle risposte \"dati\" successive.","title":"motion_report/dump_trapq"},{"location":"API_Server.html#adxl345dump_adxl345","text":"Questo endpoint viene utilizzato per la sottoscrizione ai dati dell'accelerometro ADXL345. L'ottenimento di questi aggiornamenti di movimento di basso livello pu\u00f2 essere utile per scopi diagnostici e di debug. L'utilizzo di questo endpoint pu\u00f2 aumentare il carico di sistema di Klipper. Una richiesta pu\u00f2 essere simile a: {\"id\": 123, \"method\":\"adxl345/dump_adxl345\", \"params\": {\"sensor\": \"adxl345\", \"response_template\": {}}} e potrebbe restituire: {\"id\": 123,\"result\":{\"header\":[\"time\",\"x_acceleration\",\"y_acceleration\", \"z_acceleration\"]}} e potrebbe in seguito produrre messaggi asincroni come: {\"params \":{\"overflow\":0,\"data\":[[3292.432935,-535.44309,-1529.8374,9561.4], [3292.433256,-382.45935,-1606.32927,9561.48375]]}} Il campo \"intestazione\" nella risposta alla query iniziale viene utilizzato per descrivere i campi trovati nelle risposte \"dati\" successive.","title":"adxl345/dump_adxl345"},{"location":"API_Server.html#angledump_angle","text":"Questo endpoint viene utilizzato per iscriversi a dati del sensore angolare . L'ottenimento di questi aggiornamenti di movimento di basso livello pu\u00f2 essere utile per scopi diagnostici e di debug. L'utilizzo di questo endpoint pu\u00f2 aumentare il carico di sistema di Klipper. Una richiesta pu\u00f2 essere simile a: {\"id\": 123, \"method\":\"angle/dump_angle\", \"params\": {\"sensor\": \"my_angle_sensor\", \"response_template\": {}}} e potrebbe restituire: {\"id\": 123,\"result\":{\"header\":[\"time\",\"angle\"]}} e potrebbe in seguito produrre messaggi asincroni come: {\"params\":{\"position_offset\":3.151562 ,\"errori\":0, \"dati\":[[1290.951905,-5063],[1290.952321,-5065]]}} Il campo \"intestazione\" nella risposta alla query iniziale viene utilizzato per descrivere i campi trovati nelle risposte \"dati\" successive.","title":"angle/dump_angle"},{"location":"API_Server.html#hx71xdump_hx71x","text":"This endpoint is used to subscribe to raw HX711 and HX717 ADC data. Obtaining these low-level ADC updates may be useful for diagnostic and debugging purposes. Using this endpoint may increase Klipper's system load. A request may look like: {\"id\": 123, \"method\":\"hx71x/dump_hx71x\", \"params\": {\"sensor\": \"load_cell\", \"response_template\": {}}} and might return: {\"id\": 123,\"result\":{\"header\":[\"time\",\"counts\",\"value\"]}} and might later produce asynchronous messages such as: {\"params\":{\"data\":[[3292.432935, 562534, 0.067059278], [3292.4394937, 5625322, 0.670590639]]}}","title":"hx71x/dump_hx71x"},{"location":"API_Server.html#ads1220dump_ads1220","text":"This endpoint is used to subscribe to raw ADS1220 ADC data. Obtaining these low-level ADC updates may be useful for diagnostic and debugging purposes. Using this endpoint may increase Klipper's system load. A request may look like: {\"id\": 123, \"method\":\"ads1220/dump_ads1220\", \"params\": {\"sensor\": \"load_cell\", \"response_template\": {}}} and might return: {\"id\": 123,\"result\":{\"header\":[\"time\",\"counts\",\"value\"]}} and might later produce asynchronous messages such as: {\"params\":{\"data\":[[3292.432935, 562534, 0.067059278], [3292.4394937, 5625322, 0.670590639]]}}","title":"ads1220/dump_ads1220"},{"location":"API_Server.html#pause_resumecancel","text":"Questo endpoint \u00e8 simile all'esecuzione del comando G-Code \"PRINT_CANCEL\". Ad esempio: {\"id\": 123, \"method\": \"pause_resume/cancel\"} Come con l'endpoint \"gcode/script\", questo endpoint viene completato solo dopo il completamento di tutti i comandi G-Code in sospeso.","title":"pause_resume/cancel"},{"location":"API_Server.html#pause_resumepause","text":"Questo endpoint \u00e8 simile all'esecuzione del comando G-Code \"PAUSE\". Ad esempio: {\"id\": 123, \"method\": \"pause_resume/pause\"} Come con l'endpoint \"gcode/script\", questo endpoint viene completato solo dopo il completamento di tutti i comandi G-Code in sospeso.","title":"pause_resume/pause"},{"location":"API_Server.html#pause_resumeresume","text":"Questo endpoint \u00e8 simile all'esecuzione del comando G-Code \"RESUME\". Ad esempio: {\"id\": 123, \"method\": \"pause_resume/resume\"} Come con l'endpoint \"gcode/script\", questo endpoint viene completato solo dopo il completamento di tutti i comandi G-Code in sospeso.","title":"pause_resume/resume"},{"location":"API_Server.html#query_endstopsstatus","text":"Questo endpoint eseguir\u00e0 una query sugli endpoint attivi e restituir\u00e0 il loro stato. Ad esempio: {\"id\": 123, \"method\": \"query_endstops/status\"} potrebbe restituire: {\"id\": 123, \"result\": {\"y\": \"open\", \"x\": \"aperto\", \"z\": \"TRIGGERED\"}} Come con l'endpoint \"gcode/script\", questo endpoint viene completato solo dopo il completamento di tutti i comandi G-Code in sospeso.","title":"query_endstops/status"},{"location":"API_Server.html#bed_meshdump_mesh","text":"Dumps the configuration and state for the current mesh and all saved profiles. For example: {\"id\": 123, \"method\": \"bed_mesh/dump_mesh\"} might return: { \"current_mesh\": { \"name\": \"eddy-scan-test\", \"probed_matrix\": [...], \"mesh_matrix\": [...], \"mesh_params\": { \"x_count\": 9, \"y_count\": 9, \"mesh_x_pps\": 2, \"mesh_y_pps\": 2, \"algo\": \"bicubic\", \"tension\": 0.5, \"min_x\": 20, \"max_x\": 330, \"min_y\": 30, \"max_y\": 320 } }, \"profiles\": { \"default\": { \"points\": [...], \"mesh_params\": { \"min_x\": 20, \"max_x\": 330, \"min_y\": 30, \"max_y\": 320, \"x_count\": 9, \"y_count\": 9, \"mesh_x_pps\": 2, \"mesh_y_pps\": 2, \"algo\": \"bicubic\", \"tension\": 0.5 } }, \"eddy-scan-test\": { \"points\": [...], \"mesh_params\": { \"x_count\": 9, \"y_count\": 9, \"mesh_x_pps\": 2, \"mesh_y_pps\": 2, \"algo\": \"bicubic\", \"tension\": 0.5, \"min_x\": 20, \"max_x\": 330, \"min_y\": 30, \"max_y\": 320 } }, \"eddy-rapid-test\": { \"points\": [...], \"mesh_params\": { \"x_count\": 9, \"y_count\": 9, \"mesh_x_pps\": 2, \"mesh_y_pps\": 2, \"algo\": \"bicubic\", \"tension\": 0.5, \"min_x\": 20, \"max_x\": 330, \"min_y\": 30, \"max_y\": 320 } } }, \"calibration\": { \"points\": [...], \"config\": { \"x_count\": 9, \"y_count\": 9, \"mesh_x_pps\": 2, \"mesh_y_pps\": 2, \"algo\": \"bicubic\", \"tension\": 0.5, \"mesh_min\": [ 20, 30 ], \"mesh_max\": [ 330, 320 ], \"origin\": null, \"radius\": null }, \"probe_path\": [...], \"rapid_path\": [...] }, \"probe_offsets\": [ 0, 25, 0.5 ], \"axis_minimum\": [ 0, 0, -5, 0 ], \"axis_maximum\": [ 351, 358, 330, 0 ] } The dump_mesh endpoint takes one optional parameter, mesh_args . This parameter must be an object, where the keys and values are parameters available to BED_MESH_CALIBRATE . This will update the mesh configuration and probe points using the supplied parameters prior to returning the result. It is recommended to omit mesh parameters unless it is desired to visualize the probe points and/or travel path before performing BED_MESH_CALIBRATE .","title":"bed_mesh/dump_mesh"},{"location":"Axis_Twist_Compensation.html","text":"Compensazione torsione assi \u00b6 Questo documento descrive il modulo [axis_twist_compensation]. Some printers may have a small twist in their X rail which can skew the results of a probe attached to the X carriage. This is common in printers with designs like the Prusa MK3, Sovol SV06 etc and is further described under probe location bias . It may result in probe operations such as Bed Mesh , Screws Tilt Adjust , Z Tilt Adjust etc returning inaccurate representations of the bed. Questo modulo utilizza misurazioni manuali da parte dell'utente per correggere i risultati della sonda. Tieni presente che se l'asse \u00e8 notevolmente distorto, ti consigliamo vivamente di utilizzare mezzi meccanici per ripararlo prima di applicare le correzioni del software. Warning : This module is not compatible with dockable probes yet and will try to probe the bed without attaching the probe if you use it. Overview of compensation usage \u00b6 Tip: Make sure the probe X and Y offsets are correctly set as they greatly influence calibration. Basic Usage: X-Axis Calibration \u00b6 After setting up the [axis_twist_compensation] module, run: AXIS_TWIST_COMPENSATION_CALIBRATE This command will calibrate the X-axis by default. - The calibration wizard will prompt you to measure the probe Z offset at several points along the bed. - By default, the calibration uses 3 points, but you can specify a different number with the option: SAMPLE_COUNT=<value> Adjust Your Z Offset: After completing the calibration, be sure to [adjust your Z offset] (Probe_Calibrate.md#calibrating-probe-z-offset). Perform Bed Leveling Operations: Use probe-based operations as needed, such as: Screws Tilt Adjust Z Tilt Adjust Finalize the Setup: Home all axes, and perform a Bed Mesh if necessary. Run a test print, followed by any fine-tuning if needed. For Y-Axis Calibration \u00b6 The calibration process for the Y-axis is similar to the X-axis. To calibrate the Y-axis, use: AXIS_TWIST_COMPENSATION_CALIBRATE AXIS=Y This will guide you through the same measuring process as for the X-axis. Automatic Calibration for Both Axes \u00b6 To perform automatic calibration for both the X and Y axes without manual intervention, use: AXIS_TWIST_COMPENSATION_CALIBRATE AUTO=True In this mode, the calibration process will run for both axes automatically. Tip: Bed temperature and nozzle temperature and size do not seem to have an influence to the calibration process. [axis_twist_compensation] setup and commands \u00b6 Configuration options for [axis_twist_compensation] can be found in the Configuration Reference . Commands for [axis_twist_compensation] can be found in the G-Codes Reference","title":"Compensazione torsione assi"},{"location":"Axis_Twist_Compensation.html#compensazione-torsione-assi","text":"Questo documento descrive il modulo [axis_twist_compensation]. Some printers may have a small twist in their X rail which can skew the results of a probe attached to the X carriage. This is common in printers with designs like the Prusa MK3, Sovol SV06 etc and is further described under probe location bias . It may result in probe operations such as Bed Mesh , Screws Tilt Adjust , Z Tilt Adjust etc returning inaccurate representations of the bed. Questo modulo utilizza misurazioni manuali da parte dell'utente per correggere i risultati della sonda. Tieni presente che se l'asse \u00e8 notevolmente distorto, ti consigliamo vivamente di utilizzare mezzi meccanici per ripararlo prima di applicare le correzioni del software. Warning : This module is not compatible with dockable probes yet and will try to probe the bed without attaching the probe if you use it.","title":"Compensazione torsione assi"},{"location":"Axis_Twist_Compensation.html#overview-of-compensation-usage","text":"Tip: Make sure the probe X and Y offsets are correctly set as they greatly influence calibration.","title":"Overview of compensation usage"},{"location":"Axis_Twist_Compensation.html#basic-usage-x-axis-calibration","text":"After setting up the [axis_twist_compensation] module, run: AXIS_TWIST_COMPENSATION_CALIBRATE This command will calibrate the X-axis by default. - The calibration wizard will prompt you to measure the probe Z offset at several points along the bed. - By default, the calibration uses 3 points, but you can specify a different number with the option: SAMPLE_COUNT=<value> Adjust Your Z Offset: After completing the calibration, be sure to [adjust your Z offset] (Probe_Calibrate.md#calibrating-probe-z-offset). Perform Bed Leveling Operations: Use probe-based operations as needed, such as: Screws Tilt Adjust Z Tilt Adjust Finalize the Setup: Home all axes, and perform a Bed Mesh if necessary. Run a test print, followed by any fine-tuning if needed.","title":"Basic Usage: X-Axis Calibration"},{"location":"Axis_Twist_Compensation.html#for-y-axis-calibration","text":"The calibration process for the Y-axis is similar to the X-axis. To calibrate the Y-axis, use: AXIS_TWIST_COMPENSATION_CALIBRATE AXIS=Y This will guide you through the same measuring process as for the X-axis.","title":"For Y-Axis Calibration"},{"location":"Axis_Twist_Compensation.html#automatic-calibration-for-both-axes","text":"To perform automatic calibration for both the X and Y axes without manual intervention, use: AXIS_TWIST_COMPENSATION_CALIBRATE AUTO=True In this mode, the calibration process will run for both axes automatically. Tip: Bed temperature and nozzle temperature and size do not seem to have an influence to the calibration process.","title":"Automatic Calibration for Both Axes"},{"location":"Axis_Twist_Compensation.html#axis_twist_compensation-setup-and-commands","text":"Configuration options for [axis_twist_compensation] can be found in the Configuration Reference . Commands for [axis_twist_compensation] can be found in the G-Codes Reference","title":"[axis_twist_compensation] setup and commands"},{"location":"BLTouch.html","text":"BL-Touch \u00b6 Collegare BL-Touch \u00b6 Attenzione warning prima di cominciare : Evita di toccare la punta del BL-Touch a mani nude, \u00e8 molto sensibili al sebo delle dita. Se sei costretto usa dei guanti ed evita di spingerla o piegarla. Collega il connettore \"servo\" BL-Touch a un control_pin secondo la documentazione BL-Touch o la documentazione MCU. Usando il cablaggio originale, il filo giallo del triplo \u00e8 il control_pin e il filo bianco della coppia \u00e8 il sensor_pin . \u00c8 necessario configurare questi pin in base al cablaggio. La maggior parte dei dispositivi BL-Touch richiede un pullup sul pin del sensore (prefissare il nome del pin con \"^\"). Per esempio: [bltouch] sensor_pin: ^P1.24 control_pin: P1.26 Se il BL-Touch verr\u00e0 utilizzato per l'home dell'asse Z, impostare endstop_pin: probe:z_virtual_endstop e rimuovere position_endstop nella sezione di configurazione [stepper_z] , quindi aggiungere una sezione di configurazione [safe_z_home] per aumentare il asse z, posiziona gli assi xy, spostati al centro del letto e posizionati sull'asse z. Per esempio: [safe_z_home] home_xy_position: 100, 100 # Cambiare le coordinate per il centro del tuo piatto speed: 50 z_hop: 10 # Move up 10mm z_hop_speed: 5 \u00c8 importante che il movimento z_hop in safe_z_home sia sufficientemente alto in mode che la sonda non colpisca nulla anche se il pin della sonda si trova nel suo stato pi\u00f9 basso. Test iniziali \u00b6 Prima di proseguire, verificare che il BL-Touch sia montato all'altezza corretta, il perno dovrebbe trovarsi a circa 2 mm sopra il nozzle quando \u00e8 retratto Quando si accende la stampante, la sonda BL-Touch dovrebbe eseguire un autotest e spostare il pin su e gi\u00f9 un paio di volte. Una volta completato l'autotest, il perno deve essere retratto e il LED rosso sulla sonda deve essere acceso. In caso di errori, ad esempio la sonda lampeggia in rosso o il pin \u00e8 in basso anzich\u00e9 in alto, spegnere la stampante e controllare il cablaggio e la configurazione. Se quanto sopra sembra buono, \u00e8 il momento di verificare che il pin di controllo funzioni correttamente. Per prima cosa esegui BLTOUCH_DEBUG COMMAND=pin_down nel terminale della tua stampante. Verificare che il pin si abbassi e che il LED rosso sulla sonda si spenga. In caso contrario, controllare nuovamente il cablaggio e la configurazione. Quindi emettere un BLTOUCH_DEBUG COMMAND=pin_up , verificare che il pin si muova verso l'alto e che la luce rossa si accenda di nuovo. Se lampeggia allora c'\u00e8 qualche problema. Il passaggio successivo \u00e8 confermare che il pin del sensore funzioni correttamente. Esegui BLTOUCH_DEBUG COMMAND=pin_down , verifica che il pin si sposti verso il basso, esegui BLTOUCH_DEBUG COMMAND=touch_mode , esegui QUERY_PROBE e verifica che il comando riporti \"probe: open\". Quindi, spingendo leggermente verso l'alto il perno con l'unghia del dito, eseguire nuovamente QUERY_PROBE . Verificare che il comando riporti \"probe: TRIGGERED\". Se una delle query non riporta il messaggio corretto, di solito indica un cablaggio o una configurazione errati (sebbene alcuni clones potrebbero richiedere una gestione speciale). Al completamento di questo test, eseguire BLTOUCH_DEBUG COMMAND=pin_up e verificare che il pin si muova verso l'alto. Dopo aver completato i test del pin di controllo BL-Touch e del pin del sensore, \u00e8 ora il momento di testare il rilevamento, ma con una svolta. Invece di lasciare che il perno della sonda tocchi il piano di stampa, lascia che tocchi l'unghia del dito. Posizionare la testina lontano dal letto, emettere un G28 (o PROBE se non si utilizza probe:z_virtual_endstop), attendere che la testina inizi a muoversi verso il basso e interrompere il movimento toccando molto delicatamente il perno con l'unghia. Potrebbe essere necessario farlo due volte, poich\u00e9 la configurazione di homing predefinita esegue due sonde. Preparati a spegnere la stampante se non si ferma quando tocchi il perno. Se ha avuto successo, esegui un altro G28 (o PROBE ) ma questa volta lascia che tocchi il letto come dovrebbe. BL-Touch andato male \u00b6 Una volta che il BL-Touch \u00e8 in uno stato incoerente, inizia a lampeggiare in rosso. Puoi forzarlo a lasciare quello stato emettendo: BLTOUCH_DEBUG COMMAND=reset Ci\u00f2 pu\u00f2 accadere se la sua calibrazione viene interrotta dal blocco dell'estrazione della sonda. Tuttavia, anche il BL-Touch potrebbe non essere pi\u00f9 in grado di calibrarsi. Ci\u00f2 accade se la vite sulla sua sommit\u00e0 \u00e8 nella posizione sbagliata o se il nucleo magnetico all'interno del perno della sonda si \u00e8 spostato. Se si \u00e8 alzato in modo che si attacchi alla vite, potrebbe non essere pi\u00f9 in grado di abbassare il perno. Con questo comportamento \u00e8 necessario aprire la vite e utilizzare una penna a sfera per spingerla delicatamente in posizione. Reinserire il perno nel BL-Touch in modo che cada nella posizione estratta. Riposizionare con cura la vite senza testa in posizione. \u00c8 necessario trovare la posizione giusta in modo che sia in grado di abbassare e alzare il perno e la luce rossa si accende e si spegne. Usa i comandi reset , pin_up e pin_down per raggiungere questo obiettivo. BL-Touch \"cloni\" \u00b6 Molti dispositivi \"clone\" BL-Touch funzionano correttamente con Klipper utilizzando la configurazione predefinita. Tuttavia, alcuni dispositivi \"clone\" potrebbero non supportare il comando QUERY_PROBE e alcuni dispositivi \"clone\" potrebbero richiedere la configurazione di pin_up_reports_not_triggered o pin_up_touch_mode_reports_triggered . Importante! Non configurare pin_up_reports_not_triggered o pin_up_touch_mode_reports_triggered su False senza prima seguire queste indicazioni. Non configurare nessuno di questi su False su un BL-Touch originale. Un'impostazione errata di questi valori su False pu\u00f2 aumentare il tempo di ispezione e pu\u00f2 aumentare il rischio di danneggiare la stampante. Alcuni dispositivi \"clone\" non supportano touch_mode e di conseguenza il comando QUERY_PROBE non funziona. Nonostante ci\u00f2, potrebbe essere ancora possibile eseguire il rilevamento e l'homing con questi dispositivi. Su questi dispositivi il comando QUERY_PROBE durante i initial tests non avr\u00e0 esito positivo, tuttavia il successivo test G28 (o PROBE ) riesce. Potrebbe essere possibile utilizzare questi dispositivi \"clone\" con Klipper se non si utilizza il comando QUERY_PROBE e se non si abilita la funzione probe_with_touch_mode . Alcuni dispositivi \"clone\" non sono in grado di eseguire il test di verifica del sensore interno di Klipper. Su questi dispositivi, i tentativi di home o probe possono far s\u00ec che Klipper riporti un errore \"BLTouch non \u00e8 riuscito a verificare lo stato del sensore\". In tal caso, eseguire manualmente i passaggi per verificare che il pin del sensore funzioni come descritto nella initial tests section . Se i comandi QUERY_PROBE in quel test producono sempre i risultati attesi e si verificano ancora gli errori \"BLTouch non \u00e8 riuscito a verificare lo stato del sensore\", potrebbe essere necessario impostare pin_up_touch_mode_reports_triggered su False nel file di configurazione di Klipper. Un raro numero di vecchi dispositivi \"clone\" non \u00e8 in grado di segnalare quando hanno sollevato con successo la sonda. Su questi dispositivi Klipper segnaler\u00e0 un errore \"BLTouch non \u00e8 riuscito a sollevare la sonda\" dopo ogni tentativo di home o probe. Si pu\u00f2 testare questi dispositivi: spostare la testa lontano dal letto, eseguire BLTOUCH_DEBUG COMMAND=pin_down , verificare che il pin si sia spostato verso il basso, eseguire QUERY_PROBE , verificare che il comando riporti \"probe: open\", eseguire BLTOUCH_DEBUG COMMAND= pin_up , verifica che il pin sia stato spostato in alto ed esegui QUERY_PROBE . Se il pin rimane attivo, il dispositivo non entra in uno stato di errore e la prima query riporta \"probe: open\" mentre la seconda query riporta \"probe: TRIGGERED\", quindi indica che pin_up_reports_not_triggered dovrebbe essere impostato su False in Klipper file di configurazione. BL-Touch v3 \u00b6 Alcuni dispositivi BL-Touch v3.0 e BL-Touch 3.1 potrebbero richiedere la configurazione di probe_with_touch_mode nel file di configurazione della stampante. Se il BL-Touch v3.0 ha il cavo del segnale collegato a un pin endstop (con un condensatore di filtraggio del rumore), il BL-Touch v3.0 potrebbe non essere in grado di inviare un segnale in modo coerente durante l'homing e il probe. Se i comandi QUERY_PROBE nella initial tests section producono sempre i risultati attesi, ma il toolhead non si ferma sempre durante i comandi G28/PROBE, allora \u00e8 indicativo di questo problema. Una soluzione alternativa consiste nell'impostare probe_with_touch_mode: True nel file di configurazione. Il BL-Touch v3.1 potrebbe entrare erroneamente in uno stato di errore dopo un tentativo di probe riuscito. I sintomi sono una luce lampeggiante occasionale sul BL-Touch v3.1 che dura per un paio di secondi dopo che \u00e8 entrato in contatto con successo con il letto. Klipper dovrebbe cancellare questo errore automaticamente ed \u00e8 generalmente innocuo. Tuttavia, \u00e8 possibile impostare probe_with_touch_mode nel file di configurazione per evitare questo problema. Importante! Alcuni dispositivi \"clone\" e BL-Touch v2.0 (e precedenti) potrebbero avere una precisione ridotta quando probe_with_touch_mode \u00e8 impostato su True. L'impostazione su True aumenta anche il tempo necessario per distribuire la sonda. Se si configura questo valore su un dispositivo BL-Touch \"clone\" o precedente, assicurarsi di testare l'accuratezza della sonda prima e dopo aver impostato questo valore (utilizzare il comando PROBE_ACCURACY per eseguire il test). Multi-sondaggio senza riporre \u00b6 Per impostazione predefinita, Klipper rilascia la sonda all'inizio di ogni tentativo di sonda e poi riporr\u00e0 la sonda in seguito. Questo dispiegamento e stivaggio ripetitivo della sonda pu\u00f2 aumentare il tempo totale delle sequenze di calibrazione che coinvolgono molte misurazioni della sonda. Klipper consente di lasciare la sonda dispiegata tra test consecutivi, il che pu\u00f2 ridurre il tempo totale di rilevamento. Questa modalit\u00e0 \u00e8 abilitata configurando stow_on_each_sample su False nel file di configurazione. Importante! L'impostazione di stow_on_each_sample su False pu\u00f2 portare Klipper a fare movimenti orizzontali della testa utensile mentre la sonda \u00e8 estesa. Assicurarsi di verificare che tutte le operazioni con la probe abbiano un gioco Z sufficiente prima di impostare questo valore su False. Se lo spazio libero \u00e8 insufficiente, uno spostamento orizzontale pu\u00f2 causare l'intrappolamento del perno in un'ostruzione e causare danni alla stampante. Importante! Si consiglia di utilizzare probe_with_touch_mode configurato su True quando si utilizza stow_on_each_sample configurato su False. Alcuni dispositivi \"clone\" potrebbero non rilevare un successivo contatto con il piatto se probe_with_touch_mode non \u00e8 impostato. Su tutti i dispositivi, l'utilizzo della combinazione di queste due impostazioni semplifica la segnalazione del dispositivo, che pu\u00f2 migliorare la stabilit\u00e0 generale. Si noti, tuttavia, che alcuni dispositivi \"clone\" e BL-Touch v2.0 (e precedenti) potrebbero avere una precisione ridotta quando probe_with_touch_mode \u00e8 impostato su True. Su questi dispositivi \u00e8 una buona idea testare l'accuratezza della sonda prima e dopo aver impostato probe_with_touch_mode (usare il comando di test PROBE_ACCURACY ). Calibrazione degli offset BL-Touch \u00b6 Seguire le istruzioni nella guida Probe Calibrate per impostare i parametri di configurazione x_offset, y_offset e z_offset. \u00c8 una buona idea verificare che l'offset Z sia vicino a 1 mm. In caso contrario, probabilmente vorrai spostare la sonda su o gi\u00f9 per risolvere il problema. Si desidera che si attivi ben prima che l'ugello colpisca il piatto, in modo che un possibile filamento bloccato o un piatto deformato non influisca sull'azione della sonda. Ma allo stesso tempo, si desidera che la posizione retratta sia il pi\u00f9 possibile al di sopra dell'ugello per evitare che tocchi le parti stampate. Se viene effettuata una regolazione della posizione della sonda, eseguire nuovamente i passaggi di calibrazione della sonda. Modalit\u00e0 di output BL-Touch \u00b6 Un BL-Touch V3.0 supporta l'impostazione di una modalit\u00e0 di uscita 5V o OPEN-DRAIN, un BL-Touch V3.1 supporta anche questo, ma pu\u00f2 anche memorizzarlo nella sua EEPROM interna. Se la tua scheda controller ha bisogno del livello logico alto 5V fisso della modalit\u00e0 5V, puoi impostare il parametro 'set_output_mode' nella sezione [bltouch] del file di configurazione della stampante su \"5V\". Utilizzare la modalit\u00e0 5V solo se la linea di ingresso della scheda controller \u00e8 tollerante a 5V. Ecco perch\u00e9 la configurazione di default di queste versioni BL-Touch \u00e8 la modalit\u00e0 OPEN-DRAIN. Potresti potenzialmente danneggiare la CPU delle tue schede di controllo Quindi: se una scheda controller HA BISOGNO della modalit\u00e0 5V ED \u00e8 tollerante a 5V sulla sua linea del segnale di ingresso E se si dispone di un BL-Touch Smart V3.0, \u00e8 necessario utilizzare il parametro 'set_output_mode: 5V' per garantire questa impostazione ad ogni avvio, poich\u00e9 la sonda non ricorda l'impostazione necessaria. hai un BL-Touch Smart V3.1, puoi scegliere di usare 'set_output_mode: 5V' o memorizzare la modalit\u00e0 una volta usando un comando 'BLTOUCH_STORE MODE=5V' manualmente e NON usando il parametro 'set_output_mode:'. hai qualche altra sonda: alcune sonde hanno una traccia sul circuito stampato da tagliare o un ponticello da impostare per impostare (permanentemente) la modalit\u00e0 di uscita. In tal caso, omettere completamente il parametro 'set_output_mode'. Se hai una V3.1, non automatizzare o ripetere la memorizzazione della modalit\u00e0 di output per evitare di consumare la EEPROM della sonda. La BLTouch EEPROM \u00e8 valida per circa 100.000 aggiornamenti. 100 memorizzazioni al giorno aggiungerebbero fino a circa 3 anni di attivit\u00e0 prima di logorarlo. Pertanto, la memorizzazione della modalit\u00e0 di output in una V3.1 \u00e8 progettata dal fornitore per essere un'operazione complicata (l'impostazione predefinita di fabbrica \u00e8 una modalit\u00e0 OPEN DRAIN sicura) e non \u00e8 adatta per essere emessa ripetutamente da qualsiasi slicer, macro o altro, esso \u00e8 preferibilmente da utilizzare solo quando si integra per la prima volta la sonda nell'elettronica di una stampante.","title":"BL-Touch"},{"location":"BLTouch.html#bl-touch","text":"","title":"BL-Touch"},{"location":"BLTouch.html#collegare-bl-touch","text":"Attenzione warning prima di cominciare : Evita di toccare la punta del BL-Touch a mani nude, \u00e8 molto sensibili al sebo delle dita. Se sei costretto usa dei guanti ed evita di spingerla o piegarla. Collega il connettore \"servo\" BL-Touch a un control_pin secondo la documentazione BL-Touch o la documentazione MCU. Usando il cablaggio originale, il filo giallo del triplo \u00e8 il control_pin e il filo bianco della coppia \u00e8 il sensor_pin . \u00c8 necessario configurare questi pin in base al cablaggio. La maggior parte dei dispositivi BL-Touch richiede un pullup sul pin del sensore (prefissare il nome del pin con \"^\"). Per esempio: [bltouch] sensor_pin: ^P1.24 control_pin: P1.26 Se il BL-Touch verr\u00e0 utilizzato per l'home dell'asse Z, impostare endstop_pin: probe:z_virtual_endstop e rimuovere position_endstop nella sezione di configurazione [stepper_z] , quindi aggiungere una sezione di configurazione [safe_z_home] per aumentare il asse z, posiziona gli assi xy, spostati al centro del letto e posizionati sull'asse z. Per esempio: [safe_z_home] home_xy_position: 100, 100 # Cambiare le coordinate per il centro del tuo piatto speed: 50 z_hop: 10 # Move up 10mm z_hop_speed: 5 \u00c8 importante che il movimento z_hop in safe_z_home sia sufficientemente alto in mode che la sonda non colpisca nulla anche se il pin della sonda si trova nel suo stato pi\u00f9 basso.","title":"Collegare BL-Touch"},{"location":"BLTouch.html#test-iniziali","text":"Prima di proseguire, verificare che il BL-Touch sia montato all'altezza corretta, il perno dovrebbe trovarsi a circa 2 mm sopra il nozzle quando \u00e8 retratto Quando si accende la stampante, la sonda BL-Touch dovrebbe eseguire un autotest e spostare il pin su e gi\u00f9 un paio di volte. Una volta completato l'autotest, il perno deve essere retratto e il LED rosso sulla sonda deve essere acceso. In caso di errori, ad esempio la sonda lampeggia in rosso o il pin \u00e8 in basso anzich\u00e9 in alto, spegnere la stampante e controllare il cablaggio e la configurazione. Se quanto sopra sembra buono, \u00e8 il momento di verificare che il pin di controllo funzioni correttamente. Per prima cosa esegui BLTOUCH_DEBUG COMMAND=pin_down nel terminale della tua stampante. Verificare che il pin si abbassi e che il LED rosso sulla sonda si spenga. In caso contrario, controllare nuovamente il cablaggio e la configurazione. Quindi emettere un BLTOUCH_DEBUG COMMAND=pin_up , verificare che il pin si muova verso l'alto e che la luce rossa si accenda di nuovo. Se lampeggia allora c'\u00e8 qualche problema. Il passaggio successivo \u00e8 confermare che il pin del sensore funzioni correttamente. Esegui BLTOUCH_DEBUG COMMAND=pin_down , verifica che il pin si sposti verso il basso, esegui BLTOUCH_DEBUG COMMAND=touch_mode , esegui QUERY_PROBE e verifica che il comando riporti \"probe: open\". Quindi, spingendo leggermente verso l'alto il perno con l'unghia del dito, eseguire nuovamente QUERY_PROBE . Verificare che il comando riporti \"probe: TRIGGERED\". Se una delle query non riporta il messaggio corretto, di solito indica un cablaggio o una configurazione errati (sebbene alcuni clones potrebbero richiedere una gestione speciale). Al completamento di questo test, eseguire BLTOUCH_DEBUG COMMAND=pin_up e verificare che il pin si muova verso l'alto. Dopo aver completato i test del pin di controllo BL-Touch e del pin del sensore, \u00e8 ora il momento di testare il rilevamento, ma con una svolta. Invece di lasciare che il perno della sonda tocchi il piano di stampa, lascia che tocchi l'unghia del dito. Posizionare la testina lontano dal letto, emettere un G28 (o PROBE se non si utilizza probe:z_virtual_endstop), attendere che la testina inizi a muoversi verso il basso e interrompere il movimento toccando molto delicatamente il perno con l'unghia. Potrebbe essere necessario farlo due volte, poich\u00e9 la configurazione di homing predefinita esegue due sonde. Preparati a spegnere la stampante se non si ferma quando tocchi il perno. Se ha avuto successo, esegui un altro G28 (o PROBE ) ma questa volta lascia che tocchi il letto come dovrebbe.","title":"Test iniziali"},{"location":"BLTouch.html#bl-touch-andato-male","text":"Una volta che il BL-Touch \u00e8 in uno stato incoerente, inizia a lampeggiare in rosso. Puoi forzarlo a lasciare quello stato emettendo: BLTOUCH_DEBUG COMMAND=reset Ci\u00f2 pu\u00f2 accadere se la sua calibrazione viene interrotta dal blocco dell'estrazione della sonda. Tuttavia, anche il BL-Touch potrebbe non essere pi\u00f9 in grado di calibrarsi. Ci\u00f2 accade se la vite sulla sua sommit\u00e0 \u00e8 nella posizione sbagliata o se il nucleo magnetico all'interno del perno della sonda si \u00e8 spostato. Se si \u00e8 alzato in modo che si attacchi alla vite, potrebbe non essere pi\u00f9 in grado di abbassare il perno. Con questo comportamento \u00e8 necessario aprire la vite e utilizzare una penna a sfera per spingerla delicatamente in posizione. Reinserire il perno nel BL-Touch in modo che cada nella posizione estratta. Riposizionare con cura la vite senza testa in posizione. \u00c8 necessario trovare la posizione giusta in modo che sia in grado di abbassare e alzare il perno e la luce rossa si accende e si spegne. Usa i comandi reset , pin_up e pin_down per raggiungere questo obiettivo.","title":"BL-Touch andato male"},{"location":"BLTouch.html#bl-touch-cloni","text":"Molti dispositivi \"clone\" BL-Touch funzionano correttamente con Klipper utilizzando la configurazione predefinita. Tuttavia, alcuni dispositivi \"clone\" potrebbero non supportare il comando QUERY_PROBE e alcuni dispositivi \"clone\" potrebbero richiedere la configurazione di pin_up_reports_not_triggered o pin_up_touch_mode_reports_triggered . Importante! Non configurare pin_up_reports_not_triggered o pin_up_touch_mode_reports_triggered su False senza prima seguire queste indicazioni. Non configurare nessuno di questi su False su un BL-Touch originale. Un'impostazione errata di questi valori su False pu\u00f2 aumentare il tempo di ispezione e pu\u00f2 aumentare il rischio di danneggiare la stampante. Alcuni dispositivi \"clone\" non supportano touch_mode e di conseguenza il comando QUERY_PROBE non funziona. Nonostante ci\u00f2, potrebbe essere ancora possibile eseguire il rilevamento e l'homing con questi dispositivi. Su questi dispositivi il comando QUERY_PROBE durante i initial tests non avr\u00e0 esito positivo, tuttavia il successivo test G28 (o PROBE ) riesce. Potrebbe essere possibile utilizzare questi dispositivi \"clone\" con Klipper se non si utilizza il comando QUERY_PROBE e se non si abilita la funzione probe_with_touch_mode . Alcuni dispositivi \"clone\" non sono in grado di eseguire il test di verifica del sensore interno di Klipper. Su questi dispositivi, i tentativi di home o probe possono far s\u00ec che Klipper riporti un errore \"BLTouch non \u00e8 riuscito a verificare lo stato del sensore\". In tal caso, eseguire manualmente i passaggi per verificare che il pin del sensore funzioni come descritto nella initial tests section . Se i comandi QUERY_PROBE in quel test producono sempre i risultati attesi e si verificano ancora gli errori \"BLTouch non \u00e8 riuscito a verificare lo stato del sensore\", potrebbe essere necessario impostare pin_up_touch_mode_reports_triggered su False nel file di configurazione di Klipper. Un raro numero di vecchi dispositivi \"clone\" non \u00e8 in grado di segnalare quando hanno sollevato con successo la sonda. Su questi dispositivi Klipper segnaler\u00e0 un errore \"BLTouch non \u00e8 riuscito a sollevare la sonda\" dopo ogni tentativo di home o probe. Si pu\u00f2 testare questi dispositivi: spostare la testa lontano dal letto, eseguire BLTOUCH_DEBUG COMMAND=pin_down , verificare che il pin si sia spostato verso il basso, eseguire QUERY_PROBE , verificare che il comando riporti \"probe: open\", eseguire BLTOUCH_DEBUG COMMAND= pin_up , verifica che il pin sia stato spostato in alto ed esegui QUERY_PROBE . Se il pin rimane attivo, il dispositivo non entra in uno stato di errore e la prima query riporta \"probe: open\" mentre la seconda query riporta \"probe: TRIGGERED\", quindi indica che pin_up_reports_not_triggered dovrebbe essere impostato su False in Klipper file di configurazione.","title":"BL-Touch \"cloni\""},{"location":"BLTouch.html#bl-touch-v3","text":"Alcuni dispositivi BL-Touch v3.0 e BL-Touch 3.1 potrebbero richiedere la configurazione di probe_with_touch_mode nel file di configurazione della stampante. Se il BL-Touch v3.0 ha il cavo del segnale collegato a un pin endstop (con un condensatore di filtraggio del rumore), il BL-Touch v3.0 potrebbe non essere in grado di inviare un segnale in modo coerente durante l'homing e il probe. Se i comandi QUERY_PROBE nella initial tests section producono sempre i risultati attesi, ma il toolhead non si ferma sempre durante i comandi G28/PROBE, allora \u00e8 indicativo di questo problema. Una soluzione alternativa consiste nell'impostare probe_with_touch_mode: True nel file di configurazione. Il BL-Touch v3.1 potrebbe entrare erroneamente in uno stato di errore dopo un tentativo di probe riuscito. I sintomi sono una luce lampeggiante occasionale sul BL-Touch v3.1 che dura per un paio di secondi dopo che \u00e8 entrato in contatto con successo con il letto. Klipper dovrebbe cancellare questo errore automaticamente ed \u00e8 generalmente innocuo. Tuttavia, \u00e8 possibile impostare probe_with_touch_mode nel file di configurazione per evitare questo problema. Importante! Alcuni dispositivi \"clone\" e BL-Touch v2.0 (e precedenti) potrebbero avere una precisione ridotta quando probe_with_touch_mode \u00e8 impostato su True. L'impostazione su True aumenta anche il tempo necessario per distribuire la sonda. Se si configura questo valore su un dispositivo BL-Touch \"clone\" o precedente, assicurarsi di testare l'accuratezza della sonda prima e dopo aver impostato questo valore (utilizzare il comando PROBE_ACCURACY per eseguire il test).","title":"BL-Touch v3"},{"location":"BLTouch.html#multi-sondaggio-senza-riporre","text":"Per impostazione predefinita, Klipper rilascia la sonda all'inizio di ogni tentativo di sonda e poi riporr\u00e0 la sonda in seguito. Questo dispiegamento e stivaggio ripetitivo della sonda pu\u00f2 aumentare il tempo totale delle sequenze di calibrazione che coinvolgono molte misurazioni della sonda. Klipper consente di lasciare la sonda dispiegata tra test consecutivi, il che pu\u00f2 ridurre il tempo totale di rilevamento. Questa modalit\u00e0 \u00e8 abilitata configurando stow_on_each_sample su False nel file di configurazione. Importante! L'impostazione di stow_on_each_sample su False pu\u00f2 portare Klipper a fare movimenti orizzontali della testa utensile mentre la sonda \u00e8 estesa. Assicurarsi di verificare che tutte le operazioni con la probe abbiano un gioco Z sufficiente prima di impostare questo valore su False. Se lo spazio libero \u00e8 insufficiente, uno spostamento orizzontale pu\u00f2 causare l'intrappolamento del perno in un'ostruzione e causare danni alla stampante. Importante! Si consiglia di utilizzare probe_with_touch_mode configurato su True quando si utilizza stow_on_each_sample configurato su False. Alcuni dispositivi \"clone\" potrebbero non rilevare un successivo contatto con il piatto se probe_with_touch_mode non \u00e8 impostato. Su tutti i dispositivi, l'utilizzo della combinazione di queste due impostazioni semplifica la segnalazione del dispositivo, che pu\u00f2 migliorare la stabilit\u00e0 generale. Si noti, tuttavia, che alcuni dispositivi \"clone\" e BL-Touch v2.0 (e precedenti) potrebbero avere una precisione ridotta quando probe_with_touch_mode \u00e8 impostato su True. Su questi dispositivi \u00e8 una buona idea testare l'accuratezza della sonda prima e dopo aver impostato probe_with_touch_mode (usare il comando di test PROBE_ACCURACY ).","title":"Multi-sondaggio senza riporre"},{"location":"BLTouch.html#calibrazione-degli-offset-bl-touch","text":"Seguire le istruzioni nella guida Probe Calibrate per impostare i parametri di configurazione x_offset, y_offset e z_offset. \u00c8 una buona idea verificare che l'offset Z sia vicino a 1 mm. In caso contrario, probabilmente vorrai spostare la sonda su o gi\u00f9 per risolvere il problema. Si desidera che si attivi ben prima che l'ugello colpisca il piatto, in modo che un possibile filamento bloccato o un piatto deformato non influisca sull'azione della sonda. Ma allo stesso tempo, si desidera che la posizione retratta sia il pi\u00f9 possibile al di sopra dell'ugello per evitare che tocchi le parti stampate. Se viene effettuata una regolazione della posizione della sonda, eseguire nuovamente i passaggi di calibrazione della sonda.","title":"Calibrazione degli offset BL-Touch"},{"location":"BLTouch.html#modalita-di-output-bl-touch","text":"Un BL-Touch V3.0 supporta l'impostazione di una modalit\u00e0 di uscita 5V o OPEN-DRAIN, un BL-Touch V3.1 supporta anche questo, ma pu\u00f2 anche memorizzarlo nella sua EEPROM interna. Se la tua scheda controller ha bisogno del livello logico alto 5V fisso della modalit\u00e0 5V, puoi impostare il parametro 'set_output_mode' nella sezione [bltouch] del file di configurazione della stampante su \"5V\". Utilizzare la modalit\u00e0 5V solo se la linea di ingresso della scheda controller \u00e8 tollerante a 5V. Ecco perch\u00e9 la configurazione di default di queste versioni BL-Touch \u00e8 la modalit\u00e0 OPEN-DRAIN. Potresti potenzialmente danneggiare la CPU delle tue schede di controllo Quindi: se una scheda controller HA BISOGNO della modalit\u00e0 5V ED \u00e8 tollerante a 5V sulla sua linea del segnale di ingresso E se si dispone di un BL-Touch Smart V3.0, \u00e8 necessario utilizzare il parametro 'set_output_mode: 5V' per garantire questa impostazione ad ogni avvio, poich\u00e9 la sonda non ricorda l'impostazione necessaria. hai un BL-Touch Smart V3.1, puoi scegliere di usare 'set_output_mode: 5V' o memorizzare la modalit\u00e0 una volta usando un comando 'BLTOUCH_STORE MODE=5V' manualmente e NON usando il parametro 'set_output_mode:'. hai qualche altra sonda: alcune sonde hanno una traccia sul circuito stampato da tagliare o un ponticello da impostare per impostare (permanentemente) la modalit\u00e0 di uscita. In tal caso, omettere completamente il parametro 'set_output_mode'. Se hai una V3.1, non automatizzare o ripetere la memorizzazione della modalit\u00e0 di output per evitare di consumare la EEPROM della sonda. La BLTouch EEPROM \u00e8 valida per circa 100.000 aggiornamenti. 100 memorizzazioni al giorno aggiungerebbero fino a circa 3 anni di attivit\u00e0 prima di logorarlo. Pertanto, la memorizzazione della modalit\u00e0 di output in una V3.1 \u00e8 progettata dal fornitore per essere un'operazione complicata (l'impostazione predefinita di fabbrica \u00e8 una modalit\u00e0 OPEN DRAIN sicura) e non \u00e8 adatta per essere emessa ripetutamente da qualsiasi slicer, macro o altro, esso \u00e8 preferibilmente da utilizzare solo quando si integra per la prima volta la sonda nell'elettronica di una stampante.","title":"Modalit\u00e0 di output BL-Touch"},{"location":"Beaglebone.html","text":"Beaglebone \u00b6 Questo documento descrive il processo di esecuzione di Klipper su una PRU Beaglebone. Creazione di un'immagine del sistema operativo \u00b6 Start by installing the Debian 11.7 2023-09-02 4GB microSD IoT image. One may run the image from either a micro-SD card or from builtin eMMC. If using the eMMC, install it to eMMC now by following the instructions from the above link. Then ssh into the Beaglebone machine ( ssh debian@beaglebone -- password is temppwd ). Before start installing Klipper you need to free-up additional space. there are 3 options to do that: remove some BeagleBone \"Demo\" resources if you did boot from SD-Card, and it's bigger than 4Gb - you can expand current filesystem to take whole card space do option #1 and #2 together. To remove some BeagleBone \"Demo\" resources execute these commands sudo apt remove bb-node-red-installer sudo apt remove bb-code-server To expand filesystem to full size of your SD-Card execute this command, reboot is not required. sudo growpart /dev/mmcblk0 1 sudo resize2fs /dev/mmcblk0p1 Install Klipper by running the following commands: git clone https://github.com/Klipper3d/klipper.git ./klipper/scripts/install-beaglebone.sh After installing Klipper you need to decide what kind of deployment do you need, but take a note that BeagleBone is 3.3v based hardware and in most cases you can't directly connect pins to 5v or 12v based hardware without conversion boards. As Klipper have multimodule architecture on BeagleBone you can achieve many different use cases, but general ones are following: Use case 1: Use BeagleBone only as a host system to run Klipper and additional software like OctoPrint/Fluidd + Moonraker/... and this configuration will be driving external micro-controllers via serial/usb/canbus connections. Use case 2: Use BeagleBone with extension board (cape) like CRAMPS board. in this configuration BeagleBone will host Klipper + additional software, and it will drive extension board with BeagleBone PRU cores (2 additional cores 200Mh, 32Bit). Use case 3: It's same as \"Use case 1\" but additionally you want to drive BeagleBone GPIOs with high speed by utilizing PRU cores to offload main CPU. Installing Octoprint \u00b6 One may then install Octoprint or fully skip this section if desired other software: git clone https://github.com/foosel/OctoPrint.git cd OctoPrint/ virtualenv venv ./venv/bin/python setup.py install E configura OctoPrint per l'avvio all'avvio: sudo cp ~/OctoPrint/scripts/octoprint.init /etc/init.d/octoprint sudo chmod +x /etc/init.d/octoprint sudo cp ~/OctoPrint/scripts/octoprint.default /etc/default/octoprint sudo update-rc.d octoprint defaults \u00c8 necessario modificare il file di configurazione /etc/default/octoprint di OctoPrint. Si deve cambiare l'utente OCTOPRINT_USER in debian , cambiare NICELEVEL in 0 , togliere il commento alle impostazioni di BASEDIR , CONFIGFILE e DAEMON e cambiare i riferimenti della home da /home/pi/ a /home/debian/ : sudo nano /etc/default/octoprint Quindi avvia il servizio Octoprint: sudo systemctl start octoprint Wait 1-2 minutes and make sure the OctoPrint web server is accessible - it should be at: http://beaglebone:5000/ Building the BeagleBone PRU micro-controller code (PRU firmware) \u00b6 This section is required for \"Use case 2\" and \"Use case 3\" mentioned above, you should skip it for \"Use case 1\". Check that required devices are present sudo beagle-version You should check that output contains successful \"remoteproc\" drivers loading and presence of PRU cores, in Kernel 5.10 they should be \"remoteproc1\" and \"remoteproc2\" (4a334000.pru, 4a338000.pru) Also check that many GPIOs are loaded they will look like \"Allocated GPIO id=0 name='P8_03'\" Usually everything is fine and no hardware configuration is required. If something is missing - try to play with \"uboot overlays\" options or with cape-overlays Just for reference some output of working BeagleBone Black configuration with CRAMPS board: model:[TI_AM335x_BeagleBone_Black] UBOOT: Booted Device-Tree:[am335x-boneblack-uboot-univ.dts] UBOOT: Loaded Overlay:[BB-ADC-00A0.bb.org-overlays] UBOOT: Loaded Overlay:[BB-BONE-eMMC1-01-00A0.bb.org-overlays] kernel:[5.10.168-ti-r71] /boot/uEnv.txt Settings: uboot_overlay_options:[enable_uboot_overlays=1] uboot_overlay_options:[disable_uboot_overlay_video=0] uboot_overlay_options:[disable_uboot_overlay_audio=1] uboot_overlay_options:[disable_uboot_overlay_wireless=1] uboot_overlay_options:[enable_uboot_cape_universal=1] pkg:[bb-cape-overlays]:[4.14.20210821.0-0~bullseye+20210821] pkg:[bb-customizations]:[1.20230720.1-0~bullseye+20230720] pkg:[bb-usb-gadgets]:[1.20230414.0-0~bullseye+20230414] pkg:[bb-wl18xx-firmware]:[1.20230414.0-0~bullseye+20230414] ............. ............. To compile the Klipper micro-controller code, start by configuring it for the \"Beaglebone PRU\", for \"BeagleBone Black\" additionally disable options \"Support GPIO Bit-banging devices\" and disable \"Support LCD devices\" inside the \"Optional features\" because they will not fit in 8Kb PRU firmware memory, then exit and save config: cd ~/klipper/ make menuconfig To build and install the new PRU micro-controller code, run: sudo service klipper stop make flash sudo service klipper start After previous commands was executed your PRU firmware should be ready and started to check if everything was fine you can execute following command dmesg and compare last messages with sample one which indicate that everything started properly: [ 71.105499] remoteproc remoteproc1: 4a334000.pru is available [ 71.157155] remoteproc remoteproc2: 4a338000.pru is available [ 73.256287] remoteproc remoteproc1: powering up 4a334000.pru [ 73.279246] remoteproc remoteproc1: Booting fw image am335x-pru0-fw, size 97112 [ 73.285807] remoteproc1#vdev0buffer: registered virtio0 (type 7) [ 73.285836] remoteproc remoteproc1: remote processor 4a334000.pru is now up [ 73.286322] remoteproc remoteproc2: powering up 4a338000.pru [ 73.313717] remoteproc remoteproc2: Booting fw image am335x-pru1-fw, size 188560 [ 73.313753] remoteproc remoteproc2: header-less resource table [ 73.329964] remoteproc remoteproc2: header-less resource table [ 73.348321] remoteproc remoteproc2: remote processor 4a338000.pru is now up [ 73.443355] virtio_rpmsg_bus virtio0: creating channel rpmsg-pru addr 0x1e [ 73.443727] virtio_rpmsg_bus virtio0: msg received with no recipient [ 73.444352] virtio_rpmsg_bus virtio0: rpmsg host is online [ 73.540993] rpmsg_pru virtio0.rpmsg-pru.-1.30: new rpmsg_pru device: /dev/rpmsg_pru30 take a note about \"/dev/rpmsg_pru30\" - it's your future serial device for main mcu configuration this device is required to be present, if it's absent - your PRU cores did not start properly. Building and installing Linux host micro-controller code \u00b6 This section is required for \"Use case 2\" and optional for \"Use case 3\" mentioned above \u00c8 inoltre necessario compilare e installare il codice del microcontrollore per un processo host Linux. Configuralo per un \"processo Linux\": make menuconfig Quindi installa anche questo codice del microcontrollore: sudo service klipper stop make flash sudo service klipper start take a note about \"/tmp/klipper_host_mcu\" - it will be your future serial device for \"mcu host\" if that file don't exist - refer to \"scripts/klipper-mcu.service\" file, it was installed by previous commands, and it's responsible for it. Take a note for \"Use case 2\" about following: when you will define printer configuration you should always use temperature sensors from \"mcu host\" because ADCs not present in default \"mcu\" (PRU cores). Sample configuration of \"sensor_pin\" for extruder and heated bed are available in \"generic-cramps.cfg\" You can use any other GPIO directly from \"mcu host\" by referencing them this way \"host:gpiochip1/gpio17\" but that should be avoided because it will be creating additional load on main CPU and most probably you can't use them for stepper control. Configurazione rimanente \u00b6 Complete the installation by configuring Klipper following the instructions in the main Installation document. Stampa sul Beaglebone \u00b6 Unfortunately, the Beaglebone processor can sometimes struggle to run OctoPrint well. Print stalls have been known to occur on complex prints (the printer may move faster than OctoPrint can send movement commands). If this occurs, consider using the \"virtual_sdcard\" feature (see Config Reference for details) to print directly from Klipper and disable any DEBUG or VERBOSE logging options if you did enable them. AVR micro-controller code build \u00b6 This environment have everything to build necessary micro-controller code except AVR, AVR packages was removed because of conflict with PRU packages. if you still want to build AVR micro-controller code in this environment you need to remove PRU packages and install AVR packages by executing following commands sudo apt-get remove gcc-pru sudo apt-get install avrdude gcc-avr binutils-avr avr-libc if you need to restore PRU packages - then remove ARV packages before that sudo apt-get remove avrdude gcc-avr binutils-avr avr-libc sudo apt-get install gcc-pru Hardware Pin designation \u00b6 BeagleBone is very flexible in terms of pin designation, same pin can be configured for different function but always single function for single pin, same function can be present on different pins. So you can't have multiple functions on single pin or have same function on multiple pins. Example: P9_20 - i2c2_sda/can0_tx/spi1_cs0/gpio0_12/uart1_ctsn P9_19 - i2c2_scl/can0_rx/spi1_cs1/gpio0_13/uart1_rtsn P9_24 - i2c1_scl/can1_rx/gpio0_15/uart1_tx P9_26 - i2c1_sda/can1_tx/gpio0_14/uart1_rx Pin designation is defined by using special \"overlays\" which will be loaded during linux boot they are configured by editing file /boot/uEnv.txt with elevated permissions sudo editor /boot/uEnv.txt and defining which functionality to load, for example to enable CAN1 you need to define overlay for it uboot_overlay_addr4=/lib/firmware/BB-CAN1-00A0.dtbo This overlay BB-CAN1-00A0.dtbo will reconfigure all required pins for CAN1 and create CAN device in Linux. Any change in overlays will require system reboot to be applied. If you need to understand which pins are involved in some overlay - you can analyze source files in this location: /opt/sources/bb.org-overlays/src/arm/ or search info in BeagleBone forums. Enabling hardware SPI \u00b6 BeagleBone usually have multiple hardware SPI buses, for example BeagleBone Black can have 2 of them, they can work up to 48Mhz, but usually they are limited to 16Mhz by Kernel Device-tree. By default, in BeagleBone Black some of SPI1 pins are configured for HDMI-Audio output, to fully enable 4-wire SPI1 you need to disable HDMI Audio and enable SPI1 To do that edit file /boot/uEnv.txt with elevated permissions sudo editor /boot/uEnv.txt uncomment variable disable_uboot_overlay_audio=1 next uncomment variable and define it this way uboot_overlay_addr4=/lib/firmware/BB-SPIDEV1-00A0.dtbo Save changes in /boot/uEnv.txt and reboot the board. Now you have SPI1 Enabled, to verify its presence execute command ls /dev/spidev1.* Take a note that BeagleBone usually is 3.3v based hardware and to use 5V SPI devices you need to add Level-Shifting chip, for example SN74CBTD3861, SN74LVC1G34 or similar. If you are using CRAMPS board - it already contains Level-Shifting chip and SPI1 pins will become available on P503 port, and they can accept 5v hardware, check CRAMPS board Schematics for pin references. Enabling hardware I2C \u00b6 BeagleBone usually have multiple hardware I2C buses, for example BeagleBone Black can have 3 of them, they support speed up-to 400Kbit Fast mode. By default, in BeagleBone Black there are two of them (i2c-1 and i2c-2) usually both are already configured and present on P9, third ic2-0 usually reserved for internal use. If you are using CRAMPS board then i2c-2 is present on P303 port with 3.3v level, If you want to obtain I2c-1 in CRAMPS board - you can get them on Extruder1.Step, Extruder1.Dir pins, they also are 3.3v based, check CRAMPS board Schematics for pin references. Related overlays, for Hardware Pin designation : I2C1(100Kbit): BB-I2C1-00A0.dtbo I2C1(400Kbit): BB-I2C1-FAST-00A0.dtbo I2C2(100Kbit): BB-I2C2-00A0.dtbo I2C2(400Kbit): BB-I2C2-FAST-00A0.dtbo Enabling hardware UART(Serial)/CAN \u00b6 BeagleBone have up to 6 hardware UART(Serial) buses (up to 3Mbit) and up to 2 hardware CAN(1Mbit) buses. UART1(RX,TX) and CAN1(TX,RX) and I2C2(SDA,SCL) are using same pins - so you need to chose what to use UART1(CTSN,RTSN) and CAN0(TX,RX) and I2C1(SDA,SCL) are using same pins - so you need to chose what to use All UART/CAN related pins are 3.3v based, so you will need to use Transceiver chips/boards like SN74LVC2G241DCUR (for UART), SN65HVD230 (for CAN), TTL-RS485 (for RS-485) or something similar which can convert 3.3v signals to appropriate levels. Related overlays, for Hardware Pin designation CAN0: BB-CAN0-00A0.dtbo CAN1: BB-CAN1-00A0.dtbo UART0: - used for Console UART1(RX,TX): BB-UART1-00A0.dtbo UART1(RTS,CTS): BB-UART1-RTSCTS-00A0.dtbo UART2(RX,TX): BB-UART2-00A0.dtbo UART3(RX,TX): BB-UART3-00A0.dtbo UART4(RS-485): BB-UART4-RS485-00A0.dtbo UART5(RX,TX): BB-UART5-00A0.dtbo","title":"Beaglebone"},{"location":"Beaglebone.html#beaglebone","text":"Questo documento descrive il processo di esecuzione di Klipper su una PRU Beaglebone.","title":"Beaglebone"},{"location":"Beaglebone.html#creazione-di-unimmagine-del-sistema-operativo","text":"Start by installing the Debian 11.7 2023-09-02 4GB microSD IoT image. One may run the image from either a micro-SD card or from builtin eMMC. If using the eMMC, install it to eMMC now by following the instructions from the above link. Then ssh into the Beaglebone machine ( ssh debian@beaglebone -- password is temppwd ). Before start installing Klipper you need to free-up additional space. there are 3 options to do that: remove some BeagleBone \"Demo\" resources if you did boot from SD-Card, and it's bigger than 4Gb - you can expand current filesystem to take whole card space do option #1 and #2 together. To remove some BeagleBone \"Demo\" resources execute these commands sudo apt remove bb-node-red-installer sudo apt remove bb-code-server To expand filesystem to full size of your SD-Card execute this command, reboot is not required. sudo growpart /dev/mmcblk0 1 sudo resize2fs /dev/mmcblk0p1 Install Klipper by running the following commands: git clone https://github.com/Klipper3d/klipper.git ./klipper/scripts/install-beaglebone.sh After installing Klipper you need to decide what kind of deployment do you need, but take a note that BeagleBone is 3.3v based hardware and in most cases you can't directly connect pins to 5v or 12v based hardware without conversion boards. As Klipper have multimodule architecture on BeagleBone you can achieve many different use cases, but general ones are following: Use case 1: Use BeagleBone only as a host system to run Klipper and additional software like OctoPrint/Fluidd + Moonraker/... and this configuration will be driving external micro-controllers via serial/usb/canbus connections. Use case 2: Use BeagleBone with extension board (cape) like CRAMPS board. in this configuration BeagleBone will host Klipper + additional software, and it will drive extension board with BeagleBone PRU cores (2 additional cores 200Mh, 32Bit). Use case 3: It's same as \"Use case 1\" but additionally you want to drive BeagleBone GPIOs with high speed by utilizing PRU cores to offload main CPU.","title":"Creazione di un'immagine del sistema operativo"},{"location":"Beaglebone.html#installing-octoprint","text":"One may then install Octoprint or fully skip this section if desired other software: git clone https://github.com/foosel/OctoPrint.git cd OctoPrint/ virtualenv venv ./venv/bin/python setup.py install E configura OctoPrint per l'avvio all'avvio: sudo cp ~/OctoPrint/scripts/octoprint.init /etc/init.d/octoprint sudo chmod +x /etc/init.d/octoprint sudo cp ~/OctoPrint/scripts/octoprint.default /etc/default/octoprint sudo update-rc.d octoprint defaults \u00c8 necessario modificare il file di configurazione /etc/default/octoprint di OctoPrint. Si deve cambiare l'utente OCTOPRINT_USER in debian , cambiare NICELEVEL in 0 , togliere il commento alle impostazioni di BASEDIR , CONFIGFILE e DAEMON e cambiare i riferimenti della home da /home/pi/ a /home/debian/ : sudo nano /etc/default/octoprint Quindi avvia il servizio Octoprint: sudo systemctl start octoprint Wait 1-2 minutes and make sure the OctoPrint web server is accessible - it should be at: http://beaglebone:5000/","title":"Installing Octoprint"},{"location":"Beaglebone.html#building-the-beaglebone-pru-micro-controller-code-pru-firmware","text":"This section is required for \"Use case 2\" and \"Use case 3\" mentioned above, you should skip it for \"Use case 1\". Check that required devices are present sudo beagle-version You should check that output contains successful \"remoteproc\" drivers loading and presence of PRU cores, in Kernel 5.10 they should be \"remoteproc1\" and \"remoteproc2\" (4a334000.pru, 4a338000.pru) Also check that many GPIOs are loaded they will look like \"Allocated GPIO id=0 name='P8_03'\" Usually everything is fine and no hardware configuration is required. If something is missing - try to play with \"uboot overlays\" options or with cape-overlays Just for reference some output of working BeagleBone Black configuration with CRAMPS board: model:[TI_AM335x_BeagleBone_Black] UBOOT: Booted Device-Tree:[am335x-boneblack-uboot-univ.dts] UBOOT: Loaded Overlay:[BB-ADC-00A0.bb.org-overlays] UBOOT: Loaded Overlay:[BB-BONE-eMMC1-01-00A0.bb.org-overlays] kernel:[5.10.168-ti-r71] /boot/uEnv.txt Settings: uboot_overlay_options:[enable_uboot_overlays=1] uboot_overlay_options:[disable_uboot_overlay_video=0] uboot_overlay_options:[disable_uboot_overlay_audio=1] uboot_overlay_options:[disable_uboot_overlay_wireless=1] uboot_overlay_options:[enable_uboot_cape_universal=1] pkg:[bb-cape-overlays]:[4.14.20210821.0-0~bullseye+20210821] pkg:[bb-customizations]:[1.20230720.1-0~bullseye+20230720] pkg:[bb-usb-gadgets]:[1.20230414.0-0~bullseye+20230414] pkg:[bb-wl18xx-firmware]:[1.20230414.0-0~bullseye+20230414] ............. ............. To compile the Klipper micro-controller code, start by configuring it for the \"Beaglebone PRU\", for \"BeagleBone Black\" additionally disable options \"Support GPIO Bit-banging devices\" and disable \"Support LCD devices\" inside the \"Optional features\" because they will not fit in 8Kb PRU firmware memory, then exit and save config: cd ~/klipper/ make menuconfig To build and install the new PRU micro-controller code, run: sudo service klipper stop make flash sudo service klipper start After previous commands was executed your PRU firmware should be ready and started to check if everything was fine you can execute following command dmesg and compare last messages with sample one which indicate that everything started properly: [ 71.105499] remoteproc remoteproc1: 4a334000.pru is available [ 71.157155] remoteproc remoteproc2: 4a338000.pru is available [ 73.256287] remoteproc remoteproc1: powering up 4a334000.pru [ 73.279246] remoteproc remoteproc1: Booting fw image am335x-pru0-fw, size 97112 [ 73.285807] remoteproc1#vdev0buffer: registered virtio0 (type 7) [ 73.285836] remoteproc remoteproc1: remote processor 4a334000.pru is now up [ 73.286322] remoteproc remoteproc2: powering up 4a338000.pru [ 73.313717] remoteproc remoteproc2: Booting fw image am335x-pru1-fw, size 188560 [ 73.313753] remoteproc remoteproc2: header-less resource table [ 73.329964] remoteproc remoteproc2: header-less resource table [ 73.348321] remoteproc remoteproc2: remote processor 4a338000.pru is now up [ 73.443355] virtio_rpmsg_bus virtio0: creating channel rpmsg-pru addr 0x1e [ 73.443727] virtio_rpmsg_bus virtio0: msg received with no recipient [ 73.444352] virtio_rpmsg_bus virtio0: rpmsg host is online [ 73.540993] rpmsg_pru virtio0.rpmsg-pru.-1.30: new rpmsg_pru device: /dev/rpmsg_pru30 take a note about \"/dev/rpmsg_pru30\" - it's your future serial device for main mcu configuration this device is required to be present, if it's absent - your PRU cores did not start properly.","title":"Building the BeagleBone PRU micro-controller code (PRU firmware)"},{"location":"Beaglebone.html#building-and-installing-linux-host-micro-controller-code","text":"This section is required for \"Use case 2\" and optional for \"Use case 3\" mentioned above \u00c8 inoltre necessario compilare e installare il codice del microcontrollore per un processo host Linux. Configuralo per un \"processo Linux\": make menuconfig Quindi installa anche questo codice del microcontrollore: sudo service klipper stop make flash sudo service klipper start take a note about \"/tmp/klipper_host_mcu\" - it will be your future serial device for \"mcu host\" if that file don't exist - refer to \"scripts/klipper-mcu.service\" file, it was installed by previous commands, and it's responsible for it. Take a note for \"Use case 2\" about following: when you will define printer configuration you should always use temperature sensors from \"mcu host\" because ADCs not present in default \"mcu\" (PRU cores). Sample configuration of \"sensor_pin\" for extruder and heated bed are available in \"generic-cramps.cfg\" You can use any other GPIO directly from \"mcu host\" by referencing them this way \"host:gpiochip1/gpio17\" but that should be avoided because it will be creating additional load on main CPU and most probably you can't use them for stepper control.","title":"Building and installing Linux host micro-controller code"},{"location":"Beaglebone.html#configurazione-rimanente","text":"Complete the installation by configuring Klipper following the instructions in the main Installation document.","title":"Configurazione rimanente"},{"location":"Beaglebone.html#stampa-sul-beaglebone","text":"Unfortunately, the Beaglebone processor can sometimes struggle to run OctoPrint well. Print stalls have been known to occur on complex prints (the printer may move faster than OctoPrint can send movement commands). If this occurs, consider using the \"virtual_sdcard\" feature (see Config Reference for details) to print directly from Klipper and disable any DEBUG or VERBOSE logging options if you did enable them.","title":"Stampa sul Beaglebone"},{"location":"Beaglebone.html#avr-micro-controller-code-build","text":"This environment have everything to build necessary micro-controller code except AVR, AVR packages was removed because of conflict with PRU packages. if you still want to build AVR micro-controller code in this environment you need to remove PRU packages and install AVR packages by executing following commands sudo apt-get remove gcc-pru sudo apt-get install avrdude gcc-avr binutils-avr avr-libc if you need to restore PRU packages - then remove ARV packages before that sudo apt-get remove avrdude gcc-avr binutils-avr avr-libc sudo apt-get install gcc-pru","title":"AVR micro-controller code build"},{"location":"Beaglebone.html#hardware-pin-designation","text":"BeagleBone is very flexible in terms of pin designation, same pin can be configured for different function but always single function for single pin, same function can be present on different pins. So you can't have multiple functions on single pin or have same function on multiple pins. Example: P9_20 - i2c2_sda/can0_tx/spi1_cs0/gpio0_12/uart1_ctsn P9_19 - i2c2_scl/can0_rx/spi1_cs1/gpio0_13/uart1_rtsn P9_24 - i2c1_scl/can1_rx/gpio0_15/uart1_tx P9_26 - i2c1_sda/can1_tx/gpio0_14/uart1_rx Pin designation is defined by using special \"overlays\" which will be loaded during linux boot they are configured by editing file /boot/uEnv.txt with elevated permissions sudo editor /boot/uEnv.txt and defining which functionality to load, for example to enable CAN1 you need to define overlay for it uboot_overlay_addr4=/lib/firmware/BB-CAN1-00A0.dtbo This overlay BB-CAN1-00A0.dtbo will reconfigure all required pins for CAN1 and create CAN device in Linux. Any change in overlays will require system reboot to be applied. If you need to understand which pins are involved in some overlay - you can analyze source files in this location: /opt/sources/bb.org-overlays/src/arm/ or search info in BeagleBone forums.","title":"Hardware Pin designation"},{"location":"Beaglebone.html#enabling-hardware-spi","text":"BeagleBone usually have multiple hardware SPI buses, for example BeagleBone Black can have 2 of them, they can work up to 48Mhz, but usually they are limited to 16Mhz by Kernel Device-tree. By default, in BeagleBone Black some of SPI1 pins are configured for HDMI-Audio output, to fully enable 4-wire SPI1 you need to disable HDMI Audio and enable SPI1 To do that edit file /boot/uEnv.txt with elevated permissions sudo editor /boot/uEnv.txt uncomment variable disable_uboot_overlay_audio=1 next uncomment variable and define it this way uboot_overlay_addr4=/lib/firmware/BB-SPIDEV1-00A0.dtbo Save changes in /boot/uEnv.txt and reboot the board. Now you have SPI1 Enabled, to verify its presence execute command ls /dev/spidev1.* Take a note that BeagleBone usually is 3.3v based hardware and to use 5V SPI devices you need to add Level-Shifting chip, for example SN74CBTD3861, SN74LVC1G34 or similar. If you are using CRAMPS board - it already contains Level-Shifting chip and SPI1 pins will become available on P503 port, and they can accept 5v hardware, check CRAMPS board Schematics for pin references.","title":"Enabling hardware SPI"},{"location":"Beaglebone.html#enabling-hardware-i2c","text":"BeagleBone usually have multiple hardware I2C buses, for example BeagleBone Black can have 3 of them, they support speed up-to 400Kbit Fast mode. By default, in BeagleBone Black there are two of them (i2c-1 and i2c-2) usually both are already configured and present on P9, third ic2-0 usually reserved for internal use. If you are using CRAMPS board then i2c-2 is present on P303 port with 3.3v level, If you want to obtain I2c-1 in CRAMPS board - you can get them on Extruder1.Step, Extruder1.Dir pins, they also are 3.3v based, check CRAMPS board Schematics for pin references. Related overlays, for Hardware Pin designation : I2C1(100Kbit): BB-I2C1-00A0.dtbo I2C1(400Kbit): BB-I2C1-FAST-00A0.dtbo I2C2(100Kbit): BB-I2C2-00A0.dtbo I2C2(400Kbit): BB-I2C2-FAST-00A0.dtbo","title":"Enabling hardware I2C"},{"location":"Beaglebone.html#enabling-hardware-uartserialcan","text":"BeagleBone have up to 6 hardware UART(Serial) buses (up to 3Mbit) and up to 2 hardware CAN(1Mbit) buses. UART1(RX,TX) and CAN1(TX,RX) and I2C2(SDA,SCL) are using same pins - so you need to chose what to use UART1(CTSN,RTSN) and CAN0(TX,RX) and I2C1(SDA,SCL) are using same pins - so you need to chose what to use All UART/CAN related pins are 3.3v based, so you will need to use Transceiver chips/boards like SN74LVC2G241DCUR (for UART), SN65HVD230 (for CAN), TTL-RS485 (for RS-485) or something similar which can convert 3.3v signals to appropriate levels. Related overlays, for Hardware Pin designation CAN0: BB-CAN0-00A0.dtbo CAN1: BB-CAN1-00A0.dtbo UART0: - used for Console UART1(RX,TX): BB-UART1-00A0.dtbo UART1(RTS,CTS): BB-UART1-RTSCTS-00A0.dtbo UART2(RX,TX): BB-UART2-00A0.dtbo UART3(RX,TX): BB-UART3-00A0.dtbo UART4(RS-485): BB-UART4-RS485-00A0.dtbo UART5(RX,TX): BB-UART5-00A0.dtbo","title":"Enabling hardware UART(Serial)/CAN"},{"location":"Bed_Level.html","text":"Livellamento del piatto \u00b6 La livellatura del piatto \u00e8 fondamentale per ottenere stampe di alta qualit\u00e0. Se un piatto non \u00e8 adeguatamente \"livellato\" pu\u00f2 portare a una scarsa adesione sul piatto, a una \"deformazione\" e a problemi minori durante la stampa. Questo documento serve come guida per eseguire il livellamento del piatto in Klipper. \u00c8 importante comprendere l'obiettivo del livellamento del piatto. Se alla stampante viene comandata una posizione X0 Y0 Z10 durante una stampa, l'obiettivo \u00e8 che l'ugello della stampante si trovi esattamente a 10 mm dal piatto della stampante. Inoltre, se poi la stampante dovesse essere comandata in una posizione di X50 Z10 , l'obiettivo \u00e8 che l'ugello mantenga una distanza esatta di 10 mm dal piatto durante l'intero movimento orizzontale. Per ottenere stampe di buona qualit\u00e0, la stampante deve essere calibrata in modo che le distanze Z siano precise entro circa 25 micron (0,025 mm). Questa \u00e8 una piccola distanza, significativamente pi\u00f9 piccola della larghezza di un tipico capello umano. Questa scala non pu\u00f2 essere misurata \"a occhio\". Gli effetti sottili (come l'espansione del calore) influiscono sulle misurazioni a questa scala. Il segreto per ottenere un'elevata precisione \u00e8 utilizzare un processo ripetibile e un metodo di livellamento che sfrutti l'elevata precisione del sistema di movimento della stampante. Scegliere il meccanismo di calibrazione appropriato \u00b6 Diversi tipi di stampanti utilizzano metodi diversi per eseguire il livellamento del piatto. Tutti alla fine dipendono dal \"test cartaceo\" (descritto di seguito). Tuttavia, il processo effettivo per un particolare tipo di stampante \u00e8 descritto in altri documenti. Prima di eseguire uno di questi strumenti di calibrazione, assicurarsi di eseguire i controlli descritti nel documento check di configurazione . \u00c8 necessario verificare il movimento di base della stampante prima di eseguire il livellamento del piatto. Per le stampanti con una \"sonda Z automatica\", assicurarsi di calibrare la sonda seguendo le istruzioni nel documento Probe Calibrate . Per le stampanti delta, vedere il documento Delta Calibrate . Per le stampanti con viti di fissaggio e fermi Z tradizionali, vedere il documento Manual Level . Durante la calibrazione potrebbe essere necessario impostare la Z position_min della stampante su un numero negativo (ad esempio, position_min = -2 ). La stampante applica i controlli dei confini anche durante le routine di calibrazione. L'impostazione di un numero negativo consente alla stampante di spostarsi al di sotto della posizione nominale del piatto, il che pu\u00f2 aiutare quando si tenta di determinare la posizione effettiva del piatto. Il \"test con la carta\" \u00b6 Il meccanismo primario di calibrazione del piatto primario \u00e8 il \"test della carta\". Si tratta di posizionare un normale pezzo di \"carta per fotocopiatrice\" tra il piatto della stampante e l'ugello, quindi comandare l'ugello a diverse altezze Z finch\u00e9 non si avverte una piccola quantit\u00e0 di attrito quando si spinge la carta avanti e indietro. \u00c8 importante comprendere il \"test della carta\" anche se si dispone di una \"sonda Z automatica\". La sonda stessa deve spesso essere calibrata per ottenere buoni risultati. La calibrazione della sonda viene eseguita utilizzando questo \"test della carta\". Per eseguire il test della carta, taglia un piccolo pezzo di carta rettangolare usando un paio di forbici (es. 5x3 cm). La carta ha generalmente uno spessore di circa 100 micron (0,100 mm). (Lo spessore esatto della carta non \u00e8 cruciale.) Il primo passaggio del test della carta consiste nell'ispezione dell'ugello e del piatto della stampante. Assicurati che non ci sia plastica (o altri detriti) sull'ugello o sul letto. Ispeziona l'ugello e il piatto per assicurarti che non sia presente plastica! Se si stampa sempre su un determinato nastro o superficie di stampa, \u00e8 possibile eseguire il test della carta con quel nastro/superficie in posizione. Tuttavia, tieni presente che il nastro stesso ha uno spessore e nastri diversi (o qualsiasi altra superficie di stampa) influiranno sulle misurazioni Z. Assicurati di eseguire nuovamente il test della carta per misurare ogni tipo di superficie in uso. Se c'\u00e8 della plastica sull'ugello, riscalda l'estrusore e usa una pinzetta di metallo per rimuovere quella plastica. Attendere che l'estrusore si raffreddi completamente a temperatura ambiente prima di continuare con il test della carta. Mentre l'ugello si sta raffreddando, usa le pinzette di metallo per rimuovere la plastica che potrebbe fuoriuscire. Esegui sempre il test della carta quando sia l'ugello che il letto sono a temperatura ambiente! Quando l'ugello \u00e8 riscaldato, la sua posizione (rispetto al piatto) cambia a causa dell'espansione termica. Questa espansione termica \u00e8 in genere di circa 100 micron, che ha all'incirca lo stesso spessore di un tipico pezzo di carta per stampante. L'esatta quantit\u00e0 di espansione termica non \u00e8 cruciale, cos\u00ec come lo spessore esatto della carta non \u00e8 cruciale. Inizia con il presupposto che i due siano uguali (vedi sotto per un metodo per determinare la differenza tra le due distanze). Pu\u00f2 sembrare strano calibrare la distanza a temperatura ambiente quando l'obiettivo \u00e8 avere una distanza costante quando riscaldata. Tuttavia, se si calibra quando l'ugello \u00e8 riscaldato, tende a rilasciare piccole quantit\u00e0 di plastica fusa alla carta, il che cambia la quantit\u00e0 di attrito sentito. Ci\u00f2 rende pi\u00f9 difficile ottenere una buona calibrazione. La calibrazione mentre il letto/ugello \u00e8 caldo aumenta notevolmente anche il rischio di ustione. La quantit\u00e0 di espansione termica \u00e8 stabile, quindi \u00e8 facilmente contabilizzabile pi\u00f9 avanti nel processo di calibrazione. Utilizza uno strumento automatizzato per determinare l'altezza Z precisa! Klipper ha diversi script di supporto disponibili (ad esempio, MANUAL_PROBE, Z_ENDSTOP_CALIBRATE, PROBE_CALIBRATE, DELTA_CALIBRATE). Consulta i documenti descritti sopra per sceglierne uno. Eseguire il comando appropriato nella finestra del terminale di OctoPrint. Lo script richieder\u00e0 l'interazione dell'utente nell'output del terminale OctoPrint. Sembrer\u00e0 qualcosa come: Recv: // Starting manual Z probe. Use TESTZ to adjust position. Recv: // Finish with ACCEPT or ABORT command. Recv: // Z position: ?????? --> 5.000 <-- ?????? L'altezza attuale dell'ugello (come la intende attualmente la stampante) \u00e8 mostrata tra \"--> <--\". Il numero a destra \u00e8 l'altezza dell'ultimo tentativo di sonda appena maggiore dell'altezza attuale e a sinistra \u00e8 l'ultimo tentativo di sonda inferiore all'altezza attuale (o ?????? se non \u00e8 stato effettuato alcun tentativo). Metti la carta tra l'ugello e il letto. Pu\u00f2 essere utile piegare un angolo della carta in modo che sia pi\u00f9 facile da afferrare. (Cerca di non spingere il piatto quando muovi la carta avanti e indietro.) Utilizzare il comando TESTZ per richiedere all'ugello di avvicinarsi alla carta. Per esempio: TESTZ Z=-.1 Il comando TESTZ sposter\u00e0 l'ugello di una distanza relativa dalla posizione corrente dell'ugello. (Quindi, Z=-.1 richiede che l'ugello si avvicini al piatto di 0,1 mm.) Dopo che l'ugello ha smesso di muoversi, spingere la carta avanti e indietro per controllare se l'ugello \u00e8 in contatto con la carta e per sentire la quantit\u00e0 di attrito. Continua a emettere comandi TESTZ finch\u00e9 non si avverte una piccola quantit\u00e0 di attrito durante il test con la carta. Se si trova troppo attrito, \u00e8 possibile utilizzare un valore Z positivo per spostare l'ugello verso l'alto. \u00c8 anche possibile utilizzare TESTZ Z=+ o TESTZ Z=- per \"sezionare in due\" l'ultima posizione, ovvero per spostarsi in una posizione a met\u00e0 strada tra due posizioni. Ad esempio, se si riceve il seguente prompt da un comando TESTZ: Recv: // Z position: 0.130 --> 0.230 <-- 0.280 Quindi un TESTZ Z=- sposterebbe l'ugello in una posizione Z di 0,180 (a met\u00e0 strada tra 0,130 e 0,230). \u00c8 possibile utilizzare questa funzione per ridurre rapidamente a un attrito costante. \u00c8 anche possibile usare Z=++ e Z=-- per tornare direttamente a una misurazione passata - per esempio, dopo il prompt sopra un comando TESTZ Z=-- sposterebbe l'ugello su una Z posizione di 0,130. Dopo aver trovato una piccola quantit\u00e0 di attrito, eseguire il comando ACCETTA: ACCEPT Questo accetter\u00e0 l'altezza Z data e proceder\u00e0 con lo strumento di calibrazione fornito. L'esatta quantit\u00e0 di attrito percepito non \u00e8 cruciale, cos\u00ec come la quantit\u00e0 di espansione termica e l'esatta larghezza della carta non sono cruciali. Cerca solo di ottenere la stessa quantit\u00e0 di attrito ogni volta che esegui il test. Se qualcosa va storto durante il test, \u00e8 possibile utilizzare il comando ABORT per uscire dallo strumento di calibrazione. Determinare l'espansione termica \u00b6 Dopo aver eseguito con successo il livellamento del piatto, si pu\u00f2 continuare a calcolare un valore pi\u00f9 preciso per l'impatto combinato di \"espansione termica\", \"spessore della carta\" e \"quantit\u00e0 di attrito sentito durante il test della carta\". Questo tipo di calcolo generalmente non \u00e8 necessario poich\u00e9 la maggior parte degli utenti ritiene che il semplice \"test cartaceo\" fornisca buoni risultati. Il modo pi\u00f9 semplice per eseguire questo calcolo \u00e8 stampare un oggetto di prova con pareti dritte su tutti i lati. Il cubo vuoto che si trova in docs/prints/square.stl pu\u00f2 essere usato per questo. Quando si fa lo slicing l'oggetto, assicurarsi che lo slicer utilizzi la stessa altezza del livello e la stessa larghezza di estrusione per il primo livello che utilizza per tutti i livelli successivi. Utilizzare un'altezza dello strato grossolana (l'altezza dello strato dovrebbe essere circa il 75% del diametro dell'ugello) e non utilizzare un bordo o una raft. Stampa l'oggetto di prova, attendi che si raffreddi e rimuovilo dal piatto. Ispeziona lo strato pi\u00f9 basso dell'oggetto. (Pu\u00f2 anche essere utile far scorrere un dito o un'unghia lungo il bordo inferiore.) Se si scopre che lo strato inferiore si gonfia leggermente lungo tutti i lati dell'oggetto, significa che l'ugello era leggermente pi\u00f9 vicino al piatto di quanto dovrebbe essere. Si pu\u00f2 emettere un comando SET_GCODE_OFFSET Z=+.010 per aumentare l'altezza. Nelle stampe successive \u00e8 possibile controllare questo comportamento e apportare ulteriori modifiche secondo necessit\u00e0. Le regolazioni di questo tipo sono in genere in 10 micron (0,010 mm). Se il livello inferiore appare costantemente pi\u00f9 stretto dei livelli successivi, \u00e8 possibile utilizzare il comando SET_GCODE_OFFSET per effettuare una regolazione Z negativa. Se non si \u00e8 sicuri, \u00e8 possibile diminuire la regolazione Z finch\u00e9 lo strato inferiore delle stampe non mostra un piccolo rigonfiamento, quindi arretrare finch\u00e9 non scompare. Il modo pi\u00f9 semplice per applicare la regolazione Z desiderata \u00e8 creare una macro di G-code START_PRINT, fare in modo che lo slicer chiami quella macro all'inizio di ogni stampa e aggiungere un comando SET_GCODE_OFFSET a quella macro. Per ulteriori dettagli, vedere il documento slicers .","title":"Livellamento del piatto"},{"location":"Bed_Level.html#livellamento-del-piatto","text":"La livellatura del piatto \u00e8 fondamentale per ottenere stampe di alta qualit\u00e0. Se un piatto non \u00e8 adeguatamente \"livellato\" pu\u00f2 portare a una scarsa adesione sul piatto, a una \"deformazione\" e a problemi minori durante la stampa. Questo documento serve come guida per eseguire il livellamento del piatto in Klipper. \u00c8 importante comprendere l'obiettivo del livellamento del piatto. Se alla stampante viene comandata una posizione X0 Y0 Z10 durante una stampa, l'obiettivo \u00e8 che l'ugello della stampante si trovi esattamente a 10 mm dal piatto della stampante. Inoltre, se poi la stampante dovesse essere comandata in una posizione di X50 Z10 , l'obiettivo \u00e8 che l'ugello mantenga una distanza esatta di 10 mm dal piatto durante l'intero movimento orizzontale. Per ottenere stampe di buona qualit\u00e0, la stampante deve essere calibrata in modo che le distanze Z siano precise entro circa 25 micron (0,025 mm). Questa \u00e8 una piccola distanza, significativamente pi\u00f9 piccola della larghezza di un tipico capello umano. Questa scala non pu\u00f2 essere misurata \"a occhio\". Gli effetti sottili (come l'espansione del calore) influiscono sulle misurazioni a questa scala. Il segreto per ottenere un'elevata precisione \u00e8 utilizzare un processo ripetibile e un metodo di livellamento che sfrutti l'elevata precisione del sistema di movimento della stampante.","title":"Livellamento del piatto"},{"location":"Bed_Level.html#scegliere-il-meccanismo-di-calibrazione-appropriato","text":"Diversi tipi di stampanti utilizzano metodi diversi per eseguire il livellamento del piatto. Tutti alla fine dipendono dal \"test cartaceo\" (descritto di seguito). Tuttavia, il processo effettivo per un particolare tipo di stampante \u00e8 descritto in altri documenti. Prima di eseguire uno di questi strumenti di calibrazione, assicurarsi di eseguire i controlli descritti nel documento check di configurazione . \u00c8 necessario verificare il movimento di base della stampante prima di eseguire il livellamento del piatto. Per le stampanti con una \"sonda Z automatica\", assicurarsi di calibrare la sonda seguendo le istruzioni nel documento Probe Calibrate . Per le stampanti delta, vedere il documento Delta Calibrate . Per le stampanti con viti di fissaggio e fermi Z tradizionali, vedere il documento Manual Level . Durante la calibrazione potrebbe essere necessario impostare la Z position_min della stampante su un numero negativo (ad esempio, position_min = -2 ). La stampante applica i controlli dei confini anche durante le routine di calibrazione. L'impostazione di un numero negativo consente alla stampante di spostarsi al di sotto della posizione nominale del piatto, il che pu\u00f2 aiutare quando si tenta di determinare la posizione effettiva del piatto.","title":"Scegliere il meccanismo di calibrazione appropriato"},{"location":"Bed_Level.html#il-test-con-la-carta","text":"Il meccanismo primario di calibrazione del piatto primario \u00e8 il \"test della carta\". Si tratta di posizionare un normale pezzo di \"carta per fotocopiatrice\" tra il piatto della stampante e l'ugello, quindi comandare l'ugello a diverse altezze Z finch\u00e9 non si avverte una piccola quantit\u00e0 di attrito quando si spinge la carta avanti e indietro. \u00c8 importante comprendere il \"test della carta\" anche se si dispone di una \"sonda Z automatica\". La sonda stessa deve spesso essere calibrata per ottenere buoni risultati. La calibrazione della sonda viene eseguita utilizzando questo \"test della carta\". Per eseguire il test della carta, taglia un piccolo pezzo di carta rettangolare usando un paio di forbici (es. 5x3 cm). La carta ha generalmente uno spessore di circa 100 micron (0,100 mm). (Lo spessore esatto della carta non \u00e8 cruciale.) Il primo passaggio del test della carta consiste nell'ispezione dell'ugello e del piatto della stampante. Assicurati che non ci sia plastica (o altri detriti) sull'ugello o sul letto. Ispeziona l'ugello e il piatto per assicurarti che non sia presente plastica! Se si stampa sempre su un determinato nastro o superficie di stampa, \u00e8 possibile eseguire il test della carta con quel nastro/superficie in posizione. Tuttavia, tieni presente che il nastro stesso ha uno spessore e nastri diversi (o qualsiasi altra superficie di stampa) influiranno sulle misurazioni Z. Assicurati di eseguire nuovamente il test della carta per misurare ogni tipo di superficie in uso. Se c'\u00e8 della plastica sull'ugello, riscalda l'estrusore e usa una pinzetta di metallo per rimuovere quella plastica. Attendere che l'estrusore si raffreddi completamente a temperatura ambiente prima di continuare con il test della carta. Mentre l'ugello si sta raffreddando, usa le pinzette di metallo per rimuovere la plastica che potrebbe fuoriuscire. Esegui sempre il test della carta quando sia l'ugello che il letto sono a temperatura ambiente! Quando l'ugello \u00e8 riscaldato, la sua posizione (rispetto al piatto) cambia a causa dell'espansione termica. Questa espansione termica \u00e8 in genere di circa 100 micron, che ha all'incirca lo stesso spessore di un tipico pezzo di carta per stampante. L'esatta quantit\u00e0 di espansione termica non \u00e8 cruciale, cos\u00ec come lo spessore esatto della carta non \u00e8 cruciale. Inizia con il presupposto che i due siano uguali (vedi sotto per un metodo per determinare la differenza tra le due distanze). Pu\u00f2 sembrare strano calibrare la distanza a temperatura ambiente quando l'obiettivo \u00e8 avere una distanza costante quando riscaldata. Tuttavia, se si calibra quando l'ugello \u00e8 riscaldato, tende a rilasciare piccole quantit\u00e0 di plastica fusa alla carta, il che cambia la quantit\u00e0 di attrito sentito. Ci\u00f2 rende pi\u00f9 difficile ottenere una buona calibrazione. La calibrazione mentre il letto/ugello \u00e8 caldo aumenta notevolmente anche il rischio di ustione. La quantit\u00e0 di espansione termica \u00e8 stabile, quindi \u00e8 facilmente contabilizzabile pi\u00f9 avanti nel processo di calibrazione. Utilizza uno strumento automatizzato per determinare l'altezza Z precisa! Klipper ha diversi script di supporto disponibili (ad esempio, MANUAL_PROBE, Z_ENDSTOP_CALIBRATE, PROBE_CALIBRATE, DELTA_CALIBRATE). Consulta i documenti descritti sopra per sceglierne uno. Eseguire il comando appropriato nella finestra del terminale di OctoPrint. Lo script richieder\u00e0 l'interazione dell'utente nell'output del terminale OctoPrint. Sembrer\u00e0 qualcosa come: Recv: // Starting manual Z probe. Use TESTZ to adjust position. Recv: // Finish with ACCEPT or ABORT command. Recv: // Z position: ?????? --> 5.000 <-- ?????? L'altezza attuale dell'ugello (come la intende attualmente la stampante) \u00e8 mostrata tra \"--> <--\". Il numero a destra \u00e8 l'altezza dell'ultimo tentativo di sonda appena maggiore dell'altezza attuale e a sinistra \u00e8 l'ultimo tentativo di sonda inferiore all'altezza attuale (o ?????? se non \u00e8 stato effettuato alcun tentativo). Metti la carta tra l'ugello e il letto. Pu\u00f2 essere utile piegare un angolo della carta in modo che sia pi\u00f9 facile da afferrare. (Cerca di non spingere il piatto quando muovi la carta avanti e indietro.) Utilizzare il comando TESTZ per richiedere all'ugello di avvicinarsi alla carta. Per esempio: TESTZ Z=-.1 Il comando TESTZ sposter\u00e0 l'ugello di una distanza relativa dalla posizione corrente dell'ugello. (Quindi, Z=-.1 richiede che l'ugello si avvicini al piatto di 0,1 mm.) Dopo che l'ugello ha smesso di muoversi, spingere la carta avanti e indietro per controllare se l'ugello \u00e8 in contatto con la carta e per sentire la quantit\u00e0 di attrito. Continua a emettere comandi TESTZ finch\u00e9 non si avverte una piccola quantit\u00e0 di attrito durante il test con la carta. Se si trova troppo attrito, \u00e8 possibile utilizzare un valore Z positivo per spostare l'ugello verso l'alto. \u00c8 anche possibile utilizzare TESTZ Z=+ o TESTZ Z=- per \"sezionare in due\" l'ultima posizione, ovvero per spostarsi in una posizione a met\u00e0 strada tra due posizioni. Ad esempio, se si riceve il seguente prompt da un comando TESTZ: Recv: // Z position: 0.130 --> 0.230 <-- 0.280 Quindi un TESTZ Z=- sposterebbe l'ugello in una posizione Z di 0,180 (a met\u00e0 strada tra 0,130 e 0,230). \u00c8 possibile utilizzare questa funzione per ridurre rapidamente a un attrito costante. \u00c8 anche possibile usare Z=++ e Z=-- per tornare direttamente a una misurazione passata - per esempio, dopo il prompt sopra un comando TESTZ Z=-- sposterebbe l'ugello su una Z posizione di 0,130. Dopo aver trovato una piccola quantit\u00e0 di attrito, eseguire il comando ACCETTA: ACCEPT Questo accetter\u00e0 l'altezza Z data e proceder\u00e0 con lo strumento di calibrazione fornito. L'esatta quantit\u00e0 di attrito percepito non \u00e8 cruciale, cos\u00ec come la quantit\u00e0 di espansione termica e l'esatta larghezza della carta non sono cruciali. Cerca solo di ottenere la stessa quantit\u00e0 di attrito ogni volta che esegui il test. Se qualcosa va storto durante il test, \u00e8 possibile utilizzare il comando ABORT per uscire dallo strumento di calibrazione.","title":"Il \"test con la carta\""},{"location":"Bed_Level.html#determinare-lespansione-termica","text":"Dopo aver eseguito con successo il livellamento del piatto, si pu\u00f2 continuare a calcolare un valore pi\u00f9 preciso per l'impatto combinato di \"espansione termica\", \"spessore della carta\" e \"quantit\u00e0 di attrito sentito durante il test della carta\". Questo tipo di calcolo generalmente non \u00e8 necessario poich\u00e9 la maggior parte degli utenti ritiene che il semplice \"test cartaceo\" fornisca buoni risultati. Il modo pi\u00f9 semplice per eseguire questo calcolo \u00e8 stampare un oggetto di prova con pareti dritte su tutti i lati. Il cubo vuoto che si trova in docs/prints/square.stl pu\u00f2 essere usato per questo. Quando si fa lo slicing l'oggetto, assicurarsi che lo slicer utilizzi la stessa altezza del livello e la stessa larghezza di estrusione per il primo livello che utilizza per tutti i livelli successivi. Utilizzare un'altezza dello strato grossolana (l'altezza dello strato dovrebbe essere circa il 75% del diametro dell'ugello) e non utilizzare un bordo o una raft. Stampa l'oggetto di prova, attendi che si raffreddi e rimuovilo dal piatto. Ispeziona lo strato pi\u00f9 basso dell'oggetto. (Pu\u00f2 anche essere utile far scorrere un dito o un'unghia lungo il bordo inferiore.) Se si scopre che lo strato inferiore si gonfia leggermente lungo tutti i lati dell'oggetto, significa che l'ugello era leggermente pi\u00f9 vicino al piatto di quanto dovrebbe essere. Si pu\u00f2 emettere un comando SET_GCODE_OFFSET Z=+.010 per aumentare l'altezza. Nelle stampe successive \u00e8 possibile controllare questo comportamento e apportare ulteriori modifiche secondo necessit\u00e0. Le regolazioni di questo tipo sono in genere in 10 micron (0,010 mm). Se il livello inferiore appare costantemente pi\u00f9 stretto dei livelli successivi, \u00e8 possibile utilizzare il comando SET_GCODE_OFFSET per effettuare una regolazione Z negativa. Se non si \u00e8 sicuri, \u00e8 possibile diminuire la regolazione Z finch\u00e9 lo strato inferiore delle stampe non mostra un piccolo rigonfiamento, quindi arretrare finch\u00e9 non scompare. Il modo pi\u00f9 semplice per applicare la regolazione Z desiderata \u00e8 creare una macro di G-code START_PRINT, fare in modo che lo slicer chiami quella macro all'inizio di ogni stampa e aggiungere un comando SET_GCODE_OFFSET a quella macro. Per ulteriori dettagli, vedere il documento slicers .","title":"Determinare l'espansione termica"},{"location":"Bed_Mesh.html","text":"Matrice del Piatto \u00b6 Il modulo Bed Mesh pu\u00f2 essere utilizzato per compensare le irregolarit\u00e0 della superficie del piatto per ottenere un primo strato migliore sull'intero piatto. Va notato che la correzione basata sul software non otterr\u00e0 risultati perfetti, potr\u00e0 solo approssimare la forma del piatto. Inoltre, Bed Mesh non pu\u00f2 compensare problemi meccanici ed elettrici. Se un asse \u00e8 inclinato o una sonda non \u00e8 precisa, il modulo bed_mesh non ricever\u00e0 risultati accurati dal processo di tastatura. Prima della calibrazione della mesh dovrai assicurarti che l'offset Z della tua sonda sia calibrato. Se si utilizza un fine corsa per l'homing Z, anche questo dovr\u00e0 essere calibrato. Per ulteriori informazioni, vedere Probe Calibrate e Z_ENDSTOP_CALIBRATE in Manual Level . Configurazione base \u00b6 Piatti rettangolari \u00b6 Questo esempio presuppone una stampante con un piatto rettangolare di 250 mm x 220 mm e una sonda con un offset x di 24 mm e un offset y di 5 mm. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 speed: 120 Valore predefinito: 50 La velocit\u00e0 con cui la testa di stampa si sposta tra i punti. horizontal_move_z: 5 Valore predefinito: 5 La coordinata Z a cui si solleva la sonda prima di spostarsi tra i punti. mesh_min: 35, 6 Richiesto La prima coordinata rilevata, pi\u00f9 vicina all'origine. Questa coordinata \u00e8 relativa alla posizione della sonda. mesh_max: 240, 198 Required The probed coordinate farthest from the origin. This is not necessarily the last point probed, as the probing process occurs in a zig-zag fashion. As with mesh_min , this coordinate is relative to the probe's location. probe_count: 5, 3 Valore predefinito: 3, 3 Il numero di punti da sondare su ciascun asse, specificato come valori interi X, Y. In questo esempio verranno tastati 5 punti lungo l'asse X, con 3 punti lungo l'asse Y, per un totale di 15 punti tastati. Nota che se desideri una griglia quadrata, ad esempio 3x3, questo potrebbe essere specificato come un singolo valore intero che viene utilizzato per entrambi gli assi, ad esempio probe_count: 3 . Si noti che una mesh richiede un probe_count minimo di 3 lungo ciascun asse. L'illustrazione seguente mostra come le opzioni mesh_min , mesh_max e probe_count vengono utilizzate per generare punti sonda. Le frecce indicano la direzione della procedura di probing, a partire da mesh_min . Per riferimento, quando la sonda \u00e8 a mesh_min , l'ugello sar\u00e0 a (11, 1), e quando la sonda \u00e8 a mesh_max , l'ugello sar\u00e0 a (206, 193). Piatti rotondi \u00b6 Questo esempio presuppone una stampante dotata di un raggio del piatto rotondo di 100 mm. Utilizzeremo gli stessi offset della sonda dell'esempio rettangolare, 24 mm su X e 5 mm su Y. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_radius: 75 mesh_origin: 0, 0 round_probe_count: 5 mesh_radius: 75 Obbligatorio Il raggio della mesh sondata in mm, relativo a mesh_origin . Si noti che gli offset della sonda limitano la dimensione del raggio della mesh. In questo esempio, un raggio maggiore di 76 sposterebbe lo strumento oltre il range della stampante. mesh_origin: 0, 0 Valore predefinito: 0, 0 Il punto centrale della mesh. Questa coordinata \u00e8 relativa alla posizione della sonda. Sebbene il valore predefinito sia 0, 0, pu\u00f2 essere utile regolare l'origine nel tentativo di sondare una porzione pi\u00f9 ampia del letto. Vedi l'illustrazione qui sotto. round_probe_count: 5 Valore predefinito: 5 Questo \u00e8 un valore intero che definisce il numero massimo di punti sondati lungo gli assi X e Y. Per \"massimo\" si intende il numero di punti tastati lungo l'origine della mesh. Questo valore deve essere un numero dispari, in quanto \u00e8 necessario che venga sondato il centro della mesh. L'illustrazione seguente mostra come vengono generati i punti rilevati. Come puoi vedere, impostando mesh_origin su (-10, 0) ci consente di specificare un raggio di mesh maggiore di 85. Configurazione avanzata \u00b6 Di seguito vengono spiegate in dettaglio le opzioni di configurazione pi\u00f9 avanzate. Ciascun esempio si baser\u00e0 sulla configurazione base del piatto rettangolare mostrata sopra. Ciascuna delle opzioni avanzate si applica allo stesso modo ai piatti rotondi. Interpolazione mesh \u00b6 Sebbene sia possibile campionare direttamente la matrice rilevata utilizzando una semplice interpolazione bilineare per determinare i valori Z tra i punti rilevati, \u00e8 spesso utile interpolare punti aggiuntivi utilizzando algoritmi di interpolazione pi\u00f9 avanzati per aumentare la densit\u00e0 della mesh. Questi algoritmi aggiungono curvatura alla mesh, tentando di simulare le propriet\u00e0 del materiale del letto. Bed Mesh offre interpolazione lagrange e bicubica per raggiungere questo obiettivo. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 mesh_pps: 2, 3 algorithm: bicubic bicubic_tension: 0.2 mesh_pps: 2, 3 Valore predefinito: 2, 2 L'opzione mesh_pps \u00e8 un'abbreviazione per Mesh Points Per Segment. Questa opzione specifica quanti punti interpolare per ciascun segmento lungo gli assi X e Y. Considera un \"segmento\" come lo spazio tra ogni punto sondato. Come probe_count , mesh_pps \u00e8 specificato come una coppia di interi X, Y e pu\u00f2 anche essere specificato un singolo intero che viene applicato a entrambi gli assi. In questo esempio ci sono 4 segmenti lungo l'asse X e 2 segmenti lungo l'asse Y. Questo restituisce 8 punti interpolati lungo X, 6 punti interpolati lungo Y, che si traduce in una mesh 13x8. Si noti che se mesh_pps \u00e8 impostato su 0, l'interpolazione della mesh \u00e8 disabilitata e la matrice sondata verr\u00e0 campionata direttamente. algoritmo: lagrange Valore predefinito: lagrange L'algoritmo utilizzato per interpolare la mesh. Pu\u00f2 essere \"lagrange\" o \"bicubico\". L'interpolazione Lagrange \u00e8 limitata a 6 punti sondati poich\u00e9 tende a verificarsi l'oscillazione con un numero maggiore di campioni. L'interpolazione bicubica richiede un minimo di 4 punti sondati lungo ciascun asse, se vengono specificati meno di 4 punti, viene forzato il campionamento lagrange. Se mesh_pps \u00e8 impostato su 0, questo valore viene ignorato poich\u00e9 non viene eseguita alcuna interpolazione della mesh. bicubic_tension: 0.2 Valore predefinito: 0.2 Se l'opzione algorithm \u00e8 impostata su bicubic \u00e8 possibile specificare il valore della tensione. Maggiore \u00e8 la tensione, maggiore \u00e8 la pendenza interpolata. Prestare attenzione durante la regolazione, poich\u00e9 valori pi\u00f9 elevati creano anche una maggiore sovraelongazione, che risulter\u00e0 in valori interpolati superiori o inferiori rispetto ai punti rilevati. L'illustrazione seguente mostra come vengono utilizzate le opzioni precedenti per generare una mesh interpolata. Divisione dei movimenti \u00b6 Bed Mesh funziona intercettando i comandi di spostamento di gcode e applicando una trasformazione alla loro coordinata Z. I movimenti lunghi devono essere suddivisi in movimenti pi\u00f9 piccoli per seguire correttamente la forma del piatto. Le opzioni seguenti controllano il comportamento di divisione. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 move_check_distance: 5 split_delta_z: .025 move_check_distance: 5 Valore predefinito: 5 La distanza minima per verificare la modifica desiderata in Z prima di eseguire una divisione. In questo esempio, un movimento pi\u00f9 lungo di 5 mm verr\u00e0 eseguito dall'algoritmo. Ogni 5 mm si verificher\u00e0 una ricerca Z della mesh, confrontandola con il valore Z del movimento precedente. Se il delta raggiunge la soglia impostata da split_delta_z , il movimento sar\u00e0 diviso e l'attraversamento continuer\u00e0. Questo processo si ripete fino al raggiungimento della fine del movimento, dove verr\u00e0 applicato un aggiustamento finale. I movimenti pi\u00f9 brevi di move_check_distance hanno la correzione Z corretta applicata direttamente alla mossa senza attraversamento o divisione. split_delta_z: .025 Valore predefinito: .025 Come accennato in precedenza, questa \u00e8 la deviazione minima richiesta per attivare una divisione del movimento. In questo esempio, qualsiasi valore Z con una deviazione +/- 0,025 mm attiver\u00e0 una divisione. Generalmente i valori predefiniti per queste opzioni sono sufficienti, infatti il valore predefinito di 5 mm per move_check_distance potrebbe essere eccessivo. Tuttavia un utente esperto potrebbe voler sperimentare queste opzioni nel tentativo di ottenere il primo livello ottimale. Dissolvenza Mesh \u00b6 Quando la \"dissolvenza\" \u00e8 abilitata, la regolazione Z viene gradualmente eliminata su una distanza definita dalla configurazione. Ci\u00f2 si ottiene applicando piccole regolazioni all'altezza dello strato, aumentando o diminuendo a seconda della forma del letto. Quando la dissolvenza \u00e8 completata, la regolazione Z non viene pi\u00f9 applicata, consentendo alla parte superiore della stampa di essere piatta anzich\u00e9 rispecchiare la forma del letto. La dissolvenza pu\u00f2 anche avere alcuni tratti indesiderati, se dissolve troppo rapidamente pu\u00f2 causare artefatti visibili sulla stampa. Inoltre, se il tuo letto \u00e8 notevolmente deformato, la dissolvenza pu\u00f2 ridurre o allungare l'altezza Z della stampa. In quanto tale, la dissolvenza \u00e8 disabilitata per impostazione predefinita. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 fade_start: 1 fade_end: 10 fade_target: 0 fade_start: 1 Valore predefinito: 1 L'altezza Z in cui iniziare la regolazione graduale. \u00c8 una buona idea avere alcuni layer prima di iniziare il processo di dissolvenza. fade_end: 10 Valore predefinito: 0 L'altezza Z in cui deve essere completata la dissolvenza. Se questo valore \u00e8 inferiore a fade_start , la dissolvenza \u00e8 disabilitata. Questo valore pu\u00f2 essere regolato a seconda di quanto \u00e8 deformata la superficie di stampa. Una superficie notevolmente deformata dovrebbe dissolvere su una distanza maggiore. Una superficie quasi piatta potrebbe essere in grado di ridurre questo valore per eliminarlo gradualmente pi\u00f9 rapidamente. 10mm \u00e8 un valore ragionevole per cominciare se si utilizza il valore predefinito di 1 per fade_start . fade_target: 0 Valore predefinito: il valore Z medio della mesh Il fade_target pu\u00f2 essere considerato come un offset Z aggiuntivo applicato all'intero piatto una volta completata la dissolvenza. In generale vorremmo che questo valore fosse 0, tuttavia ci sono circostanze in cui non dovrebbe esserlo. Ad esempio, supponiamo che la posizione di homing sul piatto sia un valore anomalo, ovvero 0,2 mm inferiore all'altezza media rilevata del piatto. Se fade_target \u00e8 0, la dissolvenza ridurr\u00e0 la stampa in media di 0,2 mm sul piano. Impostando fade_target su .2, l'area home si espander\u00e0 di 0,2 mm, tuttavia, il resto del piatto verr\u00e0 dimensionato accuratamente. Generalmente \u00e8 una buona idea lasciare \"fade_target\" fuori dalla configurazione in modo da utilizzare l'altezza media della mesh, tuttavia potrebbe essere preferibile regolare manualmente il target di dissolvenza se si desidera stampare su una porzione specifica del piano. Configuring the zero reference position \u00b6 Many probes are susceptible to \"drift\", ie: inaccuracies in probing introduced by heat or interference. This can make calculating the probe's z-offset challenging, particularly at different bed temperatures. As such, some printers use an endstop for homing the Z axis and a probe for calibrating the mesh. In this configuration it is possible offset the mesh so that the (X, Y) reference position applies zero adjustment. The reference postion should be the location on the bed where a Z_ENDSTOP_CALIBRATE paper test is performed. The bed_mesh module provides the zero_reference_position option for specifying this coordinate: [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 zero_reference_position: 125, 110 probe_count: 5, 3 zero_reference_position: Default Value: None (disabled) The zero_reference_position expects an (X, Y) coordinate matching that of the reference position described above. If the coordinate lies within the mesh then the mesh will be offset so the reference position applies zero adjustment. If the coordinate lies outside of the mesh then the coordinate will be probed after calibration, with the resulting z-value used as the z-offset. Note that this coordinate must NOT be in a location specified as a faulty_region if a probe is necessary. The deprecated relative_reference_index \u00b6 Existing configurations using the relative_reference_index option must be updated to use the zero_reference_position . The response to the BED_MESH_OUTPUT PGP=1 gcode command will include the (X, Y) coordinate associated with the index; this position may be used as the value for the zero_reference_position . The output will look similar to the following: // bed_mesh: generated points // Index | Tool Adjusted | Probe // 0 | (1.0, 1.0) | (24.0, 6.0) // 1 | (36.7, 1.0) | (59.7, 6.0) // 2 | (72.3, 1.0) | (95.3, 6.0) // 3 | (108.0, 1.0) | (131.0, 6.0) ... (additional generated points) // bed_mesh: relative_reference_index 24 is (131.5, 108.0) Note: The above output is also printed in klippy.log during initialization. Using the example above we see that the relative_reference_index is printed along with its coordinate. Thus the zero_reference_position is 131.5, 108 . Regioni difettose \u00b6 \u00c8 possibile che alcune aree di un piatto riportino risultati imprecisi durante il sondaggio a causa di un \"guasto\" in punti specifici. Il miglior esempio di ci\u00f2 sono i piatti con serie di magneti integrati utilizzati per trattenere le lamiere di acciaio rimovibili. Il campo magnetico su e intorno a questi magneti pu\u00f2 causare l'attivazione di una sonda induttiva a una distanza maggiore o minore di quanto sarebbe altrimenti, risultando in una mesh che non rappresenta accuratamente la superficie in queste posizioni. Nota: questo non deve essere confuso con la distorsione della posizione della sonda, che produce risultati imprecisi sull'intero letto. Le opzioni faulty_region possono essere configurate per compensare questo effetto. Se un punto generato si trova all'interno di una regione difettosa, la mesh del letto tenter\u00e0 di sondare fino a 4 punti ai confini di questa regione. Questi valori sondati verranno mediati e inseriti nella mesh come valore Z alla coordinata generata (X, Y). [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 faulty_region_1_min: 130.0, 0.0 faulty_region_1_max: 145.0, 40.0 faulty_region_2_min: 225.0, 0.0 faulty_region_2_max: 250.0, 25.0 faulty_region_3_min: 165.0, 95.0 faulty_region_3_max: 205.0, 110.0 faulty_region_4_min: 30.0, 170.0 faulty_region_4_max: 45.0, 210.0 faulty_region_{1...99}_min faulty_region_{1..99}_max Valore predefinito: Nessuno (disabilitato) Le regioni difettose sono definite in modo simile a quello della mesh stessa, dove minimo e massimo (X , Y) delle coordinate devono essere specificate per ciascuna regione. Una regione difettosa pu\u00f2 estendersi al di fuori di una mesh, tuttavia i punti alternativi generati saranno sempre all'interno del confine della mesh. Non possono sovrapporsi due regioni. L'immagine seguente illustra come vengono generati i punti di sostituzione quando un punto generato si trova all'interno di una regione difettosa. Le regioni mostrate corrispondono a quelle nella configurazione di esempio sopra. I punti di sostituzione e le relative coordinate sono identificati in verde. Adaptive Meshes \u00b6 Adaptive bed meshing is a way to speed up the bed mesh generation by only probing the area of the bed used by the objects being printed. When used, the method will automatically adjust the mesh parameters based on the area occupied by the defined print objects. The adapted mesh area will be computed from the area defined by the boundaries of all the defined print objects so it covers every object, including any margins defined in the configuration. After the area is computed, the number of probe points will be scaled down based on the ratio of the default mesh area and the adapted mesh area. To illustrate this consider the following example: For a 150mmx150mm bed with mesh_min set to 25,25 and mesh_max set to 125,125 , the default mesh area is a 100mmx100mm square. An adapted mesh area of 50,50 means a ratio of 0.5x0.5 between the adapted area and default mesh area. If the bed_mesh configuration specified probe_count as 7x7 , the adapted bed mesh will use 4x4 probe points (7 * 0.5 rounded up). [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 adaptive_margin: 5 adaptive_margin Default Value: 0 Margin (in mm) to add around the area of the bed used by the defined objects. The diagram below shows the adapted bed mesh area with an adaptive_margin of 5mm. The adapted mesh area (area in green) is computed as the used bed area (area in blue) plus the defined margin. By nature, adaptive bed meshes use the objects defined by the Gcode file being printed. Therefore, it is expected that each Gcode file will generate a mesh that probes a different area of the print bed. Therefore, adapted bed meshes should not be re-used. The expectation is that a new mesh will be generated for each print if adaptive meshing is used. It is also important to consider that adaptive bed meshing is best used on machines that can normally probe the entire bed and achieve a maximum variance less than or equal to 1 layer height. Machines with mechanical issues that a full bed mesh normally compensates for may have undesirable results when attempting print moves outside of the probed area. If a full bed mesh has a variance greater than 1 layer height, caution must be taken when using adaptive bed meshes and attempting print moves outside of the meshed area. Surface Scans \u00b6 Some probes, such as the Eddy Current Probe , are capable of \"scanning\" the surface of the bed. That is, these probes can sample a mesh without lifting the tool between samples. To activate scanning mode, the METHOD=scan or METHOD=rapid_scan probe parameter should be passed in the BED_MESH_CALIBRATE gcode command. Scan Height \u00b6 The scan height is set by the horizontal_move_z option in [bed_mesh] . In addition it can be supplied with the BED_MESH_CALIBRATE gcode command via the HORIZONTAL_MOVE_Z parameter. The scan height must be sufficiently low to avoid scanning errors. Typically a height of 2mm (ie: HORIZONTAL_MOVE_Z=2 ) should work well, presuming that the probe is mounted correctly. It should be noted that if the probe is more than 4mm above the surface then the results will be invalid. Thus, scanning is not possible on beds with severe surface deviation or beds with extreme tilt that hasn't been corrected. Rapid (Continuous) Scanning \u00b6 When performing a rapid_scan one should keep in mind that the results will have some amount of error. This error should be low enough to be useful on large print areas with reasonably thick layer heights. Some probes may be more prone to error than others. It is not recommended that rapid mode be used to scan a \"dense\" mesh. Some of the error introduced during a rapid scan may be gaussian noise from the sensor, and a dense mesh will reflect this noise (ie: there will be peaks and valleys). Bed Mesh will attempt to optimize the travel path to provide the best possible result based on the configuration. This includes avoiding faulty regions when collecting samples and \"overshooting\" the mesh when changing direction. This overshoot improves sampling at the edges of a mesh, however it requires that the mesh be configured in a way that allows the tool to travel outside of the mesh. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5 scan_overshoot: 8 scan_overshoot Default Value: 0 (disabled) The maximum amount of travel (in mm) available outside of the mesh. For rectangular beds this applies to travel on the X axis, and for round beds it applies to the entire radius. The tool must be able to travel the amount specified outside of the mesh. This value is used to optimize the travel path when performing a \"rapid scan\". The minimum value that may be specified is 1. The default is no overshoot. If no scan overshoot is configured then travel path optimization will not be applied to changes in direction. GCodes della mesh del piatto \u00b6 Calibrazione \u00b6 BED_MESH_CALIBRATE PROFILE=<name> METHOD=[manual | automatic | scan | rapid_scan] \\ [<probe_parameter>=<value>] [<mesh_parameter>=<value>] [ADAPTIVE=[0|1] \\ [ADAPTIVE_MARGIN=<value>] Default Profile: default Default Method: automatic if a probe is detected, otherwise manual Default Adaptive: 0 Default Adaptive Margin: 0 Avvia la procedura di sondaggio per la calibrazione della mesh del piatto. The mesh will be saved into a profile specified by the PROFILE parameter, or default if unspecified. The METHOD parameter takes one of the following values: METHOD=manual : enables manual probing using the nozzle and the paper test METHOD=automatic : Automatic (standard) probing. This is the default. METHOD=scan : Enables surface scanning. The tool will pause over each position to collect a sample. METHOD=rapid_scan : Enables continuous surface scanning. XY positions are automatically adjusted to include the X and/or Y offsets when a probing method other than manual is selected. \u00c8 possibile specificare parametri mesh per modificare l'area sondata. Sono disponibili i seguenti parametri: Piatti rettangolari (cartesiani): MESH_MIN MESH_MAX PROBE_COUNT Piatti rotondi (delta): MESH_RADIUS MESH_ORIGIN ROUND_PROBE_COUNT Tutti i piatti: MESH_PPS ALGORITHM ADAPTIVE ADAPTIVE_MARGIN Vedere la documentazione di configurazione sopra per i dettagli su come ogni parametro si applica alla mesh. Profili \u00b6 BED_MESH_PROFILE SAVE=<name> LOAD=<name> REMOVE=<name> Dopo aver eseguito un BED_MESH_CALIBRATE, \u00e8 possibile salvare lo stato della mesh corrente in un profilo denominato. Ci\u00f2 consente di caricare una mesh senza risondare il piatto. Dopo che un profilo \u00e8 stato salvato usando BED_MESH_PROFILE SAVE=<nome> \u00e8 possibile eseguire il gcode SAVE_CONFIG per scrivere il profilo su printer.cfg. I profili possono essere caricati eseguendo BED_MESH_PROFILE LOAD=<name> . Va notato che ogni volta che si verifica un BED_MESH_CALIBRATE, lo stato corrente viene automaticamente salvato nel profilo predefinito . Il profilo predefinito pu\u00f2 essere rimosso come segue: BED_MESH_PROFILE REMOVE=default Qualsiasi altro profilo salvato pu\u00f2 essere rimosso allo stesso modo, sostituendo default con il nome del profilo che desideri rimuovere. Caricamento del profilo predefinito \u00b6 Le versioni precedenti di bed_mesh caricavano sempre il profilo denominato default all'avvio se era presente. Questo comportamento \u00e8 stato rimosso per consentire all'utente di determinare quando viene caricato un profilo. Se un utente desidera caricare il profilo predefinito , si consiglia di aggiungere BED_MESH_PROFILE LOAD=default alla macro START_PRINT o alla configurazione \"Start G-Code\" del proprio slicer, a seconda di quale sia applicabile. In alternativa, il vecchio comportamento di caricamento di un profilo all'avvio pu\u00f2 essere ripristinato con un [delayed_gcode] : [delayed_gcode bed_mesh_init] initial_duration : .01 gcode : BED_MESH_PROFILE LOAD = default Output \u00b6 BED_MESH_OUTPUT PGP=[0 | 1] Invia lo stato della mesh corrente al terminale. Si noti che viene emessa la mesh stessa Il parametro PGP \u00e8 un'abbreviazione per \"Print Generated Points\". Se \u00e8 impostato PGP=1 , i punti sondati generati verranno inviati al terminale: // bed_mesh: generated points // Index | Tool Adjusted | Probe // 0 | (11.0, 1.0) | (35.0, 6.0) // 1 | (62.2, 1.0) | (86.2, 6.0) // 2 | (113.5, 1.0) | (137.5, 6.0) // 3 | (164.8, 1.0) | (188.8, 6.0) // 4 | (216.0, 1.0) | (240.0, 6.0) // 5 | (216.0, 97.0) | (240.0, 102.0) // 6 | (164.8, 97.0) | (188.8, 102.0) // 7 | (113.5, 97.0) | (137.5, 102.0) // 8 | (62.2, 97.0) | (86.2, 102.0) // 9 | (11.0, 97.0) | (35.0, 102.0) // 10 | (11.0, 193.0) | (35.0, 198.0) // 11 | (62.2, 193.0) | (86.2, 198.0) // 12 | (113.5, 193.0) | (137.5, 198.0) // 13 | (164.8, 193.0) | (188.8, 198.0) // 14 | (216.0, 193.0) | (240.0, 198.0) I punti \"Tool Adjusted\" si riferiscono alla posizione dell'ugello per ciascun punto e i punti \"Probe\" si riferiscono alla posizione della sonda. Si noti che quando il probing \u00e8 manuale i punti \"sonda\" si riferiscono sia alla posizione dell'utensile che dell'ugello. Cancella stato mesh \u00b6 BED_MESH_CLEAR Questo gcode pu\u00f2 essere utilizzato per cancellare lo stato della mesh interna. Applicare gli offset X/Y \u00b6 BED_MESH_OFFSET [X=<value>] [Y=<value>] [ZFADE=<value>] This is useful for printers with multiple independent extruders, as an offset is necessary to produce correct Z adjustment after a tool change. Offsets should be specified relative to the primary extruder. That is, a positive X offset should be specified if the secondary extruder is mounted to the right of the primary extruder, a positive Y offset should be specified if the secondary extruder is mounted \"behind\" the primary extruder, and a positive ZFADE offset should be specified if the secondary extruder's nozzle is above the primary extruder's. Note that a ZFADE offset does NOT directly apply additional adjustment. It is intended to compensate for a gcode offset when mesh fade is enabled. For example, if a secondary extruder is higher than the primary and needs a negative gcode offset, ie: SET_GCODE_OFFSET Z=-.2 , it can be accounted for in bed_mesh with BED_MESH_OFFSET ZFADE=.2 . Bed Mesh Webhooks APIs \u00b6 Dumping mesh data \u00b6 {\"id\": 123, \"method\": \"bed_mesh/dump_mesh\"} Dumps the configuration and state for the current mesh and all saved profiles. The dump_mesh endpoint takes one optional parameter, mesh_args . This parameter must be an object, where the keys and values are parameters available to BED_MESH_CALIBRATE . This will update the mesh configuration and probe points using the supplied parameters prior to returning the result. It is recommended to omit mesh parameters unless it is desired to visualize the probe points and/or travel path before performing BED_MESH_CALIBRATE . Visualization and analysis \u00b6 Most users will likely find that the visualizers included with applications such as Mainsail, Fluidd, and Octoprint are sufficient for basic analysis. However, Klipper's scripts folder contains the graph_mesh.py script that may be used to perform additional visualizations and more detailed analysis, particularly useful for debugging hardware or the results produced by bed_mesh : usage: graph_mesh.py [-h] {list,plot,analyze,dump} ... Graph Bed Mesh Data positional arguments: {list,plot,analyze,dump} list List available plot types plot Plot a specified type analyze Perform analysis on mesh data dump Dump API response to json file options: -h, --help show this help message and exit Pre-requisites \u00b6 Like most graphing tools provided by Klipper, graph_mesh.py requires the matplotlib and numpy python dependencies. In addition, connecting to Klipper via Moonraker's websocket requires the websockets python dependency. While all visualizations can be output to an svg file, most of the visualizations offered by graph_mesh.py are better viewed in live preview mode on a desktop class PC. For example, the 3D visualizations may be rotated and zoomed in preview mode, and the path visualizations can optionally be animated in preview mode. Plotting Mesh data \u00b6 The graph_mesh.py tool can plot several types of visualizations. Available types can be shown by running graph_mesh.py list : graph_mesh.py list points Plot original generated points path Plot probe travel path rapid Plot rapid scan travel path probedz Plot probed Z values meshz Plot mesh Z values overlay Plots the current probed mesh overlaid with a profile delta Plots the delta between current probed mesh and a profile Several options are available when plotting visualizations: usage: graph_mesh.py plot [-h] [-a] [-s] [-p PROFILE_NAME] [-o OUTPUT] <plot type> <input> positional arguments: <plot type> Type of data to graph <input> Path/url to Klipper Socket or path to json file options: -h, --help show this help message and exit -a, --animate Animate paths in live preview -s, --scale-plot Use axis limits reported by Klipper to scale plot X/Y -p PROFILE_NAME, --profile-name PROFILE_NAME Optional name of a profile to plot for 'probedz' -o OUTPUT, --output OUTPUT Output file path Below is a description of each argument: plot type : A required positional argument designating the type of visualization to generate. Must be one of the types output by the graph_mesh.py list command. input : A required positional argument containing a path or url to the input source. This must be one of the following: A path to Klipper's Unix Domain Socket A url to an instance of Moonraker A path to a json file produced by graph_mesh.py dump <input> -a : Optional animation for the path and rapid visualization types. Animations only apply to a live preview. -s : Optionally scales a plot using the axis_minimum and axis_maximum values reported by Klipper's toolhead object when the dump file was generated. -p : A profile name that may be specified when generating the probedz 3D mesh visualization. When generating an overlay or delta visualization this argument must be provided. -o : An optional file path indicating that the script should save the visualization to this location rather than run in preview mode. Images are saved in svg format. For example, to plot an animated rapid path, connecting via Klipper's unix socket: graph_mesh.py plot -a rapid ~/printer_data/comms/klippy.sock Or to plot a 3d visualization of the mesh, connecting via Moonraker: graph_mesh.py plot meshz http://my-printer.local Bed Mesh Analysis \u00b6 The graph_mesh.py tool may also be used to perform an analysis on the data provided by the bed_mesh/dump_mesh API: graph_mesh.py analyze <input> As with the plot command, the <input> must be a path to Klipper's unix socket, a URL to an instance of Moonraker, or a path to a json file generated by the dump command. To begin, the analysis will perform various checks on the points and probe paths generated by bed_mesh at the time of the dump. This includes the following: The number of probe points generated, without any additions The number of probe points generated including any points generated as the result faulty regions and/or a configured zero reference position. The number of probe points generated when performing a rapid scan. The total number of moves generated for a rapid scan. A validation that the probe points generated for a rapid scan are identical to the probe points generated for a standard probing procedure. A \"backtracking\" check for both the standard probe path and a rapid scan path. Backtracking can be defined as moving to the same position more than once during the probing procedure. Backtracking should never occur during a standard probe. Faulty regions can result in backtracking during a rapid scan in an attempt to avoid entering a faulty region when approaching or leaving a probe location, however should never occur otherwise. Next each probed mesh present in the dump will by analyzed, beginning with the mesh loaded at the time of the dump (if present) and followed by any saved profiles. The following data is extracted: Mesh shape (Min X,Y, Max X,Y Probe Count) Mesh Z range, (Minimum Z, Maximum Z) Mean Z value in the mesh Standard Deviation of the Z values in the Mesh In addition to the above, a delta analysis is performed between meshes with the same shape, reporting the following: The range of the delta between to meshes (Minimum and Maximum) The mean delta Standard Deviation of the delta The absolute maximum difference The absolute mean Save mesh data to a file \u00b6 The dump command may be used to save the response to a file which can be shared for analysis when troubleshooting: graph_mesh.py dump -o <output file name> <input> The <input> should be a path to Klipper's unix socket or a URL to an instance of Moonraker. The -o option may be used to specify the path to the output file. If omitted, the file will be saved in the working directory, with a file name in the following format: klipper-bedmesh-{year}{month}{day}{hour}{minute}{second}.json","title":"Matrice del Piatto"},{"location":"Bed_Mesh.html#matrice-del-piatto","text":"Il modulo Bed Mesh pu\u00f2 essere utilizzato per compensare le irregolarit\u00e0 della superficie del piatto per ottenere un primo strato migliore sull'intero piatto. Va notato che la correzione basata sul software non otterr\u00e0 risultati perfetti, potr\u00e0 solo approssimare la forma del piatto. Inoltre, Bed Mesh non pu\u00f2 compensare problemi meccanici ed elettrici. Se un asse \u00e8 inclinato o una sonda non \u00e8 precisa, il modulo bed_mesh non ricever\u00e0 risultati accurati dal processo di tastatura. Prima della calibrazione della mesh dovrai assicurarti che l'offset Z della tua sonda sia calibrato. Se si utilizza un fine corsa per l'homing Z, anche questo dovr\u00e0 essere calibrato. Per ulteriori informazioni, vedere Probe Calibrate e Z_ENDSTOP_CALIBRATE in Manual Level .","title":"Matrice del Piatto"},{"location":"Bed_Mesh.html#configurazione-base","text":"","title":"Configurazione base"},{"location":"Bed_Mesh.html#piatti-rettangolari","text":"Questo esempio presuppone una stampante con un piatto rettangolare di 250 mm x 220 mm e una sonda con un offset x di 24 mm e un offset y di 5 mm. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 speed: 120 Valore predefinito: 50 La velocit\u00e0 con cui la testa di stampa si sposta tra i punti. horizontal_move_z: 5 Valore predefinito: 5 La coordinata Z a cui si solleva la sonda prima di spostarsi tra i punti. mesh_min: 35, 6 Richiesto La prima coordinata rilevata, pi\u00f9 vicina all'origine. Questa coordinata \u00e8 relativa alla posizione della sonda. mesh_max: 240, 198 Required The probed coordinate farthest from the origin. This is not necessarily the last point probed, as the probing process occurs in a zig-zag fashion. As with mesh_min , this coordinate is relative to the probe's location. probe_count: 5, 3 Valore predefinito: 3, 3 Il numero di punti da sondare su ciascun asse, specificato come valori interi X, Y. In questo esempio verranno tastati 5 punti lungo l'asse X, con 3 punti lungo l'asse Y, per un totale di 15 punti tastati. Nota che se desideri una griglia quadrata, ad esempio 3x3, questo potrebbe essere specificato come un singolo valore intero che viene utilizzato per entrambi gli assi, ad esempio probe_count: 3 . Si noti che una mesh richiede un probe_count minimo di 3 lungo ciascun asse. L'illustrazione seguente mostra come le opzioni mesh_min , mesh_max e probe_count vengono utilizzate per generare punti sonda. Le frecce indicano la direzione della procedura di probing, a partire da mesh_min . Per riferimento, quando la sonda \u00e8 a mesh_min , l'ugello sar\u00e0 a (11, 1), e quando la sonda \u00e8 a mesh_max , l'ugello sar\u00e0 a (206, 193).","title":"Piatti rettangolari"},{"location":"Bed_Mesh.html#piatti-rotondi","text":"Questo esempio presuppone una stampante dotata di un raggio del piatto rotondo di 100 mm. Utilizzeremo gli stessi offset della sonda dell'esempio rettangolare, 24 mm su X e 5 mm su Y. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_radius: 75 mesh_origin: 0, 0 round_probe_count: 5 mesh_radius: 75 Obbligatorio Il raggio della mesh sondata in mm, relativo a mesh_origin . Si noti che gli offset della sonda limitano la dimensione del raggio della mesh. In questo esempio, un raggio maggiore di 76 sposterebbe lo strumento oltre il range della stampante. mesh_origin: 0, 0 Valore predefinito: 0, 0 Il punto centrale della mesh. Questa coordinata \u00e8 relativa alla posizione della sonda. Sebbene il valore predefinito sia 0, 0, pu\u00f2 essere utile regolare l'origine nel tentativo di sondare una porzione pi\u00f9 ampia del letto. Vedi l'illustrazione qui sotto. round_probe_count: 5 Valore predefinito: 5 Questo \u00e8 un valore intero che definisce il numero massimo di punti sondati lungo gli assi X e Y. Per \"massimo\" si intende il numero di punti tastati lungo l'origine della mesh. Questo valore deve essere un numero dispari, in quanto \u00e8 necessario che venga sondato il centro della mesh. L'illustrazione seguente mostra come vengono generati i punti rilevati. Come puoi vedere, impostando mesh_origin su (-10, 0) ci consente di specificare un raggio di mesh maggiore di 85.","title":"Piatti rotondi"},{"location":"Bed_Mesh.html#configurazione-avanzata","text":"Di seguito vengono spiegate in dettaglio le opzioni di configurazione pi\u00f9 avanzate. Ciascun esempio si baser\u00e0 sulla configurazione base del piatto rettangolare mostrata sopra. Ciascuna delle opzioni avanzate si applica allo stesso modo ai piatti rotondi.","title":"Configurazione avanzata"},{"location":"Bed_Mesh.html#interpolazione-mesh","text":"Sebbene sia possibile campionare direttamente la matrice rilevata utilizzando una semplice interpolazione bilineare per determinare i valori Z tra i punti rilevati, \u00e8 spesso utile interpolare punti aggiuntivi utilizzando algoritmi di interpolazione pi\u00f9 avanzati per aumentare la densit\u00e0 della mesh. Questi algoritmi aggiungono curvatura alla mesh, tentando di simulare le propriet\u00e0 del materiale del letto. Bed Mesh offre interpolazione lagrange e bicubica per raggiungere questo obiettivo. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 mesh_pps: 2, 3 algorithm: bicubic bicubic_tension: 0.2 mesh_pps: 2, 3 Valore predefinito: 2, 2 L'opzione mesh_pps \u00e8 un'abbreviazione per Mesh Points Per Segment. Questa opzione specifica quanti punti interpolare per ciascun segmento lungo gli assi X e Y. Considera un \"segmento\" come lo spazio tra ogni punto sondato. Come probe_count , mesh_pps \u00e8 specificato come una coppia di interi X, Y e pu\u00f2 anche essere specificato un singolo intero che viene applicato a entrambi gli assi. In questo esempio ci sono 4 segmenti lungo l'asse X e 2 segmenti lungo l'asse Y. Questo restituisce 8 punti interpolati lungo X, 6 punti interpolati lungo Y, che si traduce in una mesh 13x8. Si noti che se mesh_pps \u00e8 impostato su 0, l'interpolazione della mesh \u00e8 disabilitata e la matrice sondata verr\u00e0 campionata direttamente. algoritmo: lagrange Valore predefinito: lagrange L'algoritmo utilizzato per interpolare la mesh. Pu\u00f2 essere \"lagrange\" o \"bicubico\". L'interpolazione Lagrange \u00e8 limitata a 6 punti sondati poich\u00e9 tende a verificarsi l'oscillazione con un numero maggiore di campioni. L'interpolazione bicubica richiede un minimo di 4 punti sondati lungo ciascun asse, se vengono specificati meno di 4 punti, viene forzato il campionamento lagrange. Se mesh_pps \u00e8 impostato su 0, questo valore viene ignorato poich\u00e9 non viene eseguita alcuna interpolazione della mesh. bicubic_tension: 0.2 Valore predefinito: 0.2 Se l'opzione algorithm \u00e8 impostata su bicubic \u00e8 possibile specificare il valore della tensione. Maggiore \u00e8 la tensione, maggiore \u00e8 la pendenza interpolata. Prestare attenzione durante la regolazione, poich\u00e9 valori pi\u00f9 elevati creano anche una maggiore sovraelongazione, che risulter\u00e0 in valori interpolati superiori o inferiori rispetto ai punti rilevati. L'illustrazione seguente mostra come vengono utilizzate le opzioni precedenti per generare una mesh interpolata.","title":"Interpolazione mesh"},{"location":"Bed_Mesh.html#divisione-dei-movimenti","text":"Bed Mesh funziona intercettando i comandi di spostamento di gcode e applicando una trasformazione alla loro coordinata Z. I movimenti lunghi devono essere suddivisi in movimenti pi\u00f9 piccoli per seguire correttamente la forma del piatto. Le opzioni seguenti controllano il comportamento di divisione. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 move_check_distance: 5 split_delta_z: .025 move_check_distance: 5 Valore predefinito: 5 La distanza minima per verificare la modifica desiderata in Z prima di eseguire una divisione. In questo esempio, un movimento pi\u00f9 lungo di 5 mm verr\u00e0 eseguito dall'algoritmo. Ogni 5 mm si verificher\u00e0 una ricerca Z della mesh, confrontandola con il valore Z del movimento precedente. Se il delta raggiunge la soglia impostata da split_delta_z , il movimento sar\u00e0 diviso e l'attraversamento continuer\u00e0. Questo processo si ripete fino al raggiungimento della fine del movimento, dove verr\u00e0 applicato un aggiustamento finale. I movimenti pi\u00f9 brevi di move_check_distance hanno la correzione Z corretta applicata direttamente alla mossa senza attraversamento o divisione. split_delta_z: .025 Valore predefinito: .025 Come accennato in precedenza, questa \u00e8 la deviazione minima richiesta per attivare una divisione del movimento. In questo esempio, qualsiasi valore Z con una deviazione +/- 0,025 mm attiver\u00e0 una divisione. Generalmente i valori predefiniti per queste opzioni sono sufficienti, infatti il valore predefinito di 5 mm per move_check_distance potrebbe essere eccessivo. Tuttavia un utente esperto potrebbe voler sperimentare queste opzioni nel tentativo di ottenere il primo livello ottimale.","title":"Divisione dei movimenti"},{"location":"Bed_Mesh.html#dissolvenza-mesh","text":"Quando la \"dissolvenza\" \u00e8 abilitata, la regolazione Z viene gradualmente eliminata su una distanza definita dalla configurazione. Ci\u00f2 si ottiene applicando piccole regolazioni all'altezza dello strato, aumentando o diminuendo a seconda della forma del letto. Quando la dissolvenza \u00e8 completata, la regolazione Z non viene pi\u00f9 applicata, consentendo alla parte superiore della stampa di essere piatta anzich\u00e9 rispecchiare la forma del letto. La dissolvenza pu\u00f2 anche avere alcuni tratti indesiderati, se dissolve troppo rapidamente pu\u00f2 causare artefatti visibili sulla stampa. Inoltre, se il tuo letto \u00e8 notevolmente deformato, la dissolvenza pu\u00f2 ridurre o allungare l'altezza Z della stampa. In quanto tale, la dissolvenza \u00e8 disabilitata per impostazione predefinita. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 fade_start: 1 fade_end: 10 fade_target: 0 fade_start: 1 Valore predefinito: 1 L'altezza Z in cui iniziare la regolazione graduale. \u00c8 una buona idea avere alcuni layer prima di iniziare il processo di dissolvenza. fade_end: 10 Valore predefinito: 0 L'altezza Z in cui deve essere completata la dissolvenza. Se questo valore \u00e8 inferiore a fade_start , la dissolvenza \u00e8 disabilitata. Questo valore pu\u00f2 essere regolato a seconda di quanto \u00e8 deformata la superficie di stampa. Una superficie notevolmente deformata dovrebbe dissolvere su una distanza maggiore. Una superficie quasi piatta potrebbe essere in grado di ridurre questo valore per eliminarlo gradualmente pi\u00f9 rapidamente. 10mm \u00e8 un valore ragionevole per cominciare se si utilizza il valore predefinito di 1 per fade_start . fade_target: 0 Valore predefinito: il valore Z medio della mesh Il fade_target pu\u00f2 essere considerato come un offset Z aggiuntivo applicato all'intero piatto una volta completata la dissolvenza. In generale vorremmo che questo valore fosse 0, tuttavia ci sono circostanze in cui non dovrebbe esserlo. Ad esempio, supponiamo che la posizione di homing sul piatto sia un valore anomalo, ovvero 0,2 mm inferiore all'altezza media rilevata del piatto. Se fade_target \u00e8 0, la dissolvenza ridurr\u00e0 la stampa in media di 0,2 mm sul piano. Impostando fade_target su .2, l'area home si espander\u00e0 di 0,2 mm, tuttavia, il resto del piatto verr\u00e0 dimensionato accuratamente. Generalmente \u00e8 una buona idea lasciare \"fade_target\" fuori dalla configurazione in modo da utilizzare l'altezza media della mesh, tuttavia potrebbe essere preferibile regolare manualmente il target di dissolvenza se si desidera stampare su una porzione specifica del piano.","title":"Dissolvenza Mesh"},{"location":"Bed_Mesh.html#configuring-the-zero-reference-position","text":"Many probes are susceptible to \"drift\", ie: inaccuracies in probing introduced by heat or interference. This can make calculating the probe's z-offset challenging, particularly at different bed temperatures. As such, some printers use an endstop for homing the Z axis and a probe for calibrating the mesh. In this configuration it is possible offset the mesh so that the (X, Y) reference position applies zero adjustment. The reference postion should be the location on the bed where a Z_ENDSTOP_CALIBRATE paper test is performed. The bed_mesh module provides the zero_reference_position option for specifying this coordinate: [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 zero_reference_position: 125, 110 probe_count: 5, 3 zero_reference_position: Default Value: None (disabled) The zero_reference_position expects an (X, Y) coordinate matching that of the reference position described above. If the coordinate lies within the mesh then the mesh will be offset so the reference position applies zero adjustment. If the coordinate lies outside of the mesh then the coordinate will be probed after calibration, with the resulting z-value used as the z-offset. Note that this coordinate must NOT be in a location specified as a faulty_region if a probe is necessary.","title":"Configuring the zero reference position"},{"location":"Bed_Mesh.html#the-deprecated-relative_reference_index","text":"Existing configurations using the relative_reference_index option must be updated to use the zero_reference_position . The response to the BED_MESH_OUTPUT PGP=1 gcode command will include the (X, Y) coordinate associated with the index; this position may be used as the value for the zero_reference_position . The output will look similar to the following: // bed_mesh: generated points // Index | Tool Adjusted | Probe // 0 | (1.0, 1.0) | (24.0, 6.0) // 1 | (36.7, 1.0) | (59.7, 6.0) // 2 | (72.3, 1.0) | (95.3, 6.0) // 3 | (108.0, 1.0) | (131.0, 6.0) ... (additional generated points) // bed_mesh: relative_reference_index 24 is (131.5, 108.0) Note: The above output is also printed in klippy.log during initialization. Using the example above we see that the relative_reference_index is printed along with its coordinate. Thus the zero_reference_position is 131.5, 108 .","title":"The deprecated relative_reference_index"},{"location":"Bed_Mesh.html#regioni-difettose","text":"\u00c8 possibile che alcune aree di un piatto riportino risultati imprecisi durante il sondaggio a causa di un \"guasto\" in punti specifici. Il miglior esempio di ci\u00f2 sono i piatti con serie di magneti integrati utilizzati per trattenere le lamiere di acciaio rimovibili. Il campo magnetico su e intorno a questi magneti pu\u00f2 causare l'attivazione di una sonda induttiva a una distanza maggiore o minore di quanto sarebbe altrimenti, risultando in una mesh che non rappresenta accuratamente la superficie in queste posizioni. Nota: questo non deve essere confuso con la distorsione della posizione della sonda, che produce risultati imprecisi sull'intero letto. Le opzioni faulty_region possono essere configurate per compensare questo effetto. Se un punto generato si trova all'interno di una regione difettosa, la mesh del letto tenter\u00e0 di sondare fino a 4 punti ai confini di questa regione. Questi valori sondati verranno mediati e inseriti nella mesh come valore Z alla coordinata generata (X, Y). [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 faulty_region_1_min: 130.0, 0.0 faulty_region_1_max: 145.0, 40.0 faulty_region_2_min: 225.0, 0.0 faulty_region_2_max: 250.0, 25.0 faulty_region_3_min: 165.0, 95.0 faulty_region_3_max: 205.0, 110.0 faulty_region_4_min: 30.0, 170.0 faulty_region_4_max: 45.0, 210.0 faulty_region_{1...99}_min faulty_region_{1..99}_max Valore predefinito: Nessuno (disabilitato) Le regioni difettose sono definite in modo simile a quello della mesh stessa, dove minimo e massimo (X , Y) delle coordinate devono essere specificate per ciascuna regione. Una regione difettosa pu\u00f2 estendersi al di fuori di una mesh, tuttavia i punti alternativi generati saranno sempre all'interno del confine della mesh. Non possono sovrapporsi due regioni. L'immagine seguente illustra come vengono generati i punti di sostituzione quando un punto generato si trova all'interno di una regione difettosa. Le regioni mostrate corrispondono a quelle nella configurazione di esempio sopra. I punti di sostituzione e le relative coordinate sono identificati in verde.","title":"Regioni difettose"},{"location":"Bed_Mesh.html#adaptive-meshes","text":"Adaptive bed meshing is a way to speed up the bed mesh generation by only probing the area of the bed used by the objects being printed. When used, the method will automatically adjust the mesh parameters based on the area occupied by the defined print objects. The adapted mesh area will be computed from the area defined by the boundaries of all the defined print objects so it covers every object, including any margins defined in the configuration. After the area is computed, the number of probe points will be scaled down based on the ratio of the default mesh area and the adapted mesh area. To illustrate this consider the following example: For a 150mmx150mm bed with mesh_min set to 25,25 and mesh_max set to 125,125 , the default mesh area is a 100mmx100mm square. An adapted mesh area of 50,50 means a ratio of 0.5x0.5 between the adapted area and default mesh area. If the bed_mesh configuration specified probe_count as 7x7 , the adapted bed mesh will use 4x4 probe points (7 * 0.5 rounded up). [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 adaptive_margin: 5 adaptive_margin Default Value: 0 Margin (in mm) to add around the area of the bed used by the defined objects. The diagram below shows the adapted bed mesh area with an adaptive_margin of 5mm. The adapted mesh area (area in green) is computed as the used bed area (area in blue) plus the defined margin. By nature, adaptive bed meshes use the objects defined by the Gcode file being printed. Therefore, it is expected that each Gcode file will generate a mesh that probes a different area of the print bed. Therefore, adapted bed meshes should not be re-used. The expectation is that a new mesh will be generated for each print if adaptive meshing is used. It is also important to consider that adaptive bed meshing is best used on machines that can normally probe the entire bed and achieve a maximum variance less than or equal to 1 layer height. Machines with mechanical issues that a full bed mesh normally compensates for may have undesirable results when attempting print moves outside of the probed area. If a full bed mesh has a variance greater than 1 layer height, caution must be taken when using adaptive bed meshes and attempting print moves outside of the meshed area.","title":"Adaptive Meshes"},{"location":"Bed_Mesh.html#surface-scans","text":"Some probes, such as the Eddy Current Probe , are capable of \"scanning\" the surface of the bed. That is, these probes can sample a mesh without lifting the tool between samples. To activate scanning mode, the METHOD=scan or METHOD=rapid_scan probe parameter should be passed in the BED_MESH_CALIBRATE gcode command.","title":"Surface Scans"},{"location":"Bed_Mesh.html#scan-height","text":"The scan height is set by the horizontal_move_z option in [bed_mesh] . In addition it can be supplied with the BED_MESH_CALIBRATE gcode command via the HORIZONTAL_MOVE_Z parameter. The scan height must be sufficiently low to avoid scanning errors. Typically a height of 2mm (ie: HORIZONTAL_MOVE_Z=2 ) should work well, presuming that the probe is mounted correctly. It should be noted that if the probe is more than 4mm above the surface then the results will be invalid. Thus, scanning is not possible on beds with severe surface deviation or beds with extreme tilt that hasn't been corrected.","title":"Scan Height"},{"location":"Bed_Mesh.html#rapid-continuous-scanning","text":"When performing a rapid_scan one should keep in mind that the results will have some amount of error. This error should be low enough to be useful on large print areas with reasonably thick layer heights. Some probes may be more prone to error than others. It is not recommended that rapid mode be used to scan a \"dense\" mesh. Some of the error introduced during a rapid scan may be gaussian noise from the sensor, and a dense mesh will reflect this noise (ie: there will be peaks and valleys). Bed Mesh will attempt to optimize the travel path to provide the best possible result based on the configuration. This includes avoiding faulty regions when collecting samples and \"overshooting\" the mesh when changing direction. This overshoot improves sampling at the edges of a mesh, however it requires that the mesh be configured in a way that allows the tool to travel outside of the mesh. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5 scan_overshoot: 8 scan_overshoot Default Value: 0 (disabled) The maximum amount of travel (in mm) available outside of the mesh. For rectangular beds this applies to travel on the X axis, and for round beds it applies to the entire radius. The tool must be able to travel the amount specified outside of the mesh. This value is used to optimize the travel path when performing a \"rapid scan\". The minimum value that may be specified is 1. The default is no overshoot. If no scan overshoot is configured then travel path optimization will not be applied to changes in direction.","title":"Rapid (Continuous) Scanning"},{"location":"Bed_Mesh.html#gcodes-della-mesh-del-piatto","text":"","title":"GCodes della mesh del piatto"},{"location":"Bed_Mesh.html#calibrazione","text":"BED_MESH_CALIBRATE PROFILE=<name> METHOD=[manual | automatic | scan | rapid_scan] \\ [<probe_parameter>=<value>] [<mesh_parameter>=<value>] [ADAPTIVE=[0|1] \\ [ADAPTIVE_MARGIN=<value>] Default Profile: default Default Method: automatic if a probe is detected, otherwise manual Default Adaptive: 0 Default Adaptive Margin: 0 Avvia la procedura di sondaggio per la calibrazione della mesh del piatto. The mesh will be saved into a profile specified by the PROFILE parameter, or default if unspecified. The METHOD parameter takes one of the following values: METHOD=manual : enables manual probing using the nozzle and the paper test METHOD=automatic : Automatic (standard) probing. This is the default. METHOD=scan : Enables surface scanning. The tool will pause over each position to collect a sample. METHOD=rapid_scan : Enables continuous surface scanning. XY positions are automatically adjusted to include the X and/or Y offsets when a probing method other than manual is selected. \u00c8 possibile specificare parametri mesh per modificare l'area sondata. Sono disponibili i seguenti parametri: Piatti rettangolari (cartesiani): MESH_MIN MESH_MAX PROBE_COUNT Piatti rotondi (delta): MESH_RADIUS MESH_ORIGIN ROUND_PROBE_COUNT Tutti i piatti: MESH_PPS ALGORITHM ADAPTIVE ADAPTIVE_MARGIN Vedere la documentazione di configurazione sopra per i dettagli su come ogni parametro si applica alla mesh.","title":"Calibrazione"},{"location":"Bed_Mesh.html#profili","text":"BED_MESH_PROFILE SAVE=<name> LOAD=<name> REMOVE=<name> Dopo aver eseguito un BED_MESH_CALIBRATE, \u00e8 possibile salvare lo stato della mesh corrente in un profilo denominato. Ci\u00f2 consente di caricare una mesh senza risondare il piatto. Dopo che un profilo \u00e8 stato salvato usando BED_MESH_PROFILE SAVE=<nome> \u00e8 possibile eseguire il gcode SAVE_CONFIG per scrivere il profilo su printer.cfg. I profili possono essere caricati eseguendo BED_MESH_PROFILE LOAD=<name> . Va notato che ogni volta che si verifica un BED_MESH_CALIBRATE, lo stato corrente viene automaticamente salvato nel profilo predefinito . Il profilo predefinito pu\u00f2 essere rimosso come segue: BED_MESH_PROFILE REMOVE=default Qualsiasi altro profilo salvato pu\u00f2 essere rimosso allo stesso modo, sostituendo default con il nome del profilo che desideri rimuovere.","title":"Profili"},{"location":"Bed_Mesh.html#caricamento-del-profilo-predefinito","text":"Le versioni precedenti di bed_mesh caricavano sempre il profilo denominato default all'avvio se era presente. Questo comportamento \u00e8 stato rimosso per consentire all'utente di determinare quando viene caricato un profilo. Se un utente desidera caricare il profilo predefinito , si consiglia di aggiungere BED_MESH_PROFILE LOAD=default alla macro START_PRINT o alla configurazione \"Start G-Code\" del proprio slicer, a seconda di quale sia applicabile. In alternativa, il vecchio comportamento di caricamento di un profilo all'avvio pu\u00f2 essere ripristinato con un [delayed_gcode] : [delayed_gcode bed_mesh_init] initial_duration : .01 gcode : BED_MESH_PROFILE LOAD = default","title":"Caricamento del profilo predefinito"},{"location":"Bed_Mesh.html#output","text":"BED_MESH_OUTPUT PGP=[0 | 1] Invia lo stato della mesh corrente al terminale. Si noti che viene emessa la mesh stessa Il parametro PGP \u00e8 un'abbreviazione per \"Print Generated Points\". Se \u00e8 impostato PGP=1 , i punti sondati generati verranno inviati al terminale: // bed_mesh: generated points // Index | Tool Adjusted | Probe // 0 | (11.0, 1.0) | (35.0, 6.0) // 1 | (62.2, 1.0) | (86.2, 6.0) // 2 | (113.5, 1.0) | (137.5, 6.0) // 3 | (164.8, 1.0) | (188.8, 6.0) // 4 | (216.0, 1.0) | (240.0, 6.0) // 5 | (216.0, 97.0) | (240.0, 102.0) // 6 | (164.8, 97.0) | (188.8, 102.0) // 7 | (113.5, 97.0) | (137.5, 102.0) // 8 | (62.2, 97.0) | (86.2, 102.0) // 9 | (11.0, 97.0) | (35.0, 102.0) // 10 | (11.0, 193.0) | (35.0, 198.0) // 11 | (62.2, 193.0) | (86.2, 198.0) // 12 | (113.5, 193.0) | (137.5, 198.0) // 13 | (164.8, 193.0) | (188.8, 198.0) // 14 | (216.0, 193.0) | (240.0, 198.0) I punti \"Tool Adjusted\" si riferiscono alla posizione dell'ugello per ciascun punto e i punti \"Probe\" si riferiscono alla posizione della sonda. Si noti che quando il probing \u00e8 manuale i punti \"sonda\" si riferiscono sia alla posizione dell'utensile che dell'ugello.","title":"Output"},{"location":"Bed_Mesh.html#cancella-stato-mesh","text":"BED_MESH_CLEAR Questo gcode pu\u00f2 essere utilizzato per cancellare lo stato della mesh interna.","title":"Cancella stato mesh"},{"location":"Bed_Mesh.html#applicare-gli-offset-xy","text":"BED_MESH_OFFSET [X=<value>] [Y=<value>] [ZFADE=<value>] This is useful for printers with multiple independent extruders, as an offset is necessary to produce correct Z adjustment after a tool change. Offsets should be specified relative to the primary extruder. That is, a positive X offset should be specified if the secondary extruder is mounted to the right of the primary extruder, a positive Y offset should be specified if the secondary extruder is mounted \"behind\" the primary extruder, and a positive ZFADE offset should be specified if the secondary extruder's nozzle is above the primary extruder's. Note that a ZFADE offset does NOT directly apply additional adjustment. It is intended to compensate for a gcode offset when mesh fade is enabled. For example, if a secondary extruder is higher than the primary and needs a negative gcode offset, ie: SET_GCODE_OFFSET Z=-.2 , it can be accounted for in bed_mesh with BED_MESH_OFFSET ZFADE=.2 .","title":"Applicare gli offset X/Y"},{"location":"Bed_Mesh.html#bed-mesh-webhooks-apis","text":"","title":"Bed Mesh Webhooks APIs"},{"location":"Bed_Mesh.html#dumping-mesh-data","text":"{\"id\": 123, \"method\": \"bed_mesh/dump_mesh\"} Dumps the configuration and state for the current mesh and all saved profiles. The dump_mesh endpoint takes one optional parameter, mesh_args . This parameter must be an object, where the keys and values are parameters available to BED_MESH_CALIBRATE . This will update the mesh configuration and probe points using the supplied parameters prior to returning the result. It is recommended to omit mesh parameters unless it is desired to visualize the probe points and/or travel path before performing BED_MESH_CALIBRATE .","title":"Dumping mesh data"},{"location":"Bed_Mesh.html#visualization-and-analysis","text":"Most users will likely find that the visualizers included with applications such as Mainsail, Fluidd, and Octoprint are sufficient for basic analysis. However, Klipper's scripts folder contains the graph_mesh.py script that may be used to perform additional visualizations and more detailed analysis, particularly useful for debugging hardware or the results produced by bed_mesh : usage: graph_mesh.py [-h] {list,plot,analyze,dump} ... Graph Bed Mesh Data positional arguments: {list,plot,analyze,dump} list List available plot types plot Plot a specified type analyze Perform analysis on mesh data dump Dump API response to json file options: -h, --help show this help message and exit","title":"Visualization and analysis"},{"location":"Bed_Mesh.html#pre-requisites","text":"Like most graphing tools provided by Klipper, graph_mesh.py requires the matplotlib and numpy python dependencies. In addition, connecting to Klipper via Moonraker's websocket requires the websockets python dependency. While all visualizations can be output to an svg file, most of the visualizations offered by graph_mesh.py are better viewed in live preview mode on a desktop class PC. For example, the 3D visualizations may be rotated and zoomed in preview mode, and the path visualizations can optionally be animated in preview mode.","title":"Pre-requisites"},{"location":"Bed_Mesh.html#plotting-mesh-data","text":"The graph_mesh.py tool can plot several types of visualizations. Available types can be shown by running graph_mesh.py list : graph_mesh.py list points Plot original generated points path Plot probe travel path rapid Plot rapid scan travel path probedz Plot probed Z values meshz Plot mesh Z values overlay Plots the current probed mesh overlaid with a profile delta Plots the delta between current probed mesh and a profile Several options are available when plotting visualizations: usage: graph_mesh.py plot [-h] [-a] [-s] [-p PROFILE_NAME] [-o OUTPUT] <plot type> <input> positional arguments: <plot type> Type of data to graph <input> Path/url to Klipper Socket or path to json file options: -h, --help show this help message and exit -a, --animate Animate paths in live preview -s, --scale-plot Use axis limits reported by Klipper to scale plot X/Y -p PROFILE_NAME, --profile-name PROFILE_NAME Optional name of a profile to plot for 'probedz' -o OUTPUT, --output OUTPUT Output file path Below is a description of each argument: plot type : A required positional argument designating the type of visualization to generate. Must be one of the types output by the graph_mesh.py list command. input : A required positional argument containing a path or url to the input source. This must be one of the following: A path to Klipper's Unix Domain Socket A url to an instance of Moonraker A path to a json file produced by graph_mesh.py dump <input> -a : Optional animation for the path and rapid visualization types. Animations only apply to a live preview. -s : Optionally scales a plot using the axis_minimum and axis_maximum values reported by Klipper's toolhead object when the dump file was generated. -p : A profile name that may be specified when generating the probedz 3D mesh visualization. When generating an overlay or delta visualization this argument must be provided. -o : An optional file path indicating that the script should save the visualization to this location rather than run in preview mode. Images are saved in svg format. For example, to plot an animated rapid path, connecting via Klipper's unix socket: graph_mesh.py plot -a rapid ~/printer_data/comms/klippy.sock Or to plot a 3d visualization of the mesh, connecting via Moonraker: graph_mesh.py plot meshz http://my-printer.local","title":"Plotting Mesh data"},{"location":"Bed_Mesh.html#bed-mesh-analysis","text":"The graph_mesh.py tool may also be used to perform an analysis on the data provided by the bed_mesh/dump_mesh API: graph_mesh.py analyze <input> As with the plot command, the <input> must be a path to Klipper's unix socket, a URL to an instance of Moonraker, or a path to a json file generated by the dump command. To begin, the analysis will perform various checks on the points and probe paths generated by bed_mesh at the time of the dump. This includes the following: The number of probe points generated, without any additions The number of probe points generated including any points generated as the result faulty regions and/or a configured zero reference position. The number of probe points generated when performing a rapid scan. The total number of moves generated for a rapid scan. A validation that the probe points generated for a rapid scan are identical to the probe points generated for a standard probing procedure. A \"backtracking\" check for both the standard probe path and a rapid scan path. Backtracking can be defined as moving to the same position more than once during the probing procedure. Backtracking should never occur during a standard probe. Faulty regions can result in backtracking during a rapid scan in an attempt to avoid entering a faulty region when approaching or leaving a probe location, however should never occur otherwise. Next each probed mesh present in the dump will by analyzed, beginning with the mesh loaded at the time of the dump (if present) and followed by any saved profiles. The following data is extracted: Mesh shape (Min X,Y, Max X,Y Probe Count) Mesh Z range, (Minimum Z, Maximum Z) Mean Z value in the mesh Standard Deviation of the Z values in the Mesh In addition to the above, a delta analysis is performed between meshes with the same shape, reporting the following: The range of the delta between to meshes (Minimum and Maximum) The mean delta Standard Deviation of the delta The absolute maximum difference The absolute mean","title":"Bed Mesh Analysis"},{"location":"Bed_Mesh.html#save-mesh-data-to-a-file","text":"The dump command may be used to save the response to a file which can be shared for analysis when troubleshooting: graph_mesh.py dump -o <output file name> <input> The <input> should be a path to Klipper's unix socket or a URL to an instance of Moonraker. The -o option may be used to specify the path to the output file. If omitted, the file will be saved in the working directory, with a file name in the following format: klipper-bedmesh-{year}{month}{day}{hour}{minute}{second}.json","title":"Save mesh data to a file"},{"location":"Benchmarks.html","text":"Benchmark \u00b6 Questo documento descrive i benchmark di Klipper. Benchmark del microcontrollore \u00b6 Questa sezione descrive il meccanismo utilizzato per generare i benchmark della velocit\u00e0 di passaggio del microcontrollore Klipper. L'obiettivo principale dei benchmark \u00e8 fornire un meccanismo coerente per misurare l'impatto delle modifiche alla codifica all'interno del software. Un obiettivo secondario \u00e8 fornire metriche di alto livello per confrontare le prestazioni tra i chip e tra le piattaforme software. Il benchmark dello step rate \u00e8 progettato per trovare la velocit\u00e0 di stepping massima che l'hardware e il software possono raggiungere. Questa velocit\u00e0 di stepping del benchmark non \u00e8 raggiungibile nell'uso quotidiano poich\u00e9 Klipper ha bisogno di eseguire altre attivit\u00e0 (ad esempio, comunicazione mcu/host, lettura della temperatura, controllo endstop) in qualsiasi utilizzo nel mondo reale. In generale, i pin per i test di benchmark sono scelti per far lampeggiare LED o altri pin innocui. Verifica sempre che sia sicuro guidare i pin configurati prima di eseguire un benchmark. Non \u00e8 consigliabile pilotare uno stepper reale durante un benchmark. Test di riferimento della frequenza di passi \u00b6 Il test viene eseguito utilizzando lo strumento console.py (descritto in ). Il microcontrollore \u00e8 configurato per la particolare piattaforma hardware (vedi sotto) e quindi quanto segue viene tagliato e incollato nella finestra del terminale console.py: SET start_clock {clock+freq} SET ticks 1000 reset_step_clock oid=0 clock={start_clock} set_next_step_dir oid=0 dir=0 queue_step oid=0 interval={ticks} count=60000 add=0 set_next_step_dir oid=0 dir=1 queue_step oid=0 interval=3000 count=1 add=0 reset_step_clock oid=1 clock={start_clock} set_next_step_dir oid=1 dir=0 queue_step oid=1 interval={ticks} count=60000 add=0 set_next_step_dir oid=1 dir=1 queue_step oid=1 interval=3000 count=1 add=0 reset_step_clock oid=2 clock={start_clock} set_next_step_dir oid=2 dir=0 queue_step oid=2 interval={ticks} count=60000 add=0 set_next_step_dir oid=2 dir=1 queue_step oid=2 interval=3000 count=1 add=0 Quanto sopra testa tre stepper che fanno un passo simultaneo. Se l'esecuzione di quanto sopra comporta un errore \"Rescheduled timer in the past\" o \"Stepper too far in past\", indica che il parametro ticks \u00e8 troppo basso (risulta in una velocit\u00e0 di incremento troppo veloce). L'obiettivo \u00e8 trovare l'impostazione pi\u00f9 bassa del parametro tick che si traduca in modo affidabile in un completamento positivo del test. Dovrebbe essere possibile dividere in due il parametro tick fino a trovare un valore stabile. In caso di errore, \u00e8 possibile copiare e incollare quanto segue per cancellare l'errore in preparazione per il test successivo: clear_shutdown Per ottenere i benchmark del singolo stepper, viene utilizzata la stessa sequenza di configurazione, ma solo il primo blocco del test precedente viene tagliato e incollato nella finestra di console.py. Per produrre i benchmark trovati nel documento Features , il numero totale di passi al secondo viene calcolato moltiplicando il numero di stepper attivi per la frequenza nominale mcu e dividendo per il parametro tick finale. I risultati vengono arrotondati alla K pi\u00f9 vicina. Ad esempio, con tre stepper attivi: ECHO Test result is: {\"%.0fK\" % (3. * freq / ticks / 1000.)} I benchmark vengono eseguiti con parametri adatti ai driver TMC. Per i microcontrollori che supportano STEPPER_BOTH_EDGE=1 (come riportato nella riga MCU config al primo avvio di console.py) usa step_pulse_duration=0 e invert_step=-1 per abilitare lo stepping ottimizzato su entrambi i bordi del impulso di passo. Per altri microcontrollori usa un step_pulse_duration corrispondente a 100ns. Benchmark rateo passi AVR \u00b6 La seguente sequenza di configurazione viene utilizzata sui chip AVR: allocate_oids count=3 config_stepper oid=0 step_pin=PA5 dir_pin=PA4 invert_step=0 step_pulse_ticks=32 config_stepper oid=1 step_pin=PA3 dir_pin=PA2 invert_step=0 step_pulse_ticks=32 config_stepper oid=2 step_pin=PC7 dir_pin=PC6 invert_step=0 step_pulse_ticks=32 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc avr-gcc (GCC) 5.4.0 . Entrambi i test a 16Mhz e 20Mhz sono stati eseguiti utilizzando simulavr configurato per un atmega644p (i test precedenti hanno confermato i risultati del simulavr match test su entrambi un 16Mhz at90usb e un 16Mhz atmega2560). avr ticks 1 stepper 102 3 stepper 486 Benchmark rateo passi Arduino Due \u00b6 Sul Due viene utilizzata la seguente sequenza di configurazione: allocate_oids count=3 config_stepper oid=0 step_pin=PB27 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PB26 dir_pin=PC30 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PA21 dir_pin=PC30 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . sam3x8e ticks 1 stepper 66 3 stepper 257 Benchmark step rate Duet Maestro \u00b6 La seguente sequenza di configurazione viene utilizzata su Duet Maestro: allocate_oids count=3 config_stepper oid=0 step_pin=PC26 dir_pin=PC18 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PC26 dir_pin=PA8 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PC26 dir_pin=PB4 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . sam4s8c ticks 1 stepper 71 3 stepper 260 Benchmark step rate Duet Wifi \u00b6 La seguente sequenza di configurazione viene utilizzata su Duet Wifi: allocate_oids count=3 config_stepper oid=0 step_pin=PD6 dir_pin=PD11 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PD7 dir_pin=PD12 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PD8 dir_pin=PD13 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con gcc versione gcc versione 10.3.1 20210621 (rilascio) (GNU Arm Embedded Toolchain 10.3-2021.07) . sam4e8e ticks 1 stepper 48 3 stepper 215 Benchmark step rate Beaglebone PRU \u00b6 Sulla PRU viene utilizzata la seguente sequenza di configurazione: allocate_oids count=3 config_stepper oid=0 step_pin=gpio0_23 dir_pin=gpio1_12 invert_step=0 step_pulse_ticks=20 config_stepper oid=1 step_pin=gpio1_15 dir_pin=gpio0_26 invert_step=0 step_pulse_ticks=20 config_stepper oid=2 step_pin=gpio0_22 dir_pin=gpio2_1 invert_step=0 step_pulse_ticks=20 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc pru-gcc (GCC) 8.0.0 20170530 (sperimentale) . pru ticks 1 stepper 231 3 stepper 847 Benchmark step rate STM32F042 \u00b6 La seguente sequenza di configurazione viene utilizzata sull'STM32F042: allocate_oids count=3 config_stepper oid=0 step_pin=PA1 dir_pin=PA2 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PA3 dir_pin=PA2 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PB8 dir_pin=PA2 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . stm32f042 ticks 1 stepper 59 3 stepper 249 Benchmark step rate STM32F103 \u00b6 Sull'STM32F103 viene utilizzata la seguente sequenza di configurazione: allocate_oids count=3 config_stepper oid=0 step_pin=PC13 dir_pin=PB5 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PB3 dir_pin=PB6 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PA4 dir_pin=PB7 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . stm32f103 ticks 1 stepper 61 3 stepper 264 Benchmark step rate STM32F4 \u00b6 Sull'STM32F4 viene utilizzata la seguente sequenza di configurazione: allocate_oids count=3 config_stepper oid=0 step_pin=PA5 dir_pin=PB5 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PB2 dir_pin=PB6 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PB3 dir_pin=PB7 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . I risultati dell'STM32F407 sono stati ottenuti eseguendo un binario STM32F407 su un STM32F446 (e quindi utilizzando un clock a 168 Mhz). stm32f446 ticks 1 stepper 46 3 stepper 205 stm32f407 ticks 1 stepper 46 3 stepper 205 STM32H7 benchmark della velocit\u00e0 di step \u00b6 La seguente sequenza di configurazione viene utilizzata su un STM32H743VIT6: allocate_oids count=3 config_stepper oid=0 step_pin=PD4 dir_pin=PD3 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PA15 dir_pin=PA8 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PE2 dir_pin=PE3 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 00191b5c con versione gcc arm-none-eabi-gcc (15:8-2019-q3-1+b1) 8.3.1 20190703 (release) [gcc-8-branch revisione 273027] . stm32h7 ticks 1 stepper 44 3 stepper 198 Benchmark step rate STM32G0B1 \u00b6 Sull'STM32G0B1 viene utilizzata la seguente sequenza di configurazione: allocate_oids count=3 config_stepper oid=0 step_pin=PB13 dir_pin=PB12 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PB10 dir_pin=PB2 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PB0 dir_pin=PC5 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 247cd753 con versione gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . stm32g0b1 ticks 1 stepper 58 3 stepper 243 Benchmark step rate LPC176x \u00b6 La seguente sequenza di configurazione viene utilizzata sull'LPC176x: allocate_oids count=3 config_stepper oid=0 step_pin=P1.20 dir_pin=P1.18 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=P1.21 dir_pin=P1.18 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=P1.23 dir_pin=P1.18 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . I risultati a 120 Mhz LPC1769 sono stati ottenuti overclockando un LPC1768 a 120 Mhz. lpc1768 ticks 1 stepper 52 3 stepper 222 lpc1769 ticks 1 stepper 51 3 stepper 222 Benchmark step rate SAMD21 \u00b6 La seguente sequenza di configurazione viene utilizzata sul SAMD21: allocate_oids count=3 config_stepper oid=0 step_pin=PA27 dir_pin=PA20 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PB3 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PA17 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 su un microcontrollore SAMD21G18. samd21 ticks 1 stepper 70 3 stepper 306 Benchmark step rate SAMD51 \u00b6 La seguente sequenza di configurazione viene utilizzata sul SAMD51: allocate_oids count=3 config_stepper oid=0 step_pin=PA22 dir_pin=PA20 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PA22 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PA22 dir_pin=PA19 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 su un microcontrollore SAMD51J19A. samd51 ticks 1 stepper 39 3 stepper 191 1 stepper (200Mhz) 39 3 stepper (200Mhz) 181 SAME70 step rate benchmark \u00b6 The following configuration sequence is used on the SAME70: allocate_oids count=3 config_stepper oid=0 step_pin=PC18 dir_pin=PB5 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PC16 dir_pin=PD10 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PC28 dir_pin=PA4 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 The test was last run on commit 34e9ea55 with gcc version arm-none-eabi-gcc (NixOS 10.3-2021.10) 10.3.1 on a SAME70Q20B micro-controller. same70 ticks 1 stepper 45 3 stepper 190 Benchmark della velocit\u00e0 di passo AR100 \u00b6 La seguente sequenza di configurazione viene utilizzata sulla CPU AR100 (Allwinner A64): allocate_oids count=3 config_stepper oid=0 step_pin=PL10 dir_pin=PE14 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PL11 dir_pin=PE15 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PL12 dir_pin=PE16 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 The test was last run on commit b7978d37 with gcc version or1k-linux-musl-gcc (GCC) 9.2.0 on an Allwinner A64-H micro-controller. AR100 R_PIO ticks 1 stepper 85 3 stepper 359 RPxxxx step rate benchmark \u00b6 The following configuration sequence is used on the RP2040 and RP2350: allocate_oids count=3 config_stepper oid=0 step_pin=gpio25 dir_pin=gpio3 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=gpio26 dir_pin=gpio4 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=gpio27 dir_pin=gpio5 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 The test was last run on commit f6718291 with gcc version arm-none-eabi-gcc (Fedora 14.1.0-1.fc40) 14.1.0 on Raspberry Pi Pico and Pico 2 boards. rp2040 (*) ticks 1 stepper 5 3 stepper 22 rp2350 ticks 1 stepper 36 3 stepper 169 (*) Note that the reported rp2040 ticks are relative to a 12Mhz scheduling timer and do not correspond to its 125Mhz internal ARM processing rate. It is expected that 5 scheduling ticks corresponds to ~47 ARM core cycles and 22 scheduling ticks corresponds to ~224 ARM core cycles. Benchmark step rate MCU Linux \u00b6 La seguente sequenza di configurazione viene utilizzata su un Raspberry Pi: allocate_oids count=3 config_stepper oid=0 step_pin=gpio2 dir_pin=gpio3 invert_step=0 step_pulse_ticks=5 config_stepper oid=1 step_pin=gpio4 dir_pin=gpio5 invert_step=0 step_pulse_ticks=5 config_stepper oid=2 step_pin=gpio6 dir_pin=gpio17 invert_step=0 step_pulse_ticks=5 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc gcc (Raspbian 8.3.0-6+rpi1) 8.3.0 su un Raspberry Pi 3 (revisione a02082). \u00c8 stato difficile ottenere risultati stabili in questo benchmark. Linux (RPi3) ticks 1 stepper 160 3 stepper 380 Benchmark dispacciamento comandi \u00b6 Il benchmark di invio dei comandi verifica quanti comandi \"fittizi\" possono elaborare il microcontrollore. \u00c8 principalmente un test del meccanismo di comunicazione hardware. Il test viene eseguito utilizzando lo strumento console.py (descritto in ). Quanto segue \u00e8 taglia e incolla nella finestra del terminale console.py: DELAY {clock + 2*freq} get_uptime FLOOD 100000 0.0 debug_nop get_uptime Al termine del test, determinare la differenza tra gli orologi riportati nei due messaggi di risposta \"uptime\". Il numero totale di comandi al secondo \u00e8 quindi 100000 * mcu_frequency / clock_diff . Nota che questo test potrebbe saturare la capacit\u00e0 USB/CPU di un Raspberry Pi. Se \u00e8 in esecuzione su un computer host Raspberry Pi, Beaglebone o simile, aumenta il ritardo (ad esempio, DELAY {clock + 20*freq} get_uptime ). Ove applicabile, i benchmark seguenti riguardano console.py in esecuzione su una macchina di classe desktop con il dispositivo connesso tramite un hub ad alta velocit\u00e0. MCU Rateo Build Build compiler stm32f042 (CAN) 18K c105adc8 arm-none-eabi-gcc (GNU Tools 7-2018-q3-update) 7.3.1 atmega2560 (serial) 23K b161a69e avr-gcc (GCC) 4.8.1 sam3x8e (serial) 23K b161a69e arm-none-eabi-gcc (Fedora 7.1.0-5.fc27) 7.1.0 at90usb1286 (USB) 75K 01d2183f avr-gcc (GCC) 5.4.0 ar100 (seriale) 138K 08d037c6 or1k-linux-musl-gcc 9.3.0 samd21 (USB) 223K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 pru (shared memory) 260K c5968a08 pru-gcc (GCC) 8.0.0 20170530 (experimental) stm32f103 (USB) 355K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 sam3x8e (USB) 418K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 lpc1768 (USB) 534K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 lpc1769 (USB) 628K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 sam4s8c (USB) 650K 8d4a5c16 arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 samd51 (USB) 864K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 stm32f446 (USB) 870K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 rp2040 (USB) 885K f6718291 arm-none-eabi-gcc (Fedora 14.1.0-1.fc40) 14.1.0 rp2350 (USB) 885K f6718291 arm-none-eabi-gcc (Fedora 14.1.0-1.fc40) 14.1.0 Benchmark Host \u00b6 \u00c8 possibile eseguire test di temporizzazione sul software host utilizzando il meccanismo di elaborazione \"batch mode\" (descritto in ). Questo viene in genere fatto scegliendo un file G-Code grande e complesso e calcolando il tempo impiegato dal software host per elaborarlo. Per esempio: time ~/klippy-env/bin/python ./klippy/klippy.py config/example-cartesian.cfg -i something_complex.gcode -o /dev/null -d out/klipper.dict","title":"Benchmark"},{"location":"Benchmarks.html#benchmark","text":"Questo documento descrive i benchmark di Klipper.","title":"Benchmark"},{"location":"Benchmarks.html#benchmark-del-microcontrollore","text":"Questa sezione descrive il meccanismo utilizzato per generare i benchmark della velocit\u00e0 di passaggio del microcontrollore Klipper. L'obiettivo principale dei benchmark \u00e8 fornire un meccanismo coerente per misurare l'impatto delle modifiche alla codifica all'interno del software. Un obiettivo secondario \u00e8 fornire metriche di alto livello per confrontare le prestazioni tra i chip e tra le piattaforme software. Il benchmark dello step rate \u00e8 progettato per trovare la velocit\u00e0 di stepping massima che l'hardware e il software possono raggiungere. Questa velocit\u00e0 di stepping del benchmark non \u00e8 raggiungibile nell'uso quotidiano poich\u00e9 Klipper ha bisogno di eseguire altre attivit\u00e0 (ad esempio, comunicazione mcu/host, lettura della temperatura, controllo endstop) in qualsiasi utilizzo nel mondo reale. In generale, i pin per i test di benchmark sono scelti per far lampeggiare LED o altri pin innocui. Verifica sempre che sia sicuro guidare i pin configurati prima di eseguire un benchmark. Non \u00e8 consigliabile pilotare uno stepper reale durante un benchmark.","title":"Benchmark del microcontrollore"},{"location":"Benchmarks.html#test-di-riferimento-della-frequenza-di-passi","text":"Il test viene eseguito utilizzando lo strumento console.py (descritto in ). Il microcontrollore \u00e8 configurato per la particolare piattaforma hardware (vedi sotto) e quindi quanto segue viene tagliato e incollato nella finestra del terminale console.py: SET start_clock {clock+freq} SET ticks 1000 reset_step_clock oid=0 clock={start_clock} set_next_step_dir oid=0 dir=0 queue_step oid=0 interval={ticks} count=60000 add=0 set_next_step_dir oid=0 dir=1 queue_step oid=0 interval=3000 count=1 add=0 reset_step_clock oid=1 clock={start_clock} set_next_step_dir oid=1 dir=0 queue_step oid=1 interval={ticks} count=60000 add=0 set_next_step_dir oid=1 dir=1 queue_step oid=1 interval=3000 count=1 add=0 reset_step_clock oid=2 clock={start_clock} set_next_step_dir oid=2 dir=0 queue_step oid=2 interval={ticks} count=60000 add=0 set_next_step_dir oid=2 dir=1 queue_step oid=2 interval=3000 count=1 add=0 Quanto sopra testa tre stepper che fanno un passo simultaneo. Se l'esecuzione di quanto sopra comporta un errore \"Rescheduled timer in the past\" o \"Stepper too far in past\", indica che il parametro ticks \u00e8 troppo basso (risulta in una velocit\u00e0 di incremento troppo veloce). L'obiettivo \u00e8 trovare l'impostazione pi\u00f9 bassa del parametro tick che si traduca in modo affidabile in un completamento positivo del test. Dovrebbe essere possibile dividere in due il parametro tick fino a trovare un valore stabile. In caso di errore, \u00e8 possibile copiare e incollare quanto segue per cancellare l'errore in preparazione per il test successivo: clear_shutdown Per ottenere i benchmark del singolo stepper, viene utilizzata la stessa sequenza di configurazione, ma solo il primo blocco del test precedente viene tagliato e incollato nella finestra di console.py. Per produrre i benchmark trovati nel documento Features , il numero totale di passi al secondo viene calcolato moltiplicando il numero di stepper attivi per la frequenza nominale mcu e dividendo per il parametro tick finale. I risultati vengono arrotondati alla K pi\u00f9 vicina. Ad esempio, con tre stepper attivi: ECHO Test result is: {\"%.0fK\" % (3. * freq / ticks / 1000.)} I benchmark vengono eseguiti con parametri adatti ai driver TMC. Per i microcontrollori che supportano STEPPER_BOTH_EDGE=1 (come riportato nella riga MCU config al primo avvio di console.py) usa step_pulse_duration=0 e invert_step=-1 per abilitare lo stepping ottimizzato su entrambi i bordi del impulso di passo. Per altri microcontrollori usa un step_pulse_duration corrispondente a 100ns.","title":"Test di riferimento della frequenza di passi"},{"location":"Benchmarks.html#benchmark-rateo-passi-avr","text":"La seguente sequenza di configurazione viene utilizzata sui chip AVR: allocate_oids count=3 config_stepper oid=0 step_pin=PA5 dir_pin=PA4 invert_step=0 step_pulse_ticks=32 config_stepper oid=1 step_pin=PA3 dir_pin=PA2 invert_step=0 step_pulse_ticks=32 config_stepper oid=2 step_pin=PC7 dir_pin=PC6 invert_step=0 step_pulse_ticks=32 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc avr-gcc (GCC) 5.4.0 . Entrambi i test a 16Mhz e 20Mhz sono stati eseguiti utilizzando simulavr configurato per un atmega644p (i test precedenti hanno confermato i risultati del simulavr match test su entrambi un 16Mhz at90usb e un 16Mhz atmega2560). avr ticks 1 stepper 102 3 stepper 486","title":"Benchmark rateo passi AVR"},{"location":"Benchmarks.html#benchmark-rateo-passi-arduino-due","text":"Sul Due viene utilizzata la seguente sequenza di configurazione: allocate_oids count=3 config_stepper oid=0 step_pin=PB27 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PB26 dir_pin=PC30 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PA21 dir_pin=PC30 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . sam3x8e ticks 1 stepper 66 3 stepper 257","title":"Benchmark rateo passi Arduino Due"},{"location":"Benchmarks.html#benchmark-step-rate-duet-maestro","text":"La seguente sequenza di configurazione viene utilizzata su Duet Maestro: allocate_oids count=3 config_stepper oid=0 step_pin=PC26 dir_pin=PC18 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PC26 dir_pin=PA8 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PC26 dir_pin=PB4 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . sam4s8c ticks 1 stepper 71 3 stepper 260","title":"Benchmark step rate Duet Maestro"},{"location":"Benchmarks.html#benchmark-step-rate-duet-wifi","text":"La seguente sequenza di configurazione viene utilizzata su Duet Wifi: allocate_oids count=3 config_stepper oid=0 step_pin=PD6 dir_pin=PD11 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PD7 dir_pin=PD12 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PD8 dir_pin=PD13 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con gcc versione gcc versione 10.3.1 20210621 (rilascio) (GNU Arm Embedded Toolchain 10.3-2021.07) . sam4e8e ticks 1 stepper 48 3 stepper 215","title":"Benchmark step rate Duet Wifi"},{"location":"Benchmarks.html#benchmark-step-rate-beaglebone-pru","text":"Sulla PRU viene utilizzata la seguente sequenza di configurazione: allocate_oids count=3 config_stepper oid=0 step_pin=gpio0_23 dir_pin=gpio1_12 invert_step=0 step_pulse_ticks=20 config_stepper oid=1 step_pin=gpio1_15 dir_pin=gpio0_26 invert_step=0 step_pulse_ticks=20 config_stepper oid=2 step_pin=gpio0_22 dir_pin=gpio2_1 invert_step=0 step_pulse_ticks=20 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc pru-gcc (GCC) 8.0.0 20170530 (sperimentale) . pru ticks 1 stepper 231 3 stepper 847","title":"Benchmark step rate Beaglebone PRU"},{"location":"Benchmarks.html#benchmark-step-rate-stm32f042","text":"La seguente sequenza di configurazione viene utilizzata sull'STM32F042: allocate_oids count=3 config_stepper oid=0 step_pin=PA1 dir_pin=PA2 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PA3 dir_pin=PA2 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PB8 dir_pin=PA2 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . stm32f042 ticks 1 stepper 59 3 stepper 249","title":"Benchmark step rate STM32F042"},{"location":"Benchmarks.html#benchmark-step-rate-stm32f103","text":"Sull'STM32F103 viene utilizzata la seguente sequenza di configurazione: allocate_oids count=3 config_stepper oid=0 step_pin=PC13 dir_pin=PB5 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PB3 dir_pin=PB6 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PA4 dir_pin=PB7 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . stm32f103 ticks 1 stepper 61 3 stepper 264","title":"Benchmark step rate STM32F103"},{"location":"Benchmarks.html#benchmark-step-rate-stm32f4","text":"Sull'STM32F4 viene utilizzata la seguente sequenza di configurazione: allocate_oids count=3 config_stepper oid=0 step_pin=PA5 dir_pin=PB5 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PB2 dir_pin=PB6 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PB3 dir_pin=PB7 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . I risultati dell'STM32F407 sono stati ottenuti eseguendo un binario STM32F407 su un STM32F446 (e quindi utilizzando un clock a 168 Mhz). stm32f446 ticks 1 stepper 46 3 stepper 205 stm32f407 ticks 1 stepper 46 3 stepper 205","title":"Benchmark step rate STM32F4"},{"location":"Benchmarks.html#stm32h7-benchmark-della-velocita-di-step","text":"La seguente sequenza di configurazione viene utilizzata su un STM32H743VIT6: allocate_oids count=3 config_stepper oid=0 step_pin=PD4 dir_pin=PD3 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PA15 dir_pin=PA8 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PE2 dir_pin=PE3 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 00191b5c con versione gcc arm-none-eabi-gcc (15:8-2019-q3-1+b1) 8.3.1 20190703 (release) [gcc-8-branch revisione 273027] . stm32h7 ticks 1 stepper 44 3 stepper 198","title":"STM32H7 benchmark della velocit\u00e0 di step"},{"location":"Benchmarks.html#benchmark-step-rate-stm32g0b1","text":"Sull'STM32G0B1 viene utilizzata la seguente sequenza di configurazione: allocate_oids count=3 config_stepper oid=0 step_pin=PB13 dir_pin=PB12 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PB10 dir_pin=PB2 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PB0 dir_pin=PC5 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 247cd753 con versione gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . stm32g0b1 ticks 1 stepper 58 3 stepper 243","title":"Benchmark step rate STM32G0B1"},{"location":"Benchmarks.html#benchmark-step-rate-lpc176x","text":"La seguente sequenza di configurazione viene utilizzata sull'LPC176x: allocate_oids count=3 config_stepper oid=0 step_pin=P1.20 dir_pin=P1.18 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=P1.21 dir_pin=P1.18 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=P1.23 dir_pin=P1.18 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . I risultati a 120 Mhz LPC1769 sono stati ottenuti overclockando un LPC1768 a 120 Mhz. lpc1768 ticks 1 stepper 52 3 stepper 222 lpc1769 ticks 1 stepper 51 3 stepper 222","title":"Benchmark step rate LPC176x"},{"location":"Benchmarks.html#benchmark-step-rate-samd21","text":"La seguente sequenza di configurazione viene utilizzata sul SAMD21: allocate_oids count=3 config_stepper oid=0 step_pin=PA27 dir_pin=PA20 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PB3 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PA17 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 su un microcontrollore SAMD21G18. samd21 ticks 1 stepper 70 3 stepper 306","title":"Benchmark step rate SAMD21"},{"location":"Benchmarks.html#benchmark-step-rate-samd51","text":"La seguente sequenza di configurazione viene utilizzata sul SAMD51: allocate_oids count=3 config_stepper oid=0 step_pin=PA22 dir_pin=PA20 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PA22 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PA22 dir_pin=PA19 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 su un microcontrollore SAMD51J19A. samd51 ticks 1 stepper 39 3 stepper 191 1 stepper (200Mhz) 39 3 stepper (200Mhz) 181","title":"Benchmark step rate SAMD51"},{"location":"Benchmarks.html#same70-step-rate-benchmark","text":"The following configuration sequence is used on the SAME70: allocate_oids count=3 config_stepper oid=0 step_pin=PC18 dir_pin=PB5 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PC16 dir_pin=PD10 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PC28 dir_pin=PA4 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 The test was last run on commit 34e9ea55 with gcc version arm-none-eabi-gcc (NixOS 10.3-2021.10) 10.3.1 on a SAME70Q20B micro-controller. same70 ticks 1 stepper 45 3 stepper 190","title":"SAME70 step rate benchmark"},{"location":"Benchmarks.html#benchmark-della-velocita-di-passo-ar100","text":"La seguente sequenza di configurazione viene utilizzata sulla CPU AR100 (Allwinner A64): allocate_oids count=3 config_stepper oid=0 step_pin=PL10 dir_pin=PE14 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PL11 dir_pin=PE15 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PL12 dir_pin=PE16 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 The test was last run on commit b7978d37 with gcc version or1k-linux-musl-gcc (GCC) 9.2.0 on an Allwinner A64-H micro-controller. AR100 R_PIO ticks 1 stepper 85 3 stepper 359","title":"Benchmark della velocit\u00e0 di passo AR100"},{"location":"Benchmarks.html#rpxxxx-step-rate-benchmark","text":"The following configuration sequence is used on the RP2040 and RP2350: allocate_oids count=3 config_stepper oid=0 step_pin=gpio25 dir_pin=gpio3 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=gpio26 dir_pin=gpio4 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=gpio27 dir_pin=gpio5 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 The test was last run on commit f6718291 with gcc version arm-none-eabi-gcc (Fedora 14.1.0-1.fc40) 14.1.0 on Raspberry Pi Pico and Pico 2 boards. rp2040 (*) ticks 1 stepper 5 3 stepper 22 rp2350 ticks 1 stepper 36 3 stepper 169 (*) Note that the reported rp2040 ticks are relative to a 12Mhz scheduling timer and do not correspond to its 125Mhz internal ARM processing rate. It is expected that 5 scheduling ticks corresponds to ~47 ARM core cycles and 22 scheduling ticks corresponds to ~224 ARM core cycles.","title":"RPxxxx step rate benchmark"},{"location":"Benchmarks.html#benchmark-step-rate-mcu-linux","text":"La seguente sequenza di configurazione viene utilizzata su un Raspberry Pi: allocate_oids count=3 config_stepper oid=0 step_pin=gpio2 dir_pin=gpio3 invert_step=0 step_pulse_ticks=5 config_stepper oid=1 step_pin=gpio4 dir_pin=gpio5 invert_step=0 step_pulse_ticks=5 config_stepper oid=2 step_pin=gpio6 dir_pin=gpio17 invert_step=0 step_pulse_ticks=5 finalize_config crc=0 Il test \u00e8 stato eseguito l'ultima volta su commit 59314d99 con versione gcc gcc (Raspbian 8.3.0-6+rpi1) 8.3.0 su un Raspberry Pi 3 (revisione a02082). \u00c8 stato difficile ottenere risultati stabili in questo benchmark. Linux (RPi3) ticks 1 stepper 160 3 stepper 380","title":"Benchmark step rate MCU Linux"},{"location":"Benchmarks.html#benchmark-dispacciamento-comandi","text":"Il benchmark di invio dei comandi verifica quanti comandi \"fittizi\" possono elaborare il microcontrollore. \u00c8 principalmente un test del meccanismo di comunicazione hardware. Il test viene eseguito utilizzando lo strumento console.py (descritto in ). Quanto segue \u00e8 taglia e incolla nella finestra del terminale console.py: DELAY {clock + 2*freq} get_uptime FLOOD 100000 0.0 debug_nop get_uptime Al termine del test, determinare la differenza tra gli orologi riportati nei due messaggi di risposta \"uptime\". Il numero totale di comandi al secondo \u00e8 quindi 100000 * mcu_frequency / clock_diff . Nota che questo test potrebbe saturare la capacit\u00e0 USB/CPU di un Raspberry Pi. Se \u00e8 in esecuzione su un computer host Raspberry Pi, Beaglebone o simile, aumenta il ritardo (ad esempio, DELAY {clock + 20*freq} get_uptime ). Ove applicabile, i benchmark seguenti riguardano console.py in esecuzione su una macchina di classe desktop con il dispositivo connesso tramite un hub ad alta velocit\u00e0. MCU Rateo Build Build compiler stm32f042 (CAN) 18K c105adc8 arm-none-eabi-gcc (GNU Tools 7-2018-q3-update) 7.3.1 atmega2560 (serial) 23K b161a69e avr-gcc (GCC) 4.8.1 sam3x8e (serial) 23K b161a69e arm-none-eabi-gcc (Fedora 7.1.0-5.fc27) 7.1.0 at90usb1286 (USB) 75K 01d2183f avr-gcc (GCC) 5.4.0 ar100 (seriale) 138K 08d037c6 or1k-linux-musl-gcc 9.3.0 samd21 (USB) 223K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 pru (shared memory) 260K c5968a08 pru-gcc (GCC) 8.0.0 20170530 (experimental) stm32f103 (USB) 355K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 sam3x8e (USB) 418K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 lpc1768 (USB) 534K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 lpc1769 (USB) 628K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 sam4s8c (USB) 650K 8d4a5c16 arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 samd51 (USB) 864K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 stm32f446 (USB) 870K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 rp2040 (USB) 885K f6718291 arm-none-eabi-gcc (Fedora 14.1.0-1.fc40) 14.1.0 rp2350 (USB) 885K f6718291 arm-none-eabi-gcc (Fedora 14.1.0-1.fc40) 14.1.0","title":"Benchmark dispacciamento comandi"},{"location":"Benchmarks.html#benchmark-host","text":"\u00c8 possibile eseguire test di temporizzazione sul software host utilizzando il meccanismo di elaborazione \"batch mode\" (descritto in ). Questo viene in genere fatto scegliendo un file G-Code grande e complesso e calcolando il tempo impiegato dal software host per elaborarlo. Per esempio: time ~/klippy-env/bin/python ./klippy/klippy.py config/example-cartesian.cfg -i something_complex.gcode -o /dev/null -d out/klipper.dict","title":"Benchmark Host"},{"location":"Bootloader_Entry.html","text":"Bootloader Entry \u00b6 \u00c8 possibile impostare Klipper in modo che si riavvii in un Bootloader in uno dei seguenti modi: Richiesta del bootloader \u00b6 Seriale virtuale \u00b6 If a virtual (USB-ACM) serial port is in use, pulsing DTR while at 1200 baud will request the bootloader. Python (with flash_usb ) \u00b6 To enter the bootloader using python (using flash_usb ): > cd klipper/scripts > python3 -c 'import flash_usb as u; u.enter_bootloader(\"<DEVICE>\")' Entering bootloader on <DEVICE> Where <DEVICE> is your serial device, such as /dev/serial.by-id/usb-Klipper[...] or /dev/ttyACM0 Note that if this fails, no output will be printed, success is indicated by printing Entering bootloader on <DEVICE> . Picocom \u00b6 picocom -b 1200 <DEVICE> <Ctrl-A><Ctrl-P> Where <DEVICE> is your serial device, such as /dev/serial.by-id/usb-Klipper[...] or /dev/ttyACM0 <Ctrl-A><Ctrl-P> means holding Ctrl , pressing and releasing a , pressing and releasing p , then releasing Ctrl Physical serial \u00b6 If a physical serial port is being used on the MCU (even if a USB serial adapter is being used to connect to it), sending the string <SPACE><FS><SPACE>Request Serial Bootloader!!<SPACE>~ . <SPACE> is an ASCII literal space, 0x20. <FS> is the ASCII File Separator, 0x1c. Note that this is not a valid message as per the MCU Protocol , but sync characters( ~ ) are still respected. Because this message must be the only thing in the \"block\" it is received in, prefixing an extra sync character can increase reliability if other tools were previously accessing the serial port. Shell \u00b6 stty <BAUD> < /dev/<DEVICE> echo $'~ \\x1c Request Serial Bootloader!! ~' >> /dev/<DEVICE> Where <DEVICE> is your serial port, such as /dev/ttyS0 , or /dev/serial/by-id/gpio-serial2 , and <BAUD> is the baud rate of the serial port, such as 115200 . CANBUS \u00b6 If CANBUS is in use, a special admin message will request the bootloader. This message will be respected even if the device already has a nodeid, and will also be processed if the mcu is shutdown. This method also applies to devices operating in CANBridge mode. Katapult's flashtool.py \u00b6 python3 ./katapult/scripts/flashtool.py -i <CAN_IFACE> -u <UUID> -r Where <CAN_IFACE> is the can interface to use. If using can0 , both the -i and <CAN_IFACE> may be omitted. <UUID> is the UUID of your CAN device. See the CANBUS Documentation for information on finding the CAN UUID of your devices. Entering the bootloader \u00b6 When klipper receives one of the above bootloader requests: If Katapult (formerly known as CANBoot) is available, klipper will request that Katapult stay active on the next boot, then reset the MCU (therefore entering Katapult). If Katapult is not available, klipper will then try to enter a platform-specific bootloader, such as STM32's DFU mode( see note ). In short, Klipper will reboot to Katapult if installed, then a hardware specific bootloader if available. For details about the specific bootloaders on various platforms see Bootloaders Notes \u00b6 STM32 DFU Warning \u00b6 Note that on some boards, like the Octopus Pro v1, entering DFU mode can cause undesired actions (such as powering the heater while in DFU mode). It is recommended to disconnect heaters, and otherwise prevent undesired operations when using DFU mode. Consult the documentation for your board for more details.","title":"Bootloader Entry"},{"location":"Bootloader_Entry.html#bootloader-entry","text":"\u00c8 possibile impostare Klipper in modo che si riavvii in un Bootloader in uno dei seguenti modi:","title":"Bootloader Entry"},{"location":"Bootloader_Entry.html#richiesta-del-bootloader","text":"","title":"Richiesta del bootloader"},{"location":"Bootloader_Entry.html#seriale-virtuale","text":"If a virtual (USB-ACM) serial port is in use, pulsing DTR while at 1200 baud will request the bootloader.","title":"Seriale virtuale"},{"location":"Bootloader_Entry.html#python-with-flash_usb","text":"To enter the bootloader using python (using flash_usb ): > cd klipper/scripts > python3 -c 'import flash_usb as u; u.enter_bootloader(\"<DEVICE>\")' Entering bootloader on <DEVICE> Where <DEVICE> is your serial device, such as /dev/serial.by-id/usb-Klipper[...] or /dev/ttyACM0 Note that if this fails, no output will be printed, success is indicated by printing Entering bootloader on <DEVICE> .","title":"Python (with flash_usb)"},{"location":"Bootloader_Entry.html#picocom","text":"picocom -b 1200 <DEVICE> <Ctrl-A><Ctrl-P> Where <DEVICE> is your serial device, such as /dev/serial.by-id/usb-Klipper[...] or /dev/ttyACM0 <Ctrl-A><Ctrl-P> means holding Ctrl , pressing and releasing a , pressing and releasing p , then releasing Ctrl","title":"Picocom"},{"location":"Bootloader_Entry.html#physical-serial","text":"If a physical serial port is being used on the MCU (even if a USB serial adapter is being used to connect to it), sending the string <SPACE><FS><SPACE>Request Serial Bootloader!!<SPACE>~ . <SPACE> is an ASCII literal space, 0x20. <FS> is the ASCII File Separator, 0x1c. Note that this is not a valid message as per the MCU Protocol , but sync characters( ~ ) are still respected. Because this message must be the only thing in the \"block\" it is received in, prefixing an extra sync character can increase reliability if other tools were previously accessing the serial port.","title":"Physical serial"},{"location":"Bootloader_Entry.html#shell","text":"stty <BAUD> < /dev/<DEVICE> echo $'~ \\x1c Request Serial Bootloader!! ~' >> /dev/<DEVICE> Where <DEVICE> is your serial port, such as /dev/ttyS0 , or /dev/serial/by-id/gpio-serial2 , and <BAUD> is the baud rate of the serial port, such as 115200 .","title":"Shell"},{"location":"Bootloader_Entry.html#canbus","text":"If CANBUS is in use, a special admin message will request the bootloader. This message will be respected even if the device already has a nodeid, and will also be processed if the mcu is shutdown. This method also applies to devices operating in CANBridge mode.","title":"CANBUS"},{"location":"Bootloader_Entry.html#katapults-flashtoolpy","text":"python3 ./katapult/scripts/flashtool.py -i <CAN_IFACE> -u <UUID> -r Where <CAN_IFACE> is the can interface to use. If using can0 , both the -i and <CAN_IFACE> may be omitted. <UUID> is the UUID of your CAN device. See the CANBUS Documentation for information on finding the CAN UUID of your devices.","title":"Katapult's flashtool.py"},{"location":"Bootloader_Entry.html#entering-the-bootloader","text":"When klipper receives one of the above bootloader requests: If Katapult (formerly known as CANBoot) is available, klipper will request that Katapult stay active on the next boot, then reset the MCU (therefore entering Katapult). If Katapult is not available, klipper will then try to enter a platform-specific bootloader, such as STM32's DFU mode( see note ). In short, Klipper will reboot to Katapult if installed, then a hardware specific bootloader if available. For details about the specific bootloaders on various platforms see Bootloaders","title":"Entering the bootloader"},{"location":"Bootloader_Entry.html#notes","text":"","title":"Notes"},{"location":"Bootloader_Entry.html#stm32-dfu-warning","text":"Note that on some boards, like the Octopus Pro v1, entering DFU mode can cause undesired actions (such as powering the heater while in DFU mode). It is recommended to disconnect heaters, and otherwise prevent undesired operations when using DFU mode. Consult the documentation for your board for more details.","title":"STM32 DFU Warning"},{"location":"Bootloaders.html","text":"Bootloader \u00b6 Questo documento fornisce informazioni sui bootloader comuni scoperti sui microcontrollori che sono supportati da Klipper. Il bootloader \u00e8 un software di terze parti che viene eseguito sul microcontrollore quando viene acceso per la prima volta. Viene generalmente utilizzato per eseguire il flashing di una nuova applicazione (ad es. Klipper) sul microcontrollore senza richiedere hardware specializzato. Sfortunatamente, non esiste uno standard a livello di settore per il flashing di un microcontrollore, n\u00e9 esiste un bootloader standard che funzioni su tutti i microcontrollori. Peggio ancora, \u00e8 comune che ogni bootloader richieda una serie di passaggi diversa per eseguire il flashing di un'applicazione. Se si pu\u00f2 eseguire il flashing di un bootloader su un microcontrollore, generalmente si pu\u00f2 anche utilizzare quel meccanismo per eseguire il flashing di un'applicazione, ma \u00e8 necessario prestare attenzione quando si esegue questa operazione poich\u00e9 si potrebbe rimuovere inavvertitamente il bootloader. Al contrario, un bootloader generalmente consentir\u00e0 solo a un utente di eseguire il flashing di un'applicazione. Si consiglia pertanto di utilizzare un bootloader per eseguire il flashing di un'applicazione, ove possibile. Questo documento tenta di descrivere i bootloader comuni, i passaggi necessari per eseguire il flashing di un bootloader e i passaggi necessari per eseguire il flashing di un'applicazione. Questo documento non \u00e8 un riferimento autorevole; \u00e8 inteso come una raccolta di informazioni utili che gli sviluppatori di Klipper hanno accumulato. Microcontrollori AVR \u00b6 In generale, il progetto Arduino \u00e8 un buon riferimento per bootloader e procedure di flashing sui microcontrollori Atmel Atmega a 8 bit. In particolare, il file \"boards.txt\": https://github.com/arduino/Arduino/blob/1.8.5/hardware/arduino/avr/boards.txt \u00e8 un utile riferimento. Per eseguire il flashing di un bootloader, i chip AVR richiedono uno strumento di flashing hardware esterno (che comunica con il chip tramite SPI). Questo strumento pu\u00f2 essere acquistato (ad esempio, eseguire una ricerca sul Web per \"avr isp\", \"arduino isp\" o \"usb tiny isp\"). \u00c8 anche possibile utilizzare un altro Arduino o Raspberry Pi per eseguire il flashing di un bootloader AVR (ad esempio, eseguire una ricerca sul Web per \"programmare un avr utilizzando raspberry pi\"). Gli esempi seguenti sono scritti presupponendo che sia in uso un dispositivo di tipo \"AVR ISP Mk2\". Il programma \"avrdude\" \u00e8 lo strumento pi\u00f9 comune utilizzato per eseguire il flashing dei chip atmega (sia flash del bootloader che flash dell'applicazione). Atmega2560 \u00b6 Questo chip si trova in genere nell'\"Arduino Mega\" ed \u00e8 molto comune nelle schede per stampanti 3D. Per eseguire il flashing del bootloader stesso usa qualcosa come: wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/stk500v2/stk500boot_v2_mega2560.hex' avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xD8:m -U lfuse:w:0xFF:m avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U flash:w:stk500boot_v2_mega2560.hex avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m Per eseguire il flashing di un'applicazione, utilizzare qualcosa come: avrdude -cwiring -patmega2560 -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/klipper.elf.hex:i Atmega1280 \u00b6 Questo chip si trova in genere nelle prime versioni di \"Arduino Mega\". Per eseguire il flashing del bootloader stesso usa qualcosa come: wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/atmega/ATmegaBOOT_168_atmega1280.hex' avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xF5:m -U hfuse:w:0xDA:m -U lfuse:w:0xFF:m avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U flash:w:ATmegaBOOT_168_atmega1280.hex avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m Per eseguire il flashing di un'applicazione, utilizzare qualcosa come: avrdude -carduino -patmega1280 -P/dev/ttyACM0 -b57600 -D -Uflash:w:out/klipper.elf.hex:i Atmega1284p \u00b6 Questo chip si trova comunemente nelle schede per stampanti 3D in stile \"Melzi\". Per eseguire il flashing del bootloader stesso usa qualcosa come: wget 'https://github.com/Lauszus/Sanguino/raw/1.0.2/bootloaders/optiboot/optiboot_atmega1284p.hex' avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xDE:m -U lfuse:w:0xFF:m avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega1284p.hex avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m Per eseguire il flashing di un'applicazione, utilizzare qualcosa come: avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/klipper.elf.hex:i Si noti che un certo numero di schede in stile \"Melzi\" sono precaricate con un bootloader che utilizza una velocit\u00e0 di trasmissione di 57600 baud. In questo caso, per eseguire il flashing di un'applicazione utilizzare invece qualcosa di simile: avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b57600 -D -Uflash:w:out/klipper.elf.hex:i At90usb1286 \u00b6 Questo documento non copre il metodo per eseguire il flashing di un bootloader su At90usb1286 n\u00e9 copre il flashing di applicazioni generali su questo dispositivo. Il dispositivo Teensy++ di pjrc.com viene fornito con un bootloader proprietario. Richiede uno strumento di flashing personalizzato da https://github.com/PaulStoffregen/teensy_loader_cli . Si pu\u00f2 eseguire il flashing di un'applicazione usando qualcosa come: teensy_loader_cli --mcu=at90usb1286 out/klipper.elf.hex -v Atmega168 \u00b6 L'atmega168 ha uno spazio flash limitato. Se si utilizza un bootloader, si consiglia di utilizzare il bootloader Optiboot. Per eseguire il flashing di quel bootloader usa qualcosa come: wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/optiboot/optiboot_atmega168.hex' avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0x04:m -U hfuse:w:0xDD:m -U lfuse:w:0xFF:m avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega168.hex avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m Per eseguire il flashing di un'applicazione tramite il bootloader Optiboot, utilizzare qualcosa come: avrdude -carduino -patmega168 -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/klipper.elf.hex:i Microcontrollori SAM3 (Arduino Due) \u00b6 Non \u00e8 comune utilizzare un bootloader con l'mcu SAM3. Il chip stesso ha una ROM che permette di programmare il flash da porta seriale 3.3V o da USB. Per abilitare la ROM, il pin \"erase\" viene tenuto alto durante un reset, che cancella il contenuto della flash e fa funzionare la ROM. Su un Arduino Due, questa sequenza pu\u00f2 essere realizzata impostando un baud rate di 1200 sulla \"porta usb di programmazione\" (la porta USB pi\u00f9 vicina all'alimentatore). Il codice in https://github.com/shumatech/BOSSA pu\u00f2 essere utilizzato per programmare il SAM3. Si consiglia di utilizzare la versione 1.9 o successiva. Per eseguire il flashing di un'applicazione, utilizzare qualcosa come: bossac -U -p /dev/ttyACM0 -a -e -w out/klipper.bin -v -b bossac -U -p /dev/ttyACM0 -R Microcontrollori SAM4 (Duet Wifi) \u00b6 Non \u00e8 comune utilizzare un bootloader con l'mcu SAM4. Il chip stesso ha una ROM che permette di programmare la memoria flash da porta seriale 3.3V o da USB. Per abilitare la ROM, il pin \"erase\" viene tenuto alto durante un reset, che cancella il contenuto della memoria flash e fa funzionare la ROM. Il codice in https://github.com/shumatech/BOSSA pu\u00f2 essere utilizzato per programmare il SAM4. \u00c8 necessario utilizzare la versione 1.8.0 o successiva. Per eseguire il flashing di un'applicazione, utilizzare qualcosa come: bossac --port=/dev/ttyACM0 -b -U -e -w -v -R out/klipper.bin SAMDC21 micro-controllers (Duet3D Toolboard 1LC) \u00b6 The SAMC21 is flashed via the ARM Serial Wire Debug (SWD) interface. This is commonly done with a dedicated SWD hardware dongle. Alternatively, one can use a Raspberry Pi with OpenOCD . When using OpenOCD with the SAMC21, extra steps must be taken to first put the chip into Cold Plugging mode if the board makes use of the SWD pins for other purposes. If using OpenOCD on a Rasberry Pi, this can be done by running the following commands before invoking OpenOCD. SWCLK=25 SWDIO=24 SRST=18 echo \"Exporting SWCLK and SRST pins.\" echo $SWCLK > /sys/class/gpio/export echo $SRST > /sys/class/gpio/export echo \"out\" > /sys/class/gpio/gpio$SWCLK/direction echo \"out\" > /sys/class/gpio/gpio$SRST/direction echo \"Setting SWCLK low and pulsing SRST.\" echo \"0\" > /sys/class/gpio/gpio$SWCLK/value echo \"0\" > /sys/class/gpio/gpio$SRST/value echo \"1\" > /sys/class/gpio/gpio$SRST/value echo \"Unexporting SWCLK and SRST pins.\" echo $SWCLK > /sys/class/gpio/unexport echo $SRST > /sys/class/gpio/unexport To flash a program with OpenOCD use the following chip config: source [find target/at91samdXX.cfg] Obtain a program; for instance, klipper can be built for this chip. Flash with OpenOCD commands similar to: at91samd chip-erase at91samd bootloader 0 program out/klipper.elf verify Microcontrollori SAMD21 (Arduino Zero) \u00b6 Il bootloader SAMD21 viene caricato in memoria flashing tramite l'interfaccia ARM Serial Wire Debug (SWD). Questo viene fatto comunemente con un dongle hardware SWD dedicato. In alternativa, \u00e8 possibile utilizzare un Raspberry Pi con OpenOCD . Per eseguire il flashing di un bootloader con OpenOCD, utilizzare la seguente configurazione del chip: source [find target/at91samdXX.cfg] Ottieni un bootloader, ad esempio: wget 'https://github.com/arduino/ArduinoCore-samd/raw/1.8.3/bootloaders/zero/samd21_sam_ba.bin' Carica la memoria Flash con comandi OpenOCD simili a: at91samd bootloader 0 program samd21_sam_ba.bin verify Il bootloader pi\u00f9 comune sul SAMD21 \u00e8 quello che si trova sull' \"Arduino Zero\". Utilizza un bootloader da 8KiB (l'applicazione deve essere compilata con un indirizzo iniziale di 8KiB). Si pu\u00f2 entrare in questo bootloader facendo doppio clic sul pulsante di ripristino. Per eseguire il flashing di un'applicazione, utilizzare qualcosa come: bossac -U -p /dev/ttyACM0 --offset=0x2000 -w out/klipper.bin -v -b -R Al contrario, \"Arduino M0\" utilizza un bootloader da 16 KiB (l'applicazione deve essere compilata con un indirizzo iniziale di 16 KiB). Per eseguire il flashing di un'applicazione su questo bootloader, ripristinare il microcontrollore ed eseguire il comando flash entro i primi secondi dall'avvio, qualcosa del tipo: avrdude -c stk500v2 -p atmega2560 -P /dev/ttyACM0 -u -Uflash:w:out/klipper.elf.hex:i Microcontrollori SAMD51 (Adafruit Metro-M4 e simili) \u00b6 Come il SAMD21, il bootloader SAMD51 viene eseguito il flashing tramite l'interfaccia ARM Serial Wire Debug (SWD). Per eseguire il flashing di un bootloader con OpenOCD su un Raspberry Pi utilizzare la seguente configurazione del chip: source [find target/atsame5x.cfg] Ottieni un bootloader: diversi bootloader sono disponibili da https://github.com/adafruit/uf2-samdx1/releases/latest . Per esempio: wget 'https://github.com/adafruit/uf2-samdx1/releases/download/v3.7.0/bootloader-itsybitsy_m4-v3.7.0.bin' Carica la memoria Flash con comandi OpenOCD simili a: at91samd bootloader 0 program bootloader-itsybitsy_m4-v3.7.0.bin verify at91samd bootloader 16384 Il SAMD51 utilizza un bootloader da 16 KiB (l'applicazione deve essere compilata con un indirizzo iniziale di 16 KiB). Per eseguire il flashing di un'applicazione, utilizzare qualcosa come: bossac -U -p /dev/ttyACM0 --offset=0x4000 -w out/klipper.bin -v -b -R Microcontrollori STM32F103 (dispositivi Blue Pill) \u00b6 I dispositivi STM32F103 dispongono di una ROM che pu\u00f2 eseguire il flashing di un bootloader o di un'applicazione tramite seriale a 3,3 V. In genere si collegano i pin PA10 (MCU Rx) e PA9 (MCU Tx) a un adattatore UART da 3,3 V. Per accedere alla ROM, \u00e8 necessario collegare il pin \"boot 0\" in alto e il pin \"boot 1\" in basso, quindi ripristinare il dispositivo. Il pacchetto \"stm32flash\" pu\u00f2 quindi essere utilizzato per eseguire il flashing del dispositivo utilizzando qualcosa come: stm32flash -w out/klipper.bin -v -g 0 /dev/ttyAMA0 Si noti che se si utilizza un Raspberry Pi per la seriale da 3,3 V, il protocollo stm32flash utilizza una modalit\u00e0 di parit\u00e0 seriale che il \"mini UART\" di Raspberry Pi non supporta. Vedere https://www.raspberrypi.com/documentation/computers/configuration.html#configuring-uarts per i dettagli sull'abilitazione dell'uart completo sui pin GPIO di Raspberry Pi. Dopo aver caricato la memoria flash, imposta \"boot 0\" e \"boot 1\" su basso in modo che in futuro ripristini l'avvio da flash. STM32F103 con bootloader stm32duino \u00b6 Il progetto \"stm32duino\" ha un bootloader compatibile con USB - vedere: https://github.com/rogerclarkmelbourne/STM32duino-bootloader Questo bootloader pu\u00f2 essere flashato tramite seriale 3.3V con qualcosa come: wget 'https://github.com/rogerclarkmelbourne/STM32duino-bootloader/raw/master/binaries/generic_boot20_pc13.bin' stm32flash -w generic_boot20_pc13.bin -v -g 0 /dev/ttyAMA0 Questo bootloader utilizza 8KiB di spazio flash (l'applicazione deve essere compilata con un indirizzo iniziale di 8KiB). Caricare in memoria flash un'applicazione con qualcosa come: dfu-util -d 1eaf:0003 -a 2 -R -D out/klipper.bin Il bootloader in genere viene eseguito solo per un breve periodo dopo l'avvio. Potrebbe essere necessario sincronizzare il comando sopra in modo che venga eseguito mentre il bootloader \u00e8 ancora attivo (il bootloader far\u00e0 lampeggiare un led della scheda mentre \u00e8 in esecuzione). In alternativa, imposta il pin \"boot 0\" su basso e il pin \"boot 1\" su alto per rimanere nel bootloader dopo un ripristino. STM32F103 con bootloader HID \u00b6 Il bootloader HID \u00e8 un bootloader compatto e senza driver in grado di eseguire il flashing attraverso USB. \u00c8 inoltre disponibile un fork con build specifiche per SKR Mini E3 1.2 . Per le schede STM32F103 generiche come la blue pill \u00e8 possibile eseguire il flashing del bootloader tramite seriale da 3,3 V utilizzando stm32flash come indicato nella sezione stm32duino sopra, sostituendo il nome del file con il binario del bootloader hid desiderato (ad esempio: hid_generic_pc13.bin per la blue pill ). Non \u00e8 possibile utilizzare stm32flash per SKR Mini E3 poich\u00e9 il pin boot0 \u00e8 collegato direttamente a terra e non disponibile tramite pin header. Si consiglia di utilizzare un STLink V2 con STM32Cubeprogrammer per eseguire il flashing del bootloader. Se non hai accesso a un STLink \u00e8 anche possibile utilizzare un Raspberry Pi e OpenOCD con la seguente configurazione del chip: source [find target/stm32f1x.cfg] Se lo desideri puoi fare un backup della flash corrente con il seguente comando. Tieni presente che il completamento potrebbe richiedere del tempo: flash read_bank 0 btt_skr_mini_e3_backup.bin infine, puoi eseguire il flashing con comandi simili a: stm32f1x mass_erase 0 program hid_btt_skr_mini_e3.bin verify 0x08000000 NOTE: L'esempio sopra cancella il chip, quindi programma il bootloader. Indipendentemente dal metodo scelto per eseguire il flashing, si consiglia di cancellare il chip prima del flashing. Prima di eseguire il flashing di SKR Mini E3 con questo bootloader, dovresti essere consapevole che non sarai pi\u00f9 in grado di aggiornare il firmware tramite la sdcard. You may need to hold down the reset button on the board while launching OpenOCD. It should display something like: Open On-Chip Debugger 0.10.0+dev-01204-gc60252ac-dirty (2020-04-27-16:00) Licensed under GNU GPL v2 For bug reports, read http://openocd.org/doc/doxygen/bugs.html DEPRECATED! use 'adapter speed' not 'adapter_khz' Info : BCM2835 GPIO JTAG/SWD bitbang driver Info : JTAG and SWD modes enabled Info : clock speed 40 kHz Info : SWD DPIDR 0x1ba01477 Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints Info : stm32f1x.cpu: external reset detected Info : starting gdb server for stm32f1x.cpu on 3333 Info : Listening on port 3333 for gdb connections Dopodich\u00e9 puoi rilasciare il pulsante di reset. Questo bootloader richiede 2KiB di spazio flash (l'applicazione deve essere compilata con un indirizzo iniziale di 2KiB). Il programma hid-flash viene utilizzato per caricare un file binario sul bootloader. \u00c8 possibile installare questo software con i seguenti comandi: sudo apt install libusb-1.0 cd ~/klipper/lib/hidflash make Se il bootloader \u00e8 in esecuzione, puoi eseguire il flash con qualcosa del tipo: ~/klipper/lib/hidflash/hid-flash ~/klipper/out/klipper.bin in alternativa, puoi usare make flash per flashare klipper direttamente: make flash FLASH_DEVICE=1209:BEBA O se klipper \u00e8 stato precedentemente flashato: make flash FLASH_DEVICE=/dev/ttyACM0 Potrebbe essere necessario accedere manualmente al bootloader, questo pu\u00f2 essere fatto impostando \"boot 0\" basso e \"boot 1\" alto. Sull'SKR Mini E3 \"Boot 1\" non \u00e8 disponibile, quindi pu\u00f2 essere fatto impostando il pin PA2 basso se hai flashato \"hid_btt_skr_mini_e3.bin\". Questo pin \u00e8 etichettato \"TX0\" sull'intestazione TFT nel documento \"PIN\" di SKR Mini E3. C'\u00e8 un pin di terra accanto a PA2 che puoi utilizzare per abbassare PA2. STM32F103/STM32F072 con bootloader MSC \u00b6 Il bootloader MSC \u00e8 un bootloader senza driver in grado di eseguire il flashing su USB. \u00c8 possibile eseguire il flashing del bootloader tramite seriale da 3,3 V utilizzando stm32flash come indicato nella sezione stm32duino sopra, sostituendo il nome del file con il binario del bootloader MSC desiderato (ad esempio: MSCboot-Bluepill.bin per la blue pill). Per le schede STM32F072 \u00e8 anche possibile eseguire il flashing del bootloader su USB (tramite DFU) con qualcosa del tipo: dfu-util -d 0483:df11 -a 0 -R -D MSCboot-STM32F072.bin -s0x08000000:leave Questo bootloader utilizza 8KiB o 16KiB di spazio flash, vedere la descrizione del bootloader (l'applicazione deve essere compilata con l'indirizzo iniziale corrispondente). Il bootloader pu\u00f2 essere attivato premendo due volte il pulsante di reset della scheda. Non appena il bootloader viene attivato, la scheda appare come una chiavetta USB su cui \u00e8 possibile copiare il file klipper.bin. STM32F103/STM32F0x2 con bootloader CanBoot \u00b6 Il bootloader CanBoot fornisce un'opzione per caricare il firmware Klipper su CANBUS. Il bootloader stesso \u00e8 derivato dal codice sorgente di Klipper. Attualmente CanBoot supporta i modelli STM32F103, STM32F042 e STM32F072. Si consiglia di utilizzare un programmatore ST-Link per eseguire il flashing di CanBoot, tuttavia dovrebbe essere possibile eseguire il flashing utilizzando stm32flash sui dispositivi STM32F103 e \"dfu-util\" sui dispositivi STM32F042/STM32F072. Consulta le sezioni precedenti di questo documento per istruzioni su questi metodi di flashing, sostituendo canboot.bin con il nome del file dove appropriato. Il repository CanBoot collegato sopra fornisce istruzioni per la creazione del bootloader. La prima volta che CanBoot \u00e8 stato flashato, dovrebbe rilevare che non \u00e8 presente alcuna applicazione e accedere al bootloader. Se ci\u00f2 non accade \u00e8 possibile entrare nel bootloader premendo due volte di seguito il pulsante di reset. L'utilit\u00e0 flash_can.py fornita nella cartella lib/canboot pu\u00f2 essere utilizzata per caricare il firmware di Klipper. E' necessario l'UUID del dispositivo per eseguire il flashing. Se non si dispone di un UUID \u00e8 possibile interrogare i nodi che attualmente eseguono il bootloader: python3 flash_can.py -q Ci\u00f2 restituir\u00e0 gli UUID per tutti i nodi collegati non attualmente assegnati a un UUID. Questo dovrebbe includere tutti i nodi attualmente nel bootloader. Una volta che hai un UUID, puoi caricare il firmware con il seguente comando: python3 flash_can.py -i can0 -f ~/klipper/out/klipper.bin -u aabbccddeeff Dove aabbccddeeff \u00e8 sostituito dal tuo UUID. Nota che le opzioni -i e -f possono essere omesse, per impostazione predefinita sono rispettivamente can0 e ~/klipper/out/klipper.bin . Quando crei Klipper per l'uso con CanBoot, seleziona l'opzione Bootloader da 8 KiB. Microcontrollori STM32F4 (SKR Pro 1.1) \u00b6 I microcontrollori STM32F4 sono dotati di un bootloader di sistema integrato in grado di eseguire il flashing tramite USB (tramite DFU), seriale da 3,3 V e vari altri metodi (vedere il documento STM AN2606 per ulteriori informazioni). Alcune schede STM32F4, come SKR Pro 1.1, non sono in grado di accedere al bootloader DFU. Il bootloader HID \u00e8 disponibile per le schede basate su STM32F405/407 nel caso in cui l'utente preferisca eseguire il flashing tramite USB anzich\u00e9 utilizzare la scheda SD. Tieni presente che potrebbe essere necessario configurare e creare una versione specifica per la tua scheda, una build per SKR Pro 1.1 \u00e8 disponibile qui . A meno che la tua scheda non sia compatibile con DFU, il metodo di flashing pi\u00f9 accessibile \u00e8 probabilmente tramite seriale da 3,3 V, che segue la stessa procedura di flash di STM32F103 utilizzando stm32flash . Per esempio: wget https://github.com/Arksine/STM32_HID_Bootloader/releases/download/v0.5-beta/hid_bootloader_SKR_PRO.bin stm32flash -w hid_bootloader_SKR_PRO.bin -v -g 0 /dev/ttyAMA0 Questo bootloader richiede 16Kib di spazio flash sull'STM32F4 (l'applicazione deve essere compilata con un indirizzo iniziale di 16KiB). Come con l'STM32F1, l'STM32F4 utilizza lo strumento hid-flash per caricare i file binari nell'MCU. Consulta le istruzioni sopra per i dettagli su come creare e utilizzare hid-flash. Potrebbe essere necessario inserire manualmente il bootloader, questo pu\u00f2 essere fatto impostando \"boot 0\" basso, \"boot 1\" alto e collegando il dispositivo. Al termine della programmazione, scollegare il dispositivo e impostare \"boot 1\" su basso in modo che l'applicazione venga caricata. Microcontrollori LPC176x (Smoothieboards) \u00b6 Questo documento non descrive il metodo per eseguire il flashing di un bootloader stesso - vedere: http://smoothieware.org/flashing-the-bootloader per ulteriori informazioni su questo argomento. \u00c8 comune che per le Smoothieboard venga fornito con un bootloader da: https://github.com/triffid/LPC17xx-DFU-Bootloader . Quando si utilizza questo bootloader, l'applicazione deve essere compilata con un indirizzo iniziale di 16 KiB. Il modo pi\u00f9 semplice per eseguire il flashing di un'applicazione con questo bootloader \u00e8 copiare il file dell'applicazione (ad es. out/klipper.bin ) in un file denominato firmware.bin su una scheda SD, quindi riavviare il microcontrollore con quella scheda SD. Eseguire OpenOCD su Raspberry PI \u00b6 OpenOCD \u00e8 un pacchetto software in grado di eseguire il flashing e il debug di chip di basso livello. Pu\u00f2 utilizzare i pin GPIO su un Raspberry Pi per comunicare con una variet\u00e0 di chip ARM. Questa sezione descrive come installare e avviare OpenOCD. \u00c8 derivato dalle istruzioni su: https://learn.adafruit.com/programming-microcontrollers-using-openocd-on-raspberry-pi Inizia scaricando e compilando il software (ogni passaggio pu\u00f2 richiedere diversi minuti e il passaggio \"make\" pu\u00f2 richiedere pi\u00f9 di 30 minuti): sudo apt-get update sudo apt-get install autoconf libtool telnet mkdir ~/openocd cd ~/openocd/ git clone http://openocd.zylin.com/openocd cd openocd ./bootstrap ./configure --enable-sysfsgpio --enable-bcm2835gpio --prefix=/home/pi/openocd/install make make install Configurare OpenOCD \u00b6 Crea un file di configurazione OpenOCD: nano ~/openocd/openocd.cfg Utilizzare una configurazione simile alla seguente: # Uses RPi pins: GPIO25 for SWDCLK, GPIO24 for SWDIO, GPIO18 for nRST source [find interface/raspberrypi2-native.cfg] bcm2835gpio_swd_nums 25 24 bcm2835gpio_srst_num 18 transport select swd # Use hardware reset wire for chip resets reset_config srst_only adapter_nsrst_delay 100 adapter_nsrst_assert_width 100 # Specify the chip type source [find target/atsame5x.cfg] # Set the adapter speed adapter_khz 40 # Connect to chip init targets reset halt Collega il Raspberry Pi al chip di destinazione \u00b6 Spegni sia il Raspberry Pi che il chip di destinazione prima del cablaggio! Verificare che il chip di destinazione utilizzi 3,3 V prima di connettersi a un Raspberry Pi! Collega GND, SWDCLK, SWDIO e RST sul chip di destinazione rispettivamente a GND, GPIO25, GPIO24 e GPIO18 sul Raspberry Pi. Quindi accendi il Raspberry Pi e fornisci alimentazione al chip di destinazione. Eseguire OpenOCD \u00b6 Esegui OpenOCD: cd ~/openocd/ sudo ~/openocd/install/bin/openocd -f ~/openocd/openocd.cfg Quanto sopra dovrebbe far s\u00ec che OpenOCD emetta alcuni messaggi di testo e quindi attenda (non dovrebbe tornare immediatamente al prompt della shell Unix). Se OpenOCD termina da solo o se continua a emettere messaggi di testo, ricontrolla il cablaggio. Una volta che OpenOCD \u00e8 in esecuzione ed \u00e8 stabile, \u00e8 possibile inviargli comandi tramite telnet. Apri un'altra sessione ssh ed esegui quanto segue: telnet 127.0.0.1 4444 (Si pu\u00f2 uscire da telnet premendo ctrl+] e quindi eseguendo il comando \"quit\".) OpenOCD e gdb \u00b6 \u00c8 possibile utilizzare OpenOCD con gdb per eseguire il debug di Klipper. I seguenti comandi presuppongono che uno stia eseguendo gdb su una macchina di classe desktop. Aggiungi quanto segue al file di configurazione di OpenOCD: bindto 0.0.0.0 gdb_port 44444 Riavvia OpenOCD sul Raspberry Pi e quindi esegui il seguente comando Unix sul computer desktop: cd /path/to/klipper/ gdb out/klipper.elf All'interno di gdb esegui: target remote octopi:44444 (Sostituisci \"octopi\" con il nome host del Raspberry Pi.) Una volta che gdb \u00e8 in esecuzione, \u00e8 possibile impostare punti di interruzione e ispezionare i registri.","title":"Bootloader"},{"location":"Bootloaders.html#bootloader","text":"Questo documento fornisce informazioni sui bootloader comuni scoperti sui microcontrollori che sono supportati da Klipper. Il bootloader \u00e8 un software di terze parti che viene eseguito sul microcontrollore quando viene acceso per la prima volta. Viene generalmente utilizzato per eseguire il flashing di una nuova applicazione (ad es. Klipper) sul microcontrollore senza richiedere hardware specializzato. Sfortunatamente, non esiste uno standard a livello di settore per il flashing di un microcontrollore, n\u00e9 esiste un bootloader standard che funzioni su tutti i microcontrollori. Peggio ancora, \u00e8 comune che ogni bootloader richieda una serie di passaggi diversa per eseguire il flashing di un'applicazione. Se si pu\u00f2 eseguire il flashing di un bootloader su un microcontrollore, generalmente si pu\u00f2 anche utilizzare quel meccanismo per eseguire il flashing di un'applicazione, ma \u00e8 necessario prestare attenzione quando si esegue questa operazione poich\u00e9 si potrebbe rimuovere inavvertitamente il bootloader. Al contrario, un bootloader generalmente consentir\u00e0 solo a un utente di eseguire il flashing di un'applicazione. Si consiglia pertanto di utilizzare un bootloader per eseguire il flashing di un'applicazione, ove possibile. Questo documento tenta di descrivere i bootloader comuni, i passaggi necessari per eseguire il flashing di un bootloader e i passaggi necessari per eseguire il flashing di un'applicazione. Questo documento non \u00e8 un riferimento autorevole; \u00e8 inteso come una raccolta di informazioni utili che gli sviluppatori di Klipper hanno accumulato.","title":"Bootloader"},{"location":"Bootloaders.html#microcontrollori-avr","text":"In generale, il progetto Arduino \u00e8 un buon riferimento per bootloader e procedure di flashing sui microcontrollori Atmel Atmega a 8 bit. In particolare, il file \"boards.txt\": https://github.com/arduino/Arduino/blob/1.8.5/hardware/arduino/avr/boards.txt \u00e8 un utile riferimento. Per eseguire il flashing di un bootloader, i chip AVR richiedono uno strumento di flashing hardware esterno (che comunica con il chip tramite SPI). Questo strumento pu\u00f2 essere acquistato (ad esempio, eseguire una ricerca sul Web per \"avr isp\", \"arduino isp\" o \"usb tiny isp\"). \u00c8 anche possibile utilizzare un altro Arduino o Raspberry Pi per eseguire il flashing di un bootloader AVR (ad esempio, eseguire una ricerca sul Web per \"programmare un avr utilizzando raspberry pi\"). Gli esempi seguenti sono scritti presupponendo che sia in uso un dispositivo di tipo \"AVR ISP Mk2\". Il programma \"avrdude\" \u00e8 lo strumento pi\u00f9 comune utilizzato per eseguire il flashing dei chip atmega (sia flash del bootloader che flash dell'applicazione).","title":"Microcontrollori AVR"},{"location":"Bootloaders.html#atmega2560","text":"Questo chip si trova in genere nell'\"Arduino Mega\" ed \u00e8 molto comune nelle schede per stampanti 3D. Per eseguire il flashing del bootloader stesso usa qualcosa come: wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/stk500v2/stk500boot_v2_mega2560.hex' avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xD8:m -U lfuse:w:0xFF:m avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U flash:w:stk500boot_v2_mega2560.hex avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m Per eseguire il flashing di un'applicazione, utilizzare qualcosa come: avrdude -cwiring -patmega2560 -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/klipper.elf.hex:i","title":"Atmega2560"},{"location":"Bootloaders.html#atmega1280","text":"Questo chip si trova in genere nelle prime versioni di \"Arduino Mega\". Per eseguire il flashing del bootloader stesso usa qualcosa come: wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/atmega/ATmegaBOOT_168_atmega1280.hex' avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xF5:m -U hfuse:w:0xDA:m -U lfuse:w:0xFF:m avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U flash:w:ATmegaBOOT_168_atmega1280.hex avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m Per eseguire il flashing di un'applicazione, utilizzare qualcosa come: avrdude -carduino -patmega1280 -P/dev/ttyACM0 -b57600 -D -Uflash:w:out/klipper.elf.hex:i","title":"Atmega1280"},{"location":"Bootloaders.html#atmega1284p","text":"Questo chip si trova comunemente nelle schede per stampanti 3D in stile \"Melzi\". Per eseguire il flashing del bootloader stesso usa qualcosa come: wget 'https://github.com/Lauszus/Sanguino/raw/1.0.2/bootloaders/optiboot/optiboot_atmega1284p.hex' avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xDE:m -U lfuse:w:0xFF:m avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega1284p.hex avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m Per eseguire il flashing di un'applicazione, utilizzare qualcosa come: avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/klipper.elf.hex:i Si noti che un certo numero di schede in stile \"Melzi\" sono precaricate con un bootloader che utilizza una velocit\u00e0 di trasmissione di 57600 baud. In questo caso, per eseguire il flashing di un'applicazione utilizzare invece qualcosa di simile: avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b57600 -D -Uflash:w:out/klipper.elf.hex:i","title":"Atmega1284p"},{"location":"Bootloaders.html#at90usb1286","text":"Questo documento non copre il metodo per eseguire il flashing di un bootloader su At90usb1286 n\u00e9 copre il flashing di applicazioni generali su questo dispositivo. Il dispositivo Teensy++ di pjrc.com viene fornito con un bootloader proprietario. Richiede uno strumento di flashing personalizzato da https://github.com/PaulStoffregen/teensy_loader_cli . Si pu\u00f2 eseguire il flashing di un'applicazione usando qualcosa come: teensy_loader_cli --mcu=at90usb1286 out/klipper.elf.hex -v","title":"At90usb1286"},{"location":"Bootloaders.html#atmega168","text":"L'atmega168 ha uno spazio flash limitato. Se si utilizza un bootloader, si consiglia di utilizzare il bootloader Optiboot. Per eseguire il flashing di quel bootloader usa qualcosa come: wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/optiboot/optiboot_atmega168.hex' avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0x04:m -U hfuse:w:0xDD:m -U lfuse:w:0xFF:m avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega168.hex avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m Per eseguire il flashing di un'applicazione tramite il bootloader Optiboot, utilizzare qualcosa come: avrdude -carduino -patmega168 -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/klipper.elf.hex:i","title":"Atmega168"},{"location":"Bootloaders.html#microcontrollori-sam3-arduino-due","text":"Non \u00e8 comune utilizzare un bootloader con l'mcu SAM3. Il chip stesso ha una ROM che permette di programmare il flash da porta seriale 3.3V o da USB. Per abilitare la ROM, il pin \"erase\" viene tenuto alto durante un reset, che cancella il contenuto della flash e fa funzionare la ROM. Su un Arduino Due, questa sequenza pu\u00f2 essere realizzata impostando un baud rate di 1200 sulla \"porta usb di programmazione\" (la porta USB pi\u00f9 vicina all'alimentatore). Il codice in https://github.com/shumatech/BOSSA pu\u00f2 essere utilizzato per programmare il SAM3. Si consiglia di utilizzare la versione 1.9 o successiva. Per eseguire il flashing di un'applicazione, utilizzare qualcosa come: bossac -U -p /dev/ttyACM0 -a -e -w out/klipper.bin -v -b bossac -U -p /dev/ttyACM0 -R","title":"Microcontrollori SAM3 (Arduino Due)"},{"location":"Bootloaders.html#microcontrollori-sam4-duet-wifi","text":"Non \u00e8 comune utilizzare un bootloader con l'mcu SAM4. Il chip stesso ha una ROM che permette di programmare la memoria flash da porta seriale 3.3V o da USB. Per abilitare la ROM, il pin \"erase\" viene tenuto alto durante un reset, che cancella il contenuto della memoria flash e fa funzionare la ROM. Il codice in https://github.com/shumatech/BOSSA pu\u00f2 essere utilizzato per programmare il SAM4. \u00c8 necessario utilizzare la versione 1.8.0 o successiva. Per eseguire il flashing di un'applicazione, utilizzare qualcosa come: bossac --port=/dev/ttyACM0 -b -U -e -w -v -R out/klipper.bin","title":"Microcontrollori SAM4 (Duet Wifi)"},{"location":"Bootloaders.html#samdc21-micro-controllers-duet3d-toolboard-1lc","text":"The SAMC21 is flashed via the ARM Serial Wire Debug (SWD) interface. This is commonly done with a dedicated SWD hardware dongle. Alternatively, one can use a Raspberry Pi with OpenOCD . When using OpenOCD with the SAMC21, extra steps must be taken to first put the chip into Cold Plugging mode if the board makes use of the SWD pins for other purposes. If using OpenOCD on a Rasberry Pi, this can be done by running the following commands before invoking OpenOCD. SWCLK=25 SWDIO=24 SRST=18 echo \"Exporting SWCLK and SRST pins.\" echo $SWCLK > /sys/class/gpio/export echo $SRST > /sys/class/gpio/export echo \"out\" > /sys/class/gpio/gpio$SWCLK/direction echo \"out\" > /sys/class/gpio/gpio$SRST/direction echo \"Setting SWCLK low and pulsing SRST.\" echo \"0\" > /sys/class/gpio/gpio$SWCLK/value echo \"0\" > /sys/class/gpio/gpio$SRST/value echo \"1\" > /sys/class/gpio/gpio$SRST/value echo \"Unexporting SWCLK and SRST pins.\" echo $SWCLK > /sys/class/gpio/unexport echo $SRST > /sys/class/gpio/unexport To flash a program with OpenOCD use the following chip config: source [find target/at91samdXX.cfg] Obtain a program; for instance, klipper can be built for this chip. Flash with OpenOCD commands similar to: at91samd chip-erase at91samd bootloader 0 program out/klipper.elf verify","title":"SAMDC21 micro-controllers (Duet3D Toolboard 1LC)"},{"location":"Bootloaders.html#microcontrollori-samd21-arduino-zero","text":"Il bootloader SAMD21 viene caricato in memoria flashing tramite l'interfaccia ARM Serial Wire Debug (SWD). Questo viene fatto comunemente con un dongle hardware SWD dedicato. In alternativa, \u00e8 possibile utilizzare un Raspberry Pi con OpenOCD . Per eseguire il flashing di un bootloader con OpenOCD, utilizzare la seguente configurazione del chip: source [find target/at91samdXX.cfg] Ottieni un bootloader, ad esempio: wget 'https://github.com/arduino/ArduinoCore-samd/raw/1.8.3/bootloaders/zero/samd21_sam_ba.bin' Carica la memoria Flash con comandi OpenOCD simili a: at91samd bootloader 0 program samd21_sam_ba.bin verify Il bootloader pi\u00f9 comune sul SAMD21 \u00e8 quello che si trova sull' \"Arduino Zero\". Utilizza un bootloader da 8KiB (l'applicazione deve essere compilata con un indirizzo iniziale di 8KiB). Si pu\u00f2 entrare in questo bootloader facendo doppio clic sul pulsante di ripristino. Per eseguire il flashing di un'applicazione, utilizzare qualcosa come: bossac -U -p /dev/ttyACM0 --offset=0x2000 -w out/klipper.bin -v -b -R Al contrario, \"Arduino M0\" utilizza un bootloader da 16 KiB (l'applicazione deve essere compilata con un indirizzo iniziale di 16 KiB). Per eseguire il flashing di un'applicazione su questo bootloader, ripristinare il microcontrollore ed eseguire il comando flash entro i primi secondi dall'avvio, qualcosa del tipo: avrdude -c stk500v2 -p atmega2560 -P /dev/ttyACM0 -u -Uflash:w:out/klipper.elf.hex:i","title":"Microcontrollori SAMD21 (Arduino Zero)"},{"location":"Bootloaders.html#microcontrollori-samd51-adafruit-metro-m4-e-simili","text":"Come il SAMD21, il bootloader SAMD51 viene eseguito il flashing tramite l'interfaccia ARM Serial Wire Debug (SWD). Per eseguire il flashing di un bootloader con OpenOCD su un Raspberry Pi utilizzare la seguente configurazione del chip: source [find target/atsame5x.cfg] Ottieni un bootloader: diversi bootloader sono disponibili da https://github.com/adafruit/uf2-samdx1/releases/latest . Per esempio: wget 'https://github.com/adafruit/uf2-samdx1/releases/download/v3.7.0/bootloader-itsybitsy_m4-v3.7.0.bin' Carica la memoria Flash con comandi OpenOCD simili a: at91samd bootloader 0 program bootloader-itsybitsy_m4-v3.7.0.bin verify at91samd bootloader 16384 Il SAMD51 utilizza un bootloader da 16 KiB (l'applicazione deve essere compilata con un indirizzo iniziale di 16 KiB). Per eseguire il flashing di un'applicazione, utilizzare qualcosa come: bossac -U -p /dev/ttyACM0 --offset=0x4000 -w out/klipper.bin -v -b -R","title":"Microcontrollori SAMD51 (Adafruit Metro-M4 e simili)"},{"location":"Bootloaders.html#microcontrollori-stm32f103-dispositivi-blue-pill","text":"I dispositivi STM32F103 dispongono di una ROM che pu\u00f2 eseguire il flashing di un bootloader o di un'applicazione tramite seriale a 3,3 V. In genere si collegano i pin PA10 (MCU Rx) e PA9 (MCU Tx) a un adattatore UART da 3,3 V. Per accedere alla ROM, \u00e8 necessario collegare il pin \"boot 0\" in alto e il pin \"boot 1\" in basso, quindi ripristinare il dispositivo. Il pacchetto \"stm32flash\" pu\u00f2 quindi essere utilizzato per eseguire il flashing del dispositivo utilizzando qualcosa come: stm32flash -w out/klipper.bin -v -g 0 /dev/ttyAMA0 Si noti che se si utilizza un Raspberry Pi per la seriale da 3,3 V, il protocollo stm32flash utilizza una modalit\u00e0 di parit\u00e0 seriale che il \"mini UART\" di Raspberry Pi non supporta. Vedere https://www.raspberrypi.com/documentation/computers/configuration.html#configuring-uarts per i dettagli sull'abilitazione dell'uart completo sui pin GPIO di Raspberry Pi. Dopo aver caricato la memoria flash, imposta \"boot 0\" e \"boot 1\" su basso in modo che in futuro ripristini l'avvio da flash.","title":"Microcontrollori STM32F103 (dispositivi Blue Pill)"},{"location":"Bootloaders.html#stm32f103-con-bootloader-stm32duino","text":"Il progetto \"stm32duino\" ha un bootloader compatibile con USB - vedere: https://github.com/rogerclarkmelbourne/STM32duino-bootloader Questo bootloader pu\u00f2 essere flashato tramite seriale 3.3V con qualcosa come: wget 'https://github.com/rogerclarkmelbourne/STM32duino-bootloader/raw/master/binaries/generic_boot20_pc13.bin' stm32flash -w generic_boot20_pc13.bin -v -g 0 /dev/ttyAMA0 Questo bootloader utilizza 8KiB di spazio flash (l'applicazione deve essere compilata con un indirizzo iniziale di 8KiB). Caricare in memoria flash un'applicazione con qualcosa come: dfu-util -d 1eaf:0003 -a 2 -R -D out/klipper.bin Il bootloader in genere viene eseguito solo per un breve periodo dopo l'avvio. Potrebbe essere necessario sincronizzare il comando sopra in modo che venga eseguito mentre il bootloader \u00e8 ancora attivo (il bootloader far\u00e0 lampeggiare un led della scheda mentre \u00e8 in esecuzione). In alternativa, imposta il pin \"boot 0\" su basso e il pin \"boot 1\" su alto per rimanere nel bootloader dopo un ripristino.","title":"STM32F103 con bootloader stm32duino"},{"location":"Bootloaders.html#stm32f103-con-bootloader-hid","text":"Il bootloader HID \u00e8 un bootloader compatto e senza driver in grado di eseguire il flashing attraverso USB. \u00c8 inoltre disponibile un fork con build specifiche per SKR Mini E3 1.2 . Per le schede STM32F103 generiche come la blue pill \u00e8 possibile eseguire il flashing del bootloader tramite seriale da 3,3 V utilizzando stm32flash come indicato nella sezione stm32duino sopra, sostituendo il nome del file con il binario del bootloader hid desiderato (ad esempio: hid_generic_pc13.bin per la blue pill ). Non \u00e8 possibile utilizzare stm32flash per SKR Mini E3 poich\u00e9 il pin boot0 \u00e8 collegato direttamente a terra e non disponibile tramite pin header. Si consiglia di utilizzare un STLink V2 con STM32Cubeprogrammer per eseguire il flashing del bootloader. Se non hai accesso a un STLink \u00e8 anche possibile utilizzare un Raspberry Pi e OpenOCD con la seguente configurazione del chip: source [find target/stm32f1x.cfg] Se lo desideri puoi fare un backup della flash corrente con il seguente comando. Tieni presente che il completamento potrebbe richiedere del tempo: flash read_bank 0 btt_skr_mini_e3_backup.bin infine, puoi eseguire il flashing con comandi simili a: stm32f1x mass_erase 0 program hid_btt_skr_mini_e3.bin verify 0x08000000 NOTE: L'esempio sopra cancella il chip, quindi programma il bootloader. Indipendentemente dal metodo scelto per eseguire il flashing, si consiglia di cancellare il chip prima del flashing. Prima di eseguire il flashing di SKR Mini E3 con questo bootloader, dovresti essere consapevole che non sarai pi\u00f9 in grado di aggiornare il firmware tramite la sdcard. You may need to hold down the reset button on the board while launching OpenOCD. It should display something like: Open On-Chip Debugger 0.10.0+dev-01204-gc60252ac-dirty (2020-04-27-16:00) Licensed under GNU GPL v2 For bug reports, read http://openocd.org/doc/doxygen/bugs.html DEPRECATED! use 'adapter speed' not 'adapter_khz' Info : BCM2835 GPIO JTAG/SWD bitbang driver Info : JTAG and SWD modes enabled Info : clock speed 40 kHz Info : SWD DPIDR 0x1ba01477 Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints Info : stm32f1x.cpu: external reset detected Info : starting gdb server for stm32f1x.cpu on 3333 Info : Listening on port 3333 for gdb connections Dopodich\u00e9 puoi rilasciare il pulsante di reset. Questo bootloader richiede 2KiB di spazio flash (l'applicazione deve essere compilata con un indirizzo iniziale di 2KiB). Il programma hid-flash viene utilizzato per caricare un file binario sul bootloader. \u00c8 possibile installare questo software con i seguenti comandi: sudo apt install libusb-1.0 cd ~/klipper/lib/hidflash make Se il bootloader \u00e8 in esecuzione, puoi eseguire il flash con qualcosa del tipo: ~/klipper/lib/hidflash/hid-flash ~/klipper/out/klipper.bin in alternativa, puoi usare make flash per flashare klipper direttamente: make flash FLASH_DEVICE=1209:BEBA O se klipper \u00e8 stato precedentemente flashato: make flash FLASH_DEVICE=/dev/ttyACM0 Potrebbe essere necessario accedere manualmente al bootloader, questo pu\u00f2 essere fatto impostando \"boot 0\" basso e \"boot 1\" alto. Sull'SKR Mini E3 \"Boot 1\" non \u00e8 disponibile, quindi pu\u00f2 essere fatto impostando il pin PA2 basso se hai flashato \"hid_btt_skr_mini_e3.bin\". Questo pin \u00e8 etichettato \"TX0\" sull'intestazione TFT nel documento \"PIN\" di SKR Mini E3. C'\u00e8 un pin di terra accanto a PA2 che puoi utilizzare per abbassare PA2.","title":"STM32F103 con bootloader HID"},{"location":"Bootloaders.html#stm32f103stm32f072-con-bootloader-msc","text":"Il bootloader MSC \u00e8 un bootloader senza driver in grado di eseguire il flashing su USB. \u00c8 possibile eseguire il flashing del bootloader tramite seriale da 3,3 V utilizzando stm32flash come indicato nella sezione stm32duino sopra, sostituendo il nome del file con il binario del bootloader MSC desiderato (ad esempio: MSCboot-Bluepill.bin per la blue pill). Per le schede STM32F072 \u00e8 anche possibile eseguire il flashing del bootloader su USB (tramite DFU) con qualcosa del tipo: dfu-util -d 0483:df11 -a 0 -R -D MSCboot-STM32F072.bin -s0x08000000:leave Questo bootloader utilizza 8KiB o 16KiB di spazio flash, vedere la descrizione del bootloader (l'applicazione deve essere compilata con l'indirizzo iniziale corrispondente). Il bootloader pu\u00f2 essere attivato premendo due volte il pulsante di reset della scheda. Non appena il bootloader viene attivato, la scheda appare come una chiavetta USB su cui \u00e8 possibile copiare il file klipper.bin.","title":"STM32F103/STM32F072 con bootloader MSC"},{"location":"Bootloaders.html#stm32f103stm32f0x2-con-bootloader-canboot","text":"Il bootloader CanBoot fornisce un'opzione per caricare il firmware Klipper su CANBUS. Il bootloader stesso \u00e8 derivato dal codice sorgente di Klipper. Attualmente CanBoot supporta i modelli STM32F103, STM32F042 e STM32F072. Si consiglia di utilizzare un programmatore ST-Link per eseguire il flashing di CanBoot, tuttavia dovrebbe essere possibile eseguire il flashing utilizzando stm32flash sui dispositivi STM32F103 e \"dfu-util\" sui dispositivi STM32F042/STM32F072. Consulta le sezioni precedenti di questo documento per istruzioni su questi metodi di flashing, sostituendo canboot.bin con il nome del file dove appropriato. Il repository CanBoot collegato sopra fornisce istruzioni per la creazione del bootloader. La prima volta che CanBoot \u00e8 stato flashato, dovrebbe rilevare che non \u00e8 presente alcuna applicazione e accedere al bootloader. Se ci\u00f2 non accade \u00e8 possibile entrare nel bootloader premendo due volte di seguito il pulsante di reset. L'utilit\u00e0 flash_can.py fornita nella cartella lib/canboot pu\u00f2 essere utilizzata per caricare il firmware di Klipper. E' necessario l'UUID del dispositivo per eseguire il flashing. Se non si dispone di un UUID \u00e8 possibile interrogare i nodi che attualmente eseguono il bootloader: python3 flash_can.py -q Ci\u00f2 restituir\u00e0 gli UUID per tutti i nodi collegati non attualmente assegnati a un UUID. Questo dovrebbe includere tutti i nodi attualmente nel bootloader. Una volta che hai un UUID, puoi caricare il firmware con il seguente comando: python3 flash_can.py -i can0 -f ~/klipper/out/klipper.bin -u aabbccddeeff Dove aabbccddeeff \u00e8 sostituito dal tuo UUID. Nota che le opzioni -i e -f possono essere omesse, per impostazione predefinita sono rispettivamente can0 e ~/klipper/out/klipper.bin . Quando crei Klipper per l'uso con CanBoot, seleziona l'opzione Bootloader da 8 KiB.","title":"STM32F103/STM32F0x2 con bootloader CanBoot"},{"location":"Bootloaders.html#microcontrollori-stm32f4-skr-pro-11","text":"I microcontrollori STM32F4 sono dotati di un bootloader di sistema integrato in grado di eseguire il flashing tramite USB (tramite DFU), seriale da 3,3 V e vari altri metodi (vedere il documento STM AN2606 per ulteriori informazioni). Alcune schede STM32F4, come SKR Pro 1.1, non sono in grado di accedere al bootloader DFU. Il bootloader HID \u00e8 disponibile per le schede basate su STM32F405/407 nel caso in cui l'utente preferisca eseguire il flashing tramite USB anzich\u00e9 utilizzare la scheda SD. Tieni presente che potrebbe essere necessario configurare e creare una versione specifica per la tua scheda, una build per SKR Pro 1.1 \u00e8 disponibile qui . A meno che la tua scheda non sia compatibile con DFU, il metodo di flashing pi\u00f9 accessibile \u00e8 probabilmente tramite seriale da 3,3 V, che segue la stessa procedura di flash di STM32F103 utilizzando stm32flash . Per esempio: wget https://github.com/Arksine/STM32_HID_Bootloader/releases/download/v0.5-beta/hid_bootloader_SKR_PRO.bin stm32flash -w hid_bootloader_SKR_PRO.bin -v -g 0 /dev/ttyAMA0 Questo bootloader richiede 16Kib di spazio flash sull'STM32F4 (l'applicazione deve essere compilata con un indirizzo iniziale di 16KiB). Come con l'STM32F1, l'STM32F4 utilizza lo strumento hid-flash per caricare i file binari nell'MCU. Consulta le istruzioni sopra per i dettagli su come creare e utilizzare hid-flash. Potrebbe essere necessario inserire manualmente il bootloader, questo pu\u00f2 essere fatto impostando \"boot 0\" basso, \"boot 1\" alto e collegando il dispositivo. Al termine della programmazione, scollegare il dispositivo e impostare \"boot 1\" su basso in modo che l'applicazione venga caricata.","title":"Microcontrollori STM32F4 (SKR Pro 1.1)"},{"location":"Bootloaders.html#microcontrollori-lpc176x-smoothieboards","text":"Questo documento non descrive il metodo per eseguire il flashing di un bootloader stesso - vedere: http://smoothieware.org/flashing-the-bootloader per ulteriori informazioni su questo argomento. \u00c8 comune che per le Smoothieboard venga fornito con un bootloader da: https://github.com/triffid/LPC17xx-DFU-Bootloader . Quando si utilizza questo bootloader, l'applicazione deve essere compilata con un indirizzo iniziale di 16 KiB. Il modo pi\u00f9 semplice per eseguire il flashing di un'applicazione con questo bootloader \u00e8 copiare il file dell'applicazione (ad es. out/klipper.bin ) in un file denominato firmware.bin su una scheda SD, quindi riavviare il microcontrollore con quella scheda SD.","title":"Microcontrollori LPC176x (Smoothieboards)"},{"location":"Bootloaders.html#eseguire-openocd-su-raspberry-pi","text":"OpenOCD \u00e8 un pacchetto software in grado di eseguire il flashing e il debug di chip di basso livello. Pu\u00f2 utilizzare i pin GPIO su un Raspberry Pi per comunicare con una variet\u00e0 di chip ARM. Questa sezione descrive come installare e avviare OpenOCD. \u00c8 derivato dalle istruzioni su: https://learn.adafruit.com/programming-microcontrollers-using-openocd-on-raspberry-pi Inizia scaricando e compilando il software (ogni passaggio pu\u00f2 richiedere diversi minuti e il passaggio \"make\" pu\u00f2 richiedere pi\u00f9 di 30 minuti): sudo apt-get update sudo apt-get install autoconf libtool telnet mkdir ~/openocd cd ~/openocd/ git clone http://openocd.zylin.com/openocd cd openocd ./bootstrap ./configure --enable-sysfsgpio --enable-bcm2835gpio --prefix=/home/pi/openocd/install make make install","title":"Eseguire OpenOCD su Raspberry PI"},{"location":"Bootloaders.html#configurare-openocd","text":"Crea un file di configurazione OpenOCD: nano ~/openocd/openocd.cfg Utilizzare una configurazione simile alla seguente: # Uses RPi pins: GPIO25 for SWDCLK, GPIO24 for SWDIO, GPIO18 for nRST source [find interface/raspberrypi2-native.cfg] bcm2835gpio_swd_nums 25 24 bcm2835gpio_srst_num 18 transport select swd # Use hardware reset wire for chip resets reset_config srst_only adapter_nsrst_delay 100 adapter_nsrst_assert_width 100 # Specify the chip type source [find target/atsame5x.cfg] # Set the adapter speed adapter_khz 40 # Connect to chip init targets reset halt","title":"Configurare OpenOCD"},{"location":"Bootloaders.html#collega-il-raspberry-pi-al-chip-di-destinazione","text":"Spegni sia il Raspberry Pi che il chip di destinazione prima del cablaggio! Verificare che il chip di destinazione utilizzi 3,3 V prima di connettersi a un Raspberry Pi! Collega GND, SWDCLK, SWDIO e RST sul chip di destinazione rispettivamente a GND, GPIO25, GPIO24 e GPIO18 sul Raspberry Pi. Quindi accendi il Raspberry Pi e fornisci alimentazione al chip di destinazione.","title":"Collega il Raspberry Pi al chip di destinazione"},{"location":"Bootloaders.html#eseguire-openocd","text":"Esegui OpenOCD: cd ~/openocd/ sudo ~/openocd/install/bin/openocd -f ~/openocd/openocd.cfg Quanto sopra dovrebbe far s\u00ec che OpenOCD emetta alcuni messaggi di testo e quindi attenda (non dovrebbe tornare immediatamente al prompt della shell Unix). Se OpenOCD termina da solo o se continua a emettere messaggi di testo, ricontrolla il cablaggio. Una volta che OpenOCD \u00e8 in esecuzione ed \u00e8 stabile, \u00e8 possibile inviargli comandi tramite telnet. Apri un'altra sessione ssh ed esegui quanto segue: telnet 127.0.0.1 4444 (Si pu\u00f2 uscire da telnet premendo ctrl+] e quindi eseguendo il comando \"quit\".)","title":"Eseguire OpenOCD"},{"location":"Bootloaders.html#openocd-e-gdb","text":"\u00c8 possibile utilizzare OpenOCD con gdb per eseguire il debug di Klipper. I seguenti comandi presuppongono che uno stia eseguendo gdb su una macchina di classe desktop. Aggiungi quanto segue al file di configurazione di OpenOCD: bindto 0.0.0.0 gdb_port 44444 Riavvia OpenOCD sul Raspberry Pi e quindi esegui il seguente comando Unix sul computer desktop: cd /path/to/klipper/ gdb out/klipper.elf All'interno di gdb esegui: target remote octopi:44444 (Sostituisci \"octopi\" con il nome host del Raspberry Pi.) Una volta che gdb \u00e8 in esecuzione, \u00e8 possibile impostare punti di interruzione e ispezionare i registri.","title":"OpenOCD e gdb"},{"location":"CANBUS.html","text":"CANBUS \u00b6 Questo documento descrive il supporto del CAN bus di Klipper. Hardware del dispositivo \u00b6 Klipper currently supports CAN on stm32, SAME5x, and rp2040 chips. In addition, the micro-controller chip must be on a board that has a CAN transceiver. Per compilare per CAN, eseguire make menuconfig e selezionare \"CAN bus\" come interfaccia di comunicazione. Infine, compila il codice del microcontrollore e flashalo sulla scheda di destinazione. Hardware Host \u00b6 In order to use a CAN bus, it is necessary to have a host adapter. It is recommended to use a \"USB to CAN adapter\". There are many different USB to CAN adapters available from different manufacturers. When choosing one, we recommend verifying that the firmware can be updated on it. (Unfortunately, we've found some USB adapters run defective firmware and are locked down, so verify before purchasing.) Look for adapters that can run Klipper directly (in its \"USB to CAN bridge mode\") or that run the candlelight firmware . \u00c8 inoltre necessario configurare il sistema operativo host per utilizzare l'adattatore. Questo viene in genere fatto creando un nuovo file chiamato /etc/network/interfaces.d/can0 con il seguente contenuto: allow-hotplug can0 iface can0 can static bitrate 1000000 up ip link set $IFACE txqueuelen 128 Resistori di terminazione \u00b6 Un bus CAN dovrebbe avere due resistori da 120 ohm tra i cavi CANH e CANL. Idealmente, un resistore situato a ciascuna estremit\u00e0 del bus. Note that some devices have a builtin 120 ohm resistor that can not be easily removed. Some devices do not include a resistor at all. Other devices have a mechanism to select the resistor (typically by connecting a \"pin jumper\"). Be sure to check the schematics of all devices on the CAN bus to verify that there are two and only two 120 Ohm resistors on the bus. Per verificare che i resistori siano corretti, \u00e8 possibile rimuovere l'alimentazione alla stampante e utilizzare un multimetro per controllare la resistenza tra i cavi CNH e CANL: dovrebbe riportare ~60 ohm su un bus CAN cablato correttamente. Trovare canbus_uuid per nuovi microcontrollori \u00b6 A ogni microcontrollore sul bus CAN viene assegnato un ID univoco basato sull'identificatore del chip di fabbrica codificato in ciascun microcontrollore. Per trovare l'ID di ciascun dispositivo del microcontrollore, assicurati che l'hardware sia alimentato e cablato correttamente, quindi esegui: ~/klippy-env/bin/python ~/klipper/scripts/canbus_query.py can0 Se vengono rilevati dispositivi CAN non inizializzati, il comando precedente riporter\u00e0 righe come le seguenti: Found canbus_uuid=11aa22bb33cc, Application: Klipper Ogni dispositivo avr\u00e0 un identificatore univoco. Nell'esempio sopra, 11aa22bb33cc \u00e8 il \"canbus_uuid\" del microcontrollore. Nota che lo strumento canbus_query.py riporter\u00e0 solo i dispositivi non inizializzati - se Klipper (o uno strumento simile) configura il dispositivo, non apparir\u00e0 pi\u00f9 nell'elenco. Configurare Klipper \u00b6 Aggiorna Klipper configurazione mcu per utilizzare il bus CAN per comunicare con il dispositivo, ad esempio: [mcu my_can_mcu] canbus_uuid: 11aa22bb33cc Modalit\u00e0 bridge da USB a CAN bus \u00b6 Some micro-controllers support selecting \"USB to CAN bus bridge\" mode during Klipper's \"make menuconfig\". This mode may allow one to use a micro-controller as both a \"USB to CAN bus adapter\" and as a Klipper node. When Klipper uses this mode the micro-controller appears as a \"USB CAN bus adapter\" under Linux. The \"Klipper bridge mcu\" itself will appear as if it was on this CAN bus - it can be identified via canbus_query.py and it must be configured like other CAN bus Klipper nodes. Alcune note importanti quando si utilizza questa modalit\u00e0: \u00c8 necessario configurare l'interfaccia can0 (o simile) in Linux per comunicare con il bus. Tuttavia, Klipper ignora la velocit\u00e0 del bus CAN di Linux e le opzioni di temporizzazione del bus CAN. Attualmente, la frequenza del bus CAN viene specificata durante \"make menuconfig\" e la velocit\u00e0 del bus specificata in Linux viene ignorata. Whenever the \"bridge mcu\" is reset, Linux will disable the corresponding can0 interface. To ensure proper handling of FIRMWARE_RESTART and RESTART commands, it is recommended to use allow-hotplug in the /etc/network/interfaces.d/can0 file. For example: allow-hotplug can0 iface can0 can static bitrate 1000000 up ip link set $IFACE txqueuelen 128 The \"bridge mcu\" is not actually on the CAN bus. Messages to and from the bridge mcu will not be seen by other adapters that may be on the CAN bus. The available bandwidth to both the \"bridge mcu\" itself and all devices on the CAN bus is effectively limited by the CAN bus frequency. As a result, it is recommended to use a CAN bus frequency of 1000000 when using \"USB to CAN bus bridge mode\". Even at a CAN bus frequency of 1000000, there may not be sufficient bandwidth to run a SHAPER_CALIBRATE test if both the XY steppers and the accelerometer all communicate via a single \"USB to CAN bus\" interface. A USB to CAN bridge board will not appear as a USB serial device, it will not show up when running ls /dev/serial/by-id , and it can not be configured in Klipper's printer.cfg file with a serial: parameter. The bridge board appears as a \"USB CAN adapter\" and it is configured in the printer.cfg as a CAN node . Tips for troubleshooting \u00b6 See the CAN bus troubleshooting document.","title":"CANBUS"},{"location":"CANBUS.html#canbus","text":"Questo documento descrive il supporto del CAN bus di Klipper.","title":"CANBUS"},{"location":"CANBUS.html#hardware-del-dispositivo","text":"Klipper currently supports CAN on stm32, SAME5x, and rp2040 chips. In addition, the micro-controller chip must be on a board that has a CAN transceiver. Per compilare per CAN, eseguire make menuconfig e selezionare \"CAN bus\" come interfaccia di comunicazione. Infine, compila il codice del microcontrollore e flashalo sulla scheda di destinazione.","title":"Hardware del dispositivo"},{"location":"CANBUS.html#hardware-host","text":"In order to use a CAN bus, it is necessary to have a host adapter. It is recommended to use a \"USB to CAN adapter\". There are many different USB to CAN adapters available from different manufacturers. When choosing one, we recommend verifying that the firmware can be updated on it. (Unfortunately, we've found some USB adapters run defective firmware and are locked down, so verify before purchasing.) Look for adapters that can run Klipper directly (in its \"USB to CAN bridge mode\") or that run the candlelight firmware . \u00c8 inoltre necessario configurare il sistema operativo host per utilizzare l'adattatore. Questo viene in genere fatto creando un nuovo file chiamato /etc/network/interfaces.d/can0 con il seguente contenuto: allow-hotplug can0 iface can0 can static bitrate 1000000 up ip link set $IFACE txqueuelen 128","title":"Hardware Host"},{"location":"CANBUS.html#resistori-di-terminazione","text":"Un bus CAN dovrebbe avere due resistori da 120 ohm tra i cavi CANH e CANL. Idealmente, un resistore situato a ciascuna estremit\u00e0 del bus. Note that some devices have a builtin 120 ohm resistor that can not be easily removed. Some devices do not include a resistor at all. Other devices have a mechanism to select the resistor (typically by connecting a \"pin jumper\"). Be sure to check the schematics of all devices on the CAN bus to verify that there are two and only two 120 Ohm resistors on the bus. Per verificare che i resistori siano corretti, \u00e8 possibile rimuovere l'alimentazione alla stampante e utilizzare un multimetro per controllare la resistenza tra i cavi CNH e CANL: dovrebbe riportare ~60 ohm su un bus CAN cablato correttamente.","title":"Resistori di terminazione"},{"location":"CANBUS.html#trovare-canbus_uuid-per-nuovi-microcontrollori","text":"A ogni microcontrollore sul bus CAN viene assegnato un ID univoco basato sull'identificatore del chip di fabbrica codificato in ciascun microcontrollore. Per trovare l'ID di ciascun dispositivo del microcontrollore, assicurati che l'hardware sia alimentato e cablato correttamente, quindi esegui: ~/klippy-env/bin/python ~/klipper/scripts/canbus_query.py can0 Se vengono rilevati dispositivi CAN non inizializzati, il comando precedente riporter\u00e0 righe come le seguenti: Found canbus_uuid=11aa22bb33cc, Application: Klipper Ogni dispositivo avr\u00e0 un identificatore univoco. Nell'esempio sopra, 11aa22bb33cc \u00e8 il \"canbus_uuid\" del microcontrollore. Nota che lo strumento canbus_query.py riporter\u00e0 solo i dispositivi non inizializzati - se Klipper (o uno strumento simile) configura il dispositivo, non apparir\u00e0 pi\u00f9 nell'elenco.","title":"Trovare canbus_uuid per nuovi microcontrollori"},{"location":"CANBUS.html#configurare-klipper","text":"Aggiorna Klipper configurazione mcu per utilizzare il bus CAN per comunicare con il dispositivo, ad esempio: [mcu my_can_mcu] canbus_uuid: 11aa22bb33cc","title":"Configurare Klipper"},{"location":"CANBUS.html#modalita-bridge-da-usb-a-can-bus","text":"Some micro-controllers support selecting \"USB to CAN bus bridge\" mode during Klipper's \"make menuconfig\". This mode may allow one to use a micro-controller as both a \"USB to CAN bus adapter\" and as a Klipper node. When Klipper uses this mode the micro-controller appears as a \"USB CAN bus adapter\" under Linux. The \"Klipper bridge mcu\" itself will appear as if it was on this CAN bus - it can be identified via canbus_query.py and it must be configured like other CAN bus Klipper nodes. Alcune note importanti quando si utilizza questa modalit\u00e0: \u00c8 necessario configurare l'interfaccia can0 (o simile) in Linux per comunicare con il bus. Tuttavia, Klipper ignora la velocit\u00e0 del bus CAN di Linux e le opzioni di temporizzazione del bus CAN. Attualmente, la frequenza del bus CAN viene specificata durante \"make menuconfig\" e la velocit\u00e0 del bus specificata in Linux viene ignorata. Whenever the \"bridge mcu\" is reset, Linux will disable the corresponding can0 interface. To ensure proper handling of FIRMWARE_RESTART and RESTART commands, it is recommended to use allow-hotplug in the /etc/network/interfaces.d/can0 file. For example: allow-hotplug can0 iface can0 can static bitrate 1000000 up ip link set $IFACE txqueuelen 128 The \"bridge mcu\" is not actually on the CAN bus. Messages to and from the bridge mcu will not be seen by other adapters that may be on the CAN bus. The available bandwidth to both the \"bridge mcu\" itself and all devices on the CAN bus is effectively limited by the CAN bus frequency. As a result, it is recommended to use a CAN bus frequency of 1000000 when using \"USB to CAN bus bridge mode\". Even at a CAN bus frequency of 1000000, there may not be sufficient bandwidth to run a SHAPER_CALIBRATE test if both the XY steppers and the accelerometer all communicate via a single \"USB to CAN bus\" interface. A USB to CAN bridge board will not appear as a USB serial device, it will not show up when running ls /dev/serial/by-id , and it can not be configured in Klipper's printer.cfg file with a serial: parameter. The bridge board appears as a \"USB CAN adapter\" and it is configured in the printer.cfg as a CAN node .","title":"Modalit\u00e0 bridge da USB a CAN bus"},{"location":"CANBUS.html#tips-for-troubleshooting","text":"See the CAN bus troubleshooting document.","title":"Tips for troubleshooting"},{"location":"CANBUS_Troubleshooting.html","text":"Risoluzione dei problemi CANBUS \u00b6 Questo documento fornisce informazioni sulla risoluzione dei problemi di comunicazione quando si utilizza Klipper with CAN bus . Verificare la connessione CAN bus \u00b6 Il primo passo nella risoluzione dei problemi di comunicazione \u00e8 verificare il cablaggio del CAN bus. Be sure there are exactly two 120 Ohm terminating resistors on the CAN bus. If the resistors are not properly installed then messages may not be able to be sent at all or the connection may have sporadic instability. The CANH and CANL bus wiring should be twisted around each other. At a minimum, the wiring should have a twist every few centimeters. Avoid twisting the CANH and CANL wiring around power wires and ensure that power wires that travel parallel to the CANH and CANL wires do not have the same amount of twists. Verify that all plugs and wire crimps on the CAN bus wiring are fully secured. Movement of the printer toolhead may jostle the CAN bus wiring causing a bad wire crimp or unsecured plug to result in intermittent communication errors. Check for incrementing bytes_invalid counter \u00b6 The Klipper log file will report a Stats line once a second when the printer is active. These \"Stats\" lines will have a bytes_invalid counter for each micro-controller. This counter should not increment during normal printer operation (it is normal for the counter to be non-zero after a RESTART and it is not a concern if the counter increments once a month or so). If this counter increments on a CAN bus micro-controller during normal printing (it increments every few hours or more frequently) then it is an indication of a severe problem. Incrementing bytes_invalid on a CAN bus connection is a symptom of reordered messages on the CAN bus. There are two known causes of reordered messages: Old versions of the popular candlight_firmware for USB CAN adapters had a bug that could cause reordered messages. If using a USB CAN adapter running this firmware then make sure to update to the latest firmware if incrementing bytes_invalid is observed. Some Linux kernel builds for embedded devices have been known to reorder CAN bus messages. It may be necessary to use an alternative Linux kernel or to use alternative hardware that supports mainstream Linux kernels that do not exhibit this problem. Reordered messages is a severe problem that must be fixed. It will result in unstable behavior and can lead to confusing errors at any part of a print. Use an appropriate txqueuelen setting \u00b6 The Klipper code uses the Linux kernel to manage CAN bus traffic. By default, the kernel will only queue 10 CAN transmit packets. It is recommended to configure the can0 device with a txqueuelen 128 to increase that size. If Klipper transmits a packet and Linux has filled all of its transmit queue space then Linux will drop that packet and messages like the following will appear in the Klipper log: Got error -1 in can write: (105)No buffer space available Klipper will automatically retransmit the lost messages as part of its normal application level message retransmit system. Thus, this log message is a warning and it does not indicate an unrecoverable error. If a complete CAN bus failure occurs (such as a CAN wire break) then Linux will not be able to transmit any messages on the CAN bus and it is common to find the above message in the Klipper log. In this case, the log message is a symptom of a larger problem (the inability to transmit any messages) and is not directly related to Linux txqueuelen . One may check the current queue size by running the Linux command ip link show can0 . It should report a bunch of text including the snippet qlen 128 . If one sees something like qlen 10 then it indicates the CAN device has not been properly configured. It is not recommended to use a txqueuelen significantly larger than 128. A CAN bus running at a frequency of 1000000 will typically take around 120us to transmit a CAN packet. Thus a queue of 128 packets is likely to take around 15-20ms to drain. A substantially larger queue could cause excessive spikes in message round-trip-time which could lead to unrecoverable errors. Said another way, Klipper's application retransmit system is more robust if it does not have to wait for Linux to drain an excessively large queue of possibly stale data. This is analogous to the problem of bufferbloat on internet routers. Under normal circumstances Klipper may utilize ~25 queue slots per MCU - typically only utilizing more slots during retransmits. (Specifically, the Klipper host may transmit up to 192 bytes to each Klipper MCU before receiving an acknowledgment from that MCU.) If a single CAN bus has 5 or more Klipper MCUs on it, then it might be necessary to increase the txqueuelen above the recommended value of 128. However, as above, care should be taken when selecting a new value to avoid excessive round-trip-time latency. Obtaining candump logs \u00b6 The CAN bus messages sent to and from the micro-controller are handled by the Linux kernel. It is possible to capture these messages from the kernel for debugging purposes. A log of these messages may be of use in diagnostics. The Linux can-utils tool provides the capture software. It is typically installed on a machine by running: sudo apt-get update && sudo apt-get install can-utils Once installed, one may obtain a capture of all CAN bus messages on an interface with the following command: candump -tz -Ddex can0,#FFFFFFFF > mycanlog One can view the resulting log file ( mycanlog in the example above) to see each raw CAN bus message that was sent and received by Klipper. Understanding the content of these messages will likely require low-level knowledge of Klipper's CANBUS protocol and Klipper's MCU commands . Parsing Klipper messages in a candump log \u00b6 One may use the parsecandump.py tool to parse the low-level Klipper micro-controller messages contained in a candump log. Using this tool is an advanced topic that requires knowledge of Klipper MCU commands . For example: ./scripts/parsecandump.py mycanlog 108 ./out/klipper.dict This tool produces output similar to the parsedump tool . See the documentation for that tool for information on generating the Klipper micro-controller data dictionary. In the above example, 108 is the CAN bus id . It is a hexadecimal number. The id 108 is assigned by Klipper to the first micro-controller. If the CAN bus has multiple micro-controllers on it, then the second micro-controller would be 10a , the third would be 10c , and so on. The candump log must be produced using the -tz -Ddex command-line arguments (for example: candump -tz -Ddex can0,#FFFFFFFF ) in order to use the parsecandump.py tool. Using a logic analyzer on the canbus wiring \u00b6 The Sigrok Pulseview software along with a low-cost logic analyzer can be useful for diagnosing CAN bus signaling. This is an advanced topic likely only of interest to experts. One can often find \"USB logic analyzers\" for under $15 (US pricing as of 2023). These devices are often listed as \"Saleae logic clones\" or as \"24MHz 8 channel USB logic analyzers\". The above picture was taken while using Pulseview with a \"Saleae clone\" logic analyzer. The Sigrok and Pulseview software was installed on a desktop machine (also install the \"fx2lafw\" firmware if that is packaged separately). The CH0 pin on the logic analyzer was routed to the CAN Rx line, the CH1 pin was wired to the CAN Tx pin, and GND was wired to GND. Pulseview was configured to only display the D0 and D1 lines (red \"probe\" icon center top toolbar). The number of samples was set to 5 million (top toolbar) and the sample rate was set to 24Mhz (top toolbar). The CAN decoder was added (yellow and green \"bubble icon\" right top toolbar). The D0 channel was labeled as RX and set to trigger on a falling edge (click on black D0 label at left). The D1 channel was labeled as TX (click on brown D1 label at left). The CAN decoder was configured for 1Mbit rate (click on green CAN label at left). The CAN decoder was moved to the top of the display (click and drag green CAN label). Finally, the capture was started (click \"Run\" at top left) and a packet was transmitted on the CAN bus ( cansend can0 123#121212121212 ). The logic analyzer provides an independent tool for capturing packets and verifying bit timing.","title":"Risoluzione dei problemi CANBUS"},{"location":"CANBUS_Troubleshooting.html#risoluzione-dei-problemi-canbus","text":"Questo documento fornisce informazioni sulla risoluzione dei problemi di comunicazione quando si utilizza Klipper with CAN bus .","title":"Risoluzione dei problemi CANBUS"},{"location":"CANBUS_Troubleshooting.html#verificare-la-connessione-can-bus","text":"Il primo passo nella risoluzione dei problemi di comunicazione \u00e8 verificare il cablaggio del CAN bus. Be sure there are exactly two 120 Ohm terminating resistors on the CAN bus. If the resistors are not properly installed then messages may not be able to be sent at all or the connection may have sporadic instability. The CANH and CANL bus wiring should be twisted around each other. At a minimum, the wiring should have a twist every few centimeters. Avoid twisting the CANH and CANL wiring around power wires and ensure that power wires that travel parallel to the CANH and CANL wires do not have the same amount of twists. Verify that all plugs and wire crimps on the CAN bus wiring are fully secured. Movement of the printer toolhead may jostle the CAN bus wiring causing a bad wire crimp or unsecured plug to result in intermittent communication errors.","title":"Verificare la connessione CAN bus"},{"location":"CANBUS_Troubleshooting.html#check-for-incrementing-bytes_invalid-counter","text":"The Klipper log file will report a Stats line once a second when the printer is active. These \"Stats\" lines will have a bytes_invalid counter for each micro-controller. This counter should not increment during normal printer operation (it is normal for the counter to be non-zero after a RESTART and it is not a concern if the counter increments once a month or so). If this counter increments on a CAN bus micro-controller during normal printing (it increments every few hours or more frequently) then it is an indication of a severe problem. Incrementing bytes_invalid on a CAN bus connection is a symptom of reordered messages on the CAN bus. There are two known causes of reordered messages: Old versions of the popular candlight_firmware for USB CAN adapters had a bug that could cause reordered messages. If using a USB CAN adapter running this firmware then make sure to update to the latest firmware if incrementing bytes_invalid is observed. Some Linux kernel builds for embedded devices have been known to reorder CAN bus messages. It may be necessary to use an alternative Linux kernel or to use alternative hardware that supports mainstream Linux kernels that do not exhibit this problem. Reordered messages is a severe problem that must be fixed. It will result in unstable behavior and can lead to confusing errors at any part of a print.","title":"Check for incrementing bytes_invalid counter"},{"location":"CANBUS_Troubleshooting.html#use-an-appropriate-txqueuelen-setting","text":"The Klipper code uses the Linux kernel to manage CAN bus traffic. By default, the kernel will only queue 10 CAN transmit packets. It is recommended to configure the can0 device with a txqueuelen 128 to increase that size. If Klipper transmits a packet and Linux has filled all of its transmit queue space then Linux will drop that packet and messages like the following will appear in the Klipper log: Got error -1 in can write: (105)No buffer space available Klipper will automatically retransmit the lost messages as part of its normal application level message retransmit system. Thus, this log message is a warning and it does not indicate an unrecoverable error. If a complete CAN bus failure occurs (such as a CAN wire break) then Linux will not be able to transmit any messages on the CAN bus and it is common to find the above message in the Klipper log. In this case, the log message is a symptom of a larger problem (the inability to transmit any messages) and is not directly related to Linux txqueuelen . One may check the current queue size by running the Linux command ip link show can0 . It should report a bunch of text including the snippet qlen 128 . If one sees something like qlen 10 then it indicates the CAN device has not been properly configured. It is not recommended to use a txqueuelen significantly larger than 128. A CAN bus running at a frequency of 1000000 will typically take around 120us to transmit a CAN packet. Thus a queue of 128 packets is likely to take around 15-20ms to drain. A substantially larger queue could cause excessive spikes in message round-trip-time which could lead to unrecoverable errors. Said another way, Klipper's application retransmit system is more robust if it does not have to wait for Linux to drain an excessively large queue of possibly stale data. This is analogous to the problem of bufferbloat on internet routers. Under normal circumstances Klipper may utilize ~25 queue slots per MCU - typically only utilizing more slots during retransmits. (Specifically, the Klipper host may transmit up to 192 bytes to each Klipper MCU before receiving an acknowledgment from that MCU.) If a single CAN bus has 5 or more Klipper MCUs on it, then it might be necessary to increase the txqueuelen above the recommended value of 128. However, as above, care should be taken when selecting a new value to avoid excessive round-trip-time latency.","title":"Use an appropriate txqueuelen setting"},{"location":"CANBUS_Troubleshooting.html#obtaining-candump-logs","text":"The CAN bus messages sent to and from the micro-controller are handled by the Linux kernel. It is possible to capture these messages from the kernel for debugging purposes. A log of these messages may be of use in diagnostics. The Linux can-utils tool provides the capture software. It is typically installed on a machine by running: sudo apt-get update && sudo apt-get install can-utils Once installed, one may obtain a capture of all CAN bus messages on an interface with the following command: candump -tz -Ddex can0,#FFFFFFFF > mycanlog One can view the resulting log file ( mycanlog in the example above) to see each raw CAN bus message that was sent and received by Klipper. Understanding the content of these messages will likely require low-level knowledge of Klipper's CANBUS protocol and Klipper's MCU commands .","title":"Obtaining candump logs"},{"location":"CANBUS_Troubleshooting.html#parsing-klipper-messages-in-a-candump-log","text":"One may use the parsecandump.py tool to parse the low-level Klipper micro-controller messages contained in a candump log. Using this tool is an advanced topic that requires knowledge of Klipper MCU commands . For example: ./scripts/parsecandump.py mycanlog 108 ./out/klipper.dict This tool produces output similar to the parsedump tool . See the documentation for that tool for information on generating the Klipper micro-controller data dictionary. In the above example, 108 is the CAN bus id . It is a hexadecimal number. The id 108 is assigned by Klipper to the first micro-controller. If the CAN bus has multiple micro-controllers on it, then the second micro-controller would be 10a , the third would be 10c , and so on. The candump log must be produced using the -tz -Ddex command-line arguments (for example: candump -tz -Ddex can0,#FFFFFFFF ) in order to use the parsecandump.py tool.","title":"Parsing Klipper messages in a candump log"},{"location":"CANBUS_Troubleshooting.html#using-a-logic-analyzer-on-the-canbus-wiring","text":"The Sigrok Pulseview software along with a low-cost logic analyzer can be useful for diagnosing CAN bus signaling. This is an advanced topic likely only of interest to experts. One can often find \"USB logic analyzers\" for under $15 (US pricing as of 2023). These devices are often listed as \"Saleae logic clones\" or as \"24MHz 8 channel USB logic analyzers\". The above picture was taken while using Pulseview with a \"Saleae clone\" logic analyzer. The Sigrok and Pulseview software was installed on a desktop machine (also install the \"fx2lafw\" firmware if that is packaged separately). The CH0 pin on the logic analyzer was routed to the CAN Rx line, the CH1 pin was wired to the CAN Tx pin, and GND was wired to GND. Pulseview was configured to only display the D0 and D1 lines (red \"probe\" icon center top toolbar). The number of samples was set to 5 million (top toolbar) and the sample rate was set to 24Mhz (top toolbar). The CAN decoder was added (yellow and green \"bubble icon\" right top toolbar). The D0 channel was labeled as RX and set to trigger on a falling edge (click on black D0 label at left). The D1 channel was labeled as TX (click on brown D1 label at left). The CAN decoder was configured for 1Mbit rate (click on green CAN label at left). The CAN decoder was moved to the top of the display (click and drag green CAN label). Finally, the capture was started (click \"Run\" at top left) and a packet was transmitted on the CAN bus ( cansend can0 123#121212121212 ). The logic analyzer provides an independent tool for capturing packets and verifying bit timing.","title":"Using a logic analyzer on the canbus wiring"},{"location":"CANBUS_protocol.html","text":"Protocollo CANBUS \u00b6 Questo documento descrive il protocollo utilizzato da Klipper per comunicare su CAN bus . Vedere per informazioni sulla configurazione di Klipper con CANBUS. Assegnazione dell'id del microcontrollore \u00b6 Klipper utilizza solo pacchetti CAN bus di dimensioni standard CAN 2.0A, che sono limitati a 8 byte di dati e un identificatore bus CAN a 11 bit. Per supportare una comunicazione efficiente, a ogni microcontrollore viene assegnato in fase di esecuzione un ID nodo bus CAN univoco a 1 byte (\"canbus_nodeid\") per il traffico generale di comandi e risposte Klipper. I messaggi di comando di Klipper che vanno dall'host al microcontrollore utilizzano l'ID bus CAN di canbus_nodeid * 2 + 256 , mentre i messaggi di risposta di Klipper dal microcontrollore all'host usano canbus_nodeid * 2 + 256 + 1 . Ogni microcontrollore ha un identificatore di chip univoco assegnato in fabbrica che viene utilizzato durante l'assegnazione dell'ID. Questo identificatore pu\u00f2 superare la lunghezza di un pacchetto CAN, quindi una funzione hash viene utilizzata per generare un ID univoco a 6 byte ( canbus_uuid ) dall'ID di fabbrica. Messaggi dell'amministratore \u00b6 I messaggi dell'amministratore vengono utilizzati per l'assegnazione dell'ID. I messaggi di amministrazione inviati dall'host al microcontrollore utilizzano l'ID bus CAN \"0x3f0\" e i messaggi inviati dal microcontrollore all'host utilizzano l'ID bus CAN \"0x3f1\". Tutti i microcontrollori ascoltano i messaggi sull'id 0x3f0 ; quell'ID pu\u00f2 essere considerato un \"indirizzo di trasmissione\". messaggio CMD_QUERY_UNASSIGNED \u00b6 Questo comando interroga tutti i microcontrollori a cui non \u00e8 stato ancora assegnato un canbus_nodeid . I microcontrollori non assegnati risponderanno con un messaggio di risposta RESP_NEED_NODEID. Il formato del messaggio CMD_QUERY_UNASSIGNED \u00e8: <1 byte message_id = 0x00> CMD_SET_KLIPPER_NODEID messaggio \u00b6 Questo comando assegna un canbus_nodeid al microcontrollore con un dato canbus_uuid . Il formato del messaggio CMD_SET_KLIPPER_NODEID \u00e8: <1-byte message_id = 0x01><6-byte canbus_uuid><1-byte canbus_nodeid> Messaggio RESP_NEED_NODEID \u00b6 Il formato del messaggio RESP_NEED_NODEID \u00e8: <1-byte message_id = 0x20><6-byte canbus_uuid><1-byte set_klipper_nodeid = 0x01> Pacchetti dati \u00b6 Un microcontrollore a cui \u00e8 stato assegnato un nodeid tramite il comando CMD_SET_KLIPPER_NODEID pu\u00f2 inviare e ricevere pacchetti di dati. I dati del pacchetto nei messaggi che utilizzano l'ID bus CAN di ricezione del nodo ( canbus_nodeid * 2 + 256 ) vengono semplicemente aggiunti a un buffer e quando viene trovato un mcu protocol message completo, il suo contenuto viene analizzato ed elaborato . I dati vengono trattati come un flusso di byte: non \u00e8 necessario che l'inizio di un blocco di messaggi Klipper sia allineato con l'inizio di un pacchetto bus CAN. Allo stesso modo, le risposte ai messaggi del protocollo mcu vengono inviate dal microcontrollore all'host copiando i dati del messaggio in uno o pi\u00f9 pacchetti con l'ID del bus CAN di trasmissione del nodo ( canbus_nodeid * 2 + 256 + 1 ).","title":"Protocollo CANBUS"},{"location":"CANBUS_protocol.html#protocollo-canbus","text":"Questo documento descrive il protocollo utilizzato da Klipper per comunicare su CAN bus . Vedere per informazioni sulla configurazione di Klipper con CANBUS.","title":"Protocollo CANBUS"},{"location":"CANBUS_protocol.html#assegnazione-dellid-del-microcontrollore","text":"Klipper utilizza solo pacchetti CAN bus di dimensioni standard CAN 2.0A, che sono limitati a 8 byte di dati e un identificatore bus CAN a 11 bit. Per supportare una comunicazione efficiente, a ogni microcontrollore viene assegnato in fase di esecuzione un ID nodo bus CAN univoco a 1 byte (\"canbus_nodeid\") per il traffico generale di comandi e risposte Klipper. I messaggi di comando di Klipper che vanno dall'host al microcontrollore utilizzano l'ID bus CAN di canbus_nodeid * 2 + 256 , mentre i messaggi di risposta di Klipper dal microcontrollore all'host usano canbus_nodeid * 2 + 256 + 1 . Ogni microcontrollore ha un identificatore di chip univoco assegnato in fabbrica che viene utilizzato durante l'assegnazione dell'ID. Questo identificatore pu\u00f2 superare la lunghezza di un pacchetto CAN, quindi una funzione hash viene utilizzata per generare un ID univoco a 6 byte ( canbus_uuid ) dall'ID di fabbrica.","title":"Assegnazione dell'id del microcontrollore"},{"location":"CANBUS_protocol.html#messaggi-dellamministratore","text":"I messaggi dell'amministratore vengono utilizzati per l'assegnazione dell'ID. I messaggi di amministrazione inviati dall'host al microcontrollore utilizzano l'ID bus CAN \"0x3f0\" e i messaggi inviati dal microcontrollore all'host utilizzano l'ID bus CAN \"0x3f1\". Tutti i microcontrollori ascoltano i messaggi sull'id 0x3f0 ; quell'ID pu\u00f2 essere considerato un \"indirizzo di trasmissione\".","title":"Messaggi dell'amministratore"},{"location":"CANBUS_protocol.html#messaggio-cmd_query_unassigned","text":"Questo comando interroga tutti i microcontrollori a cui non \u00e8 stato ancora assegnato un canbus_nodeid . I microcontrollori non assegnati risponderanno con un messaggio di risposta RESP_NEED_NODEID. Il formato del messaggio CMD_QUERY_UNASSIGNED \u00e8: <1 byte message_id = 0x00>","title":"messaggio CMD_QUERY_UNASSIGNED"},{"location":"CANBUS_protocol.html#cmd_set_klipper_nodeid-messaggio","text":"Questo comando assegna un canbus_nodeid al microcontrollore con un dato canbus_uuid . Il formato del messaggio CMD_SET_KLIPPER_NODEID \u00e8: <1-byte message_id = 0x01><6-byte canbus_uuid><1-byte canbus_nodeid>","title":"CMD_SET_KLIPPER_NODEID messaggio"},{"location":"CANBUS_protocol.html#messaggio-resp_need_nodeid","text":"Il formato del messaggio RESP_NEED_NODEID \u00e8: <1-byte message_id = 0x20><6-byte canbus_uuid><1-byte set_klipper_nodeid = 0x01>","title":"Messaggio RESP_NEED_NODEID"},{"location":"CANBUS_protocol.html#pacchetti-dati","text":"Un microcontrollore a cui \u00e8 stato assegnato un nodeid tramite il comando CMD_SET_KLIPPER_NODEID pu\u00f2 inviare e ricevere pacchetti di dati. I dati del pacchetto nei messaggi che utilizzano l'ID bus CAN di ricezione del nodo ( canbus_nodeid * 2 + 256 ) vengono semplicemente aggiunti a un buffer e quando viene trovato un mcu protocol message completo, il suo contenuto viene analizzato ed elaborato . I dati vengono trattati come un flusso di byte: non \u00e8 necessario che l'inizio di un blocco di messaggi Klipper sia allineato con l'inizio di un pacchetto bus CAN. Allo stesso modo, le risposte ai messaggi del protocollo mcu vengono inviate dal microcontrollore all'host copiando i dati del messaggio in uno o pi\u00f9 pacchetti con l'ID del bus CAN di trasmissione del nodo ( canbus_nodeid * 2 + 256 + 1 ).","title":"Pacchetti dati"},{"location":"CONTRIBUTING.html","text":"Contribuire a Klipper \u00b6 Grazie per aver contribuito a Klipper! Questo documento descrive il processo per contribuire alle modifiche di Klipper. Consulta la contact page per informazioni sulla segnalazione di un problema o per i dettagli su come contattare gli sviluppatori. Panoramica del processo di contribuzione \u00b6 I contributi a Klipper seguono generalmente un processo di alto livello: Inizia creando una Richiesta pull GitHub quando un proposta \u00e8 pronta per la diffusione. Quando un reviewer \u00e8 disponibile per review l'invio, si assegner\u00e0 la richiesta pull su GitHub. L'obiettivo della revisione \u00e8 cercare i difetti e verificare che la proposta segua linee guida documentate. Dopo una revisione riuscita, il revisore \"approver\u00e0 la revisione\" su GitHub e un maintainer eseguir\u00e0 il commit della modifica al ramo principale di Klipper. Quando lavori sui miglioramenti, considera di iniziare (o contribuire a) un argomento su Klipper Discourse . Una discussione in corso sul forum pu\u00f2 migliorare la visibilit\u00e0 del lavoro di sviluppo e pu\u00f2 attirare altri interessati a testare nuovi lavori. Cosa aspettarsi da una revisione \u00b6 I contributi a Klipper vengono rivisti prima del merging. L'obiettivo principale del processo di revisione \u00e8 verificare la presenza di difetti e verificare che la presentazione segua le linee guida specificate nella documentazione di Klipper. Resta inteso che ci sono molti modi per portare a termine un compito; non \u00e8 intenzione della revisione discutere la \"migliore\" implementazione. Ove possibile, sono preferibili discussioni di revisione incentrate su fatti e misurazioni. La maggior parte degli invii otterr\u00e0 in feedback da una recensione. Preparati a ottenere feedback, fornire ulteriori dettagli e aggiornare l'invio, se necessario. Cose comuni che un revisore cercher\u00e0: L'invio \u00e8 privo di difetti ed \u00e8 pronto per essere diffuso? I realizzatori dei contributi sono tenuti a testare le loro modifiche prima dell'invio. I revisori cercano gli errori, ma in generale non testano gli invii. Un invio accettato viene spesso distribuito a migliaia di stampanti entro poche settimane dall'accettazione. La qualit\u00e0 degli invii \u00e8 quindi considerata una priorit\u00e0. Il repository GitHub principale Klipper3d/klipper non accetta lavori sperimentali. I realizzatori di contributi devono eseguire la sperimentazione, il debug e il test nei propri repository. Il server Klipper Discourse \u00e8 un buon posto per aumentare la consapevolezza del nuovo lavoro e per trovare utenti interessati a fornire feedback nel mondo reale. Gli invii devono superare tutti i test di regressione . Quando si corregge un difetto nel codice, i submitters dovrebbero avere una comprensione generale della causa principale di tale difetto e la correzione dovrebbe mirare a tale causa principale. Gli contributi di codice non devono contenere codice di debug eccessivo, opzioni di debug o registrazione del debug in fase di runtime. I commenti negli invii di codice dovrebbero concentrarsi sul miglioramento della manutenzione del codice. Gli invii non devono contenere \"codice commentato\" n\u00e9 commenti eccessivi che descrivono implementazioni passate. Non dovrebbero esserci commenti \"todo\" eccessivi. Gli aggiornamenti alla documentazione non devono dichiarare che si tratta di un \"work in progress\". L'invio fornisce un vantaggio \"ad alto impatto\" per gli utenti del mondo reale che svolgono attivit\u00e0 nel mondo reale? I revisori devono identificare, almeno nella loro mente, approssimativamente \"chi \u00e8 il pubblico di destinazione\", una scala approssimativa delle \"dimensioni di quel pubblico\", il \"beneficio\" che otterranno, come \"il beneficio viene misurato\" e i \"risultati di tali prove di misurazione\". Nella maggior parte dei casi questo sar\u00e0 ovvio sia per il mittente che per il revisore e non \u00e8 esplicitamente dichiarato durante una revisione. Le proposte al ramo principale di Klipper dovrebbero avere un pubblico di destinazione degno di nota. Come \"regola pratica\" generale, gli invii dovrebbero avere come target una base di utenti di almeno 100 utenti del mondo reale. Se un revisore chiede dettagli sul \"beneficio\" di un invio, non considerarlo una critica. Essere in grado di comprendere i vantaggi reali di un cambiamento \u00e8 una parte naturale di una revisione. Quando si discute dei benefici \u00e8 preferibile discutere di \"fatti e misurazioni\". In generale, i revisori non cercano risposte del modulo \"qualcuno potrebbe trovare utile l'opzione X\", n\u00e9 cercano risposte del modulo \"questo invio aggiunge una funzionalit\u00e0 implementata dal firmware X\". Invece, \u00e8 generalmente preferibile discutere i dettagli su come \u00e8 stato misurato il miglioramento della qualit\u00e0 e quali sono stati i risultati di tali misurazioni, ad esempio \"i test sulle stampanti Acme X1000 mostrano angoli migliorati come si vede in figura...\", o ad esempio \" il tempo di stampa dell'oggetto reale X su una stampante Foomatic X900 \u00e8 passato da 4 ore a 3,5 ore\". Resta inteso che i test di questo tipo possono richiedere molto tempo e sforzi. Alcune delle caratteristiche pi\u00f9 importanti di Klipper hanno richiesto mesi di discussioni, rielaborazioni, test e documentazione prima di essere fuse nel ramo principale. Tutti i nuovi moduli, opzioni di configurazione, comandi, parametri di comando e documenti dovrebbero avere un \"impatto elevato\". Non vogliamo appesantire gli utenti con opzioni che non possono configurare ragionevolmente n\u00e9 vogliamo appesantirli con opzioni che non forniscono un vantaggio notevole. Un revisore pu\u00f2 chiedere chiarimenti su come un utente deve configurare un'opzione - una risposta ideale conterr\u00e0 dettagli sul processo - ad esempio, \"gli utenti del MegaX500 dovrebbero impostare l'opzione X su 99,3 mentre gli utenti dell'Elite100Y dovrebbero calibrare l'opzione X usando la procedura ...\". Se l'obiettivo di un'opzione \u00e8 rendere il codice pi\u00f9 modulare, \u00e8 preferibile utilizzare le costanti del codice invece delle opzioni di configurazione rivolte all'utente. Nuovi moduli, nuove opzioni e nuovi parametri non dovrebbero fornire funzionalit\u00e0 simili ai moduli esistenti: se le differenze sono arbitrarie, \u00e8 preferibile utilizzare il sistema esistente o effettuare refactoring del codice esistente. Il copyright dell'invio \u00e8 chiaro, non gratuito e compatibile? I nuovi file C e Python dovrebbero avere una dichiarazione di copyright univoca. Vedere i file esistenti per il formato preferito. \u00c8 sconsigliato dichiarare un copyright su un file esistente quando si apportano modifiche minori a quel file. Il codice prelevato da fonti di terze parti deve essere compatibile con la licenza Klipper (GNU GPLv3). Grandi aggiunte di codice di terze parti dovrebbero essere aggiunte alla directory lib/ (e seguire il formato descritto in lib/README ). I mittenti devono fornire una Signed-off-line utilizzando il loro vero nome completo. Indica che il mittente \u00e8 d'accordo con il developer certificate of origin . L'invio segue le linee guida specificate nella documentazione di Klipper? In particolare, il codice deve seguire le linee guida in e i file di configurazione devono seguire le linee guida in . La documentazione di Klipper \u00e8 aggiornata per riflettere le nuove modifiche? Come minimo, la documentazione di riferimento deve essere aggiornata con le relative modifiche al codice: Tutti i comandi e i relativi parametri devono essere documentati in . Tutti i moduli rivolti all'utente e i relativi parametri di configurazione devono essere documentati in . Tutte le \"variabili di stato\" esportate devono essere documentate in . Tutti i nuovi \"webhook\" e i relativi parametri devono essere documentati in . Qualsiasi modifica che apporti una modifica non compatibile con le versioni precedenti a un comando o a un'impostazione del file di configurazione deve essere documentata in . I nuovi documenti dovrebbero essere aggiunti a e all'indice del sito web docs/_klipper3d/mkdocs.yml . I commit sono ben formati, affrontano un singolo argomento per commit e sono indipendenti? I messaggi di commit devono seguire il formato preferito . I commit non devono avere un conflitto in fase di merge. Le nuove aggiunte al ramo principale di Klipper vengono sempre eseguite tramite un \"rebase\" o \"squash and rebase\". In genere non \u00e8 necessario che i propositori uniscano nuovamente il loro invio ad ogni aggiornamento al repository principale di Klipper. Tuttavia, se c'\u00e8 un conflitto in fase di merge, si consiglia ai mittenti di usare git rebase per risolvere il conflitto. Ogni commit dovrebbe affrontare una singola modifica di alto livello. Le modifiche di grandi dimensioni dovrebbero essere suddivise in pi\u00f9 commit indipendenti. Ogni commit dovrebbe \"stare in piedi da solo\" in modo che strumenti come git bisect e git revert funzionino in modo affidabile. Le modifiche agli spazi bianchi non devono essere mescolate con le modifiche funzionali. In generale, le modifiche agli spazi bianchi gratuite non sono accettate a meno che non provengano dal \"proprietario\" stabilito del codice da modificare. Klipper non implementa una rigida \"guida allo stile di codifica\", ma le modifiche al codice esistente dovrebbero seguire il flusso di codice di alto livello, lo stile di indentazione del codice e il formato di quel codice esistente. Gli invii di nuovi moduli e sistemi hanno una maggiore flessibilit\u00e0 nello stile di codifica, ma \u00e8 preferibile che il nuovo codice segua uno stile internamente coerente e generalmente segua le norme di codifica. Non \u00e8 un obiettivo di una revisione discutere di \"migliori implementazioni\". Tuttavia, se un revisore ha difficolt\u00e0 a comprendere l'implementazione di un invio, pu\u00f2 richiedere modifiche per rendere l'implementazione pi\u00f9 trasparente. In particolare, se i revisori non riescono a convincersi che un contributo \u00e8 privo di difetti, potrebbero essere necessarie modifiche. Come parte di una revisione, un revisore pu\u00f2 creare una richiesta pull alternativa per un argomento. Questo pu\u00f2 essere fatto per evitare eccessivi \"avanti e indietro\" su elementi procedurali minori e quindi snellire il processo di proposta. Pu\u00f2 anche essere fatto perch\u00e9 la discussione ispira un revisore a costruire un'implementazione alternativa. Entrambe le situazioni sono il normale risultato di una revisione e non devono essere considerate critiche alla proposta originale. Aiutare con le revisioni \u00b6 Apprezziamo l'aiuto con le recensioni! Non \u00e8 necessario essere un revisore elencato per eseguire una revisione. I propositori di richieste pull di GitHub sono inoltre incoraggiati a rivedere i propri invii. Per aiutare con una revisione, segui i passaggi descritti in cosa aspettarsi in una revisione per verificare l'invio. Dopo aver completato la revisione, aggiungi un commento alla richiesta pull di GitHub con i tuoi risultati. Se l'invio supera la revisione, si prega di dichiararlo esplicitamente nel commento, ad esempio qualcosa del tipo \"Ho esaminato questa modifica in base ai passaggi del documento CONTRIBUTING e tutto mi sembra a posto\". Se non \u00e8 possibile completare alcuni passaggi della revisione, indicare esplicitamente quali passaggi sono stati rivisti e quali non sono stati rivisti, ad esempio qualcosa del tipo \"Non ho verificato la presenza di difetti nel codice, ma ho rivisto tutto il resto nel documento CONTRIBUTING e sembra buono\". Apprezziamo anche il test degli invii. Se il codice \u00e8 stato testato, aggiungi un commento alla richiesta pull di GitHub con i risultati del tuo test: successo o fallimento. Si prega di affermare esplicitamente che il codice \u00e8 stato testato e i risultati, ad esempio qualcosa del tipo \"Ho testato questo codice sulla mia stampante Acme900Z con una stampa a vaso e i risultati sono stati buoni\". Revisori \u00b6 I \"revisori\" di Klipper sono: Nome GitHub Id Aree di interesse Dmitry Butyugin @dmbutyugin Input shaping, test di risonanza, cinematica Eric Callahan @Arksine Livellamento del piatto, flashing MCU James Hartley @JamesH1978 File di configurazione Kevin O'Connor @KevinOConnor Core motion system, codice microcontrollore Si prega di non eseguire il \"ping\" di nessuno dei revisori e di non indirizzare gli invii a loro. Tutti i revisori controllano i forum e le PR e si occuperanno delle revisioni quando ne avranno il tempo. I \"manutentori\" di Klipper sono: Nome nome GitHub Kevin O'Connor @KevinOConnor Formato dei messaggi di commit \u00b6 Ogni commit dovrebbe avere un messaggio di commit formattato in modo simile al seguente: modulo: Riepilogo breve (50 caratteri o meno) in maiuscolo Testo esplicativo pi\u00f9 dettagliato, se necessario. Incolonna a circa 75 caratteri o gi\u00f9 di l\u00ec. In alcuni contesti, la prima riga \u00e8 trattata come l'oggetto di un'e-mail e il resto del testo come corpo. La riga vuota che separa il riassunto dal corpo \u00e8 critica (a meno che non si ometta del tutto il corpo); strumenti come rebase possono confondersi se li metti due insieme. Ulteriori paragrafi vengono dopo le righe vuote.. Firmato da: Il mio nome <myemail@example.org> Nell'esempio sopra, module dovrebbe essere il nome di un file o di una directory nel repository (senza un'estensione di file). Ad esempio, clocksync: fix di errore di battitura nella chiamata pause() al momento della connessione . Lo scopo di specificare un nome di modulo nel messaggio di commit \u00e8 di aiutare a fornire il contesto per i commenti di commit. \u00c8 importante avere una riga \"Signed-off-by\" su ogni commit - certifica che accetti il developer certificate of origin . Deve contenere il tuo vero nome (mi dispiace, niente pseudonimi o contributi anonimi) e contenere un indirizzo email corrente. Contribuire a Traduzioni Klipper \u00b6 Klipper-translations Project \u00e8 un progetto dedicato alla traduzione di Klipper in diverse lingue. Weblate ospita tutte le stringhe Gettext per la traduzione e la revisione. Le impostazioni locali possono essere visualizzate su klipper3d.org una volta che soddisfano i seguenti requisiti: 75% Copertura totale Tutti i titoli (H1) sono tradotti Una gerarchia di navigazione PR aggiornata nelle traduzioni klipper. Per ridurre la frustrazione di tradurre termini specifici del dominio e acquisire consapevolezza delle traduzioni in corso, puoi inviare un PR modificando il Klipper-translations Project readme.md . Una volta che una traduzione \u00e8 pronta, \u00e8 possibile apportare la modifica corrispondente al progetto Klipper. Se una traduzione esiste gi\u00e0 nel repository Klipper e non soddisfa pi\u00f9 l'elenco di controllo di cui sopra, verr\u00e0 contrassegnata come obsoleta dopo un mese senza aggiornamenti. Una volta soddisfatti i requisiti, \u00e8 necessario: aggiorna il repository di klipper-translations active_translations Opzionale: aggiungi un file manual-index.md nella cartella docs\\locals\\<lang> del repository klipper-translations per sostituire index.md specifico della lingua (il file index.md generato non viene visualizzato correttamente). Problemi noti: Al momento, non esiste un metodo per tradurre correttamente le immagini nella documentazione \u00c8 impossibile tradurre i titoli in mkdocs.yml.","title":"Contribuire a Klipper"},{"location":"CONTRIBUTING.html#contribuire-a-klipper","text":"Grazie per aver contribuito a Klipper! Questo documento descrive il processo per contribuire alle modifiche di Klipper. Consulta la contact page per informazioni sulla segnalazione di un problema o per i dettagli su come contattare gli sviluppatori.","title":"Contribuire a Klipper"},{"location":"CONTRIBUTING.html#panoramica-del-processo-di-contribuzione","text":"I contributi a Klipper seguono generalmente un processo di alto livello: Inizia creando una Richiesta pull GitHub quando un proposta \u00e8 pronta per la diffusione. Quando un reviewer \u00e8 disponibile per review l'invio, si assegner\u00e0 la richiesta pull su GitHub. L'obiettivo della revisione \u00e8 cercare i difetti e verificare che la proposta segua linee guida documentate. Dopo una revisione riuscita, il revisore \"approver\u00e0 la revisione\" su GitHub e un maintainer eseguir\u00e0 il commit della modifica al ramo principale di Klipper. Quando lavori sui miglioramenti, considera di iniziare (o contribuire a) un argomento su Klipper Discourse . Una discussione in corso sul forum pu\u00f2 migliorare la visibilit\u00e0 del lavoro di sviluppo e pu\u00f2 attirare altri interessati a testare nuovi lavori.","title":"Panoramica del processo di contribuzione"},{"location":"CONTRIBUTING.html#cosa-aspettarsi-da-una-revisione","text":"I contributi a Klipper vengono rivisti prima del merging. L'obiettivo principale del processo di revisione \u00e8 verificare la presenza di difetti e verificare che la presentazione segua le linee guida specificate nella documentazione di Klipper. Resta inteso che ci sono molti modi per portare a termine un compito; non \u00e8 intenzione della revisione discutere la \"migliore\" implementazione. Ove possibile, sono preferibili discussioni di revisione incentrate su fatti e misurazioni. La maggior parte degli invii otterr\u00e0 in feedback da una recensione. Preparati a ottenere feedback, fornire ulteriori dettagli e aggiornare l'invio, se necessario. Cose comuni che un revisore cercher\u00e0: L'invio \u00e8 privo di difetti ed \u00e8 pronto per essere diffuso? I realizzatori dei contributi sono tenuti a testare le loro modifiche prima dell'invio. I revisori cercano gli errori, ma in generale non testano gli invii. Un invio accettato viene spesso distribuito a migliaia di stampanti entro poche settimane dall'accettazione. La qualit\u00e0 degli invii \u00e8 quindi considerata una priorit\u00e0. Il repository GitHub principale Klipper3d/klipper non accetta lavori sperimentali. I realizzatori di contributi devono eseguire la sperimentazione, il debug e il test nei propri repository. Il server Klipper Discourse \u00e8 un buon posto per aumentare la consapevolezza del nuovo lavoro e per trovare utenti interessati a fornire feedback nel mondo reale. Gli invii devono superare tutti i test di regressione . Quando si corregge un difetto nel codice, i submitters dovrebbero avere una comprensione generale della causa principale di tale difetto e la correzione dovrebbe mirare a tale causa principale. Gli contributi di codice non devono contenere codice di debug eccessivo, opzioni di debug o registrazione del debug in fase di runtime. I commenti negli invii di codice dovrebbero concentrarsi sul miglioramento della manutenzione del codice. Gli invii non devono contenere \"codice commentato\" n\u00e9 commenti eccessivi che descrivono implementazioni passate. Non dovrebbero esserci commenti \"todo\" eccessivi. Gli aggiornamenti alla documentazione non devono dichiarare che si tratta di un \"work in progress\". L'invio fornisce un vantaggio \"ad alto impatto\" per gli utenti del mondo reale che svolgono attivit\u00e0 nel mondo reale? I revisori devono identificare, almeno nella loro mente, approssimativamente \"chi \u00e8 il pubblico di destinazione\", una scala approssimativa delle \"dimensioni di quel pubblico\", il \"beneficio\" che otterranno, come \"il beneficio viene misurato\" e i \"risultati di tali prove di misurazione\". Nella maggior parte dei casi questo sar\u00e0 ovvio sia per il mittente che per il revisore e non \u00e8 esplicitamente dichiarato durante una revisione. Le proposte al ramo principale di Klipper dovrebbero avere un pubblico di destinazione degno di nota. Come \"regola pratica\" generale, gli invii dovrebbero avere come target una base di utenti di almeno 100 utenti del mondo reale. Se un revisore chiede dettagli sul \"beneficio\" di un invio, non considerarlo una critica. Essere in grado di comprendere i vantaggi reali di un cambiamento \u00e8 una parte naturale di una revisione. Quando si discute dei benefici \u00e8 preferibile discutere di \"fatti e misurazioni\". In generale, i revisori non cercano risposte del modulo \"qualcuno potrebbe trovare utile l'opzione X\", n\u00e9 cercano risposte del modulo \"questo invio aggiunge una funzionalit\u00e0 implementata dal firmware X\". Invece, \u00e8 generalmente preferibile discutere i dettagli su come \u00e8 stato misurato il miglioramento della qualit\u00e0 e quali sono stati i risultati di tali misurazioni, ad esempio \"i test sulle stampanti Acme X1000 mostrano angoli migliorati come si vede in figura...\", o ad esempio \" il tempo di stampa dell'oggetto reale X su una stampante Foomatic X900 \u00e8 passato da 4 ore a 3,5 ore\". Resta inteso che i test di questo tipo possono richiedere molto tempo e sforzi. Alcune delle caratteristiche pi\u00f9 importanti di Klipper hanno richiesto mesi di discussioni, rielaborazioni, test e documentazione prima di essere fuse nel ramo principale. Tutti i nuovi moduli, opzioni di configurazione, comandi, parametri di comando e documenti dovrebbero avere un \"impatto elevato\". Non vogliamo appesantire gli utenti con opzioni che non possono configurare ragionevolmente n\u00e9 vogliamo appesantirli con opzioni che non forniscono un vantaggio notevole. Un revisore pu\u00f2 chiedere chiarimenti su come un utente deve configurare un'opzione - una risposta ideale conterr\u00e0 dettagli sul processo - ad esempio, \"gli utenti del MegaX500 dovrebbero impostare l'opzione X su 99,3 mentre gli utenti dell'Elite100Y dovrebbero calibrare l'opzione X usando la procedura ...\". Se l'obiettivo di un'opzione \u00e8 rendere il codice pi\u00f9 modulare, \u00e8 preferibile utilizzare le costanti del codice invece delle opzioni di configurazione rivolte all'utente. Nuovi moduli, nuove opzioni e nuovi parametri non dovrebbero fornire funzionalit\u00e0 simili ai moduli esistenti: se le differenze sono arbitrarie, \u00e8 preferibile utilizzare il sistema esistente o effettuare refactoring del codice esistente. Il copyright dell'invio \u00e8 chiaro, non gratuito e compatibile? I nuovi file C e Python dovrebbero avere una dichiarazione di copyright univoca. Vedere i file esistenti per il formato preferito. \u00c8 sconsigliato dichiarare un copyright su un file esistente quando si apportano modifiche minori a quel file. Il codice prelevato da fonti di terze parti deve essere compatibile con la licenza Klipper (GNU GPLv3). Grandi aggiunte di codice di terze parti dovrebbero essere aggiunte alla directory lib/ (e seguire il formato descritto in lib/README ). I mittenti devono fornire una Signed-off-line utilizzando il loro vero nome completo. Indica che il mittente \u00e8 d'accordo con il developer certificate of origin . L'invio segue le linee guida specificate nella documentazione di Klipper? In particolare, il codice deve seguire le linee guida in e i file di configurazione devono seguire le linee guida in . La documentazione di Klipper \u00e8 aggiornata per riflettere le nuove modifiche? Come minimo, la documentazione di riferimento deve essere aggiornata con le relative modifiche al codice: Tutti i comandi e i relativi parametri devono essere documentati in . Tutti i moduli rivolti all'utente e i relativi parametri di configurazione devono essere documentati in . Tutte le \"variabili di stato\" esportate devono essere documentate in . Tutti i nuovi \"webhook\" e i relativi parametri devono essere documentati in . Qualsiasi modifica che apporti una modifica non compatibile con le versioni precedenti a un comando o a un'impostazione del file di configurazione deve essere documentata in . I nuovi documenti dovrebbero essere aggiunti a e all'indice del sito web docs/_klipper3d/mkdocs.yml . I commit sono ben formati, affrontano un singolo argomento per commit e sono indipendenti? I messaggi di commit devono seguire il formato preferito . I commit non devono avere un conflitto in fase di merge. Le nuove aggiunte al ramo principale di Klipper vengono sempre eseguite tramite un \"rebase\" o \"squash and rebase\". In genere non \u00e8 necessario che i propositori uniscano nuovamente il loro invio ad ogni aggiornamento al repository principale di Klipper. Tuttavia, se c'\u00e8 un conflitto in fase di merge, si consiglia ai mittenti di usare git rebase per risolvere il conflitto. Ogni commit dovrebbe affrontare una singola modifica di alto livello. Le modifiche di grandi dimensioni dovrebbero essere suddivise in pi\u00f9 commit indipendenti. Ogni commit dovrebbe \"stare in piedi da solo\" in modo che strumenti come git bisect e git revert funzionino in modo affidabile. Le modifiche agli spazi bianchi non devono essere mescolate con le modifiche funzionali. In generale, le modifiche agli spazi bianchi gratuite non sono accettate a meno che non provengano dal \"proprietario\" stabilito del codice da modificare. Klipper non implementa una rigida \"guida allo stile di codifica\", ma le modifiche al codice esistente dovrebbero seguire il flusso di codice di alto livello, lo stile di indentazione del codice e il formato di quel codice esistente. Gli invii di nuovi moduli e sistemi hanno una maggiore flessibilit\u00e0 nello stile di codifica, ma \u00e8 preferibile che il nuovo codice segua uno stile internamente coerente e generalmente segua le norme di codifica. Non \u00e8 un obiettivo di una revisione discutere di \"migliori implementazioni\". Tuttavia, se un revisore ha difficolt\u00e0 a comprendere l'implementazione di un invio, pu\u00f2 richiedere modifiche per rendere l'implementazione pi\u00f9 trasparente. In particolare, se i revisori non riescono a convincersi che un contributo \u00e8 privo di difetti, potrebbero essere necessarie modifiche. Come parte di una revisione, un revisore pu\u00f2 creare una richiesta pull alternativa per un argomento. Questo pu\u00f2 essere fatto per evitare eccessivi \"avanti e indietro\" su elementi procedurali minori e quindi snellire il processo di proposta. Pu\u00f2 anche essere fatto perch\u00e9 la discussione ispira un revisore a costruire un'implementazione alternativa. Entrambe le situazioni sono il normale risultato di una revisione e non devono essere considerate critiche alla proposta originale.","title":"Cosa aspettarsi da una revisione"},{"location":"CONTRIBUTING.html#aiutare-con-le-revisioni","text":"Apprezziamo l'aiuto con le recensioni! Non \u00e8 necessario essere un revisore elencato per eseguire una revisione. I propositori di richieste pull di GitHub sono inoltre incoraggiati a rivedere i propri invii. Per aiutare con una revisione, segui i passaggi descritti in cosa aspettarsi in una revisione per verificare l'invio. Dopo aver completato la revisione, aggiungi un commento alla richiesta pull di GitHub con i tuoi risultati. Se l'invio supera la revisione, si prega di dichiararlo esplicitamente nel commento, ad esempio qualcosa del tipo \"Ho esaminato questa modifica in base ai passaggi del documento CONTRIBUTING e tutto mi sembra a posto\". Se non \u00e8 possibile completare alcuni passaggi della revisione, indicare esplicitamente quali passaggi sono stati rivisti e quali non sono stati rivisti, ad esempio qualcosa del tipo \"Non ho verificato la presenza di difetti nel codice, ma ho rivisto tutto il resto nel documento CONTRIBUTING e sembra buono\". Apprezziamo anche il test degli invii. Se il codice \u00e8 stato testato, aggiungi un commento alla richiesta pull di GitHub con i risultati del tuo test: successo o fallimento. Si prega di affermare esplicitamente che il codice \u00e8 stato testato e i risultati, ad esempio qualcosa del tipo \"Ho testato questo codice sulla mia stampante Acme900Z con una stampa a vaso e i risultati sono stati buoni\".","title":"Aiutare con le revisioni"},{"location":"CONTRIBUTING.html#revisori","text":"I \"revisori\" di Klipper sono: Nome GitHub Id Aree di interesse Dmitry Butyugin @dmbutyugin Input shaping, test di risonanza, cinematica Eric Callahan @Arksine Livellamento del piatto, flashing MCU James Hartley @JamesH1978 File di configurazione Kevin O'Connor @KevinOConnor Core motion system, codice microcontrollore Si prega di non eseguire il \"ping\" di nessuno dei revisori e di non indirizzare gli invii a loro. Tutti i revisori controllano i forum e le PR e si occuperanno delle revisioni quando ne avranno il tempo. I \"manutentori\" di Klipper sono: Nome nome GitHub Kevin O'Connor @KevinOConnor","title":"Revisori"},{"location":"CONTRIBUTING.html#formato-dei-messaggi-di-commit","text":"Ogni commit dovrebbe avere un messaggio di commit formattato in modo simile al seguente: modulo: Riepilogo breve (50 caratteri o meno) in maiuscolo Testo esplicativo pi\u00f9 dettagliato, se necessario. Incolonna a circa 75 caratteri o gi\u00f9 di l\u00ec. In alcuni contesti, la prima riga \u00e8 trattata come l'oggetto di un'e-mail e il resto del testo come corpo. La riga vuota che separa il riassunto dal corpo \u00e8 critica (a meno che non si ometta del tutto il corpo); strumenti come rebase possono confondersi se li metti due insieme. Ulteriori paragrafi vengono dopo le righe vuote.. Firmato da: Il mio nome <myemail@example.org> Nell'esempio sopra, module dovrebbe essere il nome di un file o di una directory nel repository (senza un'estensione di file). Ad esempio, clocksync: fix di errore di battitura nella chiamata pause() al momento della connessione . Lo scopo di specificare un nome di modulo nel messaggio di commit \u00e8 di aiutare a fornire il contesto per i commenti di commit. \u00c8 importante avere una riga \"Signed-off-by\" su ogni commit - certifica che accetti il developer certificate of origin . Deve contenere il tuo vero nome (mi dispiace, niente pseudonimi o contributi anonimi) e contenere un indirizzo email corrente.","title":"Formato dei messaggi di commit"},{"location":"CONTRIBUTING.html#contribuire-a-traduzioni-klipper","text":"Klipper-translations Project \u00e8 un progetto dedicato alla traduzione di Klipper in diverse lingue. Weblate ospita tutte le stringhe Gettext per la traduzione e la revisione. Le impostazioni locali possono essere visualizzate su klipper3d.org una volta che soddisfano i seguenti requisiti: 75% Copertura totale Tutti i titoli (H1) sono tradotti Una gerarchia di navigazione PR aggiornata nelle traduzioni klipper. Per ridurre la frustrazione di tradurre termini specifici del dominio e acquisire consapevolezza delle traduzioni in corso, puoi inviare un PR modificando il Klipper-translations Project readme.md . Una volta che una traduzione \u00e8 pronta, \u00e8 possibile apportare la modifica corrispondente al progetto Klipper. Se una traduzione esiste gi\u00e0 nel repository Klipper e non soddisfa pi\u00f9 l'elenco di controllo di cui sopra, verr\u00e0 contrassegnata come obsoleta dopo un mese senza aggiornamenti. Una volta soddisfatti i requisiti, \u00e8 necessario: aggiorna il repository di klipper-translations active_translations Opzionale: aggiungi un file manual-index.md nella cartella docs\\locals\\<lang> del repository klipper-translations per sostituire index.md specifico della lingua (il file index.md generato non viene visualizzato correttamente). Problemi noti: Al momento, non esiste un metodo per tradurre correttamente le immagini nella documentazione \u00c8 impossibile tradurre i titoli in mkdocs.yml.","title":"Contribuire a Traduzioni Klipper"},{"location":"Code_Overview.html","text":"Panoramica del codice \u00b6 Questo documento descrive il formato generale del codice e il flusso principale del codice di Klipper. Directory Layout \u00b6 La directory src/ contiene il sorgente C per il codice del microcontrollore. src/atsam/ , src/atsamd/ , src/avr/ , src/linux/ , src/lpc176x/ , src/ Le directory pru/ e src/stm32/ contengono il codice del microcontrollore specifico dell'architettura. src/simulator/ contiene stub di codice che consentono la compilazione di test del microcontrollore su altre architetture. La directory src/generic/ contiene codice di supporto che pu\u00f2 essere utile in diverse architetture. La build fa in modo che le include di \"board/somefile.h\" guardino prima nella directory dell'architettura corrente (ad esempio, src/avr/somefile.h) e poi nella directory generica (ad esempio, src/generic/somefile.h). La directory klippy/ contiene il software host. La maggior parte del software host \u00e8 scritto in Python, tuttavia la directory klippy/chelper/ contiene alcuni helper del codice C. La directory klippy/kinematics/ contiene il codice della cinematica del robot. La directory klippy/extras/ contiene i \"moduli\" estensibili del codice host. La directory lib/ contiene il codice della libreria di terze parti esterne necessarie per creare alcune destinazioni. La directory config/ contiene file di configurazione della stampante di esempio. La directory scripts/ contiene script di build-time utili per compilare il codice del microcontrollore. La directory test/ contiene test case automatizzati. Durante la compilazione, la build potrebbe creare una directory out/ . Questa contiene oggetti temporanei di compilazione. L'oggetto microcontrollore finale che viene creato \u00e8 out/klipper.elf.hex su AVR e out/klipper.bin su ARM. Flusso del codice del microcontrollore \u00b6 L'esecuzione del codice del microcontrollore inizia nel codice specifico dell'architettura (ad esempio, src/avr/main.c ) che alla fine chiama sched_main() che si trova in src/sched.c . Il codice sched_main() inizia eseguendo tutte le funzioni che sono state contrassegnate con la macro DECL_INIT(). Quindi continua a eseguire ripetutamente tutte le funzioni contrassegnate con la macro DECL_TASK(). Una delle principali funzioni dell'attivit\u00e0 \u00e8 command_dispatch() che si trova in src/command.c . Questa funzione viene richiamata dal codice input/output specifico della scheda (es. src/avr/serial.c , src/generic/serial_irq.c ) ed esegue le funzioni di comando associate ai comandi trovati nel flusso di input. Le funzioni di comando vengono dichiarate utilizzando la macro DECL_COMMAND() (consultare il documento protocol per ulteriori informazioni). Le funzioni task, init e comando vengono sempre eseguite con gli interrupt abilitati (tuttavia, possono disabilitare temporaneamente gli interrupt se necessario). Queste funzioni dovrebbero evitare lunghe pause, ritardi o eseguire lavori che durano un tempo significativo. (Lunghi ritardi in queste funzioni di \"attivit\u00e0\" provocano un jitter di pianificazione per altre \"attivit\u00e0\" - ritardi superiori a 100us possono diventare evidenti, ritardi superiori a 500us possono causare ritrasmissioni dei comandi, ritardi superiori a 100 ms possono causare riavvii del watchdog.) Queste funzioni pianificano il lavoro a orari specifici programmando i timer. Le funzioni timer vengono pianificate chiamando sched_add_timer() (che si trova in src/sched.c ). Il codice di pianificazione far\u00e0 in modo che la funzione data venga chiamata all'ora richiesta. Gli interrupt timer sono inizialmente gestiti in un gestore di interrupt specifico dell'architettura (ad esempio, src/avr/timer.c ) che chiama sched_timer_dispatch() situato in src/sched.c . L'interruzione del timer porta all'esecuzione delle funzioni del timer di pianificazione. Le funzioni timer vengono eseguite sempre con gli interrupt disabilitati. Le funzioni del timer dovrebbero sempre completarsi entro pochi microsecondi. Al completamento dell'evento timer, la funzione pu\u00f2 scegliere di riprogrammare se stessa. Nel caso in cui venga rilevato un errore, il codice pu\u00f2 invocare shutdown() (una macro che chiama sched_shutdown() situata in src/sched.c ). Il richiamo di shutdown() provoca l'esecuzione di tutte le funzioni contrassegnate con la macro DECL_SHUTDOWN(). Le funzioni di spegnimento vengono eseguite sempre con gli interrupt disabilitati. Gran parte delle funzionalit\u00e0 del microcontrollore implica il lavoro con pin di input/output per uso generico (GPIO). Per astrarre il codice specifico dell'architettura di basso livello dal codice dell'attivit\u00e0 di alto livello, tutti gli eventi GPIO sono implementati in wrapper specifici dell'architettura (ad esempio, src/avr/gpio.c ). Il codice \u00e8 compilato con l'ottimizzazione \"-flto -fwhole-program\" di gcc che fa un ottimo lavoro di inlining delle funzioni tra le unit\u00e0 di compilazione, quindi la maggior parte di queste minuscole funzioni gpio sono integrate nei loro chiamanti e non ci sono costi di runtime per l'utilizzo loro. Panoramica del codice Klippy \u00b6 Il codice host (Klippy) deve essere eseguito su un computer a basso costo (come un Raspberry Pi) abbinato al microcontrollore. Il codice \u00e8 scritto principalmente in Python, tuttavia utilizza CFFI per implementare alcune funzionalit\u00e0 nel codice C. L'esecuzione iniziale comincia in klippy/klippy.py . Questo legge gli argomenti della riga di comando, apre il file di configurazione della stampante, crea un'istanza degli oggetti principali della stampante e avvia la connessione seriale. L'esecuzione principale dei comandi G-code \u00e8 nel metodo process_commands() in klippy/gcode.py . Questo codice traduce i comandi del codice G in chiamate a oggetti stampante, che spesso traducono le azioni in comandi da eseguire sul microcontrollore (come dichiarato tramite la macro DECL_COMMAND nel codice del microcontrollore). Ci sono quattro thread nel codice host di Klippy. Il thread principale gestisce i comandi gcode in arrivo. Un secondo thread (che risiede interamente nel codice C klippy/chelper/serialqueue.c ) gestisce l'IO di basso livello con la porta seriale. Il terzo thread viene utilizzato per elaborare i messaggi di risposta dal microcontrollore nel codice Python (vedi klippy/serialhdl.py ). Il quarto thread scrive i messaggi di debug nel log (vedi klippy/queuelogger.py ) in modo che gli altri thread non blocchino mai le scritture del log. Flusso di codice di un comando di spostamento \u00b6 Un tipico movimento della stampante inizia quando viene inviato un comando \"G1\" all'host Klippy e si completa quando vengono prodotti i corrispondenti impulsi di passo sul microcontrollore. Questa sezione delinea il flusso di codice di un tipico comando di spostamento. Il documento cinematica fornisce ulteriori informazioni sulla meccanica dei movimenti. L'elaborazione di un comando di spostamento inizia in gcode.py. L'obiettivo di gcode.py \u00e8 tradurre il G-code in chiamate interne. Un comando G1 invocher\u00e0 cmd_G1() in klippy/extras/gcode_move.py. Il codice gcode_move.py gestisce le modifiche all'origine (ad esempio, G92), le modifiche alle posizioni relative rispetto a quelle assolute (ad esempio, G90) e le modifiche alle unit\u00e0 (ad esempio, F6000=100mm/s). Il percorso del codice per una mossa \u00e8: _process_data() -> _process_commands() -> cmd_G1() . Infine viene invocata la classe ToolHead per eseguire la richiesta effettiva: cmd_G1() -> ToolHead.move() The ToolHead class (in toolhead.py) handles \"look-ahead\" and tracks the timing of printing actions. The main codepath for a move is: ToolHead.move() -> LookAheadQueue.add_move() -> LookAheadQueue.flush() -> Move.set_junction() -> ToolHead._process_moves() . ToolHead.move() crea un oggetto Move() con i parametri del movimento (in spazio cartesiano e in unit\u00e0 di secondi e millimetri). Alla classe cinematica viene data l'opportunit\u00e0 di controllare ogni movimento ( ToolHead.move() -> kin.check_move() ). Le classi cinematiche si trovano nella directory klippy/cinematica/. Il codice check_move() pu\u00f2 generare un errore se il movimento non \u00e8 valida. Se check_move() viene completato correttamente, la cinematica sottostante deve essere in grado di gestire lo spostamento. LookAheadQueue.add_move() places the move object on the \"look-ahead\" queue. LookAheadQueue.flush() determines the start and end velocities of each move. Move.set_junction() implementa il \"generatore di trapezi\" per il movimento. Il \"generatore trapezoidale\" suddivide ogni movimento in tre parti: una fase di accelerazione costante, seguita da una fase di velocit\u00e0 costante, seguita da una fase di decelerazione costante. Ogni mossa contiene queste tre fasi in questo ordine, ma alcune fasi possono avere durata zero. Quando viene chiamato ToolHead._process_moves(), tutto ci\u00f2 che riguarda lo spostamento \u00e8 noto: la sua posizione iniziale, la sua posizione finale, la sua accelerazione, la sua velocit\u00e0 di inizio/crociera/finale e la distanza percorsa durante l'accelerazione/crociera/decelerazione. Tutte le informazioni sono memorizzate nella classe Move() e sono nello spazio cartesiano in unit\u00e0 di millimetri e secondi. Klipper uses an iterative solver to generate the step times for each stepper. For efficiency reasons, the stepper pulse times are generated in C code. The moves are first placed on a \"trapezoid motion queue\": ToolHead._process_moves() -> trapq_append() (in klippy/chelper/trapq.c). The step times are then generated: ToolHead._process_moves() -> ToolHead._advance_move_time() -> ToolHead._advance_flush_time() -> MCU_Stepper.generate_steps() -> itersolve_generate_steps() -> itersolve_gen_steps_range() (in klippy/chelper/itersolve.c). The goal of the iterative solver is to find step times given a function that calculates a stepper position from a time. This is done by repeatedly \"guessing\" various times until the stepper position formula returns the desired position of the next step on the stepper. The feedback produced from each guess is used to improve future guesses so that the process rapidly converges to the desired time. The kinematic stepper position formulas are located in the klippy/chelper/ directory (eg, kin_cart.c, kin_corexy.c, kin_delta.c, kin_extruder.c). Si noti che l'estrusore \u00e8 gestito nella propria classe cinematica: ToolHead._process_moves() -> PrinterExtruder.move() . Poich\u00e9 la classe Move() specifica l'esatto tempo di movimento e poich\u00e9 gli impulsi di passo vengono inviati al microcontrollore con una tempistica specifica, i movimenti passo-passo prodotti dalla classe estrusore saranno sincronizzati con il movimento della testa anche se il codice viene mantenuto separato. Dopo che il risolutore iterativo ha calcolato i tempi di passaggio, questi vengono aggiunti a un array: itersolve_gen_steps_range() -> stepcompress_append() (in klippy/chelper/stepcompress.c). L'array (struct stepcompress.queue) memorizza i corrispondenti tempi del contatore dell'orologio del microcontrollore per ogni passaggio. Qui il valore del \"contatore orologio del microcontrollore\" corrisponde direttamente al contatore hardware del microcontrollore - \u00e8 relativo a quando il microcontrollore \u00e8 stato acceso l'ultima volta. Il prossimo passo importante \u00e8 comprimere i passaggi: stepcompress_flush() -> compress_bisect_add() (in klippy/chelper/stepcompress.c). Questo codice genera e codifica una serie di comandi \"queue_step\" del microcontrollore che corrispondono all'elenco dei tempi di stepper compilati nella fase precedente. Questi comandi \"queue_step\" vengono quindi accodati, assegnati a priorit\u00e0 e inviati al microcontrollore (tramite stepcompress.c:steppersync e serialqueue.c:serialqueue). L'elaborazione dei comandi queue_step sul microcontrollore inizia in src/command.c che analizza il comando e chiama command_queue_step() . Il codice command_queue_step() (in src/stepper.c) aggiunge semplicemente i parametri di ogni comando queue_step a una coda per stepper. In condizioni normali, il comando queue_step viene analizzato e messo in coda almeno 100 ms prima dell'ora del suo primo passaggio. Infine, la generazione degli eventi stepper viene eseguita in stepper_event() . Viene chiamato dall'interruzione del timer hardware all'ora pianificata del primo passaggio. Il codice stepper_event() genera un impulso di passaggio e quindi si riprogramma per essere eseguito al momento dell'impulso di passaggio successivo per i parametri queue_step specificati. I parametri per ogni comando queue_step sono \"interval\", \"count\" e \"add\". Ad alto livello, stepper_event() esegue quanto segue, 'count' volte: do_step(); next_wake_time = last_wake_time + intervallo; intervallo += aggiungi; Quanto sopra pu\u00f2 sembrare un sacco di complessit\u00e0 per eseguire un movimento. Tuttavia, le uniche parti veramente interessanti sono nelle classi ToolHead e cinematica. \u00c8 questa parte del codice che specifica i movimenti e le loro tempistiche. Le restanti parti dell'elaborazione sono per lo pi\u00f9 solo comunicazioni e collegamenti. Aggiunta di un modulo host \u00b6 Il codice host Klippy ha una capacit\u00e0 di caricamento dinamico dei moduli. Se nel file di configurazione della stampante viene trovata una sezione di configurazione denominata \"[my_module]\", il software tenter\u00e0 automaticamente di caricare il modulo python klippy/extras/my_module.py . Questo sistema di moduli \u00e8 il metodo preferito per aggiungere nuove funzionalit\u00e0 a Klipper. Il modo pi\u00f9 semplice per aggiungere un nuovo modulo \u00e8 utilizzare un modulo esistente come riferimento - vedere klippy/extras/servo.py come esempio. Possono essere utili anche: L'esecuzione del modulo inizia nella funzione load_config() a livello di modulo (per le sezioni di configurazione del modulo [my_module]) o in load_config_prefix() (per le sezioni di configurazione del modulo [my_module my_name]). A questa funzione viene passato un oggetto \"config\" e deve restituire un nuovo \"oggetto stampante\" associato alla sezione di configurazione specificata. Durante il processo di creazione di un'istanza di un nuovo oggetto stampante, l'oggetto di configurazione pu\u00f2 essere utilizzato per leggere i parametri dalla sezione di configurazione specificata. Questo viene fatto usando i metodi config.get() , config.getfloat() , config.getint() , ecc. Assicurati di leggere tutti i valori dalla configurazione durante la costruzione dell'oggetto stampante: se l'utente specifica un parametro di configurazione che non viene letto durante questa fase, si presumer\u00e0 che si tratti di un errore di battitura nella configurazione e verr\u00e0 generato un errore. Usa il metodo config.get_printer() per ottenere un riferimento alla classe principale \"printer\". Questa classe \"stampante\" memorizza i riferimenti a tutti gli \"oggetti stampante\" di cui \u00e8 stata creata un'istanza. Usa il metodo printer.lookup_object() per trovare riferimenti ad altri oggetti stampante. Quasi tutte le funzionalit\u00e0 (anche i moduli cinematici principali) sono incapsulate in uno di questi oggetti stampante. Si noti, tuttavia, che quando viene istanziato un nuovo modulo, non saranno stati istanziati tutti gli altri oggetti stampante. I moduli \"gcode\" e \"pins\" saranno sempre disponibili, ma per altri moduli \u00e8 una buona idea rinviare la ricerca. Registra i gestori di eventi usando il metodo printer.register_event_handler() se il codice deve essere chiamato durante gli \"events\" generati da altri oggetti stampante. Ogni nome di evento \u00e8 una stringa e, per convenzione, \u00e8 il nome del modulo sorgente principale che genera l'evento insieme a un nome breve per l'azione che si sta verificando (ad esempio, \"klippy:connect\"). I parametri passati a ciascun gestore di eventi sono specifici dell'evento dato (cos\u00ec come la gestione delle eccezioni e il contesto di esecuzione). Due eventi di avvio comuni sono: klippy:connect - Questo evento viene generato dopo che tutti gli oggetti stampante sono stati istanziati. Viene comunemente utilizzato per cercare altri oggetti stampante, verificare le impostazioni di configurazione ed eseguire un \"handshake\" iniziale con l'hardware della stampante. klippy:ready - Questo evento viene generato dopo che tutti i gestori di connessione sono stati completati correttamente. Indica che la stampante sta passando a uno stato pronto per gestire le normali operazioni. Non generare un errore in questo callback. Se c'\u00e8 un errore nella configurazione dell'utente, assicurati di sollevarlo durante le fasi load_config() o \"connect event\". Utilizzare raise config.error(\"my error\") o raise printer.config_error (\"my error\") per segnalare l'errore. Utilizzare il modulo \"pin\" per configurare un pin su un microcontrollore. Questo \u00e8 in genere fatto con qualcosa di simile a printer.lookup_object(\"pins\").setup_pin(\"pwm\", config.get(\"my_pin\")) . L'oggetto restituito pu\u00f2 quindi essere comandato in fase di esecuzione. Se l'oggetto stampante definisce un metodo get_status() , il modulo pu\u00f2 esportare informazioni sullo stato tramite macro e tramite Server API . Il metodo get_status() deve restituire un dizionario Python con chiavi che sono stringhe e valori che sono interi, float, stringhe, elenchi, dizionari, True, False o None. \u00c8 possibile utilizzare anche tuple (e tuple con nome) (appaiono come elenchi quando si accede tramite il server API). Gli elenchi e i dizionari esportati devono essere trattati come \"immutabili\" - se il loro contenuto cambia, \u00e8 necessario restituire un nuovo oggetto da get_status() , altrimenti il server API non rilever\u00e0 tali modifiche. Se il modulo necessita dell'accesso alla temporizzazione del sistema o a descrittori di file esterni, utilizzare printer.get_reactor() per ottenere l'accesso alla classe globale \"event reactor\". Questa classe reattore consente di programmare i timer, attendere l'input sui descrittori di file e di \"sopprimere\" il codice host. Non utilizzare variabili globali. Tutto lo stato dovrebbe essere memorizzato nell'oggetto stampante restituito dalla funzione load_config() . Questo \u00e8 importante, altrimenti il comando RESTART potrebbe non funzionare come previsto. Inoltre, per ragioni simili, se vengono aperti file (o socket) esterni, assicurati di registrare un gestore di eventi \"klippy:disconnect\" e chiuderli da quella richiamata. Evitare di accedere alle variabili dei membri interni (o di chiamare metodi che iniziano con un trattino basso) di altri oggetti stampante. L'osservanza di questa convenzione semplifica la gestione delle modifiche future. Si consiglia di assegnare un valore a tutte le variabili membro nel costruttore Python delle classi Python. (E quindi evita di utilizzare la capacit\u00e0 di Python di creare dinamicamente nuove variabili membro.) Se una variabile Python deve memorizzare un valore in virgola mobile, si consiglia di assegnare e manipolare sempre quella variabile con costanti in virgola mobile (e non utilizzare mai costanti intere). Ad esempio, preferisci self.speed = 1. su self.speed = 1 e preferisci self.speed = 2. * x su self.speed = 2 * x . L'uso coerente di valori in virgola mobile pu\u00f2 evitare difficolt\u00e0 di debug nelle conversioni di tipo Python. Se invii il modulo per l'inclusione nel codice Klipper principale, assicurati di inserire un avviso di copyright nella parte superiore del modulo. Vedere i moduli esistenti per il formato preferito. Aggiunta di una nuova cinematica \u00b6 Questa sezione fornisce alcuni suggerimenti sull'aggiunta del supporto a Klipper per ulteriori tipi di cinematica della stampante. Questo tipo di attivit\u00e0 richiede un'ottima comprensione delle formule matematiche per la cinematica di destinazione. Richiede anche capacit\u00e0 di sviluppo software, sebbene sia necessario solo aggiornare il software host. Passi utili: Inizia studiando la sezione \" flusso di codice di un movimento \" e il documento di cinematica . Esaminare le classi cinematiche esistenti nella directory klippy/kinematics/. Le classi cinematiche hanno il compito di convertire una mossa in coordinate cartesiane nel movimento su ogni stepper. Si dovrebbe essere in grado di copiare uno di questi file come punto di partenza. Implementa in C le funzioni di posizione cinematica dello stepper per ogni stepper se non sono gi\u00e0 disponibili (vedi kin_cart.c, kin_corexy.c e kin_delta.c in klippy/chelper/). La funzione dovrebbe chiamare move_get_coord() per convertire un dato tempo di spostamento (in secondi) in una coordinata cartesiana (in millimetri), e quindi calcolare la posizione dello stepper desiderata (in millimetri) da quella coordinata cartesiana. Implementa il metodo calc_position() nella nuova classe cinematica. Questo metodo calcola la posizione della testa di stampa in coordinate cartesiane dalla posizione di ogni stepper. Non \u00e8 necessario che sia efficiente poich\u00e9 in genere viene chiamato solo durante le operazioni di homing e probing. Other methods. Implement the check_move() , get_status() , get_steppers() , home() , clear_homing_state() , and set_position() methods. These functions are typically used to provide kinematic specific checks. However, at the start of development one can use boiler-plate code here. Implementare casi di prova. Crea un file g-code con una serie di movimenti che possono testare casi importanti per la cinematica data. Segui la documentazione di debug per convertire questo file di codice G in comandi del microcontrollore. Questo \u00e8 utile per esercitare corner case e per verificare la presenza di regressioni. Porting su un nuovo microcontrollore \u00b6 Questa sezione fornisce alcuni suggerimenti sul porting del codice del microcontrollore di Klipper su una nuova architettura. Questo tipo di attivit\u00e0 richiede una buona conoscenza dello sviluppo embedded e un accesso diretto al microcontrollore di destinazione. Passi utili: Inizia identificando eventuali librerie di terze parti che verranno utilizzate durante il trasferimento. Esempi comuni includono wrapper \"CMSIS\" e librerie \"HAL\" del produttore. Tutto il codice di terze parti deve essere compatibile con GNU GPLv3. Il codice di terze parti dovrebbe essere salvato nella directory lib/ di Klipper. Aggiorna il file lib/README con informazioni su dove e quando \u00e8 stata ottenuta la libreria. \u00c8 preferibile copiare il codice nel repository di Klipper senza modifiche, ma se sono necessarie modifiche, tali modifiche dovrebbero essere elencate esplicitamente nel file lib/README. Crea una nuova sottodirectory di architettura nella directory src/ e aggiungi il supporto iniziale di Kconfig e Makefile. Utilizzare le architetture esistenti come guida. src/simulator fornisce un esempio di base di un punto di partenza minimo. Il primo compito di programmazione \u00e8 portare il supporto di comunicazione alla scheda di destinazione. Questo \u00e8 il passo pi\u00f9 difficile in un nuovo porting. Una volta che la comunicazione di base funziona, i passaggi rimanenti tendono a essere molto pi\u00f9 semplici. \u00c8 tipico utilizzare un dispositivo seriale di tipo UART durante lo sviluppo iniziale poich\u00e9 questi tipi di dispositivi hardware sono generalmente pi\u00f9 facili da abilitare e controllare. Durante questa fase, fai un uso generoso del codice di supporto dalla directory src/generic/ (controlla come src/simulator/Makefile include il codice C generico nella build). \u00c8 inoltre necessario definire timer_read_time() (che restituisce l'orologio di sistema corrente) in questa fase, ma non \u00e8 necessario supportare completamente la gestione di timer irq. Acquisisci familiarit\u00e0 con lo strumento console.py (come descritto nel documento di debug ) e verifica la connettivit\u00e0 al microcontrollore con esso. Questo strumento traduce il protocollo di comunicazione del microcontrollore di basso livello in un formato leggibile dall'uomo. Aggiungi il supporto per l'invio del timer da interrupt hardware. Vedere Klipper commit 970831ee come esempio dei passaggi 1-5 eseguiti per l'architettura LPC176x. Visualizza il supporto di input e output GPIO di base. Vedi Klipper commit c78b9076 come esempio di questo. Riporta periferiche aggiuntive, ad esempio consulta il commit di Klipper 65613aed , c812a40a , e c381d03a . Crea un file di configurazione di Klipper di esempio nella directory config/. Testare il microcontrollore con il programma principale klippy.py. Prendi in considerazione l'aggiunta di build test case nella directory test/. Ulteriori suggerimenti per la programmazione: Evitare di utilizzare \"C bitfields\" per accedere ai registri IO; preferire operazioni di lettura e scrittura dirette di numeri interi a 32 bit, 16 bit o 8 bit. Le specifiche del linguaggio C non specificano chiaramente come il compilatore deve implementare campi di bit C (ad esempio, endianness e layout di bit), ed \u00e8 difficile determinare quali operazioni di I/O si verificheranno su un campo di bit C letto o scritto. Preferibilmente scrivere valori espliciti nei registri IO invece di usare operazioni di lettura-modifica-scrittura. Cio\u00e8, se si aggiorna un campo in un registro IO in cui gli altri campi hanno valori noti, \u00e8 preferibile scrivere in modo esplicito il contenuto completo del registro. Le scritture esplicite producono codice pi\u00f9 piccolo, pi\u00f9 veloce e pi\u00f9 facile da eseguire il debug. Sistemi di coordinate \u00b6 Internamente, Klipper tiene traccia principalmente della posizione della testa di stampa in coordinate cartesiane relative al sistema di coordinate specificato nel file di configurazione. Cio\u00e8, la maggior parte del codice Klipper non subir\u00e0 mai un cambiamento nei sistemi di coordinate. Se l'utente fa una richiesta per cambiare l'origine (ad esempio, un comando G92 ), allora quell'effetto si ottiene traducendo i comandi futuri nel sistema di coordinate primario. Tuttavia, in alcuni casi \u00e8 utile ottenere la posizione della testa di stampa in qualche altro sistema di coordinate e Klipper ha diversi strumenti per facilitarlo. Questo pu\u00f2 essere visto eseguendo il comando GET_POSITION. Per esempio: Send: GET_POSITION Recv: // mcu: stepper_a:-2060 stepper_b:-1169 stepper_c:-1613 Recv: // stepper: stepper_a:457.254159 stepper_b:466.085669 stepper_c:465.382132 Recv: // kinematic: X:8.339144 Y:-3.131558 Z:233.347121 Recv: // toolhead: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000 Recv: // gcode: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000 Recv: // gcode base: X:0.000000 Y:0.000000 Z:0.000000 E:0.000000 Recv: // gcode homing: X:0.000000 Y:0.000000 Z:0.000000 La posizione \"mcu\" ( stepper.get_mcu_position() nel codice) \u00e8 il numero totale di passaggi che il microcontrollore ha emesso in direzione positiva meno il numero di passaggi emessi in direzione negativa dall'ultimo microcontrollore Ripristina. Se il robot \u00e8 in movimento quando viene emessa la query, il valore riportato include le mosse memorizzate nel buffer del microcontrollore, ma non include le mosse nella coda di previsione. La posizione \"stepper\" ( stepper.get_commanded_position() ) \u00e8 la posizione del dato stepper come tracciato dal codice della cinematica. Questo corrisponde generalmente alla posizione (in mm) del carrello lungo il suo binario, rispetto a position_endstop specificato nel file di configurazione. (Alcune cinematiche tracciano le posizioni dello stepper in radianti anzich\u00e9 in millimetri.) Se il robot \u00e8 in movimento quando viene emessa la query, il valore riportato include i movimenti memorizzati nel buffer del microcontrollore, ma non include i movimenti sulla coda di previsione. Si possono usare le chiamate toolhead.flush_step_generation() o toolhead.wait_moves() per svuotare completamente il codice look-ahead e generazione di passaggi. La posizione \"cinematica\" ( kin.calc_position() ) \u00e8 la posizione cartesiana della testa di stampa come derivata dalle posizioni \"stepper\" ed \u00e8 relativa al sistema di coordinate specificato nel file di configurazione. Questo pu\u00f2 differire dalla posizione cartesiana richiesta a causa della granularit\u00e0 dei motori passo-passo. Se il robot \u00e8 in movimento quando vengono prese le posizioni \"stepper\", il valore riportato include i movimenti memorizzati nel buffer del microcontrollore, ma non include i movimenti sulla coda di previsione. Si possono usare le chiamate toolhead.flush_step_generation() o toolhead.wait_moves() per svuotare completamente il codice look-ahead e generazione di passaggi. La posizione della \"testa di stampa\" ( toolhead.get_position() ) \u00e8 l'ultima posizione richiesta della testa di stampa in coordinate cartesiane rispetto al sistema di coordinate specificato nel file di configurazione. Se il robot \u00e8 in movimento quando viene emessa la richiesta, il valore riportato include tutti i movimenti richiesti (anche quelli nei buffer in attesa di essere inviati ai driver del motore passo-passo). La posizione \"gcode\" \u00e8 l'ultima posizione richiesta da un comando G1 (o G0 ) in coordinate cartesiane relative al sistema di coordinate specificato nel file di configurazione. Questo pu\u00f2 differire dalla posizione \"toolhead\" se \u00e8 attiva una trasformazione del g-code (ad es. bed_mesh, bed_tilt, skew_correction). Questo pu\u00f2 differire dalle coordinate effettive specificate nell'ultimo comando G1 se l'origine del g-code \u00e8 stata modificata (ad esempio, G92 , SET_GCODE_OFFSET , M221 ). Il comando M114 ( gcode_move.get_status()['gcode_position'] ) riporter\u00e0 l'ultima posizione del g-code rispetto al sistema di coordinate del g-code corrente. La \"gcode base\" \u00e8 la posizione dell'origine del codice g in coordinate cartesiane rispetto al sistema di coordinate specificato nel file di configurazione. Comandi come G92 , SET_GCODE_OFFSET e M221 alterano questo valore. Il \"gcode homing\" \u00e8 la posizione da usare per l'origine del g-code (in coordinate cartesiane relative al sistema di coordinate specificato nel file di configurazione) dopo un comando home G28 . Il comando SET_GCODE_OFFSET pu\u00f2 alterare questo valore. Time \u00b6 Fondamentale per il funzionamento di Klipper \u00e8 la gestione di orologi, orari e timestamp. Klipper esegue azioni sulla stampante programmando eventi che si verificheranno nel prossimo futuro. Ad esempio, per accendere una ventola, il codice potrebbe programmare una modifica a un pin GPIO in 100 ms. \u00c8 raro che il codice tenti di eseguire un'azione istantanea. Pertanto, la gestione del tempo all'interno di Klipper \u00e8 fondamentale per il corretto funzionamento. Esistono tre tipi di tempi tracciati internamente nel software host di Klipper: Ora di sistema. L'ora del sistema utilizza l'orologio del sistema: \u00e8 un numero in virgola mobile memorizzato come secondi ed \u00e8 (generalmente) relativo all'ultimo avvio del computer host. I tempi di sistema hanno un uso limitato nel software: vengono utilizzati principalmente durante l'interazione con il sistema operativo. All'interno del codice host, gli orari di sistema sono spesso archiviati in variabili denominate eventtime o curtime . Tempo di stampa. Il tempo di stampa \u00e8 sincronizzato con l'orologio principale del microcontrollore (il microcontrollore definito nella sezione di configurazione \"[mcu]\"). \u00c8 un numero in virgola mobile memorizzato come secondi ed \u00e8 relativo all'ultimo riavvio dell'mcu principale. \u00c8 possibile convertire da un \"tempo di stampa\" all'orologio hardware del microcontrollore principale moltiplicando il tempo di stampa per la frequenza di frequenza configurata staticamente dell'mcu. Il codice host di alto livello utilizza i tempi di stampa per calcolare quasi tutte le azioni fisiche (ad es. movimento della testa, modifiche del riscaldatore, ecc.). All'interno del codice host, i tempi di stampa sono generalmente memorizzati in variabili denominate print_time o move_time . Orologio MCU. Questo \u00e8 il contatore dell'orologio hardware su ogni microcontrollore. Viene memorizzato come numero intero e la sua velocit\u00e0 di aggiornamento \u00e8 relativa alla frequenza del microcontrollore specificato. Il software host traduce i suoi tempi interni in orologi prima della trasmissione all'mcu. Il codice mcu tiene traccia del tempo solo in tick dell'orologio. All'interno del codice host, i valori di clock vengono tracciati come interi a 64 bit, mentre il codice mcu utilizza interi a 32 bit. All'interno del codice host, gli orologi sono generalmente memorizzati in variabili con nomi contenenti clock o tick . La conversione tra i diversi formati dell'ora \u00e8 implementata principalmente nel codice klippy/clocksync.py . Alcune cose da tenere presenti durante la revisione del codice: Orologi a 32 bit e 64 bit: per ridurre la larghezza di banda e migliorare l'efficienza del microcontrollore, gli orologi sul microcontrollore vengono tracciati come numeri interi a 32 bit. Quando si confrontano due orologi nel codice mcu, la funzione timer_is_before() deve essere sempre utilizzata per garantire che i rollover interi siano gestiti correttamente. Il software host converte gli orologi a 32 bit in orologi a 64 bit aggiungendo i bit di ordine superiore dall'ultimo timestamp mcu che ha ricevuto - nessun messaggio dall'mcu \u00e8 mai pi\u00f9 di 2^31 tick di clock in futuro o nel passato, quindi questa conversione non \u00e8 mai ambigua . L'host converte da clock a 64 bit a clock a 32 bit semplicemente troncando i bit di ordine superiore. Per garantire che non vi siano ambiguit\u00e0 in questa conversione, il codice klippy/chelper/serialqueue.c memorizza i messaggi nel buffer finch\u00e9 non si trovano entro 2^31 tick di clock dall'ora target. Microcontrollori multipli: il software host supporta l'utilizzo di pi\u00f9 microcontrollori su una singola stampante. In questo caso, il \"clock MCU\" di ogni microcontrollore viene tracciato separatamente. Il codice clocksync.py gestisce la deriva dell'orologio tra i microcontrollori modificando il modo in cui converte da \"tempo di stampa\" a \"orologio MCU\". Sul mcus secondario, la frequenza mcu utilizzata in questa conversione viene regolarmente aggiornata per tenere conto della deriva misurata.","title":"Panoramica del codice"},{"location":"Code_Overview.html#panoramica-del-codice","text":"Questo documento descrive il formato generale del codice e il flusso principale del codice di Klipper.","title":"Panoramica del codice"},{"location":"Code_Overview.html#directory-layout","text":"La directory src/ contiene il sorgente C per il codice del microcontrollore. src/atsam/ , src/atsamd/ , src/avr/ , src/linux/ , src/lpc176x/ , src/ Le directory pru/ e src/stm32/ contengono il codice del microcontrollore specifico dell'architettura. src/simulator/ contiene stub di codice che consentono la compilazione di test del microcontrollore su altre architetture. La directory src/generic/ contiene codice di supporto che pu\u00f2 essere utile in diverse architetture. La build fa in modo che le include di \"board/somefile.h\" guardino prima nella directory dell'architettura corrente (ad esempio, src/avr/somefile.h) e poi nella directory generica (ad esempio, src/generic/somefile.h). La directory klippy/ contiene il software host. La maggior parte del software host \u00e8 scritto in Python, tuttavia la directory klippy/chelper/ contiene alcuni helper del codice C. La directory klippy/kinematics/ contiene il codice della cinematica del robot. La directory klippy/extras/ contiene i \"moduli\" estensibili del codice host. La directory lib/ contiene il codice della libreria di terze parti esterne necessarie per creare alcune destinazioni. La directory config/ contiene file di configurazione della stampante di esempio. La directory scripts/ contiene script di build-time utili per compilare il codice del microcontrollore. La directory test/ contiene test case automatizzati. Durante la compilazione, la build potrebbe creare una directory out/ . Questa contiene oggetti temporanei di compilazione. L'oggetto microcontrollore finale che viene creato \u00e8 out/klipper.elf.hex su AVR e out/klipper.bin su ARM.","title":"Directory Layout"},{"location":"Code_Overview.html#flusso-del-codice-del-microcontrollore","text":"L'esecuzione del codice del microcontrollore inizia nel codice specifico dell'architettura (ad esempio, src/avr/main.c ) che alla fine chiama sched_main() che si trova in src/sched.c . Il codice sched_main() inizia eseguendo tutte le funzioni che sono state contrassegnate con la macro DECL_INIT(). Quindi continua a eseguire ripetutamente tutte le funzioni contrassegnate con la macro DECL_TASK(). Una delle principali funzioni dell'attivit\u00e0 \u00e8 command_dispatch() che si trova in src/command.c . Questa funzione viene richiamata dal codice input/output specifico della scheda (es. src/avr/serial.c , src/generic/serial_irq.c ) ed esegue le funzioni di comando associate ai comandi trovati nel flusso di input. Le funzioni di comando vengono dichiarate utilizzando la macro DECL_COMMAND() (consultare il documento protocol per ulteriori informazioni). Le funzioni task, init e comando vengono sempre eseguite con gli interrupt abilitati (tuttavia, possono disabilitare temporaneamente gli interrupt se necessario). Queste funzioni dovrebbero evitare lunghe pause, ritardi o eseguire lavori che durano un tempo significativo. (Lunghi ritardi in queste funzioni di \"attivit\u00e0\" provocano un jitter di pianificazione per altre \"attivit\u00e0\" - ritardi superiori a 100us possono diventare evidenti, ritardi superiori a 500us possono causare ritrasmissioni dei comandi, ritardi superiori a 100 ms possono causare riavvii del watchdog.) Queste funzioni pianificano il lavoro a orari specifici programmando i timer. Le funzioni timer vengono pianificate chiamando sched_add_timer() (che si trova in src/sched.c ). Il codice di pianificazione far\u00e0 in modo che la funzione data venga chiamata all'ora richiesta. Gli interrupt timer sono inizialmente gestiti in un gestore di interrupt specifico dell'architettura (ad esempio, src/avr/timer.c ) che chiama sched_timer_dispatch() situato in src/sched.c . L'interruzione del timer porta all'esecuzione delle funzioni del timer di pianificazione. Le funzioni timer vengono eseguite sempre con gli interrupt disabilitati. Le funzioni del timer dovrebbero sempre completarsi entro pochi microsecondi. Al completamento dell'evento timer, la funzione pu\u00f2 scegliere di riprogrammare se stessa. Nel caso in cui venga rilevato un errore, il codice pu\u00f2 invocare shutdown() (una macro che chiama sched_shutdown() situata in src/sched.c ). Il richiamo di shutdown() provoca l'esecuzione di tutte le funzioni contrassegnate con la macro DECL_SHUTDOWN(). Le funzioni di spegnimento vengono eseguite sempre con gli interrupt disabilitati. Gran parte delle funzionalit\u00e0 del microcontrollore implica il lavoro con pin di input/output per uso generico (GPIO). Per astrarre il codice specifico dell'architettura di basso livello dal codice dell'attivit\u00e0 di alto livello, tutti gli eventi GPIO sono implementati in wrapper specifici dell'architettura (ad esempio, src/avr/gpio.c ). Il codice \u00e8 compilato con l'ottimizzazione \"-flto -fwhole-program\" di gcc che fa un ottimo lavoro di inlining delle funzioni tra le unit\u00e0 di compilazione, quindi la maggior parte di queste minuscole funzioni gpio sono integrate nei loro chiamanti e non ci sono costi di runtime per l'utilizzo loro.","title":"Flusso del codice del microcontrollore"},{"location":"Code_Overview.html#panoramica-del-codice-klippy","text":"Il codice host (Klippy) deve essere eseguito su un computer a basso costo (come un Raspberry Pi) abbinato al microcontrollore. Il codice \u00e8 scritto principalmente in Python, tuttavia utilizza CFFI per implementare alcune funzionalit\u00e0 nel codice C. L'esecuzione iniziale comincia in klippy/klippy.py . Questo legge gli argomenti della riga di comando, apre il file di configurazione della stampante, crea un'istanza degli oggetti principali della stampante e avvia la connessione seriale. L'esecuzione principale dei comandi G-code \u00e8 nel metodo process_commands() in klippy/gcode.py . Questo codice traduce i comandi del codice G in chiamate a oggetti stampante, che spesso traducono le azioni in comandi da eseguire sul microcontrollore (come dichiarato tramite la macro DECL_COMMAND nel codice del microcontrollore). Ci sono quattro thread nel codice host di Klippy. Il thread principale gestisce i comandi gcode in arrivo. Un secondo thread (che risiede interamente nel codice C klippy/chelper/serialqueue.c ) gestisce l'IO di basso livello con la porta seriale. Il terzo thread viene utilizzato per elaborare i messaggi di risposta dal microcontrollore nel codice Python (vedi klippy/serialhdl.py ). Il quarto thread scrive i messaggi di debug nel log (vedi klippy/queuelogger.py ) in modo che gli altri thread non blocchino mai le scritture del log.","title":"Panoramica del codice Klippy"},{"location":"Code_Overview.html#flusso-di-codice-di-un-comando-di-spostamento","text":"Un tipico movimento della stampante inizia quando viene inviato un comando \"G1\" all'host Klippy e si completa quando vengono prodotti i corrispondenti impulsi di passo sul microcontrollore. Questa sezione delinea il flusso di codice di un tipico comando di spostamento. Il documento cinematica fornisce ulteriori informazioni sulla meccanica dei movimenti. L'elaborazione di un comando di spostamento inizia in gcode.py. L'obiettivo di gcode.py \u00e8 tradurre il G-code in chiamate interne. Un comando G1 invocher\u00e0 cmd_G1() in klippy/extras/gcode_move.py. Il codice gcode_move.py gestisce le modifiche all'origine (ad esempio, G92), le modifiche alle posizioni relative rispetto a quelle assolute (ad esempio, G90) e le modifiche alle unit\u00e0 (ad esempio, F6000=100mm/s). Il percorso del codice per una mossa \u00e8: _process_data() -> _process_commands() -> cmd_G1() . Infine viene invocata la classe ToolHead per eseguire la richiesta effettiva: cmd_G1() -> ToolHead.move() The ToolHead class (in toolhead.py) handles \"look-ahead\" and tracks the timing of printing actions. The main codepath for a move is: ToolHead.move() -> LookAheadQueue.add_move() -> LookAheadQueue.flush() -> Move.set_junction() -> ToolHead._process_moves() . ToolHead.move() crea un oggetto Move() con i parametri del movimento (in spazio cartesiano e in unit\u00e0 di secondi e millimetri). Alla classe cinematica viene data l'opportunit\u00e0 di controllare ogni movimento ( ToolHead.move() -> kin.check_move() ). Le classi cinematiche si trovano nella directory klippy/cinematica/. Il codice check_move() pu\u00f2 generare un errore se il movimento non \u00e8 valida. Se check_move() viene completato correttamente, la cinematica sottostante deve essere in grado di gestire lo spostamento. LookAheadQueue.add_move() places the move object on the \"look-ahead\" queue. LookAheadQueue.flush() determines the start and end velocities of each move. Move.set_junction() implementa il \"generatore di trapezi\" per il movimento. Il \"generatore trapezoidale\" suddivide ogni movimento in tre parti: una fase di accelerazione costante, seguita da una fase di velocit\u00e0 costante, seguita da una fase di decelerazione costante. Ogni mossa contiene queste tre fasi in questo ordine, ma alcune fasi possono avere durata zero. Quando viene chiamato ToolHead._process_moves(), tutto ci\u00f2 che riguarda lo spostamento \u00e8 noto: la sua posizione iniziale, la sua posizione finale, la sua accelerazione, la sua velocit\u00e0 di inizio/crociera/finale e la distanza percorsa durante l'accelerazione/crociera/decelerazione. Tutte le informazioni sono memorizzate nella classe Move() e sono nello spazio cartesiano in unit\u00e0 di millimetri e secondi. Klipper uses an iterative solver to generate the step times for each stepper. For efficiency reasons, the stepper pulse times are generated in C code. The moves are first placed on a \"trapezoid motion queue\": ToolHead._process_moves() -> trapq_append() (in klippy/chelper/trapq.c). The step times are then generated: ToolHead._process_moves() -> ToolHead._advance_move_time() -> ToolHead._advance_flush_time() -> MCU_Stepper.generate_steps() -> itersolve_generate_steps() -> itersolve_gen_steps_range() (in klippy/chelper/itersolve.c). The goal of the iterative solver is to find step times given a function that calculates a stepper position from a time. This is done by repeatedly \"guessing\" various times until the stepper position formula returns the desired position of the next step on the stepper. The feedback produced from each guess is used to improve future guesses so that the process rapidly converges to the desired time. The kinematic stepper position formulas are located in the klippy/chelper/ directory (eg, kin_cart.c, kin_corexy.c, kin_delta.c, kin_extruder.c). Si noti che l'estrusore \u00e8 gestito nella propria classe cinematica: ToolHead._process_moves() -> PrinterExtruder.move() . Poich\u00e9 la classe Move() specifica l'esatto tempo di movimento e poich\u00e9 gli impulsi di passo vengono inviati al microcontrollore con una tempistica specifica, i movimenti passo-passo prodotti dalla classe estrusore saranno sincronizzati con il movimento della testa anche se il codice viene mantenuto separato. Dopo che il risolutore iterativo ha calcolato i tempi di passaggio, questi vengono aggiunti a un array: itersolve_gen_steps_range() -> stepcompress_append() (in klippy/chelper/stepcompress.c). L'array (struct stepcompress.queue) memorizza i corrispondenti tempi del contatore dell'orologio del microcontrollore per ogni passaggio. Qui il valore del \"contatore orologio del microcontrollore\" corrisponde direttamente al contatore hardware del microcontrollore - \u00e8 relativo a quando il microcontrollore \u00e8 stato acceso l'ultima volta. Il prossimo passo importante \u00e8 comprimere i passaggi: stepcompress_flush() -> compress_bisect_add() (in klippy/chelper/stepcompress.c). Questo codice genera e codifica una serie di comandi \"queue_step\" del microcontrollore che corrispondono all'elenco dei tempi di stepper compilati nella fase precedente. Questi comandi \"queue_step\" vengono quindi accodati, assegnati a priorit\u00e0 e inviati al microcontrollore (tramite stepcompress.c:steppersync e serialqueue.c:serialqueue). L'elaborazione dei comandi queue_step sul microcontrollore inizia in src/command.c che analizza il comando e chiama command_queue_step() . Il codice command_queue_step() (in src/stepper.c) aggiunge semplicemente i parametri di ogni comando queue_step a una coda per stepper. In condizioni normali, il comando queue_step viene analizzato e messo in coda almeno 100 ms prima dell'ora del suo primo passaggio. Infine, la generazione degli eventi stepper viene eseguita in stepper_event() . Viene chiamato dall'interruzione del timer hardware all'ora pianificata del primo passaggio. Il codice stepper_event() genera un impulso di passaggio e quindi si riprogramma per essere eseguito al momento dell'impulso di passaggio successivo per i parametri queue_step specificati. I parametri per ogni comando queue_step sono \"interval\", \"count\" e \"add\". Ad alto livello, stepper_event() esegue quanto segue, 'count' volte: do_step(); next_wake_time = last_wake_time + intervallo; intervallo += aggiungi; Quanto sopra pu\u00f2 sembrare un sacco di complessit\u00e0 per eseguire un movimento. Tuttavia, le uniche parti veramente interessanti sono nelle classi ToolHead e cinematica. \u00c8 questa parte del codice che specifica i movimenti e le loro tempistiche. Le restanti parti dell'elaborazione sono per lo pi\u00f9 solo comunicazioni e collegamenti.","title":"Flusso di codice di un comando di spostamento"},{"location":"Code_Overview.html#aggiunta-di-un-modulo-host","text":"Il codice host Klippy ha una capacit\u00e0 di caricamento dinamico dei moduli. Se nel file di configurazione della stampante viene trovata una sezione di configurazione denominata \"[my_module]\", il software tenter\u00e0 automaticamente di caricare il modulo python klippy/extras/my_module.py . Questo sistema di moduli \u00e8 il metodo preferito per aggiungere nuove funzionalit\u00e0 a Klipper. Il modo pi\u00f9 semplice per aggiungere un nuovo modulo \u00e8 utilizzare un modulo esistente come riferimento - vedere klippy/extras/servo.py come esempio. Possono essere utili anche: L'esecuzione del modulo inizia nella funzione load_config() a livello di modulo (per le sezioni di configurazione del modulo [my_module]) o in load_config_prefix() (per le sezioni di configurazione del modulo [my_module my_name]). A questa funzione viene passato un oggetto \"config\" e deve restituire un nuovo \"oggetto stampante\" associato alla sezione di configurazione specificata. Durante il processo di creazione di un'istanza di un nuovo oggetto stampante, l'oggetto di configurazione pu\u00f2 essere utilizzato per leggere i parametri dalla sezione di configurazione specificata. Questo viene fatto usando i metodi config.get() , config.getfloat() , config.getint() , ecc. Assicurati di leggere tutti i valori dalla configurazione durante la costruzione dell'oggetto stampante: se l'utente specifica un parametro di configurazione che non viene letto durante questa fase, si presumer\u00e0 che si tratti di un errore di battitura nella configurazione e verr\u00e0 generato un errore. Usa il metodo config.get_printer() per ottenere un riferimento alla classe principale \"printer\". Questa classe \"stampante\" memorizza i riferimenti a tutti gli \"oggetti stampante\" di cui \u00e8 stata creata un'istanza. Usa il metodo printer.lookup_object() per trovare riferimenti ad altri oggetti stampante. Quasi tutte le funzionalit\u00e0 (anche i moduli cinematici principali) sono incapsulate in uno di questi oggetti stampante. Si noti, tuttavia, che quando viene istanziato un nuovo modulo, non saranno stati istanziati tutti gli altri oggetti stampante. I moduli \"gcode\" e \"pins\" saranno sempre disponibili, ma per altri moduli \u00e8 una buona idea rinviare la ricerca. Registra i gestori di eventi usando il metodo printer.register_event_handler() se il codice deve essere chiamato durante gli \"events\" generati da altri oggetti stampante. Ogni nome di evento \u00e8 una stringa e, per convenzione, \u00e8 il nome del modulo sorgente principale che genera l'evento insieme a un nome breve per l'azione che si sta verificando (ad esempio, \"klippy:connect\"). I parametri passati a ciascun gestore di eventi sono specifici dell'evento dato (cos\u00ec come la gestione delle eccezioni e il contesto di esecuzione). Due eventi di avvio comuni sono: klippy:connect - Questo evento viene generato dopo che tutti gli oggetti stampante sono stati istanziati. Viene comunemente utilizzato per cercare altri oggetti stampante, verificare le impostazioni di configurazione ed eseguire un \"handshake\" iniziale con l'hardware della stampante. klippy:ready - Questo evento viene generato dopo che tutti i gestori di connessione sono stati completati correttamente. Indica che la stampante sta passando a uno stato pronto per gestire le normali operazioni. Non generare un errore in questo callback. Se c'\u00e8 un errore nella configurazione dell'utente, assicurati di sollevarlo durante le fasi load_config() o \"connect event\". Utilizzare raise config.error(\"my error\") o raise printer.config_error (\"my error\") per segnalare l'errore. Utilizzare il modulo \"pin\" per configurare un pin su un microcontrollore. Questo \u00e8 in genere fatto con qualcosa di simile a printer.lookup_object(\"pins\").setup_pin(\"pwm\", config.get(\"my_pin\")) . L'oggetto restituito pu\u00f2 quindi essere comandato in fase di esecuzione. Se l'oggetto stampante definisce un metodo get_status() , il modulo pu\u00f2 esportare informazioni sullo stato tramite macro e tramite Server API . Il metodo get_status() deve restituire un dizionario Python con chiavi che sono stringhe e valori che sono interi, float, stringhe, elenchi, dizionari, True, False o None. \u00c8 possibile utilizzare anche tuple (e tuple con nome) (appaiono come elenchi quando si accede tramite il server API). Gli elenchi e i dizionari esportati devono essere trattati come \"immutabili\" - se il loro contenuto cambia, \u00e8 necessario restituire un nuovo oggetto da get_status() , altrimenti il server API non rilever\u00e0 tali modifiche. Se il modulo necessita dell'accesso alla temporizzazione del sistema o a descrittori di file esterni, utilizzare printer.get_reactor() per ottenere l'accesso alla classe globale \"event reactor\". Questa classe reattore consente di programmare i timer, attendere l'input sui descrittori di file e di \"sopprimere\" il codice host. Non utilizzare variabili globali. Tutto lo stato dovrebbe essere memorizzato nell'oggetto stampante restituito dalla funzione load_config() . Questo \u00e8 importante, altrimenti il comando RESTART potrebbe non funzionare come previsto. Inoltre, per ragioni simili, se vengono aperti file (o socket) esterni, assicurati di registrare un gestore di eventi \"klippy:disconnect\" e chiuderli da quella richiamata. Evitare di accedere alle variabili dei membri interni (o di chiamare metodi che iniziano con un trattino basso) di altri oggetti stampante. L'osservanza di questa convenzione semplifica la gestione delle modifiche future. Si consiglia di assegnare un valore a tutte le variabili membro nel costruttore Python delle classi Python. (E quindi evita di utilizzare la capacit\u00e0 di Python di creare dinamicamente nuove variabili membro.) Se una variabile Python deve memorizzare un valore in virgola mobile, si consiglia di assegnare e manipolare sempre quella variabile con costanti in virgola mobile (e non utilizzare mai costanti intere). Ad esempio, preferisci self.speed = 1. su self.speed = 1 e preferisci self.speed = 2. * x su self.speed = 2 * x . L'uso coerente di valori in virgola mobile pu\u00f2 evitare difficolt\u00e0 di debug nelle conversioni di tipo Python. Se invii il modulo per l'inclusione nel codice Klipper principale, assicurati di inserire un avviso di copyright nella parte superiore del modulo. Vedere i moduli esistenti per il formato preferito.","title":"Aggiunta di un modulo host"},{"location":"Code_Overview.html#aggiunta-di-una-nuova-cinematica","text":"Questa sezione fornisce alcuni suggerimenti sull'aggiunta del supporto a Klipper per ulteriori tipi di cinematica della stampante. Questo tipo di attivit\u00e0 richiede un'ottima comprensione delle formule matematiche per la cinematica di destinazione. Richiede anche capacit\u00e0 di sviluppo software, sebbene sia necessario solo aggiornare il software host. Passi utili: Inizia studiando la sezione \" flusso di codice di un movimento \" e il documento di cinematica . Esaminare le classi cinematiche esistenti nella directory klippy/kinematics/. Le classi cinematiche hanno il compito di convertire una mossa in coordinate cartesiane nel movimento su ogni stepper. Si dovrebbe essere in grado di copiare uno di questi file come punto di partenza. Implementa in C le funzioni di posizione cinematica dello stepper per ogni stepper se non sono gi\u00e0 disponibili (vedi kin_cart.c, kin_corexy.c e kin_delta.c in klippy/chelper/). La funzione dovrebbe chiamare move_get_coord() per convertire un dato tempo di spostamento (in secondi) in una coordinata cartesiana (in millimetri), e quindi calcolare la posizione dello stepper desiderata (in millimetri) da quella coordinata cartesiana. Implementa il metodo calc_position() nella nuova classe cinematica. Questo metodo calcola la posizione della testa di stampa in coordinate cartesiane dalla posizione di ogni stepper. Non \u00e8 necessario che sia efficiente poich\u00e9 in genere viene chiamato solo durante le operazioni di homing e probing. Other methods. Implement the check_move() , get_status() , get_steppers() , home() , clear_homing_state() , and set_position() methods. These functions are typically used to provide kinematic specific checks. However, at the start of development one can use boiler-plate code here. Implementare casi di prova. Crea un file g-code con una serie di movimenti che possono testare casi importanti per la cinematica data. Segui la documentazione di debug per convertire questo file di codice G in comandi del microcontrollore. Questo \u00e8 utile per esercitare corner case e per verificare la presenza di regressioni.","title":"Aggiunta di una nuova cinematica"},{"location":"Code_Overview.html#porting-su-un-nuovo-microcontrollore","text":"Questa sezione fornisce alcuni suggerimenti sul porting del codice del microcontrollore di Klipper su una nuova architettura. Questo tipo di attivit\u00e0 richiede una buona conoscenza dello sviluppo embedded e un accesso diretto al microcontrollore di destinazione. Passi utili: Inizia identificando eventuali librerie di terze parti che verranno utilizzate durante il trasferimento. Esempi comuni includono wrapper \"CMSIS\" e librerie \"HAL\" del produttore. Tutto il codice di terze parti deve essere compatibile con GNU GPLv3. Il codice di terze parti dovrebbe essere salvato nella directory lib/ di Klipper. Aggiorna il file lib/README con informazioni su dove e quando \u00e8 stata ottenuta la libreria. \u00c8 preferibile copiare il codice nel repository di Klipper senza modifiche, ma se sono necessarie modifiche, tali modifiche dovrebbero essere elencate esplicitamente nel file lib/README. Crea una nuova sottodirectory di architettura nella directory src/ e aggiungi il supporto iniziale di Kconfig e Makefile. Utilizzare le architetture esistenti come guida. src/simulator fornisce un esempio di base di un punto di partenza minimo. Il primo compito di programmazione \u00e8 portare il supporto di comunicazione alla scheda di destinazione. Questo \u00e8 il passo pi\u00f9 difficile in un nuovo porting. Una volta che la comunicazione di base funziona, i passaggi rimanenti tendono a essere molto pi\u00f9 semplici. \u00c8 tipico utilizzare un dispositivo seriale di tipo UART durante lo sviluppo iniziale poich\u00e9 questi tipi di dispositivi hardware sono generalmente pi\u00f9 facili da abilitare e controllare. Durante questa fase, fai un uso generoso del codice di supporto dalla directory src/generic/ (controlla come src/simulator/Makefile include il codice C generico nella build). \u00c8 inoltre necessario definire timer_read_time() (che restituisce l'orologio di sistema corrente) in questa fase, ma non \u00e8 necessario supportare completamente la gestione di timer irq. Acquisisci familiarit\u00e0 con lo strumento console.py (come descritto nel documento di debug ) e verifica la connettivit\u00e0 al microcontrollore con esso. Questo strumento traduce il protocollo di comunicazione del microcontrollore di basso livello in un formato leggibile dall'uomo. Aggiungi il supporto per l'invio del timer da interrupt hardware. Vedere Klipper commit 970831ee come esempio dei passaggi 1-5 eseguiti per l'architettura LPC176x. Visualizza il supporto di input e output GPIO di base. Vedi Klipper commit c78b9076 come esempio di questo. Riporta periferiche aggiuntive, ad esempio consulta il commit di Klipper 65613aed , c812a40a , e c381d03a . Crea un file di configurazione di Klipper di esempio nella directory config/. Testare il microcontrollore con il programma principale klippy.py. Prendi in considerazione l'aggiunta di build test case nella directory test/. Ulteriori suggerimenti per la programmazione: Evitare di utilizzare \"C bitfields\" per accedere ai registri IO; preferire operazioni di lettura e scrittura dirette di numeri interi a 32 bit, 16 bit o 8 bit. Le specifiche del linguaggio C non specificano chiaramente come il compilatore deve implementare campi di bit C (ad esempio, endianness e layout di bit), ed \u00e8 difficile determinare quali operazioni di I/O si verificheranno su un campo di bit C letto o scritto. Preferibilmente scrivere valori espliciti nei registri IO invece di usare operazioni di lettura-modifica-scrittura. Cio\u00e8, se si aggiorna un campo in un registro IO in cui gli altri campi hanno valori noti, \u00e8 preferibile scrivere in modo esplicito il contenuto completo del registro. Le scritture esplicite producono codice pi\u00f9 piccolo, pi\u00f9 veloce e pi\u00f9 facile da eseguire il debug.","title":"Porting su un nuovo microcontrollore"},{"location":"Code_Overview.html#sistemi-di-coordinate","text":"Internamente, Klipper tiene traccia principalmente della posizione della testa di stampa in coordinate cartesiane relative al sistema di coordinate specificato nel file di configurazione. Cio\u00e8, la maggior parte del codice Klipper non subir\u00e0 mai un cambiamento nei sistemi di coordinate. Se l'utente fa una richiesta per cambiare l'origine (ad esempio, un comando G92 ), allora quell'effetto si ottiene traducendo i comandi futuri nel sistema di coordinate primario. Tuttavia, in alcuni casi \u00e8 utile ottenere la posizione della testa di stampa in qualche altro sistema di coordinate e Klipper ha diversi strumenti per facilitarlo. Questo pu\u00f2 essere visto eseguendo il comando GET_POSITION. Per esempio: Send: GET_POSITION Recv: // mcu: stepper_a:-2060 stepper_b:-1169 stepper_c:-1613 Recv: // stepper: stepper_a:457.254159 stepper_b:466.085669 stepper_c:465.382132 Recv: // kinematic: X:8.339144 Y:-3.131558 Z:233.347121 Recv: // toolhead: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000 Recv: // gcode: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000 Recv: // gcode base: X:0.000000 Y:0.000000 Z:0.000000 E:0.000000 Recv: // gcode homing: X:0.000000 Y:0.000000 Z:0.000000 La posizione \"mcu\" ( stepper.get_mcu_position() nel codice) \u00e8 il numero totale di passaggi che il microcontrollore ha emesso in direzione positiva meno il numero di passaggi emessi in direzione negativa dall'ultimo microcontrollore Ripristina. Se il robot \u00e8 in movimento quando viene emessa la query, il valore riportato include le mosse memorizzate nel buffer del microcontrollore, ma non include le mosse nella coda di previsione. La posizione \"stepper\" ( stepper.get_commanded_position() ) \u00e8 la posizione del dato stepper come tracciato dal codice della cinematica. Questo corrisponde generalmente alla posizione (in mm) del carrello lungo il suo binario, rispetto a position_endstop specificato nel file di configurazione. (Alcune cinematiche tracciano le posizioni dello stepper in radianti anzich\u00e9 in millimetri.) Se il robot \u00e8 in movimento quando viene emessa la query, il valore riportato include i movimenti memorizzati nel buffer del microcontrollore, ma non include i movimenti sulla coda di previsione. Si possono usare le chiamate toolhead.flush_step_generation() o toolhead.wait_moves() per svuotare completamente il codice look-ahead e generazione di passaggi. La posizione \"cinematica\" ( kin.calc_position() ) \u00e8 la posizione cartesiana della testa di stampa come derivata dalle posizioni \"stepper\" ed \u00e8 relativa al sistema di coordinate specificato nel file di configurazione. Questo pu\u00f2 differire dalla posizione cartesiana richiesta a causa della granularit\u00e0 dei motori passo-passo. Se il robot \u00e8 in movimento quando vengono prese le posizioni \"stepper\", il valore riportato include i movimenti memorizzati nel buffer del microcontrollore, ma non include i movimenti sulla coda di previsione. Si possono usare le chiamate toolhead.flush_step_generation() o toolhead.wait_moves() per svuotare completamente il codice look-ahead e generazione di passaggi. La posizione della \"testa di stampa\" ( toolhead.get_position() ) \u00e8 l'ultima posizione richiesta della testa di stampa in coordinate cartesiane rispetto al sistema di coordinate specificato nel file di configurazione. Se il robot \u00e8 in movimento quando viene emessa la richiesta, il valore riportato include tutti i movimenti richiesti (anche quelli nei buffer in attesa di essere inviati ai driver del motore passo-passo). La posizione \"gcode\" \u00e8 l'ultima posizione richiesta da un comando G1 (o G0 ) in coordinate cartesiane relative al sistema di coordinate specificato nel file di configurazione. Questo pu\u00f2 differire dalla posizione \"toolhead\" se \u00e8 attiva una trasformazione del g-code (ad es. bed_mesh, bed_tilt, skew_correction). Questo pu\u00f2 differire dalle coordinate effettive specificate nell'ultimo comando G1 se l'origine del g-code \u00e8 stata modificata (ad esempio, G92 , SET_GCODE_OFFSET , M221 ). Il comando M114 ( gcode_move.get_status()['gcode_position'] ) riporter\u00e0 l'ultima posizione del g-code rispetto al sistema di coordinate del g-code corrente. La \"gcode base\" \u00e8 la posizione dell'origine del codice g in coordinate cartesiane rispetto al sistema di coordinate specificato nel file di configurazione. Comandi come G92 , SET_GCODE_OFFSET e M221 alterano questo valore. Il \"gcode homing\" \u00e8 la posizione da usare per l'origine del g-code (in coordinate cartesiane relative al sistema di coordinate specificato nel file di configurazione) dopo un comando home G28 . Il comando SET_GCODE_OFFSET pu\u00f2 alterare questo valore.","title":"Sistemi di coordinate"},{"location":"Code_Overview.html#time","text":"Fondamentale per il funzionamento di Klipper \u00e8 la gestione di orologi, orari e timestamp. Klipper esegue azioni sulla stampante programmando eventi che si verificheranno nel prossimo futuro. Ad esempio, per accendere una ventola, il codice potrebbe programmare una modifica a un pin GPIO in 100 ms. \u00c8 raro che il codice tenti di eseguire un'azione istantanea. Pertanto, la gestione del tempo all'interno di Klipper \u00e8 fondamentale per il corretto funzionamento. Esistono tre tipi di tempi tracciati internamente nel software host di Klipper: Ora di sistema. L'ora del sistema utilizza l'orologio del sistema: \u00e8 un numero in virgola mobile memorizzato come secondi ed \u00e8 (generalmente) relativo all'ultimo avvio del computer host. I tempi di sistema hanno un uso limitato nel software: vengono utilizzati principalmente durante l'interazione con il sistema operativo. All'interno del codice host, gli orari di sistema sono spesso archiviati in variabili denominate eventtime o curtime . Tempo di stampa. Il tempo di stampa \u00e8 sincronizzato con l'orologio principale del microcontrollore (il microcontrollore definito nella sezione di configurazione \"[mcu]\"). \u00c8 un numero in virgola mobile memorizzato come secondi ed \u00e8 relativo all'ultimo riavvio dell'mcu principale. \u00c8 possibile convertire da un \"tempo di stampa\" all'orologio hardware del microcontrollore principale moltiplicando il tempo di stampa per la frequenza di frequenza configurata staticamente dell'mcu. Il codice host di alto livello utilizza i tempi di stampa per calcolare quasi tutte le azioni fisiche (ad es. movimento della testa, modifiche del riscaldatore, ecc.). All'interno del codice host, i tempi di stampa sono generalmente memorizzati in variabili denominate print_time o move_time . Orologio MCU. Questo \u00e8 il contatore dell'orologio hardware su ogni microcontrollore. Viene memorizzato come numero intero e la sua velocit\u00e0 di aggiornamento \u00e8 relativa alla frequenza del microcontrollore specificato. Il software host traduce i suoi tempi interni in orologi prima della trasmissione all'mcu. Il codice mcu tiene traccia del tempo solo in tick dell'orologio. All'interno del codice host, i valori di clock vengono tracciati come interi a 64 bit, mentre il codice mcu utilizza interi a 32 bit. All'interno del codice host, gli orologi sono generalmente memorizzati in variabili con nomi contenenti clock o tick . La conversione tra i diversi formati dell'ora \u00e8 implementata principalmente nel codice klippy/clocksync.py . Alcune cose da tenere presenti durante la revisione del codice: Orologi a 32 bit e 64 bit: per ridurre la larghezza di banda e migliorare l'efficienza del microcontrollore, gli orologi sul microcontrollore vengono tracciati come numeri interi a 32 bit. Quando si confrontano due orologi nel codice mcu, la funzione timer_is_before() deve essere sempre utilizzata per garantire che i rollover interi siano gestiti correttamente. Il software host converte gli orologi a 32 bit in orologi a 64 bit aggiungendo i bit di ordine superiore dall'ultimo timestamp mcu che ha ricevuto - nessun messaggio dall'mcu \u00e8 mai pi\u00f9 di 2^31 tick di clock in futuro o nel passato, quindi questa conversione non \u00e8 mai ambigua . L'host converte da clock a 64 bit a clock a 32 bit semplicemente troncando i bit di ordine superiore. Per garantire che non vi siano ambiguit\u00e0 in questa conversione, il codice klippy/chelper/serialqueue.c memorizza i messaggi nel buffer finch\u00e9 non si trovano entro 2^31 tick di clock dall'ora target. Microcontrollori multipli: il software host supporta l'utilizzo di pi\u00f9 microcontrollori su una singola stampante. In questo caso, il \"clock MCU\" di ogni microcontrollore viene tracciato separatamente. Il codice clocksync.py gestisce la deriva dell'orologio tra i microcontrollori modificando il modo in cui converte da \"tempo di stampa\" a \"orologio MCU\". Sul mcus secondario, la frequenza mcu utilizzata in questa conversione viene regolarmente aggiornata per tenere conto della deriva misurata.","title":"Time"},{"location":"Command_Templates.html","text":"Modelli di comandi \u00b6 Questo documento fornisce informazioni sull'implementazione di sequenze di comandi G-Code nelle sezioni di configurazione gcode_macro (e simili). Denominazione macro G-Code \u00b6 Le maiuscole non sono importanti per il nome della macro G-Code: MY_MACRO e my_macro saranno considerate allo stesso modo e possono essere chiamati in maiuscolo o minuscolo. Se nel nome della macro vengono utilizzati dei numeri, devono trovarsi tutti alla fine del nome (ad es. TEST_MACRO25 \u00e8 valido, ma MACRO25_TEST3 non lo \u00e8). Formattazione di G-Code nel config \u00b6 L'indentazione \u00e8 importante quando si definisce una macro nel file di configurazione. Per specificare una sequenza G-Code su pi\u00f9 righe \u00e8 importante che ogni riga abbia un'indentazione adeguata. Per esempio: [gcode_macro led_lampeggiante] gcode: SET_PIN PIN=my_led VALUE=1 G4 P2000 SET_PIN PIN=my_led VALUE=0 Nota come l'opzione di configurazione gcode: inizia sempre all'inizio della riga e le righe successive nella macro G-Code non iniziano mai all'inizio. Aggiungi una descrizione alla tua macro \u00b6 Per aiutare a identificare la funzionalit\u00e0 \u00e8 possibile aggiungere una breve descrizione. Aggiungi descrizione: con un breve testo per descrivere la funzionalit\u00e0. L'impostazione predefinita \u00e8 \"Macro codice G\" se non specificato. Per esempio: [gcode_macro led_lampeggiante] description: Esegue lampeggio del led una volta gcode: SET_PIN PIN=my_led VALUE=1 G4 P2000 SET_PIN PIN=my_led VALUE=0 Il terminale visualizzer\u00e0 la descrizione quando si utilizza il comando HELP o la funzione di completamento automatico. Salva/ripristina lo stato per i movimenti G-Code \u00b6 Sfortunatamente, il linguaggio di comando G-Code pu\u00f2 essere difficile da usare. Il meccanismo standard per spostare la testa di stampa \u00e8 tramite il comando G1 (il comando G0 \u00e8 un alias per G1 e pu\u00f2 essere usato in modo intercambiabile con esso). Tuttavia, questo comando si basa sull'impostazione dello \"stato di analisi del codice G\" da M82 , M83 , G90 , G91 , G92 e precedenti comandi G1 . Quando si crea una macro G-Code \u00e8 una buona idea impostare sempre in modo esplicito lo stato di analisi del G-Code prima di emettere un comando G1 . (Altrimenti, c'\u00e8 il rischio che il comando G1 faccia una richiesta indesiderabile.) Un modo comune per farlo \u00e8 avvolgere le mosse G1 in SAVE_GCODE_STATE , G91 e RESTORE_GCODE_STATE . Per esempio: [gcode_macro MOVE_UP] gcode: SAVE_GCODE_STATE NAME=my_move_up_state G91 G1 Z10 F300 RESTORE_GCODE_STATE NAME=my_move_up_state Il comando G91 pone lo stato di analisi del codice G in \"modalit\u00e0 di spostamento relativo\" e il comando RESTORE_GCODE_STATE ripristina lo stato a quello che era prima di entrare nella macro. Assicurati di specificare una velocit\u00e0 esplicita (tramite il parametro F ) sul primo comando G1 . Espansione del modello \u00b6 La sezione di configurazione di gcode_macro gcode: viene valutata utilizzando il linguaggio del modello Jinja2. \u00c8 possibile valutare le espressioni in fase di esecuzione racchiudendole in caratteri { } o utilizzando istruzioni condizionali racchiuse in {% %} . Vedere la documentazione Jinja2 per ulteriori informazioni sulla sintassi. Un esempio di macro complessa: [gcode_macro clean_nozzle] gcode: {% set wipe_count = 8 %} SAVE_GCODE_STATE NAME=clean_nozzle_state G90 G0 Z15 F300 {% for wipe in range(wipe_count) %} {% for coordinate in [(275, 4),(235, 4)] %} G0 X{coordinate[0]} Y{coordinate[1] + 0.25 * wipe} Z9.7 F12000 {% endfor %} {% endfor %} RESTORE_GCODE_STATE NAME=clean_nozzle_state Parametri Macro \u00b6 Spesso \u00e8 utile controllare i parametri passati alla macro quando viene chiamata. Questi parametri sono disponibili tramite la pseudo-variabile params . Ad esempio, se la macro: [gcode_macro SET_PERCENT] gcode: M117 Now at { params.VALUE|float * 100 }% sono stati invocati come SET_PERCENT VALUE=.2 verrebbero valutati in M117 Now at 20% . Si noti che i nomi dei parametri sono sempre in maiuscolo quando vengono valutati nella macro e vengono sempre passati come stringhe. Se si eseguono calcoli matematici, devono essere convertiti esplicitamente in numeri interi o float. \u00c8 comune usare la direttiva Jinja2 set per usare un parametro predefinito e assegnare il risultato a un nome locale. Per esempio: [gcode_macro SET_BED_TEMPERATURE] gcode: {% set bed_temp = params.TEMPERATURE|default(40)|float %} M140 S{bed_temp La variabile \"rawparams\" \u00b6 \u00c8 possibile accedere ai parametri completi non analizzati per la macro in esecuzione tramite la pseudo-variabile rawparams . Nota che questo includer\u00e0 tutti i commenti che facevano parte del comando originale. Vedere il file sample-macros.cfg per un esempio che mostra come sovrascrivere il comando M117 usando rawparams . La variabile \"printer\" \u00b6 \u00c8 possibile ispezionare (e modificare) lo stato corrente della stampante tramite la pseudo-variabile printer . Per esempio: [gcode_macro slow_fan] gcode: M106 S{ printer.fan.speed * 0.9 * 255} I campi disponibili sono definiti nel documento Status Reference . Importante! Le macro vengono prima valutate per intero e solo dopo vengono eseguiti i comandi risultanti. Se una macro emette un comando che altera lo stato della stampante, i risultati di tale cambiamento di stato non saranno visibili durante la valutazione della macro. Ci\u00f2 pu\u00f2 anche comportare un comportamento impercettibile quando una macro genera comandi che chiamano altre macro, poich\u00e9 la macro chiamata viene valutata quando viene richiamata (che avviene dopo l'intera valutazione della macro chiamante). Per convenzione, il nome immediatamente successivo a printer \u00e8 il nome di una sezione di configurazione. Quindi, ad esempio, printer.fan si riferisce all'oggetto fan creato dalla sezione di configurazione [fan] . Ci sono alcune eccezioni a questa regola, in particolare gli oggetti gcode_move e toolhead . Se la sezione di configurazione contiene spazi, \u00e8 possibile accedervi tramite l'accessor [ ] , ad esempio: printer[\"generic_heater my_chamber_heater\"].temperature . Si noti che la direttiva Jinja2 set pu\u00f2 assegnare un nome locale a un oggetto nella gerarchia printer . Ci\u00f2 pu\u00f2 rendere le macro pi\u00f9 leggibili e ridurre la digitazione. Per esempio: [gcode_macro QUERY_HTU21D] gcode: {% set sensor = printer[\"htu21d my_sensor\"] %} M117 Temp:{sensor.temperature} Humidity:{sensor.humidity} Azioni \u00b6 Sono disponibili alcuni comandi che possono alterare lo stato della stampante. Ad esempio, { action_emergency_stop() } provocherebbe l'arresto della stampante. Si noti che queste azioni vengono eseguite nel momento in cui viene valutata la macro, il che potrebbe richiedere un periodo di tempo significativo prima dell'esecuzione dei comandi g-code generati. Comandi \"azione\" disponibili: action_respond_info(msg) : scrive il dato msg sullo pseudo-terminale /tmp/printer. Ogni riga di msg verr\u00e0 inviata con un prefisso \"//\". action_raise_error(msg) : annulla la macro corrente (e qualsiasi macro chiamante) e scrivie il dato msg sullo pseudo-terminale /tmp/printer. La prima riga di msg verr\u00e0 inviata con un prefisso \"!!\" e le righe successive avranno un prefisso \"//\". action_emergency_stop(msg) : fa passare la stampante a uno stato di spegnimento. Il parametro msg \u00e8 opzionale, pu\u00f2 essere utile per descrivere il motivo dell'arresto. action_call_remote_method(method_name) : chiama un metodo registrato da un client remoto. Se il metodo accetta parametri, questi dovrebbero essere forniti tramite argomenti chiave, ad esempio: action_call_remote_method(\"print_stuff\", my_arg=\"hello_world\") Variabili \u00b6 Il comando SET_GCODE_VARIABLE pu\u00f2 essere utile per salvare lo stato tra le chiamate di macro. I nomi delle variabili non possono contenere caratteri maiuscoli. Per esempio: [gcode_macro start_probe] variable_bed_temp: 0 gcode: # Salva la temperatura target nella variabile bed_temp SET_GCODE_VARIABLE MACRO=start_probe VARIABLE=bed_temp VALUE={printer.heater_bed.target} # Disattiva il riscaldamento del piatto M140 # Esegue sonda PROBE # Chiama la macro finish_probe al completamento finish_probe [gcode_macro finish_probe] gcode: # Ripristinare la temperatura del piatto M140 S{printer[\"gcode_macro start_probe\"].bed_temp} Assicurarsi di tenere in considerazione i tempi della valutazione della macro e dell'esecuzione dei comandi quando si utilizza SET_GCODE_VARIABLE. Gcode ritardati \u00b6 L'opzione di configurazione [delayed_gcode] pu\u00f2 essere utilizzata per eseguire una sequenza gcode ritardata: [delayed_gcode clear_display] gcode: M117 [gcode_macro load_filament] gcode: G91 G1 E50 G90 M400 M117 Load Complete! UPDATE_DELAYED_GCODE ID=clear_display DURATION=10 Quando viene eseguita la macro load_filament sopra, visualizzer\u00e0 un \"Load Complete!\" messaggio al termine dell'estrusione. L'ultima riga di gcode abilita il delay_gcode \"clear_display\", impostato per essere eseguito in 10 secondi. L'opzione di configurazione initial_duration pu\u00f2 essere impostata per eseguire il delay_gcode all'avvio della stampante. Il conto alla rovescia inizia quando la stampante entra nello stato \"ready\". Ad esempio, il codice delay_g riportato di seguito verr\u00e0 eseguito 5 secondi dopo che la stampante \u00e8 pronta, inizializzando il display con un messaggio\"Welcome!\": [delayed_gcode welcome] initial_duration: 5. gcode: M117 Welcome! \u00c8 possibile che un gcode ritardato si ripeta aggiornandosi nell'opzione gcode: [delayed_gcode report_temp] initial_duration: 2. gcode: {action_respond_info(\"Extruder Temp: %.1f\" % (printer.extruder0.temperature))} UPDATE_DELAYED_GCODE ID=report_temp DURATION=2 Il codice delayed_gcode sopra riportato invier\u00e0 \"// Extruder Temp: [ex0_temp]\" a Octoprint ogni 2 secondi. Questo pu\u00f2 essere annullato con il seguente gcode: UPDATE_DELAYED_GCODE ID=report_temp DURATION=0 Modelli di menu \u00b6 Se \u00e8 abilitata una sezione di configurazione display , \u00e8 possibile personalizzare il menu con le sezioni di configurazione menu . I seguenti attributi di sola lettura sono disponibili nei modelli di menu: menu.width - larghezza dell'elemento (numero di colonne di visualizzazione) menu.ns - namespace del elemento menu.event - nome dell'evento che ha attivato lo script menu.input - valore di input, disponibile solo nel contesto dello script di input Le seguenti azioni sono disponibili nei modelli di menu: menu.back(force, update) : eseguir\u00e0 il comando menu back, parametri booleani opzionali <force> e <update> . Quando <force> \u00e8 impostato su True, interromper\u00e0 anche la modifica. Il valore predefinito \u00e8 False. Quando <update> \u00e8 impostato su False, gli elementi del contenitore padre non vengono aggiornati. Il valore predefinito \u00e8 True. menu.exit(force) - eseguir\u00e0 il comando di uscita dal menu, parametro booleano opzionale <force> valore predefinito False. Quando <force> \u00e8 impostato su True, interromper\u00e0 anche la modifica. Il valore predefinito \u00e8 False. Salvare variabili su disco \u00b6 Se \u00e8 stata abilitata una sezione di configurazione save_variables , SAVE_VARIABLE VARIABLE=<nome> VALUE=<valore> pu\u00f2 essere utilizzato per salvare la variabile su disco in modo che possa essere utilizzata tra i riavvii. Tutte le variabili memorizzate vengono caricate nel dict printer.save_variables.variables all'avvio e possono essere utilizzate nelle macro gcode. per evitare righe troppo lunghe puoi aggiungere quanto segue nella parte superiore della macro: {% set svv = printer.save_variables.variables %} Ad esempio, potrebbe essere utilizzato per salvare lo stato dell'hotend 2-in-1-out e quando si avvia una stampa assicurarsi che venga utilizzato l'estrusore attivo, anzich\u00e9 T0: [gcode_macro T1] gcode: ACTIVATE_EXTRUDER extruder=extruder1 SAVE_VARIABLE VARIABLE=currentextruder VALUE='\"extruder1\"' [gcode_macro T0] gcode: ACTIVATE_EXTRUDER extruder=extruder SAVE_VARIABLE VARIABLE=currentextruder VALUE='\"extruder\"' [gcode_macro START_GCODE] gcode: {% set svv = printer.save_variables.variables %} ACTIVATE_EXTRUDER extruder={svv.currentextruder}","title":"Modelli di comandi"},{"location":"Command_Templates.html#modelli-di-comandi","text":"Questo documento fornisce informazioni sull'implementazione di sequenze di comandi G-Code nelle sezioni di configurazione gcode_macro (e simili).","title":"Modelli di comandi"},{"location":"Command_Templates.html#denominazione-macro-g-code","text":"Le maiuscole non sono importanti per il nome della macro G-Code: MY_MACRO e my_macro saranno considerate allo stesso modo e possono essere chiamati in maiuscolo o minuscolo. Se nel nome della macro vengono utilizzati dei numeri, devono trovarsi tutti alla fine del nome (ad es. TEST_MACRO25 \u00e8 valido, ma MACRO25_TEST3 non lo \u00e8).","title":"Denominazione macro G-Code"},{"location":"Command_Templates.html#formattazione-di-g-code-nel-config","text":"L'indentazione \u00e8 importante quando si definisce una macro nel file di configurazione. Per specificare una sequenza G-Code su pi\u00f9 righe \u00e8 importante che ogni riga abbia un'indentazione adeguata. Per esempio: [gcode_macro led_lampeggiante] gcode: SET_PIN PIN=my_led VALUE=1 G4 P2000 SET_PIN PIN=my_led VALUE=0 Nota come l'opzione di configurazione gcode: inizia sempre all'inizio della riga e le righe successive nella macro G-Code non iniziano mai all'inizio.","title":"Formattazione di G-Code nel config"},{"location":"Command_Templates.html#aggiungi-una-descrizione-alla-tua-macro","text":"Per aiutare a identificare la funzionalit\u00e0 \u00e8 possibile aggiungere una breve descrizione. Aggiungi descrizione: con un breve testo per descrivere la funzionalit\u00e0. L'impostazione predefinita \u00e8 \"Macro codice G\" se non specificato. Per esempio: [gcode_macro led_lampeggiante] description: Esegue lampeggio del led una volta gcode: SET_PIN PIN=my_led VALUE=1 G4 P2000 SET_PIN PIN=my_led VALUE=0 Il terminale visualizzer\u00e0 la descrizione quando si utilizza il comando HELP o la funzione di completamento automatico.","title":"Aggiungi una descrizione alla tua macro"},{"location":"Command_Templates.html#salvaripristina-lo-stato-per-i-movimenti-g-code","text":"Sfortunatamente, il linguaggio di comando G-Code pu\u00f2 essere difficile da usare. Il meccanismo standard per spostare la testa di stampa \u00e8 tramite il comando G1 (il comando G0 \u00e8 un alias per G1 e pu\u00f2 essere usato in modo intercambiabile con esso). Tuttavia, questo comando si basa sull'impostazione dello \"stato di analisi del codice G\" da M82 , M83 , G90 , G91 , G92 e precedenti comandi G1 . Quando si crea una macro G-Code \u00e8 una buona idea impostare sempre in modo esplicito lo stato di analisi del G-Code prima di emettere un comando G1 . (Altrimenti, c'\u00e8 il rischio che il comando G1 faccia una richiesta indesiderabile.) Un modo comune per farlo \u00e8 avvolgere le mosse G1 in SAVE_GCODE_STATE , G91 e RESTORE_GCODE_STATE . Per esempio: [gcode_macro MOVE_UP] gcode: SAVE_GCODE_STATE NAME=my_move_up_state G91 G1 Z10 F300 RESTORE_GCODE_STATE NAME=my_move_up_state Il comando G91 pone lo stato di analisi del codice G in \"modalit\u00e0 di spostamento relativo\" e il comando RESTORE_GCODE_STATE ripristina lo stato a quello che era prima di entrare nella macro. Assicurati di specificare una velocit\u00e0 esplicita (tramite il parametro F ) sul primo comando G1 .","title":"Salva/ripristina lo stato per i movimenti G-Code"},{"location":"Command_Templates.html#espansione-del-modello","text":"La sezione di configurazione di gcode_macro gcode: viene valutata utilizzando il linguaggio del modello Jinja2. \u00c8 possibile valutare le espressioni in fase di esecuzione racchiudendole in caratteri { } o utilizzando istruzioni condizionali racchiuse in {% %} . Vedere la documentazione Jinja2 per ulteriori informazioni sulla sintassi. Un esempio di macro complessa: [gcode_macro clean_nozzle] gcode: {% set wipe_count = 8 %} SAVE_GCODE_STATE NAME=clean_nozzle_state G90 G0 Z15 F300 {% for wipe in range(wipe_count) %} {% for coordinate in [(275, 4),(235, 4)] %} G0 X{coordinate[0]} Y{coordinate[1] + 0.25 * wipe} Z9.7 F12000 {% endfor %} {% endfor %} RESTORE_GCODE_STATE NAME=clean_nozzle_state","title":"Espansione del modello"},{"location":"Command_Templates.html#parametri-macro","text":"Spesso \u00e8 utile controllare i parametri passati alla macro quando viene chiamata. Questi parametri sono disponibili tramite la pseudo-variabile params . Ad esempio, se la macro: [gcode_macro SET_PERCENT] gcode: M117 Now at { params.VALUE|float * 100 }% sono stati invocati come SET_PERCENT VALUE=.2 verrebbero valutati in M117 Now at 20% . Si noti che i nomi dei parametri sono sempre in maiuscolo quando vengono valutati nella macro e vengono sempre passati come stringhe. Se si eseguono calcoli matematici, devono essere convertiti esplicitamente in numeri interi o float. \u00c8 comune usare la direttiva Jinja2 set per usare un parametro predefinito e assegnare il risultato a un nome locale. Per esempio: [gcode_macro SET_BED_TEMPERATURE] gcode: {% set bed_temp = params.TEMPERATURE|default(40)|float %} M140 S{bed_temp","title":"Parametri Macro"},{"location":"Command_Templates.html#la-variabile-rawparams","text":"\u00c8 possibile accedere ai parametri completi non analizzati per la macro in esecuzione tramite la pseudo-variabile rawparams . Nota che questo includer\u00e0 tutti i commenti che facevano parte del comando originale. Vedere il file sample-macros.cfg per un esempio che mostra come sovrascrivere il comando M117 usando rawparams .","title":"La variabile \"rawparams\""},{"location":"Command_Templates.html#la-variabile-printer","text":"\u00c8 possibile ispezionare (e modificare) lo stato corrente della stampante tramite la pseudo-variabile printer . Per esempio: [gcode_macro slow_fan] gcode: M106 S{ printer.fan.speed * 0.9 * 255} I campi disponibili sono definiti nel documento Status Reference . Importante! Le macro vengono prima valutate per intero e solo dopo vengono eseguiti i comandi risultanti. Se una macro emette un comando che altera lo stato della stampante, i risultati di tale cambiamento di stato non saranno visibili durante la valutazione della macro. Ci\u00f2 pu\u00f2 anche comportare un comportamento impercettibile quando una macro genera comandi che chiamano altre macro, poich\u00e9 la macro chiamata viene valutata quando viene richiamata (che avviene dopo l'intera valutazione della macro chiamante). Per convenzione, il nome immediatamente successivo a printer \u00e8 il nome di una sezione di configurazione. Quindi, ad esempio, printer.fan si riferisce all'oggetto fan creato dalla sezione di configurazione [fan] . Ci sono alcune eccezioni a questa regola, in particolare gli oggetti gcode_move e toolhead . Se la sezione di configurazione contiene spazi, \u00e8 possibile accedervi tramite l'accessor [ ] , ad esempio: printer[\"generic_heater my_chamber_heater\"].temperature . Si noti che la direttiva Jinja2 set pu\u00f2 assegnare un nome locale a un oggetto nella gerarchia printer . Ci\u00f2 pu\u00f2 rendere le macro pi\u00f9 leggibili e ridurre la digitazione. Per esempio: [gcode_macro QUERY_HTU21D] gcode: {% set sensor = printer[\"htu21d my_sensor\"] %} M117 Temp:{sensor.temperature} Humidity:{sensor.humidity}","title":"La variabile \"printer\""},{"location":"Command_Templates.html#azioni","text":"Sono disponibili alcuni comandi che possono alterare lo stato della stampante. Ad esempio, { action_emergency_stop() } provocherebbe l'arresto della stampante. Si noti che queste azioni vengono eseguite nel momento in cui viene valutata la macro, il che potrebbe richiedere un periodo di tempo significativo prima dell'esecuzione dei comandi g-code generati. Comandi \"azione\" disponibili: action_respond_info(msg) : scrive il dato msg sullo pseudo-terminale /tmp/printer. Ogni riga di msg verr\u00e0 inviata con un prefisso \"//\". action_raise_error(msg) : annulla la macro corrente (e qualsiasi macro chiamante) e scrivie il dato msg sullo pseudo-terminale /tmp/printer. La prima riga di msg verr\u00e0 inviata con un prefisso \"!!\" e le righe successive avranno un prefisso \"//\". action_emergency_stop(msg) : fa passare la stampante a uno stato di spegnimento. Il parametro msg \u00e8 opzionale, pu\u00f2 essere utile per descrivere il motivo dell'arresto. action_call_remote_method(method_name) : chiama un metodo registrato da un client remoto. Se il metodo accetta parametri, questi dovrebbero essere forniti tramite argomenti chiave, ad esempio: action_call_remote_method(\"print_stuff\", my_arg=\"hello_world\")","title":"Azioni"},{"location":"Command_Templates.html#variabili","text":"Il comando SET_GCODE_VARIABLE pu\u00f2 essere utile per salvare lo stato tra le chiamate di macro. I nomi delle variabili non possono contenere caratteri maiuscoli. Per esempio: [gcode_macro start_probe] variable_bed_temp: 0 gcode: # Salva la temperatura target nella variabile bed_temp SET_GCODE_VARIABLE MACRO=start_probe VARIABLE=bed_temp VALUE={printer.heater_bed.target} # Disattiva il riscaldamento del piatto M140 # Esegue sonda PROBE # Chiama la macro finish_probe al completamento finish_probe [gcode_macro finish_probe] gcode: # Ripristinare la temperatura del piatto M140 S{printer[\"gcode_macro start_probe\"].bed_temp} Assicurarsi di tenere in considerazione i tempi della valutazione della macro e dell'esecuzione dei comandi quando si utilizza SET_GCODE_VARIABLE.","title":"Variabili"},{"location":"Command_Templates.html#gcode-ritardati","text":"L'opzione di configurazione [delayed_gcode] pu\u00f2 essere utilizzata per eseguire una sequenza gcode ritardata: [delayed_gcode clear_display] gcode: M117 [gcode_macro load_filament] gcode: G91 G1 E50 G90 M400 M117 Load Complete! UPDATE_DELAYED_GCODE ID=clear_display DURATION=10 Quando viene eseguita la macro load_filament sopra, visualizzer\u00e0 un \"Load Complete!\" messaggio al termine dell'estrusione. L'ultima riga di gcode abilita il delay_gcode \"clear_display\", impostato per essere eseguito in 10 secondi. L'opzione di configurazione initial_duration pu\u00f2 essere impostata per eseguire il delay_gcode all'avvio della stampante. Il conto alla rovescia inizia quando la stampante entra nello stato \"ready\". Ad esempio, il codice delay_g riportato di seguito verr\u00e0 eseguito 5 secondi dopo che la stampante \u00e8 pronta, inizializzando il display con un messaggio\"Welcome!\": [delayed_gcode welcome] initial_duration: 5. gcode: M117 Welcome! \u00c8 possibile che un gcode ritardato si ripeta aggiornandosi nell'opzione gcode: [delayed_gcode report_temp] initial_duration: 2. gcode: {action_respond_info(\"Extruder Temp: %.1f\" % (printer.extruder0.temperature))} UPDATE_DELAYED_GCODE ID=report_temp DURATION=2 Il codice delayed_gcode sopra riportato invier\u00e0 \"// Extruder Temp: [ex0_temp]\" a Octoprint ogni 2 secondi. Questo pu\u00f2 essere annullato con il seguente gcode: UPDATE_DELAYED_GCODE ID=report_temp DURATION=0","title":"Gcode ritardati"},{"location":"Command_Templates.html#modelli-di-menu","text":"Se \u00e8 abilitata una sezione di configurazione display , \u00e8 possibile personalizzare il menu con le sezioni di configurazione menu . I seguenti attributi di sola lettura sono disponibili nei modelli di menu: menu.width - larghezza dell'elemento (numero di colonne di visualizzazione) menu.ns - namespace del elemento menu.event - nome dell'evento che ha attivato lo script menu.input - valore di input, disponibile solo nel contesto dello script di input Le seguenti azioni sono disponibili nei modelli di menu: menu.back(force, update) : eseguir\u00e0 il comando menu back, parametri booleani opzionali <force> e <update> . Quando <force> \u00e8 impostato su True, interromper\u00e0 anche la modifica. Il valore predefinito \u00e8 False. Quando <update> \u00e8 impostato su False, gli elementi del contenitore padre non vengono aggiornati. Il valore predefinito \u00e8 True. menu.exit(force) - eseguir\u00e0 il comando di uscita dal menu, parametro booleano opzionale <force> valore predefinito False. Quando <force> \u00e8 impostato su True, interromper\u00e0 anche la modifica. Il valore predefinito \u00e8 False.","title":"Modelli di menu"},{"location":"Command_Templates.html#salvare-variabili-su-disco","text":"Se \u00e8 stata abilitata una sezione di configurazione save_variables , SAVE_VARIABLE VARIABLE=<nome> VALUE=<valore> pu\u00f2 essere utilizzato per salvare la variabile su disco in modo che possa essere utilizzata tra i riavvii. Tutte le variabili memorizzate vengono caricate nel dict printer.save_variables.variables all'avvio e possono essere utilizzate nelle macro gcode. per evitare righe troppo lunghe puoi aggiungere quanto segue nella parte superiore della macro: {% set svv = printer.save_variables.variables %} Ad esempio, potrebbe essere utilizzato per salvare lo stato dell'hotend 2-in-1-out e quando si avvia una stampa assicurarsi che venga utilizzato l'estrusore attivo, anzich\u00e9 T0: [gcode_macro T1] gcode: ACTIVATE_EXTRUDER extruder=extruder1 SAVE_VARIABLE VARIABLE=currentextruder VALUE='\"extruder1\"' [gcode_macro T0] gcode: ACTIVATE_EXTRUDER extruder=extruder SAVE_VARIABLE VARIABLE=currentextruder VALUE='\"extruder\"' [gcode_macro START_GCODE] gcode: {% set svv = printer.save_variables.variables %} ACTIVATE_EXTRUDER extruder={svv.currentextruder}","title":"Salvare variabili su disco"},{"location":"Config_Changes.html","text":"Modifiche alla configurazione \u00b6 Questo documento copre le modifiche software recenti al file di configurazione che non sono compatibili con le versioni precedenti. \u00c8 una buona idea rivedere questo documento durante l'aggiornamento del software Klipper. Tutte le date in questo documento sono approssimative. Cambiamenti \u00b6 20241203: The resonance test has been changed to include slow sweeping moves. This change requires that testing point(s) have some clearance in X/Y plane (+/- 30 mm from the test point should suffice when using the default settings). The new test should generally produce more accurate and reliable test results. However, if required, the previous test behavior can be restored by adding options sweeping_period: 0 and accel_per_hz: 75 to the [resonance_tester] config section. 20241201: In some cases Klipper may have ignored leading characters or spaces in a traditional G-Code command. For example, \"99M123\" may have been interpreted as \"M123\" and \"M 321\" may have been interpreted as \"M321\". Klipper will now report these cases with an \"Unknown command\" warning. 20241112: Option CHIPS=<chip_name> in TEST_RESONANCES and SHAPER_CALIBRATE requires specifying the full name(s) of the accel chip(s). For example, adxl345 rpi instead of short name - rpi . 20240912: SET_PIN , SET_SERVO , SET_FAN_SPEED , M106 , and M107 commands are now collated. Previously, if many updates to the same object were issued faster than the minimum scheduling time (typically 100ms) then actual updates could be queued far into the future. Now if many updates are issued in rapid succession then it is possible that only the latest request will be applied. If the previous behavior is requried then consider adding explicit G4 delay commands between updates. 20240912: Support for maximum_mcu_duration and static_value parameters in [output_pin] config sections have been removed. These options have been deprecated since 20240123. 20240415: The on_error_gcode parameter in the [virtual_sdcard] config section now has a default. If this parameter is not specified it now defaults to TURN_OFF_HEATERS . If the previous behavior is desired (take no default action on an error during a virtual_sdcard print) then define on_error_gcode with an empty value. 20240313: The max_accel_to_decel parameter in the [printer] config section has been deprecated. The ACCEL_TO_DECEL parameter of the SET_VELOCITY_LIMIT command has been deprecated. The printer.toolhead.max_accel_to_decel status has been removed. Use the minimum_cruise_ratio parameter instead. The deprecated features will be removed in the near future, and using them in the interim may result in subtly different behavior. 20240215: Several deprecated features have been removed. Using \"NTC 100K beta 3950\" as a thermistor name has been removed (deprecated on 20211110). The SYNC_STEPPER_TO_EXTRUDER and SET_EXTRUDER_STEP_DISTANCE commands have been removed, and the extruder shared_heater config option has been removed (deprecated on 20220210). The bed_mesh relative_reference_index option has been removed (deprecated on 20230619). 20240123: The output_pin SET_PIN CYCLE_TIME parameter has been removed. Use the new pwm_cycle_time module if it is necessary to dynamically change a pwm pin's cycle time. 20240123: The output_pin maximum_mcu_duration parameter is deprecated. Use a pwm_tool config section instead. The option will be removed in the near future. 20240123: The output_pin static_value parameter is deprecated. Replace with value and shutdown_value parameters. The option will be removed in the near future. 20231216: The [hall_filament_width_sensor] is changed to trigger filament runout when the thickness of the filament exceeds max_diameter . The maximum diameter defaults to default_nominal_filament_diameter + max_difference . See [hall_filament_width_sensor] configuration reference for more details. 20231207: Several undocumented config parameters in the [printer] config section have been removed (the buffer_time_low, buffer_time_high, buffer_time_start, and move_flush_time parameters). 20231110: Klipper v0.12.0 released. 20230826: If safe_distance is set or calculated to be 0 in [dual_carriage] , the carriages proximity checks will be disabled as per documentation. A user may wish to configure safe_distance explicitly to prevent accidental crashes of the carriages with each other. Additionally, the homing order of the primary and the dual carriage is changed in some configurations (certain configurations when both carriages home in the same direction, see [dual_carriage] configuration reference for more details). 20230810: The flash-sdcard.sh script now supports both variants of the Bigtreetech SKR-3, STM32H743 and STM32H723. For this, the original tag of btt-skr-3 now has changed to be either btt-skr-3-h743 or btt-skr-3-h723. 20230729: The exported status for dual_carriage is changed. Instead of exporting mode and active_carriage , the individual modes for each carriage are exported as printer.dual_carriage.carriage_0 and printer.dual_carriage.carriage_1 . 20230619: The relative_reference_index option has been deprecated and superceded by the zero_reference_position option. Refer to the Bed Mesh Documentation for details on how to update the configuration. With this deprecation the RELATIVE_REFERENCE_INDEX is no longer available as a parameter for the BED_MESH_CALIBRATE gcode command. 20230530: The default canbus frequency in \"make menuconfig\" is now 1000000. If using canbus and using canbus with some other frequency is required, then be sure to select \"Enable extra low-level configuration options\" and specify the desired \"CAN bus speed\" in \"make menuconfig\" when compiling and flashing the micro-controller. 20230525: SHAPER_CALIBRATE command immediately applies input shaper parameters if [input_shaper] was enabled already. 20230407: The stalled_bytes counter in the log and in the printer.mcu.last_stats field has been renamed to upcoming_bytes . 20230323: On tmc5160 drivers multistep_filt is now enabled by default. Set driver_MULTISTEP_FILT: False in the tmc5160 config for the previous behavior. 20230304: Il comando SET_TMC_CURRENT ora regola correttamente il registro globalscaler per i driver che lo dispongono. Ci\u00f2 rimuove una limitazione per cui su tmc5160, le correnti non potevano essere aumentate con SET_TMC_CURRENT rispetto al valore run_current impostato nel file di configurazione. Tuttavia, questo ha un effetto collaterale: dopo aver eseguito SET_TMC_CURRENT , lo stepper deve essere tenuto fermo per >130 ms nel caso in cui venga utilizzato StealthChop2 in modo che la calibrazione AT#1 venga eseguita dal driver. 20230202: il formato delle informazioni sullo stato di printer.screws_tilt_adjust \u00e8 stato modificato. Le informazioni vengono ora memorizzate come dizionario delle viti con le misurazioni risultanti. Consulta il riferimento sullo stato per i dettagli. 20230201: Il modulo [bed_mesh] non carica pi\u00f9 il profilo default all'avvio. Si consiglia agli utenti che usano il profilo default di aggiungere BED_MESH_PROFILE LOAD=default alla loro macro START_PRINT (o alla configurazione \"Start G-Code\" del loro slicer quando applicabile). 20230103: Ora \u00e8 possibile con lo script flash-sdcard.sh eseguire il flashing di entrambe le varianti di Bigtreetech SKR-2, STM32F407 e STM32F429. Ci\u00f2 significa che il tag originale di btt-skr2 ora \u00e8 cambiato in btt-skr-2-f407 o btt-skr-2-f429. 20221128: rilascio di Klipper v0.11.0. 20221122: In precedenza, con safe_z_home, era possibile che z_hop dopo l'homing g28 andasse nella direzione z negativa. Ora, uno z_hop viene eseguito dopo g28 solo se risulta in un hop positivo, rispecchiando il comportamento dello z_hop che si verifica prima dell'homing g28. 20220616: in precedenza era possibile eseguire il flashing di un rp2040 in modalit\u00e0 bootloader eseguendo make flash FLASH_DEVICE=first . Il comando equivalente \u00e8 ora make flash FLASH_DEVICE=2e8a:0003 . 20220612: Il microcontrollore rp2040 ora ha una soluzione alternativa per l'errata USB \"rp2040-e5\". Ci\u00f2 dovrebbe rendere pi\u00f9 affidabili le connessioni USB iniziali. Tuttavia, potrebbe comportare un cambiamento nel comportamento del pin gpio15. \u00c8 improbabile che il cambiamento di comportamento di gpio15 sia evidente. 20220407: l'opzione di configurazione temperature_fan pid_integral_max \u00e8 stata rimossa (era deprecata su 20210612). 20220407: L'ordine dei colori predefinito per i LED pca9632 \u00e8 ora \"RGBW\". Aggiungi un'impostazione esplicita color_order: RBGW alla sezione di configurazione di pca9632 per ottenere il comportamento precedente. 20220330: Il formato delle informazioni di stato printer.neopixel.color_data per i moduli neopixel e dotstar \u00e8 cambiato. Le informazioni sono ora memorizzate come un elenco di elenchi di colori (invece di un elenco di dizionari). Per i dettagli, vedere il riferimento dello stato . 20220307: M73 non imposter\u00e0 pi\u00f9 l'avanzamento della stampa su 0 se manca P . 20220304: Non esiste pi\u00f9 un valore predefinito per il parametro extruder delle sezioni di configurazione extruder_stepper . Se lo si desidera, specificare esplicitamente extruder: extruder per associare il motore passo-passo alla coda di movimento \"estrusore\" all'avvio. 20220210: Il comando SYNC_STEPPER_TO_EXTRUDER \u00e8 deprecato; il comando SET_EXTRUDER_STEP_DISTANCE \u00e8 deprecato; l'opzione di configurazione extruder shared_heater \u00e8 deprecata. Queste funzionalit\u00e0 verranno rimosse nel prossimo futuro. Sostituisci SET_EXTRUDER_STEP_DISTANCE con SET_EXTRUDER_ROTATION_DISTANCE . Sostituisci SYNC_STEPPER_TO_EXTRUDER con SYNC_EXTRUDER_MOTION . Sostituisci le sezioni di configurazione dell'estrusore usando shared_heater con le sezioni di configurazione extruder_stepper e aggiorna le macro di attivazione per usare SYNC_EXTRUDER_MOTION . 20220116: Il codice di calcolo della run_current per tmc2130, tmc2208, tmc2209 e tmc2660 \u00e8 cambiato. Per alcune impostazioni di run_current i driver possono ora essere configurati in modo diverso. Questa nuova configurazione dovrebbe essere pi\u00f9 accurata, ma potrebbe invalidare la precedente ottimizzazione del driver tmc. 20211230: Gli script per ottimizzare l'input shaper ( scripts/calibrate_shaper.py e scripts/graph_accelerometer.py ) sono stati migrati per utilizzare Python3 per impostazione predefinita. Di conseguenza, gli utenti devono installare le versioni Python3 di determinati pacchetti (ad esempio sudo apt install python3-numpy python3-matplotlib ) per continuare a utilizzare questi script. Per maggiori dettagli, fare riferimento a Installazione del software . In alternativa, gli utenti possono forzare temporaneamente l'esecuzione di questi script in Python 2 chiamando esplicitamente l'interprete Python2 nella console: python2 ~/klipper/scripts/calibrate_shaper.py ... 20211110: Il sensore di temperatura \"NTC 100K beta 3950\" \u00e8 obsoleto. Questo sensore verr\u00e0 rimosso nel prossimo futuro. La maggior parte degli utenti trover\u00e0 il sensore di temperatura \"Generico 3950\" pi\u00f9 accurato. Per continuare a utilizzare la definizione precedente (in genere meno accurata), definire un termistore personalizzato con temperature1: 25 , resistance1: 100000 e beta: 3950 . 20211104: L'opzione \"step pulse duration\" in \"make menuconfig\" \u00e8 stata rimossa. La durata del passaggio predefinita per i driver TMC configurati in modalit\u00e0 UART o SPI \u00e8 ora di 100 ns. Una nuova impostazione step_pulse_duration nella sezione stepper config dovrebbe essere impostata per tutti gli stepper che necessitano di una durata dell'impulso personalizzata. 20211102: diverse funzionalit\u00e0 deprecate sono state rimosse. L'opzione stepper step_distance \u00e8 stata rimossa (obsoleta nel 20201222). L'alias del sensore rpi_temperature \u00e8 stato rimosso (obsoleto il 20210219). L'opzione mcu pin_map \u00e8 stata rimossa (deprecata su 20210325). La gcode_macro default_parameter_<name> e l'accesso macro ai parametri dei comandi diversi dalla pseudo-variabile params sono stati rimossi (deprecato in 20210503). L'opzione del riscaldatore pid_integral_max \u00e8 stata rimossa (obsoleta il 20210612). 20210929: Klipper v0.10.0 rilasciato. 20210903: Il valore predefinito smooth_time per i riscaldatori \u00e8 cambiato in 1 secondo (da 2 secondi). Per la maggior parte delle stampanti ci\u00f2 si tradurr\u00e0 in un controllo della temperatura pi\u00f9 stabile. 20210830: il nome adxl345 predefinito \u00e8 ora \"adxl345\". Il parametro CHIP predefinito per ACCELEROMETER_MEASURE e ACCELEROMETER_QUERY ora \u00e8 \"adxl345\". 20210830: il comando adxl345 ACCELEROMETER_MEASURE non supporta pi\u00f9 un parametro RATE. Per modificare la frequenza delle query, aggiornare il file printer.cfg ed eseguire un comando RESTART. 20210821: Diverse impostazioni di configurazione in printer.configfile.settings verranno ora riportate come elenchi anzich\u00e9 come stringhe grezze. Se si desidera la stringa grezza effettiva, utilizzare invece printer.configfile.config . 20210819: In alcuni casi, un movimento di riferimento G28 pu\u00f2 terminare in una posizione che \u00e8 nominalmente al di fuori dell'intervallo di movimento valido. In rare situazioni ci\u00f2 pu\u00f2 causare errori di \"spostamento fuori portata\" confusi dopo l'homing. In tal caso, modificare gli script di avvio per spostare la testa utensile in una posizione valida subito dopo l'homing. 20210814: Gli pseudo-pin solo analogici su atmega168 e atmega328 sono stati rinominati da PE0/PE1 a PE2/PE3. 20210720: una sezione controller_fan ora monitora tutti i motori passo-passo per impostazione predefinita (non solo i motori passo-passo cinematici). Se si desidera il comportamento precedente, vedere l'opzione di configurazione stepper nel riferimento di configurazione . 20210703: Una sezione di configurazione samd_sercom deve ora specificare il bus sercom che sta configurando tramite l'opzione sercom . 20210612: L'opzione di configurazione pid_integral_max nelle sezioni riscaldatore e temperature_fan \u00e8 obsoleta. L'opzione verr\u00e0 rimossa nel prossimo futuro. 20210503: The gcode_macro default_parameter_<name> config option is deprecated. Use the params pseudo-variable to access macro parameters. Other methods for accessing macro parameters will be removed in the near future. Most users can replace a default_parameter_NAME: VALUE config option with a line like the following in the start of the macro: {% set NAME = params.NAME|default(VALUE)|float %} . See the Command Templates document for examples. 20210430: il comando SET_VELOCITY_LIMIT (e M204) ora pu\u00f2 impostare una velocit\u00e0, un'accelerazione e una square_corner_velocity maggiori dei valori specificati nel file di configurazione. 20210325: il supporto per l'opzione di configurazione pin_map \u00e8 deprecato. Utilizzare il file sample-aliases.cfg per tradurre i nomi dei pin del microcontroller effettivi. L'opzione di configurazione pin_map verr\u00e0 rimossa nel prossimo futuro. 20210313: Il supporto di Klipper per i microcontrollori che comunicano con il bus CAN \u00e8 cambiato. Se si utilizza il bus CAN, \u00e8 necessario eseguire nuovamente il flashing di tutti i microcontrollori e la configurazione di Klipper deve essere aggiornata . 20210310: Il valore predefinito TMC2660 per driver_SFILT \u00e8 stato modificato da 1 a 0. 20210227: I driver del motore passo-passo TMC in modalit\u00e0 UART o SPI ora vengono interrogati una volta al secondo ogni volta che sono abilitati - se il driver non pu\u00f2 essere contattato o se il driver segnala un errore, Klipper passer\u00e0 allo stato di spegnimento. 20210219: Il modulo rpi_temperature \u00e8 stato rinominato in temperature_host . Sostituisci tutte le occorrenze di sensor_type: rpi_temperature con sensor_type: temperature_host . Il percorso del file di temperatura pu\u00f2 essere specificato nella variabile di configurazione sensor_path . Il nome rpi_temperature \u00e8 deprecato e verr\u00e0 rimosso nel prossimo futuro. 20210201: Il comando TEST_RESONANCES ora disabiliter\u00e0 l'input shaping se era stato precedentemente abilitato (e lo riattiver\u00e0 dopo il test). Per ignorare questo comportamento e mantenere abilitato lo shaping dell'input, \u00e8 possibile passare un parametro aggiuntivo INPUT_SHAPING=1 al comando. 20210201: Il comando ACCELEROMETER_MEASURE aggiunger\u00e0 ora il nome del chip dell'accelerometro al nome del file di output se al chip \u00e8 stato assegnato un nome nella corrispondente sezione adxl345 di printer.cfg. 20201222: L'impostazione step_distance nelle sezioni di configurazione dello stepper \u00e8 obsoleta. Si consiglia di aggiornare la configurazione per utilizzare l'impostazione rotation_distance . Il supporto per step_distance verr\u00e0 rimosso nel prossimo futuro. 20201218: L'impostazione endstop_phase nel modulo endstop_phase \u00e8 stata sostituita con trigger_phase . Se si utilizza il modulo fasi endstop, sar\u00e0 necessario convertire in rotation_distance e ricalibrare eventuali fasi endstop eseguendo il comando ENDSTOP_PHASE_CALIBRATE. 20201218: le stampanti rotanti delta e polari ora devono specificare un gear_ratio per i loro stepper rotanti e potrebbero non specificare pi\u00f9 un parametro step_distance . Vedere il riferimento di configurazione per il formato del nuovo parametro gear_ratio. 20201213: Non \u00e8 valido specificare una Z \"position_endstop\" quando si utilizza \"probe:z_virtual_endstop\". Verr\u00e0 ora generato un errore se viene specificata una Z \"position_endstop\" con \"probe:z_virtual_endstop\". Rimuovere la definizione Z \"position_endstop\" per correggere l'errore. 20201120: La sezione di configurazione [board_pins] ora specifica il nome mcu in un parametro esplicito mcu: . Se si utilizza board_pins per un mcu secondario, \u00e8 necessario aggiornare la configurazione per specificare quel nome. Vedere il riferimento di configurazione per ulteriori dettagli. 20201112: Il tempo riportato da print_stats.print_duration \u00e8 cambiato. La durata precedente alla prima estrusione rilevata \u00e8 ora esclusa. 20201029: L'opzione di configurazione color_order_GRB di neopixel \u00e8 stata rimossa. Se necessario, aggiorna la configurazione per impostare la nuova opzione color_order su RGB, GRB, RGBW o GRBW. 20201029: L'opzione seriale nella sezione di configurazione di mcu non \u00e8 pi\u00f9 impostata su /dev/ttyS0. Nella rara situazione in cui /dev/ttyS0 \u00e8 la porta seriale desiderata, deve essere specificata esplicitamente. 20201020: Klipper v0.9.0 rilasciato. 20200902: Il calcolo della resistenza-to-temperatura dell'RTD per i convertitori MAX31865 \u00e8 stato corretto in modo che non fosse basso. Se si utilizza un dispositivo di questo tipo, \u00e8 necessario ricalibrare la temperatura di stampa e le impostazioni PID. 20200816: L'oggetto printer.gcode della macro gcode \u00e8 stato rinominato in printer.gcode_move . Diverse variabili non documentate in printer.toolhead e printer.gcode sono state rimosse. Vedere docs/Command_Templates.md per un elenco delle variabili di modello disponibili. 20200816: Il sistema \"action_\" della macro gcode \u00e8 cambiato. Sostituisci tutte le chiamate a printer.gcode.action_emergency_stop() con action_emergency_stop() , printer.gcode.action_respond_info() con action_respond_info() e printer.gcode.action_respond_error() con action_raise_error( ) . 20200809: Il sistema di menu \u00e8 stato riscritto. Se il menu \u00e8 stato personalizzato sar\u00e0 necessario aggiornare alla nuova configurazione. Vedere config/example-menu.cfg per i dettagli di configurazione e vedere klippy/extras/display/menu.cfg per esempi. 20200731: Il comportamento dell'attributo progress riportato dall'oggetto stampante virtual_sdcard \u00e8 cambiato. L'avanzamento non viene pi\u00f9 reimpostato su 0 quando una stampa viene sospesa. Ora riporter\u00e0 sempre lo stato di avanzamento in base alla posizione interna del file o 0 se nessun file \u00e8 attualmente caricato. 20200725: Il parametro di configurazione servo enable e il parametro SET_SERVO ENABLE sono stati rimossi. Aggiorna qualsiasi macro per usare SET_SERVO SERVO=my_servo WIDTH=0 per disabilitare un servo. 20200608: Il supporto del display LCD ha cambiato il nome di alcuni \"glifi\" interni. Se \u00e8 stato implementato un layout di visualizzazione personalizzato, potrebbe essere necessario aggiornare ai nomi dei glifi pi\u00f9 recenti (consultare klippy/extras/display/display.cfg per un elenco dei glifi disponibili). 20200606: i nomi dei pin su Linux Mcu sono cambiati. I pin ora hanno nomi nella forma gpiochip<chipid>/gpio<gpio> . Per gpiochip0 puoi anche usare un breve gpio<gpio> . Ad esempio, ci\u00f2 che prima veniva chiamato P20 ora diventa gpio20 o gpiochip0/gpio20 . 20200603: il layout LCD 16x4 predefinito non mostrer\u00e0 pi\u00f9 il tempo rimanente stimato in una stampa. (Verr\u00e0 mostrato solo il tempo trascorso.) Se si desidera il vecchio comportamento, \u00e8 possibile personalizzare la visualizzazione del menu con tali informazioni (vedere la descrizione di display_data in config/example-extras.cfg per i dettagli). 20200531: l'ID prodotto/fornitore USB predefinito \u00e8 ora 0x1d50/0x614e. Questi nuovi ID sono riservati a Klipper (grazie al progetto openmoko). Questa modifica non dovrebbe richiedere alcuna modifica alla configurazione, ma i nuovi ID potrebbero essere visualizzati nei registri di sistema. 20200524: Il valore predefinito per il campo tmc5160 pwm_freq \u00e8 ora zero (anzich\u00e9 uno). 20200425: La variabile del modello di comando gcode_macro printer.heater \u00e8 stata rinominata printer.heaters . 20200313: Il layout lcd predefinito per le stampanti multiestrusore con schermo 16x4 \u00e8 cambiato. Il layout dello schermo del singolo estrusore \u00e8 ora quello predefinito e mostrer\u00e0 l'estrusore attualmente attivo. Per utilizzare il layout di visualizzazione precedente, impostare \"display_group: _multiextruder_16x4\" nella sezione [display] del file printer.cfg. 20200308: La voce di menu predefinita __test \u00e8 stata rimossa. Se il file di configurazione ha un menu personalizzato, assicurati di rimuovere tutti i riferimenti a questa voce di menu __test . 20200308: le opzioni del menu \"deck\" e \"card\" sono state rimosse. Per personalizzare il layout di uno schermo lcd utilizzare le nuove sezioni display_data config (vedi config/example-extras.cfg per i dettagli). 20200109: Il modulo bed_mesh ora fa riferimento alla posizione della sonda per la configurazione della mesh. Pertanto, alcune opzioni di configurazione sono state rinominate per riflettere in modo pi\u00f9 accurato la funzionalit\u00e0 prevista. Per i piatti rettangolari, min_point e max_point sono stati rinominati rispettivamente in mesh_min e mesh_max . Per i piatti rotondi, bed_radius \u00e8 stato rinominato in mesh_radius . \u00c8 stata aggiunta anche una nuova opzione mesh_origin per i piatti rotondi. Si noti che queste modifiche sono anche incompatibili con i profili mesh salvati in precedenza. Se viene rilevato un profilo incompatibile, verr\u00e0 ignorato e pianificato per la rimozione. Il processo di rimozione pu\u00f2 essere completato emettendo il comando SAVE_CONFIG. L'utente dovr\u00e0 ricalibrare ogni profilo. 20191218: la sezione di configurazione del display non supporta pi\u00f9 \"lcd_type: st7567\". Usa invece il tipo di visualizzazione \"uc1701\" - imposta \"lcd_type: uc1701\" e cambia \"rs_pin: some_pin\" in \"rst_pin: some_pin\". Potrebbe anche essere necessario aggiungere un'impostazione di configurazione \"contrasto: 60\". 20191210: I comandi integrati T0, T1, T2, ... sono stati rimossi. Le opzioni di configurazione activate_gcode e deactivate_gcode dell'estrusore sono state rimosse. Se questi comandi (e script) sono necessari, definire le singole macro di stile [gcode_macro T0] che chiamano il comando ACTIVATE_EXTRUDER. Vedere i file config/sample-idex.cfg e sample-multi-extruder.cfg per esempi. 20191210: il supporto per il comando M206 \u00e8 stato rimosso. Sostituisci con chiamate a SET_GCODE_OFFSET. Se \u00e8 necessario il supporto per M206, aggiungere una sezione di configurazione [gcode_macro M206] che richiami SET_GCODE_OFFSET. (Ad esempio \"SET_GCODE_OFFSET Z=-{params.Z}\".) 20191202: il supporto per il parametro \"S\" non documentato del comando \"G4\" \u00e8 stato rimosso. Sostituire eventuali occorrenze di S con il parametro \"P\" standard (il ritardo specificato in millisecondi). 20191126: i nomi USB sono cambiati sui microcontrollori con supporto USB nativo. Ora usano un ID chip univoco per impostazione predefinita (ove disponibile). Se una sezione di configurazione \"mcu\" utilizza un'impostazione \"serial\" che inizia con \"/dev/serial/by-id/\", potrebbe essere necessario aggiornare la configurazione. Esegui \"ls /dev/serial/by-id/*\" in un terminale ssh per determinare il nuovo ID. 20191121: il parametro pressure_advance_lookahead_time \u00e8 stato rimosso. Vedere example.cfg per impostazioni di configurazione alternative. 20191112: la funzionalit\u00e0 di abilitazione virtuale del driver stepper tmc \u00e8 ora abilitata automaticamente se lo stepper non dispone di un pin di abilitazione stepper dedicato. Rimuovere i riferimenti a tmcXXXX:virtual_enable dal file config. La possibilit\u00e0 di controllare pi\u00f9 pin nella configurazione stepper enable_pin \u00e8 stata rimossa. Se sono necessari pi\u00f9 pin, utilizzare una sezione di configurazione multi_pin. 20191107: La sezione di configurazione dell'estrusore primario deve essere specificata come \"extruder\" e non pu\u00f2 pi\u00f9 essere specificata come \"extruder0\". I modelli di comando Gcode che richiedono lo stato dell'estrusore sono ora accessibili tramite \"{printer.extruder}\". 20191021: Klipper v0.8.0 rilasciato 20191003: L'opzione move_to_previous in [safe_z_homing] ora \u00e8 impostata su False. (Era effettivamente Falso prima del 20190918.) 20190918: L'opzione zhop in [safe_z_homing] viene sempre riapplicata dopo il completamento dell'homing dell'asse Z. Ci\u00f2 potrebbe richiedere agli utenti di aggiornare gli script personalizzati basati su questo modulo. 20190806: Il comando SET_NEOPIXEL \u00e8 stato rinominato in SET_LED. 20190726: il codice del dac mcp4728 \u00e8 cambiato. L'indirizzo i2c predefinito \u00e8 ora 0x60 e il riferimento di tensione \u00e8 ora relativo al riferimento interno di 2,048 volt del mcp4728. 20190710: l'opzione z_hop \u00e8 stata rimossa dalla sezione di configurazione [firmware_retract]. Il supporto z_hop era incompleto e potrebbe causare un comportamento errato con diversi filtri dei dati comuni. 20190710: I parametri opzionali del comando PROBE_ACCURACY sono stati modificati. Potrebbe essere necessario aggiornare eventuali macro o script che utilizzano quel comando. 20190628: tutte le opzioni di configurazione sono state rimosse dalla sezione [skew_correction]. La configurazione per skew_correction viene ora eseguita tramite il gcode SET_SKEW. Vedere Correzione inclinazione per l'utilizzo consigliato. 20190607: I parametri \"variable_X\" di gcode_macro (insieme al parametro VALUE di SET_GCODE_VARIABLE) vengono ora analizzati come valori literals di Python. Se \u00e8 necessario assegnare un valore a una stringa, racchiudere il valore tra virgolette in modo che venga valutato come una stringa. 20190606: le opzioni di configurazione \"samples\", \"samples_result\" e \"sample_retract_dist\" sono state spostate nella sezione di configurazione \"probe\". Queste opzioni non sono pi\u00f9 supportate nelle sezioni di configurazione \"delta_calibrate\", \"bed_tilt\", \"bed_mesh\", \"screws_tilt_adjust\", \"z_tilt\" o \"quad_gantry_level\". 20190528: La variabile magica \"status\" nella valutazione del modello gcode_macro \u00e8 stata rinominata \"printer\". 20190520: Il comando SET_GCODE_OFFSET \u00e8 stato modificato; aggiorna tutte le macro del codice g di conseguenza. Il comando non applicher\u00e0 pi\u00f9 l'offset richiesto al successivo comando G1. Il vecchio comportamento pu\u00f2 essere approssimato utilizzando il nuovo parametro \"MOVE=1\". 20190404: i pacchetti software host Python sono stati aggiornati. Gli utenti dovranno eseguire nuovamente lo script ~/klipper/scripts/install-octopi.sh (o in altro modo aggiornare le dipendenze di Python se non si utilizza un'installazione OctoPi standard). 20190404: I parametri i2c_bus e spi_bus (in varie sezioni di configurazione) ora prendono un nome bus anzich\u00e9 un numero. 20190404: I parametri di configurazione sx1509 sono stati modificati. Il parametro 'address' ora \u00e8 'i2c_address' e deve essere specificato come numero decimale. Dove 0x3E \u00e8 stato utilizzato in precedenza, specificare 62. 20190328: Il valore min_speed nella configurazione [temperature_fan] verr\u00e0 ora rispettato e la ventola funzioner\u00e0 sempre a questa velocit\u00e0 o superiore in modalit\u00e0 PID. 20190322: il valore predefinito per \"driver_HEND\" nelle sezioni di configurazione [tmc2660] \u00e8 stato modificato da 6 a 3. Il campo \"driver_VSENSE\" \u00e8 stato rimosso (ora viene calcolato automaticamente da run_current). 20190310: La sezione di configurazione [controller_fan] ora prende sempre un nome (come [controller_fan my_controller_fan]). 20190308: Il campo \"driver_BLANK_TIME_SELECT\" nelle sezioni di configurazione [tmc2130] e [tmc2208] \u00e8 stato rinominato in \"driver_TBL\". 20190308: la sezione di configurazione [tmc2660] \u00e8 stata modificata. Ora deve essere fornito un nuovo parametro di configurazione sense_resistor. Il significato di molti dei parametri driver_XXX \u00e8 cambiato. 20190228: gli utenti di SPI o I2C su schede SAMD21 devono ora specificare i pin del bus tramite una sezione di configurazione [samd_sercom]. 20190224: l'opzione bed_shape \u00e8 stata rimossa da bed_mesh. L'opzione raggio \u00e8 stata rinominata bed_radius. Gli utenti con letti rotondi dovrebbero fornire le opzioni bed_radius e round_probe_count. 20190107: il parametro i2c_address nella sezione di configurazione mcp4451 \u00e8 stato modificato. Questa \u00e8 un'impostazione comune su Smoothieboards. Il nuovo valore \u00e8 la met\u00e0 del vecchio valore (88 dovrebbe essere cambiato in 44 e 90 dovrebbe essere cambiato in 45). 20181220: Klipper v0.7.0 rilasciato","title":"Modifiche alla configurazione"},{"location":"Config_Changes.html#modifiche-alla-configurazione","text":"Questo documento copre le modifiche software recenti al file di configurazione che non sono compatibili con le versioni precedenti. \u00c8 una buona idea rivedere questo documento durante l'aggiornamento del software Klipper. Tutte le date in questo documento sono approssimative.","title":"Modifiche alla configurazione"},{"location":"Config_Changes.html#cambiamenti","text":"20241203: The resonance test has been changed to include slow sweeping moves. This change requires that testing point(s) have some clearance in X/Y plane (+/- 30 mm from the test point should suffice when using the default settings). The new test should generally produce more accurate and reliable test results. However, if required, the previous test behavior can be restored by adding options sweeping_period: 0 and accel_per_hz: 75 to the [resonance_tester] config section. 20241201: In some cases Klipper may have ignored leading characters or spaces in a traditional G-Code command. For example, \"99M123\" may have been interpreted as \"M123\" and \"M 321\" may have been interpreted as \"M321\". Klipper will now report these cases with an \"Unknown command\" warning. 20241112: Option CHIPS=<chip_name> in TEST_RESONANCES and SHAPER_CALIBRATE requires specifying the full name(s) of the accel chip(s). For example, adxl345 rpi instead of short name - rpi . 20240912: SET_PIN , SET_SERVO , SET_FAN_SPEED , M106 , and M107 commands are now collated. Previously, if many updates to the same object were issued faster than the minimum scheduling time (typically 100ms) then actual updates could be queued far into the future. Now if many updates are issued in rapid succession then it is possible that only the latest request will be applied. If the previous behavior is requried then consider adding explicit G4 delay commands between updates. 20240912: Support for maximum_mcu_duration and static_value parameters in [output_pin] config sections have been removed. These options have been deprecated since 20240123. 20240415: The on_error_gcode parameter in the [virtual_sdcard] config section now has a default. If this parameter is not specified it now defaults to TURN_OFF_HEATERS . If the previous behavior is desired (take no default action on an error during a virtual_sdcard print) then define on_error_gcode with an empty value. 20240313: The max_accel_to_decel parameter in the [printer] config section has been deprecated. The ACCEL_TO_DECEL parameter of the SET_VELOCITY_LIMIT command has been deprecated. The printer.toolhead.max_accel_to_decel status has been removed. Use the minimum_cruise_ratio parameter instead. The deprecated features will be removed in the near future, and using them in the interim may result in subtly different behavior. 20240215: Several deprecated features have been removed. Using \"NTC 100K beta 3950\" as a thermistor name has been removed (deprecated on 20211110). The SYNC_STEPPER_TO_EXTRUDER and SET_EXTRUDER_STEP_DISTANCE commands have been removed, and the extruder shared_heater config option has been removed (deprecated on 20220210). The bed_mesh relative_reference_index option has been removed (deprecated on 20230619). 20240123: The output_pin SET_PIN CYCLE_TIME parameter has been removed. Use the new pwm_cycle_time module if it is necessary to dynamically change a pwm pin's cycle time. 20240123: The output_pin maximum_mcu_duration parameter is deprecated. Use a pwm_tool config section instead. The option will be removed in the near future. 20240123: The output_pin static_value parameter is deprecated. Replace with value and shutdown_value parameters. The option will be removed in the near future. 20231216: The [hall_filament_width_sensor] is changed to trigger filament runout when the thickness of the filament exceeds max_diameter . The maximum diameter defaults to default_nominal_filament_diameter + max_difference . See [hall_filament_width_sensor] configuration reference for more details. 20231207: Several undocumented config parameters in the [printer] config section have been removed (the buffer_time_low, buffer_time_high, buffer_time_start, and move_flush_time parameters). 20231110: Klipper v0.12.0 released. 20230826: If safe_distance is set or calculated to be 0 in [dual_carriage] , the carriages proximity checks will be disabled as per documentation. A user may wish to configure safe_distance explicitly to prevent accidental crashes of the carriages with each other. Additionally, the homing order of the primary and the dual carriage is changed in some configurations (certain configurations when both carriages home in the same direction, see [dual_carriage] configuration reference for more details). 20230810: The flash-sdcard.sh script now supports both variants of the Bigtreetech SKR-3, STM32H743 and STM32H723. For this, the original tag of btt-skr-3 now has changed to be either btt-skr-3-h743 or btt-skr-3-h723. 20230729: The exported status for dual_carriage is changed. Instead of exporting mode and active_carriage , the individual modes for each carriage are exported as printer.dual_carriage.carriage_0 and printer.dual_carriage.carriage_1 . 20230619: The relative_reference_index option has been deprecated and superceded by the zero_reference_position option. Refer to the Bed Mesh Documentation for details on how to update the configuration. With this deprecation the RELATIVE_REFERENCE_INDEX is no longer available as a parameter for the BED_MESH_CALIBRATE gcode command. 20230530: The default canbus frequency in \"make menuconfig\" is now 1000000. If using canbus and using canbus with some other frequency is required, then be sure to select \"Enable extra low-level configuration options\" and specify the desired \"CAN bus speed\" in \"make menuconfig\" when compiling and flashing the micro-controller. 20230525: SHAPER_CALIBRATE command immediately applies input shaper parameters if [input_shaper] was enabled already. 20230407: The stalled_bytes counter in the log and in the printer.mcu.last_stats field has been renamed to upcoming_bytes . 20230323: On tmc5160 drivers multistep_filt is now enabled by default. Set driver_MULTISTEP_FILT: False in the tmc5160 config for the previous behavior. 20230304: Il comando SET_TMC_CURRENT ora regola correttamente il registro globalscaler per i driver che lo dispongono. Ci\u00f2 rimuove una limitazione per cui su tmc5160, le correnti non potevano essere aumentate con SET_TMC_CURRENT rispetto al valore run_current impostato nel file di configurazione. Tuttavia, questo ha un effetto collaterale: dopo aver eseguito SET_TMC_CURRENT , lo stepper deve essere tenuto fermo per >130 ms nel caso in cui venga utilizzato StealthChop2 in modo che la calibrazione AT#1 venga eseguita dal driver. 20230202: il formato delle informazioni sullo stato di printer.screws_tilt_adjust \u00e8 stato modificato. Le informazioni vengono ora memorizzate come dizionario delle viti con le misurazioni risultanti. Consulta il riferimento sullo stato per i dettagli. 20230201: Il modulo [bed_mesh] non carica pi\u00f9 il profilo default all'avvio. Si consiglia agli utenti che usano il profilo default di aggiungere BED_MESH_PROFILE LOAD=default alla loro macro START_PRINT (o alla configurazione \"Start G-Code\" del loro slicer quando applicabile). 20230103: Ora \u00e8 possibile con lo script flash-sdcard.sh eseguire il flashing di entrambe le varianti di Bigtreetech SKR-2, STM32F407 e STM32F429. Ci\u00f2 significa che il tag originale di btt-skr2 ora \u00e8 cambiato in btt-skr-2-f407 o btt-skr-2-f429. 20221128: rilascio di Klipper v0.11.0. 20221122: In precedenza, con safe_z_home, era possibile che z_hop dopo l'homing g28 andasse nella direzione z negativa. Ora, uno z_hop viene eseguito dopo g28 solo se risulta in un hop positivo, rispecchiando il comportamento dello z_hop che si verifica prima dell'homing g28. 20220616: in precedenza era possibile eseguire il flashing di un rp2040 in modalit\u00e0 bootloader eseguendo make flash FLASH_DEVICE=first . Il comando equivalente \u00e8 ora make flash FLASH_DEVICE=2e8a:0003 . 20220612: Il microcontrollore rp2040 ora ha una soluzione alternativa per l'errata USB \"rp2040-e5\". Ci\u00f2 dovrebbe rendere pi\u00f9 affidabili le connessioni USB iniziali. Tuttavia, potrebbe comportare un cambiamento nel comportamento del pin gpio15. \u00c8 improbabile che il cambiamento di comportamento di gpio15 sia evidente. 20220407: l'opzione di configurazione temperature_fan pid_integral_max \u00e8 stata rimossa (era deprecata su 20210612). 20220407: L'ordine dei colori predefinito per i LED pca9632 \u00e8 ora \"RGBW\". Aggiungi un'impostazione esplicita color_order: RBGW alla sezione di configurazione di pca9632 per ottenere il comportamento precedente. 20220330: Il formato delle informazioni di stato printer.neopixel.color_data per i moduli neopixel e dotstar \u00e8 cambiato. Le informazioni sono ora memorizzate come un elenco di elenchi di colori (invece di un elenco di dizionari). Per i dettagli, vedere il riferimento dello stato . 20220307: M73 non imposter\u00e0 pi\u00f9 l'avanzamento della stampa su 0 se manca P . 20220304: Non esiste pi\u00f9 un valore predefinito per il parametro extruder delle sezioni di configurazione extruder_stepper . Se lo si desidera, specificare esplicitamente extruder: extruder per associare il motore passo-passo alla coda di movimento \"estrusore\" all'avvio. 20220210: Il comando SYNC_STEPPER_TO_EXTRUDER \u00e8 deprecato; il comando SET_EXTRUDER_STEP_DISTANCE \u00e8 deprecato; l'opzione di configurazione extruder shared_heater \u00e8 deprecata. Queste funzionalit\u00e0 verranno rimosse nel prossimo futuro. Sostituisci SET_EXTRUDER_STEP_DISTANCE con SET_EXTRUDER_ROTATION_DISTANCE . Sostituisci SYNC_STEPPER_TO_EXTRUDER con SYNC_EXTRUDER_MOTION . Sostituisci le sezioni di configurazione dell'estrusore usando shared_heater con le sezioni di configurazione extruder_stepper e aggiorna le macro di attivazione per usare SYNC_EXTRUDER_MOTION . 20220116: Il codice di calcolo della run_current per tmc2130, tmc2208, tmc2209 e tmc2660 \u00e8 cambiato. Per alcune impostazioni di run_current i driver possono ora essere configurati in modo diverso. Questa nuova configurazione dovrebbe essere pi\u00f9 accurata, ma potrebbe invalidare la precedente ottimizzazione del driver tmc. 20211230: Gli script per ottimizzare l'input shaper ( scripts/calibrate_shaper.py e scripts/graph_accelerometer.py ) sono stati migrati per utilizzare Python3 per impostazione predefinita. Di conseguenza, gli utenti devono installare le versioni Python3 di determinati pacchetti (ad esempio sudo apt install python3-numpy python3-matplotlib ) per continuare a utilizzare questi script. Per maggiori dettagli, fare riferimento a Installazione del software . In alternativa, gli utenti possono forzare temporaneamente l'esecuzione di questi script in Python 2 chiamando esplicitamente l'interprete Python2 nella console: python2 ~/klipper/scripts/calibrate_shaper.py ... 20211110: Il sensore di temperatura \"NTC 100K beta 3950\" \u00e8 obsoleto. Questo sensore verr\u00e0 rimosso nel prossimo futuro. La maggior parte degli utenti trover\u00e0 il sensore di temperatura \"Generico 3950\" pi\u00f9 accurato. Per continuare a utilizzare la definizione precedente (in genere meno accurata), definire un termistore personalizzato con temperature1: 25 , resistance1: 100000 e beta: 3950 . 20211104: L'opzione \"step pulse duration\" in \"make menuconfig\" \u00e8 stata rimossa. La durata del passaggio predefinita per i driver TMC configurati in modalit\u00e0 UART o SPI \u00e8 ora di 100 ns. Una nuova impostazione step_pulse_duration nella sezione stepper config dovrebbe essere impostata per tutti gli stepper che necessitano di una durata dell'impulso personalizzata. 20211102: diverse funzionalit\u00e0 deprecate sono state rimosse. L'opzione stepper step_distance \u00e8 stata rimossa (obsoleta nel 20201222). L'alias del sensore rpi_temperature \u00e8 stato rimosso (obsoleto il 20210219). L'opzione mcu pin_map \u00e8 stata rimossa (deprecata su 20210325). La gcode_macro default_parameter_<name> e l'accesso macro ai parametri dei comandi diversi dalla pseudo-variabile params sono stati rimossi (deprecato in 20210503). L'opzione del riscaldatore pid_integral_max \u00e8 stata rimossa (obsoleta il 20210612). 20210929: Klipper v0.10.0 rilasciato. 20210903: Il valore predefinito smooth_time per i riscaldatori \u00e8 cambiato in 1 secondo (da 2 secondi). Per la maggior parte delle stampanti ci\u00f2 si tradurr\u00e0 in un controllo della temperatura pi\u00f9 stabile. 20210830: il nome adxl345 predefinito \u00e8 ora \"adxl345\". Il parametro CHIP predefinito per ACCELEROMETER_MEASURE e ACCELEROMETER_QUERY ora \u00e8 \"adxl345\". 20210830: il comando adxl345 ACCELEROMETER_MEASURE non supporta pi\u00f9 un parametro RATE. Per modificare la frequenza delle query, aggiornare il file printer.cfg ed eseguire un comando RESTART. 20210821: Diverse impostazioni di configurazione in printer.configfile.settings verranno ora riportate come elenchi anzich\u00e9 come stringhe grezze. Se si desidera la stringa grezza effettiva, utilizzare invece printer.configfile.config . 20210819: In alcuni casi, un movimento di riferimento G28 pu\u00f2 terminare in una posizione che \u00e8 nominalmente al di fuori dell'intervallo di movimento valido. In rare situazioni ci\u00f2 pu\u00f2 causare errori di \"spostamento fuori portata\" confusi dopo l'homing. In tal caso, modificare gli script di avvio per spostare la testa utensile in una posizione valida subito dopo l'homing. 20210814: Gli pseudo-pin solo analogici su atmega168 e atmega328 sono stati rinominati da PE0/PE1 a PE2/PE3. 20210720: una sezione controller_fan ora monitora tutti i motori passo-passo per impostazione predefinita (non solo i motori passo-passo cinematici). Se si desidera il comportamento precedente, vedere l'opzione di configurazione stepper nel riferimento di configurazione . 20210703: Una sezione di configurazione samd_sercom deve ora specificare il bus sercom che sta configurando tramite l'opzione sercom . 20210612: L'opzione di configurazione pid_integral_max nelle sezioni riscaldatore e temperature_fan \u00e8 obsoleta. L'opzione verr\u00e0 rimossa nel prossimo futuro. 20210503: The gcode_macro default_parameter_<name> config option is deprecated. Use the params pseudo-variable to access macro parameters. Other methods for accessing macro parameters will be removed in the near future. Most users can replace a default_parameter_NAME: VALUE config option with a line like the following in the start of the macro: {% set NAME = params.NAME|default(VALUE)|float %} . See the Command Templates document for examples. 20210430: il comando SET_VELOCITY_LIMIT (e M204) ora pu\u00f2 impostare una velocit\u00e0, un'accelerazione e una square_corner_velocity maggiori dei valori specificati nel file di configurazione. 20210325: il supporto per l'opzione di configurazione pin_map \u00e8 deprecato. Utilizzare il file sample-aliases.cfg per tradurre i nomi dei pin del microcontroller effettivi. L'opzione di configurazione pin_map verr\u00e0 rimossa nel prossimo futuro. 20210313: Il supporto di Klipper per i microcontrollori che comunicano con il bus CAN \u00e8 cambiato. Se si utilizza il bus CAN, \u00e8 necessario eseguire nuovamente il flashing di tutti i microcontrollori e la configurazione di Klipper deve essere aggiornata . 20210310: Il valore predefinito TMC2660 per driver_SFILT \u00e8 stato modificato da 1 a 0. 20210227: I driver del motore passo-passo TMC in modalit\u00e0 UART o SPI ora vengono interrogati una volta al secondo ogni volta che sono abilitati - se il driver non pu\u00f2 essere contattato o se il driver segnala un errore, Klipper passer\u00e0 allo stato di spegnimento. 20210219: Il modulo rpi_temperature \u00e8 stato rinominato in temperature_host . Sostituisci tutte le occorrenze di sensor_type: rpi_temperature con sensor_type: temperature_host . Il percorso del file di temperatura pu\u00f2 essere specificato nella variabile di configurazione sensor_path . Il nome rpi_temperature \u00e8 deprecato e verr\u00e0 rimosso nel prossimo futuro. 20210201: Il comando TEST_RESONANCES ora disabiliter\u00e0 l'input shaping se era stato precedentemente abilitato (e lo riattiver\u00e0 dopo il test). Per ignorare questo comportamento e mantenere abilitato lo shaping dell'input, \u00e8 possibile passare un parametro aggiuntivo INPUT_SHAPING=1 al comando. 20210201: Il comando ACCELEROMETER_MEASURE aggiunger\u00e0 ora il nome del chip dell'accelerometro al nome del file di output se al chip \u00e8 stato assegnato un nome nella corrispondente sezione adxl345 di printer.cfg. 20201222: L'impostazione step_distance nelle sezioni di configurazione dello stepper \u00e8 obsoleta. Si consiglia di aggiornare la configurazione per utilizzare l'impostazione rotation_distance . Il supporto per step_distance verr\u00e0 rimosso nel prossimo futuro. 20201218: L'impostazione endstop_phase nel modulo endstop_phase \u00e8 stata sostituita con trigger_phase . Se si utilizza il modulo fasi endstop, sar\u00e0 necessario convertire in rotation_distance e ricalibrare eventuali fasi endstop eseguendo il comando ENDSTOP_PHASE_CALIBRATE. 20201218: le stampanti rotanti delta e polari ora devono specificare un gear_ratio per i loro stepper rotanti e potrebbero non specificare pi\u00f9 un parametro step_distance . Vedere il riferimento di configurazione per il formato del nuovo parametro gear_ratio. 20201213: Non \u00e8 valido specificare una Z \"position_endstop\" quando si utilizza \"probe:z_virtual_endstop\". Verr\u00e0 ora generato un errore se viene specificata una Z \"position_endstop\" con \"probe:z_virtual_endstop\". Rimuovere la definizione Z \"position_endstop\" per correggere l'errore. 20201120: La sezione di configurazione [board_pins] ora specifica il nome mcu in un parametro esplicito mcu: . Se si utilizza board_pins per un mcu secondario, \u00e8 necessario aggiornare la configurazione per specificare quel nome. Vedere il riferimento di configurazione per ulteriori dettagli. 20201112: Il tempo riportato da print_stats.print_duration \u00e8 cambiato. La durata precedente alla prima estrusione rilevata \u00e8 ora esclusa. 20201029: L'opzione di configurazione color_order_GRB di neopixel \u00e8 stata rimossa. Se necessario, aggiorna la configurazione per impostare la nuova opzione color_order su RGB, GRB, RGBW o GRBW. 20201029: L'opzione seriale nella sezione di configurazione di mcu non \u00e8 pi\u00f9 impostata su /dev/ttyS0. Nella rara situazione in cui /dev/ttyS0 \u00e8 la porta seriale desiderata, deve essere specificata esplicitamente. 20201020: Klipper v0.9.0 rilasciato. 20200902: Il calcolo della resistenza-to-temperatura dell'RTD per i convertitori MAX31865 \u00e8 stato corretto in modo che non fosse basso. Se si utilizza un dispositivo di questo tipo, \u00e8 necessario ricalibrare la temperatura di stampa e le impostazioni PID. 20200816: L'oggetto printer.gcode della macro gcode \u00e8 stato rinominato in printer.gcode_move . Diverse variabili non documentate in printer.toolhead e printer.gcode sono state rimosse. Vedere docs/Command_Templates.md per un elenco delle variabili di modello disponibili. 20200816: Il sistema \"action_\" della macro gcode \u00e8 cambiato. Sostituisci tutte le chiamate a printer.gcode.action_emergency_stop() con action_emergency_stop() , printer.gcode.action_respond_info() con action_respond_info() e printer.gcode.action_respond_error() con action_raise_error( ) . 20200809: Il sistema di menu \u00e8 stato riscritto. Se il menu \u00e8 stato personalizzato sar\u00e0 necessario aggiornare alla nuova configurazione. Vedere config/example-menu.cfg per i dettagli di configurazione e vedere klippy/extras/display/menu.cfg per esempi. 20200731: Il comportamento dell'attributo progress riportato dall'oggetto stampante virtual_sdcard \u00e8 cambiato. L'avanzamento non viene pi\u00f9 reimpostato su 0 quando una stampa viene sospesa. Ora riporter\u00e0 sempre lo stato di avanzamento in base alla posizione interna del file o 0 se nessun file \u00e8 attualmente caricato. 20200725: Il parametro di configurazione servo enable e il parametro SET_SERVO ENABLE sono stati rimossi. Aggiorna qualsiasi macro per usare SET_SERVO SERVO=my_servo WIDTH=0 per disabilitare un servo. 20200608: Il supporto del display LCD ha cambiato il nome di alcuni \"glifi\" interni. Se \u00e8 stato implementato un layout di visualizzazione personalizzato, potrebbe essere necessario aggiornare ai nomi dei glifi pi\u00f9 recenti (consultare klippy/extras/display/display.cfg per un elenco dei glifi disponibili). 20200606: i nomi dei pin su Linux Mcu sono cambiati. I pin ora hanno nomi nella forma gpiochip<chipid>/gpio<gpio> . Per gpiochip0 puoi anche usare un breve gpio<gpio> . Ad esempio, ci\u00f2 che prima veniva chiamato P20 ora diventa gpio20 o gpiochip0/gpio20 . 20200603: il layout LCD 16x4 predefinito non mostrer\u00e0 pi\u00f9 il tempo rimanente stimato in una stampa. (Verr\u00e0 mostrato solo il tempo trascorso.) Se si desidera il vecchio comportamento, \u00e8 possibile personalizzare la visualizzazione del menu con tali informazioni (vedere la descrizione di display_data in config/example-extras.cfg per i dettagli). 20200531: l'ID prodotto/fornitore USB predefinito \u00e8 ora 0x1d50/0x614e. Questi nuovi ID sono riservati a Klipper (grazie al progetto openmoko). Questa modifica non dovrebbe richiedere alcuna modifica alla configurazione, ma i nuovi ID potrebbero essere visualizzati nei registri di sistema. 20200524: Il valore predefinito per il campo tmc5160 pwm_freq \u00e8 ora zero (anzich\u00e9 uno). 20200425: La variabile del modello di comando gcode_macro printer.heater \u00e8 stata rinominata printer.heaters . 20200313: Il layout lcd predefinito per le stampanti multiestrusore con schermo 16x4 \u00e8 cambiato. Il layout dello schermo del singolo estrusore \u00e8 ora quello predefinito e mostrer\u00e0 l'estrusore attualmente attivo. Per utilizzare il layout di visualizzazione precedente, impostare \"display_group: _multiextruder_16x4\" nella sezione [display] del file printer.cfg. 20200308: La voce di menu predefinita __test \u00e8 stata rimossa. Se il file di configurazione ha un menu personalizzato, assicurati di rimuovere tutti i riferimenti a questa voce di menu __test . 20200308: le opzioni del menu \"deck\" e \"card\" sono state rimosse. Per personalizzare il layout di uno schermo lcd utilizzare le nuove sezioni display_data config (vedi config/example-extras.cfg per i dettagli). 20200109: Il modulo bed_mesh ora fa riferimento alla posizione della sonda per la configurazione della mesh. Pertanto, alcune opzioni di configurazione sono state rinominate per riflettere in modo pi\u00f9 accurato la funzionalit\u00e0 prevista. Per i piatti rettangolari, min_point e max_point sono stati rinominati rispettivamente in mesh_min e mesh_max . Per i piatti rotondi, bed_radius \u00e8 stato rinominato in mesh_radius . \u00c8 stata aggiunta anche una nuova opzione mesh_origin per i piatti rotondi. Si noti che queste modifiche sono anche incompatibili con i profili mesh salvati in precedenza. Se viene rilevato un profilo incompatibile, verr\u00e0 ignorato e pianificato per la rimozione. Il processo di rimozione pu\u00f2 essere completato emettendo il comando SAVE_CONFIG. L'utente dovr\u00e0 ricalibrare ogni profilo. 20191218: la sezione di configurazione del display non supporta pi\u00f9 \"lcd_type: st7567\". Usa invece il tipo di visualizzazione \"uc1701\" - imposta \"lcd_type: uc1701\" e cambia \"rs_pin: some_pin\" in \"rst_pin: some_pin\". Potrebbe anche essere necessario aggiungere un'impostazione di configurazione \"contrasto: 60\". 20191210: I comandi integrati T0, T1, T2, ... sono stati rimossi. Le opzioni di configurazione activate_gcode e deactivate_gcode dell'estrusore sono state rimosse. Se questi comandi (e script) sono necessari, definire le singole macro di stile [gcode_macro T0] che chiamano il comando ACTIVATE_EXTRUDER. Vedere i file config/sample-idex.cfg e sample-multi-extruder.cfg per esempi. 20191210: il supporto per il comando M206 \u00e8 stato rimosso. Sostituisci con chiamate a SET_GCODE_OFFSET. Se \u00e8 necessario il supporto per M206, aggiungere una sezione di configurazione [gcode_macro M206] che richiami SET_GCODE_OFFSET. (Ad esempio \"SET_GCODE_OFFSET Z=-{params.Z}\".) 20191202: il supporto per il parametro \"S\" non documentato del comando \"G4\" \u00e8 stato rimosso. Sostituire eventuali occorrenze di S con il parametro \"P\" standard (il ritardo specificato in millisecondi). 20191126: i nomi USB sono cambiati sui microcontrollori con supporto USB nativo. Ora usano un ID chip univoco per impostazione predefinita (ove disponibile). Se una sezione di configurazione \"mcu\" utilizza un'impostazione \"serial\" che inizia con \"/dev/serial/by-id/\", potrebbe essere necessario aggiornare la configurazione. Esegui \"ls /dev/serial/by-id/*\" in un terminale ssh per determinare il nuovo ID. 20191121: il parametro pressure_advance_lookahead_time \u00e8 stato rimosso. Vedere example.cfg per impostazioni di configurazione alternative. 20191112: la funzionalit\u00e0 di abilitazione virtuale del driver stepper tmc \u00e8 ora abilitata automaticamente se lo stepper non dispone di un pin di abilitazione stepper dedicato. Rimuovere i riferimenti a tmcXXXX:virtual_enable dal file config. La possibilit\u00e0 di controllare pi\u00f9 pin nella configurazione stepper enable_pin \u00e8 stata rimossa. Se sono necessari pi\u00f9 pin, utilizzare una sezione di configurazione multi_pin. 20191107: La sezione di configurazione dell'estrusore primario deve essere specificata come \"extruder\" e non pu\u00f2 pi\u00f9 essere specificata come \"extruder0\". I modelli di comando Gcode che richiedono lo stato dell'estrusore sono ora accessibili tramite \"{printer.extruder}\". 20191021: Klipper v0.8.0 rilasciato 20191003: L'opzione move_to_previous in [safe_z_homing] ora \u00e8 impostata su False. (Era effettivamente Falso prima del 20190918.) 20190918: L'opzione zhop in [safe_z_homing] viene sempre riapplicata dopo il completamento dell'homing dell'asse Z. Ci\u00f2 potrebbe richiedere agli utenti di aggiornare gli script personalizzati basati su questo modulo. 20190806: Il comando SET_NEOPIXEL \u00e8 stato rinominato in SET_LED. 20190726: il codice del dac mcp4728 \u00e8 cambiato. L'indirizzo i2c predefinito \u00e8 ora 0x60 e il riferimento di tensione \u00e8 ora relativo al riferimento interno di 2,048 volt del mcp4728. 20190710: l'opzione z_hop \u00e8 stata rimossa dalla sezione di configurazione [firmware_retract]. Il supporto z_hop era incompleto e potrebbe causare un comportamento errato con diversi filtri dei dati comuni. 20190710: I parametri opzionali del comando PROBE_ACCURACY sono stati modificati. Potrebbe essere necessario aggiornare eventuali macro o script che utilizzano quel comando. 20190628: tutte le opzioni di configurazione sono state rimosse dalla sezione [skew_correction]. La configurazione per skew_correction viene ora eseguita tramite il gcode SET_SKEW. Vedere Correzione inclinazione per l'utilizzo consigliato. 20190607: I parametri \"variable_X\" di gcode_macro (insieme al parametro VALUE di SET_GCODE_VARIABLE) vengono ora analizzati come valori literals di Python. Se \u00e8 necessario assegnare un valore a una stringa, racchiudere il valore tra virgolette in modo che venga valutato come una stringa. 20190606: le opzioni di configurazione \"samples\", \"samples_result\" e \"sample_retract_dist\" sono state spostate nella sezione di configurazione \"probe\". Queste opzioni non sono pi\u00f9 supportate nelle sezioni di configurazione \"delta_calibrate\", \"bed_tilt\", \"bed_mesh\", \"screws_tilt_adjust\", \"z_tilt\" o \"quad_gantry_level\". 20190528: La variabile magica \"status\" nella valutazione del modello gcode_macro \u00e8 stata rinominata \"printer\". 20190520: Il comando SET_GCODE_OFFSET \u00e8 stato modificato; aggiorna tutte le macro del codice g di conseguenza. Il comando non applicher\u00e0 pi\u00f9 l'offset richiesto al successivo comando G1. Il vecchio comportamento pu\u00f2 essere approssimato utilizzando il nuovo parametro \"MOVE=1\". 20190404: i pacchetti software host Python sono stati aggiornati. Gli utenti dovranno eseguire nuovamente lo script ~/klipper/scripts/install-octopi.sh (o in altro modo aggiornare le dipendenze di Python se non si utilizza un'installazione OctoPi standard). 20190404: I parametri i2c_bus e spi_bus (in varie sezioni di configurazione) ora prendono un nome bus anzich\u00e9 un numero. 20190404: I parametri di configurazione sx1509 sono stati modificati. Il parametro 'address' ora \u00e8 'i2c_address' e deve essere specificato come numero decimale. Dove 0x3E \u00e8 stato utilizzato in precedenza, specificare 62. 20190328: Il valore min_speed nella configurazione [temperature_fan] verr\u00e0 ora rispettato e la ventola funzioner\u00e0 sempre a questa velocit\u00e0 o superiore in modalit\u00e0 PID. 20190322: il valore predefinito per \"driver_HEND\" nelle sezioni di configurazione [tmc2660] \u00e8 stato modificato da 6 a 3. Il campo \"driver_VSENSE\" \u00e8 stato rimosso (ora viene calcolato automaticamente da run_current). 20190310: La sezione di configurazione [controller_fan] ora prende sempre un nome (come [controller_fan my_controller_fan]). 20190308: Il campo \"driver_BLANK_TIME_SELECT\" nelle sezioni di configurazione [tmc2130] e [tmc2208] \u00e8 stato rinominato in \"driver_TBL\". 20190308: la sezione di configurazione [tmc2660] \u00e8 stata modificata. Ora deve essere fornito un nuovo parametro di configurazione sense_resistor. Il significato di molti dei parametri driver_XXX \u00e8 cambiato. 20190228: gli utenti di SPI o I2C su schede SAMD21 devono ora specificare i pin del bus tramite una sezione di configurazione [samd_sercom]. 20190224: l'opzione bed_shape \u00e8 stata rimossa da bed_mesh. L'opzione raggio \u00e8 stata rinominata bed_radius. Gli utenti con letti rotondi dovrebbero fornire le opzioni bed_radius e round_probe_count. 20190107: il parametro i2c_address nella sezione di configurazione mcp4451 \u00e8 stato modificato. Questa \u00e8 un'impostazione comune su Smoothieboards. Il nuovo valore \u00e8 la met\u00e0 del vecchio valore (88 dovrebbe essere cambiato in 44 e 90 dovrebbe essere cambiato in 45). 20181220: Klipper v0.7.0 rilasciato","title":"Cambiamenti"},{"location":"Config_Reference.html","text":"Riferimenti configurazione \u00b6 Questo documento \u00e8 un riferimento per le opzioni disponibili nel file di configurazione di Klipper. Le descrizioni in questo documento sono formattate in modo che sia possibile tagliarle e incollarle in un file di configurazione della stampante. Consulta il documento di installazione per informazioni sulla configurazione di Klipper e sulla scelta di un file di configurazione iniziale. Configurazione del microcontrollore \u00b6 Formato dei nomi dei pin del microcontrollore \u00b6 Molte opzioni di configurazione richiedono il nome di un pin del microcontrollore. Klipper usa i nomi hardware per questi pin, ad esempio \"PA4\". I nomi dei pin possono essere preceduti da ! per indicare che deve essere utilizzata una polarit\u00e0 inversa (ad esempio, trigger su basso anzich\u00e9 alto). I pin di input possono essere preceduti da ^ per indicare che un resistore di pull-up hardware deve essere abilitato per il pin. Se il microcontrollore supporta resistori pull-down, un pin di ingresso pu\u00f2 in alternativa essere preceduto da ~ . Nota, alcune sezioni di configurazione potrebbero \"creare\" pin aggiuntivi. Quando ci\u00f2 si verifica, la sezione di configurazione che definisce i pin deve essere elencata nel file di configurazione prima di qualsiasi sezione che utilizza tali pin. [mcu] \u00b6 Configurazione del microcontrollore primario. [mcu] serial: # La porta seriale per la connessione all'MCU. In caso di dubbi (o se # cambia) vedere \"Dov'\u00e8 la mia porta seriale?\" sezione delle FAQ. # Questo parametro deve essere fornito quando si utilizza una # porta seriale. #baud: 250000 # La velocit\u00e0 di trasmissione da utilizzare. Il valore predefinito \u00e8 250000. #canbus_uuid: # Se si utilizza un dispositivo collegato a un bus CAN, questo imposta # l'identificatore univoco del chip a cui connettersi. Questo valore deve # essere fornito quando si utilizza il bus CAN per la comunicazione. #canbus_interface: # Se si utilizza un dispositivo collegato a un bus CAN, viene impostata # l'interfaccia di rete CAN da utilizzare. L'impostazione predefinita \u00e8 'can0'. #restart_method: # Questo controlla il meccanismo che l'host utilizzer\u00e0 per reimpostare # il microcontrollore. Le scelte sono \"arduino\", \"cheetah\", \"rpi_usb\" e # \"command\". Il metodo 'arduino' (attiva/disattiva DTR) \u00e8 comune su # schede Arduino e cloni. Il metodo 'cheetah' \u00e8 un metodo speciale # necessario per alcune schede Fysetc Cheetah. Il metodo \"rpi_usb\" # \u00e8 utile sulle schede Raspberry Pi con microcontrollori alimentati # tramite USB: disabilita brevemente l'alimentazione a tutte le porte # USB per eseguire un ripristino del microcontrollore. Il metodo # \"comando\" prevede l'invio di un comando Klipper al microcontrollore # in modo che possa reimpostarsi. L'impostazione predefinita \u00e8 # 'arduino' se il microcontrollore comunica su una porta seriale, # altrimenti 'comando'. [mcu my_extra_mcu] \u00b6 Microcontrollori aggiuntivi (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"mcu\"). Microcontrollori aggiuntivi introducono pin aggiuntivi che possono essere configurati come riscaldatori, stepper, ventole, ecc. Ad esempio, se viene introdotta una sezione \"[mcu extra_mcu]\", i pin come \"extra_mcu:ar9\" possono quindi essere utilizzati altrove nella configurazione (dove \"ar9\" \u00e8 un nome pin hardware o un nome alias sul dato mcu). [mcu my_extra_mcu] # Vedere la sezione \"mcu\" per i parametri di configurazione. Impostazioni cinematiche comuni \u00b6 [printer] \u00b6 La sezione printer controlla le impostazioni di alto livello della stampante. [printer] kinematics: # The type of printer in use. This option may be one of: cartesian, # corexy, corexz, hybrid_corexy, hybrid_corexz, rotary_delta, delta, # deltesian, polar, winch, or none. This parameter must be specified. max_velocity: # Maximum velocity (in mm/s) of the toolhead (relative to the # print). This parameter must be specified. max_accel: # Maximum acceleration (in mm/s^2) of the toolhead (relative to the # print). Although this parameter is described as a \"maximum\" # acceleration, in practice most moves that accelerate or decelerate # will do so at the rate specified here. The value specified here # may be changed at runtime using the SET_VELOCITY_LIMIT command. # This parameter must be specified. #minimum_cruise_ratio: 0.5 # Most moves will accelerate to a cruising speed, travel at that # cruising speed, and then decelerate. However, some moves that # travel a short distance could nominally accelerate and then # immediately decelerate. This option reduces the top speed of these # moves to ensure there is always a minimum distance traveled at a # cruising speed. That is, it enforces a minimum distance traveled # at cruising speed relative to the total distance traveled. It is # intended to reduce the top speed of short zigzag moves (and thus # reduce printer vibration from these moves). For example, a # minimum_cruise_ratio of 0.5 would ensure that a standalone 1.5mm # move would have a minimum cruising distance of 0.75mm. Specify a # ratio of 0.0 to disable this feature (there would be no minimum # cruising distance enforced between acceleration and deceleration). # The value specified here may be changed at runtime using the # SET_VELOCITY_LIMIT command. The default is 0.5. #square_corner_velocity: 5.0 # The maximum velocity (in mm/s) that the toolhead may travel a 90 # degree corner at. A non-zero value can reduce changes in extruder # flow rates by enabling instantaneous velocity changes of the # toolhead during cornering. This value configures the internal # centripetal velocity cornering algorithm; corners with angles # larger than 90 degrees will have a higher cornering velocity while # corners with angles less than 90 degrees will have a lower # cornering velocity. If this is set to zero then the toolhead will # decelerate to zero at each corner. The value specified here may be # changed at runtime using the SET_VELOCITY_LIMIT command. The # default is 5mm/s. #max_accel_to_decel: # This parameter is deprecated and should no longer be used. [stepper] \u00b6 Definizioni di motori passo-passo. Diversi tipi di stampante (come specificato dall'opzione \"cinematica\" nella sezione di configurazione [stampante]) richiedono nomi diversi per lo stepper (ad esempio, stepper_x vs stepper_a ). Di seguito sono riportate le definizioni comuni di stepper. Vedere il documento distanza di rotazione per informazioni sul calcolo del parametro rotation_distance . Consultare il documento Multi-MCU homing per informazioni sull'homing utilizzando pi\u00f9 microcontrollori. [stepper_x] step_pin: # Pin GPIO Step (attivato in alto) . Questo parametro deve essere fornito. dir_pin: # Pin GPIO di direzione (alto indica una direzione positiva). # Questo parametro deve essere fornito. enable_pin: # Pin GPIO di abilitazione (l'impostazione predefinita \u00e8 abilita alto; usa ! # per indicare abilita basso). Se questo parametro non viene fornito, il # driver del motore passo-passo deve essere sempre abilitato. rotation_distance: # Distanza (in mm) che l'asse percorre con una rotazione completa del # motore passo-passo (o viene specificata la marcia finale del rapporto di # trasmissione). Questo parametro deve essere fornito. microsteps: # Il numero di micropassi utilizzati dal driver del motore passo-passo. # Questo parametro deve essere fornito. #full_steps_per_rotation: 200 # Il numero di passi completi per una rotazione del motore passo-passo. # Impostarlo su 200 per un motore passo-passo da 1.8 gradi o su 400 per # un motore da 0.9 gradi. Il valore predefinito \u00e8 200. #gear_ratio: # Il rapporto di trasmissione se il motore passo-passo \u00e8 collegato all'asse # tramite un riduttore. Ad esempio, si pu\u00f2 specificare \"5:1\" se \u00e8 in uso un # riduttore 5 a 1. Se l'asse ha pi\u00f9 riduttori, \u00e8 possibile specificare un elenco # di rapporti di trasmissione separati da virgole (ad esempio, \"57:11, 2:1\"). # Se viene specificato gear_ratio, rotation_distance specifica la distanza # percorsa dall'asse per una rotazione completa dell'ingranaggio finale. # L'impostazione predefinita \u00e8 di non utilizzare un rapporto di trasmissione. #step_pulse_duration: # Il tempo minimo tra il fronte del segnale dell'impulso del passo e il # successivo fronte del segnale \"non passo\". Viene utilizzato anche per # impostare il tempo minimo tra un impulso di passo e un segnale di cambio # di direzione. L'impostazione predefinita \u00e8 0.000000100 (100ns) per gli # stepper TMC configurati in modalit\u00e0 UART o SPI e l'impostazione # predefinita \u00e8 0.000002 (che \u00e8 2us) per tutti gli altri stepper. endstop_pin: # Pin di rilevamento interruttore di fine corsa. Se questo pin di fine corsa # si trova su un mcu diverso dal motore passo-passo, abilita il # \"homing multi-mcu\". Questo parametro deve essere fornito per gli # stepper X, Y e Z su stampanti in stile cartesiano. #position_min: 0 # Distanza minima valida (in mm) alla quale l'utente pu\u00f2 comandare # il movimento dello stepper. Il valore predefinito \u00e8 0 mm. position_endstop: # Posizione del finecorsa (in mm). Questo parametro deve essere fornito # per gli stepper X, Y e Z su stampanti in stile cartesiano. position_max: # Distanza massima valida (in mm) alla quale l'utente pu\u00f2 comandare lo # spostamento dello stepper. Questo parametro deve essere fornito per # gli stepper X, Y e Z su stampanti in stile cartesiano. #homing_speed: 5.0 # Velocit\u00e0 massima (in mm/s) dello stepper durante l'homing. # Il valore predefinito \u00e8 5 mm/s. #homing_retract_dist: 5.0 # Distanza dall'arretramento (in mm) prima della corsa di riferimento # una seconda volta durante la corsa di riferimento. Impostalo a zero per # disabilitare la seconda casa. Il valore predefinito \u00e8 5 mm. #homing_retract_speed: # Velocit\u00e0 da utilizzare nella corsa di ritorno dopo l'homing nel caso in # cui questa dovesse essere diversa dalla velocit\u00e0 di homing, che \u00e8 # l'impostazione predefinita per questo parametro #second_homing_speed: # Velocit\u00e0 (in mm/s) dello stepper durante l'esecuzione del secondo # homing. L'impostazione predefinita \u00e8 homing_speed/2. #homing_positive_dir: # Se true, l'homing far\u00e0 muovere lo stepper in una direzione positiva # (allontanandosi da zero); se falso, home verso zero. \u00c8 meglio utilizzare # l'impostazione predefinita piuttosto che specificare questo parametro. # Il valore predefinito \u00e8 true se position_endstop \u00e8 vicino a position_max # false se vicino a position_min. Cinematica cartesiana \u00b6 Vedere example-cartesian.cfg per un file di configurazione della cinematica cartesiana di esempio. Qui sono descritti solo i parametri specifici delle stampanti cartesiane - vedere impostazioni cinematiche comuni per i parametri disponibili. [printer] kinematics: cartesian max_z_velocity: # Imposta la velocit\u00e0 massima (in mm/s) di movimento lungo # l'asse z. Questa impostazione pu\u00f2 essere utilizzata per limitare # la velocit\u00e0 massima del motore passo-passo z. L'impostazione # predefinita \u00e8 utilizzare max_velocity per max_z_velocity. max_z_accel: # Imposta l'accelerazione massima (in mm/s^2) del movimento # lungo l'asse z. Limita l'accelerazione del motore passo-passo z. # L'impostazione predefinita \u00e8 utilizzare max_accel per max_z_accel. # La sezione stepper_x viene utilizzata per descrivere lo stepper # che controlla l'asse X in un robot cartesiano. [stepper_x] # La sezione stepper_y viene utilizzata per descrivere lo stepper # che controlla l'asse Y in un robot cartesiano. [stepper_y] # La sezione stepper_z viene utilizzata per descrivere lo stepper # che controlla l'asse Z in un robot cartesiano. [stepper_z] Cinematica Delta lineare \u00b6 Vedere example-delta.cfg per un file di configurazione della cinematica delta lineare di esempio. Consultare la guida alla calibrazione delta per informazioni sulla calibrazione. Qui vengono descritti solo i parametri specifici per le stampanti delta lineari - vedere impostazioni cinematiche comuni per i parametri disponibili. [printer] kinematics: delta max_z_velocity: # Per le stampanti delta questo limita la velocit\u00e0 massima (in mm/s) dei # movimenti con movimento dell'asse z. Questa impostazione pu\u00f2 essere # utilizzata per ridurre la velocit\u00e0 massima dei movimenti su/gi\u00f9 (che # richiedono una velocit\u00e0 di incremento maggiore rispetto ad altri # movimenti su una stampante delta). L'impostazione predefinita \u00e8 # utilizzare max_velocity per max_z_velocity. #max_z_accel: # Imposta l'accelerazione massima (in mm/s^2) del movimento lungo # l'asse z. L'impostazione pu\u00f2 essere utile se la stampante pu\u00f2 # raggiungere un'accelerazione maggiore sui movimenti XY rispetto ai # movimenti Z (ad esempio, quando si utilizza l'input shaper). # L'impostazione predefinita \u00e8 utilizzare max_accel per max_z_accel. #minimum_z_position: 0 # La posizione Z minima in cui l'utente pu\u00f2 comandare alla testa di # spostarsi. Il valore predefinito \u00e8 0. delta_radius: # Raggio (in mm) del cerchio orizzontale formato dalle tre torri ad # asse lineare. Questo parametro pu\u00f2 anche essere calcolato come: # delta_radius = smooth_rod_offset - effector_offset - carriage_offset # Questo parametro deve essere fornito. #print_radius: # Il raggio (in mm) delle coordinate XY della testa di stampa valide. # \u00c8 possibile utilizzare questa impostazione per personalizzare il # controllo dell'intervallo dei movimenti della testa. Se qui # viene specificato un valore elevato, potrebbe essere possibile # comandare la collisione della testa di stampa con una torre. # L'impostazione predefinita \u00e8 usare delta_radius per print_radius # (che normalmente impedirebbe una collisione con torri). # La sezione stepper_a descrive lo stepper che controlla la torre # anteriore sinistra (a 210 gradi). Questa sezione controlla anche i # parametri di homing (velocit\u00e0 di homing, homing retract_dist) # per tutte le torri. [stepper_a] position_endstop: # Distanza (in mm) tra l'ugello e il piatto quando l'ugello si trova al # centro dell'area di costruzione e si attiva il finecorsa. Questo # parametro deve essere fornito per stepper_a; per stepper_b e # stepper_c questo parametro \u00e8 predefinito sul valore specificato # per stepper_a. arm_length: # Lunghezza (in mm) dell'asta diagonale che collega questa torre # alla testa di stampa. Questo parametro deve essere fornito per # stepper_a; per stepper_b e stepper_c questo parametro \u00e8 predefinito sul valore specificato per stepper_a. #angle: # Questa opzione specifica l'angolo (in gradi) a cui si trova la torre. # Il valore predefinito \u00e8 210 per stepper_a, 330 per stepper_b e 90 # per stepper_c. # La sezione stepper_b descrive lo stepper che controlla la torre # anteriore destra (a 330 gradi). [stepper_b] # La sezione stepper_c descrive lo stepper che controlla la torre # posteriore (a 90 gradi). [stepper_c] # La sezione delta_calibrate abilita un comando G-code esteso # DELTA_CALIBRATE in grado di calibrare le posizioni e gli angoli # dei finecorsa della torre. [delta_calibrate] radius: # Raggio (in mm) dell'area che pu\u00f2 essere sondata. Questo \u00e8 # il raggio delle coordinate dell'ugello da sondare; se si utilizza # una sonda automatica con un offset XY, scegliere un raggio # sufficientemente piccolo in modo che la sonda si adatti sempre # al piatto. Questo parametro deve essere fornito. #speed: 50 # La velocit\u00e0 (in mm/s) degli spostamenti senza probing durante # la calibrazione. Il valore predefinito \u00e8 50. #horizontal_move_z: 5 # L'altezza (in mm) a cui la testa deve essere comandata di # spostarsi appena prima di avviare un'operazione di sonda. # L'impostazione predefinita \u00e8 5. Cinematica Deltesiana \u00b6 Vedere example-deltesian.cfg per un esempio di file di configurazione della cinematica deltesiana. Qui sono descritti solo i parametri specifici per le stampanti deltesiane - vedere impostazioni cinematiche comuni per i parametri disponibili. [printer] kinematics: deltesian max_z_velocity: # For deltesian printers, this limits the maximum velocity (in mm/s) of # moves with z axis movement. This setting can be used to reduce the # maximum speed of up/down moves (which require a higher step rate # than other moves on a deltesian printer). The default is to use # max_velocity for max_z_velocity. #max_z_accel: # This sets the maximum acceleration (in mm/s^2) of movement along # the z axis. Setting this may be useful if the printer can reach higher # acceleration on XY moves than Z moves (eg, when using input shaper). # The default is to use max_accel for max_z_accel. #minimum_z_position: 0 # The minimum Z position that the user may command the head to move # to. The default is 0. #min_angle: 5 # This represents the minimum angle (in degrees) relative to horizontal # that the deltesian arms are allowed to achieve. This parameter is # intended to restrict the arms from becoming completely horizontal, # which would risk accidental inversion of the XZ axis. The default is 5. #print_width: # The distance (in mm) of valid toolhead X coordinates. One may use # this setting to customize the range checking of toolhead moves. If # a large value is specified here then it may be possible to command # the toolhead into a collision with a tower. This setting usually # corresponds to bed width (in mm). #slow_ratio: 3 # The ratio used to limit velocity and acceleration on moves near the # extremes of the X axis. If vertical distance divided by horizontal # distance exceeds the value of slow_ratio, then velocity and # acceleration are limited to half their nominal values. If vertical # distance divided by horizontal distance exceeds twice the value of # the slow_ratio, then velocity and acceleration are limited to one # quarter of their nominal values. The default is 3. # The stepper_left section is used to describe the stepper controlling # the left tower. This section also controls the homing parameters # (homing_speed, homing_retract_dist) for all towers. [stepper_left] position_endstop: # Distance (in mm) between the nozzle and the bed when the nozzle is # in the center of the build area and the endstops are triggered. This # parameter must be provided for stepper_left; for stepper_right this # parameter defaults to the value specified for stepper_left. arm_length: # Length (in mm) of the diagonal rod that connects the tower carriage to # the print head. This parameter must be provided for stepper_left; for # stepper_right, this parameter defaults to the value specified for # stepper_left. arm_x_length: # Horizontal distance between the print head and the tower when the # printers is homed. This parameter must be provided for stepper_left; # for stepper_right, this parameter defaults to the value specified for # stepper_left. # The stepper_right section is used to describe the stepper controlling the # right tower. [stepper_right] # The stepper_y section is used to describe the stepper controlling # the Y axis in a deltesian robot. [stepper_y] Cinematica CoreXY \u00b6 Vedere example-corexy.cfg per un file cinematico corexy (e h-bot) di esempio. Qui sono descritti solo i parametri specifici per le stampanti corexy - vedere impostazioni cinematiche comuni per i parametri disponibili. [printer] kinematics: corexy max_z_velocity: # Imposta la velocit\u00e0 massima (in mm/s) di movimento lungo l'asse z. # Questa impostazione pu\u00f2 essere utilizzata per limitare la velocit\u00e0 # massima del motore passo-passo z. L'impostazione predefinita \u00e8 # utilizzare max_velocity per max_z_velocity. max_z_accel: # Imposta l'accelerazione massima (in mm/s^2) del movimento # lungo l'asse z. Limita l'accelerazione del motore passo-passo z. # L'impostazione predefinita \u00e8 utilizzare max_accel per max_z_accel. # La sezione stepper_x viene utilizzata per descrivere l'asse X e lo # stepper che controlla il movimento X+Y. [stepper_x] # La sezione stepper_y viene utilizzata per descrivere l'asse Y e lo # stepper che controlla il movimento X+Y. [stepper_y] # La sezione stepper_z viene utilizzata per descrivere l'asse Z [stepper_z] Cinematica CoreXZ \u00b6 Vedere example-corexz.cfg per un file di configurazione della cinematica corexz di esempio. Qui sono descritti solo i parametri specifici per le stampanti corexz - vedere impostazioni cinematiche comuni per i parametri disponibili. [printer] kinematics: corexz max_z_velocity: # Imposta la velocit\u00e0 massima (in mm/s) di movimento lungo l'asse z. # L'impostazione predefinita \u00e8 utilizzare max_velocity per # max_z_velocity. max_z_accel: # Imposta l'accelerazione massima (in mm/s^2) del movimento lungo # l'asse z. L'impostazione predefinita \u00e8 utilizzare max_accel per # max_z_accel. # La sezione stepper_x viene utilizzata per descrivere l'asse X e lo # stepper che controlla il movimento X+Z. [stepper_x] # La sezione stepper_y viene utilizzata per descrivere l'asse Y [stepper_y] # La sezione stepper_z viene utilizzata per descrivere l'asse Z e lo # stepper che controlla il movimento X+Z. [stepper_z] Cinematica Hybrid-CoreXY \u00b6 Vedere example-hybrid-corexy.cfg per un file di configurazione della cinematica corexy ibrida di esempio. Questa cinematica \u00e8 anche nota come cinematica Markforged. Qui vengono descritti solo i parametri specifici delle stampanti corexy ibride, vedere impostazioni cinematiche comuni per i parametri disponibili. [printer] kinematics: hybrid_corexy max_z_velocity: # Imposta la velocit\u00e0 massima (in mm/s) di movimento lungo # l'asse z. L'impostazione predefinita \u00e8 utilizzare max_velocity # per max_z_velocity. max_z_accel: # Imposta l'accelerazione massima (in mm/s^2) del movimento # lungo l'asse z. L'impostazione predefinita \u00e8 utilizzare max_accel # per max_z_accel. # La sezione stepper_x viene utilizzata per descrivere l'asse X e lo # stepper che controlla il movimento X-Y. [stepper_x] # La sezione stepper_y viene utilizzata per descrivere lo stepper # che controlla l'asse Y. [stepper_y] # La sezione stepper_z viene utilizzata per descrivere lo stepper # che controlla l'asse Z. [stepper_z] Cinematica Hybrid-CoreXZ \u00b6 Vedere example-hybrid-corexz.cfg per un file di configurazione della cinematica corexz ibrido di esempio. Questa cinematica \u00e8 anche nota come cinematica Markforged. Qui vengono descritti solo i parametri specifici delle stampanti corexy ibride, vedere impostazioni cinematiche comuni per i parametri disponibili. [printer] kinematics: hybrid_corexz max_z_velocity: # Questo imposta la velocit\u00e0 massima (in mm/s) di movimento lungo # l'asse z. L'impostazione predefinita \u00e8 utilizzare max_velocity per # max_z_velocity. max_z_accel: # Imposta l'accelerazione massima (in mm/s^2) del movimento lungo # l'asse z. L'impostazione predefinita \u00e8 utilizzare max_accel per # max_z_accel. # La sezione stepper_x viene utilizzata per descrivere l'asse X e lo # stepper che controlla il movimento X-Z. [stepper_x] # La sezione stepper_y viene utilizzata per descrivere lo stepper che # controlla l'asse Y. [stepper_y] # La sezione stepper_z viene utilizzata per descrivere lo stepper che # controlla l'asse Z. [stepper_z] Cinematica polare \u00b6 Vedere example-polar.cfg per un file di configurazione della cinematica polare di esempio. Qui sono descritti solo i parametri specifici per le stampanti polari - vedere impostazioni cinematiche comuni per i parametri disponibili. LA CINEMATICA POLARE \u00c8 UN LAVORO IN CORSO. \u00c8 noto che i movimenti intorno alla posizione 0, 0 non funzionano correttamente. [printer] kinematics: polar max_z_velocity: # Imposta la velocit\u00e0 massima (in mm/s) di movimento lungo l'asse z. # Questa impostazione pu\u00f2 essere utilizzata per limitare la velocit\u00e0 # massima del motore passo-passo z. L'impostazione predefinita \u00e8 # utilizzare max_velocity per max_z_velocity. max_z_accel: # Questo imposta l'accelerazione massima (in mm/s^2) del # movimento lungo l'asse z. Limita l'accelerazione del motore # passo-passo z. L'impostazione predefinita \u00e8 utilizzare max_accel # per max_z_accel. # La sezione stepper_bed viene utilizzata per descrivere lo stepper # che controlla il piatto [stepper_bed] gear_ratio: # \u00c8 necessario specificare un gear_ratio e rotation_distance # potrebbe non essere specificato. Ad esempio, se il piatto ha una # ruota a 80 denti azionata da uno stepper con una ruota a 16 # denti, si dovrebbe specificare un rapporto di trasmissione di \"80:16\". # Questo parametro deve essere fornito. # La sezione stepper_arm \u00e8 usata per descrivere lo stepper che # controlla il carrello sul braccio. [stepper_arm] # La sezione stepper_z viene utilizzata per descrivere lo stepper che # controlla l'asse Z. [stepper_z] Cinematica delta rotatoria \u00b6 Vedere example-rotary-delta.cfg per un esempio di file di configurazione della cinematica delta rotante. Qui vengono descritti solo i parametri specifici delle stampanti delta rotative - vedere impostazioni cinematiche comuni per i parametri disponibili. LA CINEMATICA DELTA ROTANTE \u00c8 UN LAVORO IN CORSO. Gli spostamenti di homing potrebbero scadere e alcuni controlli dei confini non vengono implementati. [printer] kinematics: rotary_delta max_z_velocity: # For delta printers this limits the maximum velocity (in mm/s) of # moves with z axis movement. This setting can be used to reduce the # maximum speed of up/down moves (which require a higher step rate # than other moves on a delta printer). The default is to use # max_velocity for max_z_velocity. #minimum_z_position: 0 # The minimum Z position that the user may command the head to move # to. The default is 0. shoulder_radius: # Radius (in mm) of the horizontal circle formed by the three # shoulder joints, minus the radius of the circle formed by the # effector joints. This parameter may also be calculated as: # shoulder_radius = (delta_f - delta_e) / sqrt(12) # This parameter must be provided. shoulder_height: # Distance (in mm) of the shoulder joints from the bed, minus the # effector toolhead height. This parameter must be provided. # The stepper_a section describes the stepper controlling the rear # right arm (at 30 degrees). This section also controls the homing # parameters (homing_speed, homing_retract_dist) for all arms. [stepper_a] gear_ratio: # A gear_ratio must be specified and rotation_distance may not be # specified. For example, if the arm has an 80 toothed pulley driven # by a pulley with 16 teeth, which is in turn connected to a 60 # toothed pulley driven by a stepper with a 16 toothed pulley, then # one would specify a gear ratio of \"80:16, 60:16\". This parameter # must be provided. position_endstop: # Distance (in mm) between the nozzle and the bed when the nozzle is # in the center of the build area and the endstop triggers. This # parameter must be provided for stepper_a; for stepper_b and # stepper_c this parameter defaults to the value specified for # stepper_a. upper_arm_length: # Length (in mm) of the arm connecting the \"shoulder joint\" to the # \"elbow joint\". This parameter must be provided for stepper_a; for # stepper_b and stepper_c this parameter defaults to the value # specified for stepper_a. lower_arm_length: # Length (in mm) of the arm connecting the \"elbow joint\" to the # \"effector joint\". This parameter must be provided for stepper_a; # for stepper_b and stepper_c this parameter defaults to the value # specified for stepper_a. #angle: # This option specifies the angle (in degrees) that the arm is at. # The default is 30 for stepper_a, 150 for stepper_b, and 270 for # stepper_c. # The stepper_b section describes the stepper controlling the rear # left arm (at 150 degrees). [stepper_b] # The stepper_c section describes the stepper controlling the front # arm (at 270 degrees). [stepper_c] # The delta_calibrate section enables a DELTA_CALIBRATE extended # g-code command that can calibrate the shoulder endstop positions. [delta_calibrate] radius: # Radius (in mm) of the area that may be probed. This is the radius # of nozzle coordinates to be probed; if using an automatic probe # with an XY offset then choose a radius small enough so that the # probe always fits over the bed. This parameter must be provided. #speed: 50 # The speed (in mm/s) of non-probing moves during the calibration. # The default is 50. #horizontal_move_z: 5 # The height (in mm) that the head should be commanded to move to # just prior to starting a probe operation. The default is 5. Cinematica dell'argano a fune \u00b6 Vedere example-winch.cfg per un esempio di file di configurazione della cinematica con verricello, cable winch. Qui sono descritti solo i parametri specifici per le stampanti cavo verricello - vedere impostazioni comuni cinematiche per i parametri disponibili. IL SUPPORTO DEL VERRICELLO \u00c8 SPERIMENTALE. L'homing non \u00e8 implementato nella cinematica del verricello. Per riportare la stampante alla posizione iniziale, inviare manualmente i comandi di movimento finch\u00e9 la testa utensile non si trova su 0, 0, 0, quindi emettere un comando \"G28\". [printer] kinematics: winch # The stepper_a section describes the stepper connected to the first # cable winch. A minimum of 3 and a maximum of 26 cable winches may be # defined (stepper_a to stepper_z) though it is common to define 4. [stepper_a] rotation_distance: # The rotation_distance is the nominal distance (in mm) the toolhead # moves towards the cable winch for each full rotation of the # stepper motor. This parameter must be provided. anchor_x: anchor_y: anchor_z: # The X, Y, and Z position of the cable winch in cartesian space. # These parameters must be provided. Nessuna cinematica \u00b6 \u00c8 possibile definire una cinematica speciale \"none\" per disabilitare il supporto cinematico in Klipper. Questo pu\u00f2 essere utile per controllare dispositivi che non sono le tipiche stampanti 3D o per scopi di debug. [printer] kinematics: none max_velocity: 1 max_accel: 1 # \u00c8 necessario definire i parametri max_velocity e max_accel. I valori # non vengono utilizzati per la cinematica \"none\". Supporto per estrusore e piatto riscaldato comuni \u00b6 [extruder] \u00b6 La sezione dell'estrusore viene utilizzata per descrivere i parametri del riscaldatore per l'hotend dell'ugello insieme allo stepper che controlla l'estrusore. Per ulteriori informazioni, vedere riferimento comando . Consultare la Guida all'avanzamento della pressione per informazioni sulla regolazione dell'anticipo della pressione. [extruder] step_pin: dir_pin: enable_pin: microsteps: rotation_distance: #full_steps_per_rotation: #gear_ratio: # Vedere la sezione \"stepper\" per una descrizione di quanto sopra # Se nessuno dei parametri precedenti \u00e8 specificato, nessuno stepper # sar\u00e0 associato all'hotend dell'ugello (sebbene un comando # SYNC_EXTRUDER_MOTION possa associarne uno in fase di esecuzione). nozzle_diameter: # Diametro dell'orifizio dell'ugello (in mm). Questo parametro deve essere fornito. filament_diameter:: # Il diametro nominale del filamento grezzo (in mm) quando # entra nell'estrusore. Questo parametro deve essere fornito. #max_extrude_cross_section: # Area massima (in mm^2) di una sezione trasversale dell'estrusione # (ad es. larghezza dell'estrusione moltiplicata per l'altezza dello strato). # Questa impostazione previene quantit\u00e0 eccessive di estrusione # durante spostamenti XY relativamente piccoli. # Se un movimento richiede una velocit\u00e0 di estrusione che supererebbe questo valore # causer\u00e0 la restituzione di un errore. L'impostazione predefinita # \u00e8: 4.0 * diametro_ugello^2 instantaneous_corner_velocity: 1.000 # La variazione di velocit\u00e0 istantanea massima (in mm/s) del # estrusore durante il collegamento di due movimenti. Il valore predefinito \u00e8 1 mm/s. #max_extrude_only_distance: 50.0 # Lunghezza massima (in mm di filamento grezzo) che pu\u00f2 avere un movimento # di retrazione o di sola estrusione. Se uno spostamento di retrazione # o di sola estrusione richiede una distanza maggiore di questo valore, # verr\u00e0 restituito un errore. Il valore predefinito \u00e8 50 mm. #max_extrude_only_velocity: #max_extrude_only_accel: # Velocit\u00e0 massima (in mm/s) e accelerazione (in mm/s^2) del # motore estrusore per retrazioni e movimenti di sola estrusione. # Queste impostazioni non hanno alcun impatto sui normali movimenti di stampa. # Se non specificati, vengono calcolati per corrispondere al limite che avrebbe # un movimento di stampa XY con una sezione trasversale di 4,0*diametro_ugello^2. #pressure_advance: 0.0 # La quantit\u00e0 di filamento grezzo da spingere nell'estrusore durante # accelerazione dell'estrusore. Una uguale quantit\u00e0 di filamento viene # retratta durante la decelerazione. Si misura in millimetri per # millimetro/secondo. Il valore predefinito \u00e8 0, che disabilita l'avanzamento della pressione. #pressure_advance_smooth_time: 0,040 # Un intervallo di tempo (in secondi) da utilizzare per calcolare la velocit\u00e0 media # dell'estrusore per l'avanzamento della pressione. Un valore maggiore si traduce # in movimenti pi\u00f9 fluidi dell'estrusore. Questo parametro non pu\u00f2 superare i 200 ms. # Questa impostazione si applica solo se pressure_advance \u00e8 diverso da zero. # Il valore predefinito \u00e8 0,040 (40 millisecondi). # # Le restanti variabili descrivono il riscaldatore dell'estrusore. heater_pin: # Pin di uscita PWM che controlla il riscaldatore. Questo parametro deve essere fornito. #max_power: 1.0 # La potenza massima (espressa come un valore compreso tra 0,0 e 1,0) a cui # pu\u00f2 essere impostato il riscaldatore_pin. Il valore 1.0 consente di impostare il pin # completamente abilitato per periodi prolungati, mentre un valore di 0,5 # consentirebbe di abilitare il pin per non pi\u00f9 della met\u00e0 del tempo. Questo # l'impostazione pu\u00f2 essere utilizzata per limitare la potenza totale # (per periodi prolungati) al riscaldatore. L'impostazione predefinita \u00e8 1.0. sensor_type: # Tipo di sensore - i termistori comuni sono \"EPCOS 100K B57560G104F\", # \"ATC Semitec 104GT-2\", \"ATC Semitec 104NT-4-R025H42G\", \"Generico # 3950\",\"Honeywell 100K 135-104LAG-J01\", \"NTC 100K MGB18-104F39050L32\", # \"SliceEngineering 450\" e \"TDK NTCG104LH104JT1\". Vedere la sezione # \"Sensori di temperatura\" per altri sensori. Questo parametro deve essere fornito. sensor_pin: # Pin di ingresso analogico collegato al sensore. Questo parametro deve essere fornito. #pullup_resistor: 4700 # La resistenza (in ohm) del pullup collegato al termistore. Questo parametro # \u00e8 valido solo quando il sensore \u00e8 un termistore. Il valore predefinito \u00e8 4700 ohm. #smooth_time: 1.0 # Un valore di tempo (in secondi) durante il quale le misurazioni della # temperatura verranno uniformate per ridurre l'impatto del rumore # di misurazione. Il valore predefinito \u00e8 1 secondo. control: # Algoritmo di controllo (pid o filigrana). Questo parametro deve # essere fornito. pid_Kp: pid_Ki: pid_Kd: # Il proporzionale (pid_Kp), l'integrale (pid_Ki) e la derivata # (pid_Kd) impostazioni per il sistema di controllo del feedback PID. Klipper # valuta le impostazioni PID con la seguente formula generale: # riscaldatore_pwm = (Kp*errore + Ki*integrale(errore) - Kd*derivato(errore)) / 255 # Dove \"errore\" \u00e8 \"temperatura_richiesta - temperatura_misurata\" # e \"heater_pwm\" \u00e8 la velocit\u00e0 di riscaldamento richiesta con 0,0 completamente # off e 1.0 completamente on. Prendi in considerazione l'utilizzo di PID_CALIBRATE # comando per ottenere questi parametri. pid_Kp, pid_Ki e pid_Kd # i parametri devono essere forniti per i riscaldatori PID. #delta_max: 2.0 # Sui riscaldatori controllati questo \u00e8 il numero di gradi in # Celsius al di sopra della temperatura target prima di disattivare il riscaldatore # cos\u00ec come il numero di gradi sotto il target prima # riattivare il riscaldatore. L'impostazione predefinita \u00e8 2 gradi Celsius. #pwm_cycle_time: 0,100 # Tempo in secondi per ogni ciclo PWM software del riscaldatore. # non \u00e8 consigliabile impostarlo a meno che non ci sia necessario come # requisito accendere il riscaldatore pi\u00f9 velocemente di 10 volte al secondo. # Il valore predefinito \u00e8 0,100 secondi. #min_extrude_temp: 170 # La temperatura minima (in gradi Celsius) alla quale possono essere # impartiti comandi all'estrusore. L'impostazione predefinita \u00e8 170 gradi Celsius. min_temp: max_temp: # L'intervallo massimo di temperature valide (in gradi Celsius) in cui # il riscaldatore deve rimanere all'interno. Questo controlla una funzione di sicurezza # implementata nel codice del microcontrollore , la temperatura # non cadr\u00e0 mai al di fuori di questo intervallo, altrimenti il microcontrollore # entrer\u00e0 in uno stato di arresto. Questo controllo pu\u00f2 aiutare a rilevarne alcuni # guasti hardware del riscaldatore e del sensore. Imposta questo intervallo solo in modo ampio # abbastanza in modo che temperature ragionevoli non si traducano in un errore. # Questi parametri devono essere forniti. [heater_bed] \u00b6 La sezione heater_bed descrive un piatto riscaldato. Utilizza le stesse impostazioni del riscaldatore descritte nella sezione \"extruder\". [heater_bed] heater_pin: sensor_type: sensor_pin: control: min_temp: max_temp: # Vedere la sezione \"extruder\" per una descrizione dei parametri sopra. Supporto livellamento del piatto \u00b6 [bed_mesh] \u00b6 Mesh Bed Leveling. Si pu\u00f2 definire una sezione di configurazione bed_mesh per abilitare trasformazioni di spostamento che sfalsano l'asse z in base a una mesh generata da punti sondati. Quando si utilizza una sonda per la posizione di riferimento sull'asse z, si consiglia di definire una sezione safe_z_home in printer.cfg per la posizione di riferimento verso il centro dell'area di stampa. Per ulteriori informazioni, vedere la bed mesh guide e riferimento del comando . Esempi visivi: rectangular bed, probe_count = 3, 3: x---x---x (max_point) | x---x---x | (min_point) x---x---x round bed, round_probe_count = 5, bed_radius = r: x (0, r) end / x---x---x \\ (-r, 0) x---x---x---x---x (r, 0) \\ x---x---x / x (0, -r) start [bed_mesh] #speed: 50 # The speed (in mm/s) of non-probing moves during the calibration. # The default is 50. #horizontal_move_z: 5 # The height (in mm) that the head should be commanded to move to # just prior to starting a probe operation. The default is 5. #mesh_radius: # Defines the radius of the mesh to probe for round beds. Note that # the radius is relative to the coordinate specified by the # mesh_origin option. This parameter must be provided for round beds # and omitted for rectangular beds. #mesh_origin: # Defines the center X, Y coordinate of the mesh for round beds. This # coordinate is relative to the probe's location. It may be useful # to adjust the mesh_origin in an effort to maximize the size of the # mesh radius. Default is 0, 0. This parameter must be omitted for # rectangular beds. #mesh_min: # Defines the minimum X, Y coordinate of the mesh for rectangular # beds. This coordinate is relative to the probe's location. This # will be the first point probed, nearest to the origin. This # parameter must be provided for rectangular beds. #mesh_max: # Defines the maximum X, Y coordinate of the mesh for rectangular # beds. Adheres to the same principle as mesh_min, however this will # be the furthest point probed from the bed's origin. This parameter # must be provided for rectangular beds. #probe_count: 3, 3 # For rectangular beds, this is a comma separate pair of integer # values X, Y defining the number of points to probe along each # axis. A single value is also valid, in which case that value will # be applied to both axes. Default is 3, 3. #round_probe_count: 5 # For round beds, this integer value defines the maximum number of # points to probe along each axis. This value must be an odd number. # Default is 5. #fade_start: 1.0 # The gcode z position in which to start phasing out z-adjustment # when fade is enabled. Default is 1.0. #fade_end: 0.0 # The gcode z position in which phasing out completes. When set to a # value below fade_start, fade is disabled. It should be noted that # fade may add unwanted scaling along the z-axis of a print. If a # user wishes to enable fade, a value of 10.0 is recommended. # Default is 0.0, which disables fade. #fade_target: # The z position in which fade should converge. When this value is # set to a non-zero value it must be within the range of z-values in # the mesh. Users that wish to converge to the z homing position # should set this to 0. Default is the average z value of the mesh. #split_delta_z: .025 # The amount of Z difference (in mm) along a move that will trigger # a split. Default is .025. #move_check_distance: 5.0 # The distance (in mm) along a move to check for split_delta_z. # This is also the minimum length that a move can be split. Default # is 5.0. #mesh_pps: 2, 2 # A comma separated pair of integers X, Y defining the number of # points per segment to interpolate in the mesh along each axis. A # \"segment\" can be defined as the space between each probed point. # The user may enter a single value which will be applied to both # axes. Default is 2, 2. #algorithm: lagrange # The interpolation algorithm to use. May be either \"lagrange\" or # \"bicubic\". This option will not affect 3x3 grids, which are forced # to use lagrange sampling. Default is lagrange. #bicubic_tension: .2 # When using the bicubic algorithm the tension parameter above may # be applied to change the amount of slope interpolated. Larger # numbers will increase the amount of slope, which results in more # curvature in the mesh. Default is .2. #zero_reference_position: # An optional X,Y coordinate that specifies the location on the bed # where Z = 0. When this option is specified the mesh will be offset # so that zero Z adjustment occurs at this location. The default is # no zero reference. #faulty_region_1_min: #faulty_region_1_max: # Optional points that define a faulty region. See docs/Bed_Mesh.md # for details on faulty regions. Up to 99 faulty regions may be added. # By default no faulty regions are set. #adaptive_margin: # An optional margin (in mm) to be added around the bed area used by # the defined print objects when generating an adaptive mesh. #scan_overshoot: # The maximum amount of travel (in mm) available outside of the mesh. # For rectangular beds this applies to travel on the X axis, and for round beds # it applies to the entire radius. The tool must be able to travel the amount # specified outside of the mesh. This value is used to optimize the travel # path when performing a \"rapid scan\". The minimum value that may be specified # is 1. The default is no overshoot. [bed_tilt] \u00b6 Compensazione dell'inclinazione del piatto. Si pu\u00f2 definire una sezione di configurazione bed_tilt per abilitare le trasformazioni di movimento che tengono conto di un piatto inclinato. Nota che bed_mesh e bed_tilt sono incompatibili; entrambi non possono essere definiti. Per ulteriori informazioni, vedere riferimento comando . [bed_tilt] #x_adjust: 0 # The amount to add to each move's Z height for each mm on the X # axis. The default is 0. #y_adjust: 0 # The amount to add to each move's Z height for each mm on the Y # axis. The default is 0. #z_adjust: 0 # The amount to add to the Z height when the nozzle is nominally at # 0, 0. The default is 0. # The remaining parameters control a BED_TILT_CALIBRATE extended # g-code command that may be used to calibrate appropriate x and y # adjustment parameters. #points: # A list of X, Y coordinates (one per line; subsequent lines # indented) that should be probed during a BED_TILT_CALIBRATE # command. Specify coordinates of the nozzle and be sure the probe # is above the bed at the given nozzle coordinates. The default is # to not enable the command. #speed: 50 # The speed (in mm/s) of non-probing moves during the calibration. # The default is 50. #horizontal_move_z: 5 # The height (in mm) that the head should be commanded to move to # just prior to starting a probe operation. The default is 5. [bed_screws] \u00b6 Strumento per aiutare a regolare le viti di livellamento del letto. Si pu\u00f2 definire una sezione di configurazione [bed_screws] per abilitare un comando g-code BED_SCREWS_ADJUST. Per ulteriori informazioni, vedere la guida al livellamento e il riferimento al comando . [bed_screws] #screw1: # The X, Y coordinate of the first bed leveling screw. This is a # position to command the nozzle to that is directly above the bed # screw (or as close as possible while still being above the bed). # This parameter must be provided. #screw1_name: # An arbitrary name for the given screw. This name is displayed when # the helper script runs. The default is to use a name based upon # the screw XY location. #screw1_fine_adjust: # An X, Y coordinate to command the nozzle to so that one can fine # tune the bed leveling screw. The default is to not perform fine # adjustments on the bed screw. #screw2: #screw2_name: #screw2_fine_adjust: #... # Additional bed leveling screws. At least three screws must be # defined. #horizontal_move_z: 5 # The height (in mm) that the head should be commanded to move to # when moving from one screw location to the next. The default is 5. #probe_height: 0 # The height of the probe (in mm) after adjusting for the thermal # expansion of bed and nozzle. The default is zero. #speed: 50 # The speed (in mm/s) of non-probing moves during the calibration. # The default is 50. #probe_speed: 5 # The speed (in mm/s) when moving from a horizontal_move_z position # to a probe_height position. The default is 5. [screws_tilt_adjust] \u00b6 Strumento per aiutare a regolare l'inclinazione delle viti del piatto utilizzando la sonda Z. Si pu\u00f2 definire una sezione di configurazione Screws_tilt_adjust per abilitare un comando g-code SCREWS_TILT_CALCULATE. Per ulteriori informazioni, vedere la guida al livellamento e riferimento al comando . [screws_tilt_adjust] #screw1: # The (X, Y) coordinate of the first bed leveling screw. This is a # position to command the nozzle to so that the probe is directly # above the bed screw (or as close as possible while still being # above the bed). This is the base screw used in calculations. This # parameter must be provided. #screw1_name: # An arbitrary name for the given screw. This name is displayed when # the helper script runs. The default is to use a name based upon # the screw XY location. #screw2: #screw2_name: #... # Additional bed leveling screws. At least two screws must be # defined. #speed: 50 # The speed (in mm/s) of non-probing moves during the calibration. # The default is 50. #horizontal_move_z: 5 # The height (in mm) that the head should be commanded to move to # just prior to starting a probe operation. The default is 5. #screw_thread: CW-M3 # The type of screw used for bed leveling, M3, M4, or M5, and the # rotation direction of the knob that is used to level the bed. # Accepted values: CW-M3, CCW-M3, CW-M4, CCW-M4, CW-M5, CCW-M5. # Default value is CW-M3 which most printers use. A clockwise # rotation of the knob decreases the gap between the nozzle and the # bed. Conversely, a counter-clockwise rotation increases the gap. [z_tilt] \u00b6 Regolazione multipla dell'inclinazione dello stepper Z. Questa funzione consente la regolazione indipendente di pi\u00f9 stepper z (vedere la sezione \"stepper_z1\") per regolare l'inclinazione. Se questa sezione \u00e8 presente, diventa disponibile un comando G-Code esteso Z_TILT_ADJUST. [z_tilt] #z_positions: # Un elenco di coordinate X, Y (una per riga; le righe successive # identate) che descrivono la posizione di ciascun \"pivot point\" # del piattotto. Il \"pivot point\" \u00e8 il punto in cui il piatto si attacca # al dato stepper Z. Viene descritto utilizzando le coordinate dell'ugello # (la posizione X, Y dell'ugello se potesse spostarsi direttamente sopra # il punto). La prima voce corrisponde a stepper_z, la seconda a # stepper_z1, la terza a stepper_z2, ecc. # Questo parametro deve essere fornito. #points: # Un elenco di coordinate X, Y (una per riga; righe successive identate) # che devono essere rilevate durante un comando Z_TILT_ADJUST. # Specificare le coordinate dell'ugello e assicurarsi che la sonda sia # sopra il piatto alle coordinate dell'ugello date. # Questo parametro deve essere fornito. #speed: 50 # La velocit\u00e0 (in mm/s) degli spostamenti senza probing durante # la calibrazione. Il valore predefinito \u00e8 50. #horizontal_move_z: 5 # L'altezza (in mm) a cui la testa deve essere comandata per spostarsi # appena prima di avviare un'operazione di probing. # L'impostazione predefinita \u00e8 5. #retries: 0 # Numero di volte per riprovare se i punti rilevati non sono all'interno # della tolleranza. #retry_tolerance: 0 # Se i tentativi sono abilitati, riprovare se i punti sondati pi\u00f9 grande e # pi\u00f9 piccolo differiscono pi\u00f9 di retry_tolerance. Nota che l'unit\u00e0 di # modifica pi\u00f9 piccola qui sarebbe un singolo passaggio. # Tuttavia, se stai sondando pi\u00f9 punti rispetto agli stepper, # probabilmente avrai un valore minimo fisso per l'intervallo di punti # sondati che puoi apprendere osservando l'output del comando. [quad_gantry_level] \u00b6 Livellamento del gantly mediante 4 motori Z controllati in modo indipendente. Corregge gli effetti della parabola iperbolica (patatine fritte) sul portale mobile che \u00e8 pi\u00f9 flessibile. ATTENZIONE: l'utilizzo su un letto mobile pu\u00f2 portare a risultati indesiderati. Se questa sezione \u00e8 presente, diventa disponibile un comando G-Code esteso QUAD_GANTRY_LEVEL. Questa routine presuppone la seguente configurazione del motore Z: ---------------- |Z1 Z2| | --------- | | | | | | | | | | x-------- | |Z Z3| ---------------- Dove x \u00e8 il punto 0, 0 sul piatto [quad_gantry_level] #gantry_corners: # A newline separated list of X, Y coordinates describing the two # opposing corners of the gantry. The first entry corresponds to Z, # the second to Z2. This parameter must be provided. #points: # A newline separated list of four X, Y points that should be probed # during a QUAD_GANTRY_LEVEL command. Order of the locations is # important, and should correspond to Z, Z1, Z2, and Z3 location in # order. This parameter must be provided. For maximum accuracy, # ensure your probe offsets are configured. #speed: 50 # The speed (in mm/s) of non-probing moves during the calibration. # The default is 50. #horizontal_move_z: 5 # The height (in mm) that the head should be commanded to move to # just prior to starting a probe operation. The default is 5. #max_adjust: 4 # Safety limit if an adjustment greater than this value is requested # quad_gantry_level will abort. #retries: 0 # Number of times to retry if the probed points aren't within # tolerance. #retry_tolerance: 0 # If retries are enabled then retry if largest and smallest probed # points differ more than retry_tolerance. [skew_correction] \u00b6 Correzione dell'inclinazione della stampante. \u00c8 possibile utilizzare il software per correggere l'inclinazione della stampante su 3 piani, xy, xz, yz. Questo viene fatto stampando un modello di calibrazione lungo un piano e misurando tre lunghezze. A causa della natura della correzione dell'inclinazione, queste lunghezze vengono impostate tramite gcode. Per i dettagli, vedere Correzione inclinazione e Command Reference . [skew_correction] [z_thermal_adjust] \u00b6 Regolazione della posizione Z della testa di stampa in funzione della temperatura. Compensare il movimento verticale della testina utensile causato dall'espansione termica del telaio della stampante in tempo reale utilizzando un sensore di temperatura (tipicamente accoppiato a una sezione verticale del telaio). Vedi anche: comandi g-code estesi . [z_thermal_adjust] #temp_coeff: # Il coefficiente di dilatazione della temperatura, in mm/degC. Ad esempio, un # temp_coeff di 0,01 mm/degC sposter\u00e0 l'asse Z verso il basso di 0,01 mm per ogni # grado Celsius di auemnto del sensore di temperatura . Il valore predefinito \u00e8 # 0,0 mm/degC, che non applica alcuna regolazione. #smooth_time: # Finestra di smoothing applicata al sensore di temperatura, in secondi. Pu\u00f2 # ridurre il rumore del motore da piccole correzioni eccessive in risposta al # rumore del sensore. Il valore predefinito \u00e8 2,0 secondi. #z_adjust_off_above: # Disattiva le regolazioni al di sopra di questa altezza Z [mm]. L'ultima correzione # calcolata rimarr\u00e0 applicata finch\u00e9 la testa utensile non si sposter\u00e0 nuovamente # al di sotto dell'altezza Z specificata. # Il valore predefinito \u00e8 99999999,0 mm (sempre attivo). #max_z_adjustment: # Massima regolazione assoluta applicabile all'asse Z [mm]. Il valore predefinito # \u00e8 99999999,0 mm (illimitato). #sensor_type: #sensor_pin: #min_temp: #max_temp: # Configurazione del sensore di temperatura. Vedere la sezione \"extruder\" per # la definizione dei parametri di cui sopra. #gcode_id: # Vedere la sezione \"heater_generic\" per la definizione di questo parametro. Homing personalizzato \u00b6 [safe_z_home] \u00b6 Homing Z sicuro. Si pu\u00f2 utilizzare questo meccanismo per posizionare l'asse Z su una specifica coordinata X, Y. Ci\u00f2 \u00e8 utile se la testa portautensili, ad esempio, deve spostarsi al centro del letto prima che Z possa essere riposizionato. [safe_z_home] home_xy_position: # Una coordinata X, Y (ad es. 100, 100) dove deve essere eseguita # homing Z. Questo parametro deve essere fornito. #speed: 50.0 # Velocit\u00e0 alla quale la testa di stampa viene spostata sulla # coordinata Z sicura. Il valore predefinito \u00e8 50 mm/s #z_hop: # Distanza (in mm) per sollevare l'asse Z prima dell'homing. # Questo si applica a qualsiasi comando di homing, anche se non # si trova sull'asse Z. Se l'asse Z \u00e8 gi\u00e0 azzerato e la posizione Z # corrente \u00e8 inferiore a z_hop, questo sollever\u00e0 la testa a un'altezza # di z_hop. Se l'asse Z non \u00e8 gi\u00e0 azzerato la testina viene sollevata # di z_hop. L'impostazione predefinita \u00e8 di non implementare Z hop. #z_hop_speed: 15.0 # Velocit\u00e0 (in mm/s) alla quale l'asse Z viene sollevato prima # del homing. Il valore predefinito \u00e8 15 mm/s. #move_to_previous: False # Quando \u00e8 impostato su True, gli assi X e Y vengono ripristinati alle # posizioni precedenti dopo l'homing dell'asse Z. # L'impostazione predefinita \u00e8 False. [homing_override] \u00b6 Homing Override. Si pu\u00f2 utilizzare questo meccanismo per eseguire una serie di comandi g-code al posto di un G28 che si trova nel normale input di g-code. Questo pu\u00f2 essere utile su stampanti che richiedono una procedura specifica per l'home della macchina. [homing_override] gcode: # Un elenco di comandi G-Code da eseguire al posto dei comandi # G28 trovati nel normale input di G-Code. # Vedi docs/Command_Templates.md per il formato G-Code. # Se un G28 \u00e8 contenuto in questo elenco di comandi, invocher\u00e0 # la normale procedura di homing per la stampante. I comandi # qui elencati devono eseguire l'home di tutti gli assi. # Questo parametro deve essere fornito. #axes: xyz # Gli assi da sovrascrivere. Ad esempio, se questo \u00e8 impostato # su \"z\", lo script di override verr\u00e0 eseguito solo quando l'asse z # \u00e8 azzerato (ad esempio, tramite un comando \"G28\" o \"G28 Z0\"). # Nota, lo script di sovrascrittura dovrebbe comunque ospitare # tutti gli assi. L'impostazione predefinita \u00e8 \"xyz\" che fa s\u00ec che lo # script di override venga eseguito al posto di tutti i comandi G28. #set_position_x: #set_position_y: #set_position_z: # Se specificato, la stampante presumer\u00e0 che l'asse si trovi # nella posizione specificata prima di eseguire i comandi g-code # precedenti. L'impostazione di questa opzione disabilita i # controlli di riferimento per quell'asse. Questo pu\u00f2 essere utile # se la testa deve muoversi prima di invocare il normale # meccanismo G28 per un asse. L'impostazione predefinita \u00e8 # di non forzare una posizione per un asse. [endstop_phase] \u00b6 Finecorsa regolati in fase stepper. Per utilizzare questa funzione, definire una sezione di configurazione con un prefisso \"endstop_phase\" seguito dal nome della corrispondente sezione di configurazione dello stepper (ad esempio, \"[endstop_phase stepper_z]\"). Questa funzione pu\u00f2 migliorare la precisione degli interruttori di fine corsa. Aggiungi una semplice dichiarazione \"[endstop_phase]\" per abilitare il comando ENDSTOP_PHASE_CALIBRATE. Per ulteriori informazioni, vedere la endstop phases guide e command reference . [endstop_phase stepper_z] #endstop_accuracy: # Imposta la precisione prevista (in mm) del finecorsa. Questo rappresenta # la distanza massima di errore che il finecorsa pu\u00f2 attivare (ad es. se un # finecorsa pu\u00f2 occasionalmente attivarsi 100um in anticipo o fino a 100um in ritardo # quindi impostalo su 0,200 per 200 um). L'impostazione predefinita \u00e8 # 4*distanza_rotazione/passi_completi_per_rotazione. #trigger_phase: # Questo specifica la fase del driver del motore passo-passo da aspettarsi # quando si raggiunge il finecorsa. \u00c8 composto da due numeri separati # da un '/' - la fase e il numero totale di # fasi (ad es. \"7/64\"). Impostare questo valore solo se si \u00e8 sicuri che il # driver del motore passo-passo viene ripristinato ogni volta che viene ripristinato l'mcu. Se questo # non \u00e8 impostato, la prima fase verr\u00e0 rilevata al primo home # e quella fase sar\u00e0 utilizzata su tutte le abitazioni successive. #endstop_align_zero: False # Se true, la posizione_endstop dell'asse sar\u00e0 effettivamente # modificato in modo che la posizione zero dell'asse avvenga a passo pieno # sul motore. (Se utilizzato sull'asse Z e la stampa # l'altezza del livello \u00e8 un multiplo di una distanza di un passo intero, allora ogni # layer si eseguir\u00e0 in un step completo.) L'impostazione predefinita \u00e8 False. Macro ed eventi G-Code \u00b6 [gcode_macro] \u00b6 Macro G-Code (\u00e8 possibile definire un numero qualsiasi di sezioni con un prefisso \"gcode_macro\"). Per ulteriori informazioni, consulta la Guida ai modelli di comando . [gcode_macro my_cmd] #gcode: # Un elenco di comandi G-Code da eseguire al posto di \"my_cmd\". # Vedi docs/Command_Templates.md per il formato G-Code. # Questo parametro deve essere fornito. #variable_<name>: # Si pu\u00f2 specificare un numero qualsiasi di opzioni con un prefisso # \"variable_\". Al nome della variabile data verr\u00e0 assegnato il valore dato # (analizzato come un valore letterale Python) e sar\u00e0 disponibile durante # l'espansione della macro. Ad esempio, una configurazione con # \"variable_fan_speed = 75\" potrebbe avere comandi gcode contenenti # \"M106 S{ fan_speed * 255 }\". Le variabili possono essere modificate in # fase di esecuzione utilizzando il comando SET_GCODE_VARIABLE # (consultare docs/Command_Templates.md per i dettagli). # I nomi delle variabili potrebbero non utilizzare caratteri maiuscoli. #rename_existing: # Questa opzione far\u00e0 s\u00ec che la macro ignori un comando G-Code # esistente e fornisca la definizione precedente del comando tramite # il nome fornito qui. Questo pu\u00f2 essere usato per sovrascrivere i # comandi G-Code integrati. Prestare attenzione quando si ignorano # i comandi poich\u00e9 possono causare risultati complessi e imprevisti. # L'impostazione predefinita \u00e8 di non sovrascrivere un comando # G-Code esistente. #description: G-Code macro # Ci\u00f2 aggiunger\u00e0 una breve descrizione utilizzata al comando HELP # o durante l'utilizzo della funzione di completamento automatico. # Predefinito \"G-Code macro\" [delayed_gcode] \u00b6 Esegui un gcode con un ritardo impostato. Per ulteriori informazioni, consulta la Guida template dei comandi e riferimento al comando . [delayed_gcode my_delayed_gcode] gcode: # A list of G-Code commands to execute when the delay duration has # elapsed. G-Code templates are supported. This parameter must be # provided. #initial_duration: 0.0 # The duration of the initial delay (in seconds). If set to a # non-zero value the delayed_gcode will execute the specified number # of seconds after the printer enters the \"ready\" state. This can be # useful for initialization procedures or a repeating delayed_gcode. # If set to 0 the delayed_gcode will not execute on startup. # Default is 0. [save_variables] \u00b6 Supporta il salvataggio delle variabili su disco in modo che vengano mantenute durante i riavvii. Per ulteriori informazioni, vedere template dei comandi e G-Code reference . [save_variables] filename: # Richiesto: fornire un nome file che verrebbe utilizzato per salvare # le variabili su disco, ad es. ~/variables.cfg [idle_timeout] \u00b6 Timeout di inattivit\u00e0. Viene automaticamente abilitato un timeout di inattivit\u00e0: aggiungi una sezione di configurazione di idle_timeout esplicita per modificare le impostazioni predefinite. [idle_timeout] #gcode: # Un elenco di comandi G-Code da eseguire in un timeout di # inattivit\u00e0. Vedi docs/Command Templates.md per il formato # G-Code. L'impostazione predefinita \u00e8 # eseguire \"TURN_OFF HEATERS\" e \"M84\". #timeout: 600 # Tempo di inattivit\u00e0 (in secondi) da attendere prima di eseguire # i comandi G-Code sopra. Il valore predefinito \u00e8 600 secondi. Funzionalit\u00e0 opzionali G-Code \u00b6 [virtual_sdcard] \u00b6 Una scheda SD virtuale pu\u00f2 essere utile se la macchina host non \u00e8 abbastanza veloce per eseguire bene OctoPrint. Consente al software host Klipper di stampare direttamente i file gcode archiviati in una directory sull'host utilizzando i comandi G-Code standard (ad esempio, M24). [virtual_sdcard] path: # The path of the local directory on the host machine to look for # g-code files. This is a read-only directory (sdcard file writes # are not supported). One may point this to OctoPrint's upload # directory (generally ~/.octoprint/uploads/ ). This parameter must # be provided. #on_error_gcode: # A list of G-Code commands to execute when an error is reported. # See docs/Command_Templates.md for G-Code format. The default is to # run TURN_OFF_HEATERS. [sdcard_loop] \u00b6 Alcune stampanti con funzionalit\u00e0 di pulizia del piatto, come un espulsore di parti o una stampante a nastro, possono trovare impiego nelle sezioni di loop del file sdcard. (Ad esempio, per stampare la stessa parte pi\u00f9 e pi\u00f9 volte, o ripetere la sezione a di una parte per una catena o un altro motivo ripetuto). Consulta il command reference per i comandi supportati. Vedere il file sample-macros.cfg per una macro M808 G-Code compatibile con Marlin. [sdcard_loop] [force_move] \u00b6 Supporta lo spostamento manuale dei motori passo-passo per scopi diagnostici. Nota, l'utilizzo di questa funzione potrebbe mettere la stampante in uno stato non valido - vedere il command reference per dettagli importanti. [force_move] #enable_force_move: False # Impostare su True per abilitare FORCE_MOVE e SET_KINEMATIC_POSITION # i comandi G-Code estesi. L'impostazione predefinita \u00e8 False. [pause_resume] \u00b6 Funzionalit\u00e0 di Pause/Resume con supporto di acquisizione e ripristino della posizione. Per ulteriori informazioni, vedere riferimento comando . [pause_resume] #recover_velocity: 50. # Quando si abilita pause_resume, la velocit\u00e0 con cui tornare alla # posizione catturata (in mm/s). Il valore predefinito \u00e8 50,0 mm/s. [firmware_retraction] \u00b6 Retrazione del filamento del firmware. Ci\u00f2 abilita i comandi GCODE G10 (ritiro) e G11 (non ritirati) emessi da molti slicer. I parametri seguenti forniscono le impostazioni predefinite di avvio, sebbene i valori possano essere regolati tramite il [comando] SET_RETRACTION (G-Codes.md#firmware_retraction)), consentendo l'impostazione e l'ottimizzazione del filamento a runtime. [firmware_retraction] #retract_length: 0 # La lunghezza del filamento (in mm) da ritrarre quando G10 # \u00e8 attivato e da ritrarre quando G11 \u00e8 attivato (ma vedere # unretract_extra_length di seguito). I# l valore predefinito \u00e8 0 mm. #retract_speed: 20 # La velocit\u00e0 di retrazione, in mm/s. # Il valore predefinito \u00e8 20 mm/s. #unretract_extra_length: 0 # La lunghezza (in mm) del filamento *aggiuntivo* da # sommare quando non si ritrae. #unretract_speed: 10 # La velocit\u00e0 di srotolamento, in mm/s. # Il valore predefinito \u00e8 10 mm/s. [gcode_arcs] \u00b6 Supporto per i comandi Gcode arc (G2/G3). [gcode_arcs] #resolution: 1.0 # Un arco sar\u00e0 diviso in segmenti. La lunghezza di ciascun segmento # sar\u00e0 uguale alla risoluzione in mm impostata sopra. Valori pi\u00f9 bassi # produrranno un arco pi\u00f9 fine, ma anche pi\u00f9 lavoro per la tua macchina. # Archi pi\u00f9 piccoli del valore configurato diventer\u00e0 linee rette. # L'impostazione predefinita \u00e8 # 1mm. [respond] \u00b6 Abilita i comandi estesi \"M118\" e \"RESPOND\" commands . [respond] #default_type: echo # Imposta il prefisso predefinito dell'output \"M118\" e \"RESPOND\" su uno dei seguenti: # echo: \"echo: \" (Questa \u00e8 l'impostazione predefinita) # command: \"// \" # error: \"!! \" #default_prefix: echo: # Imposta direttamente il prefisso predefinito. Se presente # questo valore sovrascriver\u00e0 il \"default_type\". [exclude_object] \u00b6 Abilita il supporto per escludere o cancellare singoli oggetti durante il processo di stampa. Per ulteriori informazioni, vedere la guida escludi oggetti e riferimento ai comandi . Vedere il file sample-macros.cfg per una macro G-Code M486 compatibile con Marlin/RepRapFirmware. [exclude_object] Compensazione della risonanza \u00b6 [input_shaper] \u00b6 Abilita compensazione della risonanza . Vedere anche il command reference . [input_shaper] #shaper_freq_x: 0 # Una frequenza (in Hz) dell'input shaper per l'asse X. Questa \u00e8 # solitamente una frequenza di risonanza dell'asse X che l'input # shaper dovrebbe sopprimere. Per shaper pi\u00f9 complessi, come # shaper di input EI a 2 e 3 gobbe, questo parametro pu\u00f2 essere # impostato in base a diverse considerazioni. # Il valore predefinito \u00e8 0, che disabilita la modellatura dell'input # per l'asse X. #shaper_freq_y: 0 # Una frequenza (in Hz) dell'input shaper per l'asse Y. Questa \u00e8 # solitamente una frequenza di risonanza dell'asse Y che l'input # shaper dovrebbe sopprimere. Per shaper pi\u00f9 complessi, come # shaper di input EI a 2 e 3 gobbe, questo parametro pu\u00f2 essere # impostato in base a diverse considerazioni. Il valore predefinito # \u00e8 0, che disabilita la modellatura dell'input per l'asse Y. #shaper_type: mzv # Un tipo di input shaper da utilizzare per entrambi gli assi X e Y. # Gli shaper supportati sono zv, mzv, zvd, ei, 2hump_ei e # 3hump_ei. L'impostazione predefinita \u00e8 mzv input shaper. #shaper_type_x: #shaper_type_y: # Se shaper_type non \u00e8 impostato, questi due parametri possono # essere utilizzati per configurare diversi shaper di input per gli # assi X e Y. Sono supportati gli stessi valori del parametro # shaper_type. #damping_ratio_x: 0.1 #damping_ratio_y: 0.1 # Rapporti di smorzamento delle vibrazioni degli assi X e Y # utilizzati dagli shaper di input per migliorare la soppressione # delle vibrazioni. Il valore predefinito \u00e8 0,1, un buon valore per la # maggior parte delle stampanti. Nella maggior parte dei casi # questo parametro non richiede ottimizzazione e # non deve essere modificato. [adxl345] \u00b6 Supporto per accelerometri ADXL345. Questo supporto consente di interrogare le misurazioni dell'accelerometro dal sensore. Ci\u00f2 abilita un comando ACCELEROMETER_MEASURE (consultare G-Codes per ulteriori informazioni). Il nome del chip predefinito \u00e8 \"predefinito\", ma \u00e8 possibile specificare un nome esplicito (ad esempio, [adxl345 my_chip_name]). [adxl345] cs_pin: # The SPI enable pin for the sensor. This parameter must be provided. #spi_speed: 5000000 # The SPI speed (in hz) to use when communicating with the chip. # The default is 5000000. #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. #axes_map: x, y, z # The accelerometer axis for each of the printer's X, Y, and Z axes. # This may be useful if the accelerometer is mounted in an # orientation that does not match the printer orientation. For # example, one could set this to \"y, x, z\" to swap the X and Y axes. # It is also possible to negate an axis if the accelerometer # direction is reversed (eg, \"x, z, -y\"). The default is \"x, y, z\". #rate: 3200 # Output data rate for ADXL345. ADXL345 supports the following data # rates: 3200, 1600, 800, 400, 200, 100, 50, and 25. Note that it is # not recommended to change this rate from the default 3200, and # rates below 800 will considerably affect the quality of resonance # measurements. [lis2dw] \u00b6 Support for LIS2DW accelerometers. [lis2dw] #cs_pin: # The SPI enable pin for the sensor. This parameter must be provided # if using SPI. #spi_speed: 5000000 # The SPI speed (in hz) to use when communicating with the chip. # The default is 5000000. #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. #i2c_address: # Default is 25 (0x19). If SA0 is high, it would be 24 (0x18) instead. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: 400000 # See the \"common I2C settings\" section for a description of the # above parameters. The default \"i2c_speed\" is 400000. #axes_map: x, y, z # See the \"adxl345\" section for information on this parameter. [lis3dh] \u00b6 Support for LIS3DH accelerometers. [lis3dh] #cs_pin: # The SPI enable pin for the sensor. This parameter must be provided # if using SPI. #spi_speed: 5000000 # The SPI speed (in hz) to use when communicating with the chip. # The default is 5000000. #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. #i2c_address: # Default is 25 (0x19). If SA0 is high, it would be 24 (0x18) instead. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: 400000 # See the \"common I2C settings\" section for a description of the # above parameters. The default \"i2c_speed\" is 400000. #axes_map: x, y, z # See the \"adxl345\" section for information on this parameter. [mpu9250] \u00b6 Supporto per accelerometri MPU-9250, MPU-9255, MPU-6515, MPU-6050 e MPU-6500 (\u00e8 possibile definire un numero qualsiasi di sezioni con un prefisso \"mpu9250\"). [mpu9250 my_accelerometer] #i2c_address: # Default is 104 (0x68). If AD0 is high, it would be 0x69 instead. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: 400000 # See the \"common I2C settings\" section for a description of the # above parameters. The default \"i2c_speed\" is 400000. #axes_map: x, y, z # See the \"adxl345\" section for information on this parameter. [resonance_tester] \u00b6 Supporto per test di risonanza e calibrazione automatica del input shaper. Per utilizzare la maggior parte delle funzionalit\u00e0 di questo modulo, devono essere installate dipendenze software aggiuntive; fare riferimento a Measuring Resonances e al command reference per ulteriori informazioni. Per ulteriori informazioni sul parametro max_smoothing e sul suo utilizzo, vedere la sezione Max smoothing della guida alla misurazione delle risonanze. [resonance_tester] #probe_points: # A list of X, Y, Z coordinates of points (one point per line) to test # resonances at. At least one point is required. Make sure that all # points with some safety margin in XY plane (~a few centimeters) # are reachable by the toolhead. #accel_chip: # A name of the accelerometer chip to use for measurements. If # adxl345 chip was defined without an explicit name, this parameter # can simply reference it as \"accel_chip: adxl345\", otherwise an # explicit name must be supplied as well, e.g. \"accel_chip: adxl345 # my_chip_name\". Either this, or the next two parameters must be # set. #accel_chip_x: #accel_chip_y: # Names of the accelerometer chips to use for measurements for each # of the axis. Can be useful, for instance, on bed slinger printer, # if two separate accelerometers are mounted on the bed (for Y axis) # and on the toolhead (for X axis). These parameters have the same # format as 'accel_chip' parameter. Only 'accel_chip' or these two # parameters must be provided. #max_smoothing: # Maximum input shaper smoothing to allow for each axis during shaper # auto-calibration (with 'SHAPER_CALIBRATE' command). By default no # maximum smoothing is specified. Refer to Measuring_Resonances guide # for more details on using this feature. #move_speed: 50 # The speed (in mm/s) to move the toolhead to and between test points # during the calibration. The default is 50. #min_freq: 5 # Minimum frequency to test for resonances. The default is 5 Hz. #max_freq: 133.33 # Maximum frequency to test for resonances. The default is 133.33 Hz. #accel_per_hz: 60 # This parameter is used to determine which acceleration to use to # test a specific frequency: accel = accel_per_hz * freq. Higher the # value, the higher is the energy of the oscillations. Can be set to # a lower than the default value if the resonances get too strong on # the printer. However, lower values make measurements of # high-frequency resonances less precise. The default value is 75 # (mm/sec). #hz_per_sec: 1 # Determines the speed of the test. When testing all frequencies in # range [min_freq, max_freq], each second the frequency increases by # hz_per_sec. Small values make the test slow, and the large values # will decrease the precision of the test. The default value is 1.0 # (Hz/sec == sec^-2). #sweeping_accel: 400 # An acceleration of slow sweeping moves. The default is 400 mm/sec^2. #sweeping_period: 1.2 # A period of slow sweeping moves. Setting this parameter to 0 # disables slow sweeping moves. Avoid setting it to a too small # non-zero value in order to not poison the measurements. # The default is 1.2 sec which is a good all-round choice. Helper per i file di configurazione \u00b6 [board_pins] \u00b6 Alias pin board (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"board_pins\"). Usalo per definire gli alias per i pin su un microcontrollore. [board_pins my_aliases] mcu: mcu # A comma separated list of micro-controllers that may use the # aliases. The default is to apply the aliases to the main \"mcu\". aliases: aliases_<name>: # A comma separated list of \"name=value\" aliases to create for the # given micro-controller. For example, \"EXP1_1=PE6\" would create an # \"EXP1_1\" alias for the \"PE6\" pin. However, if \"value\" is enclosed # in \"<>\" then \"name\" is created as a reserved pin (for example, # \"EXP1_9=<GND>\" would reserve \"EXP1_9\"). Any number of options # starting with \"aliases_\" may be specified. [include] \u00b6 Supporto per includere i file. Uno pu\u00f2 includere un file di configurazione aggiuntivo dal file di configurazione della stampante principale. Possono essere utilizzati anche caratteri jolly (ad es. \"configs/*.cfg\"). [include my_other_config.cfg] [duplicate_pin_override] \u00b6 Questo strumento consente di definire pi\u00f9 volte un singolo pin del microcontrollore in un file di configurazione senza il normale controllo degli errori. Questo \u00e8 inteso per scopi diagnostici e di debug. Questa sezione non \u00e8 necessaria laddove Klipper supporta l'utilizzo dello stesso pin pi\u00f9 volte e l'utilizzo di questa sostituzione pu\u00f2 causare risultati confusi e imprevisti. [duplicate_pin_override] pins: # Un elenco di pin separato da virgole che possono essere utilizzati pi\u00f9 volte in # un file di configurazione senza normali controlli degli errori. Questo parametro deve essere # fornito. Hardware per probing del piatto \u00b6 [probe] \u00b6 Sonda di altezza Z. Si pu\u00f2 definire questa sezione per abilitare l'hardware di rilevamento dell'altezza Z. Quando questa sezione \u00e8 abilitata, i comandi estesi PROBE e QUERY_PROBE comandi g-code diventano disponibili. Inoltre, vedere la Guida alla calibrazione della sonda . La sezione probe crea anche un pin virtuale \"probe:z_virtual_endstop\". Si pu\u00f2 impostare stepper_z endstop_pin su questo pin virtuale su stampanti in stile cartesiano che utilizzano la sonda al posto di un endstop z. Se si utilizza \"probe:z_virtual_endstop\", non definire un position_endstop nella sezione di configurazione stepper_z. [probe] pin: # Pin di rilevamento della sonda. Se il pin si trova su un # microcontrollore diverso rispetto agli stepper Z, abilita # \"homing multi-mcu\". Questo parametro deve essere fornito. #deactivate_on_each_sample: True # Questo determina se Klipper deve eseguire la disattivazione # gcode tra ogni tentativo di esplorazione durante l'esecuzione di # una sequenza di probe multiple. L'impostazione predefinita \u00e8 True. #x_offset: 0.0 # La distanza (in mm) tra la sonda e l'ugello lungo l'asse x. # Il valore predefinito \u00e8 0. #y_offset: 0.0 # La distanza (in mm) tra la sonda e l'ugello lungo l'asse y. # Il valore predefinito \u00e8 0. z_offset: # La distanza (in mm) tra il piatto e l'ugello quando la sonda si attiva. # Questo parametro deve essere fornito. #speed: 5.0 # Velocit\u00e0 (in mm/s) dell'asse Z durante probing. # Il valore predefinito \u00e8 5 mm/s. #samples: 1 # Il numero di volte in cui sondare ciascun punto. I valori z sondati # verranno mediati. L'impostazione predefinita \u00e8 sondare 1 volta. #sample_retract_dist: 2.0 # La distanza (in mm) per sollevare la testa di stampa tra ciascun # campione (se si esegue il campionamento pi\u00f9 di una volta). # Il valore predefinito \u00e8 2 mm. #lift_speed: # Velocit\u00e0 (in mm/s) dell'asse Z durante il sollevamento della sonda # tra i campioni. L'impostazione predefinita prevede l'utilizzo dello # stesso valore del parametro 'speed'. #samples_result: average # Il metodo di calcolo durante il campionamento pi\u00f9 di una volta: # \"median\" o \"average\". L'impostazione predefinita \u00e8 average. #samples_tolerance: 0.100 # La distanza Z massima (in mm) che un campione pu\u00f2 differire da # altri campioni. Se questa tolleranza viene superata, viene segnalato # un errore o il tentativo viene riavviato # (vedere samples_tolerance_retries). Il valore predefinito \u00e8 0,100 mm. #samples_tolerance_retries: 0 # Il numero di tentativi per riprovare se viene trovato un campione che # supera samples_tolerance. In un nuovo tentativo, tutti i campioni # correnti vengono eliminati e il tentativo di sonda viene riavviato. # Se non si ottiene un insieme valido di campioni nel numero di tentativi # specificato, viene segnalato un errore. Il valore predefinito \u00e8 zero che # causa la segnalazione di un errore sul primo campione che supera # samples_tolerance. #activate_gcode: # Un elenco di comandi G-Code da eseguire prima di ogni tentativo di # esplorazione. Vedi docs/Command_Templates.md per il formato # G-Code. Questo pu\u00f2 essere utile se la sonda deve essere attivata in # qualche modo. Non impartire qui alcun comando che sposti la testa # di stampa (ad es. G1). L'impostazione predefinita \u00e8 di non eseguire # alcun comando G-Code speciale all'attivazione. #deactivate_gcode: # Un elenco di comandi G-Code da eseguire dopo il completamento di # ogni tentativo di esplorazione. Vedi docs/Command_Templates.md # per il formato G-Code. Non impartire qui alcun comando che sposti # la testina. L'impostazione predefinita \u00e8 di non eseguire alcun # comando G-Code speciale alla disattivazione. [bltouch] \u00b6 Sonda BLTouch. Si pu\u00f2 definire questa sezione (anzich\u00e9 una sezione sonda) per abilitare una sonda BLTouch. Per ulteriori informazioni, vedere BL-Touch guide e command reference .. Viene anche creato un pin virtuale \"probe:z_virtual_endstop\" (consultare la sezione \"probe\" per i dettagli). [bltouch] sensor_pin: # Pin connected to the BLTouch sensor pin. Most BLTouch devices # require a pullup on the sensor pin (prefix the pin name with \"^\"). # This parameter must be provided. control_pin: # Pin connected to the BLTouch control pin. This parameter must be # provided. #pin_move_time: 0.680 # The amount of time (in seconds) to wait for the BLTouch pin to # move up or down. The default is 0.680 seconds. #stow_on_each_sample: True # This determines if Klipper should command the pin to move up # between each probe attempt when performing a multiple probe # sequence. Read the directions in docs/BLTouch.md before setting # this to False. The default is True. #probe_with_touch_mode: False # If this is set to True then Klipper will probe with the device in # \"touch_mode\". The default is False (probing in \"pin_down\" mode). #pin_up_reports_not_triggered: True # Set if the BLTouch consistently reports the probe in a \"not # triggered\" state after a successful \"pin_up\" command. This should # be True for all genuine BLTouch devices. Read the directions in # docs/BLTouch.md before setting this to False. The default is True. #pin_up_touch_mode_reports_triggered: True # Set if the BLTouch consistently reports a \"triggered\" state after # the commands \"pin_up\" followed by \"touch_mode\". This should be # True for all genuine BLTouch devices. Read the directions in # docs/BLTouch.md before setting this to False. The default is True. #set_output_mode: # Request a specific sensor pin output mode on the BLTouch V3.0 (and # later). This setting should not be used on other types of probes. # Set to \"5V\" to request a sensor pin output of 5 Volts (only use if # the controller board needs 5V mode and is 5V tolerant on its input # signal line). Set to \"OD\" to request the sensor pin output use # open drain mode. The default is to not request an output mode. #x_offset: #y_offset: #z_offset: #speed: #lift_speed: #samples: #sample_retract_dist: #samples_result: #samples_tolerance: #samples_tolerance_retries: # See the \"probe\" section for information on these parameters. [smart_effector] \u00b6 Lo \"Smart Effector\" di Duet3d implementa una sonda Z utilizzando un sensore di forza. Si pu\u00f2 definire questa sezione invece di [probe] per abilitare le funzioni specifiche di Smart Effector. Ci\u00f2 consente anche a comandi di runtime di regolare i parametri di Smart Effector in fase di esecuzione. [smart_effector] pin: # Pin collegato al pin di uscita della sonda Z Smart Effector (pin 5). Si noti # che la resistenza di pullup sulla scheda generalmente non \u00e8 richiesta. # Tuttavia, se il pin di uscita \u00e8 collegato al pin della scheda con un resistore # di pullup, tale resistore deve essere di valore elevato (ad es. 10K Ohm o pi\u00f9). # Alcune schede hanno un resistore di pullup di basso valore sull'ingresso # della sonda Z, che probabilmente far\u00e0 risultare in uno stato di sonda sempre # attivato. In questo caso, collegare lo Smart Effector a un pin diverso sulla # scheda. Questo parametro \u00e8 obbligatorio. #control_pin: # Pin collegato al pin di ingresso di controllo Smart Effector (pin 7). Se fornito, # diventano disponibili i comandi di programmazione della sensibilit\u00e0 # di Smart Effector. #probe_accel: # Se impostato, limita l'accelerazione dei movimenti di tastatura (in mm/sec^2). # Un'improvvisa grande accelerazione all'inizio del movimento di esplorazione # pu\u00f2 causare l'attivazione spuria della sonda, specialmente se l'hotend \u00e8 pesante. # Per evitarlo, potrebbe essere necessario ridurre l'accelerazione dei movimenti # di tastatura tramite questo parametro. #recovery_time: 0.4 # Un ritardo tra i movimenti di spostamento e tastatura in secondi. Un # movimento veloce prima della tastatura pu\u00f2 causare l'attivazione spuria della # sonda. Ci\u00f2 pu\u00f2 causare errori \"Sonda attivata prima del movimento\" se non # \u00e8 impostato alcun ritardo. Il valore 0 disabilita il ritardo di ripristino. # Il valore predefinito \u00e8 0.4. #x_offset: #y_offset: # Dovrebbe essere lasciato non impostato (o impostato su 0). z_offset: # Altezza di attivazione della sonda. Inizia con -0.1 (mm) e regola in seguito # usando il comando `PROBE_CALIBRATE`. Questo parametro deve essere fornito. #speed: # Velocit\u00e0 (in mm/s) dell'asse Z durante la tastatura. Si consiglia di iniziare con la # velocit\u00e0 di tastatura di 20 mm/s e di regolarla secondo necessit\u00e0 per migliorare la # precisione e la ripetibilit\u00e0 dell'attivazione della sonda. #samples: #sample_retract_dist: #samples_result: #samples_tolerance: #samples_tolerance_retries: #activate_gcode: #deactivate_gcode: #deactivate_on_each_sample: # Vedere la sezione \"probe\" per ulteriori informazioni sui parametri di cui sopra. [probe_eddy_current] \u00b6 Support for eddy current inductive probes. One may define this section (instead of a probe section) to enable this probe. See the command reference for further information. [probe_eddy_current my_eddy_probe] sensor_type: ldc1612 # The sensor chip used to perform eddy current measurements. This # parameter must be provided and must be set to ldc1612. #intb_pin: # MCU gpio pin connected to the ldc1612 sensor's INTB pin (if # available). The default is to not use the INTB pin. #z_offset: # The nominal distance (in mm) between the nozzle and bed that a # probing attempt should stop at. This parameter must be provided. #i2c_address: #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # The i2c settings for the sensor chip. See the \"common I2C # settings\" section for a description of the above parameters. #x_offset: #y_offset: #speed: #lift_speed: #samples: #sample_retract_dist: #samples_result: #samples_tolerance: #samples_tolerance_retries: # See the \"probe\" section for information on these parameters. [axis_twist_compensation] \u00b6 A tool to compensate for inaccurate probe readings due to twist in X or Y gantry. See the Axis Twist Compensation Guide for more detailed information regarding symptoms, configuration and setup. [axis_twist_compensation] #speed: 50 # The speed (in mm/s) of non-probing moves during the calibration. # The default is 50. #horizontal_move_z: 5 # The height (in mm) that the head should be commanded to move to # just prior to starting a probe operation. The default is 5. calibrate_start_x: 20 # Defines the minimum X coordinate of the calibration # This should be the X coordinate that positions the nozzle at the starting # calibration position. calibrate_end_x: 200 # Defines the maximum X coordinate of the calibration # This should be the X coordinate that positions the nozzle at the ending # calibration position. calibrate_y: 112.5 # Defines the Y coordinate of the calibration # This should be the Y coordinate that positions the nozzle during the # calibration process. This parameter is recommended to # be near the center of the bed # For Y-axis twist compensation, specify the following parameters: calibrate_start_y: ... # Defines the minimum Y coordinate of the calibration # This should be the Y coordinate that positions the nozzle at the starting # calibration position for the Y axis. This parameter must be provided if # compensating for Y axis twist. calibrate_end_y: ... # Defines the maximum Y coordinate of the calibration # This should be the Y coordinate that positions the nozzle at the ending # calibration position for the Y axis. This parameter must be provided if # compensating for Y axis twist. calibrate_x: ... # Defines the X coordinate of the calibration for Y axis twist compensation # This should be the X coordinate that positions the nozzle during the # calibration process for Y axis twist compensation. This parameter must be # provided and is recommended to be near the center of the bed. Motori passo-passo ed estrusori aggiuntivi \u00b6 [stepper_z1] \u00b6 Assi multi-stepper. Su una stampante in stile cartesiano, lo stepper che controlla un dato asse pu\u00f2 avere blocchi di configurazione aggiuntivi che definiscono gli stepper che dovrebbero essere azionati insieme allo stepper primario. Si pu\u00f2 definire un numero qualsiasi di sezioni con un suffisso numerico che inizia da 1 (ad esempio, \"stepper_z1\", \"stepper_z2\", ecc.). [stepper_z1] #step_pin: #dir_pin: #enable_pin: #microsteps: #rotation_distance: # Vedere la sezione \"stepper\" per la definizione dei parametri di cui sopra. #endstop_pin: # Se viene definito un endstop_pin per lo stepper aggiuntivo, lo stepper # si fermer\u00e0 fino all'attivazione dell'endstop. In caso contrario, lo stepper # si fermer\u00e0 fino a quando non verr\u00e0 attivato il finecorsa sullo stepper # primario per l'asse. [extruder1] \u00b6 In una stampante multiestrusore aggiungere una sezione estrusore aggiuntiva per ogni estrusore aggiuntivo. Le sezioni aggiuntive dell'estrusore devono essere denominate \"extruder1\", \"extruder2\", \"extruder3\" e cos\u00ec via. Vedere la sezione \"extruder\" per una descrizione dei parametri disponibili. Vedere sample-multi-extruder.cfg per un esempio di configurazione. [extruder1] #step_pin: #dir_pin: #... # Vedere la sezione \"estrusore\" per i parametri per lo stepper e il riscaldatore # disponibili. #shared_heater: # Questa opzione \u00e8 obsoleta e non deve pi\u00f9 essere specificata. [dual_carriage] \u00b6 Support for cartesian and hybrid_corexy/z printers with dual carriages on a single axis. The carriage mode can be set via the SET_DUAL_CARRIAGE extended g-code command. For example, \"SET_DUAL_CARRIAGE CARRIAGE=1\" command will activate the carriage defined in this section (CARRIAGE=0 will return activation to the primary carriage). Dual carriage support is typically combined with extra extruders - the SET_DUAL_CARRIAGE command is often called at the same time as the ACTIVATE_EXTRUDER command. Be sure to park the carriages during deactivation. Note that during G28 homing, typically the primary carriage is homed first followed by the carriage defined in the [dual_carriage] config section. However, the [dual_carriage] carriage will be homed first if both carriages home in a positive direction and the [dual_carriage] carriage has a position_endstop greater than the primary carriage, or if both carriages home in a negative direction and the [dual_carriage] carriage has a position_endstop less than the primary carriage. Inoltre, \u00e8 possibile utilizzare i comandi \"SET_DUAL_CARRIAGE CARRIAGE=1 MODE=COPY\" o \"SET_DUAL_CARRIAGE CARRIAGE=1 MODE=MIRROR\" per attivare la modalit\u00e0 di copia o di mirroring del doppio carrello, nel qual caso seguir\u00e0 di conseguenza il movimento del carrello 0 . Questi comandi possono essere utilizzati per stampare due parti contemporaneamente: due parti identiche (in modalit\u00e0 COPIA) o parti specchiate (in modalit\u00e0 SPECCHIO). Tieni presente che le modalit\u00e0 COPY e MIRROR richiedono anche la configurazione appropriata dell'estrusore sul doppio carrello, che in genere pu\u00f2 essere ottenuta con \"SYNC_EXTRUDER_MOTION MOTION_QUEUE=extruder EXTRUDER= \" o un comando simile. Vedere sample-idex.cfg per un esempio di configurazione. [dual_carriage] axis: # The axis this extra carriage is on (either x or y). This parameter # must be provided. #safe_distance: # The minimum distance (in mm) to enforce between the dual and the primary # carriages. If a G-Code command is executed that will bring the carriages # closer than the specified limit, such a command will be rejected with an # error. If safe_distance is not provided, it will be inferred from # position_min and position_max for the dual and primary carriages. If set # to 0 (or safe_distance is unset and position_min and position_max are # identical for the primary and dual carraiges), the carriages proximity # checks will be disabled. #step_pin: #dir_pin: #enable_pin: #microsteps: #rotation_distance: #endstop_pin: #position_endstop: #position_min: #position_max: # See the \"stepper\" section for the definition of the above parameters. [extruder_stepper] \u00b6 Supporto per stepper aggiuntivi sincronizzati al movimento di un estrusore (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"extruder_stepper\"). Per ulteriori informazioni, vedere riferimento comando . [extruder_stepper my_extra_stepper] extruder: # L'estrusore con cui \u00e8 sincronizzato questo stepper. Se questo \u00e8 impostato su # una stringa vuota, lo stepper non verr\u00e0 sincronizzato con un # estrusore. Questo parametro deve essere fornito. #step_pin: #dir_pin: #enable_pin: #microsteps: #rotation_distance: # Vedere la sezione \"stepper\" per la definizione dei parametri sopra. # . [Stepper manuali] \u00b6 Stepper manuali (\u00e8 possibile definire un numero qualsiasi di sezioni con un prefisso \"manual_stepper\"). Questi sono stepper controllati dal comando g-code MANUAL_STEPPER. Ad esempio: \"MANUAL_STEPPER STEPPER=my_stepper MOVE=10 SPEED=5\". Vedere il file G-Codes per una descrizione del comando MANUAL_STEPPER. Gli stepper non sono collegati alla normale cinematica della stampante. [manual_stepper my_stepper] #step_pin: #dir_pin: #enable_pin: #microsteps: #rotation_distance: # Vedere la sezione \"stepper\" per una descrizione di questi parametri. #velocity: # Impostare la velocit\u00e0 predefinita (in mm/s) per lo stepper. Questo # valore verr\u00e0 utilizzato se un comando MANUAL_STEPPER non specifica # un parametro SPEED. Il valore predefinito \u00e8 5 mm/s. #accel: # Imposta l'accelerazione predefinita (in mm/s^2) per lo stepper. # Un'accelerazione pari a zero non risulter\u00e0 in nessuna accelerazione. # Questo valore verr\u00e0 utilizzato se un comando MANUAL_STEPPER non # specifica un parametro ACCEL. Il valore predefinito \u00e8 zero. #endstop_pin: # Pin di rilevamento interruttore di fine corsa. Se specificato, \u00e8 possibile # eseguire \"movimenti di riferimento\" aggiungendo un parametro # STOP_ON_ENDSTOP ai comandi di movimento MANUAL_STEPPER. Riscaldatori e sensori personalizzati \u00b6 [verify_heater] \u00b6 Verifica riscaldatore e sensore di temperatura. La verifica del riscaldatore viene abilitata automaticamente per ogni riscaldatore configurato sulla stampante. Usa le sezioni di verifica_riscaldatore per modificare le impostazioni predefinite. [verify_heater heater_config_name] #max_error: 120 # Il massimo \"errore di temperatura cumulativo\" prima di generare un # errore. Valori pi\u00f9 piccoli comportano un controllo pi\u00f9 rigoroso e valori # pi\u00f9 grandi consentono pi\u00f9 tempo prima che venga segnalato un errore. # Nello specifico la temperatura viene osservata una volta al secondo e # se \u00e8 prossima alla temperatura target viene azzerato un \"contatore errori\" # interno; in caso contrario, se la temperatura \u00e8 inferiore all'intervallo target, # il contatore viene aumentato della quantit\u00e0 in cui la temperatura riportata # differisce da tale intervallo. Se il contatore supera questo \"errore_max\", # viene generato un errore. Il valore predefinito \u00e8 120. #check_gain_time: # Questo controlla la verifica del riscaldatore durante il riscaldamento # iniziale. Valori pi\u00f9 piccoli comportano un controllo pi\u00f9 rigoroso e valori # pi\u00f9 grandi consentono pi\u00f9 tempo prima che venga segnalato un errore. # In particolare, durante il riscaldamento iniziale, fintanto che il riscaldatore # aumenta di temperatura entro questo intervallo di tempo (specificato in # secondi), il \"contatore errori\" interno viene azzerato. Il valore predefinito # \u00e8 20 secondi per gli estrusori e 60 secondi per heater_bed. #hysteresis: 5 # La differenza di temperatura massima (in gradi Celsius) rispetto a una # temperatura target considerata nell'intervallo del target. Questo controlla # nell'intervallo max_error. \u00c8 raro personalizzare questo valore. # L'impostazione predefinita \u00e8 5. #heating_gain: 2 # La temperatura minima (in gradi Celsius) di cui il riscaldatore deve # aumentare durante il check_gain_time. \u00c8 raro personalizzare questo valore. # L'impostazione predefinita \u00e8 2. [homing_heaters] \u00b6 Strumento per disabilitare i riscaldatori durante l'homing o la probing di un asse. [homing_heaters] #steppers: # Un elenco separato da virgole di stepper che dovrebbero causare # la disattivazione dei riscaldatori. L'impostazione predefinita \u00e8 # disabilitare i riscaldatori per qualsiasi spostamento di homing/sonda. # Esempio tipico: stepper_z #heaters: # Un elenco separato da virgole di riscaldatori da disabilitare # durante i movimenti di homing/probing. L'impostazione # predefinita \u00e8 disabilitare tutti i riscaldatori. # Esempio tipico: estrusore, letto riscaldatore [thermistor] \u00b6 Termistori personalizzati (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"thermistor\"). \u00c8 possibile utilizzare un termistore personalizzato nel campo sensor_type di una sezione di configurazione del riscaldatore. (Ad esempio, se si definisce una sezione \"[thermistor my_thermistor]\", \u00e8 possibile utilizzare un \"sensor_type: my_thermistor\" quando si definisce un riscaldatore.) Assicurati di posizionare la sezione del termistore nel file di configurazione sopra il suo primo utilizzo in una sezione del riscaldatore . [thermistor my_thermistor] #temperature1: #resistance1: #temperature2: #resistance2: #temperature3: #resistance3: # Tre misure di resistenza (in Ohm) alle temperature date (in Celsius). # Le tre misurazioni verranno utilizzate per calcolare i coefficienti di # Steinhart-Hart per il termistore. Questi parametri devono essere # forniti quando si utilizza Steinhart-Hart per definire il termistore. #beta: # In alternativa, \u00e8 possibile definire temperatura1, resistenza1 e beta # per definire i parametri del termistore. Questo parametro deve # essere fornito quando si utilizza \"beta\" per definire il termistore. [adc_temperature] \u00b6 Sensori di temperatura ADC personalizzati (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"adc_temperature\"). Ci\u00f2 consente di definire un sensore di temperatura personalizzato che misura una tensione su un pin del convertitore da analogico a digitale (ADC) e utilizza l'interpolazione lineare tra una serie di misurazioni di temperatura/tensione (o temperatura/resistenza) configurate per determinare la temperatura. Il sensore risultante pu\u00f2 essere utilizzato come tipo_sensore in una sezione riscaldatore. (Ad esempio, se si definisce una sezione \"[adc_temperature my_sensor]\", \u00e8 possibile utilizzare un \"sensor_type: my_sensor\" quando si definisce un riscaldatore.) Assicurati di posizionare la sezione del sensore nel file di configurazione sopra il suo primo utilizzo in una sezione del riscaldatore. [adc_temperature my_sensor] #temperature1: #voltage1: #temperature2: #voltage2: #... # A set of temperatures (in Celsius) and voltages (in Volts) to use # as reference when converting a temperature. A heater section using # this sensor may also specify adc_voltage and voltage_offset # parameters to define the ADC voltage (see \"Common temperature # amplifiers\" section for details). At least two measurements must # be provided. #temperature1: #resistance1: #temperature2: #resistance2: #... # Alternatively one may specify a set of temperatures (in Celsius) # and resistance (in Ohms) to use as reference when converting a # temperature. A heater section using this sensor may also specify a # pullup_resistor parameter (see \"extruder\" section for details). At # least two measurements must be provided. [heater_generic] \u00b6 Riscaldatori generici (si pu\u00f2 definire un numero qualsiasi di sezioni con il prefisso \"riscaldatore_generico\"). Questi riscaldatori si comportano in modo simile ai riscaldatori standard (estrusori, piatti riscaldati). Utilizzare il comando SET_HEATER_TEMPERATURE (consultare G-Codes per i dettagli) per impostare la temperatura target. [heater_generic my_generic_heater] #gcode_id: # L'ID da utilizzare quando si riporta la temperatura nel comando M105. # Questo parametro deve essere fornito. #max_power: #sensor_type: #sensor_pin: #smooth_time: #control: #pid_Kp: #pid_Ki: #pid_Kd: #pwm_cycle_time: #min_temp: #max_temp: # Vedere la sezione \"extruder\" per la definizione dei parametri sopra. [temperature_sensor] \u00b6 Sensori di temperatura generici. \u00c8 possibile definire un numero qualsiasi di sensori di temperatura aggiuntivi che vengono riportati tramite il comando M105. [temperature_sensor my_sensor] #sensor_type: #sensor_pin: #min_temp: #max_temp: # Vedi la sezione \"extruder\" per la definizione dei parametri # sopra indicati. #gcode_id: # Vedi la sezione \"heater_generic\" per la definizione dei # parametri sopra indicati. [temperature_probe] \u00b6 Reports probe coil temperature. Includes optional thermal drift calibration for eddy current based probes. A [temperature_probe] section may be linked to a [probe_eddy_current] by using the same postfix for both sections. [temperature_probe my_probe] #sensor_type: #sensor_pin: #min_temp: #max_temp: # Temperature sensor configuration. # See the \"extruder\" section for the definition of the above # parameters. #smooth_time: # A time value (in seconds) over which temperature measurements will # be smoothed to reduce the impact of measurement noise. The default # is 2.0 seconds. #gcode_id: # See the \"heater_generic\" section for the definition of this # parameter. #speed: # The travel speed [mm/s] for xy moves during calibration. Default # is the speed defined by the probe. #horizontal_move_z: # The z distance [mm] from the bed at which xy moves will occur # during calibration. Default is 2mm. #resting_z: # The z distance [mm] from the bed at which the tool will rest # to heat the probe coil during calibration. Default is .4mm #calibration_position: # The X, Y, Z position where the tool should be moved when # probe drift calibration initializes. This is the location # where the first manual probe will occur. If omitted, the # default behavior is not to move the tool prior to the first # manual probe. #calibration_bed_temp: # The maximum safe bed temperature (in C) used to heat the probe # during probe drift calibration. When set, the calibration # procedure will turn on the bed after the first sample is # taken. When the calibration procedure is complete the bed # temperature will be set to zero. When omitted the default # behavior is not to set the bed temperature. #calibration_extruder_temp: # The extruder temperature (in C) set probe during drift calibration. # When this option is supplied the procedure will wait for until the # specified temperature is reached before requesting the first manual # probe. When the calibration procedure is complete the extruder # temperature will be set to 0. When omitted the default behavior is # not to set the extruder temperature. #extruder_heating_z: 50. # The Z location where extruder heating will occur if the # \"calibration_extruder_temp\" option is set. Its recommended to heat # the extruder some distance from the bed to minimize its impact on # the probe coil temperature. The default is 50. #max_validation_temp: 60. # The maximum temperature used to validate the calibration. It is # recommended to set this to a value between 100 and 120 for enclosed # printers. The default is 60. Sensori di temperatura \u00b6 Klipper include definizioni per molti tipi di sensori di temperatura. Questi sensori possono essere utilizzati in qualsiasi sezione di configurazione che richieda un sensore di temperatura (come una sezione [extruder] o [heater_bed] ). Termistori comuni \u00b6 Termistori comuni. I seguenti parametri sono disponibili nelle sezioni del riscaldatore che utilizzano uno di questi sensori. sensor_type: # Uno di \"EPCOS 100K B57560G104F\", \"ATC Semitec 104GT-2\", # \"ATC Semitec 104NT-4-R025H42G\", \"Generic 3950\", # \"Honeywell 100K 135-104LAG-J01\", \"NTC 100K MGB18-104F39050L32\", # \"SliceEngineering 450\", o \"TDK NTCG104LH104JT1\" sensor_pin: # Pin di ingresso analogico collegato al termistore. # Questo parametro deve essere fornito. #pullup_resistor: 4700 # La resistenza (in ohm) del pullup collegato al termistore. # Il valore predefinito \u00e8 4700 ohm. #inline_resistor: 0 # La resistenza (in ohm) di un resistore aggiuntivo (non a variazione di # calore) posizionato in linea con il termistore. \u00c8 raro impostare questo. # Il valore predefinito \u00e8 0 ohm. Amplificatori di temperatura comuni \u00b6 Amplificatori di temperatura comuni. I seguenti parametri sono disponibili nelle sezioni del riscaldatore che utilizzano uno di questi sensori. sensor_type: # Uno tra \"PT100 INA826\", \"AD595\", \"AD597\", \"AD8494\", \"AD8495\", # \"AD8496\", o \"AD8497\". sensor_pin: # Pin di ingresso analogico collegato al sensore. Questo parametro # deve essere fornito. #adc_voltage: 5.0 # La tensione di confronto dell'ADC (in Volt). Il valore predefinito # \u00e8 5 volt. #voltage_offset: 0 # L'offset di tensione ADC (in Volt). Il valore predefinito \u00e8 0. Sensore PT1000 collegato direttamente \u00b6 Sensore PT1000 collegato direttamente. I seguenti parametri sono disponibili nelle sezioni del riscaldatore che utilizzano uno di questi sensori. sensor_type: PT1000 sensor_pin: # Pin di ingresso analogico collegato al sensore. Questo parametro # deve essere fornito. #pullup_resistor: 4700 # La resistenza (in ohm) del pullup collegato al sensore. Il valore # predefinito \u00e8 4700 ohm. Sensori di temperatura MAXxxxxx \u00b6 Sensori temperatura MAXxxxxx con interfaccia periferica seriale (SPI). I seguenti parametri sono disponibili nelle sezioni del riscaldatore che utilizzano uno di questi tipi di sensore. sensor_type: # Uno tra \"MAX6675\", \"MAX31855\", \"MAX31856\", o \"MAX31865\". sensor_pin: # Il pin mcu collegato al pin di selezione del chip del sensore. # Questo parametro deve essere fornito. #spi_speed: 4000000 # La velocit\u00e0 SPI (in hz) da utilizzare durante la comunicazione # con il chip. Il valore predefinito \u00e8 4000000. #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # Vedere la sezione \"impostazioni comuni SPI\" per una # descrizione dei parametri di cui sopra. #tc_type: K #tc_use_50Hz_filter: False #tc_averaging_count: 1 # I parametri di cui sopra controllano i parametri del sensore # dei chip MAX31856. I valori predefiniti per ciascun parametro # sono accanto al nome del parametro nell'elenco precedente. #rtd_nominal_r: 100 #rtd_reference_r: 430 #rtd_num_of_wires: 2 #rtd_use_50Hz_filter: False # I parametri di cui sopra controllano i parametri del sensore dei # chip MAX31865. I valori predefiniti per ciascun parametro sono # accanto al nome del parametro nell'elenco precedente. BMP180/BMP280/BME280/BMP388/BME680 temperature sensor \u00b6 BMP180/BMP280/BME280/BMP388/BME680 two wire interface (I2C) environmental sensors. Note that these sensors are not intended for use with extruders and heater beds, but rather for monitoring ambient temperature (C), pressure (hPa), relative humidity and in case of the BME680 gas level. See sample-macros.cfg for a gcode_macro that may be used to report pressure and humidity in addition to temperature. sensor_type: BME280 #i2c_address: # Default is 118 (0x76). The BMP180, BMP388 and some BME280 sensors # have an address of 119 (0x77). #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. Sensore temperatura AHT10/AHT20/AHT21 \u00b6 Sensori ambientali con interfaccia a due fili (I2C) AHT10/AHT20/AHT21. Si noti che questi sensori non sono destinati all'uso con estrusori e letti riscaldanti, ma piuttosto per il monitoraggio della temperatura ambiente (C) e dell'umidit\u00e0 relativa. Vedi sample-macros.cfg per un gcode_macro che pu\u00f2 essere utilizzato per segnalare l'umidit\u00e0 oltre alla temperatura. sensor_type: AHT10 # Also use AHT10 for AHT20 and AHT21 sensors. #i2c_address: # Default is 56 (0x38). Some AHT10 sensors give the option to use # 57 (0x39) by moving a resistor. #i2c_mcu: #i2c_bus: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #aht10_report_time: # Interval in seconds between readings. Default is 30, minimum is 5 Sensore HTU21D \u00b6 Sensore ambientale con interfaccia a due fili (I2C) della famiglia HTU21D. Si noti che questo sensore non \u00e8 destinato all'uso con estrusori e letti riscaldanti, ma piuttosto per il monitoraggio della temperatura ambiente (C) e dell'umidit\u00e0 relativa(%). Vedere sample-macros.cfg per una gcode_macro che pu\u00f2 essere utilizzata per riportare l'umidit\u00e0 oltre alla temperatura. sensor_type: # Must be \"HTU21D\" , \"SI7013\", \"SI7020\", \"SI7021\" or \"SHT21\" #i2c_address: # Default is 64 (0x40). #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #htu21d_hold_master: # If the sensor can hold the I2C buf while reading. If True no other # bus communication can be performed while reading is in progress. # Default is False. #htu21d_resolution: # The resolution of temperature and humidity reading. # Valid values are: # 'TEMP14_HUM12' -> 14bit for Temp and 12bit for humidity # 'TEMP13_HUM10' -> 13bit for Temp and 10bit for humidity # 'TEMP12_HUM08' -> 12bit for Temp and 08bit for humidity # 'TEMP11_HUM11' -> 11bit for Temp and 11bit for humidity # Default is: \"TEMP11_HUM11\" #htu21d_report_time: # Interval in seconds between readings. Default is 30 SHT3X sensor \u00b6 SHT3X family two wire interface (I2C) environmental sensor. These sensors have a range of -55~125 C, so are usable for e.g. chamber temperature monitoring. They can also function as simple fan/heater controllers. sensor_type: SHT3X #i2c_address: # Default is 68 (0x44). #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. Sensore di temperatura LM75 \u00b6 Sensori di temperatura (I2C) LM75/LM75A. Questi sensori hanno una gamma di -55~125 C, quindi sono utilizzabili ad es. monitoraggio della temperatura della camera. Possono anche funzionare come semplici controller per ventole/riscaldatori. sensor_type: LM75 #i2c_address: # Default is 72 (0x48). Normal range is 72-79 (0x48-0x4F) and the 3 # low bits of the address are configured via pins on the chip # (usually with jumpers or hard wired). #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #lm75_report_time: # Interval in seconds between readings. Default is 0.8, with minimum # 0.5. Sensore di temperatura integrato nel microcontrollore \u00b6 I microcontrollori atsam, atsamd e stm32 contengono un sensore di temperatura interno. \u00c8 possibile utilizzare il sensore \"temperature_mcu\" per monitorare queste temperature. sensor_type: temperature_mcu #sensor_mcu: mcu # Il microcontrollore da cui leggere. L'impostazione predefinita \u00e8 \"mcu\". #sensor_temperature1: #sensor_adc1: # Specificare i due parametri precedenti (una temperatura in gradi # Celsius e un valore ADC come float compreso tra 0,0 e 1,0) per # calibrare la temperatura del microcontrollore. Ci\u00f2 potrebbe # migliorare la precisione della temperatura riportata su alcuni chip. # Un modo tipico per ottenere queste informazioni di calibrazione # consiste nel rimuovere completamente l'alimentazione dalla # stampante per alcune ore (per assicurarsi che sia alla temperatura # ambiente), quindi accenderla e utilizzare il comando QUERY_ADC # per ottenere una misurazione ADC. Utilizzare un altro sensore di # temperatura sulla stampante per trovare la temperatura ambiente # corrispondente. L'impostazione predefinita consiste nell'utilizzare # i dati di calibrazione di fabbrica sul microcontrollore (se applicabile) # o i valori nominali dalle specifiche del microcontrollore. #sensor_temperature2: #sensor_adc2: # Se viene specificato sensor_temperature1/sensor_adc1, \u00e8 anche # possibile specificare i dati di calibrazione sensor_temperature2/sensor_adc2. # Ci\u00f2 potrebbe fornire informazioni calibrate sulla \"curva della # temperatura\". L'impostazione predefinita consiste nell'utilizzare i dati # di calibrazione di fabbrica sul microcontrollore (se applicabile) o i # valori nominali dalle specifiche del microcontrollore. Sensore di temperatura host \u00b6 Temperatura dalla macchina (es. Raspberry Pi) che esegue il software host. sensor_type: temperature_host #sensor_path: # il percorso del file di sistema della temperatura. L'impostazione # predefinita \u00e8 \"/sys/class/thermal/thermal_zone0/temp\" che \u00e8 il file di # sistema della temperatura su un computer Raspberry Pi. Sensore di temperatura DS18B20 \u00b6 DS18B20 \u00e8 un sensore di temperatura digitale a 1 filo (w1). Si noti che questo sensore non \u00e8 destinato all'uso con estrusori e letti riscaldanti, ma piuttosto per il monitoraggio della temperatura ambiente (C). Questi sensori hanno una portata fino a 125 C, quindi sono utilizzabili ad es. monitoraggio della temperatura della camera. Possono anche funzionare come semplici controller per ventole/riscaldatori. I sensori DS18B20 sono supportati solo su \"host mcu\", ad es. il Raspberry Pi. \u00c8 necessario installare il modulo del kernel Linux w1-gpio. sensor_type: DS18B20 serial_no: # Ogni dispositivo a 1 filo ha un numero di serie univoco utilizzato per # identificare il dispositivo, solitamente nel formato 28-031674b175ff. Questo # parametro deve essere fornito. I dispositivi collegati a 1 filo possono essere # elencati utilizzando il seguente comando Linux: ls /sys/bus/w1/devices/ #ds18_report_time: # Intervallo in secondi tra le letture. Il valore predefinito \u00e8 3.0, con un # minimo di 1.0 #sensor_mcu: # Il microcontrollore da cui leggere. Deve essere host_mcu Combined temperature sensor \u00b6 Combined temperature sensor is a virtual temperature sensor based on several other sensors. This sensor can be used with extruders, heater_generic and heater beds. sensor_type: temperature_combined #sensor_list: # Must be provided. List of sensors to combine to new \"virtual\" # sensor. # E.g. 'temperature_sensor sensor1,extruder,heater_bed' #combination_method: # Must be provided. Combination method used for the sensor. # Available options are 'max', 'min', 'mean'. #maximum_deviation: # Must be provided. Maximum permissible deviation between the sensors # to combine (e.g. 5 degrees). To disable it, use a large value (e.g. 999.9) Ventole \u00b6 [fan] \u00b6 Ventola di raffreddamento della stampa. [fan] pin: # Pin di output che controlla la ventola. Questo parametro deve essere fornito. #max_power: 1.0 # La potenza massima (espressa come un valore compreso tra 0.0 e 1.0) a # cui pu\u00f2 essere impostato il pin. Il valore 1.0 consente di impostare il pin # completamente abilitato per periodi prolungati, mentre un valore di 0.5 # consentirebbe di abilitare il pin per non pi\u00f9 della met\u00e0 del tempo. Questa # impostazione pu\u00f2 essere utilizzata per limitare la potenza totale (per # periodi prolungati) della ventola. Se questo valore \u00e8 inferiore a 1.0, le # richieste di velocit\u00e0 della ventola verranno ridimensionate tra zero e # max_power (ad esempio, se max_power \u00e8 0.9 e viene richiesta una # velocit\u00e0 della ventola dell'80%, la potenza della ventola verr\u00e0 impostata # su 72%). L'impostazione predefinita \u00e8 1.0. #shutdown_speed: 0 # La velocit\u00e0 della ventola desiderata (espressa come valore da 0.0 a # 1.0) se il software del microcontrollore entra in uno stato di errore. # Il valore predefinito \u00e8 0. #cycle_time: 0.010 # La quantit\u00e0 di tempo (in secondi) per ogni ciclo di alimentazione PWM # alla ventola. Si consiglia di essere pari o superiore a 10 millisecondi # quando si utilizza il PWM basato su software. # Il valore predefinito \u00e8 0,010 secondi. #hardware_pwm: False # Abilitare questa opzione per utilizzare PWM hardware anzich\u00e9 PWM # software. La maggior parte delle ventole non funziona bene con PWM # hardware, quindi non \u00e8 consigliabile abilitarlo a meno che non vi sia # un requisito elettrico per passare a velocit\u00e0 molto elevate. Quando # si utilizza l'hardware PWM, il tempo di ciclo effettivo \u00e8 vincolato # dall'implementazione e pu\u00f2 essere notevolmente diverso dal tempo # di ciclo richiesto. L'impostazione predefinita \u00e8 False. #kick_start_time: 0.100 # Tempo (in secondi) per far funzionare la ventola a piena velocit\u00e0 # quando la si abilita per la prima volta o la si aumenta di oltre il 50% # (aiuta a far girare la ventola). Il valore predefinito \u00e8 0,100 secondi. #off_below: 0.0 # La velocit\u00e0 minima in input che alimenter\u00e0 la ventola (espressa # come un valore da 0.0 a 1.0). Quando viene richiesta una velocit\u00e0 # inferiore a off_below la ventola verr\u00e0 invece spenta. Questa # impostazione pu\u00f2 essere utilizzata per prevenire lo stallo della # ventola e per garantire che i kick start siano efficaci. # Il valore predefinito \u00e8 0.0. # # Questa impostazione deve essere ricalibrata ogni volta che # max_power viene regolato. Per calibrare questa impostazione, # inizia con off_below impostato su 0.0 e la ventola gira. Abbassare # gradualmente la velocit\u00e0 della ventola per determinare la velocit\u00e0 # di ingresso pi\u00f9 bassa che aziona la ventola in modo affidabile senza # stalli. Impostare off_below al duty cycle corrispondente a questo # valore (ad esempio, 12% -> 0,12) o leggermente superiore. #tachometer_pin: # Pin di ingresso contagiri per il monitoraggio della velocit\u00e0 della # ventola. In genere \u00e8 richiesto un pullup. Questo parametro \u00e8 facoltativo. #tachometer_ppr: 2 # Quando viene specificato tachometer_pin, questo \u00e8 il numero di # impulsi per giro del segnale del tachimetro. Per una ventola BLDC # questo \u00e8 normalmente la met\u00e0 del numero di poli. # L'impostazione predefinita \u00e8 2. #tachometer_poll_interval: 0.0015 # Quando viene specificato tachometer_pin, questo \u00e8 il periodo di polling # del pin del contagiri, in secondi. Il valore predefinito \u00e8 0.0015, che \u00e8 # abbastanza veloce per le ventole al di sotto di 10000 RPM a 2 PPR. Deve # essere inferiore a 30/(tachometer_ppr*rpm), con un certo margine, # dove rpm \u00e8 la velocit\u00e0 massima (in RPM) della ventola. #enable_pin: # Pin opzionale per abilitare l'alimentazione alla ventola. Questo pu\u00f2 # essere utile per le ventole con ingressi PWM dedicati. Alcune di queste # ventole rimangono accese anche allo 0% di ingresso PWM. In tal caso, # il pin PWM pu\u00f2 essere utilizzato normalmente e ad es. un FET commutato # a terra (pin della ventola standard) pu\u00f2 essere utilizzato per controllare # l'alimentazione alla ventola. [heater_fan] \u00b6 Ventole di raffreddamento del riscaldatore (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"heater_fan\"). Una \"ventola riscaldatore\" \u00e8 una ventola che verr\u00e0 abilitata ogni volta che il riscaldatore associato \u00e8 attivo. Per impostazione predefinita, un heater_fan ha una velocit\u00e0 di spegnimento pari a max_power. [heater_fan heatbreak_cooling_fan] #pin: #max_power: #shutdown_speed: #cycle_time: #hardware_pwm: #kick_start_time: #off_below: #tachometer_pin: #tachometer_ppr: #tachometer_poll_interval: #enable_pin: # See the \"fan\" section for a description of the above parameters. #heater: extruder # Name of the config section defining the heater that this fan is # associated with. If a comma separated list of heater names is # provided here, then the fan will be enabled when any of the given # heaters are enabled. The default is \"extruder\". #heater_temp: 50.0 # A temperature (in Celsius) that the heater must drop below before # the fan is disabled. The default is 50 Celsius. #fan_speed: 1.0 # The fan speed (expressed as a value from 0.0 to 1.0) that the fan # will be set to when its associated heater is enabled. The default # is 1.0 [controller_fan] \u00b6 Ventola di raffreddamento del controller (\u00e8 possibile definire un numero qualsiasi di sezioni con il prefisso \"controller_fan\"). Una \"ventola del controller\" \u00e8 una ventola che verr\u00e0 abilitata ogni volta che il riscaldatore associato o il driver stepper associato \u00e8 attivo. La ventola si fermer\u00e0 ogni volta che viene raggiunto un idle_timeout per garantire che non si verifichi alcun surriscaldamento dopo la disattivazione di un componente osservato. [controller_fan my_controller_fan] #pin: #max_power: #shutdown_speed: #cycle_time: #hardware_pwm: #kick_start_time: #off_below: #tachometer_pin: #tachometer_ppr: #tachometer_poll_interval: #enable_pin: # Vedere la sezione \"fan\" per una descrizione dei parametri di cui sopra. #fan_speed: 1.0 # La velocit\u00e0 della ventola (espressa come un valore compreso tra 0.0 e # 1.0) a cui verr\u00e0 impostata la ventola quando \u00e8 attivo un riscaldatore # o un driver passo-passo. L'impostazione predefinita \u00e8 1.0 #idle_timeout: # La quantit\u00e0 di tempo (in secondi) dopo che un driver passo-passo o # un riscaldatore \u00e8 stato attivo per la quale la ventola deve essere tenuta # in funzione. L'impostazione predefinita \u00e8 30 secondi. #idle_speed: # La velocit\u00e0 della ventola (espressa come un valore compreso tra 0.0 # e 1.0) a cui verr\u00e0 impostata la ventola quando era attivo un riscaldatore # o un driver passo-passo e prima che venga raggiunto l'idle_timeout. # L'impostazione predefinita \u00e8 fan_speed. #heater: #stepper: # Nome della sezione di configurazione che definisce il riscaldatore/ # stepper a cui \u00e8 associata questa ventola. Se qui viene fornito un # elenco separato da virgole di nomi di riscaldatori/stepper, la ventola # sar\u00e0 abilitata quando uno qualsiasi dei riscaldatori/stepper indicati # \u00e8 abilitato. Il riscaldatore predefinito \u00e8 \"estrusore\", lo stepper # predefinito sono tutti. [temperature_fan] \u00b6 Ventole di raffreddamento attivate dalla temperatura (\u00e8 possibile definire un numero qualsiasi di sezioni con un prefisso \"temperature_fan\"). Una \"ventola di temperatura\" \u00e8 una ventola che verr\u00e0 abilitata ogni volta che il sensore associato \u00e8 al di sopra di una temperatura impostata. Per impostazione predefinita, una ventola_temperatura ha una velocit\u00e0_di_arresto pari a potenza_massima. Per ulteriori informazioni, vedere command reference . [temperature_fan my_temp_fan] #pin: #max_power: #shutdown_speed: #cycle_time: #hardware_pwm: #kick_start_time: #off_below: #tachometer_pin: #tachometer_ppr: #tachometer_poll_interval: #enable_pin: # Vedere la sezione \"fan\" per una descrizione dei parametri di cui sopra. #sensor_type: #sensor_pin: #control: #max_delta: #min_temp: #max_temp: # Vedere la sezione \"extruder\" per una descrizione dei parametri di cui sopra. #pid_Kp: #pid_Ki: #pid_Kd: # Le impostazioni proporzionale (pid_Kp), integrale (pid_Ki) e derivata (pid_Kd) # per il sistema di controllo del feedback PID. Klipper valuta le impostazioni PID # con la seguente formula generale: fan_pwm = max_power - (Kp*e + Ki*integral(e) # - Kd*derivative(e)) / 255 Dove \"e\" \u00e8 \"target_temperature - measure_temperature\" # e \"fan_pwm\" \u00e8 la frequenza della ventola richiesta con 0.0 per spento e 1.0 al # massimo. I parametri pid_Kp, pid_Ki e pid_Kd devono essere forniti quando l# 'algoritmo di controllo PID \u00e8 abilitato. #pid_deriv_time: 2.0 # Un valore di tempo (in secondi) su cui le misurazioni della temperatura verranno # livellate quando si utilizza l'algoritmo di controllo PID. Ci\u00f2 pu\u00f2 ridurre l'impatto # del rumore di misurazione. Il valore predefinito \u00e8 2 secondi. #target_temp: 40.0 # Una temperatura (in Celsius) che sar\u00e0 la temperatura target. # L'impostazione predefinita \u00e8 40 gradi. #max_speed: 1.0 # La velocit\u00e0 della ventola (espressa come un valore compreso tra 0.0 e 1.0) a cui # verr\u00e0 impostata la ventola quando la temperatura del sensore supera il valore # impostato. L'impostazione predefinita \u00e8 1.0. #min_speed: 0.3 # La velocit\u00e0 minima della ventola (espressa come un valore compreso tra 0.0 e # 1.0) alla quale la ventola verr\u00e0 impostata per le ventole con temperatura PID. # Il valore predefinito \u00e8 0.3. #gcode_id: # Se impostata, la temperatura verr\u00e0 riportata nelle query M105 utilizzando l'id # fornito. L'impostazione predefinita \u00e8 di non riportare la temperatura tramite M105. [fan_generic] \u00b6 Ventola a controllo manuale (si pu\u00f2 definire un numero qualsiasi di sezioni con il prefisso \"fan_generic\"). La velocit\u00e0 di una ventola controllata manualmente viene impostata con SET_FAN_SPEED comando gcode . [fan_generic extruder_partfan] #pin: #max_power: #shutdown_speed: #cycle_time: #hardware_pwm: #kick_start_time: #off_below: #tachometer_pin: #tachometer_ppr: #tachometer_poll_interval: #enable_pin: # Vedere la sezione \"fan\" per una descrizione dei parametri di cui sopra. LEDs \u00b6 [led] \u00b6 Supporto per LED (e strisce LED) controllati tramite pin PWM del microcontrollore (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"led\"). Per ulteriori informazioni, vedere command reference . [led my_led] #red_pin: #green_pin: #blue_pin: #white_pin: # Il pin che controlla il colore del LED specificato. Deve essere fornito # almeno uno dei parametri sopra indicati. #cycle_time: 0.010 # La quantit\u00e0 di tempo (in secondi) per ciclo PWM. Si consiglia che sia # pari o superiore a 10 millisecondi quando si utilizza il PWM basato # su software. Il valore predefinito \u00e8 0,010 secondi. #hardware_pwm: False # Abilitare questa opzione per utilizzare PWM hardware anzich\u00e9 PWM # software. Quando si utilizza l'hardware PWM, il tempo di ciclo effettivo # \u00e8 vincolato dall'implementazione e pu\u00f2 essere notevolmente diverso # dal tempo di ciclo richiesto. L'impostazione predefinita \u00e8 Falso. #initial_RED: 0.0 #initial_GREEN: 0.0 #initial_BLUE: 0.0 #initial_WHITE: 0.0 # Imposta il colore iniziale del LED. Ciascun valore deve essere # compreso tra 0,0 e 1,0. Il valore predefinito per ogni colore \u00e8 0. [neopixel] \u00b6 Supporto LED Neopixel (aka WS2812) (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"neopixel\"). Per ulteriori informazioni, vedere riferimento comando . Si noti che l'implementazione di linux mcu non supporta attualmente i neopixel collegati direttamente. L'attuale design che utilizza l'interfaccia del kernel Linux non consente questo scenario perch\u00e9 l'interfaccia GPIO del kernel non \u00e8 sufficientemente veloce da fornire le frequenze di impulso richieste. [neopixel my_neopixel] pin: # Il pin collegato al neopixel. Questo parametro deve essere fornito. #chain_count: # Il numero di chip Neopixel che sono \"collegati a margherita\" al # pin fornito. Il valore predefinito \u00e8 1 (che indica che un solo # Neopixel \u00e8 collegato al pin). #color_order: GRB # Impostare l'ordine dei pixel richiesto dall'hardware del LED # (utilizzando una stringa contenente le lettere R, G, B, W con W # opzionale). In alternativa, questo pu\u00f2 essere un elenco separato # da virgole di pixel, uno per ogni LED nella catena. # L'impostazione predefinita \u00e8 GRB. #initial_RED: 0.0 #initial_GREEN: 0.0 #initial_BLUE: 0.0 #initial_WHITE: 0.0 # Vedere la sezione \"led\" per informazioni su questi parametri. [dotstar] \u00b6 Supporto LED Dotstar (conosciuti anche come APA102) (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"dotstar\"). Per ulteriori informazioni, vedere command reference . [dotstar my_dotstar] data_pin: # Il pin connesso alla data line del dotstar. Questo parametro # deve essere fornito. clock_pin: # Il pin connesso alla clock line del dotstar. Questo parametro # deve essere fornito. #chain_count: # Vedere la sezione \"neopixel\" per informazioni su questo parametro. #initial_RED: 0.0 #initial_GREEN: 0.0 #initial_BLUE: 0.0 # Vedere la sezione \"led\" per informazioni su questo parametro. [pca9533] \u00b6 PCA9533 Supporto LED. Il PCA9533 viene utilizzato sulla scheda mightyboard. [pca9533 my_pca9533] #i2c_address: 98 # The i2c address that the chip is using on the i2c bus. Use 98 for # the PCA9533/1, 99 for the PCA9533/2. The default is 98. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #initial_RED: 0.0 #initial_GREEN: 0.0 #initial_BLUE: 0.0 #initial_WHITE: 0.0 # See the \"led\" section for information on these parameters. [pca9632] \u00b6 Supporto LED PCA9632. Il PCA9632 viene utilizzato su FlashForge Dreamer. [pca9632 my_pca9632] #i2c_address: 98 # The i2c address that the chip is using on the i2c bus. This may be # 96, 97, 98, or 99. The default is 98. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #scl_pin: #sda_pin: # Alternatively, if the pca9632 is not connected to a hardware I2C # bus, then one may specify the \"clock\" (scl_pin) and \"data\" # (sda_pin) pins. The default is to use hardware I2C. #color_order: RGBW # Set the pixel order of the LED (using a string containing the # letters R, G, B, W). The default is RGBW. #initial_RED: 0.0 #initial_GREEN: 0.0 #initial_BLUE: 0.0 #initial_WHITE: 0.0 # See the \"led\" section for information on these parameters. Servocomandi aggiuntivi, pulsanti e altri pin \u00b6 [servo] \u00b6 Servo (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"servo\"). I servo possono essere controllati usando SET_SERVO comando g-code . Ad esempio: SET_SERVO SERVO=my_servo ANGLE=180 [servo my_servo] pin: # Pin di uscita PWM che controlla il servo. Questo parametro deve # essere fornito. #maximum_servo_angle: 180 # L'angolo massimo (in gradi) a cui questo servo pu\u00f2 essere impostato. # L'impostazione predefinita \u00e8 180 gradi. #minimum_pulse_width: 0.001 # La durata minima dell'impulso (in secondi). Questo dovrebbe # corrispondere a un angolo di 0 gradi. Il valore predefinito \u00e8 0.001 secondi. #maximum_pulse_width: 0.002 # La durata massima dell'impulso (in secondi). Questo dovrebbe # corrispondere a un angolo di maximum_servo_angle. Il valore # predefinito \u00e8 0.002 secondi. #initial_angle: # Angolo iniziale (in gradi) su cui impostare il servo. L'impostazione # predefinita \u00e8 di non inviare alcun segnale all'avvio. #initial_pulse_width: # Durata iniziale dell'impulso (in secondi) su cui impostare il servo. # (Questo \u00e8 valido solo se initial_angle non \u00e8 impostato.) # L'impostazione predefinita \u00e8 di non inviare alcun segnale all'avvio. [gcode_button] \u00b6 Esegui gcode quando un pulsante viene premuto o rilasciato (o quando un pin cambia stato). Puoi controllare lo stato del pulsante usando QUERY_BUTTON button=my_gcode_button . [gcode_button my_gcode_button] pin: # Il pin su cui \u00e8 collegato il pulsante. Questo parametro deve essere fornito. #analog_range: # Due resistenze separate da virgole (in Ohm) che specificano l'intervallo # di resistenza minimo e massimo per il pulsante. Se viene fornito # analog_range, il pin deve essere un pin con capacit\u00e0 analogica. # L'impostazione predefinita \u00e8 utilizzare digital gpio per il pulsante. #analog_pullup_resistor: # La resistenza di pullup (in Ohm) quando \u00e8 specificato analog_range. # Il valore predefinito \u00e8 4700 ohm. #press_gcode: # Un elenco di comandi G-Code da eseguire quando si preme il pulsante. # I modelli G-Code sono supportati. Questo parametro deve essere fornito. #release_gcode: # Un elenco di comandi G-Code da eseguire quando il pulsante viene # rilasciato. I modelli G-Code sono supportati. L'impostazione predefinita # \u00e8 di non eseguire alcun comando al rilascio di un pulsante. [output_pin] \u00b6 Pin di uscita configurabili in fase di run-time (\u00e8 possibile definire un numero qualsiasi di sezioni con un prefisso \"output_pin\"). I pin configurati qui verranno impostati come pin di output e sar\u00e0 possibile modificarli in fase di esecuzione utilizzando il comando esteso \"SET_PIN PIN=my_pin VALUE=.1\" comandi g-code . [output_pin my_pin] pin: # The pin to configure as an output. This parameter must be # provided. #pwm: False # Set if the output pin should be capable of pulse-width-modulation. # If this is true, the value fields should be between 0 and 1; if it # is false the value fields should be either 0 or 1. The default is # False. #value: # The value to initially set the pin to during MCU configuration. # The default is 0 (for low voltage). #shutdown_value: # The value to set the pin to on an MCU shutdown event. The default # is 0 (for low voltage). #cycle_time: 0.100 # The amount of time (in seconds) per PWM cycle. It is recommended # this be 10 milliseconds or greater when using software based PWM. # The default is 0.100 seconds for pwm pins. #hardware_pwm: False # Enable this to use hardware PWM instead of software PWM. When # using hardware PWM the actual cycle time is constrained by the # implementation and may be significantly different than the # requested cycle_time. The default is False. #scale: # This parameter can be used to alter how the 'value' and # 'shutdown_value' parameters are interpreted for pwm pins. If # provided, then the 'value' parameter should be between 0.0 and # 'scale'. This may be useful when configuring a PWM pin that # controls a stepper voltage reference. The 'scale' can be set to # the equivalent stepper amperage if the PWM were fully enabled, and # then the 'value' parameter can be specified using the desired # amperage for the stepper. The default is to not scale the 'value' # parameter. #maximum_mcu_duration: #static_value: # These options are deprecated and should no longer be specified. [pwm_tool] \u00b6 Pulse width modulation digital output pins capable of high speed updates (one may define any number of sections with an \"output_pin\" prefix). Pins configured here will be setup as output pins and one may modify them at run-time using \"SET_PIN PIN=my_pin VALUE=.1\" type extended g-code commands . [pwm_tool my_tool] pin: # The pin to configure as an output. This parameter must be provided. #maximum_mcu_duration: # The maximum duration a non-shutdown value may be driven by the MCU # without an acknowledge from the host. # If host can not keep up with an update, the MCU will shutdown # and set all pins to their respective shutdown values. # Default: 0 (disabled) # Usual values are around 5 seconds. #value: #shutdown_value: #cycle_time: 0.100 #hardware_pwm: False #scale: # See the \"output_pin\" section for the definition of these parameters. [pwm_cycle_time] \u00b6 Run-time configurable output pins with dynamic pwm cycle timing (one may define any number of sections with an \"pwm_cycle_time\" prefix). Pins configured here will be setup as output pins and one may modify them at run-time using \"SET_PIN PIN=my_pin VALUE=.1 CYCLE_TIME=0.100\" type extended g-code commands . [pwm_cycle_time my_pin] pin: #value: #shutdown_value: #cycle_time: 0.100 #scale: # See the \"output_pin\" section for information on these parameters. [static_digital_output] \u00b6 Pin di uscita digitali configurati staticamente (\u00e8 possibile definire un numero qualsiasi di sezioni con un prefisso \"static_digital_output\"). I pin configurati qui verranno impostati come uscita GPIO durante la configurazione dell'MCU. Non possono essere modificati in fase di esecuzione. [static_digital_output my_output_pins] pins: # Un elenco separato da virgole di pin da impostare come pin di # output GPIO. Il pin verr\u00e0 impostato su un livello alto a meno che il # nome del pin non sia preceduto da \"!\". Questo parametro deve # essere fornito. [multi_pin] \u00b6 Uscite a pin multipli (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"multi_pin\"). Un output multi_pin crea un alias pin interno che pu\u00f2 modificare pi\u00f9 pin di output ogni volta che viene impostato il pin alias. Ad esempio, si potrebbe definire un oggetto \"[multi_pin my_fan]\" contenente due pin e quindi impostare \"pin=multi_pin:my_fan\" nella sezione \"[fan]\" - ad ogni cambio di ventola entrambi i pin di output verrebbero aggiornati. Questi alias non possono essere utilizzati con i pin del motore passo-passo. [multi_pin my_multi_pin] pins: # Un elenco separato da virgole di pin associati a questo alias. # Questo parametro deve essere fornito. Configurazione del driver TMC per stepper \u00b6 Configurazione dei driver per motori passo-passo Trinamic in modalit\u00e0 UART/SPI. Ulteriori informazioni si trovano nella TMC Drivers guide e nel command reference . [tmc2130] \u00b6 Configurare un driver per motore passo-passo TMC2130 tramite bus SPI. Per utilizzare questa funzione, definire una sezione di configurazione con un prefisso \"tmc2130\" seguito dal nome della sezione di configurazione dello stepper corrispondente (ad esempio, \"[tmc2130 stepper_x]\"). [tmc2130 stepper_x] cs_pin: # The pin corresponding to the TMC2130 chip select line. This pin # will be set to low at the start of SPI messages and raised to high # after the message completes. This parameter must be provided. #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. #chain_position: #chain_length: # These parameters configure an SPI daisy chain. The two parameters # define the stepper position in the chain and the total chain length. # Position 1 corresponds to the stepper that connects to the MOSI signal. # The default is to not use an SPI daisy chain. #interpolate: True # If true, enable step interpolation (the driver will internally # step at a rate of 256 micro-steps). This interpolation does # introduce a small systemic positional deviation - see # TMC_Drivers.md for details. The default is True. run_current: # The amount of current (in amps RMS) to configure the driver to use # during stepper movement. This parameter must be provided. #hold_current: # The amount of current (in amps RMS) to configure the driver to use # when the stepper is not moving. Setting a hold_current is not # recommended (see TMC_Drivers.md for details). The default is to # not reduce the current. #sense_resistor: 0.110 # The resistance (in ohms) of the motor sense resistor. The default # is 0.110 ohms. #stealthchop_threshold: 0 # The velocity (in mm/s) to set the \"stealthChop\" threshold to. When # set, \"stealthChop\" mode will be enabled if the stepper motor # velocity is below this value. The default is 0, which disables # \"stealthChop\" mode. #coolstep_threshold: # The velocity (in mm/s) to set the TMC driver internal \"CoolStep\" # threshold to. If set, the coolstep feature will be enabled when # the stepper motor velocity is near or above this value. Important # - if coolstep_threshold is set and \"sensorless homing\" is used, # then one must ensure that the homing speed is above the coolstep # threshold! The default is to not enable the coolstep feature. #high_velocity_threshold: # The velocity (in mm/s) to set the TMC driver internal \"high # velocity\" threshold (THIGH) to. This is typically used to disable # the \"CoolStep\" feature at high speeds. The default is to not set a # TMC \"high velocity\" threshold. #driver_MSLUT0: 2863314260 #driver_MSLUT1: 1251300522 #driver_MSLUT2: 608774441 #driver_MSLUT3: 269500962 #driver_MSLUT4: 4227858431 #driver_MSLUT5: 3048961917 #driver_MSLUT6: 1227445590 #driver_MSLUT7: 4211234 #driver_W0: 2 #driver_W1: 1 #driver_W2: 1 #driver_W3: 1 #driver_X1: 128 #driver_X2: 255 #driver_X3: 255 #driver_START_SIN: 0 #driver_START_SIN90: 247 # These fields control the Microstep Table registers directly. The optimal # wave table is specific to each motor and might vary with current. An # optimal configuration will have minimal print artifacts caused by # non-linear stepper movement. The values specified above are the default # values used by the driver. The value must be specified as a decimal integer # (hex form is not supported). In order to compute the wave table fields, # see the tmc2130 \"Calculation Sheet\" from the Trinamic website. #driver_IHOLDDELAY: 8 #driver_TPOWERDOWN: 0 #driver_TBL: 1 #driver_TOFF: 4 #driver_HEND: 7 #driver_HSTRT: 0 #driver_VHIGHFS: 0 #driver_VHIGHCHM: 0 #driver_PWM_AUTOSCALE: True #driver_PWM_FREQ: 1 #driver_PWM_GRAD: 4 #driver_PWM_AMPL: 128 #driver_SGT: 0 #driver_SEMIN: 0 #driver_SEUP: 0 #driver_SEMAX: 0 #driver_SEDN: 0 #driver_SEIMIN: 0 #driver_SFILT: 0 # Set the given register during the configuration of the TMC2130 # chip. This may be used to set custom motor parameters. The # defaults for each parameter are next to the parameter name in the # above list. #diag0_pin: #diag1_pin: # The micro-controller pin attached to one of the DIAG lines of the # TMC2130 chip. Only a single diag pin should be specified. The pin # is \"active low\" and is thus normally prefaced with \"^!\". Setting # this creates a \"tmc2130_stepper_x:virtual_endstop\" virtual pin # which may be used as the stepper's endstop_pin. Doing this enables # \"sensorless homing\". (Be sure to also set driver_SGT to an # appropriate sensitivity value.) The default is to not enable # sensorless homing. [tmc2208] \u00b6 Configurare un driver per motore passo-passo TMC2208 (o TMC2224) tramite UART a filo singolo. Per utilizzare questa funzione, definire una sezione di configurazione con un prefisso \"tmc2208\" seguito dal nome della sezione di configurazione dello stepper corrispondente (ad esempio, \"[tmc2208 stepper_x]\"). [tmc2208 stepper_x] uart_pin: # The pin connected to the TMC2208 PDN_UART line. This parameter # must be provided. #tx_pin: # If using separate receive and transmit lines to communicate with # the driver then set uart_pin to the receive pin and tx_pin to the # transmit pin. The default is to use uart_pin for both reading and # writing. #select_pins: # A comma separated list of pins to set prior to accessing the # tmc2208 UART. This may be useful for configuring an analog mux for # UART communication. The default is to not configure any pins. #interpolate: True # If true, enable step interpolation (the driver will internally # step at a rate of 256 micro-steps). This interpolation does # introduce a small systemic positional deviation - see # TMC_Drivers.md for details. The default is True. run_current: # The amount of current (in amps RMS) to configure the driver to use # during stepper movement. This parameter must be provided. #hold_current: # The amount of current (in amps RMS) to configure the driver to use # when the stepper is not moving. Setting a hold_current is not # recommended (see TMC_Drivers.md for details). The default is to # not reduce the current. #sense_resistor: 0.110 # The resistance (in ohms) of the motor sense resistor. The default # is 0.110 ohms. #stealthchop_threshold: 0 # The velocity (in mm/s) to set the \"stealthChop\" threshold to. When # set, \"stealthChop\" mode will be enabled if the stepper motor # velocity is below this value. The default is 0, which disables # \"stealthChop\" mode. #driver_MULTISTEP_FILT: True #driver_IHOLDDELAY: 8 #driver_TPOWERDOWN: 20 #driver_TBL: 2 #driver_TOFF: 3 #driver_HEND: 0 #driver_HSTRT: 5 #driver_PWM_AUTOGRAD: True #driver_PWM_AUTOSCALE: True #driver_PWM_LIM: 12 #driver_PWM_REG: 8 #driver_PWM_FREQ: 1 #driver_PWM_GRAD: 14 #driver_PWM_OFS: 36 # Set the given register during the configuration of the TMC2208 # chip. This may be used to set custom motor parameters. The # defaults for each parameter are next to the parameter name in the # above list. [tmc2209] \u00b6 Configurare un driver per motore passo-passo TMC2209 tramite UART a filo singolo. Per utilizzare questa funzione, definire una sezione di configurazione con un prefisso \"tmc2209\" seguito dal nome della sezione di configurazione dello stepper corrispondente (ad esempio, \"[tmc2209 stepper_x]\"). [tmc2209 stepper_x] uart_pin: #tx_pin: #select_pins: #interpolate: True run_current: #hold_current: #sense_resistor: 0.110 #stealthchop_threshold: 0 # See the \"tmc2208\" section for the definition of these parameters. #coolstep_threshold: # The velocity (in mm/s) to set the TMC driver internal \"CoolStep\" # threshold to. If set, the coolstep feature will be enabled when # the stepper motor velocity is near or above this value. Important # - if coolstep_threshold is set and \"sensorless homing\" is used, # then one must ensure that the homing speed is above the coolstep # threshold! The default is to not enable the coolstep feature. #uart_address: # The address of the TMC2209 chip for UART messages (an integer # between 0 and 3). This is typically used when multiple TMC2209 # chips are connected to the same UART pin. The default is zero. #driver_MULTISTEP_FILT: True #driver_IHOLDDELAY: 8 #driver_TPOWERDOWN: 20 #driver_TBL: 2 #driver_TOFF: 3 #driver_HEND: 0 #driver_HSTRT: 5 #driver_PWM_AUTOGRAD: True #driver_PWM_AUTOSCALE: True #driver_PWM_LIM: 12 #driver_PWM_REG: 8 #driver_PWM_FREQ: 1 #driver_PWM_GRAD: 14 #driver_PWM_OFS: 36 #driver_SGTHRS: 0 #driver_SEMIN: 0 #driver_SEUP: 0 #driver_SEMAX: 0 #driver_SEDN: 0 #driver_SEIMIN: 0 # Set the given register during the configuration of the TMC2209 # chip. This may be used to set custom motor parameters. The # defaults for each parameter are next to the parameter name in the # above list. #diag_pin: # The micro-controller pin attached to the DIAG line of the TMC2209 # chip. The pin is normally prefaced with \"^\" to enable a pullup. # Setting this creates a \"tmc2209_stepper_x:virtual_endstop\" virtual # pin which may be used as the stepper's endstop_pin. Doing this # enables \"sensorless homing\". (Be sure to also set driver_SGTHRS to # an appropriate sensitivity value.) The default is to not enable # sensorless homing. [tmc2660] \u00b6 Configurare un driver per motore passo-passo TMC2660 tramite bus SPI. Per utilizzare questa funzione, definire una sezione di configurazione con un prefisso tmc2660 seguito dal nome della sezione di configurazione dello stepper corrispondente (ad esempio, \"[tmc2660 stepper_x]\"). [tmc2660 stepper_x] cs_pin: # Il pin corrispondente al pin di selezione del chip TMC2660. Questo pin # verr\u00e0 impostato su basso all'inizio dei messaggi SPI e impostato su # alto al termine del trasferimento del messaggio. Questo parametro # deve essere fornito. #spi_speed: 4000000 # Frequenza bus SPI utilizzata per comunicare con il driver # passo-passo TMC2660. Il valore predefinito \u00e8 4000000. #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # Vedere la sezione \"impostazioni comuni SPI\" per una descrizione # dei parametri di cui sopra. #interpolate: True # Se true, abilita l'interpolazione del passo (il driver eseguir\u00e0 un passo # interno a una velocit\u00e0 di 256 micropassi). Funziona solo se microsteps # \u00e8 impostato su 16. L'interpolazione introduce una piccola deviazione # posizionale sistemica - vedere TMC_Drivers.md per i dettagli. # L'impostazione predefinita \u00e8 Vero. run_current: # La quantit\u00e0 di corrente (in ampere RMS) utilizzata dal driver durante # il movimento passo-passo. Questo parametro deve essere fornito. #sense_resistor: # La resistenza (in ohm) del resistore di rilevamento del motore. # Questo parametro deve essere fornito. #idle_current_percent: 100 # La percentuale di run_current a cui il driver stepper sar\u00e0 ridotto allo # scadere del timeout di inattivit\u00e0 (\u00e8 necessario impostare il timeout # utilizzando una sezione di configurazione [idle_timeout]). La corrente # verr\u00e0 nuovamente aumentata una volta che lo stepper dovr\u00e0 muoversi # di nuovo. Assicurati di impostarlo su un valore sufficientemente alto in # modo che gli stepper non perdano la loro posizione. C'\u00e8 anche un piccolo # ritardo fino a quando la corrente non viene nuovamente aumentata, # quindi tienine conto quando comandi mosse veloci mentre lo stepper \u00e8 # al minimo. Il valore predefinito \u00e8 100 (nessuna riduzione). #driver_TBL: 2 #driver_RNDTF: 0 #driver_HDEC: 0 #driver_CHM: 0 #driver_HEND: 3 #driver_HSTRT: 3 #driver_TOFF: 4 #driver_SEIMIN: 0 #driver_SEDN: 0 #driver_SEMAX: 0 #driver_SEUP: 0 #driver_SEMIN: 0 #driver_SFILT: 0 #driver_SGT: 0 #driver_SLPH: 0 #driver_SLPL: 0 #driver_DISS2G: 0 #driver_TS2G: 3 # Imposta il parametro indicato durante la configurazione del chip TMC2660. # Questo pu\u00f2 essere utilizzato per impostare parametri del driver personalizzati. # Le impostazioni predefinite per ogni parametro sono accanto al nome del # parametro nell'elenco sopra. Vedere la scheda tecnica del TMC2660 su cosa # fa ogni parametro e quali sono le restrizioni sulle combinazioni di parametri. # Prestare particolare attenzione al registro CHOPCONF, dove l'impostazione # di CHM su zero o uno comporter\u00e0 modifiche al layout (il primo bit di HDEC) # viene interpretato come MSB di HSTRT in questo caso). [tmc2240] \u00b6 Configure a TMC2240 stepper motor driver via SPI bus or UART. To use this feature, define a config section with a \"tmc2240\" prefix followed by the name of the corresponding stepper config section (for example, \"[tmc2240 stepper_x]\"). [tmc2240 stepper_x] cs_pin: # The pin corresponding to the TMC2240 chip select line. This pin # will be set to low at the start of SPI messages and raised to high # after the message completes. This parameter must be provided. #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. #uart_pin: # The pin connected to the TMC2240 DIAG1/SW line. If this parameter # is provided UART communication is used rather then SPI. #chain_position: #chain_length: # These parameters configure an SPI daisy chain. The two parameters # define the stepper position in the chain and the total chain length. # Position 1 corresponds to the stepper that connects to the MOSI signal. # The default is to not use an SPI daisy chain. #interpolate: True # If true, enable step interpolation (the driver will internally # step at a rate of 256 micro-steps). The default is True. run_current: # The amount of current (in amps RMS) to configure the driver to use # during stepper movement. This parameter must be provided. #hold_current: # The amount of current (in amps RMS) to configure the driver to use # when the stepper is not moving. Setting a hold_current is not # recommended (see TMC_Drivers.md for details). The default is to # not reduce the current. #rref: 12000 # The resistance (in ohms) of the resistor between IREF and GND. The # default is 12000. #stealthchop_threshold: 0 # The velocity (in mm/s) to set the \"stealthChop\" threshold to. When # set, \"stealthChop\" mode will be enabled if the stepper motor # velocity is below this value. The default is 0, which disables # \"stealthChop\" mode. #coolstep_threshold: # The velocity (in mm/s) to set the TMC driver internal \"CoolStep\" # threshold to. If set, the coolstep feature will be enabled when # the stepper motor velocity is near or above this value. Important # - if coolstep_threshold is set and \"sensorless homing\" is used, # then one must ensure that the homing speed is above the coolstep # threshold! The default is to not enable the coolstep feature. #high_velocity_threshold: # The velocity (in mm/s) to set the TMC driver internal \"high # velocity\" threshold (THIGH) to. This is typically used to disable # the \"CoolStep\" feature at high speeds. The default is to not set a # TMC \"high velocity\" threshold. #driver_MSLUT0: 2863314260 #driver_MSLUT1: 1251300522 #driver_MSLUT2: 608774441 #driver_MSLUT3: 269500962 #driver_MSLUT4: 4227858431 #driver_MSLUT5: 3048961917 #driver_MSLUT6: 1227445590 #driver_MSLUT7: 4211234 #driver_W0: 2 #driver_W1: 1 #driver_W2: 1 #driver_W3: 1 #driver_X1: 128 #driver_X2: 255 #driver_X3: 255 #driver_START_SIN: 0 #driver_START_SIN90: 247 #driver_OFFSET_SIN90: 0 # These fields control the Microstep Table registers directly. The optimal # wave table is specific to each motor and might vary with current. An # optimal configuration will have minimal print artifacts caused by # non-linear stepper movement. The values specified above are the default # values used by the driver. The value must be specified as a decimal integer # (hex form is not supported). In order to compute the wave table fields, # see the tmc2130 \"Calculation Sheet\" from the Trinamic website. # Additionally, this driver also has the OFFSET_SIN90 field which can be used # to tune a motor with unbalanced coils. See the `Sine Wave Lookup Table` # section in the datasheet for information about this field and how to tune # it. #driver_MULTISTEP_FILT: True #driver_IHOLDDELAY: 6 #driver_IRUNDELAY: 4 #driver_TPOWERDOWN: 10 #driver_TBL: 2 #driver_TOFF: 3 #driver_HEND: 2 #driver_HSTRT: 5 #driver_FD3: 0 #driver_TPFD: 4 #driver_CHM: 0 #driver_VHIGHFS: 0 #driver_VHIGHCHM: 0 #driver_DISS2G: 0 #driver_DISS2VS: 0 #driver_PWM_AUTOSCALE: True #driver_PWM_AUTOGRAD: True #driver_PWM_FREQ: 0 #driver_FREEWHEEL: 0 #driver_PWM_GRAD: 0 #driver_PWM_OFS: 29 #driver_PWM_REG: 4 #driver_PWM_LIM: 12 #driver_SGT: 0 #driver_SEMIN: 0 #driver_SEUP: 0 #driver_SEMAX: 0 #driver_SEDN: 0 #driver_SEIMIN: 0 #driver_SFILT: 0 #driver_SG4_ANGLE_OFFSET: 1 #driver_SLOPE_CONTROL: 0 # Set the given register during the configuration of the TMC2240 # chip. This may be used to set custom motor parameters. The # defaults for each parameter are next to the parameter name in the # above list. #diag0_pin: #diag1_pin: # The micro-controller pin attached to one of the DIAG lines of the # TMC2240 chip. Only a single diag pin should be specified. The pin # is \"active low\" and is thus normally prefaced with \"^!\". Setting # this creates a \"tmc2240_stepper_x:virtual_endstop\" virtual pin # which may be used as the stepper's endstop_pin. Doing this enables # \"sensorless homing\". (Be sure to also set driver_SGT to an # appropriate sensitivity value.) The default is to not enable # sensorless homing. [tmc5160] \u00b6 Configurare un driver per motore passo-passo TMC5160 tramite bus SPI. Per utilizzare questa funzione, definire una sezione di configurazione con un prefisso \"tmc5160\" seguito dal nome della sezione di configurazione dello stepper corrispondente (ad esempio, \"[tmc5160 stepper_x]\"). [tmc5160 stepper_x] cs_pin: # The pin corresponding to the TMC5160 chip select line. This pin # will be set to low at the start of SPI messages and raised to high # after the message completes. This parameter must be provided. #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. #chain_position: #chain_length: # These parameters configure an SPI daisy chain. The two parameters # define the stepper position in the chain and the total chain length. # Position 1 corresponds to the stepper that connects to the MOSI signal. # The default is to not use an SPI daisy chain. #interpolate: True # If true, enable step interpolation (the driver will internally # step at a rate of 256 micro-steps). The default is True. run_current: # The amount of current (in amps RMS) to configure the driver to use # during stepper movement. This parameter must be provided. #hold_current: # The amount of current (in amps RMS) to configure the driver to use # when the stepper is not moving. Setting a hold_current is not # recommended (see TMC_Drivers.md for details). The default is to # not reduce the current. #sense_resistor: 0.075 # The resistance (in ohms) of the motor sense resistor. The default # is 0.075 ohms. #stealthchop_threshold: 0 # The velocity (in mm/s) to set the \"stealthChop\" threshold to. When # set, \"stealthChop\" mode will be enabled if the stepper motor # velocity is below this value. The default is 0, which disables # \"stealthChop\" mode. #coolstep_threshold: # The velocity (in mm/s) to set the TMC driver internal \"CoolStep\" # threshold to. If set, the coolstep feature will be enabled when # the stepper motor velocity is near or above this value. Important # - if coolstep_threshold is set and \"sensorless homing\" is used, # then one must ensure that the homing speed is above the coolstep # threshold! The default is to not enable the coolstep feature. #high_velocity_threshold: # The velocity (in mm/s) to set the TMC driver internal \"high # velocity\" threshold (THIGH) to. This is typically used to disable # the \"CoolStep\" feature at high speeds. The default is to not set a # TMC \"high velocity\" threshold. #driver_MSLUT0: 2863314260 #driver_MSLUT1: 1251300522 #driver_MSLUT2: 608774441 #driver_MSLUT3: 269500962 #driver_MSLUT4: 4227858431 #driver_MSLUT5: 3048961917 #driver_MSLUT6: 1227445590 #driver_MSLUT7: 4211234 #driver_W0: 2 #driver_W1: 1 #driver_W2: 1 #driver_W3: 1 #driver_X1: 128 #driver_X2: 255 #driver_X3: 255 #driver_START_SIN: 0 #driver_START_SIN90: 247 # These fields control the Microstep Table registers directly. The optimal # wave table is specific to each motor and might vary with current. An # optimal configuration will have minimal print artifacts caused by # non-linear stepper movement. The values specified above are the default # values used by the driver. The value must be specified as a decimal integer # (hex form is not supported). In order to compute the wave table fields, # see the tmc2130 \"Calculation Sheet\" from the Trinamic website. #driver_MULTISTEP_FILT: True #driver_IHOLDDELAY: 6 #driver_TPOWERDOWN: 10 #driver_TBL: 2 #driver_TOFF: 3 #driver_HEND: 2 #driver_HSTRT: 5 #driver_FD3: 0 #driver_TPFD: 4 #driver_CHM: 0 #driver_VHIGHFS: 0 #driver_VHIGHCHM: 0 #driver_DISS2G: 0 #driver_DISS2VS: 0 #driver_PWM_AUTOSCALE: True #driver_PWM_AUTOGRAD: True #driver_PWM_FREQ: 0 #driver_FREEWHEEL: 0 #driver_PWM_GRAD: 0 #driver_PWM_OFS: 30 #driver_PWM_REG: 4 #driver_PWM_LIM: 12 #driver_SGT: 0 #driver_SEMIN: 0 #driver_SEUP: 0 #driver_SEMAX: 0 #driver_SEDN: 0 #driver_SEIMIN: 0 #driver_SFILT: 0 #driver_DRVSTRENGTH: 0 #driver_BBMCLKS: 4 #driver_BBMTIME: 0 #driver_FILT_ISENSE: 0 # Set the given register during the configuration of the TMC5160 # chip. This may be used to set custom motor parameters. The # defaults for each parameter are next to the parameter name in the # above list. #diag0_pin: #diag1_pin: # The micro-controller pin attached to one of the DIAG lines of the # TMC5160 chip. Only a single diag pin should be specified. The pin # is \"active low\" and is thus normally prefaced with \"^!\". Setting # this creates a \"tmc5160_stepper_x:virtual_endstop\" virtual pin # which may be used as the stepper's endstop_pin. Doing this enables # \"sensorless homing\". (Be sure to also set driver_SGT to an # appropriate sensitivity value.) The default is to not enable # sensorless homing. Configurazione della corrente del motore passo-passo a run-time \u00b6 [ad5206] \u00b6 Digipot AD5206 configurati staticamente collegati tramite bus SPI (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"ad5206\"). [ad5206 my_digipot] enable_pin: # The pin corresponding to the AD5206 chip select line. This pin # will be set to low at the start of SPI messages and raised to high # after the message completes. This parameter must be provided. #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. #channel_1: #channel_2: #channel_3: #channel_4: #channel_5: #channel_6: # The value to statically set the given AD5206 channel to. This is # typically set to a number between 0.0 and 1.0 with 1.0 being the # highest resistance and 0.0 being the lowest resistance. However, # the range may be changed with the 'scale' parameter (see below). # If a channel is not specified then it is left unconfigured. #scale: # This parameter can be used to alter how the 'channel_x' parameters # are interpreted. If provided, then the 'channel_x' parameters # should be between 0.0 and 'scale'. This may be useful when the # AD5206 is used to set stepper voltage references. The 'scale' can # be set to the equivalent stepper amperage if the AD5206 were at # its highest resistance, and then the 'channel_x' parameters can be # specified using the desired amperage value for the stepper. The # default is to not scale the 'channel_x' parameters. [mcp4451] \u00b6 Digipot MCP4451 configurato staticamente collegato tramite bus I2C (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"mcp4451\"). [mcp4451 my_digipot] i2c_address: # The i2c address that the chip is using on the i2c bus. This # parameter must be provided. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #wiper_0: #wiper_1: #wiper_2: #wiper_3: # The value to statically set the given MCP4451 \"wiper\" to. This is # typically set to a number between 0.0 and 1.0 with 1.0 being the # highest resistance and 0.0 being the lowest resistance. However, # the range may be changed with the 'scale' parameter (see below). # If a wiper is not specified then it is left unconfigured. #scale: # This parameter can be used to alter how the 'wiper_x' parameters # are interpreted. If provided, then the 'wiper_x' parameters should # be between 0.0 and 'scale'. This may be useful when the MCP4451 is # used to set stepper voltage references. The 'scale' can be set to # the equivalent stepper amperage if the MCP4451 were at its highest # resistance, and then the 'wiper_x' parameters can be specified # using the desired amperage value for the stepper. The default is # to not scale the 'wiper_x' parameters. [mcp4728] \u00b6 Convertitore digitale-analogico MCP4728 in configurazione statica collegato tramite bus I2C (\u00e8 possibile definire un numero qualsiasi di sezioni con prefisso \"mcp4728\"). [mcp4728 my_dac] #i2c_address: 96 # The i2c address that the chip is using on the i2c bus. The default # is 96. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #channel_a: #channel_b: #channel_c: #channel_d: # The value to statically set the given MCP4728 channel to. This is # typically set to a number between 0.0 and 1.0 with 1.0 being the # highest voltage (2.048V) and 0.0 being the lowest voltage. # However, the range may be changed with the 'scale' parameter (see # below). If a channel is not specified then it is left # unconfigured. #scale: # This parameter can be used to alter how the 'channel_x' parameters # are interpreted. If provided, then the 'channel_x' parameters # should be between 0.0 and 'scale'. This may be useful when the # MCP4728 is used to set stepper voltage references. The 'scale' can # be set to the equivalent stepper amperage if the MCP4728 were at # its highest voltage (2.048V), and then the 'channel_x' parameters # can be specified using the desired amperage value for the # stepper. The default is to not scale the 'channel_x' parameters. [mcp4018] \u00b6 Digipot MCP4018 configurato staticamente collegato tramite due pin gpio \"bit banging\" (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"mcp4018\"). [mcp4018 my_digipot] scl_pin: # Il pin \"clock\" SCL. Questo parametro deve essere fornito. sda_pin: # Il pin \"dati\" SDA. Questo parametro deve essere fornito. wiper: # Il valore su cui impostare staticamente il \"Wiper\" MCP4018 # specificato. Questo \u00e8 in genere impostato su un numero compreso # tra 0,0 e 1,0 con 1,0 come resistenza pi\u00f9 alta e 0,0 come resistenza # pi\u00f9 bassa. Tuttavia, l'intervallo pu\u00f2 essere modificato con il # parametro 'scale' (vedi sotto). Questo parametro deve essere fornito. #scale: # Questo parametro pu\u00f2 essere utilizzato per modificare il modo in # cui viene interpretato il parametro 'wiper'. Se fornito, il parametro # 'wiper' dovrebbe essere compreso tra 0.0 e 'scale'. Questo pu\u00f2 essere # utile quando l'MCP4018 viene utilizzato per impostare i riferimenti di # tensione stepper. La \"scala\" pu\u00f2 essere impostata sull'amperaggio # stepper equivalente se l'MCP4018 \u00e8 alla sua massima resistenza, # quindi \u00e8 possibile specificare il parametro \"wiper\" utilizzando il # valore di amperaggio desiderato per lo stepper. L'impostazione # predefinita \u00e8 di non ridimensionare il parametro 'wiper'. Supporto display \u00b6 [display] \u00b6 Supporto per un display collegato al microcontrollore. [display] lcd_type: # The type of LCD chip in use. This may be \"hd44780\", \"hd44780_spi\", # \"aip31068_spi\", \"st7920\", \"emulated_st7920\", \"uc1701\", \"ssd1306\", or # \"sh1106\". # See the display sections below for information on each type and # additional parameters they provide. This parameter must be # provided. #display_group: # The name of the display_data group to show on the display. This # controls the content of the screen (see the \"display_data\" section # for more information). The default is _default_20x4 for hd44780 or # aip31068_spi displays and _default_16x4 for other displays. #menu_timeout: # Timeout for menu. Being inactive this amount of seconds will # trigger menu exit or return to root menu when having autorun # enabled. The default is 0 seconds (disabled) #menu_root: # Name of the main menu section to show when clicking the encoder # on the home screen. The defaults is __main, and this shows the # the default menus as defined in klippy/extras/display/menu.cfg #menu_reverse_navigation: # When enabled it will reverse up and down directions for list # navigation. The default is False. This parameter is optional. #encoder_pins: # The pins connected to encoder. 2 pins must be provided when using # encoder. This parameter must be provided when using menu. #encoder_steps_per_detent: # How many steps the encoder emits per detent (\"click\"). If the # encoder takes two detents to move between entries or moves two # entries from one detent, try changing this. Allowed values are 2 # (half-stepping) or 4 (full-stepping). The default is 4. #click_pin: # The pin connected to 'enter' button or encoder 'click'. This # parameter must be provided when using menu. The presence of an # 'analog_range_click_pin' config parameter turns this parameter # from digital to analog. #back_pin: # The pin connected to 'back' button. This parameter is optional, # menu can be used without it. The presence of an # 'analog_range_back_pin' config parameter turns this parameter from # digital to analog. #up_pin: # The pin connected to 'up' button. This parameter must be provided # when using menu without encoder. The presence of an # 'analog_range_up_pin' config parameter turns this parameter from # digital to analog. #down_pin: # The pin connected to 'down' button. This parameter must be # provided when using menu without encoder. The presence of an # 'analog_range_down_pin' config parameter turns this parameter from # digital to analog. #kill_pin: # The pin connected to 'kill' button. This button will call # emergency stop. The presence of an 'analog_range_kill_pin' config # parameter turns this parameter from digital to analog. #analog_pullup_resistor: 4700 # The resistance (in ohms) of the pullup attached to the analog # button. The default is 4700 ohms. #analog_range_click_pin: # The resistance range for a 'enter' button. Range minimum and # maximum comma-separated values must be provided when using analog # button. #analog_range_back_pin: # The resistance range for a 'back' button. Range minimum and # maximum comma-separated values must be provided when using analog # button. #analog_range_up_pin: # The resistance range for a 'up' button. Range minimum and maximum # comma-separated values must be provided when using analog button. #analog_range_down_pin: # The resistance range for a 'down' button. Range minimum and # maximum comma-separated values must be provided when using analog # button. #analog_range_kill_pin: # The resistance range for a 'kill' button. Range minimum and # maximum comma-separated values must be provided when using analog # button. display hd44780 \u00b6 Informazioni sulla configurazione dei display hd44780 (utilizzati nei display di tipo \"RepRapDiscount 2004 Smart Controller\"). [display] lcd_type: hd44780 # Set to \"hd44780\" for hd44780 displays. rs_pin: e_pin: d4_pin: d5_pin: d6_pin: d7_pin: # The pins connected to an hd44780 type lcd. These parameters must # be provided. #hd44780_protocol_init: True # Perform 8-bit/4-bit protocol initialization on an hd44780 display. # This is necessary on real hd44780 devices. However, one may need # to disable this on some \"clone\" devices. The default is True. #line_length: # Set the number of characters per line for an hd44780 type lcd. # Possible values are 20 (default) and 16. The number of lines is # fixed to 4. ... display hd44780_spi \u00b6 Informazioni sulla configurazione di un display hd44780_spi - un display 20x04 controllato tramite uno \"shift register\" hardware (che viene utilizzato nelle stampanti basate su mightyboard). [display] lcd_type: hd44780_spi # Set to \"hd44780_spi\" for hd44780_spi displays. latch_pin: spi_software_sclk_pin: spi_software_mosi_pin: spi_software_miso_pin: # The pins connected to the shift register controlling the display. # The spi_software_miso_pin needs to be set to an unused pin of the # printer mainboard as the shift register does not have a MISO pin, # but the software spi implementation requires this pin to be # configured. #hd44780_protocol_init: True # Perform 8-bit/4-bit protocol initialization on an hd44780 display. # This is necessary on real hd44780 devices. However, one may need # to disable this on some \"clone\" devices. The default is True. #line_length: # Set the number of characters per line for an hd44780 type lcd. # Possible values are 20 (default) and 16. The number of lines is # fixed to 4. ... aip31068_spi display \u00b6 Information on configuring an aip31068_spi display - a very similar to hd44780_spi a 20x04 (20 symbols by 4 lines) display with slightly different internal protocol. [display] lcd_type: aip31068_spi latch_pin: spi_software_sclk_pin: spi_software_mosi_pin: spi_software_miso_pin: # The pins connected to the shift register controlling the display. # The spi_software_miso_pin needs to be set to an unused pin of the # printer mainboard as the shift register does not have a MISO pin, # but the software spi implementation requires this pin to be # configured. #line_length: # Set the number of characters per line for an hd44780 type lcd. # Possible values are 20 (default) and 16. The number of lines is # fixed to 4. ... display st7920 \u00b6 Informazioni sulla configurazione dei display st7920 (utilizzati nei display di tipo \"RepRapDiscount 12864 Full Graphic Smart Controller\"). [display] lcd_type: st7920 # Set to \"st7920\" for st7920 displays. cs_pin: sclk_pin: sid_pin: # The pins connected to an st7920 type lcd. These parameters must be # provided. ... display emulazione emulated_st7920 \u00b6 Informazioni sulla configurazione di un display st7920 emulato, presenti in alcuni \"dispositivi touchscreen da 2,4 pollici\" e simili. [display] lcd_type: emulated_st7920 # Set to \"emulated_st7920\" for emulated_st7920 displays. en_pin: spi_software_sclk_pin: spi_software_mosi_pin: spi_software_miso_pin: # The pins connected to an emulated_st7920 type lcd. The en_pin # corresponds to the cs_pin of the st7920 type lcd, # spi_software_sclk_pin corresponds to sclk_pin and # spi_software_mosi_pin corresponds to sid_pin. The # spi_software_miso_pin needs to be set to an unused pin of the # printer mainboard as the st7920 as no MISO pin but the software # spi implementation requires this pin to be configured. ... display uc1701 \u00b6 Informazioni sulla configurazione dei display uc1701 (utilizzati nei display di tipo \"MKS Mini 12864\"). [display] lcd_type: uc1701 # Set to \"uc1701\" for uc1701 displays. cs_pin: a0_pin: # The pins connected to a uc1701 type lcd. These parameters must be # provided. #rst_pin: # The pin connected to the \"rst\" pin on the lcd. If it is not # specified then the hardware must have a pull-up on the # corresponding lcd line. #contrast: # The contrast to set. The value may range from 0 to 63 and the # default is 40. ... display ssd1306 e sh1106 \u00b6 Informazioni sulla configurazione dei display ssd1306 e sh1106. [display] lcd_type: # Set to either \"ssd1306\" or \"sh1106\" for the given display type. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # Optional parameters available for displays connected via an i2c # bus. See the \"common I2C settings\" section for a description of # the above parameters. #cs_pin: #dc_pin: #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # The pins connected to the lcd when in \"4-wire\" spi mode. See the # \"common SPI settings\" section for a description of the parameters # that start with \"spi_\". The default is to use i2c mode for the # display. #reset_pin: # A reset pin may be specified on the display. If it is not # specified then the hardware must have a pull-up on the # corresponding lcd line. #contrast: # The contrast to set. The value may range from 0 to 256 and the # default is 239. #vcomh: 0 # Set the Vcomh value on the display. This value is associated with # a \"smearing\" effect on some OLED displays. The value may range # from 0 to 63. Default is 0. #invert: False # TRUE inverts the pixels on certain OLED displays. The default is # False. #x_offset: 0 # Set the horizontal offset value on SH1106 displays. The default is # 0. ... [display_data] \u00b6 Supporto per la visualizzazione di dati personalizzati su uno schermo LCD. \u00c8 possibile creare un numero qualsiasi di gruppi di visualizzazione e un numero qualsiasi di elementi di dati in quei gruppi. Il display mostrer\u00e0 tutti gli elementi di dati per un determinato gruppo se l'opzione display_group nella sezione [display] \u00e8 impostata sul nome del gruppo specificato. Viene creato automaticamente un default set of display groups . \u00c8 possibile sostituire o estendere questi elementi display_data sovrascrivendo i valori predefiniti nel file di configurazione principale printer.cfg . [display_data my_group_name my_data_name] position: # Comma separated row and column of the display position that should # be used to display the information. This parameter must be # provided. text: # The text to show at the given position. This field is evaluated # using command templates (see docs/Command_Templates.md). This # parameter must be provided. [display_template] \u00b6 Visualizza il testo dei dati \"macro\" (\u00e8 possibile definire un numero qualsiasi di sezioni con un prefisso display_template). Per informazioni sul template, vedere il documento template di comandi . Questa funzione consente di ridurre le definizioni ripetitive nelle sezioni display_data. Si pu\u00f2 usare la funzione incorporata render() nelle sezioni display_data per valutare un template. Per esempio, se si dovesse definire [display_template my_template] allora si potrebbe usare { render('my_template') } in una sezione display_data. Questa funzione pu\u00f2 essere utilizzata anche per aggiornamenti LED continui utilizzando il comando SET_LED_TEMPLATE . [display_template my_template_name] #param_<name>: # One may specify any number of options with a \"param_\" prefix. The # given name will be assigned the given value (parsed as a Python # literal) and will be available during macro expansion. If the # parameter is passed in the call to render() then that value will # be used during macro expansion. For example, a config with # \"param_speed = 75\" might have a caller with # \"render('my_template_name', param_speed=80)\". Parameter names may # not use upper case characters. text: # The text to return when the this template is rendered. This field # is evaluated using command templates (see # docs/Command_Templates.md). This parameter must be provided. [display_glyph] \u00b6 Visualizza un glifo personalizzato sui display che lo supportano. Al nome dato verranno assegnati i dati di visualizzazione dati che possono quindi essere referenziati nei modelli di visualizzazione con il loro nome circondato da due simboli \"tilde\" per esempio ~my_display_glyph~ Vedere sample-glyphs.cfg per alcuni esempi. [display_glyph my_display_glyph] #data: # The display data, stored as 16 lines consisting of 16 bits (1 per # pixel) where '.' is a blank pixel and '*' is an on pixel (e.g., # \"****************\" to display a solid horizontal line). # Alternatively, one can use '0' for a blank pixel and '1' for an on # pixel. Put each display line into a separate config line. The # glyph must consist of exactly 16 lines with 16 bits each. This # parameter is optional. #hd44780_data: # Glyph to use on 20x4 hd44780 displays. The glyph must consist of # exactly 8 lines with 5 bits each. This parameter is optional. #hd44780_slot: # The hd44780 hardware index (0..7) to store the glyph at. If # multiple distinct images use the same slot then make sure to only # use one of those images in any given screen. This parameter is # required if hd44780_data is specified. [display my_extra_display] \u00b6 Se in printer.cfg \u00e8 stata definita una sezione primaria [display] come mostrato sopra, \u00e8 possibile definire pi\u00f9 display ausiliari. Si noti che i display ausiliari attualmente non supportano la funzionalit\u00e0 del menu, quindi non supportano le opzioni del \"menu\" o la configurazione dei pulsanti. [display my_extra_display] # Vedere la sezione \"display\" per i parametri disponibili. [menu] \u00b6 Menu display lcd personalizzabili. Viene creato automaticamente un default set of menus . \u00c8 possibile sostituire o estendere il menu sovrascrivendo le impostazioni predefinite nel file di configurazione principale printer.cfg . Consulta il command template document per informazioni sugli attributi di menu disponibili durante il rendering del modello. # Common parameters available for all menu config sections. #[menu __some_list __some_name] #type: disabled # Permanently disabled menu element, only required attribute is 'type'. # Allows you to easily disable/hide existing menu items. #[menu some_name] #type: # One of command, input, list, text: # command - basic menu element with various script triggers # input - same like 'command' but has value changing capabilities. # Press will start/stop edit mode. # list - it allows for menu items to be grouped together in a # scrollable list. Add to the list by creating menu # configurations using \"some_list\" as a prefix - for # example: [menu some_list some_item_in_the_list] # vsdlist - same as 'list' but will append files from virtual sdcard # (will be removed in the future) #name: # Name of menu item - evaluated as a template. #enable: # Template that evaluates to True or False. #index: # Position where an item needs to be inserted in list. By default # the item is added at the end. #[menu some_list] #type: list #name: #enable: # See above for a description of these parameters. #[menu some_list some_command] #type: command #name: #enable: # See above for a description of these parameters. #gcode: # Script to run on button click or long click. Evaluated as a # template. #[menu some_list some_input] #type: input #name: #enable: # See above for a description of these parameters. #input: # Initial value to use when editing - evaluated as a template. # Result must be float. #input_min: # Minimum value of range - evaluated as a template. Default -99999. #input_max: # Maximum value of range - evaluated as a template. Default 99999. #input_step: # Editing step - Must be a positive integer or float value. It has # internal fast rate step. When \"(input_max - input_min) / # input_step > 100\" then fast rate step is 10 * input_step else fast # rate step is same input_step. #realtime: # This attribute accepts static boolean value. When enabled then # gcode script is run after each value change. The default is False. #gcode: # Script to run on button click, long click or value change. # Evaluated as a template. The button click will trigger the edit # mode start or end. Sensori di filamento \u00b6 [filament_switch_sensor] \u00b6 Sensore del filamento a interruttore. Supporto per l'inserimento del filamento e il rilevamento dell'esaurimento tramite un sensore interruttore, come un interruttore di fine corsa. Per ulteriori informazioni, vedere command reference . [filament_switch_sensor my_sensor] #pause_on_runout: True # Se impostato su True, verr\u00e0 eseguita una PAUSA immediatamente # dopo il rilevamento di un'eccentricit\u00e0. Si noti che se pause_on_runout # \u00e8 False e runout_gcode viene omesso, il rilevamento dell'eccentricit\u00e0 # \u00e8 disabilitato. L'impostazione predefinita \u00e8 Vero. #runout_gcode: # Un elenco di comandi G-Code da eseguire dopo il rilevamento di # un'esaurimento del filamento. Vedi docs/Command_Templates.md # per il formato G-Code. Se pause_on_runout \u00e8 impostato su True, # questo codice G verr\u00e0 eseguito al termine della PAUSA. # L'impostazione predefinita \u00e8 di non eseguire alcun comando G-Code. #insert_gcode: # Un elenco di comandi G-Code da eseguire dopo il rilevamento # dell'inserimento di filamento. Vedi docs/Command_Templates.md # per il formato G-Code. L'impostazione predefinita non prevede # l'esecuzione di alcun comando G-Code, che disabilita il rilevamento # dell'inserimento. #event_delay: 3.0 # Il tempo minimo in secondi per ritardare tra gli eventi. Gli eventi # attivati durante questo periodo di tempo verranno ignorati # silenziosamente. L'impostazione predefinita \u00e8 3 secondi. #pause_delay: 0.5 # Il tempo di ritardo, in secondi, tra l'invio del comando pause e # l'esecuzione di runout_gcode. Potrebbe essere utile aumentare # questo ritardo se OctoPrint mostra uno strano comportamento # di pausa. Il valore predefinito \u00e8 0,5 secondi. #switch_pin: # Il pin su cui \u00e8 collegato l'interruttore. # Questo parametro deve essere fornito. [filament_motion_sensor] \u00b6 Sensore di movimento del filamento. Supporto per l'inserimento del filamento e il rilevamento dell'esaurimento mediante un codificatore che commuta il pin di uscita durante il movimento del filamento attraverso il sensore. Per ulteriori informazioni, vedere command reference . [filament_motion_sensor my_sensor] detection_length: 7.0 # La lunghezza minima di filamento tirato attraverso il sensore # per attivare un cambio di stato su switch_pin # Il default \u00e8 7 mm. extruder: # Nome della sezione extruder section con cui questo sensore \u00e8 associato. # Questo parametro deve essere fornito. switch_pin: #pause_on_runout: #runout_gcode: #insert_gcode: #event_delay: #pause_delay: # Vedere la sezione \"filament_switch_sensor\" per la descrizione dei # parametri riportati sopra. [tsl1401cl_filament_width_sensor] \u00b6 Sensore di larghezza del filamento basato su TSLl401CL. Consulta la guida per ulteriori informazioni. sl1401cl_filament_width_sensor] #pin: #diametro nominale del filamento predefinito: 1,75 (mm) # Differenza massima consentita del diametro del filamento in mm. #max_difference: 0.2 # La distanza dal sensore alla camera di fusione in mm. #measurement_delay: 100 [hall_filament_width_sensor] \u00b6 Sensore di larghezza del filamento ad effetto Hall (vedere Sensore di larghezza del filamento Hall ). [hall_filament_width_sensor] adc1: adc2: # Pin di ingresso analogico collegati al sensore. # Questi parametri devono essere forniti. #cal_dia1: 1.50 #cal_dia2: 2.00 # I valori di calibrazione (in mm) per i sensori. Il valore predefinito # \u00e8 1.50 per cal_dia1 e 2.00 per cal_dia2. #raw_dia1: 9500 #raw_dia2: 10500 # I valori di calibrazione grezzi per i sensori. Il valore predefinito \u00e8 # 9500 per raw_dia1 e 10500 per raw_dia2. #default_nominal_filament_diameter: 1.75 # Il diametro nominale del filamento. # Questo parametro deve essere fornito. #max_difference: 0.200 # Differenza massima consentita del diametro del filamento in # millimetri (mm). Se la differenza tra il diametro nominale del # filamento e l'uscita del sensore \u00e8 maggiore di +- max_difference, # il moltiplicatore di estrusione viene riportato a %100. # Il valore predefinito \u00e8 0,200. #measurement_delay: 70 # La distanza dal sensore alla camera di fusione/hot-end in # millimetri (mm). Il filamento tra il sensore e l'hot-end verr\u00e0 # trattato come default_nominal_filament_diameter. Il modulo # host funziona con la logica FIFO. Mantiene ogni valore e posizione # del sensore in un array e li riporta nella posizione corretta. # Questo parametro deve essere fornito. #enable: False # Sensore abilitato o disabilitato dopo l'accensione. L'impostazione predefinita \u00e8 disabilitare. #measurement_interval: 10 # La distanza approssimativa (in mm) tra le letture del sensore. # Il valore predefinito \u00e8 10 mm. #logging: False # Il log esterno al terminale e klipper.log pu\u00f2 essere # attivato|off tramite comando. #min_diameter: 1.0 # Diametro minimo per trigger filament_switch_sensor virtuale. #use_current_dia_while_delay: False # Utilizzare il diametro attuale invece del diametro nominale # mentre il ritardo di misurazione non \u00e8 trascorso. #pause_on_runout: #runout_gcode: #insert_gcode: #event_delay: #pause_delay: # Vedere la sezione \"filament_switch_sensor\" per una # descrizione dei parametri di cui sopra. Load Cells \u00b6 [load_cell] \u00b6 Load Cell. Uses an ADC sensor attached to a load cell to create a digital scale. [load_cell] sensor_type: # This must be one of the supported sensor types, see below. HX711 \u00b6 This is a 24 bit low sample rate chip using \"bit-bang\" communications. It is suitable for filament scales. [load_cell] sensor_type: hx711 sclk_pin: # The pin connected to the HX711 clock line. This parameter must be provided. dout_pin: # The pin connected to the HX711 data output line. This parameter must be # provided. #gain: A-128 # Valid values for gain are: A-128, A-64, B-32. The default is A-128. # 'A' denotes the input channel and the number denotes the gain. Only the 3 # listed combinations are supported by the chip. Note that changing the gain # setting also selects the channel being read. #sample_rate: 80 # Valid values for sample_rate are 80 or 10. The default value is 80. # This must match the wiring of the chip. The sample rate cannot be changed # in software. HX717 \u00b6 This is the 4x higher sample rate version of the HX711, suitable for probing. [load_cell] sensor_type: hx717 sclk_pin: # The pin connected to the HX717 clock line. This parameter must be provided. dout_pin: # The pin connected to the HX717 data output line. This parameter must be # provided. #gain: A-128 # Valid values for gain are A-128, B-64, A-64, B-8. # 'A' denotes the input channel and the number denotes the gain setting. # Only the 4 listed combinations are supported by the chip. Note that # changing the gain setting also selects the channel being read. #sample_rate: 320 # Valid values for sample_rate are: 10, 20, 80, 320. The default is 320. # This must match the wiring of the chip. The sample rate cannot be changed # in software. ADS1220 \u00b6 The ADS1220 is a 24 bit ADC supporting up to a 2Khz sample rate configurable in software. [load_cell] sensor_type: ads1220 cs_pin: # The pin connected to the ADS1220 chip select line. This parameter must # be provided. #spi_speed: 512000 # This chip supports 2 speeds: 256000 or 512000. The faster speed is only # enabled when one of the Turbo sample rates is used. The correct spi_speed # is selected based on the sample rate. #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. data_ready_pin: # Pin connected to the ADS1220 data ready line. This parameter must be # provided. #gain: 128 # Valid gain values are 128, 64, 32, 16, 8, 4, 2, 1 # The default is 128 #pga_bypass: False # Disable the internal Programmable Gain Amplifier. If # True the PGA will be disabled for gains 1, 2, and 4. The PGA is always # enabled for gain settings 8 to 128, regardless of the pga_bypass setting. # If AVSS is used as an input pga_bypass is forced to True. # The default is False. #sample_rate: 660 # This chip supports two ranges of sample rates, Normal and Turbo. In turbo # mode the chip's internal clock runs twice as fast and the SPI communication # speed is also doubled. # Normal sample rates: 20, 45, 90, 175, 330, 600, 1000 # Turbo sample rates: 40, 90, 180, 350, 660, 1200, 2000 # The default is 660 #input_mux: # Input multiplexer configuration, select a pair of pins to use. The first pin # is the positive, AINP, and the second pin is the negative, AINN. Valid # values are: 'AIN0_AIN1', 'AIN0_AIN2', 'AIN0_AIN3', 'AIN1_AIN2', 'AIN1_AIN3', # 'AIN2_AIN3', 'AIN1_AIN0', 'AIN3_AIN2', 'AIN0_AVSS', 'AIN1_AVSS', 'AIN2_AVSS' # and 'AIN3_AVSS'. If AVSS is used the PGA is bypassed and the pga_bypass # setting will be forced to True. # The default is AIN0_AIN1. #vref: # The selected voltage reference. Valid values are: 'internal', 'REF0', 'REF1' # and 'analog_supply'. Default is 'internal'. Supporto hardware per specifica scheda \u00b6 [sx1509] \u00b6 Configurare un'espansione SX1509 da I2C a GPIO. A causa del ritardo dovuto alla comunicazione I2C, NON utilizzare i pin SX1509 come abilitazione stepper, pin step o dir o qualsiasi altro pin che richieda un bit banging veloce. Sono utilizzati al meglio come uscite digitali statiche o controllate da gcode o pin hardware-pwm per es. fan. Si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"sx1509\". Ogni espansione fornisce un set di 16 pin (da sx1509_my_sx1509:PIN_0 a sx1509_my_sx1509:PIN_15) che possono essere utilizzati nella configurazione della stampante. Per un esempio, vedere il file generic-duet2-duex.cfg . [sx1509 my_sx1509] i2c_address: # I2C address used by this expander. Depending on the hardware # jumpers this is one out of the following addresses: 62 63 112 # 113. This parameter must be provided. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. [samd_sercom] \u00b6 Configurazione SAMD SERCOM per specificare quali pin utilizzare su un determinato SERCOM. Si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"samd_sercom\". Ogni SERCOM deve essere configurato prima di utilizzarlo come periferica SPI o I2C. Posiziona questa sezione di configurazione sopra qualsiasi altra sezione che fa uso di bus SPI o I2C. [samd_sercom my_sercom] sercom: # Il nome del bus Sercom da configurare nel microcontrollore. I nomi # disponibili sono \"sercom0\", \"sercom1\", ecc. # Questo parametro deve essere fornito. tx_pin: # Pin MOSI per la comunicazione SPI o pin SDA (dati) per la # comunicazione I2C. Il pin deve avere una configurazione pinmux # valida per la specifica periferica SERCOM. # Questo parametro deve essere fornito. #rx_pin: # Pin MISO per la comunicazione SPI. Questo pin non viene utilizzato # per la comunicazione I2C (I2C utilizza tx_pin sia per l'invio che per la # ricezione). Il pin deve avere una configurazione pinmux valida per la # specifica periferica SERCOM. Questo parametro \u00e8 facoltativo. clk_pin: # Pin CLK per la comunicazione SPI o pin SCL (clock) per la # comunicazione I2C. Il pin deve avere una configurazione pinmux # valida per la specifica periferica SERCOM. Questo parametro deve # essere fornito. [adc_scaled] \u00b6 Scaling analogico di Duet2 Maestro tramite letture vref e vssa. La definizione di una sezione adc_scaled abilita pin adc virtuali (come \"my_name:PB0\") che vengono regolati automaticamente dai pin di monitoraggio vref e vssa della scheda. Assicurati di definire questa sezione di configurazione sopra qualsiasi sezione di configurazione che utilizza uno di questi pin virtuali. Per un esempio, vedere il file generic-duet2-maestro.cfg . [adc_scaled my_name] vref_pin: # The ADC pin to use for VREF monitoring. This parameter must be # provided. vssa_pin: # The ADC pin to use for VSSA monitoring. This parameter must be # provided. #smooth_time: 2.0 # A time value (in seconds) over which the vref and vssa # measurements will be smoothed to reduce the impact of measurement # noise. The default is 2 seconds. [replicape] \u00b6 Supporto per Replicape: vedere la guida beaglebone e il file generic-replicape.cfg per un esempio. # La sezione di configurazione \"replicape\" aggiunge i pin di abilitazione # dello stepper virtuale \"replicape: stepper_x_enable\" (per stepper X, Y, Z, # E e H) e i pin di uscita PWM \"replicape: power_x\" (per hotbed, e, h, fan0, # fan1 , fan2 e fan3) che possono quindi essere utilizzati altrove nel file # di configurazione. [replicape] revision: # La revisione dell'hardware di replicape. Attualmente \u00e8 supportata solo # la revisione \"B3\". Questo parametro deve essere fornito. #enable_pin: !gpio0_20 # Il pin di abilitazione globale dei replicape. L'impostazione predefinita # \u00e8 !gpio0_20 (aka P9_41). host_mcu: # Il nome della sezione mcu config che comunica con l'istanza mcu # \"linux process\" di Klipper. Questo parametro deve essere fornito. #standstill_power_down: False # Questo parametro controlla la linea CFG6_ENN su tutti i motori # passo-passo. True imposta le righe di abilitazione su \"open\". # L'impostazione predefinita \u00e8 Falso. #stepper_x_microstep_mode: #stepper_y_microstep_mode: #stepper_z_microstep_mode: #stepper_e_microstep_mode: #stepper_h_microstep_mode: # Questo parametro controlla i pin CFG1 e CFG2 del driver del motore # passo-passo specificato. Le opzioni disponibili sono: disabilita, 1, 2, # spread2, 4, 16, spread4, spread16, stealth4 e stealth16. L'impostazione # predefinita \u00e8 disabilitata. #stepper_x_current: #stepper_y_current: #stepper_z_current: #stepper_e_current: #stepper_h_current: # La corrente massima configurata (in Amp) del driver del motore # passo-passo. Questo parametro deve essere fornito se lo stepper non # \u00e8 in modalit\u00e0 disabilitazione. #stepper_x_chopper_off_time_high: #stepper_y_chopper_off_time_high: #stepper_z_chopper_off_time_high: #stepper_e_chopper_off_time_high: #stepper_h_chopper_off_time_high: # Questo parametro controlla il pin CFG0 del driver del motore # passo-passo (True imposta CFG0 alto, False lo imposta basso). # L'impostazione predefinita \u00e8 False. #stepper_x_chopper_hysteresis_high: #stepper_y_chopper_hysteresis_high: #stepper_z_chopper_hysteresis_high: #stepper_e_chopper_hysteresis_high: #stepper_h_chopper_hysteresis_high: # Questo parametro controlla il pin CFG4 del driver del motore # passo-passo (True imposta CFG4 alto, False lo imposta basso). # L'impostazione predefinita \u00e8 False. #stepper_x_chopper_blank_time_high: #stepper_y_chopper_blank_time_high: #stepper_z_chopper_blank_time_high: #stepper_e_chopper_blank_time_high: #stepper_h_chopper_blank_time_high: # Questo parametro controlla il pin CFG5 del driver del motore # passo-passo (True imposta CFG5 alto, False lo imposta basso). # L'impostazione predefinita \u00e8 True. Altri moduli personalizzati \u00b6 [palette2] \u00b6 Supporto multimateriale Palette 2: fornisce un'integrazione pi\u00f9 stretta supportando i dispositivi Palette 2 in modalit\u00e0 connessa. Questo modulo richiede anche [virtual_sdcard] e [pause_resume] per la piena funzionalit\u00e0. Se si utilizza questo modulo, non utilizzare il plug-in Palette 2 per Octoprint poich\u00e9 entreranno in conflitto e 1 non si inizializzer\u00e0 correttamente, probabilmente interrompendo la stampa. Se utilizzi Octoprint e esegui lo streaming di gcode sulla porta seriale invece di stampare da virtual_sd, rimuovere M1 e M0 da Pausa dei comandi in Impostazioni > Connessione seriale > Firmware e protocollo eviter\u00e0 la necessit\u00e0 per avviare la stampa sulla tavolozza 2 e riattivare la pausa in Octoprint per avviare la stampa. [palette2] serial: # The serial port to connect to the Palette 2. #baud: 115200 # The baud rate to use. The default is 115200. #feedrate_splice: 0.8 # The feedrate to use when splicing, default is 0.8 #feedrate_normal: 1.0 # The feedrate to use after splicing, default is 1.0 #auto_load_speed: 2 # Extrude feedrate when autoloading, default is 2 (mm/s) #auto_cancel_variation: 0.1 # Auto cancel print when ping variation is above this threshold [angle] \u00b6 Magnetic hall angle sensor support for reading stepper motor angle shaft measurements using a1333, as5047d, mt6816, mt6826s, or tle5012b SPI chips. The measurements are available via the API Server and motion analysis tool . See the G-Code reference for available commands. [angle my_angle_sensor] sensor_type: # The type of the magnetic hall sensor chip. Available choices are # \"a1333\", \"as5047d\", \"mt6816\", \"mt6826s\", and \"tle5012b\". This parameter must be # specified. #sample_period: 0.000400 # The query period (in seconds) to use during measurements. The # default is 0.000400 (which is 2500 samples per second). #stepper: # The name of the stepper that the angle sensor is attached to (eg, # \"stepper_x\"). Setting this value enables an angle calibration # tool. To use this feature, the Python \"numpy\" package must be # installed. The default is to not enable angle calibration for the # angle sensor. cs_pin: # The SPI enable pin for the sensor. This parameter must be provided. #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. Parametri bus comuni \u00b6 Impostazioni SPI comuni \u00b6 I seguenti parametri sono generalmente disponibili per i dispositivi che utilizzano un bus SPI. #spi_speed: # La velocit\u00e0 SPI (in Hz) da utilizzare durante la comunicazione con il # dispositivo. L'impostazione predefinita dipende dal tipo di dispositivo. #spi_bus: # Se il microcontrollore supporta pi\u00f9 bus SPI, \u00e8 possibile specificare # qui il nome del bus del microcontrollore. L'impostazione predefinita # dipende dal tipo di microcontrollore. #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # Specificare i parametri di cui sopra per utilizzare \"SPI basato su # software\". Questa modalit\u00e0 non richiede il supporto hardware del # microcontrollore (in genere \u00e8 possibile utilizzare qualsiasi pin generico). # L'impostazione predefinita \u00e8 di non utilizzare \"spi software\". Impostazioni I2C comuni \u00b6 I seguenti parametri sono generalmente disponibili per i dispositivi che utilizzano un bus I2C. Tieni presente che l'attuale supporto del microcontrollore di Klipper per I2C generalmente non tollera il rumore di linea. Errori imprevisti sui cavi I2C potrebbero far s\u00ec che Klipper sollevi un errore di runtime. Il supporto di Klipper per il ripristino degli errori varia a seconda del tipo di microcontrollore. In genere si consiglia di utilizzare solo dispositivi I2C che si trovano sullo stesso circuito stampato del microcontrollore. Most Klipper micro-controller implementations only support an i2c_speed of 100000 ( standard mode , 100kbit/s). The Klipper \"Linux\" micro-controller supports a 400000 speed ( fast mode , 400kbit/s), but it must be set in the operating system and the i2c_speed parameter is otherwise ignored. The Klipper \"RP2040\" micro-controller and ATmega AVR family and some STM32 (F0, G0, G4, L4, F7, H7) support a rate of 400000 via the i2c_speed parameter. All other Klipper micro-controllers use a 100000 rate and ignore the i2c_speed parameter. #i2c_address: # The i2c address of the device. This must specified as a decimal # number (not in hex). The default depends on the type of device. #i2c_mcu: # The name of the micro-controller that the chip is connected to. # The default is \"mcu\". #i2c_bus: # If the micro-controller supports multiple I2C busses then one may # specify the micro-controller bus name here. The default depends on # the type of micro-controller. #i2c_software_scl_pin: #i2c_software_sda_pin: # Specify these parameters to use micro-controller software based # I2C \"bit-banging\" support. The two parameters should the two pins # on the micro-controller to use for the scl and sda wires. The # default is to use hardware based I2C support as specified by the # i2c_bus parameter. #i2c_speed: # The I2C speed (in Hz) to use when communicating with the device. # The Klipper implementation on most micro-controllers is hard-coded # to 100000 and changing this value has no effect. The default is # 100000. Linux, RP2040 and ATmega support 400000.","title":"Riferimenti configurazione"},{"location":"Config_Reference.html#riferimenti-configurazione","text":"Questo documento \u00e8 un riferimento per le opzioni disponibili nel file di configurazione di Klipper. Le descrizioni in questo documento sono formattate in modo che sia possibile tagliarle e incollarle in un file di configurazione della stampante. Consulta il documento di installazione per informazioni sulla configurazione di Klipper e sulla scelta di un file di configurazione iniziale.","title":"Riferimenti configurazione"},{"location":"Config_Reference.html#configurazione-del-microcontrollore","text":"","title":"Configurazione del microcontrollore"},{"location":"Config_Reference.html#formato-dei-nomi-dei-pin-del-microcontrollore","text":"Molte opzioni di configurazione richiedono il nome di un pin del microcontrollore. Klipper usa i nomi hardware per questi pin, ad esempio \"PA4\". I nomi dei pin possono essere preceduti da ! per indicare che deve essere utilizzata una polarit\u00e0 inversa (ad esempio, trigger su basso anzich\u00e9 alto). I pin di input possono essere preceduti da ^ per indicare che un resistore di pull-up hardware deve essere abilitato per il pin. Se il microcontrollore supporta resistori pull-down, un pin di ingresso pu\u00f2 in alternativa essere preceduto da ~ . Nota, alcune sezioni di configurazione potrebbero \"creare\" pin aggiuntivi. Quando ci\u00f2 si verifica, la sezione di configurazione che definisce i pin deve essere elencata nel file di configurazione prima di qualsiasi sezione che utilizza tali pin.","title":"Formato dei nomi dei pin del microcontrollore"},{"location":"Config_Reference.html#mcu","text":"Configurazione del microcontrollore primario. [mcu] serial: # La porta seriale per la connessione all'MCU. In caso di dubbi (o se # cambia) vedere \"Dov'\u00e8 la mia porta seriale?\" sezione delle FAQ. # Questo parametro deve essere fornito quando si utilizza una # porta seriale. #baud: 250000 # La velocit\u00e0 di trasmissione da utilizzare. Il valore predefinito \u00e8 250000. #canbus_uuid: # Se si utilizza un dispositivo collegato a un bus CAN, questo imposta # l'identificatore univoco del chip a cui connettersi. Questo valore deve # essere fornito quando si utilizza il bus CAN per la comunicazione. #canbus_interface: # Se si utilizza un dispositivo collegato a un bus CAN, viene impostata # l'interfaccia di rete CAN da utilizzare. L'impostazione predefinita \u00e8 'can0'. #restart_method: # Questo controlla il meccanismo che l'host utilizzer\u00e0 per reimpostare # il microcontrollore. Le scelte sono \"arduino\", \"cheetah\", \"rpi_usb\" e # \"command\". Il metodo 'arduino' (attiva/disattiva DTR) \u00e8 comune su # schede Arduino e cloni. Il metodo 'cheetah' \u00e8 un metodo speciale # necessario per alcune schede Fysetc Cheetah. Il metodo \"rpi_usb\" # \u00e8 utile sulle schede Raspberry Pi con microcontrollori alimentati # tramite USB: disabilita brevemente l'alimentazione a tutte le porte # USB per eseguire un ripristino del microcontrollore. Il metodo # \"comando\" prevede l'invio di un comando Klipper al microcontrollore # in modo che possa reimpostarsi. L'impostazione predefinita \u00e8 # 'arduino' se il microcontrollore comunica su una porta seriale, # altrimenti 'comando'.","title":"[mcu]"},{"location":"Config_Reference.html#mcu-my_extra_mcu","text":"Microcontrollori aggiuntivi (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"mcu\"). Microcontrollori aggiuntivi introducono pin aggiuntivi che possono essere configurati come riscaldatori, stepper, ventole, ecc. Ad esempio, se viene introdotta una sezione \"[mcu extra_mcu]\", i pin come \"extra_mcu:ar9\" possono quindi essere utilizzati altrove nella configurazione (dove \"ar9\" \u00e8 un nome pin hardware o un nome alias sul dato mcu). [mcu my_extra_mcu] # Vedere la sezione \"mcu\" per i parametri di configurazione.","title":"[mcu my_extra_mcu]"},{"location":"Config_Reference.html#impostazioni-cinematiche-comuni","text":"","title":"Impostazioni cinematiche comuni"},{"location":"Config_Reference.html#printer","text":"La sezione printer controlla le impostazioni di alto livello della stampante. [printer] kinematics: # The type of printer in use. This option may be one of: cartesian, # corexy, corexz, hybrid_corexy, hybrid_corexz, rotary_delta, delta, # deltesian, polar, winch, or none. This parameter must be specified. max_velocity: # Maximum velocity (in mm/s) of the toolhead (relative to the # print). This parameter must be specified. max_accel: # Maximum acceleration (in mm/s^2) of the toolhead (relative to the # print). Although this parameter is described as a \"maximum\" # acceleration, in practice most moves that accelerate or decelerate # will do so at the rate specified here. The value specified here # may be changed at runtime using the SET_VELOCITY_LIMIT command. # This parameter must be specified. #minimum_cruise_ratio: 0.5 # Most moves will accelerate to a cruising speed, travel at that # cruising speed, and then decelerate. However, some moves that # travel a short distance could nominally accelerate and then # immediately decelerate. This option reduces the top speed of these # moves to ensure there is always a minimum distance traveled at a # cruising speed. That is, it enforces a minimum distance traveled # at cruising speed relative to the total distance traveled. It is # intended to reduce the top speed of short zigzag moves (and thus # reduce printer vibration from these moves). For example, a # minimum_cruise_ratio of 0.5 would ensure that a standalone 1.5mm # move would have a minimum cruising distance of 0.75mm. Specify a # ratio of 0.0 to disable this feature (there would be no minimum # cruising distance enforced between acceleration and deceleration). # The value specified here may be changed at runtime using the # SET_VELOCITY_LIMIT command. The default is 0.5. #square_corner_velocity: 5.0 # The maximum velocity (in mm/s) that the toolhead may travel a 90 # degree corner at. A non-zero value can reduce changes in extruder # flow rates by enabling instantaneous velocity changes of the # toolhead during cornering. This value configures the internal # centripetal velocity cornering algorithm; corners with angles # larger than 90 degrees will have a higher cornering velocity while # corners with angles less than 90 degrees will have a lower # cornering velocity. If this is set to zero then the toolhead will # decelerate to zero at each corner. The value specified here may be # changed at runtime using the SET_VELOCITY_LIMIT command. The # default is 5mm/s. #max_accel_to_decel: # This parameter is deprecated and should no longer be used.","title":"[printer]"},{"location":"Config_Reference.html#stepper","text":"Definizioni di motori passo-passo. Diversi tipi di stampante (come specificato dall'opzione \"cinematica\" nella sezione di configurazione [stampante]) richiedono nomi diversi per lo stepper (ad esempio, stepper_x vs stepper_a ). Di seguito sono riportate le definizioni comuni di stepper. Vedere il documento distanza di rotazione per informazioni sul calcolo del parametro rotation_distance . Consultare il documento Multi-MCU homing per informazioni sull'homing utilizzando pi\u00f9 microcontrollori. [stepper_x] step_pin: # Pin GPIO Step (attivato in alto) . Questo parametro deve essere fornito. dir_pin: # Pin GPIO di direzione (alto indica una direzione positiva). # Questo parametro deve essere fornito. enable_pin: # Pin GPIO di abilitazione (l'impostazione predefinita \u00e8 abilita alto; usa ! # per indicare abilita basso). Se questo parametro non viene fornito, il # driver del motore passo-passo deve essere sempre abilitato. rotation_distance: # Distanza (in mm) che l'asse percorre con una rotazione completa del # motore passo-passo (o viene specificata la marcia finale del rapporto di # trasmissione). Questo parametro deve essere fornito. microsteps: # Il numero di micropassi utilizzati dal driver del motore passo-passo. # Questo parametro deve essere fornito. #full_steps_per_rotation: 200 # Il numero di passi completi per una rotazione del motore passo-passo. # Impostarlo su 200 per un motore passo-passo da 1.8 gradi o su 400 per # un motore da 0.9 gradi. Il valore predefinito \u00e8 200. #gear_ratio: # Il rapporto di trasmissione se il motore passo-passo \u00e8 collegato all'asse # tramite un riduttore. Ad esempio, si pu\u00f2 specificare \"5:1\" se \u00e8 in uso un # riduttore 5 a 1. Se l'asse ha pi\u00f9 riduttori, \u00e8 possibile specificare un elenco # di rapporti di trasmissione separati da virgole (ad esempio, \"57:11, 2:1\"). # Se viene specificato gear_ratio, rotation_distance specifica la distanza # percorsa dall'asse per una rotazione completa dell'ingranaggio finale. # L'impostazione predefinita \u00e8 di non utilizzare un rapporto di trasmissione. #step_pulse_duration: # Il tempo minimo tra il fronte del segnale dell'impulso del passo e il # successivo fronte del segnale \"non passo\". Viene utilizzato anche per # impostare il tempo minimo tra un impulso di passo e un segnale di cambio # di direzione. L'impostazione predefinita \u00e8 0.000000100 (100ns) per gli # stepper TMC configurati in modalit\u00e0 UART o SPI e l'impostazione # predefinita \u00e8 0.000002 (che \u00e8 2us) per tutti gli altri stepper. endstop_pin: # Pin di rilevamento interruttore di fine corsa. Se questo pin di fine corsa # si trova su un mcu diverso dal motore passo-passo, abilita il # \"homing multi-mcu\". Questo parametro deve essere fornito per gli # stepper X, Y e Z su stampanti in stile cartesiano. #position_min: 0 # Distanza minima valida (in mm) alla quale l'utente pu\u00f2 comandare # il movimento dello stepper. Il valore predefinito \u00e8 0 mm. position_endstop: # Posizione del finecorsa (in mm). Questo parametro deve essere fornito # per gli stepper X, Y e Z su stampanti in stile cartesiano. position_max: # Distanza massima valida (in mm) alla quale l'utente pu\u00f2 comandare lo # spostamento dello stepper. Questo parametro deve essere fornito per # gli stepper X, Y e Z su stampanti in stile cartesiano. #homing_speed: 5.0 # Velocit\u00e0 massima (in mm/s) dello stepper durante l'homing. # Il valore predefinito \u00e8 5 mm/s. #homing_retract_dist: 5.0 # Distanza dall'arretramento (in mm) prima della corsa di riferimento # una seconda volta durante la corsa di riferimento. Impostalo a zero per # disabilitare la seconda casa. Il valore predefinito \u00e8 5 mm. #homing_retract_speed: # Velocit\u00e0 da utilizzare nella corsa di ritorno dopo l'homing nel caso in # cui questa dovesse essere diversa dalla velocit\u00e0 di homing, che \u00e8 # l'impostazione predefinita per questo parametro #second_homing_speed: # Velocit\u00e0 (in mm/s) dello stepper durante l'esecuzione del secondo # homing. L'impostazione predefinita \u00e8 homing_speed/2. #homing_positive_dir: # Se true, l'homing far\u00e0 muovere lo stepper in una direzione positiva # (allontanandosi da zero); se falso, home verso zero. \u00c8 meglio utilizzare # l'impostazione predefinita piuttosto che specificare questo parametro. # Il valore predefinito \u00e8 true se position_endstop \u00e8 vicino a position_max # false se vicino a position_min.","title":"[stepper]"},{"location":"Config_Reference.html#cinematica-cartesiana","text":"Vedere example-cartesian.cfg per un file di configurazione della cinematica cartesiana di esempio. Qui sono descritti solo i parametri specifici delle stampanti cartesiane - vedere impostazioni cinematiche comuni per i parametri disponibili. [printer] kinematics: cartesian max_z_velocity: # Imposta la velocit\u00e0 massima (in mm/s) di movimento lungo # l'asse z. Questa impostazione pu\u00f2 essere utilizzata per limitare # la velocit\u00e0 massima del motore passo-passo z. L'impostazione # predefinita \u00e8 utilizzare max_velocity per max_z_velocity. max_z_accel: # Imposta l'accelerazione massima (in mm/s^2) del movimento # lungo l'asse z. Limita l'accelerazione del motore passo-passo z. # L'impostazione predefinita \u00e8 utilizzare max_accel per max_z_accel. # La sezione stepper_x viene utilizzata per descrivere lo stepper # che controlla l'asse X in un robot cartesiano. [stepper_x] # La sezione stepper_y viene utilizzata per descrivere lo stepper # che controlla l'asse Y in un robot cartesiano. [stepper_y] # La sezione stepper_z viene utilizzata per descrivere lo stepper # che controlla l'asse Z in un robot cartesiano. [stepper_z]","title":"Cinematica cartesiana"},{"location":"Config_Reference.html#cinematica-delta-lineare","text":"Vedere example-delta.cfg per un file di configurazione della cinematica delta lineare di esempio. Consultare la guida alla calibrazione delta per informazioni sulla calibrazione. Qui vengono descritti solo i parametri specifici per le stampanti delta lineari - vedere impostazioni cinematiche comuni per i parametri disponibili. [printer] kinematics: delta max_z_velocity: # Per le stampanti delta questo limita la velocit\u00e0 massima (in mm/s) dei # movimenti con movimento dell'asse z. Questa impostazione pu\u00f2 essere # utilizzata per ridurre la velocit\u00e0 massima dei movimenti su/gi\u00f9 (che # richiedono una velocit\u00e0 di incremento maggiore rispetto ad altri # movimenti su una stampante delta). L'impostazione predefinita \u00e8 # utilizzare max_velocity per max_z_velocity. #max_z_accel: # Imposta l'accelerazione massima (in mm/s^2) del movimento lungo # l'asse z. L'impostazione pu\u00f2 essere utile se la stampante pu\u00f2 # raggiungere un'accelerazione maggiore sui movimenti XY rispetto ai # movimenti Z (ad esempio, quando si utilizza l'input shaper). # L'impostazione predefinita \u00e8 utilizzare max_accel per max_z_accel. #minimum_z_position: 0 # La posizione Z minima in cui l'utente pu\u00f2 comandare alla testa di # spostarsi. Il valore predefinito \u00e8 0. delta_radius: # Raggio (in mm) del cerchio orizzontale formato dalle tre torri ad # asse lineare. Questo parametro pu\u00f2 anche essere calcolato come: # delta_radius = smooth_rod_offset - effector_offset - carriage_offset # Questo parametro deve essere fornito. #print_radius: # Il raggio (in mm) delle coordinate XY della testa di stampa valide. # \u00c8 possibile utilizzare questa impostazione per personalizzare il # controllo dell'intervallo dei movimenti della testa. Se qui # viene specificato un valore elevato, potrebbe essere possibile # comandare la collisione della testa di stampa con una torre. # L'impostazione predefinita \u00e8 usare delta_radius per print_radius # (che normalmente impedirebbe una collisione con torri). # La sezione stepper_a descrive lo stepper che controlla la torre # anteriore sinistra (a 210 gradi). Questa sezione controlla anche i # parametri di homing (velocit\u00e0 di homing, homing retract_dist) # per tutte le torri. [stepper_a] position_endstop: # Distanza (in mm) tra l'ugello e il piatto quando l'ugello si trova al # centro dell'area di costruzione e si attiva il finecorsa. Questo # parametro deve essere fornito per stepper_a; per stepper_b e # stepper_c questo parametro \u00e8 predefinito sul valore specificato # per stepper_a. arm_length: # Lunghezza (in mm) dell'asta diagonale che collega questa torre # alla testa di stampa. Questo parametro deve essere fornito per # stepper_a; per stepper_b e stepper_c questo parametro \u00e8 predefinito sul valore specificato per stepper_a. #angle: # Questa opzione specifica l'angolo (in gradi) a cui si trova la torre. # Il valore predefinito \u00e8 210 per stepper_a, 330 per stepper_b e 90 # per stepper_c. # La sezione stepper_b descrive lo stepper che controlla la torre # anteriore destra (a 330 gradi). [stepper_b] # La sezione stepper_c descrive lo stepper che controlla la torre # posteriore (a 90 gradi). [stepper_c] # La sezione delta_calibrate abilita un comando G-code esteso # DELTA_CALIBRATE in grado di calibrare le posizioni e gli angoli # dei finecorsa della torre. [delta_calibrate] radius: # Raggio (in mm) dell'area che pu\u00f2 essere sondata. Questo \u00e8 # il raggio delle coordinate dell'ugello da sondare; se si utilizza # una sonda automatica con un offset XY, scegliere un raggio # sufficientemente piccolo in modo che la sonda si adatti sempre # al piatto. Questo parametro deve essere fornito. #speed: 50 # La velocit\u00e0 (in mm/s) degli spostamenti senza probing durante # la calibrazione. Il valore predefinito \u00e8 50. #horizontal_move_z: 5 # L'altezza (in mm) a cui la testa deve essere comandata di # spostarsi appena prima di avviare un'operazione di sonda. # L'impostazione predefinita \u00e8 5.","title":"Cinematica Delta lineare"},{"location":"Config_Reference.html#cinematica-deltesiana","text":"Vedere example-deltesian.cfg per un esempio di file di configurazione della cinematica deltesiana. Qui sono descritti solo i parametri specifici per le stampanti deltesiane - vedere impostazioni cinematiche comuni per i parametri disponibili. [printer] kinematics: deltesian max_z_velocity: # For deltesian printers, this limits the maximum velocity (in mm/s) of # moves with z axis movement. This setting can be used to reduce the # maximum speed of up/down moves (which require a higher step rate # than other moves on a deltesian printer). The default is to use # max_velocity for max_z_velocity. #max_z_accel: # This sets the maximum acceleration (in mm/s^2) of movement along # the z axis. Setting this may be useful if the printer can reach higher # acceleration on XY moves than Z moves (eg, when using input shaper). # The default is to use max_accel for max_z_accel. #minimum_z_position: 0 # The minimum Z position that the user may command the head to move # to. The default is 0. #min_angle: 5 # This represents the minimum angle (in degrees) relative to horizontal # that the deltesian arms are allowed to achieve. This parameter is # intended to restrict the arms from becoming completely horizontal, # which would risk accidental inversion of the XZ axis. The default is 5. #print_width: # The distance (in mm) of valid toolhead X coordinates. One may use # this setting to customize the range checking of toolhead moves. If # a large value is specified here then it may be possible to command # the toolhead into a collision with a tower. This setting usually # corresponds to bed width (in mm). #slow_ratio: 3 # The ratio used to limit velocity and acceleration on moves near the # extremes of the X axis. If vertical distance divided by horizontal # distance exceeds the value of slow_ratio, then velocity and # acceleration are limited to half their nominal values. If vertical # distance divided by horizontal distance exceeds twice the value of # the slow_ratio, then velocity and acceleration are limited to one # quarter of their nominal values. The default is 3. # The stepper_left section is used to describe the stepper controlling # the left tower. This section also controls the homing parameters # (homing_speed, homing_retract_dist) for all towers. [stepper_left] position_endstop: # Distance (in mm) between the nozzle and the bed when the nozzle is # in the center of the build area and the endstops are triggered. This # parameter must be provided for stepper_left; for stepper_right this # parameter defaults to the value specified for stepper_left. arm_length: # Length (in mm) of the diagonal rod that connects the tower carriage to # the print head. This parameter must be provided for stepper_left; for # stepper_right, this parameter defaults to the value specified for # stepper_left. arm_x_length: # Horizontal distance between the print head and the tower when the # printers is homed. This parameter must be provided for stepper_left; # for stepper_right, this parameter defaults to the value specified for # stepper_left. # The stepper_right section is used to describe the stepper controlling the # right tower. [stepper_right] # The stepper_y section is used to describe the stepper controlling # the Y axis in a deltesian robot. [stepper_y]","title":"Cinematica Deltesiana"},{"location":"Config_Reference.html#cinematica-corexy","text":"Vedere example-corexy.cfg per un file cinematico corexy (e h-bot) di esempio. Qui sono descritti solo i parametri specifici per le stampanti corexy - vedere impostazioni cinematiche comuni per i parametri disponibili. [printer] kinematics: corexy max_z_velocity: # Imposta la velocit\u00e0 massima (in mm/s) di movimento lungo l'asse z. # Questa impostazione pu\u00f2 essere utilizzata per limitare la velocit\u00e0 # massima del motore passo-passo z. L'impostazione predefinita \u00e8 # utilizzare max_velocity per max_z_velocity. max_z_accel: # Imposta l'accelerazione massima (in mm/s^2) del movimento # lungo l'asse z. Limita l'accelerazione del motore passo-passo z. # L'impostazione predefinita \u00e8 utilizzare max_accel per max_z_accel. # La sezione stepper_x viene utilizzata per descrivere l'asse X e lo # stepper che controlla il movimento X+Y. [stepper_x] # La sezione stepper_y viene utilizzata per descrivere l'asse Y e lo # stepper che controlla il movimento X+Y. [stepper_y] # La sezione stepper_z viene utilizzata per descrivere l'asse Z [stepper_z]","title":"Cinematica CoreXY"},{"location":"Config_Reference.html#cinematica-corexz","text":"Vedere example-corexz.cfg per un file di configurazione della cinematica corexz di esempio. Qui sono descritti solo i parametri specifici per le stampanti corexz - vedere impostazioni cinematiche comuni per i parametri disponibili. [printer] kinematics: corexz max_z_velocity: # Imposta la velocit\u00e0 massima (in mm/s) di movimento lungo l'asse z. # L'impostazione predefinita \u00e8 utilizzare max_velocity per # max_z_velocity. max_z_accel: # Imposta l'accelerazione massima (in mm/s^2) del movimento lungo # l'asse z. L'impostazione predefinita \u00e8 utilizzare max_accel per # max_z_accel. # La sezione stepper_x viene utilizzata per descrivere l'asse X e lo # stepper che controlla il movimento X+Z. [stepper_x] # La sezione stepper_y viene utilizzata per descrivere l'asse Y [stepper_y] # La sezione stepper_z viene utilizzata per descrivere l'asse Z e lo # stepper che controlla il movimento X+Z. [stepper_z]","title":"Cinematica CoreXZ"},{"location":"Config_Reference.html#cinematica-hybrid-corexy","text":"Vedere example-hybrid-corexy.cfg per un file di configurazione della cinematica corexy ibrida di esempio. Questa cinematica \u00e8 anche nota come cinematica Markforged. Qui vengono descritti solo i parametri specifici delle stampanti corexy ibride, vedere impostazioni cinematiche comuni per i parametri disponibili. [printer] kinematics: hybrid_corexy max_z_velocity: # Imposta la velocit\u00e0 massima (in mm/s) di movimento lungo # l'asse z. L'impostazione predefinita \u00e8 utilizzare max_velocity # per max_z_velocity. max_z_accel: # Imposta l'accelerazione massima (in mm/s^2) del movimento # lungo l'asse z. L'impostazione predefinita \u00e8 utilizzare max_accel # per max_z_accel. # La sezione stepper_x viene utilizzata per descrivere l'asse X e lo # stepper che controlla il movimento X-Y. [stepper_x] # La sezione stepper_y viene utilizzata per descrivere lo stepper # che controlla l'asse Y. [stepper_y] # La sezione stepper_z viene utilizzata per descrivere lo stepper # che controlla l'asse Z. [stepper_z]","title":"Cinematica Hybrid-CoreXY"},{"location":"Config_Reference.html#cinematica-hybrid-corexz","text":"Vedere example-hybrid-corexz.cfg per un file di configurazione della cinematica corexz ibrido di esempio. Questa cinematica \u00e8 anche nota come cinematica Markforged. Qui vengono descritti solo i parametri specifici delle stampanti corexy ibride, vedere impostazioni cinematiche comuni per i parametri disponibili. [printer] kinematics: hybrid_corexz max_z_velocity: # Questo imposta la velocit\u00e0 massima (in mm/s) di movimento lungo # l'asse z. L'impostazione predefinita \u00e8 utilizzare max_velocity per # max_z_velocity. max_z_accel: # Imposta l'accelerazione massima (in mm/s^2) del movimento lungo # l'asse z. L'impostazione predefinita \u00e8 utilizzare max_accel per # max_z_accel. # La sezione stepper_x viene utilizzata per descrivere l'asse X e lo # stepper che controlla il movimento X-Z. [stepper_x] # La sezione stepper_y viene utilizzata per descrivere lo stepper che # controlla l'asse Y. [stepper_y] # La sezione stepper_z viene utilizzata per descrivere lo stepper che # controlla l'asse Z. [stepper_z]","title":"Cinematica Hybrid-CoreXZ"},{"location":"Config_Reference.html#cinematica-polare","text":"Vedere example-polar.cfg per un file di configurazione della cinematica polare di esempio. Qui sono descritti solo i parametri specifici per le stampanti polari - vedere impostazioni cinematiche comuni per i parametri disponibili. LA CINEMATICA POLARE \u00c8 UN LAVORO IN CORSO. \u00c8 noto che i movimenti intorno alla posizione 0, 0 non funzionano correttamente. [printer] kinematics: polar max_z_velocity: # Imposta la velocit\u00e0 massima (in mm/s) di movimento lungo l'asse z. # Questa impostazione pu\u00f2 essere utilizzata per limitare la velocit\u00e0 # massima del motore passo-passo z. L'impostazione predefinita \u00e8 # utilizzare max_velocity per max_z_velocity. max_z_accel: # Questo imposta l'accelerazione massima (in mm/s^2) del # movimento lungo l'asse z. Limita l'accelerazione del motore # passo-passo z. L'impostazione predefinita \u00e8 utilizzare max_accel # per max_z_accel. # La sezione stepper_bed viene utilizzata per descrivere lo stepper # che controlla il piatto [stepper_bed] gear_ratio: # \u00c8 necessario specificare un gear_ratio e rotation_distance # potrebbe non essere specificato. Ad esempio, se il piatto ha una # ruota a 80 denti azionata da uno stepper con una ruota a 16 # denti, si dovrebbe specificare un rapporto di trasmissione di \"80:16\". # Questo parametro deve essere fornito. # La sezione stepper_arm \u00e8 usata per descrivere lo stepper che # controlla il carrello sul braccio. [stepper_arm] # La sezione stepper_z viene utilizzata per descrivere lo stepper che # controlla l'asse Z. [stepper_z]","title":"Cinematica polare"},{"location":"Config_Reference.html#cinematica-delta-rotatoria","text":"Vedere example-rotary-delta.cfg per un esempio di file di configurazione della cinematica delta rotante. Qui vengono descritti solo i parametri specifici delle stampanti delta rotative - vedere impostazioni cinematiche comuni per i parametri disponibili. LA CINEMATICA DELTA ROTANTE \u00c8 UN LAVORO IN CORSO. Gli spostamenti di homing potrebbero scadere e alcuni controlli dei confini non vengono implementati. [printer] kinematics: rotary_delta max_z_velocity: # For delta printers this limits the maximum velocity (in mm/s) of # moves with z axis movement. This setting can be used to reduce the # maximum speed of up/down moves (which require a higher step rate # than other moves on a delta printer). The default is to use # max_velocity for max_z_velocity. #minimum_z_position: 0 # The minimum Z position that the user may command the head to move # to. The default is 0. shoulder_radius: # Radius (in mm) of the horizontal circle formed by the three # shoulder joints, minus the radius of the circle formed by the # effector joints. This parameter may also be calculated as: # shoulder_radius = (delta_f - delta_e) / sqrt(12) # This parameter must be provided. shoulder_height: # Distance (in mm) of the shoulder joints from the bed, minus the # effector toolhead height. This parameter must be provided. # The stepper_a section describes the stepper controlling the rear # right arm (at 30 degrees). This section also controls the homing # parameters (homing_speed, homing_retract_dist) for all arms. [stepper_a] gear_ratio: # A gear_ratio must be specified and rotation_distance may not be # specified. For example, if the arm has an 80 toothed pulley driven # by a pulley with 16 teeth, which is in turn connected to a 60 # toothed pulley driven by a stepper with a 16 toothed pulley, then # one would specify a gear ratio of \"80:16, 60:16\". This parameter # must be provided. position_endstop: # Distance (in mm) between the nozzle and the bed when the nozzle is # in the center of the build area and the endstop triggers. This # parameter must be provided for stepper_a; for stepper_b and # stepper_c this parameter defaults to the value specified for # stepper_a. upper_arm_length: # Length (in mm) of the arm connecting the \"shoulder joint\" to the # \"elbow joint\". This parameter must be provided for stepper_a; for # stepper_b and stepper_c this parameter defaults to the value # specified for stepper_a. lower_arm_length: # Length (in mm) of the arm connecting the \"elbow joint\" to the # \"effector joint\". This parameter must be provided for stepper_a; # for stepper_b and stepper_c this parameter defaults to the value # specified for stepper_a. #angle: # This option specifies the angle (in degrees) that the arm is at. # The default is 30 for stepper_a, 150 for stepper_b, and 270 for # stepper_c. # The stepper_b section describes the stepper controlling the rear # left arm (at 150 degrees). [stepper_b] # The stepper_c section describes the stepper controlling the front # arm (at 270 degrees). [stepper_c] # The delta_calibrate section enables a DELTA_CALIBRATE extended # g-code command that can calibrate the shoulder endstop positions. [delta_calibrate] radius: # Radius (in mm) of the area that may be probed. This is the radius # of nozzle coordinates to be probed; if using an automatic probe # with an XY offset then choose a radius small enough so that the # probe always fits over the bed. This parameter must be provided. #speed: 50 # The speed (in mm/s) of non-probing moves during the calibration. # The default is 50. #horizontal_move_z: 5 # The height (in mm) that the head should be commanded to move to # just prior to starting a probe operation. The default is 5.","title":"Cinematica delta rotatoria"},{"location":"Config_Reference.html#cinematica-dellargano-a-fune","text":"Vedere example-winch.cfg per un esempio di file di configurazione della cinematica con verricello, cable winch. Qui sono descritti solo i parametri specifici per le stampanti cavo verricello - vedere impostazioni comuni cinematiche per i parametri disponibili. IL SUPPORTO DEL VERRICELLO \u00c8 SPERIMENTALE. L'homing non \u00e8 implementato nella cinematica del verricello. Per riportare la stampante alla posizione iniziale, inviare manualmente i comandi di movimento finch\u00e9 la testa utensile non si trova su 0, 0, 0, quindi emettere un comando \"G28\". [printer] kinematics: winch # The stepper_a section describes the stepper connected to the first # cable winch. A minimum of 3 and a maximum of 26 cable winches may be # defined (stepper_a to stepper_z) though it is common to define 4. [stepper_a] rotation_distance: # The rotation_distance is the nominal distance (in mm) the toolhead # moves towards the cable winch for each full rotation of the # stepper motor. This parameter must be provided. anchor_x: anchor_y: anchor_z: # The X, Y, and Z position of the cable winch in cartesian space. # These parameters must be provided.","title":"Cinematica dell'argano a fune"},{"location":"Config_Reference.html#nessuna-cinematica","text":"\u00c8 possibile definire una cinematica speciale \"none\" per disabilitare il supporto cinematico in Klipper. Questo pu\u00f2 essere utile per controllare dispositivi che non sono le tipiche stampanti 3D o per scopi di debug. [printer] kinematics: none max_velocity: 1 max_accel: 1 # \u00c8 necessario definire i parametri max_velocity e max_accel. I valori # non vengono utilizzati per la cinematica \"none\".","title":"Nessuna cinematica"},{"location":"Config_Reference.html#supporto-per-estrusore-e-piatto-riscaldato-comuni","text":"","title":"Supporto per estrusore e piatto riscaldato comuni"},{"location":"Config_Reference.html#extruder","text":"La sezione dell'estrusore viene utilizzata per descrivere i parametri del riscaldatore per l'hotend dell'ugello insieme allo stepper che controlla l'estrusore. Per ulteriori informazioni, vedere riferimento comando . Consultare la Guida all'avanzamento della pressione per informazioni sulla regolazione dell'anticipo della pressione. [extruder] step_pin: dir_pin: enable_pin: microsteps: rotation_distance: #full_steps_per_rotation: #gear_ratio: # Vedere la sezione \"stepper\" per una descrizione di quanto sopra # Se nessuno dei parametri precedenti \u00e8 specificato, nessuno stepper # sar\u00e0 associato all'hotend dell'ugello (sebbene un comando # SYNC_EXTRUDER_MOTION possa associarne uno in fase di esecuzione). nozzle_diameter: # Diametro dell'orifizio dell'ugello (in mm). Questo parametro deve essere fornito. filament_diameter:: # Il diametro nominale del filamento grezzo (in mm) quando # entra nell'estrusore. Questo parametro deve essere fornito. #max_extrude_cross_section: # Area massima (in mm^2) di una sezione trasversale dell'estrusione # (ad es. larghezza dell'estrusione moltiplicata per l'altezza dello strato). # Questa impostazione previene quantit\u00e0 eccessive di estrusione # durante spostamenti XY relativamente piccoli. # Se un movimento richiede una velocit\u00e0 di estrusione che supererebbe questo valore # causer\u00e0 la restituzione di un errore. L'impostazione predefinita # \u00e8: 4.0 * diametro_ugello^2 instantaneous_corner_velocity: 1.000 # La variazione di velocit\u00e0 istantanea massima (in mm/s) del # estrusore durante il collegamento di due movimenti. Il valore predefinito \u00e8 1 mm/s. #max_extrude_only_distance: 50.0 # Lunghezza massima (in mm di filamento grezzo) che pu\u00f2 avere un movimento # di retrazione o di sola estrusione. Se uno spostamento di retrazione # o di sola estrusione richiede una distanza maggiore di questo valore, # verr\u00e0 restituito un errore. Il valore predefinito \u00e8 50 mm. #max_extrude_only_velocity: #max_extrude_only_accel: # Velocit\u00e0 massima (in mm/s) e accelerazione (in mm/s^2) del # motore estrusore per retrazioni e movimenti di sola estrusione. # Queste impostazioni non hanno alcun impatto sui normali movimenti di stampa. # Se non specificati, vengono calcolati per corrispondere al limite che avrebbe # un movimento di stampa XY con una sezione trasversale di 4,0*diametro_ugello^2. #pressure_advance: 0.0 # La quantit\u00e0 di filamento grezzo da spingere nell'estrusore durante # accelerazione dell'estrusore. Una uguale quantit\u00e0 di filamento viene # retratta durante la decelerazione. Si misura in millimetri per # millimetro/secondo. Il valore predefinito \u00e8 0, che disabilita l'avanzamento della pressione. #pressure_advance_smooth_time: 0,040 # Un intervallo di tempo (in secondi) da utilizzare per calcolare la velocit\u00e0 media # dell'estrusore per l'avanzamento della pressione. Un valore maggiore si traduce # in movimenti pi\u00f9 fluidi dell'estrusore. Questo parametro non pu\u00f2 superare i 200 ms. # Questa impostazione si applica solo se pressure_advance \u00e8 diverso da zero. # Il valore predefinito \u00e8 0,040 (40 millisecondi). # # Le restanti variabili descrivono il riscaldatore dell'estrusore. heater_pin: # Pin di uscita PWM che controlla il riscaldatore. Questo parametro deve essere fornito. #max_power: 1.0 # La potenza massima (espressa come un valore compreso tra 0,0 e 1,0) a cui # pu\u00f2 essere impostato il riscaldatore_pin. Il valore 1.0 consente di impostare il pin # completamente abilitato per periodi prolungati, mentre un valore di 0,5 # consentirebbe di abilitare il pin per non pi\u00f9 della met\u00e0 del tempo. Questo # l'impostazione pu\u00f2 essere utilizzata per limitare la potenza totale # (per periodi prolungati) al riscaldatore. L'impostazione predefinita \u00e8 1.0. sensor_type: # Tipo di sensore - i termistori comuni sono \"EPCOS 100K B57560G104F\", # \"ATC Semitec 104GT-2\", \"ATC Semitec 104NT-4-R025H42G\", \"Generico # 3950\",\"Honeywell 100K 135-104LAG-J01\", \"NTC 100K MGB18-104F39050L32\", # \"SliceEngineering 450\" e \"TDK NTCG104LH104JT1\". Vedere la sezione # \"Sensori di temperatura\" per altri sensori. Questo parametro deve essere fornito. sensor_pin: # Pin di ingresso analogico collegato al sensore. Questo parametro deve essere fornito. #pullup_resistor: 4700 # La resistenza (in ohm) del pullup collegato al termistore. Questo parametro # \u00e8 valido solo quando il sensore \u00e8 un termistore. Il valore predefinito \u00e8 4700 ohm. #smooth_time: 1.0 # Un valore di tempo (in secondi) durante il quale le misurazioni della # temperatura verranno uniformate per ridurre l'impatto del rumore # di misurazione. Il valore predefinito \u00e8 1 secondo. control: # Algoritmo di controllo (pid o filigrana). Questo parametro deve # essere fornito. pid_Kp: pid_Ki: pid_Kd: # Il proporzionale (pid_Kp), l'integrale (pid_Ki) e la derivata # (pid_Kd) impostazioni per il sistema di controllo del feedback PID. Klipper # valuta le impostazioni PID con la seguente formula generale: # riscaldatore_pwm = (Kp*errore + Ki*integrale(errore) - Kd*derivato(errore)) / 255 # Dove \"errore\" \u00e8 \"temperatura_richiesta - temperatura_misurata\" # e \"heater_pwm\" \u00e8 la velocit\u00e0 di riscaldamento richiesta con 0,0 completamente # off e 1.0 completamente on. Prendi in considerazione l'utilizzo di PID_CALIBRATE # comando per ottenere questi parametri. pid_Kp, pid_Ki e pid_Kd # i parametri devono essere forniti per i riscaldatori PID. #delta_max: 2.0 # Sui riscaldatori controllati questo \u00e8 il numero di gradi in # Celsius al di sopra della temperatura target prima di disattivare il riscaldatore # cos\u00ec come il numero di gradi sotto il target prima # riattivare il riscaldatore. L'impostazione predefinita \u00e8 2 gradi Celsius. #pwm_cycle_time: 0,100 # Tempo in secondi per ogni ciclo PWM software del riscaldatore. # non \u00e8 consigliabile impostarlo a meno che non ci sia necessario come # requisito accendere il riscaldatore pi\u00f9 velocemente di 10 volte al secondo. # Il valore predefinito \u00e8 0,100 secondi. #min_extrude_temp: 170 # La temperatura minima (in gradi Celsius) alla quale possono essere # impartiti comandi all'estrusore. L'impostazione predefinita \u00e8 170 gradi Celsius. min_temp: max_temp: # L'intervallo massimo di temperature valide (in gradi Celsius) in cui # il riscaldatore deve rimanere all'interno. Questo controlla una funzione di sicurezza # implementata nel codice del microcontrollore , la temperatura # non cadr\u00e0 mai al di fuori di questo intervallo, altrimenti il microcontrollore # entrer\u00e0 in uno stato di arresto. Questo controllo pu\u00f2 aiutare a rilevarne alcuni # guasti hardware del riscaldatore e del sensore. Imposta questo intervallo solo in modo ampio # abbastanza in modo che temperature ragionevoli non si traducano in un errore. # Questi parametri devono essere forniti.","title":"[extruder]"},{"location":"Config_Reference.html#heater_bed","text":"La sezione heater_bed descrive un piatto riscaldato. Utilizza le stesse impostazioni del riscaldatore descritte nella sezione \"extruder\". [heater_bed] heater_pin: sensor_type: sensor_pin: control: min_temp: max_temp: # Vedere la sezione \"extruder\" per una descrizione dei parametri sopra.","title":"[heater_bed]"},{"location":"Config_Reference.html#supporto-livellamento-del-piatto","text":"","title":"Supporto livellamento del piatto"},{"location":"Config_Reference.html#bed_mesh","text":"Mesh Bed Leveling. Si pu\u00f2 definire una sezione di configurazione bed_mesh per abilitare trasformazioni di spostamento che sfalsano l'asse z in base a una mesh generata da punti sondati. Quando si utilizza una sonda per la posizione di riferimento sull'asse z, si consiglia di definire una sezione safe_z_home in printer.cfg per la posizione di riferimento verso il centro dell'area di stampa. Per ulteriori informazioni, vedere la bed mesh guide e riferimento del comando . Esempi visivi: rectangular bed, probe_count = 3, 3: x---x---x (max_point) | x---x---x | (min_point) x---x---x round bed, round_probe_count = 5, bed_radius = r: x (0, r) end / x---x---x \\ (-r, 0) x---x---x---x---x (r, 0) \\ x---x---x / x (0, -r) start [bed_mesh] #speed: 50 # The speed (in mm/s) of non-probing moves during the calibration. # The default is 50. #horizontal_move_z: 5 # The height (in mm) that the head should be commanded to move to # just prior to starting a probe operation. The default is 5. #mesh_radius: # Defines the radius of the mesh to probe for round beds. Note that # the radius is relative to the coordinate specified by the # mesh_origin option. This parameter must be provided for round beds # and omitted for rectangular beds. #mesh_origin: # Defines the center X, Y coordinate of the mesh for round beds. This # coordinate is relative to the probe's location. It may be useful # to adjust the mesh_origin in an effort to maximize the size of the # mesh radius. Default is 0, 0. This parameter must be omitted for # rectangular beds. #mesh_min: # Defines the minimum X, Y coordinate of the mesh for rectangular # beds. This coordinate is relative to the probe's location. This # will be the first point probed, nearest to the origin. This # parameter must be provided for rectangular beds. #mesh_max: # Defines the maximum X, Y coordinate of the mesh for rectangular # beds. Adheres to the same principle as mesh_min, however this will # be the furthest point probed from the bed's origin. This parameter # must be provided for rectangular beds. #probe_count: 3, 3 # For rectangular beds, this is a comma separate pair of integer # values X, Y defining the number of points to probe along each # axis. A single value is also valid, in which case that value will # be applied to both axes. Default is 3, 3. #round_probe_count: 5 # For round beds, this integer value defines the maximum number of # points to probe along each axis. This value must be an odd number. # Default is 5. #fade_start: 1.0 # The gcode z position in which to start phasing out z-adjustment # when fade is enabled. Default is 1.0. #fade_end: 0.0 # The gcode z position in which phasing out completes. When set to a # value below fade_start, fade is disabled. It should be noted that # fade may add unwanted scaling along the z-axis of a print. If a # user wishes to enable fade, a value of 10.0 is recommended. # Default is 0.0, which disables fade. #fade_target: # The z position in which fade should converge. When this value is # set to a non-zero value it must be within the range of z-values in # the mesh. Users that wish to converge to the z homing position # should set this to 0. Default is the average z value of the mesh. #split_delta_z: .025 # The amount of Z difference (in mm) along a move that will trigger # a split. Default is .025. #move_check_distance: 5.0 # The distance (in mm) along a move to check for split_delta_z. # This is also the minimum length that a move can be split. Default # is 5.0. #mesh_pps: 2, 2 # A comma separated pair of integers X, Y defining the number of # points per segment to interpolate in the mesh along each axis. A # \"segment\" can be defined as the space between each probed point. # The user may enter a single value which will be applied to both # axes. Default is 2, 2. #algorithm: lagrange # The interpolation algorithm to use. May be either \"lagrange\" or # \"bicubic\". This option will not affect 3x3 grids, which are forced # to use lagrange sampling. Default is lagrange. #bicubic_tension: .2 # When using the bicubic algorithm the tension parameter above may # be applied to change the amount of slope interpolated. Larger # numbers will increase the amount of slope, which results in more # curvature in the mesh. Default is .2. #zero_reference_position: # An optional X,Y coordinate that specifies the location on the bed # where Z = 0. When this option is specified the mesh will be offset # so that zero Z adjustment occurs at this location. The default is # no zero reference. #faulty_region_1_min: #faulty_region_1_max: # Optional points that define a faulty region. See docs/Bed_Mesh.md # for details on faulty regions. Up to 99 faulty regions may be added. # By default no faulty regions are set. #adaptive_margin: # An optional margin (in mm) to be added around the bed area used by # the defined print objects when generating an adaptive mesh. #scan_overshoot: # The maximum amount of travel (in mm) available outside of the mesh. # For rectangular beds this applies to travel on the X axis, and for round beds # it applies to the entire radius. The tool must be able to travel the amount # specified outside of the mesh. This value is used to optimize the travel # path when performing a \"rapid scan\". The minimum value that may be specified # is 1. The default is no overshoot.","title":"[bed_mesh]"},{"location":"Config_Reference.html#bed_tilt","text":"Compensazione dell'inclinazione del piatto. Si pu\u00f2 definire una sezione di configurazione bed_tilt per abilitare le trasformazioni di movimento che tengono conto di un piatto inclinato. Nota che bed_mesh e bed_tilt sono incompatibili; entrambi non possono essere definiti. Per ulteriori informazioni, vedere riferimento comando . [bed_tilt] #x_adjust: 0 # The amount to add to each move's Z height for each mm on the X # axis. The default is 0. #y_adjust: 0 # The amount to add to each move's Z height for each mm on the Y # axis. The default is 0. #z_adjust: 0 # The amount to add to the Z height when the nozzle is nominally at # 0, 0. The default is 0. # The remaining parameters control a BED_TILT_CALIBRATE extended # g-code command that may be used to calibrate appropriate x and y # adjustment parameters. #points: # A list of X, Y coordinates (one per line; subsequent lines # indented) that should be probed during a BED_TILT_CALIBRATE # command. Specify coordinates of the nozzle and be sure the probe # is above the bed at the given nozzle coordinates. The default is # to not enable the command. #speed: 50 # The speed (in mm/s) of non-probing moves during the calibration. # The default is 50. #horizontal_move_z: 5 # The height (in mm) that the head should be commanded to move to # just prior to starting a probe operation. The default is 5.","title":"[bed_tilt]"},{"location":"Config_Reference.html#bed_screws","text":"Strumento per aiutare a regolare le viti di livellamento del letto. Si pu\u00f2 definire una sezione di configurazione [bed_screws] per abilitare un comando g-code BED_SCREWS_ADJUST. Per ulteriori informazioni, vedere la guida al livellamento e il riferimento al comando . [bed_screws] #screw1: # The X, Y coordinate of the first bed leveling screw. This is a # position to command the nozzle to that is directly above the bed # screw (or as close as possible while still being above the bed). # This parameter must be provided. #screw1_name: # An arbitrary name for the given screw. This name is displayed when # the helper script runs. The default is to use a name based upon # the screw XY location. #screw1_fine_adjust: # An X, Y coordinate to command the nozzle to so that one can fine # tune the bed leveling screw. The default is to not perform fine # adjustments on the bed screw. #screw2: #screw2_name: #screw2_fine_adjust: #... # Additional bed leveling screws. At least three screws must be # defined. #horizontal_move_z: 5 # The height (in mm) that the head should be commanded to move to # when moving from one screw location to the next. The default is 5. #probe_height: 0 # The height of the probe (in mm) after adjusting for the thermal # expansion of bed and nozzle. The default is zero. #speed: 50 # The speed (in mm/s) of non-probing moves during the calibration. # The default is 50. #probe_speed: 5 # The speed (in mm/s) when moving from a horizontal_move_z position # to a probe_height position. The default is 5.","title":"[bed_screws]"},{"location":"Config_Reference.html#screws_tilt_adjust","text":"Strumento per aiutare a regolare l'inclinazione delle viti del piatto utilizzando la sonda Z. Si pu\u00f2 definire una sezione di configurazione Screws_tilt_adjust per abilitare un comando g-code SCREWS_TILT_CALCULATE. Per ulteriori informazioni, vedere la guida al livellamento e riferimento al comando . [screws_tilt_adjust] #screw1: # The (X, Y) coordinate of the first bed leveling screw. This is a # position to command the nozzle to so that the probe is directly # above the bed screw (or as close as possible while still being # above the bed). This is the base screw used in calculations. This # parameter must be provided. #screw1_name: # An arbitrary name for the given screw. This name is displayed when # the helper script runs. The default is to use a name based upon # the screw XY location. #screw2: #screw2_name: #... # Additional bed leveling screws. At least two screws must be # defined. #speed: 50 # The speed (in mm/s) of non-probing moves during the calibration. # The default is 50. #horizontal_move_z: 5 # The height (in mm) that the head should be commanded to move to # just prior to starting a probe operation. The default is 5. #screw_thread: CW-M3 # The type of screw used for bed leveling, M3, M4, or M5, and the # rotation direction of the knob that is used to level the bed. # Accepted values: CW-M3, CCW-M3, CW-M4, CCW-M4, CW-M5, CCW-M5. # Default value is CW-M3 which most printers use. A clockwise # rotation of the knob decreases the gap between the nozzle and the # bed. Conversely, a counter-clockwise rotation increases the gap.","title":"[screws_tilt_adjust]"},{"location":"Config_Reference.html#z_tilt","text":"Regolazione multipla dell'inclinazione dello stepper Z. Questa funzione consente la regolazione indipendente di pi\u00f9 stepper z (vedere la sezione \"stepper_z1\") per regolare l'inclinazione. Se questa sezione \u00e8 presente, diventa disponibile un comando G-Code esteso Z_TILT_ADJUST. [z_tilt] #z_positions: # Un elenco di coordinate X, Y (una per riga; le righe successive # identate) che descrivono la posizione di ciascun \"pivot point\" # del piattotto. Il \"pivot point\" \u00e8 il punto in cui il piatto si attacca # al dato stepper Z. Viene descritto utilizzando le coordinate dell'ugello # (la posizione X, Y dell'ugello se potesse spostarsi direttamente sopra # il punto). La prima voce corrisponde a stepper_z, la seconda a # stepper_z1, la terza a stepper_z2, ecc. # Questo parametro deve essere fornito. #points: # Un elenco di coordinate X, Y (una per riga; righe successive identate) # che devono essere rilevate durante un comando Z_TILT_ADJUST. # Specificare le coordinate dell'ugello e assicurarsi che la sonda sia # sopra il piatto alle coordinate dell'ugello date. # Questo parametro deve essere fornito. #speed: 50 # La velocit\u00e0 (in mm/s) degli spostamenti senza probing durante # la calibrazione. Il valore predefinito \u00e8 50. #horizontal_move_z: 5 # L'altezza (in mm) a cui la testa deve essere comandata per spostarsi # appena prima di avviare un'operazione di probing. # L'impostazione predefinita \u00e8 5. #retries: 0 # Numero di volte per riprovare se i punti rilevati non sono all'interno # della tolleranza. #retry_tolerance: 0 # Se i tentativi sono abilitati, riprovare se i punti sondati pi\u00f9 grande e # pi\u00f9 piccolo differiscono pi\u00f9 di retry_tolerance. Nota che l'unit\u00e0 di # modifica pi\u00f9 piccola qui sarebbe un singolo passaggio. # Tuttavia, se stai sondando pi\u00f9 punti rispetto agli stepper, # probabilmente avrai un valore minimo fisso per l'intervallo di punti # sondati che puoi apprendere osservando l'output del comando.","title":"[z_tilt]"},{"location":"Config_Reference.html#quad_gantry_level","text":"Livellamento del gantly mediante 4 motori Z controllati in modo indipendente. Corregge gli effetti della parabola iperbolica (patatine fritte) sul portale mobile che \u00e8 pi\u00f9 flessibile. ATTENZIONE: l'utilizzo su un letto mobile pu\u00f2 portare a risultati indesiderati. Se questa sezione \u00e8 presente, diventa disponibile un comando G-Code esteso QUAD_GANTRY_LEVEL. Questa routine presuppone la seguente configurazione del motore Z: ---------------- |Z1 Z2| | --------- | | | | | | | | | | x-------- | |Z Z3| ---------------- Dove x \u00e8 il punto 0, 0 sul piatto [quad_gantry_level] #gantry_corners: # A newline separated list of X, Y coordinates describing the two # opposing corners of the gantry. The first entry corresponds to Z, # the second to Z2. This parameter must be provided. #points: # A newline separated list of four X, Y points that should be probed # during a QUAD_GANTRY_LEVEL command. Order of the locations is # important, and should correspond to Z, Z1, Z2, and Z3 location in # order. This parameter must be provided. For maximum accuracy, # ensure your probe offsets are configured. #speed: 50 # The speed (in mm/s) of non-probing moves during the calibration. # The default is 50. #horizontal_move_z: 5 # The height (in mm) that the head should be commanded to move to # just prior to starting a probe operation. The default is 5. #max_adjust: 4 # Safety limit if an adjustment greater than this value is requested # quad_gantry_level will abort. #retries: 0 # Number of times to retry if the probed points aren't within # tolerance. #retry_tolerance: 0 # If retries are enabled then retry if largest and smallest probed # points differ more than retry_tolerance.","title":"[quad_gantry_level]"},{"location":"Config_Reference.html#skew_correction","text":"Correzione dell'inclinazione della stampante. \u00c8 possibile utilizzare il software per correggere l'inclinazione della stampante su 3 piani, xy, xz, yz. Questo viene fatto stampando un modello di calibrazione lungo un piano e misurando tre lunghezze. A causa della natura della correzione dell'inclinazione, queste lunghezze vengono impostate tramite gcode. Per i dettagli, vedere Correzione inclinazione e Command Reference . [skew_correction]","title":"[skew_correction]"},{"location":"Config_Reference.html#z_thermal_adjust","text":"Regolazione della posizione Z della testa di stampa in funzione della temperatura. Compensare il movimento verticale della testina utensile causato dall'espansione termica del telaio della stampante in tempo reale utilizzando un sensore di temperatura (tipicamente accoppiato a una sezione verticale del telaio). Vedi anche: comandi g-code estesi . [z_thermal_adjust] #temp_coeff: # Il coefficiente di dilatazione della temperatura, in mm/degC. Ad esempio, un # temp_coeff di 0,01 mm/degC sposter\u00e0 l'asse Z verso il basso di 0,01 mm per ogni # grado Celsius di auemnto del sensore di temperatura . Il valore predefinito \u00e8 # 0,0 mm/degC, che non applica alcuna regolazione. #smooth_time: # Finestra di smoothing applicata al sensore di temperatura, in secondi. Pu\u00f2 # ridurre il rumore del motore da piccole correzioni eccessive in risposta al # rumore del sensore. Il valore predefinito \u00e8 2,0 secondi. #z_adjust_off_above: # Disattiva le regolazioni al di sopra di questa altezza Z [mm]. L'ultima correzione # calcolata rimarr\u00e0 applicata finch\u00e9 la testa utensile non si sposter\u00e0 nuovamente # al di sotto dell'altezza Z specificata. # Il valore predefinito \u00e8 99999999,0 mm (sempre attivo). #max_z_adjustment: # Massima regolazione assoluta applicabile all'asse Z [mm]. Il valore predefinito # \u00e8 99999999,0 mm (illimitato). #sensor_type: #sensor_pin: #min_temp: #max_temp: # Configurazione del sensore di temperatura. Vedere la sezione \"extruder\" per # la definizione dei parametri di cui sopra. #gcode_id: # Vedere la sezione \"heater_generic\" per la definizione di questo parametro.","title":"[z_thermal_adjust]"},{"location":"Config_Reference.html#homing-personalizzato","text":"","title":"Homing personalizzato"},{"location":"Config_Reference.html#safe_z_home","text":"Homing Z sicuro. Si pu\u00f2 utilizzare questo meccanismo per posizionare l'asse Z su una specifica coordinata X, Y. Ci\u00f2 \u00e8 utile se la testa portautensili, ad esempio, deve spostarsi al centro del letto prima che Z possa essere riposizionato. [safe_z_home] home_xy_position: # Una coordinata X, Y (ad es. 100, 100) dove deve essere eseguita # homing Z. Questo parametro deve essere fornito. #speed: 50.0 # Velocit\u00e0 alla quale la testa di stampa viene spostata sulla # coordinata Z sicura. Il valore predefinito \u00e8 50 mm/s #z_hop: # Distanza (in mm) per sollevare l'asse Z prima dell'homing. # Questo si applica a qualsiasi comando di homing, anche se non # si trova sull'asse Z. Se l'asse Z \u00e8 gi\u00e0 azzerato e la posizione Z # corrente \u00e8 inferiore a z_hop, questo sollever\u00e0 la testa a un'altezza # di z_hop. Se l'asse Z non \u00e8 gi\u00e0 azzerato la testina viene sollevata # di z_hop. L'impostazione predefinita \u00e8 di non implementare Z hop. #z_hop_speed: 15.0 # Velocit\u00e0 (in mm/s) alla quale l'asse Z viene sollevato prima # del homing. Il valore predefinito \u00e8 15 mm/s. #move_to_previous: False # Quando \u00e8 impostato su True, gli assi X e Y vengono ripristinati alle # posizioni precedenti dopo l'homing dell'asse Z. # L'impostazione predefinita \u00e8 False.","title":"[safe_z_home]"},{"location":"Config_Reference.html#homing_override","text":"Homing Override. Si pu\u00f2 utilizzare questo meccanismo per eseguire una serie di comandi g-code al posto di un G28 che si trova nel normale input di g-code. Questo pu\u00f2 essere utile su stampanti che richiedono una procedura specifica per l'home della macchina. [homing_override] gcode: # Un elenco di comandi G-Code da eseguire al posto dei comandi # G28 trovati nel normale input di G-Code. # Vedi docs/Command_Templates.md per il formato G-Code. # Se un G28 \u00e8 contenuto in questo elenco di comandi, invocher\u00e0 # la normale procedura di homing per la stampante. I comandi # qui elencati devono eseguire l'home di tutti gli assi. # Questo parametro deve essere fornito. #axes: xyz # Gli assi da sovrascrivere. Ad esempio, se questo \u00e8 impostato # su \"z\", lo script di override verr\u00e0 eseguito solo quando l'asse z # \u00e8 azzerato (ad esempio, tramite un comando \"G28\" o \"G28 Z0\"). # Nota, lo script di sovrascrittura dovrebbe comunque ospitare # tutti gli assi. L'impostazione predefinita \u00e8 \"xyz\" che fa s\u00ec che lo # script di override venga eseguito al posto di tutti i comandi G28. #set_position_x: #set_position_y: #set_position_z: # Se specificato, la stampante presumer\u00e0 che l'asse si trovi # nella posizione specificata prima di eseguire i comandi g-code # precedenti. L'impostazione di questa opzione disabilita i # controlli di riferimento per quell'asse. Questo pu\u00f2 essere utile # se la testa deve muoversi prima di invocare il normale # meccanismo G28 per un asse. L'impostazione predefinita \u00e8 # di non forzare una posizione per un asse.","title":"[homing_override]"},{"location":"Config_Reference.html#endstop_phase","text":"Finecorsa regolati in fase stepper. Per utilizzare questa funzione, definire una sezione di configurazione con un prefisso \"endstop_phase\" seguito dal nome della corrispondente sezione di configurazione dello stepper (ad esempio, \"[endstop_phase stepper_z]\"). Questa funzione pu\u00f2 migliorare la precisione degli interruttori di fine corsa. Aggiungi una semplice dichiarazione \"[endstop_phase]\" per abilitare il comando ENDSTOP_PHASE_CALIBRATE. Per ulteriori informazioni, vedere la endstop phases guide e command reference . [endstop_phase stepper_z] #endstop_accuracy: # Imposta la precisione prevista (in mm) del finecorsa. Questo rappresenta # la distanza massima di errore che il finecorsa pu\u00f2 attivare (ad es. se un # finecorsa pu\u00f2 occasionalmente attivarsi 100um in anticipo o fino a 100um in ritardo # quindi impostalo su 0,200 per 200 um). L'impostazione predefinita \u00e8 # 4*distanza_rotazione/passi_completi_per_rotazione. #trigger_phase: # Questo specifica la fase del driver del motore passo-passo da aspettarsi # quando si raggiunge il finecorsa. \u00c8 composto da due numeri separati # da un '/' - la fase e il numero totale di # fasi (ad es. \"7/64\"). Impostare questo valore solo se si \u00e8 sicuri che il # driver del motore passo-passo viene ripristinato ogni volta che viene ripristinato l'mcu. Se questo # non \u00e8 impostato, la prima fase verr\u00e0 rilevata al primo home # e quella fase sar\u00e0 utilizzata su tutte le abitazioni successive. #endstop_align_zero: False # Se true, la posizione_endstop dell'asse sar\u00e0 effettivamente # modificato in modo che la posizione zero dell'asse avvenga a passo pieno # sul motore. (Se utilizzato sull'asse Z e la stampa # l'altezza del livello \u00e8 un multiplo di una distanza di un passo intero, allora ogni # layer si eseguir\u00e0 in un step completo.) L'impostazione predefinita \u00e8 False.","title":"[endstop_phase]"},{"location":"Config_Reference.html#macro-ed-eventi-g-code","text":"","title":"Macro ed eventi G-Code"},{"location":"Config_Reference.html#gcode_macro","text":"Macro G-Code (\u00e8 possibile definire un numero qualsiasi di sezioni con un prefisso \"gcode_macro\"). Per ulteriori informazioni, consulta la Guida ai modelli di comando . [gcode_macro my_cmd] #gcode: # Un elenco di comandi G-Code da eseguire al posto di \"my_cmd\". # Vedi docs/Command_Templates.md per il formato G-Code. # Questo parametro deve essere fornito. #variable_<name>: # Si pu\u00f2 specificare un numero qualsiasi di opzioni con un prefisso # \"variable_\". Al nome della variabile data verr\u00e0 assegnato il valore dato # (analizzato come un valore letterale Python) e sar\u00e0 disponibile durante # l'espansione della macro. Ad esempio, una configurazione con # \"variable_fan_speed = 75\" potrebbe avere comandi gcode contenenti # \"M106 S{ fan_speed * 255 }\". Le variabili possono essere modificate in # fase di esecuzione utilizzando il comando SET_GCODE_VARIABLE # (consultare docs/Command_Templates.md per i dettagli). # I nomi delle variabili potrebbero non utilizzare caratteri maiuscoli. #rename_existing: # Questa opzione far\u00e0 s\u00ec che la macro ignori un comando G-Code # esistente e fornisca la definizione precedente del comando tramite # il nome fornito qui. Questo pu\u00f2 essere usato per sovrascrivere i # comandi G-Code integrati. Prestare attenzione quando si ignorano # i comandi poich\u00e9 possono causare risultati complessi e imprevisti. # L'impostazione predefinita \u00e8 di non sovrascrivere un comando # G-Code esistente. #description: G-Code macro # Ci\u00f2 aggiunger\u00e0 una breve descrizione utilizzata al comando HELP # o durante l'utilizzo della funzione di completamento automatico. # Predefinito \"G-Code macro\"","title":"[gcode_macro]"},{"location":"Config_Reference.html#delayed_gcode","text":"Esegui un gcode con un ritardo impostato. Per ulteriori informazioni, consulta la Guida template dei comandi e riferimento al comando . [delayed_gcode my_delayed_gcode] gcode: # A list of G-Code commands to execute when the delay duration has # elapsed. G-Code templates are supported. This parameter must be # provided. #initial_duration: 0.0 # The duration of the initial delay (in seconds). If set to a # non-zero value the delayed_gcode will execute the specified number # of seconds after the printer enters the \"ready\" state. This can be # useful for initialization procedures or a repeating delayed_gcode. # If set to 0 the delayed_gcode will not execute on startup. # Default is 0.","title":"[delayed_gcode]"},{"location":"Config_Reference.html#save_variables","text":"Supporta il salvataggio delle variabili su disco in modo che vengano mantenute durante i riavvii. Per ulteriori informazioni, vedere template dei comandi e G-Code reference . [save_variables] filename: # Richiesto: fornire un nome file che verrebbe utilizzato per salvare # le variabili su disco, ad es. ~/variables.cfg","title":"[save_variables]"},{"location":"Config_Reference.html#idle_timeout","text":"Timeout di inattivit\u00e0. Viene automaticamente abilitato un timeout di inattivit\u00e0: aggiungi una sezione di configurazione di idle_timeout esplicita per modificare le impostazioni predefinite. [idle_timeout] #gcode: # Un elenco di comandi G-Code da eseguire in un timeout di # inattivit\u00e0. Vedi docs/Command Templates.md per il formato # G-Code. L'impostazione predefinita \u00e8 # eseguire \"TURN_OFF HEATERS\" e \"M84\". #timeout: 600 # Tempo di inattivit\u00e0 (in secondi) da attendere prima di eseguire # i comandi G-Code sopra. Il valore predefinito \u00e8 600 secondi.","title":"[idle_timeout]"},{"location":"Config_Reference.html#funzionalita-opzionali-g-code","text":"","title":"Funzionalit\u00e0 opzionali G-Code"},{"location":"Config_Reference.html#virtual_sdcard","text":"Una scheda SD virtuale pu\u00f2 essere utile se la macchina host non \u00e8 abbastanza veloce per eseguire bene OctoPrint. Consente al software host Klipper di stampare direttamente i file gcode archiviati in una directory sull'host utilizzando i comandi G-Code standard (ad esempio, M24). [virtual_sdcard] path: # The path of the local directory on the host machine to look for # g-code files. This is a read-only directory (sdcard file writes # are not supported). One may point this to OctoPrint's upload # directory (generally ~/.octoprint/uploads/ ). This parameter must # be provided. #on_error_gcode: # A list of G-Code commands to execute when an error is reported. # See docs/Command_Templates.md for G-Code format. The default is to # run TURN_OFF_HEATERS.","title":"[virtual_sdcard]"},{"location":"Config_Reference.html#sdcard_loop","text":"Alcune stampanti con funzionalit\u00e0 di pulizia del piatto, come un espulsore di parti o una stampante a nastro, possono trovare impiego nelle sezioni di loop del file sdcard. (Ad esempio, per stampare la stessa parte pi\u00f9 e pi\u00f9 volte, o ripetere la sezione a di una parte per una catena o un altro motivo ripetuto). Consulta il command reference per i comandi supportati. Vedere il file sample-macros.cfg per una macro M808 G-Code compatibile con Marlin. [sdcard_loop]","title":"[sdcard_loop]"},{"location":"Config_Reference.html#force_move","text":"Supporta lo spostamento manuale dei motori passo-passo per scopi diagnostici. Nota, l'utilizzo di questa funzione potrebbe mettere la stampante in uno stato non valido - vedere il command reference per dettagli importanti. [force_move] #enable_force_move: False # Impostare su True per abilitare FORCE_MOVE e SET_KINEMATIC_POSITION # i comandi G-Code estesi. L'impostazione predefinita \u00e8 False.","title":"[force_move]"},{"location":"Config_Reference.html#pause_resume","text":"Funzionalit\u00e0 di Pause/Resume con supporto di acquisizione e ripristino della posizione. Per ulteriori informazioni, vedere riferimento comando . [pause_resume] #recover_velocity: 50. # Quando si abilita pause_resume, la velocit\u00e0 con cui tornare alla # posizione catturata (in mm/s). Il valore predefinito \u00e8 50,0 mm/s.","title":"[pause_resume]"},{"location":"Config_Reference.html#firmware_retraction","text":"Retrazione del filamento del firmware. Ci\u00f2 abilita i comandi GCODE G10 (ritiro) e G11 (non ritirati) emessi da molti slicer. I parametri seguenti forniscono le impostazioni predefinite di avvio, sebbene i valori possano essere regolati tramite il [comando] SET_RETRACTION (G-Codes.md#firmware_retraction)), consentendo l'impostazione e l'ottimizzazione del filamento a runtime. [firmware_retraction] #retract_length: 0 # La lunghezza del filamento (in mm) da ritrarre quando G10 # \u00e8 attivato e da ritrarre quando G11 \u00e8 attivato (ma vedere # unretract_extra_length di seguito). I# l valore predefinito \u00e8 0 mm. #retract_speed: 20 # La velocit\u00e0 di retrazione, in mm/s. # Il valore predefinito \u00e8 20 mm/s. #unretract_extra_length: 0 # La lunghezza (in mm) del filamento *aggiuntivo* da # sommare quando non si ritrae. #unretract_speed: 10 # La velocit\u00e0 di srotolamento, in mm/s. # Il valore predefinito \u00e8 10 mm/s.","title":"[firmware_retraction]"},{"location":"Config_Reference.html#gcode_arcs","text":"Supporto per i comandi Gcode arc (G2/G3). [gcode_arcs] #resolution: 1.0 # Un arco sar\u00e0 diviso in segmenti. La lunghezza di ciascun segmento # sar\u00e0 uguale alla risoluzione in mm impostata sopra. Valori pi\u00f9 bassi # produrranno un arco pi\u00f9 fine, ma anche pi\u00f9 lavoro per la tua macchina. # Archi pi\u00f9 piccoli del valore configurato diventer\u00e0 linee rette. # L'impostazione predefinita \u00e8 # 1mm.","title":"[gcode_arcs]"},{"location":"Config_Reference.html#respond","text":"Abilita i comandi estesi \"M118\" e \"RESPOND\" commands . [respond] #default_type: echo # Imposta il prefisso predefinito dell'output \"M118\" e \"RESPOND\" su uno dei seguenti: # echo: \"echo: \" (Questa \u00e8 l'impostazione predefinita) # command: \"// \" # error: \"!! \" #default_prefix: echo: # Imposta direttamente il prefisso predefinito. Se presente # questo valore sovrascriver\u00e0 il \"default_type\".","title":"[respond]"},{"location":"Config_Reference.html#exclude_object","text":"Abilita il supporto per escludere o cancellare singoli oggetti durante il processo di stampa. Per ulteriori informazioni, vedere la guida escludi oggetti e riferimento ai comandi . Vedere il file sample-macros.cfg per una macro G-Code M486 compatibile con Marlin/RepRapFirmware. [exclude_object]","title":"[exclude_object]"},{"location":"Config_Reference.html#compensazione-della-risonanza","text":"","title":"Compensazione della risonanza"},{"location":"Config_Reference.html#input_shaper","text":"Abilita compensazione della risonanza . Vedere anche il command reference . [input_shaper] #shaper_freq_x: 0 # Una frequenza (in Hz) dell'input shaper per l'asse X. Questa \u00e8 # solitamente una frequenza di risonanza dell'asse X che l'input # shaper dovrebbe sopprimere. Per shaper pi\u00f9 complessi, come # shaper di input EI a 2 e 3 gobbe, questo parametro pu\u00f2 essere # impostato in base a diverse considerazioni. # Il valore predefinito \u00e8 0, che disabilita la modellatura dell'input # per l'asse X. #shaper_freq_y: 0 # Una frequenza (in Hz) dell'input shaper per l'asse Y. Questa \u00e8 # solitamente una frequenza di risonanza dell'asse Y che l'input # shaper dovrebbe sopprimere. Per shaper pi\u00f9 complessi, come # shaper di input EI a 2 e 3 gobbe, questo parametro pu\u00f2 essere # impostato in base a diverse considerazioni. Il valore predefinito # \u00e8 0, che disabilita la modellatura dell'input per l'asse Y. #shaper_type: mzv # Un tipo di input shaper da utilizzare per entrambi gli assi X e Y. # Gli shaper supportati sono zv, mzv, zvd, ei, 2hump_ei e # 3hump_ei. L'impostazione predefinita \u00e8 mzv input shaper. #shaper_type_x: #shaper_type_y: # Se shaper_type non \u00e8 impostato, questi due parametri possono # essere utilizzati per configurare diversi shaper di input per gli # assi X e Y. Sono supportati gli stessi valori del parametro # shaper_type. #damping_ratio_x: 0.1 #damping_ratio_y: 0.1 # Rapporti di smorzamento delle vibrazioni degli assi X e Y # utilizzati dagli shaper di input per migliorare la soppressione # delle vibrazioni. Il valore predefinito \u00e8 0,1, un buon valore per la # maggior parte delle stampanti. Nella maggior parte dei casi # questo parametro non richiede ottimizzazione e # non deve essere modificato.","title":"[input_shaper]"},{"location":"Config_Reference.html#adxl345","text":"Supporto per accelerometri ADXL345. Questo supporto consente di interrogare le misurazioni dell'accelerometro dal sensore. Ci\u00f2 abilita un comando ACCELEROMETER_MEASURE (consultare G-Codes per ulteriori informazioni). Il nome del chip predefinito \u00e8 \"predefinito\", ma \u00e8 possibile specificare un nome esplicito (ad esempio, [adxl345 my_chip_name]). [adxl345] cs_pin: # The SPI enable pin for the sensor. This parameter must be provided. #spi_speed: 5000000 # The SPI speed (in hz) to use when communicating with the chip. # The default is 5000000. #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. #axes_map: x, y, z # The accelerometer axis for each of the printer's X, Y, and Z axes. # This may be useful if the accelerometer is mounted in an # orientation that does not match the printer orientation. For # example, one could set this to \"y, x, z\" to swap the X and Y axes. # It is also possible to negate an axis if the accelerometer # direction is reversed (eg, \"x, z, -y\"). The default is \"x, y, z\". #rate: 3200 # Output data rate for ADXL345. ADXL345 supports the following data # rates: 3200, 1600, 800, 400, 200, 100, 50, and 25. Note that it is # not recommended to change this rate from the default 3200, and # rates below 800 will considerably affect the quality of resonance # measurements.","title":"[adxl345]"},{"location":"Config_Reference.html#lis2dw","text":"Support for LIS2DW accelerometers. [lis2dw] #cs_pin: # The SPI enable pin for the sensor. This parameter must be provided # if using SPI. #spi_speed: 5000000 # The SPI speed (in hz) to use when communicating with the chip. # The default is 5000000. #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. #i2c_address: # Default is 25 (0x19). If SA0 is high, it would be 24 (0x18) instead. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: 400000 # See the \"common I2C settings\" section for a description of the # above parameters. The default \"i2c_speed\" is 400000. #axes_map: x, y, z # See the \"adxl345\" section for information on this parameter.","title":"[lis2dw]"},{"location":"Config_Reference.html#lis3dh","text":"Support for LIS3DH accelerometers. [lis3dh] #cs_pin: # The SPI enable pin for the sensor. This parameter must be provided # if using SPI. #spi_speed: 5000000 # The SPI speed (in hz) to use when communicating with the chip. # The default is 5000000. #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. #i2c_address: # Default is 25 (0x19). If SA0 is high, it would be 24 (0x18) instead. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: 400000 # See the \"common I2C settings\" section for a description of the # above parameters. The default \"i2c_speed\" is 400000. #axes_map: x, y, z # See the \"adxl345\" section for information on this parameter.","title":"[lis3dh]"},{"location":"Config_Reference.html#mpu9250","text":"Supporto per accelerometri MPU-9250, MPU-9255, MPU-6515, MPU-6050 e MPU-6500 (\u00e8 possibile definire un numero qualsiasi di sezioni con un prefisso \"mpu9250\"). [mpu9250 my_accelerometer] #i2c_address: # Default is 104 (0x68). If AD0 is high, it would be 0x69 instead. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: 400000 # See the \"common I2C settings\" section for a description of the # above parameters. The default \"i2c_speed\" is 400000. #axes_map: x, y, z # See the \"adxl345\" section for information on this parameter.","title":"[mpu9250]"},{"location":"Config_Reference.html#resonance_tester","text":"Supporto per test di risonanza e calibrazione automatica del input shaper. Per utilizzare la maggior parte delle funzionalit\u00e0 di questo modulo, devono essere installate dipendenze software aggiuntive; fare riferimento a Measuring Resonances e al command reference per ulteriori informazioni. Per ulteriori informazioni sul parametro max_smoothing e sul suo utilizzo, vedere la sezione Max smoothing della guida alla misurazione delle risonanze. [resonance_tester] #probe_points: # A list of X, Y, Z coordinates of points (one point per line) to test # resonances at. At least one point is required. Make sure that all # points with some safety margin in XY plane (~a few centimeters) # are reachable by the toolhead. #accel_chip: # A name of the accelerometer chip to use for measurements. If # adxl345 chip was defined without an explicit name, this parameter # can simply reference it as \"accel_chip: adxl345\", otherwise an # explicit name must be supplied as well, e.g. \"accel_chip: adxl345 # my_chip_name\". Either this, or the next two parameters must be # set. #accel_chip_x: #accel_chip_y: # Names of the accelerometer chips to use for measurements for each # of the axis. Can be useful, for instance, on bed slinger printer, # if two separate accelerometers are mounted on the bed (for Y axis) # and on the toolhead (for X axis). These parameters have the same # format as 'accel_chip' parameter. Only 'accel_chip' or these two # parameters must be provided. #max_smoothing: # Maximum input shaper smoothing to allow for each axis during shaper # auto-calibration (with 'SHAPER_CALIBRATE' command). By default no # maximum smoothing is specified. Refer to Measuring_Resonances guide # for more details on using this feature. #move_speed: 50 # The speed (in mm/s) to move the toolhead to and between test points # during the calibration. The default is 50. #min_freq: 5 # Minimum frequency to test for resonances. The default is 5 Hz. #max_freq: 133.33 # Maximum frequency to test for resonances. The default is 133.33 Hz. #accel_per_hz: 60 # This parameter is used to determine which acceleration to use to # test a specific frequency: accel = accel_per_hz * freq. Higher the # value, the higher is the energy of the oscillations. Can be set to # a lower than the default value if the resonances get too strong on # the printer. However, lower values make measurements of # high-frequency resonances less precise. The default value is 75 # (mm/sec). #hz_per_sec: 1 # Determines the speed of the test. When testing all frequencies in # range [min_freq, max_freq], each second the frequency increases by # hz_per_sec. Small values make the test slow, and the large values # will decrease the precision of the test. The default value is 1.0 # (Hz/sec == sec^-2). #sweeping_accel: 400 # An acceleration of slow sweeping moves. The default is 400 mm/sec^2. #sweeping_period: 1.2 # A period of slow sweeping moves. Setting this parameter to 0 # disables slow sweeping moves. Avoid setting it to a too small # non-zero value in order to not poison the measurements. # The default is 1.2 sec which is a good all-round choice.","title":"[resonance_tester]"},{"location":"Config_Reference.html#helper-per-i-file-di-configurazione","text":"","title":"Helper per i file di configurazione"},{"location":"Config_Reference.html#board_pins","text":"Alias pin board (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"board_pins\"). Usalo per definire gli alias per i pin su un microcontrollore. [board_pins my_aliases] mcu: mcu # A comma separated list of micro-controllers that may use the # aliases. The default is to apply the aliases to the main \"mcu\". aliases: aliases_<name>: # A comma separated list of \"name=value\" aliases to create for the # given micro-controller. For example, \"EXP1_1=PE6\" would create an # \"EXP1_1\" alias for the \"PE6\" pin. However, if \"value\" is enclosed # in \"<>\" then \"name\" is created as a reserved pin (for example, # \"EXP1_9=<GND>\" would reserve \"EXP1_9\"). Any number of options # starting with \"aliases_\" may be specified.","title":"[board_pins]"},{"location":"Config_Reference.html#include","text":"Supporto per includere i file. Uno pu\u00f2 includere un file di configurazione aggiuntivo dal file di configurazione della stampante principale. Possono essere utilizzati anche caratteri jolly (ad es. \"configs/*.cfg\"). [include my_other_config.cfg]","title":"[include]"},{"location":"Config_Reference.html#duplicate_pin_override","text":"Questo strumento consente di definire pi\u00f9 volte un singolo pin del microcontrollore in un file di configurazione senza il normale controllo degli errori. Questo \u00e8 inteso per scopi diagnostici e di debug. Questa sezione non \u00e8 necessaria laddove Klipper supporta l'utilizzo dello stesso pin pi\u00f9 volte e l'utilizzo di questa sostituzione pu\u00f2 causare risultati confusi e imprevisti. [duplicate_pin_override] pins: # Un elenco di pin separato da virgole che possono essere utilizzati pi\u00f9 volte in # un file di configurazione senza normali controlli degli errori. Questo parametro deve essere # fornito.","title":"[duplicate_pin_override]"},{"location":"Config_Reference.html#hardware-per-probing-del-piatto","text":"","title":"Hardware per probing del piatto"},{"location":"Config_Reference.html#probe","text":"Sonda di altezza Z. Si pu\u00f2 definire questa sezione per abilitare l'hardware di rilevamento dell'altezza Z. Quando questa sezione \u00e8 abilitata, i comandi estesi PROBE e QUERY_PROBE comandi g-code diventano disponibili. Inoltre, vedere la Guida alla calibrazione della sonda . La sezione probe crea anche un pin virtuale \"probe:z_virtual_endstop\". Si pu\u00f2 impostare stepper_z endstop_pin su questo pin virtuale su stampanti in stile cartesiano che utilizzano la sonda al posto di un endstop z. Se si utilizza \"probe:z_virtual_endstop\", non definire un position_endstop nella sezione di configurazione stepper_z. [probe] pin: # Pin di rilevamento della sonda. Se il pin si trova su un # microcontrollore diverso rispetto agli stepper Z, abilita # \"homing multi-mcu\". Questo parametro deve essere fornito. #deactivate_on_each_sample: True # Questo determina se Klipper deve eseguire la disattivazione # gcode tra ogni tentativo di esplorazione durante l'esecuzione di # una sequenza di probe multiple. L'impostazione predefinita \u00e8 True. #x_offset: 0.0 # La distanza (in mm) tra la sonda e l'ugello lungo l'asse x. # Il valore predefinito \u00e8 0. #y_offset: 0.0 # La distanza (in mm) tra la sonda e l'ugello lungo l'asse y. # Il valore predefinito \u00e8 0. z_offset: # La distanza (in mm) tra il piatto e l'ugello quando la sonda si attiva. # Questo parametro deve essere fornito. #speed: 5.0 # Velocit\u00e0 (in mm/s) dell'asse Z durante probing. # Il valore predefinito \u00e8 5 mm/s. #samples: 1 # Il numero di volte in cui sondare ciascun punto. I valori z sondati # verranno mediati. L'impostazione predefinita \u00e8 sondare 1 volta. #sample_retract_dist: 2.0 # La distanza (in mm) per sollevare la testa di stampa tra ciascun # campione (se si esegue il campionamento pi\u00f9 di una volta). # Il valore predefinito \u00e8 2 mm. #lift_speed: # Velocit\u00e0 (in mm/s) dell'asse Z durante il sollevamento della sonda # tra i campioni. L'impostazione predefinita prevede l'utilizzo dello # stesso valore del parametro 'speed'. #samples_result: average # Il metodo di calcolo durante il campionamento pi\u00f9 di una volta: # \"median\" o \"average\". L'impostazione predefinita \u00e8 average. #samples_tolerance: 0.100 # La distanza Z massima (in mm) che un campione pu\u00f2 differire da # altri campioni. Se questa tolleranza viene superata, viene segnalato # un errore o il tentativo viene riavviato # (vedere samples_tolerance_retries). Il valore predefinito \u00e8 0,100 mm. #samples_tolerance_retries: 0 # Il numero di tentativi per riprovare se viene trovato un campione che # supera samples_tolerance. In un nuovo tentativo, tutti i campioni # correnti vengono eliminati e il tentativo di sonda viene riavviato. # Se non si ottiene un insieme valido di campioni nel numero di tentativi # specificato, viene segnalato un errore. Il valore predefinito \u00e8 zero che # causa la segnalazione di un errore sul primo campione che supera # samples_tolerance. #activate_gcode: # Un elenco di comandi G-Code da eseguire prima di ogni tentativo di # esplorazione. Vedi docs/Command_Templates.md per il formato # G-Code. Questo pu\u00f2 essere utile se la sonda deve essere attivata in # qualche modo. Non impartire qui alcun comando che sposti la testa # di stampa (ad es. G1). L'impostazione predefinita \u00e8 di non eseguire # alcun comando G-Code speciale all'attivazione. #deactivate_gcode: # Un elenco di comandi G-Code da eseguire dopo il completamento di # ogni tentativo di esplorazione. Vedi docs/Command_Templates.md # per il formato G-Code. Non impartire qui alcun comando che sposti # la testina. L'impostazione predefinita \u00e8 di non eseguire alcun # comando G-Code speciale alla disattivazione.","title":"[probe]"},{"location":"Config_Reference.html#bltouch","text":"Sonda BLTouch. Si pu\u00f2 definire questa sezione (anzich\u00e9 una sezione sonda) per abilitare una sonda BLTouch. Per ulteriori informazioni, vedere BL-Touch guide e command reference .. Viene anche creato un pin virtuale \"probe:z_virtual_endstop\" (consultare la sezione \"probe\" per i dettagli). [bltouch] sensor_pin: # Pin connected to the BLTouch sensor pin. Most BLTouch devices # require a pullup on the sensor pin (prefix the pin name with \"^\"). # This parameter must be provided. control_pin: # Pin connected to the BLTouch control pin. This parameter must be # provided. #pin_move_time: 0.680 # The amount of time (in seconds) to wait for the BLTouch pin to # move up or down. The default is 0.680 seconds. #stow_on_each_sample: True # This determines if Klipper should command the pin to move up # between each probe attempt when performing a multiple probe # sequence. Read the directions in docs/BLTouch.md before setting # this to False. The default is True. #probe_with_touch_mode: False # If this is set to True then Klipper will probe with the device in # \"touch_mode\". The default is False (probing in \"pin_down\" mode). #pin_up_reports_not_triggered: True # Set if the BLTouch consistently reports the probe in a \"not # triggered\" state after a successful \"pin_up\" command. This should # be True for all genuine BLTouch devices. Read the directions in # docs/BLTouch.md before setting this to False. The default is True. #pin_up_touch_mode_reports_triggered: True # Set if the BLTouch consistently reports a \"triggered\" state after # the commands \"pin_up\" followed by \"touch_mode\". This should be # True for all genuine BLTouch devices. Read the directions in # docs/BLTouch.md before setting this to False. The default is True. #set_output_mode: # Request a specific sensor pin output mode on the BLTouch V3.0 (and # later). This setting should not be used on other types of probes. # Set to \"5V\" to request a sensor pin output of 5 Volts (only use if # the controller board needs 5V mode and is 5V tolerant on its input # signal line). Set to \"OD\" to request the sensor pin output use # open drain mode. The default is to not request an output mode. #x_offset: #y_offset: #z_offset: #speed: #lift_speed: #samples: #sample_retract_dist: #samples_result: #samples_tolerance: #samples_tolerance_retries: # See the \"probe\" section for information on these parameters.","title":"[bltouch]"},{"location":"Config_Reference.html#smart_effector","text":"Lo \"Smart Effector\" di Duet3d implementa una sonda Z utilizzando un sensore di forza. Si pu\u00f2 definire questa sezione invece di [probe] per abilitare le funzioni specifiche di Smart Effector. Ci\u00f2 consente anche a comandi di runtime di regolare i parametri di Smart Effector in fase di esecuzione. [smart_effector] pin: # Pin collegato al pin di uscita della sonda Z Smart Effector (pin 5). Si noti # che la resistenza di pullup sulla scheda generalmente non \u00e8 richiesta. # Tuttavia, se il pin di uscita \u00e8 collegato al pin della scheda con un resistore # di pullup, tale resistore deve essere di valore elevato (ad es. 10K Ohm o pi\u00f9). # Alcune schede hanno un resistore di pullup di basso valore sull'ingresso # della sonda Z, che probabilmente far\u00e0 risultare in uno stato di sonda sempre # attivato. In questo caso, collegare lo Smart Effector a un pin diverso sulla # scheda. Questo parametro \u00e8 obbligatorio. #control_pin: # Pin collegato al pin di ingresso di controllo Smart Effector (pin 7). Se fornito, # diventano disponibili i comandi di programmazione della sensibilit\u00e0 # di Smart Effector. #probe_accel: # Se impostato, limita l'accelerazione dei movimenti di tastatura (in mm/sec^2). # Un'improvvisa grande accelerazione all'inizio del movimento di esplorazione # pu\u00f2 causare l'attivazione spuria della sonda, specialmente se l'hotend \u00e8 pesante. # Per evitarlo, potrebbe essere necessario ridurre l'accelerazione dei movimenti # di tastatura tramite questo parametro. #recovery_time: 0.4 # Un ritardo tra i movimenti di spostamento e tastatura in secondi. Un # movimento veloce prima della tastatura pu\u00f2 causare l'attivazione spuria della # sonda. Ci\u00f2 pu\u00f2 causare errori \"Sonda attivata prima del movimento\" se non # \u00e8 impostato alcun ritardo. Il valore 0 disabilita il ritardo di ripristino. # Il valore predefinito \u00e8 0.4. #x_offset: #y_offset: # Dovrebbe essere lasciato non impostato (o impostato su 0). z_offset: # Altezza di attivazione della sonda. Inizia con -0.1 (mm) e regola in seguito # usando il comando `PROBE_CALIBRATE`. Questo parametro deve essere fornito. #speed: # Velocit\u00e0 (in mm/s) dell'asse Z durante la tastatura. Si consiglia di iniziare con la # velocit\u00e0 di tastatura di 20 mm/s e di regolarla secondo necessit\u00e0 per migliorare la # precisione e la ripetibilit\u00e0 dell'attivazione della sonda. #samples: #sample_retract_dist: #samples_result: #samples_tolerance: #samples_tolerance_retries: #activate_gcode: #deactivate_gcode: #deactivate_on_each_sample: # Vedere la sezione \"probe\" per ulteriori informazioni sui parametri di cui sopra.","title":"[smart_effector]"},{"location":"Config_Reference.html#probe_eddy_current","text":"Support for eddy current inductive probes. One may define this section (instead of a probe section) to enable this probe. See the command reference for further information. [probe_eddy_current my_eddy_probe] sensor_type: ldc1612 # The sensor chip used to perform eddy current measurements. This # parameter must be provided and must be set to ldc1612. #intb_pin: # MCU gpio pin connected to the ldc1612 sensor's INTB pin (if # available). The default is to not use the INTB pin. #z_offset: # The nominal distance (in mm) between the nozzle and bed that a # probing attempt should stop at. This parameter must be provided. #i2c_address: #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # The i2c settings for the sensor chip. See the \"common I2C # settings\" section for a description of the above parameters. #x_offset: #y_offset: #speed: #lift_speed: #samples: #sample_retract_dist: #samples_result: #samples_tolerance: #samples_tolerance_retries: # See the \"probe\" section for information on these parameters.","title":"[probe_eddy_current]"},{"location":"Config_Reference.html#axis_twist_compensation","text":"A tool to compensate for inaccurate probe readings due to twist in X or Y gantry. See the Axis Twist Compensation Guide for more detailed information regarding symptoms, configuration and setup. [axis_twist_compensation] #speed: 50 # The speed (in mm/s) of non-probing moves during the calibration. # The default is 50. #horizontal_move_z: 5 # The height (in mm) that the head should be commanded to move to # just prior to starting a probe operation. The default is 5. calibrate_start_x: 20 # Defines the minimum X coordinate of the calibration # This should be the X coordinate that positions the nozzle at the starting # calibration position. calibrate_end_x: 200 # Defines the maximum X coordinate of the calibration # This should be the X coordinate that positions the nozzle at the ending # calibration position. calibrate_y: 112.5 # Defines the Y coordinate of the calibration # This should be the Y coordinate that positions the nozzle during the # calibration process. This parameter is recommended to # be near the center of the bed # For Y-axis twist compensation, specify the following parameters: calibrate_start_y: ... # Defines the minimum Y coordinate of the calibration # This should be the Y coordinate that positions the nozzle at the starting # calibration position for the Y axis. This parameter must be provided if # compensating for Y axis twist. calibrate_end_y: ... # Defines the maximum Y coordinate of the calibration # This should be the Y coordinate that positions the nozzle at the ending # calibration position for the Y axis. This parameter must be provided if # compensating for Y axis twist. calibrate_x: ... # Defines the X coordinate of the calibration for Y axis twist compensation # This should be the X coordinate that positions the nozzle during the # calibration process for Y axis twist compensation. This parameter must be # provided and is recommended to be near the center of the bed.","title":"[axis_twist_compensation]"},{"location":"Config_Reference.html#motori-passo-passo-ed-estrusori-aggiuntivi","text":"","title":"Motori passo-passo ed estrusori aggiuntivi"},{"location":"Config_Reference.html#stepper_z1","text":"Assi multi-stepper. Su una stampante in stile cartesiano, lo stepper che controlla un dato asse pu\u00f2 avere blocchi di configurazione aggiuntivi che definiscono gli stepper che dovrebbero essere azionati insieme allo stepper primario. Si pu\u00f2 definire un numero qualsiasi di sezioni con un suffisso numerico che inizia da 1 (ad esempio, \"stepper_z1\", \"stepper_z2\", ecc.). [stepper_z1] #step_pin: #dir_pin: #enable_pin: #microsteps: #rotation_distance: # Vedere la sezione \"stepper\" per la definizione dei parametri di cui sopra. #endstop_pin: # Se viene definito un endstop_pin per lo stepper aggiuntivo, lo stepper # si fermer\u00e0 fino all'attivazione dell'endstop. In caso contrario, lo stepper # si fermer\u00e0 fino a quando non verr\u00e0 attivato il finecorsa sullo stepper # primario per l'asse.","title":"[stepper_z1]"},{"location":"Config_Reference.html#extruder1","text":"In una stampante multiestrusore aggiungere una sezione estrusore aggiuntiva per ogni estrusore aggiuntivo. Le sezioni aggiuntive dell'estrusore devono essere denominate \"extruder1\", \"extruder2\", \"extruder3\" e cos\u00ec via. Vedere la sezione \"extruder\" per una descrizione dei parametri disponibili. Vedere sample-multi-extruder.cfg per un esempio di configurazione. [extruder1] #step_pin: #dir_pin: #... # Vedere la sezione \"estrusore\" per i parametri per lo stepper e il riscaldatore # disponibili. #shared_heater: # Questa opzione \u00e8 obsoleta e non deve pi\u00f9 essere specificata.","title":"[extruder1]"},{"location":"Config_Reference.html#dual_carriage","text":"Support for cartesian and hybrid_corexy/z printers with dual carriages on a single axis. The carriage mode can be set via the SET_DUAL_CARRIAGE extended g-code command. For example, \"SET_DUAL_CARRIAGE CARRIAGE=1\" command will activate the carriage defined in this section (CARRIAGE=0 will return activation to the primary carriage). Dual carriage support is typically combined with extra extruders - the SET_DUAL_CARRIAGE command is often called at the same time as the ACTIVATE_EXTRUDER command. Be sure to park the carriages during deactivation. Note that during G28 homing, typically the primary carriage is homed first followed by the carriage defined in the [dual_carriage] config section. However, the [dual_carriage] carriage will be homed first if both carriages home in a positive direction and the [dual_carriage] carriage has a position_endstop greater than the primary carriage, or if both carriages home in a negative direction and the [dual_carriage] carriage has a position_endstop less than the primary carriage. Inoltre, \u00e8 possibile utilizzare i comandi \"SET_DUAL_CARRIAGE CARRIAGE=1 MODE=COPY\" o \"SET_DUAL_CARRIAGE CARRIAGE=1 MODE=MIRROR\" per attivare la modalit\u00e0 di copia o di mirroring del doppio carrello, nel qual caso seguir\u00e0 di conseguenza il movimento del carrello 0 . Questi comandi possono essere utilizzati per stampare due parti contemporaneamente: due parti identiche (in modalit\u00e0 COPIA) o parti specchiate (in modalit\u00e0 SPECCHIO). Tieni presente che le modalit\u00e0 COPY e MIRROR richiedono anche la configurazione appropriata dell'estrusore sul doppio carrello, che in genere pu\u00f2 essere ottenuta con \"SYNC_EXTRUDER_MOTION MOTION_QUEUE=extruder EXTRUDER= \" o un comando simile. Vedere sample-idex.cfg per un esempio di configurazione. [dual_carriage] axis: # The axis this extra carriage is on (either x or y). This parameter # must be provided. #safe_distance: # The minimum distance (in mm) to enforce between the dual and the primary # carriages. If a G-Code command is executed that will bring the carriages # closer than the specified limit, such a command will be rejected with an # error. If safe_distance is not provided, it will be inferred from # position_min and position_max for the dual and primary carriages. If set # to 0 (or safe_distance is unset and position_min and position_max are # identical for the primary and dual carraiges), the carriages proximity # checks will be disabled. #step_pin: #dir_pin: #enable_pin: #microsteps: #rotation_distance: #endstop_pin: #position_endstop: #position_min: #position_max: # See the \"stepper\" section for the definition of the above parameters.","title":"[dual_carriage]"},{"location":"Config_Reference.html#extruder_stepper","text":"Supporto per stepper aggiuntivi sincronizzati al movimento di un estrusore (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"extruder_stepper\"). Per ulteriori informazioni, vedere riferimento comando . [extruder_stepper my_extra_stepper] extruder: # L'estrusore con cui \u00e8 sincronizzato questo stepper. Se questo \u00e8 impostato su # una stringa vuota, lo stepper non verr\u00e0 sincronizzato con un # estrusore. Questo parametro deve essere fornito. #step_pin: #dir_pin: #enable_pin: #microsteps: #rotation_distance: # Vedere la sezione \"stepper\" per la definizione dei parametri sopra. # .","title":"[extruder_stepper]"},{"location":"Config_Reference.html#stepper-manuali","text":"Stepper manuali (\u00e8 possibile definire un numero qualsiasi di sezioni con un prefisso \"manual_stepper\"). Questi sono stepper controllati dal comando g-code MANUAL_STEPPER. Ad esempio: \"MANUAL_STEPPER STEPPER=my_stepper MOVE=10 SPEED=5\". Vedere il file G-Codes per una descrizione del comando MANUAL_STEPPER. Gli stepper non sono collegati alla normale cinematica della stampante. [manual_stepper my_stepper] #step_pin: #dir_pin: #enable_pin: #microsteps: #rotation_distance: # Vedere la sezione \"stepper\" per una descrizione di questi parametri. #velocity: # Impostare la velocit\u00e0 predefinita (in mm/s) per lo stepper. Questo # valore verr\u00e0 utilizzato se un comando MANUAL_STEPPER non specifica # un parametro SPEED. Il valore predefinito \u00e8 5 mm/s. #accel: # Imposta l'accelerazione predefinita (in mm/s^2) per lo stepper. # Un'accelerazione pari a zero non risulter\u00e0 in nessuna accelerazione. # Questo valore verr\u00e0 utilizzato se un comando MANUAL_STEPPER non # specifica un parametro ACCEL. Il valore predefinito \u00e8 zero. #endstop_pin: # Pin di rilevamento interruttore di fine corsa. Se specificato, \u00e8 possibile # eseguire \"movimenti di riferimento\" aggiungendo un parametro # STOP_ON_ENDSTOP ai comandi di movimento MANUAL_STEPPER.","title":"[Stepper manuali]"},{"location":"Config_Reference.html#riscaldatori-e-sensori-personalizzati","text":"","title":"Riscaldatori e sensori personalizzati"},{"location":"Config_Reference.html#verify_heater","text":"Verifica riscaldatore e sensore di temperatura. La verifica del riscaldatore viene abilitata automaticamente per ogni riscaldatore configurato sulla stampante. Usa le sezioni di verifica_riscaldatore per modificare le impostazioni predefinite. [verify_heater heater_config_name] #max_error: 120 # Il massimo \"errore di temperatura cumulativo\" prima di generare un # errore. Valori pi\u00f9 piccoli comportano un controllo pi\u00f9 rigoroso e valori # pi\u00f9 grandi consentono pi\u00f9 tempo prima che venga segnalato un errore. # Nello specifico la temperatura viene osservata una volta al secondo e # se \u00e8 prossima alla temperatura target viene azzerato un \"contatore errori\" # interno; in caso contrario, se la temperatura \u00e8 inferiore all'intervallo target, # il contatore viene aumentato della quantit\u00e0 in cui la temperatura riportata # differisce da tale intervallo. Se il contatore supera questo \"errore_max\", # viene generato un errore. Il valore predefinito \u00e8 120. #check_gain_time: # Questo controlla la verifica del riscaldatore durante il riscaldamento # iniziale. Valori pi\u00f9 piccoli comportano un controllo pi\u00f9 rigoroso e valori # pi\u00f9 grandi consentono pi\u00f9 tempo prima che venga segnalato un errore. # In particolare, durante il riscaldamento iniziale, fintanto che il riscaldatore # aumenta di temperatura entro questo intervallo di tempo (specificato in # secondi), il \"contatore errori\" interno viene azzerato. Il valore predefinito # \u00e8 20 secondi per gli estrusori e 60 secondi per heater_bed. #hysteresis: 5 # La differenza di temperatura massima (in gradi Celsius) rispetto a una # temperatura target considerata nell'intervallo del target. Questo controlla # nell'intervallo max_error. \u00c8 raro personalizzare questo valore. # L'impostazione predefinita \u00e8 5. #heating_gain: 2 # La temperatura minima (in gradi Celsius) di cui il riscaldatore deve # aumentare durante il check_gain_time. \u00c8 raro personalizzare questo valore. # L'impostazione predefinita \u00e8 2.","title":"[verify_heater]"},{"location":"Config_Reference.html#homing_heaters","text":"Strumento per disabilitare i riscaldatori durante l'homing o la probing di un asse. [homing_heaters] #steppers: # Un elenco separato da virgole di stepper che dovrebbero causare # la disattivazione dei riscaldatori. L'impostazione predefinita \u00e8 # disabilitare i riscaldatori per qualsiasi spostamento di homing/sonda. # Esempio tipico: stepper_z #heaters: # Un elenco separato da virgole di riscaldatori da disabilitare # durante i movimenti di homing/probing. L'impostazione # predefinita \u00e8 disabilitare tutti i riscaldatori. # Esempio tipico: estrusore, letto riscaldatore","title":"[homing_heaters]"},{"location":"Config_Reference.html#thermistor","text":"Termistori personalizzati (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"thermistor\"). \u00c8 possibile utilizzare un termistore personalizzato nel campo sensor_type di una sezione di configurazione del riscaldatore. (Ad esempio, se si definisce una sezione \"[thermistor my_thermistor]\", \u00e8 possibile utilizzare un \"sensor_type: my_thermistor\" quando si definisce un riscaldatore.) Assicurati di posizionare la sezione del termistore nel file di configurazione sopra il suo primo utilizzo in una sezione del riscaldatore . [thermistor my_thermistor] #temperature1: #resistance1: #temperature2: #resistance2: #temperature3: #resistance3: # Tre misure di resistenza (in Ohm) alle temperature date (in Celsius). # Le tre misurazioni verranno utilizzate per calcolare i coefficienti di # Steinhart-Hart per il termistore. Questi parametri devono essere # forniti quando si utilizza Steinhart-Hart per definire il termistore. #beta: # In alternativa, \u00e8 possibile definire temperatura1, resistenza1 e beta # per definire i parametri del termistore. Questo parametro deve # essere fornito quando si utilizza \"beta\" per definire il termistore.","title":"[thermistor]"},{"location":"Config_Reference.html#adc_temperature","text":"Sensori di temperatura ADC personalizzati (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"adc_temperature\"). Ci\u00f2 consente di definire un sensore di temperatura personalizzato che misura una tensione su un pin del convertitore da analogico a digitale (ADC) e utilizza l'interpolazione lineare tra una serie di misurazioni di temperatura/tensione (o temperatura/resistenza) configurate per determinare la temperatura. Il sensore risultante pu\u00f2 essere utilizzato come tipo_sensore in una sezione riscaldatore. (Ad esempio, se si definisce una sezione \"[adc_temperature my_sensor]\", \u00e8 possibile utilizzare un \"sensor_type: my_sensor\" quando si definisce un riscaldatore.) Assicurati di posizionare la sezione del sensore nel file di configurazione sopra il suo primo utilizzo in una sezione del riscaldatore. [adc_temperature my_sensor] #temperature1: #voltage1: #temperature2: #voltage2: #... # A set of temperatures (in Celsius) and voltages (in Volts) to use # as reference when converting a temperature. A heater section using # this sensor may also specify adc_voltage and voltage_offset # parameters to define the ADC voltage (see \"Common temperature # amplifiers\" section for details). At least two measurements must # be provided. #temperature1: #resistance1: #temperature2: #resistance2: #... # Alternatively one may specify a set of temperatures (in Celsius) # and resistance (in Ohms) to use as reference when converting a # temperature. A heater section using this sensor may also specify a # pullup_resistor parameter (see \"extruder\" section for details). At # least two measurements must be provided.","title":"[adc_temperature]"},{"location":"Config_Reference.html#heater_generic","text":"Riscaldatori generici (si pu\u00f2 definire un numero qualsiasi di sezioni con il prefisso \"riscaldatore_generico\"). Questi riscaldatori si comportano in modo simile ai riscaldatori standard (estrusori, piatti riscaldati). Utilizzare il comando SET_HEATER_TEMPERATURE (consultare G-Codes per i dettagli) per impostare la temperatura target. [heater_generic my_generic_heater] #gcode_id: # L'ID da utilizzare quando si riporta la temperatura nel comando M105. # Questo parametro deve essere fornito. #max_power: #sensor_type: #sensor_pin: #smooth_time: #control: #pid_Kp: #pid_Ki: #pid_Kd: #pwm_cycle_time: #min_temp: #max_temp: # Vedere la sezione \"extruder\" per la definizione dei parametri sopra.","title":"[heater_generic]"},{"location":"Config_Reference.html#temperature_sensor","text":"Sensori di temperatura generici. \u00c8 possibile definire un numero qualsiasi di sensori di temperatura aggiuntivi che vengono riportati tramite il comando M105. [temperature_sensor my_sensor] #sensor_type: #sensor_pin: #min_temp: #max_temp: # Vedi la sezione \"extruder\" per la definizione dei parametri # sopra indicati. #gcode_id: # Vedi la sezione \"heater_generic\" per la definizione dei # parametri sopra indicati.","title":"[temperature_sensor]"},{"location":"Config_Reference.html#temperature_probe","text":"Reports probe coil temperature. Includes optional thermal drift calibration for eddy current based probes. A [temperature_probe] section may be linked to a [probe_eddy_current] by using the same postfix for both sections. [temperature_probe my_probe] #sensor_type: #sensor_pin: #min_temp: #max_temp: # Temperature sensor configuration. # See the \"extruder\" section for the definition of the above # parameters. #smooth_time: # A time value (in seconds) over which temperature measurements will # be smoothed to reduce the impact of measurement noise. The default # is 2.0 seconds. #gcode_id: # See the \"heater_generic\" section for the definition of this # parameter. #speed: # The travel speed [mm/s] for xy moves during calibration. Default # is the speed defined by the probe. #horizontal_move_z: # The z distance [mm] from the bed at which xy moves will occur # during calibration. Default is 2mm. #resting_z: # The z distance [mm] from the bed at which the tool will rest # to heat the probe coil during calibration. Default is .4mm #calibration_position: # The X, Y, Z position where the tool should be moved when # probe drift calibration initializes. This is the location # where the first manual probe will occur. If omitted, the # default behavior is not to move the tool prior to the first # manual probe. #calibration_bed_temp: # The maximum safe bed temperature (in C) used to heat the probe # during probe drift calibration. When set, the calibration # procedure will turn on the bed after the first sample is # taken. When the calibration procedure is complete the bed # temperature will be set to zero. When omitted the default # behavior is not to set the bed temperature. #calibration_extruder_temp: # The extruder temperature (in C) set probe during drift calibration. # When this option is supplied the procedure will wait for until the # specified temperature is reached before requesting the first manual # probe. When the calibration procedure is complete the extruder # temperature will be set to 0. When omitted the default behavior is # not to set the extruder temperature. #extruder_heating_z: 50. # The Z location where extruder heating will occur if the # \"calibration_extruder_temp\" option is set. Its recommended to heat # the extruder some distance from the bed to minimize its impact on # the probe coil temperature. The default is 50. #max_validation_temp: 60. # The maximum temperature used to validate the calibration. It is # recommended to set this to a value between 100 and 120 for enclosed # printers. The default is 60.","title":"[temperature_probe]"},{"location":"Config_Reference.html#sensori-di-temperatura","text":"Klipper include definizioni per molti tipi di sensori di temperatura. Questi sensori possono essere utilizzati in qualsiasi sezione di configurazione che richieda un sensore di temperatura (come una sezione [extruder] o [heater_bed] ).","title":"Sensori di temperatura"},{"location":"Config_Reference.html#termistori-comuni","text":"Termistori comuni. I seguenti parametri sono disponibili nelle sezioni del riscaldatore che utilizzano uno di questi sensori. sensor_type: # Uno di \"EPCOS 100K B57560G104F\", \"ATC Semitec 104GT-2\", # \"ATC Semitec 104NT-4-R025H42G\", \"Generic 3950\", # \"Honeywell 100K 135-104LAG-J01\", \"NTC 100K MGB18-104F39050L32\", # \"SliceEngineering 450\", o \"TDK NTCG104LH104JT1\" sensor_pin: # Pin di ingresso analogico collegato al termistore. # Questo parametro deve essere fornito. #pullup_resistor: 4700 # La resistenza (in ohm) del pullup collegato al termistore. # Il valore predefinito \u00e8 4700 ohm. #inline_resistor: 0 # La resistenza (in ohm) di un resistore aggiuntivo (non a variazione di # calore) posizionato in linea con il termistore. \u00c8 raro impostare questo. # Il valore predefinito \u00e8 0 ohm.","title":"Termistori comuni"},{"location":"Config_Reference.html#amplificatori-di-temperatura-comuni","text":"Amplificatori di temperatura comuni. I seguenti parametri sono disponibili nelle sezioni del riscaldatore che utilizzano uno di questi sensori. sensor_type: # Uno tra \"PT100 INA826\", \"AD595\", \"AD597\", \"AD8494\", \"AD8495\", # \"AD8496\", o \"AD8497\". sensor_pin: # Pin di ingresso analogico collegato al sensore. Questo parametro # deve essere fornito. #adc_voltage: 5.0 # La tensione di confronto dell'ADC (in Volt). Il valore predefinito # \u00e8 5 volt. #voltage_offset: 0 # L'offset di tensione ADC (in Volt). Il valore predefinito \u00e8 0.","title":"Amplificatori di temperatura comuni"},{"location":"Config_Reference.html#sensore-pt1000-collegato-direttamente","text":"Sensore PT1000 collegato direttamente. I seguenti parametri sono disponibili nelle sezioni del riscaldatore che utilizzano uno di questi sensori. sensor_type: PT1000 sensor_pin: # Pin di ingresso analogico collegato al sensore. Questo parametro # deve essere fornito. #pullup_resistor: 4700 # La resistenza (in ohm) del pullup collegato al sensore. Il valore # predefinito \u00e8 4700 ohm.","title":"Sensore PT1000 collegato direttamente"},{"location":"Config_Reference.html#sensori-di-temperatura-maxxxxxx","text":"Sensori temperatura MAXxxxxx con interfaccia periferica seriale (SPI). I seguenti parametri sono disponibili nelle sezioni del riscaldatore che utilizzano uno di questi tipi di sensore. sensor_type: # Uno tra \"MAX6675\", \"MAX31855\", \"MAX31856\", o \"MAX31865\". sensor_pin: # Il pin mcu collegato al pin di selezione del chip del sensore. # Questo parametro deve essere fornito. #spi_speed: 4000000 # La velocit\u00e0 SPI (in hz) da utilizzare durante la comunicazione # con il chip. Il valore predefinito \u00e8 4000000. #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # Vedere la sezione \"impostazioni comuni SPI\" per una # descrizione dei parametri di cui sopra. #tc_type: K #tc_use_50Hz_filter: False #tc_averaging_count: 1 # I parametri di cui sopra controllano i parametri del sensore # dei chip MAX31856. I valori predefiniti per ciascun parametro # sono accanto al nome del parametro nell'elenco precedente. #rtd_nominal_r: 100 #rtd_reference_r: 430 #rtd_num_of_wires: 2 #rtd_use_50Hz_filter: False # I parametri di cui sopra controllano i parametri del sensore dei # chip MAX31865. I valori predefiniti per ciascun parametro sono # accanto al nome del parametro nell'elenco precedente.","title":"Sensori di temperatura MAXxxxxx"},{"location":"Config_Reference.html#bmp180bmp280bme280bmp388bme680-temperature-sensor","text":"BMP180/BMP280/BME280/BMP388/BME680 two wire interface (I2C) environmental sensors. Note that these sensors are not intended for use with extruders and heater beds, but rather for monitoring ambient temperature (C), pressure (hPa), relative humidity and in case of the BME680 gas level. See sample-macros.cfg for a gcode_macro that may be used to report pressure and humidity in addition to temperature. sensor_type: BME280 #i2c_address: # Default is 118 (0x76). The BMP180, BMP388 and some BME280 sensors # have an address of 119 (0x77). #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters.","title":"BMP180/BMP280/BME280/BMP388/BME680 temperature sensor"},{"location":"Config_Reference.html#sensore-temperatura-aht10aht20aht21","text":"Sensori ambientali con interfaccia a due fili (I2C) AHT10/AHT20/AHT21. Si noti che questi sensori non sono destinati all'uso con estrusori e letti riscaldanti, ma piuttosto per il monitoraggio della temperatura ambiente (C) e dell'umidit\u00e0 relativa. Vedi sample-macros.cfg per un gcode_macro che pu\u00f2 essere utilizzato per segnalare l'umidit\u00e0 oltre alla temperatura. sensor_type: AHT10 # Also use AHT10 for AHT20 and AHT21 sensors. #i2c_address: # Default is 56 (0x38). Some AHT10 sensors give the option to use # 57 (0x39) by moving a resistor. #i2c_mcu: #i2c_bus: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #aht10_report_time: # Interval in seconds between readings. Default is 30, minimum is 5","title":"Sensore temperatura AHT10/AHT20/AHT21"},{"location":"Config_Reference.html#sensore-htu21d","text":"Sensore ambientale con interfaccia a due fili (I2C) della famiglia HTU21D. Si noti che questo sensore non \u00e8 destinato all'uso con estrusori e letti riscaldanti, ma piuttosto per il monitoraggio della temperatura ambiente (C) e dell'umidit\u00e0 relativa(%). Vedere sample-macros.cfg per una gcode_macro che pu\u00f2 essere utilizzata per riportare l'umidit\u00e0 oltre alla temperatura. sensor_type: # Must be \"HTU21D\" , \"SI7013\", \"SI7020\", \"SI7021\" or \"SHT21\" #i2c_address: # Default is 64 (0x40). #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #htu21d_hold_master: # If the sensor can hold the I2C buf while reading. If True no other # bus communication can be performed while reading is in progress. # Default is False. #htu21d_resolution: # The resolution of temperature and humidity reading. # Valid values are: # 'TEMP14_HUM12' -> 14bit for Temp and 12bit for humidity # 'TEMP13_HUM10' -> 13bit for Temp and 10bit for humidity # 'TEMP12_HUM08' -> 12bit for Temp and 08bit for humidity # 'TEMP11_HUM11' -> 11bit for Temp and 11bit for humidity # Default is: \"TEMP11_HUM11\" #htu21d_report_time: # Interval in seconds between readings. Default is 30","title":"Sensore HTU21D"},{"location":"Config_Reference.html#sht3x-sensor","text":"SHT3X family two wire interface (I2C) environmental sensor. These sensors have a range of -55~125 C, so are usable for e.g. chamber temperature monitoring. They can also function as simple fan/heater controllers. sensor_type: SHT3X #i2c_address: # Default is 68 (0x44). #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters.","title":"SHT3X sensor"},{"location":"Config_Reference.html#sensore-di-temperatura-lm75","text":"Sensori di temperatura (I2C) LM75/LM75A. Questi sensori hanno una gamma di -55~125 C, quindi sono utilizzabili ad es. monitoraggio della temperatura della camera. Possono anche funzionare come semplici controller per ventole/riscaldatori. sensor_type: LM75 #i2c_address: # Default is 72 (0x48). Normal range is 72-79 (0x48-0x4F) and the 3 # low bits of the address are configured via pins on the chip # (usually with jumpers or hard wired). #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #lm75_report_time: # Interval in seconds between readings. Default is 0.8, with minimum # 0.5.","title":"Sensore di temperatura LM75"},{"location":"Config_Reference.html#sensore-di-temperatura-integrato-nel-microcontrollore","text":"I microcontrollori atsam, atsamd e stm32 contengono un sensore di temperatura interno. \u00c8 possibile utilizzare il sensore \"temperature_mcu\" per monitorare queste temperature. sensor_type: temperature_mcu #sensor_mcu: mcu # Il microcontrollore da cui leggere. L'impostazione predefinita \u00e8 \"mcu\". #sensor_temperature1: #sensor_adc1: # Specificare i due parametri precedenti (una temperatura in gradi # Celsius e un valore ADC come float compreso tra 0,0 e 1,0) per # calibrare la temperatura del microcontrollore. Ci\u00f2 potrebbe # migliorare la precisione della temperatura riportata su alcuni chip. # Un modo tipico per ottenere queste informazioni di calibrazione # consiste nel rimuovere completamente l'alimentazione dalla # stampante per alcune ore (per assicurarsi che sia alla temperatura # ambiente), quindi accenderla e utilizzare il comando QUERY_ADC # per ottenere una misurazione ADC. Utilizzare un altro sensore di # temperatura sulla stampante per trovare la temperatura ambiente # corrispondente. L'impostazione predefinita consiste nell'utilizzare # i dati di calibrazione di fabbrica sul microcontrollore (se applicabile) # o i valori nominali dalle specifiche del microcontrollore. #sensor_temperature2: #sensor_adc2: # Se viene specificato sensor_temperature1/sensor_adc1, \u00e8 anche # possibile specificare i dati di calibrazione sensor_temperature2/sensor_adc2. # Ci\u00f2 potrebbe fornire informazioni calibrate sulla \"curva della # temperatura\". L'impostazione predefinita consiste nell'utilizzare i dati # di calibrazione di fabbrica sul microcontrollore (se applicabile) o i # valori nominali dalle specifiche del microcontrollore.","title":"Sensore di temperatura integrato nel microcontrollore"},{"location":"Config_Reference.html#sensore-di-temperatura-host","text":"Temperatura dalla macchina (es. Raspberry Pi) che esegue il software host. sensor_type: temperature_host #sensor_path: # il percorso del file di sistema della temperatura. L'impostazione # predefinita \u00e8 \"/sys/class/thermal/thermal_zone0/temp\" che \u00e8 il file di # sistema della temperatura su un computer Raspberry Pi.","title":"Sensore di temperatura host"},{"location":"Config_Reference.html#sensore-di-temperatura-ds18b20","text":"DS18B20 \u00e8 un sensore di temperatura digitale a 1 filo (w1). Si noti che questo sensore non \u00e8 destinato all'uso con estrusori e letti riscaldanti, ma piuttosto per il monitoraggio della temperatura ambiente (C). Questi sensori hanno una portata fino a 125 C, quindi sono utilizzabili ad es. monitoraggio della temperatura della camera. Possono anche funzionare come semplici controller per ventole/riscaldatori. I sensori DS18B20 sono supportati solo su \"host mcu\", ad es. il Raspberry Pi. \u00c8 necessario installare il modulo del kernel Linux w1-gpio. sensor_type: DS18B20 serial_no: # Ogni dispositivo a 1 filo ha un numero di serie univoco utilizzato per # identificare il dispositivo, solitamente nel formato 28-031674b175ff. Questo # parametro deve essere fornito. I dispositivi collegati a 1 filo possono essere # elencati utilizzando il seguente comando Linux: ls /sys/bus/w1/devices/ #ds18_report_time: # Intervallo in secondi tra le letture. Il valore predefinito \u00e8 3.0, con un # minimo di 1.0 #sensor_mcu: # Il microcontrollore da cui leggere. Deve essere host_mcu","title":"Sensore di temperatura DS18B20"},{"location":"Config_Reference.html#combined-temperature-sensor","text":"Combined temperature sensor is a virtual temperature sensor based on several other sensors. This sensor can be used with extruders, heater_generic and heater beds. sensor_type: temperature_combined #sensor_list: # Must be provided. List of sensors to combine to new \"virtual\" # sensor. # E.g. 'temperature_sensor sensor1,extruder,heater_bed' #combination_method: # Must be provided. Combination method used for the sensor. # Available options are 'max', 'min', 'mean'. #maximum_deviation: # Must be provided. Maximum permissible deviation between the sensors # to combine (e.g. 5 degrees). To disable it, use a large value (e.g. 999.9)","title":"Combined temperature sensor"},{"location":"Config_Reference.html#ventole","text":"","title":"Ventole"},{"location":"Config_Reference.html#fan","text":"Ventola di raffreddamento della stampa. [fan] pin: # Pin di output che controlla la ventola. Questo parametro deve essere fornito. #max_power: 1.0 # La potenza massima (espressa come un valore compreso tra 0.0 e 1.0) a # cui pu\u00f2 essere impostato il pin. Il valore 1.0 consente di impostare il pin # completamente abilitato per periodi prolungati, mentre un valore di 0.5 # consentirebbe di abilitare il pin per non pi\u00f9 della met\u00e0 del tempo. Questa # impostazione pu\u00f2 essere utilizzata per limitare la potenza totale (per # periodi prolungati) della ventola. Se questo valore \u00e8 inferiore a 1.0, le # richieste di velocit\u00e0 della ventola verranno ridimensionate tra zero e # max_power (ad esempio, se max_power \u00e8 0.9 e viene richiesta una # velocit\u00e0 della ventola dell'80%, la potenza della ventola verr\u00e0 impostata # su 72%). L'impostazione predefinita \u00e8 1.0. #shutdown_speed: 0 # La velocit\u00e0 della ventola desiderata (espressa come valore da 0.0 a # 1.0) se il software del microcontrollore entra in uno stato di errore. # Il valore predefinito \u00e8 0. #cycle_time: 0.010 # La quantit\u00e0 di tempo (in secondi) per ogni ciclo di alimentazione PWM # alla ventola. Si consiglia di essere pari o superiore a 10 millisecondi # quando si utilizza il PWM basato su software. # Il valore predefinito \u00e8 0,010 secondi. #hardware_pwm: False # Abilitare questa opzione per utilizzare PWM hardware anzich\u00e9 PWM # software. La maggior parte delle ventole non funziona bene con PWM # hardware, quindi non \u00e8 consigliabile abilitarlo a meno che non vi sia # un requisito elettrico per passare a velocit\u00e0 molto elevate. Quando # si utilizza l'hardware PWM, il tempo di ciclo effettivo \u00e8 vincolato # dall'implementazione e pu\u00f2 essere notevolmente diverso dal tempo # di ciclo richiesto. L'impostazione predefinita \u00e8 False. #kick_start_time: 0.100 # Tempo (in secondi) per far funzionare la ventola a piena velocit\u00e0 # quando la si abilita per la prima volta o la si aumenta di oltre il 50% # (aiuta a far girare la ventola). Il valore predefinito \u00e8 0,100 secondi. #off_below: 0.0 # La velocit\u00e0 minima in input che alimenter\u00e0 la ventola (espressa # come un valore da 0.0 a 1.0). Quando viene richiesta una velocit\u00e0 # inferiore a off_below la ventola verr\u00e0 invece spenta. Questa # impostazione pu\u00f2 essere utilizzata per prevenire lo stallo della # ventola e per garantire che i kick start siano efficaci. # Il valore predefinito \u00e8 0.0. # # Questa impostazione deve essere ricalibrata ogni volta che # max_power viene regolato. Per calibrare questa impostazione, # inizia con off_below impostato su 0.0 e la ventola gira. Abbassare # gradualmente la velocit\u00e0 della ventola per determinare la velocit\u00e0 # di ingresso pi\u00f9 bassa che aziona la ventola in modo affidabile senza # stalli. Impostare off_below al duty cycle corrispondente a questo # valore (ad esempio, 12% -> 0,12) o leggermente superiore. #tachometer_pin: # Pin di ingresso contagiri per il monitoraggio della velocit\u00e0 della # ventola. In genere \u00e8 richiesto un pullup. Questo parametro \u00e8 facoltativo. #tachometer_ppr: 2 # Quando viene specificato tachometer_pin, questo \u00e8 il numero di # impulsi per giro del segnale del tachimetro. Per una ventola BLDC # questo \u00e8 normalmente la met\u00e0 del numero di poli. # L'impostazione predefinita \u00e8 2. #tachometer_poll_interval: 0.0015 # Quando viene specificato tachometer_pin, questo \u00e8 il periodo di polling # del pin del contagiri, in secondi. Il valore predefinito \u00e8 0.0015, che \u00e8 # abbastanza veloce per le ventole al di sotto di 10000 RPM a 2 PPR. Deve # essere inferiore a 30/(tachometer_ppr*rpm), con un certo margine, # dove rpm \u00e8 la velocit\u00e0 massima (in RPM) della ventola. #enable_pin: # Pin opzionale per abilitare l'alimentazione alla ventola. Questo pu\u00f2 # essere utile per le ventole con ingressi PWM dedicati. Alcune di queste # ventole rimangono accese anche allo 0% di ingresso PWM. In tal caso, # il pin PWM pu\u00f2 essere utilizzato normalmente e ad es. un FET commutato # a terra (pin della ventola standard) pu\u00f2 essere utilizzato per controllare # l'alimentazione alla ventola.","title":"[fan]"},{"location":"Config_Reference.html#heater_fan","text":"Ventole di raffreddamento del riscaldatore (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"heater_fan\"). Una \"ventola riscaldatore\" \u00e8 una ventola che verr\u00e0 abilitata ogni volta che il riscaldatore associato \u00e8 attivo. Per impostazione predefinita, un heater_fan ha una velocit\u00e0 di spegnimento pari a max_power. [heater_fan heatbreak_cooling_fan] #pin: #max_power: #shutdown_speed: #cycle_time: #hardware_pwm: #kick_start_time: #off_below: #tachometer_pin: #tachometer_ppr: #tachometer_poll_interval: #enable_pin: # See the \"fan\" section for a description of the above parameters. #heater: extruder # Name of the config section defining the heater that this fan is # associated with. If a comma separated list of heater names is # provided here, then the fan will be enabled when any of the given # heaters are enabled. The default is \"extruder\". #heater_temp: 50.0 # A temperature (in Celsius) that the heater must drop below before # the fan is disabled. The default is 50 Celsius. #fan_speed: 1.0 # The fan speed (expressed as a value from 0.0 to 1.0) that the fan # will be set to when its associated heater is enabled. The default # is 1.0","title":"[heater_fan]"},{"location":"Config_Reference.html#controller_fan","text":"Ventola di raffreddamento del controller (\u00e8 possibile definire un numero qualsiasi di sezioni con il prefisso \"controller_fan\"). Una \"ventola del controller\" \u00e8 una ventola che verr\u00e0 abilitata ogni volta che il riscaldatore associato o il driver stepper associato \u00e8 attivo. La ventola si fermer\u00e0 ogni volta che viene raggiunto un idle_timeout per garantire che non si verifichi alcun surriscaldamento dopo la disattivazione di un componente osservato. [controller_fan my_controller_fan] #pin: #max_power: #shutdown_speed: #cycle_time: #hardware_pwm: #kick_start_time: #off_below: #tachometer_pin: #tachometer_ppr: #tachometer_poll_interval: #enable_pin: # Vedere la sezione \"fan\" per una descrizione dei parametri di cui sopra. #fan_speed: 1.0 # La velocit\u00e0 della ventola (espressa come un valore compreso tra 0.0 e # 1.0) a cui verr\u00e0 impostata la ventola quando \u00e8 attivo un riscaldatore # o un driver passo-passo. L'impostazione predefinita \u00e8 1.0 #idle_timeout: # La quantit\u00e0 di tempo (in secondi) dopo che un driver passo-passo o # un riscaldatore \u00e8 stato attivo per la quale la ventola deve essere tenuta # in funzione. L'impostazione predefinita \u00e8 30 secondi. #idle_speed: # La velocit\u00e0 della ventola (espressa come un valore compreso tra 0.0 # e 1.0) a cui verr\u00e0 impostata la ventola quando era attivo un riscaldatore # o un driver passo-passo e prima che venga raggiunto l'idle_timeout. # L'impostazione predefinita \u00e8 fan_speed. #heater: #stepper: # Nome della sezione di configurazione che definisce il riscaldatore/ # stepper a cui \u00e8 associata questa ventola. Se qui viene fornito un # elenco separato da virgole di nomi di riscaldatori/stepper, la ventola # sar\u00e0 abilitata quando uno qualsiasi dei riscaldatori/stepper indicati # \u00e8 abilitato. Il riscaldatore predefinito \u00e8 \"estrusore\", lo stepper # predefinito sono tutti.","title":"[controller_fan]"},{"location":"Config_Reference.html#temperature_fan","text":"Ventole di raffreddamento attivate dalla temperatura (\u00e8 possibile definire un numero qualsiasi di sezioni con un prefisso \"temperature_fan\"). Una \"ventola di temperatura\" \u00e8 una ventola che verr\u00e0 abilitata ogni volta che il sensore associato \u00e8 al di sopra di una temperatura impostata. Per impostazione predefinita, una ventola_temperatura ha una velocit\u00e0_di_arresto pari a potenza_massima. Per ulteriori informazioni, vedere command reference . [temperature_fan my_temp_fan] #pin: #max_power: #shutdown_speed: #cycle_time: #hardware_pwm: #kick_start_time: #off_below: #tachometer_pin: #tachometer_ppr: #tachometer_poll_interval: #enable_pin: # Vedere la sezione \"fan\" per una descrizione dei parametri di cui sopra. #sensor_type: #sensor_pin: #control: #max_delta: #min_temp: #max_temp: # Vedere la sezione \"extruder\" per una descrizione dei parametri di cui sopra. #pid_Kp: #pid_Ki: #pid_Kd: # Le impostazioni proporzionale (pid_Kp), integrale (pid_Ki) e derivata (pid_Kd) # per il sistema di controllo del feedback PID. Klipper valuta le impostazioni PID # con la seguente formula generale: fan_pwm = max_power - (Kp*e + Ki*integral(e) # - Kd*derivative(e)) / 255 Dove \"e\" \u00e8 \"target_temperature - measure_temperature\" # e \"fan_pwm\" \u00e8 la frequenza della ventola richiesta con 0.0 per spento e 1.0 al # massimo. I parametri pid_Kp, pid_Ki e pid_Kd devono essere forniti quando l# 'algoritmo di controllo PID \u00e8 abilitato. #pid_deriv_time: 2.0 # Un valore di tempo (in secondi) su cui le misurazioni della temperatura verranno # livellate quando si utilizza l'algoritmo di controllo PID. Ci\u00f2 pu\u00f2 ridurre l'impatto # del rumore di misurazione. Il valore predefinito \u00e8 2 secondi. #target_temp: 40.0 # Una temperatura (in Celsius) che sar\u00e0 la temperatura target. # L'impostazione predefinita \u00e8 40 gradi. #max_speed: 1.0 # La velocit\u00e0 della ventola (espressa come un valore compreso tra 0.0 e 1.0) a cui # verr\u00e0 impostata la ventola quando la temperatura del sensore supera il valore # impostato. L'impostazione predefinita \u00e8 1.0. #min_speed: 0.3 # La velocit\u00e0 minima della ventola (espressa come un valore compreso tra 0.0 e # 1.0) alla quale la ventola verr\u00e0 impostata per le ventole con temperatura PID. # Il valore predefinito \u00e8 0.3. #gcode_id: # Se impostata, la temperatura verr\u00e0 riportata nelle query M105 utilizzando l'id # fornito. L'impostazione predefinita \u00e8 di non riportare la temperatura tramite M105.","title":"[temperature_fan]"},{"location":"Config_Reference.html#fan_generic","text":"Ventola a controllo manuale (si pu\u00f2 definire un numero qualsiasi di sezioni con il prefisso \"fan_generic\"). La velocit\u00e0 di una ventola controllata manualmente viene impostata con SET_FAN_SPEED comando gcode . [fan_generic extruder_partfan] #pin: #max_power: #shutdown_speed: #cycle_time: #hardware_pwm: #kick_start_time: #off_below: #tachometer_pin: #tachometer_ppr: #tachometer_poll_interval: #enable_pin: # Vedere la sezione \"fan\" per una descrizione dei parametri di cui sopra.","title":"[fan_generic]"},{"location":"Config_Reference.html#leds","text":"","title":"LEDs"},{"location":"Config_Reference.html#led","text":"Supporto per LED (e strisce LED) controllati tramite pin PWM del microcontrollore (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"led\"). Per ulteriori informazioni, vedere command reference . [led my_led] #red_pin: #green_pin: #blue_pin: #white_pin: # Il pin che controlla il colore del LED specificato. Deve essere fornito # almeno uno dei parametri sopra indicati. #cycle_time: 0.010 # La quantit\u00e0 di tempo (in secondi) per ciclo PWM. Si consiglia che sia # pari o superiore a 10 millisecondi quando si utilizza il PWM basato # su software. Il valore predefinito \u00e8 0,010 secondi. #hardware_pwm: False # Abilitare questa opzione per utilizzare PWM hardware anzich\u00e9 PWM # software. Quando si utilizza l'hardware PWM, il tempo di ciclo effettivo # \u00e8 vincolato dall'implementazione e pu\u00f2 essere notevolmente diverso # dal tempo di ciclo richiesto. L'impostazione predefinita \u00e8 Falso. #initial_RED: 0.0 #initial_GREEN: 0.0 #initial_BLUE: 0.0 #initial_WHITE: 0.0 # Imposta il colore iniziale del LED. Ciascun valore deve essere # compreso tra 0,0 e 1,0. Il valore predefinito per ogni colore \u00e8 0.","title":"[led]"},{"location":"Config_Reference.html#neopixel","text":"Supporto LED Neopixel (aka WS2812) (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"neopixel\"). Per ulteriori informazioni, vedere riferimento comando . Si noti che l'implementazione di linux mcu non supporta attualmente i neopixel collegati direttamente. L'attuale design che utilizza l'interfaccia del kernel Linux non consente questo scenario perch\u00e9 l'interfaccia GPIO del kernel non \u00e8 sufficientemente veloce da fornire le frequenze di impulso richieste. [neopixel my_neopixel] pin: # Il pin collegato al neopixel. Questo parametro deve essere fornito. #chain_count: # Il numero di chip Neopixel che sono \"collegati a margherita\" al # pin fornito. Il valore predefinito \u00e8 1 (che indica che un solo # Neopixel \u00e8 collegato al pin). #color_order: GRB # Impostare l'ordine dei pixel richiesto dall'hardware del LED # (utilizzando una stringa contenente le lettere R, G, B, W con W # opzionale). In alternativa, questo pu\u00f2 essere un elenco separato # da virgole di pixel, uno per ogni LED nella catena. # L'impostazione predefinita \u00e8 GRB. #initial_RED: 0.0 #initial_GREEN: 0.0 #initial_BLUE: 0.0 #initial_WHITE: 0.0 # Vedere la sezione \"led\" per informazioni su questi parametri.","title":"[neopixel]"},{"location":"Config_Reference.html#dotstar","text":"Supporto LED Dotstar (conosciuti anche come APA102) (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"dotstar\"). Per ulteriori informazioni, vedere command reference . [dotstar my_dotstar] data_pin: # Il pin connesso alla data line del dotstar. Questo parametro # deve essere fornito. clock_pin: # Il pin connesso alla clock line del dotstar. Questo parametro # deve essere fornito. #chain_count: # Vedere la sezione \"neopixel\" per informazioni su questo parametro. #initial_RED: 0.0 #initial_GREEN: 0.0 #initial_BLUE: 0.0 # Vedere la sezione \"led\" per informazioni su questo parametro.","title":"[dotstar]"},{"location":"Config_Reference.html#pca9533","text":"PCA9533 Supporto LED. Il PCA9533 viene utilizzato sulla scheda mightyboard. [pca9533 my_pca9533] #i2c_address: 98 # The i2c address that the chip is using on the i2c bus. Use 98 for # the PCA9533/1, 99 for the PCA9533/2. The default is 98. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #initial_RED: 0.0 #initial_GREEN: 0.0 #initial_BLUE: 0.0 #initial_WHITE: 0.0 # See the \"led\" section for information on these parameters.","title":"[pca9533]"},{"location":"Config_Reference.html#pca9632","text":"Supporto LED PCA9632. Il PCA9632 viene utilizzato su FlashForge Dreamer. [pca9632 my_pca9632] #i2c_address: 98 # The i2c address that the chip is using on the i2c bus. This may be # 96, 97, 98, or 99. The default is 98. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #scl_pin: #sda_pin: # Alternatively, if the pca9632 is not connected to a hardware I2C # bus, then one may specify the \"clock\" (scl_pin) and \"data\" # (sda_pin) pins. The default is to use hardware I2C. #color_order: RGBW # Set the pixel order of the LED (using a string containing the # letters R, G, B, W). The default is RGBW. #initial_RED: 0.0 #initial_GREEN: 0.0 #initial_BLUE: 0.0 #initial_WHITE: 0.0 # See the \"led\" section for information on these parameters.","title":"[pca9632]"},{"location":"Config_Reference.html#servocomandi-aggiuntivi-pulsanti-e-altri-pin","text":"","title":"Servocomandi aggiuntivi, pulsanti e altri pin"},{"location":"Config_Reference.html#servo","text":"Servo (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"servo\"). I servo possono essere controllati usando SET_SERVO comando g-code . Ad esempio: SET_SERVO SERVO=my_servo ANGLE=180 [servo my_servo] pin: # Pin di uscita PWM che controlla il servo. Questo parametro deve # essere fornito. #maximum_servo_angle: 180 # L'angolo massimo (in gradi) a cui questo servo pu\u00f2 essere impostato. # L'impostazione predefinita \u00e8 180 gradi. #minimum_pulse_width: 0.001 # La durata minima dell'impulso (in secondi). Questo dovrebbe # corrispondere a un angolo di 0 gradi. Il valore predefinito \u00e8 0.001 secondi. #maximum_pulse_width: 0.002 # La durata massima dell'impulso (in secondi). Questo dovrebbe # corrispondere a un angolo di maximum_servo_angle. Il valore # predefinito \u00e8 0.002 secondi. #initial_angle: # Angolo iniziale (in gradi) su cui impostare il servo. L'impostazione # predefinita \u00e8 di non inviare alcun segnale all'avvio. #initial_pulse_width: # Durata iniziale dell'impulso (in secondi) su cui impostare il servo. # (Questo \u00e8 valido solo se initial_angle non \u00e8 impostato.) # L'impostazione predefinita \u00e8 di non inviare alcun segnale all'avvio.","title":"[servo]"},{"location":"Config_Reference.html#gcode_button","text":"Esegui gcode quando un pulsante viene premuto o rilasciato (o quando un pin cambia stato). Puoi controllare lo stato del pulsante usando QUERY_BUTTON button=my_gcode_button . [gcode_button my_gcode_button] pin: # Il pin su cui \u00e8 collegato il pulsante. Questo parametro deve essere fornito. #analog_range: # Due resistenze separate da virgole (in Ohm) che specificano l'intervallo # di resistenza minimo e massimo per il pulsante. Se viene fornito # analog_range, il pin deve essere un pin con capacit\u00e0 analogica. # L'impostazione predefinita \u00e8 utilizzare digital gpio per il pulsante. #analog_pullup_resistor: # La resistenza di pullup (in Ohm) quando \u00e8 specificato analog_range. # Il valore predefinito \u00e8 4700 ohm. #press_gcode: # Un elenco di comandi G-Code da eseguire quando si preme il pulsante. # I modelli G-Code sono supportati. Questo parametro deve essere fornito. #release_gcode: # Un elenco di comandi G-Code da eseguire quando il pulsante viene # rilasciato. I modelli G-Code sono supportati. L'impostazione predefinita # \u00e8 di non eseguire alcun comando al rilascio di un pulsante.","title":"[gcode_button]"},{"location":"Config_Reference.html#output_pin","text":"Pin di uscita configurabili in fase di run-time (\u00e8 possibile definire un numero qualsiasi di sezioni con un prefisso \"output_pin\"). I pin configurati qui verranno impostati come pin di output e sar\u00e0 possibile modificarli in fase di esecuzione utilizzando il comando esteso \"SET_PIN PIN=my_pin VALUE=.1\" comandi g-code . [output_pin my_pin] pin: # The pin to configure as an output. This parameter must be # provided. #pwm: False # Set if the output pin should be capable of pulse-width-modulation. # If this is true, the value fields should be between 0 and 1; if it # is false the value fields should be either 0 or 1. The default is # False. #value: # The value to initially set the pin to during MCU configuration. # The default is 0 (for low voltage). #shutdown_value: # The value to set the pin to on an MCU shutdown event. The default # is 0 (for low voltage). #cycle_time: 0.100 # The amount of time (in seconds) per PWM cycle. It is recommended # this be 10 milliseconds or greater when using software based PWM. # The default is 0.100 seconds for pwm pins. #hardware_pwm: False # Enable this to use hardware PWM instead of software PWM. When # using hardware PWM the actual cycle time is constrained by the # implementation and may be significantly different than the # requested cycle_time. The default is False. #scale: # This parameter can be used to alter how the 'value' and # 'shutdown_value' parameters are interpreted for pwm pins. If # provided, then the 'value' parameter should be between 0.0 and # 'scale'. This may be useful when configuring a PWM pin that # controls a stepper voltage reference. The 'scale' can be set to # the equivalent stepper amperage if the PWM were fully enabled, and # then the 'value' parameter can be specified using the desired # amperage for the stepper. The default is to not scale the 'value' # parameter. #maximum_mcu_duration: #static_value: # These options are deprecated and should no longer be specified.","title":"[output_pin]"},{"location":"Config_Reference.html#pwm_tool","text":"Pulse width modulation digital output pins capable of high speed updates (one may define any number of sections with an \"output_pin\" prefix). Pins configured here will be setup as output pins and one may modify them at run-time using \"SET_PIN PIN=my_pin VALUE=.1\" type extended g-code commands . [pwm_tool my_tool] pin: # The pin to configure as an output. This parameter must be provided. #maximum_mcu_duration: # The maximum duration a non-shutdown value may be driven by the MCU # without an acknowledge from the host. # If host can not keep up with an update, the MCU will shutdown # and set all pins to their respective shutdown values. # Default: 0 (disabled) # Usual values are around 5 seconds. #value: #shutdown_value: #cycle_time: 0.100 #hardware_pwm: False #scale: # See the \"output_pin\" section for the definition of these parameters.","title":"[pwm_tool]"},{"location":"Config_Reference.html#pwm_cycle_time","text":"Run-time configurable output pins with dynamic pwm cycle timing (one may define any number of sections with an \"pwm_cycle_time\" prefix). Pins configured here will be setup as output pins and one may modify them at run-time using \"SET_PIN PIN=my_pin VALUE=.1 CYCLE_TIME=0.100\" type extended g-code commands . [pwm_cycle_time my_pin] pin: #value: #shutdown_value: #cycle_time: 0.100 #scale: # See the \"output_pin\" section for information on these parameters.","title":"[pwm_cycle_time]"},{"location":"Config_Reference.html#static_digital_output","text":"Pin di uscita digitali configurati staticamente (\u00e8 possibile definire un numero qualsiasi di sezioni con un prefisso \"static_digital_output\"). I pin configurati qui verranno impostati come uscita GPIO durante la configurazione dell'MCU. Non possono essere modificati in fase di esecuzione. [static_digital_output my_output_pins] pins: # Un elenco separato da virgole di pin da impostare come pin di # output GPIO. Il pin verr\u00e0 impostato su un livello alto a meno che il # nome del pin non sia preceduto da \"!\". Questo parametro deve # essere fornito.","title":"[static_digital_output]"},{"location":"Config_Reference.html#multi_pin","text":"Uscite a pin multipli (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"multi_pin\"). Un output multi_pin crea un alias pin interno che pu\u00f2 modificare pi\u00f9 pin di output ogni volta che viene impostato il pin alias. Ad esempio, si potrebbe definire un oggetto \"[multi_pin my_fan]\" contenente due pin e quindi impostare \"pin=multi_pin:my_fan\" nella sezione \"[fan]\" - ad ogni cambio di ventola entrambi i pin di output verrebbero aggiornati. Questi alias non possono essere utilizzati con i pin del motore passo-passo. [multi_pin my_multi_pin] pins: # Un elenco separato da virgole di pin associati a questo alias. # Questo parametro deve essere fornito.","title":"[multi_pin]"},{"location":"Config_Reference.html#configurazione-del-driver-tmc-per-stepper","text":"Configurazione dei driver per motori passo-passo Trinamic in modalit\u00e0 UART/SPI. Ulteriori informazioni si trovano nella TMC Drivers guide e nel command reference .","title":"Configurazione del driver TMC per stepper"},{"location":"Config_Reference.html#tmc2130","text":"Configurare un driver per motore passo-passo TMC2130 tramite bus SPI. Per utilizzare questa funzione, definire una sezione di configurazione con un prefisso \"tmc2130\" seguito dal nome della sezione di configurazione dello stepper corrispondente (ad esempio, \"[tmc2130 stepper_x]\"). [tmc2130 stepper_x] cs_pin: # The pin corresponding to the TMC2130 chip select line. This pin # will be set to low at the start of SPI messages and raised to high # after the message completes. This parameter must be provided. #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. #chain_position: #chain_length: # These parameters configure an SPI daisy chain. The two parameters # define the stepper position in the chain and the total chain length. # Position 1 corresponds to the stepper that connects to the MOSI signal. # The default is to not use an SPI daisy chain. #interpolate: True # If true, enable step interpolation (the driver will internally # step at a rate of 256 micro-steps). This interpolation does # introduce a small systemic positional deviation - see # TMC_Drivers.md for details. The default is True. run_current: # The amount of current (in amps RMS) to configure the driver to use # during stepper movement. This parameter must be provided. #hold_current: # The amount of current (in amps RMS) to configure the driver to use # when the stepper is not moving. Setting a hold_current is not # recommended (see TMC_Drivers.md for details). The default is to # not reduce the current. #sense_resistor: 0.110 # The resistance (in ohms) of the motor sense resistor. The default # is 0.110 ohms. #stealthchop_threshold: 0 # The velocity (in mm/s) to set the \"stealthChop\" threshold to. When # set, \"stealthChop\" mode will be enabled if the stepper motor # velocity is below this value. The default is 0, which disables # \"stealthChop\" mode. #coolstep_threshold: # The velocity (in mm/s) to set the TMC driver internal \"CoolStep\" # threshold to. If set, the coolstep feature will be enabled when # the stepper motor velocity is near or above this value. Important # - if coolstep_threshold is set and \"sensorless homing\" is used, # then one must ensure that the homing speed is above the coolstep # threshold! The default is to not enable the coolstep feature. #high_velocity_threshold: # The velocity (in mm/s) to set the TMC driver internal \"high # velocity\" threshold (THIGH) to. This is typically used to disable # the \"CoolStep\" feature at high speeds. The default is to not set a # TMC \"high velocity\" threshold. #driver_MSLUT0: 2863314260 #driver_MSLUT1: 1251300522 #driver_MSLUT2: 608774441 #driver_MSLUT3: 269500962 #driver_MSLUT4: 4227858431 #driver_MSLUT5: 3048961917 #driver_MSLUT6: 1227445590 #driver_MSLUT7: 4211234 #driver_W0: 2 #driver_W1: 1 #driver_W2: 1 #driver_W3: 1 #driver_X1: 128 #driver_X2: 255 #driver_X3: 255 #driver_START_SIN: 0 #driver_START_SIN90: 247 # These fields control the Microstep Table registers directly. The optimal # wave table is specific to each motor and might vary with current. An # optimal configuration will have minimal print artifacts caused by # non-linear stepper movement. The values specified above are the default # values used by the driver. The value must be specified as a decimal integer # (hex form is not supported). In order to compute the wave table fields, # see the tmc2130 \"Calculation Sheet\" from the Trinamic website. #driver_IHOLDDELAY: 8 #driver_TPOWERDOWN: 0 #driver_TBL: 1 #driver_TOFF: 4 #driver_HEND: 7 #driver_HSTRT: 0 #driver_VHIGHFS: 0 #driver_VHIGHCHM: 0 #driver_PWM_AUTOSCALE: True #driver_PWM_FREQ: 1 #driver_PWM_GRAD: 4 #driver_PWM_AMPL: 128 #driver_SGT: 0 #driver_SEMIN: 0 #driver_SEUP: 0 #driver_SEMAX: 0 #driver_SEDN: 0 #driver_SEIMIN: 0 #driver_SFILT: 0 # Set the given register during the configuration of the TMC2130 # chip. This may be used to set custom motor parameters. The # defaults for each parameter are next to the parameter name in the # above list. #diag0_pin: #diag1_pin: # The micro-controller pin attached to one of the DIAG lines of the # TMC2130 chip. Only a single diag pin should be specified. The pin # is \"active low\" and is thus normally prefaced with \"^!\". Setting # this creates a \"tmc2130_stepper_x:virtual_endstop\" virtual pin # which may be used as the stepper's endstop_pin. Doing this enables # \"sensorless homing\". (Be sure to also set driver_SGT to an # appropriate sensitivity value.) The default is to not enable # sensorless homing.","title":"[tmc2130]"},{"location":"Config_Reference.html#tmc2208","text":"Configurare un driver per motore passo-passo TMC2208 (o TMC2224) tramite UART a filo singolo. Per utilizzare questa funzione, definire una sezione di configurazione con un prefisso \"tmc2208\" seguito dal nome della sezione di configurazione dello stepper corrispondente (ad esempio, \"[tmc2208 stepper_x]\"). [tmc2208 stepper_x] uart_pin: # The pin connected to the TMC2208 PDN_UART line. This parameter # must be provided. #tx_pin: # If using separate receive and transmit lines to communicate with # the driver then set uart_pin to the receive pin and tx_pin to the # transmit pin. The default is to use uart_pin for both reading and # writing. #select_pins: # A comma separated list of pins to set prior to accessing the # tmc2208 UART. This may be useful for configuring an analog mux for # UART communication. The default is to not configure any pins. #interpolate: True # If true, enable step interpolation (the driver will internally # step at a rate of 256 micro-steps). This interpolation does # introduce a small systemic positional deviation - see # TMC_Drivers.md for details. The default is True. run_current: # The amount of current (in amps RMS) to configure the driver to use # during stepper movement. This parameter must be provided. #hold_current: # The amount of current (in amps RMS) to configure the driver to use # when the stepper is not moving. Setting a hold_current is not # recommended (see TMC_Drivers.md for details). The default is to # not reduce the current. #sense_resistor: 0.110 # The resistance (in ohms) of the motor sense resistor. The default # is 0.110 ohms. #stealthchop_threshold: 0 # The velocity (in mm/s) to set the \"stealthChop\" threshold to. When # set, \"stealthChop\" mode will be enabled if the stepper motor # velocity is below this value. The default is 0, which disables # \"stealthChop\" mode. #driver_MULTISTEP_FILT: True #driver_IHOLDDELAY: 8 #driver_TPOWERDOWN: 20 #driver_TBL: 2 #driver_TOFF: 3 #driver_HEND: 0 #driver_HSTRT: 5 #driver_PWM_AUTOGRAD: True #driver_PWM_AUTOSCALE: True #driver_PWM_LIM: 12 #driver_PWM_REG: 8 #driver_PWM_FREQ: 1 #driver_PWM_GRAD: 14 #driver_PWM_OFS: 36 # Set the given register during the configuration of the TMC2208 # chip. This may be used to set custom motor parameters. The # defaults for each parameter are next to the parameter name in the # above list.","title":"[tmc2208]"},{"location":"Config_Reference.html#tmc2209","text":"Configurare un driver per motore passo-passo TMC2209 tramite UART a filo singolo. Per utilizzare questa funzione, definire una sezione di configurazione con un prefisso \"tmc2209\" seguito dal nome della sezione di configurazione dello stepper corrispondente (ad esempio, \"[tmc2209 stepper_x]\"). [tmc2209 stepper_x] uart_pin: #tx_pin: #select_pins: #interpolate: True run_current: #hold_current: #sense_resistor: 0.110 #stealthchop_threshold: 0 # See the \"tmc2208\" section for the definition of these parameters. #coolstep_threshold: # The velocity (in mm/s) to set the TMC driver internal \"CoolStep\" # threshold to. If set, the coolstep feature will be enabled when # the stepper motor velocity is near or above this value. Important # - if coolstep_threshold is set and \"sensorless homing\" is used, # then one must ensure that the homing speed is above the coolstep # threshold! The default is to not enable the coolstep feature. #uart_address: # The address of the TMC2209 chip for UART messages (an integer # between 0 and 3). This is typically used when multiple TMC2209 # chips are connected to the same UART pin. The default is zero. #driver_MULTISTEP_FILT: True #driver_IHOLDDELAY: 8 #driver_TPOWERDOWN: 20 #driver_TBL: 2 #driver_TOFF: 3 #driver_HEND: 0 #driver_HSTRT: 5 #driver_PWM_AUTOGRAD: True #driver_PWM_AUTOSCALE: True #driver_PWM_LIM: 12 #driver_PWM_REG: 8 #driver_PWM_FREQ: 1 #driver_PWM_GRAD: 14 #driver_PWM_OFS: 36 #driver_SGTHRS: 0 #driver_SEMIN: 0 #driver_SEUP: 0 #driver_SEMAX: 0 #driver_SEDN: 0 #driver_SEIMIN: 0 # Set the given register during the configuration of the TMC2209 # chip. This may be used to set custom motor parameters. The # defaults for each parameter are next to the parameter name in the # above list. #diag_pin: # The micro-controller pin attached to the DIAG line of the TMC2209 # chip. The pin is normally prefaced with \"^\" to enable a pullup. # Setting this creates a \"tmc2209_stepper_x:virtual_endstop\" virtual # pin which may be used as the stepper's endstop_pin. Doing this # enables \"sensorless homing\". (Be sure to also set driver_SGTHRS to # an appropriate sensitivity value.) The default is to not enable # sensorless homing.","title":"[tmc2209]"},{"location":"Config_Reference.html#tmc2660","text":"Configurare un driver per motore passo-passo TMC2660 tramite bus SPI. Per utilizzare questa funzione, definire una sezione di configurazione con un prefisso tmc2660 seguito dal nome della sezione di configurazione dello stepper corrispondente (ad esempio, \"[tmc2660 stepper_x]\"). [tmc2660 stepper_x] cs_pin: # Il pin corrispondente al pin di selezione del chip TMC2660. Questo pin # verr\u00e0 impostato su basso all'inizio dei messaggi SPI e impostato su # alto al termine del trasferimento del messaggio. Questo parametro # deve essere fornito. #spi_speed: 4000000 # Frequenza bus SPI utilizzata per comunicare con il driver # passo-passo TMC2660. Il valore predefinito \u00e8 4000000. #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # Vedere la sezione \"impostazioni comuni SPI\" per una descrizione # dei parametri di cui sopra. #interpolate: True # Se true, abilita l'interpolazione del passo (il driver eseguir\u00e0 un passo # interno a una velocit\u00e0 di 256 micropassi). Funziona solo se microsteps # \u00e8 impostato su 16. L'interpolazione introduce una piccola deviazione # posizionale sistemica - vedere TMC_Drivers.md per i dettagli. # L'impostazione predefinita \u00e8 Vero. run_current: # La quantit\u00e0 di corrente (in ampere RMS) utilizzata dal driver durante # il movimento passo-passo. Questo parametro deve essere fornito. #sense_resistor: # La resistenza (in ohm) del resistore di rilevamento del motore. # Questo parametro deve essere fornito. #idle_current_percent: 100 # La percentuale di run_current a cui il driver stepper sar\u00e0 ridotto allo # scadere del timeout di inattivit\u00e0 (\u00e8 necessario impostare il timeout # utilizzando una sezione di configurazione [idle_timeout]). La corrente # verr\u00e0 nuovamente aumentata una volta che lo stepper dovr\u00e0 muoversi # di nuovo. Assicurati di impostarlo su un valore sufficientemente alto in # modo che gli stepper non perdano la loro posizione. C'\u00e8 anche un piccolo # ritardo fino a quando la corrente non viene nuovamente aumentata, # quindi tienine conto quando comandi mosse veloci mentre lo stepper \u00e8 # al minimo. Il valore predefinito \u00e8 100 (nessuna riduzione). #driver_TBL: 2 #driver_RNDTF: 0 #driver_HDEC: 0 #driver_CHM: 0 #driver_HEND: 3 #driver_HSTRT: 3 #driver_TOFF: 4 #driver_SEIMIN: 0 #driver_SEDN: 0 #driver_SEMAX: 0 #driver_SEUP: 0 #driver_SEMIN: 0 #driver_SFILT: 0 #driver_SGT: 0 #driver_SLPH: 0 #driver_SLPL: 0 #driver_DISS2G: 0 #driver_TS2G: 3 # Imposta il parametro indicato durante la configurazione del chip TMC2660. # Questo pu\u00f2 essere utilizzato per impostare parametri del driver personalizzati. # Le impostazioni predefinite per ogni parametro sono accanto al nome del # parametro nell'elenco sopra. Vedere la scheda tecnica del TMC2660 su cosa # fa ogni parametro e quali sono le restrizioni sulle combinazioni di parametri. # Prestare particolare attenzione al registro CHOPCONF, dove l'impostazione # di CHM su zero o uno comporter\u00e0 modifiche al layout (il primo bit di HDEC) # viene interpretato come MSB di HSTRT in questo caso).","title":"[tmc2660]"},{"location":"Config_Reference.html#tmc2240","text":"Configure a TMC2240 stepper motor driver via SPI bus or UART. To use this feature, define a config section with a \"tmc2240\" prefix followed by the name of the corresponding stepper config section (for example, \"[tmc2240 stepper_x]\"). [tmc2240 stepper_x] cs_pin: # The pin corresponding to the TMC2240 chip select line. This pin # will be set to low at the start of SPI messages and raised to high # after the message completes. This parameter must be provided. #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. #uart_pin: # The pin connected to the TMC2240 DIAG1/SW line. If this parameter # is provided UART communication is used rather then SPI. #chain_position: #chain_length: # These parameters configure an SPI daisy chain. The two parameters # define the stepper position in the chain and the total chain length. # Position 1 corresponds to the stepper that connects to the MOSI signal. # The default is to not use an SPI daisy chain. #interpolate: True # If true, enable step interpolation (the driver will internally # step at a rate of 256 micro-steps). The default is True. run_current: # The amount of current (in amps RMS) to configure the driver to use # during stepper movement. This parameter must be provided. #hold_current: # The amount of current (in amps RMS) to configure the driver to use # when the stepper is not moving. Setting a hold_current is not # recommended (see TMC_Drivers.md for details). The default is to # not reduce the current. #rref: 12000 # The resistance (in ohms) of the resistor between IREF and GND. The # default is 12000. #stealthchop_threshold: 0 # The velocity (in mm/s) to set the \"stealthChop\" threshold to. When # set, \"stealthChop\" mode will be enabled if the stepper motor # velocity is below this value. The default is 0, which disables # \"stealthChop\" mode. #coolstep_threshold: # The velocity (in mm/s) to set the TMC driver internal \"CoolStep\" # threshold to. If set, the coolstep feature will be enabled when # the stepper motor velocity is near or above this value. Important # - if coolstep_threshold is set and \"sensorless homing\" is used, # then one must ensure that the homing speed is above the coolstep # threshold! The default is to not enable the coolstep feature. #high_velocity_threshold: # The velocity (in mm/s) to set the TMC driver internal \"high # velocity\" threshold (THIGH) to. This is typically used to disable # the \"CoolStep\" feature at high speeds. The default is to not set a # TMC \"high velocity\" threshold. #driver_MSLUT0: 2863314260 #driver_MSLUT1: 1251300522 #driver_MSLUT2: 608774441 #driver_MSLUT3: 269500962 #driver_MSLUT4: 4227858431 #driver_MSLUT5: 3048961917 #driver_MSLUT6: 1227445590 #driver_MSLUT7: 4211234 #driver_W0: 2 #driver_W1: 1 #driver_W2: 1 #driver_W3: 1 #driver_X1: 128 #driver_X2: 255 #driver_X3: 255 #driver_START_SIN: 0 #driver_START_SIN90: 247 #driver_OFFSET_SIN90: 0 # These fields control the Microstep Table registers directly. The optimal # wave table is specific to each motor and might vary with current. An # optimal configuration will have minimal print artifacts caused by # non-linear stepper movement. The values specified above are the default # values used by the driver. The value must be specified as a decimal integer # (hex form is not supported). In order to compute the wave table fields, # see the tmc2130 \"Calculation Sheet\" from the Trinamic website. # Additionally, this driver also has the OFFSET_SIN90 field which can be used # to tune a motor with unbalanced coils. See the `Sine Wave Lookup Table` # section in the datasheet for information about this field and how to tune # it. #driver_MULTISTEP_FILT: True #driver_IHOLDDELAY: 6 #driver_IRUNDELAY: 4 #driver_TPOWERDOWN: 10 #driver_TBL: 2 #driver_TOFF: 3 #driver_HEND: 2 #driver_HSTRT: 5 #driver_FD3: 0 #driver_TPFD: 4 #driver_CHM: 0 #driver_VHIGHFS: 0 #driver_VHIGHCHM: 0 #driver_DISS2G: 0 #driver_DISS2VS: 0 #driver_PWM_AUTOSCALE: True #driver_PWM_AUTOGRAD: True #driver_PWM_FREQ: 0 #driver_FREEWHEEL: 0 #driver_PWM_GRAD: 0 #driver_PWM_OFS: 29 #driver_PWM_REG: 4 #driver_PWM_LIM: 12 #driver_SGT: 0 #driver_SEMIN: 0 #driver_SEUP: 0 #driver_SEMAX: 0 #driver_SEDN: 0 #driver_SEIMIN: 0 #driver_SFILT: 0 #driver_SG4_ANGLE_OFFSET: 1 #driver_SLOPE_CONTROL: 0 # Set the given register during the configuration of the TMC2240 # chip. This may be used to set custom motor parameters. The # defaults for each parameter are next to the parameter name in the # above list. #diag0_pin: #diag1_pin: # The micro-controller pin attached to one of the DIAG lines of the # TMC2240 chip. Only a single diag pin should be specified. The pin # is \"active low\" and is thus normally prefaced with \"^!\". Setting # this creates a \"tmc2240_stepper_x:virtual_endstop\" virtual pin # which may be used as the stepper's endstop_pin. Doing this enables # \"sensorless homing\". (Be sure to also set driver_SGT to an # appropriate sensitivity value.) The default is to not enable # sensorless homing.","title":"[tmc2240]"},{"location":"Config_Reference.html#tmc5160","text":"Configurare un driver per motore passo-passo TMC5160 tramite bus SPI. Per utilizzare questa funzione, definire una sezione di configurazione con un prefisso \"tmc5160\" seguito dal nome della sezione di configurazione dello stepper corrispondente (ad esempio, \"[tmc5160 stepper_x]\"). [tmc5160 stepper_x] cs_pin: # The pin corresponding to the TMC5160 chip select line. This pin # will be set to low at the start of SPI messages and raised to high # after the message completes. This parameter must be provided. #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. #chain_position: #chain_length: # These parameters configure an SPI daisy chain. The two parameters # define the stepper position in the chain and the total chain length. # Position 1 corresponds to the stepper that connects to the MOSI signal. # The default is to not use an SPI daisy chain. #interpolate: True # If true, enable step interpolation (the driver will internally # step at a rate of 256 micro-steps). The default is True. run_current: # The amount of current (in amps RMS) to configure the driver to use # during stepper movement. This parameter must be provided. #hold_current: # The amount of current (in amps RMS) to configure the driver to use # when the stepper is not moving. Setting a hold_current is not # recommended (see TMC_Drivers.md for details). The default is to # not reduce the current. #sense_resistor: 0.075 # The resistance (in ohms) of the motor sense resistor. The default # is 0.075 ohms. #stealthchop_threshold: 0 # The velocity (in mm/s) to set the \"stealthChop\" threshold to. When # set, \"stealthChop\" mode will be enabled if the stepper motor # velocity is below this value. The default is 0, which disables # \"stealthChop\" mode. #coolstep_threshold: # The velocity (in mm/s) to set the TMC driver internal \"CoolStep\" # threshold to. If set, the coolstep feature will be enabled when # the stepper motor velocity is near or above this value. Important # - if coolstep_threshold is set and \"sensorless homing\" is used, # then one must ensure that the homing speed is above the coolstep # threshold! The default is to not enable the coolstep feature. #high_velocity_threshold: # The velocity (in mm/s) to set the TMC driver internal \"high # velocity\" threshold (THIGH) to. This is typically used to disable # the \"CoolStep\" feature at high speeds. The default is to not set a # TMC \"high velocity\" threshold. #driver_MSLUT0: 2863314260 #driver_MSLUT1: 1251300522 #driver_MSLUT2: 608774441 #driver_MSLUT3: 269500962 #driver_MSLUT4: 4227858431 #driver_MSLUT5: 3048961917 #driver_MSLUT6: 1227445590 #driver_MSLUT7: 4211234 #driver_W0: 2 #driver_W1: 1 #driver_W2: 1 #driver_W3: 1 #driver_X1: 128 #driver_X2: 255 #driver_X3: 255 #driver_START_SIN: 0 #driver_START_SIN90: 247 # These fields control the Microstep Table registers directly. The optimal # wave table is specific to each motor and might vary with current. An # optimal configuration will have minimal print artifacts caused by # non-linear stepper movement. The values specified above are the default # values used by the driver. The value must be specified as a decimal integer # (hex form is not supported). In order to compute the wave table fields, # see the tmc2130 \"Calculation Sheet\" from the Trinamic website. #driver_MULTISTEP_FILT: True #driver_IHOLDDELAY: 6 #driver_TPOWERDOWN: 10 #driver_TBL: 2 #driver_TOFF: 3 #driver_HEND: 2 #driver_HSTRT: 5 #driver_FD3: 0 #driver_TPFD: 4 #driver_CHM: 0 #driver_VHIGHFS: 0 #driver_VHIGHCHM: 0 #driver_DISS2G: 0 #driver_DISS2VS: 0 #driver_PWM_AUTOSCALE: True #driver_PWM_AUTOGRAD: True #driver_PWM_FREQ: 0 #driver_FREEWHEEL: 0 #driver_PWM_GRAD: 0 #driver_PWM_OFS: 30 #driver_PWM_REG: 4 #driver_PWM_LIM: 12 #driver_SGT: 0 #driver_SEMIN: 0 #driver_SEUP: 0 #driver_SEMAX: 0 #driver_SEDN: 0 #driver_SEIMIN: 0 #driver_SFILT: 0 #driver_DRVSTRENGTH: 0 #driver_BBMCLKS: 4 #driver_BBMTIME: 0 #driver_FILT_ISENSE: 0 # Set the given register during the configuration of the TMC5160 # chip. This may be used to set custom motor parameters. The # defaults for each parameter are next to the parameter name in the # above list. #diag0_pin: #diag1_pin: # The micro-controller pin attached to one of the DIAG lines of the # TMC5160 chip. Only a single diag pin should be specified. The pin # is \"active low\" and is thus normally prefaced with \"^!\". Setting # this creates a \"tmc5160_stepper_x:virtual_endstop\" virtual pin # which may be used as the stepper's endstop_pin. Doing this enables # \"sensorless homing\". (Be sure to also set driver_SGT to an # appropriate sensitivity value.) The default is to not enable # sensorless homing.","title":"[tmc5160]"},{"location":"Config_Reference.html#configurazione-della-corrente-del-motore-passo-passo-a-run-time","text":"","title":"Configurazione della corrente del motore passo-passo a run-time"},{"location":"Config_Reference.html#ad5206","text":"Digipot AD5206 configurati staticamente collegati tramite bus SPI (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"ad5206\"). [ad5206 my_digipot] enable_pin: # The pin corresponding to the AD5206 chip select line. This pin # will be set to low at the start of SPI messages and raised to high # after the message completes. This parameter must be provided. #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. #channel_1: #channel_2: #channel_3: #channel_4: #channel_5: #channel_6: # The value to statically set the given AD5206 channel to. This is # typically set to a number between 0.0 and 1.0 with 1.0 being the # highest resistance and 0.0 being the lowest resistance. However, # the range may be changed with the 'scale' parameter (see below). # If a channel is not specified then it is left unconfigured. #scale: # This parameter can be used to alter how the 'channel_x' parameters # are interpreted. If provided, then the 'channel_x' parameters # should be between 0.0 and 'scale'. This may be useful when the # AD5206 is used to set stepper voltage references. The 'scale' can # be set to the equivalent stepper amperage if the AD5206 were at # its highest resistance, and then the 'channel_x' parameters can be # specified using the desired amperage value for the stepper. The # default is to not scale the 'channel_x' parameters.","title":"[ad5206]"},{"location":"Config_Reference.html#mcp4451","text":"Digipot MCP4451 configurato staticamente collegato tramite bus I2C (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"mcp4451\"). [mcp4451 my_digipot] i2c_address: # The i2c address that the chip is using on the i2c bus. This # parameter must be provided. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #wiper_0: #wiper_1: #wiper_2: #wiper_3: # The value to statically set the given MCP4451 \"wiper\" to. This is # typically set to a number between 0.0 and 1.0 with 1.0 being the # highest resistance and 0.0 being the lowest resistance. However, # the range may be changed with the 'scale' parameter (see below). # If a wiper is not specified then it is left unconfigured. #scale: # This parameter can be used to alter how the 'wiper_x' parameters # are interpreted. If provided, then the 'wiper_x' parameters should # be between 0.0 and 'scale'. This may be useful when the MCP4451 is # used to set stepper voltage references. The 'scale' can be set to # the equivalent stepper amperage if the MCP4451 were at its highest # resistance, and then the 'wiper_x' parameters can be specified # using the desired amperage value for the stepper. The default is # to not scale the 'wiper_x' parameters.","title":"[mcp4451]"},{"location":"Config_Reference.html#mcp4728","text":"Convertitore digitale-analogico MCP4728 in configurazione statica collegato tramite bus I2C (\u00e8 possibile definire un numero qualsiasi di sezioni con prefisso \"mcp4728\"). [mcp4728 my_dac] #i2c_address: 96 # The i2c address that the chip is using on the i2c bus. The default # is 96. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #channel_a: #channel_b: #channel_c: #channel_d: # The value to statically set the given MCP4728 channel to. This is # typically set to a number between 0.0 and 1.0 with 1.0 being the # highest voltage (2.048V) and 0.0 being the lowest voltage. # However, the range may be changed with the 'scale' parameter (see # below). If a channel is not specified then it is left # unconfigured. #scale: # This parameter can be used to alter how the 'channel_x' parameters # are interpreted. If provided, then the 'channel_x' parameters # should be between 0.0 and 'scale'. This may be useful when the # MCP4728 is used to set stepper voltage references. The 'scale' can # be set to the equivalent stepper amperage if the MCP4728 were at # its highest voltage (2.048V), and then the 'channel_x' parameters # can be specified using the desired amperage value for the # stepper. The default is to not scale the 'channel_x' parameters.","title":"[mcp4728]"},{"location":"Config_Reference.html#mcp4018","text":"Digipot MCP4018 configurato staticamente collegato tramite due pin gpio \"bit banging\" (si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"mcp4018\"). [mcp4018 my_digipot] scl_pin: # Il pin \"clock\" SCL. Questo parametro deve essere fornito. sda_pin: # Il pin \"dati\" SDA. Questo parametro deve essere fornito. wiper: # Il valore su cui impostare staticamente il \"Wiper\" MCP4018 # specificato. Questo \u00e8 in genere impostato su un numero compreso # tra 0,0 e 1,0 con 1,0 come resistenza pi\u00f9 alta e 0,0 come resistenza # pi\u00f9 bassa. Tuttavia, l'intervallo pu\u00f2 essere modificato con il # parametro 'scale' (vedi sotto). Questo parametro deve essere fornito. #scale: # Questo parametro pu\u00f2 essere utilizzato per modificare il modo in # cui viene interpretato il parametro 'wiper'. Se fornito, il parametro # 'wiper' dovrebbe essere compreso tra 0.0 e 'scale'. Questo pu\u00f2 essere # utile quando l'MCP4018 viene utilizzato per impostare i riferimenti di # tensione stepper. La \"scala\" pu\u00f2 essere impostata sull'amperaggio # stepper equivalente se l'MCP4018 \u00e8 alla sua massima resistenza, # quindi \u00e8 possibile specificare il parametro \"wiper\" utilizzando il # valore di amperaggio desiderato per lo stepper. L'impostazione # predefinita \u00e8 di non ridimensionare il parametro 'wiper'.","title":"[mcp4018]"},{"location":"Config_Reference.html#supporto-display","text":"","title":"Supporto display"},{"location":"Config_Reference.html#display","text":"Supporto per un display collegato al microcontrollore. [display] lcd_type: # The type of LCD chip in use. This may be \"hd44780\", \"hd44780_spi\", # \"aip31068_spi\", \"st7920\", \"emulated_st7920\", \"uc1701\", \"ssd1306\", or # \"sh1106\". # See the display sections below for information on each type and # additional parameters they provide. This parameter must be # provided. #display_group: # The name of the display_data group to show on the display. This # controls the content of the screen (see the \"display_data\" section # for more information). The default is _default_20x4 for hd44780 or # aip31068_spi displays and _default_16x4 for other displays. #menu_timeout: # Timeout for menu. Being inactive this amount of seconds will # trigger menu exit or return to root menu when having autorun # enabled. The default is 0 seconds (disabled) #menu_root: # Name of the main menu section to show when clicking the encoder # on the home screen. The defaults is __main, and this shows the # the default menus as defined in klippy/extras/display/menu.cfg #menu_reverse_navigation: # When enabled it will reverse up and down directions for list # navigation. The default is False. This parameter is optional. #encoder_pins: # The pins connected to encoder. 2 pins must be provided when using # encoder. This parameter must be provided when using menu. #encoder_steps_per_detent: # How many steps the encoder emits per detent (\"click\"). If the # encoder takes two detents to move between entries or moves two # entries from one detent, try changing this. Allowed values are 2 # (half-stepping) or 4 (full-stepping). The default is 4. #click_pin: # The pin connected to 'enter' button or encoder 'click'. This # parameter must be provided when using menu. The presence of an # 'analog_range_click_pin' config parameter turns this parameter # from digital to analog. #back_pin: # The pin connected to 'back' button. This parameter is optional, # menu can be used without it. The presence of an # 'analog_range_back_pin' config parameter turns this parameter from # digital to analog. #up_pin: # The pin connected to 'up' button. This parameter must be provided # when using menu without encoder. The presence of an # 'analog_range_up_pin' config parameter turns this parameter from # digital to analog. #down_pin: # The pin connected to 'down' button. This parameter must be # provided when using menu without encoder. The presence of an # 'analog_range_down_pin' config parameter turns this parameter from # digital to analog. #kill_pin: # The pin connected to 'kill' button. This button will call # emergency stop. The presence of an 'analog_range_kill_pin' config # parameter turns this parameter from digital to analog. #analog_pullup_resistor: 4700 # The resistance (in ohms) of the pullup attached to the analog # button. The default is 4700 ohms. #analog_range_click_pin: # The resistance range for a 'enter' button. Range minimum and # maximum comma-separated values must be provided when using analog # button. #analog_range_back_pin: # The resistance range for a 'back' button. Range minimum and # maximum comma-separated values must be provided when using analog # button. #analog_range_up_pin: # The resistance range for a 'up' button. Range minimum and maximum # comma-separated values must be provided when using analog button. #analog_range_down_pin: # The resistance range for a 'down' button. Range minimum and # maximum comma-separated values must be provided when using analog # button. #analog_range_kill_pin: # The resistance range for a 'kill' button. Range minimum and # maximum comma-separated values must be provided when using analog # button.","title":"[display]"},{"location":"Config_Reference.html#display-hd44780","text":"Informazioni sulla configurazione dei display hd44780 (utilizzati nei display di tipo \"RepRapDiscount 2004 Smart Controller\"). [display] lcd_type: hd44780 # Set to \"hd44780\" for hd44780 displays. rs_pin: e_pin: d4_pin: d5_pin: d6_pin: d7_pin: # The pins connected to an hd44780 type lcd. These parameters must # be provided. #hd44780_protocol_init: True # Perform 8-bit/4-bit protocol initialization on an hd44780 display. # This is necessary on real hd44780 devices. However, one may need # to disable this on some \"clone\" devices. The default is True. #line_length: # Set the number of characters per line for an hd44780 type lcd. # Possible values are 20 (default) and 16. The number of lines is # fixed to 4. ...","title":"display hd44780"},{"location":"Config_Reference.html#display-hd44780_spi","text":"Informazioni sulla configurazione di un display hd44780_spi - un display 20x04 controllato tramite uno \"shift register\" hardware (che viene utilizzato nelle stampanti basate su mightyboard). [display] lcd_type: hd44780_spi # Set to \"hd44780_spi\" for hd44780_spi displays. latch_pin: spi_software_sclk_pin: spi_software_mosi_pin: spi_software_miso_pin: # The pins connected to the shift register controlling the display. # The spi_software_miso_pin needs to be set to an unused pin of the # printer mainboard as the shift register does not have a MISO pin, # but the software spi implementation requires this pin to be # configured. #hd44780_protocol_init: True # Perform 8-bit/4-bit protocol initialization on an hd44780 display. # This is necessary on real hd44780 devices. However, one may need # to disable this on some \"clone\" devices. The default is True. #line_length: # Set the number of characters per line for an hd44780 type lcd. # Possible values are 20 (default) and 16. The number of lines is # fixed to 4. ...","title":"display hd44780_spi"},{"location":"Config_Reference.html#aip31068_spi-display","text":"Information on configuring an aip31068_spi display - a very similar to hd44780_spi a 20x04 (20 symbols by 4 lines) display with slightly different internal protocol. [display] lcd_type: aip31068_spi latch_pin: spi_software_sclk_pin: spi_software_mosi_pin: spi_software_miso_pin: # The pins connected to the shift register controlling the display. # The spi_software_miso_pin needs to be set to an unused pin of the # printer mainboard as the shift register does not have a MISO pin, # but the software spi implementation requires this pin to be # configured. #line_length: # Set the number of characters per line for an hd44780 type lcd. # Possible values are 20 (default) and 16. The number of lines is # fixed to 4. ...","title":"aip31068_spi display"},{"location":"Config_Reference.html#display-st7920","text":"Informazioni sulla configurazione dei display st7920 (utilizzati nei display di tipo \"RepRapDiscount 12864 Full Graphic Smart Controller\"). [display] lcd_type: st7920 # Set to \"st7920\" for st7920 displays. cs_pin: sclk_pin: sid_pin: # The pins connected to an st7920 type lcd. These parameters must be # provided. ...","title":"display st7920"},{"location":"Config_Reference.html#display-emulazione-emulated_st7920","text":"Informazioni sulla configurazione di un display st7920 emulato, presenti in alcuni \"dispositivi touchscreen da 2,4 pollici\" e simili. [display] lcd_type: emulated_st7920 # Set to \"emulated_st7920\" for emulated_st7920 displays. en_pin: spi_software_sclk_pin: spi_software_mosi_pin: spi_software_miso_pin: # The pins connected to an emulated_st7920 type lcd. The en_pin # corresponds to the cs_pin of the st7920 type lcd, # spi_software_sclk_pin corresponds to sclk_pin and # spi_software_mosi_pin corresponds to sid_pin. The # spi_software_miso_pin needs to be set to an unused pin of the # printer mainboard as the st7920 as no MISO pin but the software # spi implementation requires this pin to be configured. ...","title":"display emulazione emulated_st7920"},{"location":"Config_Reference.html#display-uc1701","text":"Informazioni sulla configurazione dei display uc1701 (utilizzati nei display di tipo \"MKS Mini 12864\"). [display] lcd_type: uc1701 # Set to \"uc1701\" for uc1701 displays. cs_pin: a0_pin: # The pins connected to a uc1701 type lcd. These parameters must be # provided. #rst_pin: # The pin connected to the \"rst\" pin on the lcd. If it is not # specified then the hardware must have a pull-up on the # corresponding lcd line. #contrast: # The contrast to set. The value may range from 0 to 63 and the # default is 40. ...","title":"display uc1701"},{"location":"Config_Reference.html#display-ssd1306-e-sh1106","text":"Informazioni sulla configurazione dei display ssd1306 e sh1106. [display] lcd_type: # Set to either \"ssd1306\" or \"sh1106\" for the given display type. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # Optional parameters available for displays connected via an i2c # bus. See the \"common I2C settings\" section for a description of # the above parameters. #cs_pin: #dc_pin: #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # The pins connected to the lcd when in \"4-wire\" spi mode. See the # \"common SPI settings\" section for a description of the parameters # that start with \"spi_\". The default is to use i2c mode for the # display. #reset_pin: # A reset pin may be specified on the display. If it is not # specified then the hardware must have a pull-up on the # corresponding lcd line. #contrast: # The contrast to set. The value may range from 0 to 256 and the # default is 239. #vcomh: 0 # Set the Vcomh value on the display. This value is associated with # a \"smearing\" effect on some OLED displays. The value may range # from 0 to 63. Default is 0. #invert: False # TRUE inverts the pixels on certain OLED displays. The default is # False. #x_offset: 0 # Set the horizontal offset value on SH1106 displays. The default is # 0. ...","title":"display ssd1306 e sh1106"},{"location":"Config_Reference.html#display_data","text":"Supporto per la visualizzazione di dati personalizzati su uno schermo LCD. \u00c8 possibile creare un numero qualsiasi di gruppi di visualizzazione e un numero qualsiasi di elementi di dati in quei gruppi. Il display mostrer\u00e0 tutti gli elementi di dati per un determinato gruppo se l'opzione display_group nella sezione [display] \u00e8 impostata sul nome del gruppo specificato. Viene creato automaticamente un default set of display groups . \u00c8 possibile sostituire o estendere questi elementi display_data sovrascrivendo i valori predefiniti nel file di configurazione principale printer.cfg . [display_data my_group_name my_data_name] position: # Comma separated row and column of the display position that should # be used to display the information. This parameter must be # provided. text: # The text to show at the given position. This field is evaluated # using command templates (see docs/Command_Templates.md). This # parameter must be provided.","title":"[display_data]"},{"location":"Config_Reference.html#display_template","text":"Visualizza il testo dei dati \"macro\" (\u00e8 possibile definire un numero qualsiasi di sezioni con un prefisso display_template). Per informazioni sul template, vedere il documento template di comandi . Questa funzione consente di ridurre le definizioni ripetitive nelle sezioni display_data. Si pu\u00f2 usare la funzione incorporata render() nelle sezioni display_data per valutare un template. Per esempio, se si dovesse definire [display_template my_template] allora si potrebbe usare { render('my_template') } in una sezione display_data. Questa funzione pu\u00f2 essere utilizzata anche per aggiornamenti LED continui utilizzando il comando SET_LED_TEMPLATE . [display_template my_template_name] #param_<name>: # One may specify any number of options with a \"param_\" prefix. The # given name will be assigned the given value (parsed as a Python # literal) and will be available during macro expansion. If the # parameter is passed in the call to render() then that value will # be used during macro expansion. For example, a config with # \"param_speed = 75\" might have a caller with # \"render('my_template_name', param_speed=80)\". Parameter names may # not use upper case characters. text: # The text to return when the this template is rendered. This field # is evaluated using command templates (see # docs/Command_Templates.md). This parameter must be provided.","title":"[display_template]"},{"location":"Config_Reference.html#display_glyph","text":"Visualizza un glifo personalizzato sui display che lo supportano. Al nome dato verranno assegnati i dati di visualizzazione dati che possono quindi essere referenziati nei modelli di visualizzazione con il loro nome circondato da due simboli \"tilde\" per esempio ~my_display_glyph~ Vedere sample-glyphs.cfg per alcuni esempi. [display_glyph my_display_glyph] #data: # The display data, stored as 16 lines consisting of 16 bits (1 per # pixel) where '.' is a blank pixel and '*' is an on pixel (e.g., # \"****************\" to display a solid horizontal line). # Alternatively, one can use '0' for a blank pixel and '1' for an on # pixel. Put each display line into a separate config line. The # glyph must consist of exactly 16 lines with 16 bits each. This # parameter is optional. #hd44780_data: # Glyph to use on 20x4 hd44780 displays. The glyph must consist of # exactly 8 lines with 5 bits each. This parameter is optional. #hd44780_slot: # The hd44780 hardware index (0..7) to store the glyph at. If # multiple distinct images use the same slot then make sure to only # use one of those images in any given screen. This parameter is # required if hd44780_data is specified.","title":"[display_glyph]"},{"location":"Config_Reference.html#display-my_extra_display","text":"Se in printer.cfg \u00e8 stata definita una sezione primaria [display] come mostrato sopra, \u00e8 possibile definire pi\u00f9 display ausiliari. Si noti che i display ausiliari attualmente non supportano la funzionalit\u00e0 del menu, quindi non supportano le opzioni del \"menu\" o la configurazione dei pulsanti. [display my_extra_display] # Vedere la sezione \"display\" per i parametri disponibili.","title":"[display my_extra_display]"},{"location":"Config_Reference.html#menu","text":"Menu display lcd personalizzabili. Viene creato automaticamente un default set of menus . \u00c8 possibile sostituire o estendere il menu sovrascrivendo le impostazioni predefinite nel file di configurazione principale printer.cfg . Consulta il command template document per informazioni sugli attributi di menu disponibili durante il rendering del modello. # Common parameters available for all menu config sections. #[menu __some_list __some_name] #type: disabled # Permanently disabled menu element, only required attribute is 'type'. # Allows you to easily disable/hide existing menu items. #[menu some_name] #type: # One of command, input, list, text: # command - basic menu element with various script triggers # input - same like 'command' but has value changing capabilities. # Press will start/stop edit mode. # list - it allows for menu items to be grouped together in a # scrollable list. Add to the list by creating menu # configurations using \"some_list\" as a prefix - for # example: [menu some_list some_item_in_the_list] # vsdlist - same as 'list' but will append files from virtual sdcard # (will be removed in the future) #name: # Name of menu item - evaluated as a template. #enable: # Template that evaluates to True or False. #index: # Position where an item needs to be inserted in list. By default # the item is added at the end. #[menu some_list] #type: list #name: #enable: # See above for a description of these parameters. #[menu some_list some_command] #type: command #name: #enable: # See above for a description of these parameters. #gcode: # Script to run on button click or long click. Evaluated as a # template. #[menu some_list some_input] #type: input #name: #enable: # See above for a description of these parameters. #input: # Initial value to use when editing - evaluated as a template. # Result must be float. #input_min: # Minimum value of range - evaluated as a template. Default -99999. #input_max: # Maximum value of range - evaluated as a template. Default 99999. #input_step: # Editing step - Must be a positive integer or float value. It has # internal fast rate step. When \"(input_max - input_min) / # input_step > 100\" then fast rate step is 10 * input_step else fast # rate step is same input_step. #realtime: # This attribute accepts static boolean value. When enabled then # gcode script is run after each value change. The default is False. #gcode: # Script to run on button click, long click or value change. # Evaluated as a template. The button click will trigger the edit # mode start or end.","title":"[menu]"},{"location":"Config_Reference.html#sensori-di-filamento","text":"","title":"Sensori di filamento"},{"location":"Config_Reference.html#filament_switch_sensor","text":"Sensore del filamento a interruttore. Supporto per l'inserimento del filamento e il rilevamento dell'esaurimento tramite un sensore interruttore, come un interruttore di fine corsa. Per ulteriori informazioni, vedere command reference . [filament_switch_sensor my_sensor] #pause_on_runout: True # Se impostato su True, verr\u00e0 eseguita una PAUSA immediatamente # dopo il rilevamento di un'eccentricit\u00e0. Si noti che se pause_on_runout # \u00e8 False e runout_gcode viene omesso, il rilevamento dell'eccentricit\u00e0 # \u00e8 disabilitato. L'impostazione predefinita \u00e8 Vero. #runout_gcode: # Un elenco di comandi G-Code da eseguire dopo il rilevamento di # un'esaurimento del filamento. Vedi docs/Command_Templates.md # per il formato G-Code. Se pause_on_runout \u00e8 impostato su True, # questo codice G verr\u00e0 eseguito al termine della PAUSA. # L'impostazione predefinita \u00e8 di non eseguire alcun comando G-Code. #insert_gcode: # Un elenco di comandi G-Code da eseguire dopo il rilevamento # dell'inserimento di filamento. Vedi docs/Command_Templates.md # per il formato G-Code. L'impostazione predefinita non prevede # l'esecuzione di alcun comando G-Code, che disabilita il rilevamento # dell'inserimento. #event_delay: 3.0 # Il tempo minimo in secondi per ritardare tra gli eventi. Gli eventi # attivati durante questo periodo di tempo verranno ignorati # silenziosamente. L'impostazione predefinita \u00e8 3 secondi. #pause_delay: 0.5 # Il tempo di ritardo, in secondi, tra l'invio del comando pause e # l'esecuzione di runout_gcode. Potrebbe essere utile aumentare # questo ritardo se OctoPrint mostra uno strano comportamento # di pausa. Il valore predefinito \u00e8 0,5 secondi. #switch_pin: # Il pin su cui \u00e8 collegato l'interruttore. # Questo parametro deve essere fornito.","title":"[filament_switch_sensor]"},{"location":"Config_Reference.html#filament_motion_sensor","text":"Sensore di movimento del filamento. Supporto per l'inserimento del filamento e il rilevamento dell'esaurimento mediante un codificatore che commuta il pin di uscita durante il movimento del filamento attraverso il sensore. Per ulteriori informazioni, vedere command reference . [filament_motion_sensor my_sensor] detection_length: 7.0 # La lunghezza minima di filamento tirato attraverso il sensore # per attivare un cambio di stato su switch_pin # Il default \u00e8 7 mm. extruder: # Nome della sezione extruder section con cui questo sensore \u00e8 associato. # Questo parametro deve essere fornito. switch_pin: #pause_on_runout: #runout_gcode: #insert_gcode: #event_delay: #pause_delay: # Vedere la sezione \"filament_switch_sensor\" per la descrizione dei # parametri riportati sopra.","title":"[filament_motion_sensor]"},{"location":"Config_Reference.html#tsl1401cl_filament_width_sensor","text":"Sensore di larghezza del filamento basato su TSLl401CL. Consulta la guida per ulteriori informazioni. sl1401cl_filament_width_sensor] #pin: #diametro nominale del filamento predefinito: 1,75 (mm) # Differenza massima consentita del diametro del filamento in mm. #max_difference: 0.2 # La distanza dal sensore alla camera di fusione in mm. #measurement_delay: 100","title":"[tsl1401cl_filament_width_sensor]"},{"location":"Config_Reference.html#hall_filament_width_sensor","text":"Sensore di larghezza del filamento ad effetto Hall (vedere Sensore di larghezza del filamento Hall ). [hall_filament_width_sensor] adc1: adc2: # Pin di ingresso analogico collegati al sensore. # Questi parametri devono essere forniti. #cal_dia1: 1.50 #cal_dia2: 2.00 # I valori di calibrazione (in mm) per i sensori. Il valore predefinito # \u00e8 1.50 per cal_dia1 e 2.00 per cal_dia2. #raw_dia1: 9500 #raw_dia2: 10500 # I valori di calibrazione grezzi per i sensori. Il valore predefinito \u00e8 # 9500 per raw_dia1 e 10500 per raw_dia2. #default_nominal_filament_diameter: 1.75 # Il diametro nominale del filamento. # Questo parametro deve essere fornito. #max_difference: 0.200 # Differenza massima consentita del diametro del filamento in # millimetri (mm). Se la differenza tra il diametro nominale del # filamento e l'uscita del sensore \u00e8 maggiore di +- max_difference, # il moltiplicatore di estrusione viene riportato a %100. # Il valore predefinito \u00e8 0,200. #measurement_delay: 70 # La distanza dal sensore alla camera di fusione/hot-end in # millimetri (mm). Il filamento tra il sensore e l'hot-end verr\u00e0 # trattato come default_nominal_filament_diameter. Il modulo # host funziona con la logica FIFO. Mantiene ogni valore e posizione # del sensore in un array e li riporta nella posizione corretta. # Questo parametro deve essere fornito. #enable: False # Sensore abilitato o disabilitato dopo l'accensione. L'impostazione predefinita \u00e8 disabilitare. #measurement_interval: 10 # La distanza approssimativa (in mm) tra le letture del sensore. # Il valore predefinito \u00e8 10 mm. #logging: False # Il log esterno al terminale e klipper.log pu\u00f2 essere # attivato|off tramite comando. #min_diameter: 1.0 # Diametro minimo per trigger filament_switch_sensor virtuale. #use_current_dia_while_delay: False # Utilizzare il diametro attuale invece del diametro nominale # mentre il ritardo di misurazione non \u00e8 trascorso. #pause_on_runout: #runout_gcode: #insert_gcode: #event_delay: #pause_delay: # Vedere la sezione \"filament_switch_sensor\" per una # descrizione dei parametri di cui sopra.","title":"[hall_filament_width_sensor]"},{"location":"Config_Reference.html#load-cells","text":"","title":"Load Cells"},{"location":"Config_Reference.html#load_cell","text":"Load Cell. Uses an ADC sensor attached to a load cell to create a digital scale. [load_cell] sensor_type: # This must be one of the supported sensor types, see below.","title":"[load_cell]"},{"location":"Config_Reference.html#hx711","text":"This is a 24 bit low sample rate chip using \"bit-bang\" communications. It is suitable for filament scales. [load_cell] sensor_type: hx711 sclk_pin: # The pin connected to the HX711 clock line. This parameter must be provided. dout_pin: # The pin connected to the HX711 data output line. This parameter must be # provided. #gain: A-128 # Valid values for gain are: A-128, A-64, B-32. The default is A-128. # 'A' denotes the input channel and the number denotes the gain. Only the 3 # listed combinations are supported by the chip. Note that changing the gain # setting also selects the channel being read. #sample_rate: 80 # Valid values for sample_rate are 80 or 10. The default value is 80. # This must match the wiring of the chip. The sample rate cannot be changed # in software.","title":"HX711"},{"location":"Config_Reference.html#hx717","text":"This is the 4x higher sample rate version of the HX711, suitable for probing. [load_cell] sensor_type: hx717 sclk_pin: # The pin connected to the HX717 clock line. This parameter must be provided. dout_pin: # The pin connected to the HX717 data output line. This parameter must be # provided. #gain: A-128 # Valid values for gain are A-128, B-64, A-64, B-8. # 'A' denotes the input channel and the number denotes the gain setting. # Only the 4 listed combinations are supported by the chip. Note that # changing the gain setting also selects the channel being read. #sample_rate: 320 # Valid values for sample_rate are: 10, 20, 80, 320. The default is 320. # This must match the wiring of the chip. The sample rate cannot be changed # in software.","title":"HX717"},{"location":"Config_Reference.html#ads1220","text":"The ADS1220 is a 24 bit ADC supporting up to a 2Khz sample rate configurable in software. [load_cell] sensor_type: ads1220 cs_pin: # The pin connected to the ADS1220 chip select line. This parameter must # be provided. #spi_speed: 512000 # This chip supports 2 speeds: 256000 or 512000. The faster speed is only # enabled when one of the Turbo sample rates is used. The correct spi_speed # is selected based on the sample rate. #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. data_ready_pin: # Pin connected to the ADS1220 data ready line. This parameter must be # provided. #gain: 128 # Valid gain values are 128, 64, 32, 16, 8, 4, 2, 1 # The default is 128 #pga_bypass: False # Disable the internal Programmable Gain Amplifier. If # True the PGA will be disabled for gains 1, 2, and 4. The PGA is always # enabled for gain settings 8 to 128, regardless of the pga_bypass setting. # If AVSS is used as an input pga_bypass is forced to True. # The default is False. #sample_rate: 660 # This chip supports two ranges of sample rates, Normal and Turbo. In turbo # mode the chip's internal clock runs twice as fast and the SPI communication # speed is also doubled. # Normal sample rates: 20, 45, 90, 175, 330, 600, 1000 # Turbo sample rates: 40, 90, 180, 350, 660, 1200, 2000 # The default is 660 #input_mux: # Input multiplexer configuration, select a pair of pins to use. The first pin # is the positive, AINP, and the second pin is the negative, AINN. Valid # values are: 'AIN0_AIN1', 'AIN0_AIN2', 'AIN0_AIN3', 'AIN1_AIN2', 'AIN1_AIN3', # 'AIN2_AIN3', 'AIN1_AIN0', 'AIN3_AIN2', 'AIN0_AVSS', 'AIN1_AVSS', 'AIN2_AVSS' # and 'AIN3_AVSS'. If AVSS is used the PGA is bypassed and the pga_bypass # setting will be forced to True. # The default is AIN0_AIN1. #vref: # The selected voltage reference. Valid values are: 'internal', 'REF0', 'REF1' # and 'analog_supply'. Default is 'internal'.","title":"ADS1220"},{"location":"Config_Reference.html#supporto-hardware-per-specifica-scheda","text":"","title":"Supporto hardware per specifica scheda"},{"location":"Config_Reference.html#sx1509","text":"Configurare un'espansione SX1509 da I2C a GPIO. A causa del ritardo dovuto alla comunicazione I2C, NON utilizzare i pin SX1509 come abilitazione stepper, pin step o dir o qualsiasi altro pin che richieda un bit banging veloce. Sono utilizzati al meglio come uscite digitali statiche o controllate da gcode o pin hardware-pwm per es. fan. Si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"sx1509\". Ogni espansione fornisce un set di 16 pin (da sx1509_my_sx1509:PIN_0 a sx1509_my_sx1509:PIN_15) che possono essere utilizzati nella configurazione della stampante. Per un esempio, vedere il file generic-duet2-duex.cfg . [sx1509 my_sx1509] i2c_address: # I2C address used by this expander. Depending on the hardware # jumpers this is one out of the following addresses: 62 63 112 # 113. This parameter must be provided. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters.","title":"[sx1509]"},{"location":"Config_Reference.html#samd_sercom","text":"Configurazione SAMD SERCOM per specificare quali pin utilizzare su un determinato SERCOM. Si pu\u00f2 definire un numero qualsiasi di sezioni con un prefisso \"samd_sercom\". Ogni SERCOM deve essere configurato prima di utilizzarlo come periferica SPI o I2C. Posiziona questa sezione di configurazione sopra qualsiasi altra sezione che fa uso di bus SPI o I2C. [samd_sercom my_sercom] sercom: # Il nome del bus Sercom da configurare nel microcontrollore. I nomi # disponibili sono \"sercom0\", \"sercom1\", ecc. # Questo parametro deve essere fornito. tx_pin: # Pin MOSI per la comunicazione SPI o pin SDA (dati) per la # comunicazione I2C. Il pin deve avere una configurazione pinmux # valida per la specifica periferica SERCOM. # Questo parametro deve essere fornito. #rx_pin: # Pin MISO per la comunicazione SPI. Questo pin non viene utilizzato # per la comunicazione I2C (I2C utilizza tx_pin sia per l'invio che per la # ricezione). Il pin deve avere una configurazione pinmux valida per la # specifica periferica SERCOM. Questo parametro \u00e8 facoltativo. clk_pin: # Pin CLK per la comunicazione SPI o pin SCL (clock) per la # comunicazione I2C. Il pin deve avere una configurazione pinmux # valida per la specifica periferica SERCOM. Questo parametro deve # essere fornito.","title":"[samd_sercom]"},{"location":"Config_Reference.html#adc_scaled","text":"Scaling analogico di Duet2 Maestro tramite letture vref e vssa. La definizione di una sezione adc_scaled abilita pin adc virtuali (come \"my_name:PB0\") che vengono regolati automaticamente dai pin di monitoraggio vref e vssa della scheda. Assicurati di definire questa sezione di configurazione sopra qualsiasi sezione di configurazione che utilizza uno di questi pin virtuali. Per un esempio, vedere il file generic-duet2-maestro.cfg . [adc_scaled my_name] vref_pin: # The ADC pin to use for VREF monitoring. This parameter must be # provided. vssa_pin: # The ADC pin to use for VSSA monitoring. This parameter must be # provided. #smooth_time: 2.0 # A time value (in seconds) over which the vref and vssa # measurements will be smoothed to reduce the impact of measurement # noise. The default is 2 seconds.","title":"[adc_scaled]"},{"location":"Config_Reference.html#replicape","text":"Supporto per Replicape: vedere la guida beaglebone e il file generic-replicape.cfg per un esempio. # La sezione di configurazione \"replicape\" aggiunge i pin di abilitazione # dello stepper virtuale \"replicape: stepper_x_enable\" (per stepper X, Y, Z, # E e H) e i pin di uscita PWM \"replicape: power_x\" (per hotbed, e, h, fan0, # fan1 , fan2 e fan3) che possono quindi essere utilizzati altrove nel file # di configurazione. [replicape] revision: # La revisione dell'hardware di replicape. Attualmente \u00e8 supportata solo # la revisione \"B3\". Questo parametro deve essere fornito. #enable_pin: !gpio0_20 # Il pin di abilitazione globale dei replicape. L'impostazione predefinita # \u00e8 !gpio0_20 (aka P9_41). host_mcu: # Il nome della sezione mcu config che comunica con l'istanza mcu # \"linux process\" di Klipper. Questo parametro deve essere fornito. #standstill_power_down: False # Questo parametro controlla la linea CFG6_ENN su tutti i motori # passo-passo. True imposta le righe di abilitazione su \"open\". # L'impostazione predefinita \u00e8 Falso. #stepper_x_microstep_mode: #stepper_y_microstep_mode: #stepper_z_microstep_mode: #stepper_e_microstep_mode: #stepper_h_microstep_mode: # Questo parametro controlla i pin CFG1 e CFG2 del driver del motore # passo-passo specificato. Le opzioni disponibili sono: disabilita, 1, 2, # spread2, 4, 16, spread4, spread16, stealth4 e stealth16. L'impostazione # predefinita \u00e8 disabilitata. #stepper_x_current: #stepper_y_current: #stepper_z_current: #stepper_e_current: #stepper_h_current: # La corrente massima configurata (in Amp) del driver del motore # passo-passo. Questo parametro deve essere fornito se lo stepper non # \u00e8 in modalit\u00e0 disabilitazione. #stepper_x_chopper_off_time_high: #stepper_y_chopper_off_time_high: #stepper_z_chopper_off_time_high: #stepper_e_chopper_off_time_high: #stepper_h_chopper_off_time_high: # Questo parametro controlla il pin CFG0 del driver del motore # passo-passo (True imposta CFG0 alto, False lo imposta basso). # L'impostazione predefinita \u00e8 False. #stepper_x_chopper_hysteresis_high: #stepper_y_chopper_hysteresis_high: #stepper_z_chopper_hysteresis_high: #stepper_e_chopper_hysteresis_high: #stepper_h_chopper_hysteresis_high: # Questo parametro controlla il pin CFG4 del driver del motore # passo-passo (True imposta CFG4 alto, False lo imposta basso). # L'impostazione predefinita \u00e8 False. #stepper_x_chopper_blank_time_high: #stepper_y_chopper_blank_time_high: #stepper_z_chopper_blank_time_high: #stepper_e_chopper_blank_time_high: #stepper_h_chopper_blank_time_high: # Questo parametro controlla il pin CFG5 del driver del motore # passo-passo (True imposta CFG5 alto, False lo imposta basso). # L'impostazione predefinita \u00e8 True.","title":"[replicape]"},{"location":"Config_Reference.html#altri-moduli-personalizzati","text":"","title":"Altri moduli personalizzati"},{"location":"Config_Reference.html#palette2","text":"Supporto multimateriale Palette 2: fornisce un'integrazione pi\u00f9 stretta supportando i dispositivi Palette 2 in modalit\u00e0 connessa. Questo modulo richiede anche [virtual_sdcard] e [pause_resume] per la piena funzionalit\u00e0. Se si utilizza questo modulo, non utilizzare il plug-in Palette 2 per Octoprint poich\u00e9 entreranno in conflitto e 1 non si inizializzer\u00e0 correttamente, probabilmente interrompendo la stampa. Se utilizzi Octoprint e esegui lo streaming di gcode sulla porta seriale invece di stampare da virtual_sd, rimuovere M1 e M0 da Pausa dei comandi in Impostazioni > Connessione seriale > Firmware e protocollo eviter\u00e0 la necessit\u00e0 per avviare la stampa sulla tavolozza 2 e riattivare la pausa in Octoprint per avviare la stampa. [palette2] serial: # The serial port to connect to the Palette 2. #baud: 115200 # The baud rate to use. The default is 115200. #feedrate_splice: 0.8 # The feedrate to use when splicing, default is 0.8 #feedrate_normal: 1.0 # The feedrate to use after splicing, default is 1.0 #auto_load_speed: 2 # Extrude feedrate when autoloading, default is 2 (mm/s) #auto_cancel_variation: 0.1 # Auto cancel print when ping variation is above this threshold","title":"[palette2]"},{"location":"Config_Reference.html#angle","text":"Magnetic hall angle sensor support for reading stepper motor angle shaft measurements using a1333, as5047d, mt6816, mt6826s, or tle5012b SPI chips. The measurements are available via the API Server and motion analysis tool . See the G-Code reference for available commands. [angle my_angle_sensor] sensor_type: # The type of the magnetic hall sensor chip. Available choices are # \"a1333\", \"as5047d\", \"mt6816\", \"mt6826s\", and \"tle5012b\". This parameter must be # specified. #sample_period: 0.000400 # The query period (in seconds) to use during measurements. The # default is 0.000400 (which is 2500 samples per second). #stepper: # The name of the stepper that the angle sensor is attached to (eg, # \"stepper_x\"). Setting this value enables an angle calibration # tool. To use this feature, the Python \"numpy\" package must be # installed. The default is to not enable angle calibration for the # angle sensor. cs_pin: # The SPI enable pin for the sensor. This parameter must be provided. #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters.","title":"[angle]"},{"location":"Config_Reference.html#parametri-bus-comuni","text":"","title":"Parametri bus comuni"},{"location":"Config_Reference.html#impostazioni-spi-comuni","text":"I seguenti parametri sono generalmente disponibili per i dispositivi che utilizzano un bus SPI. #spi_speed: # La velocit\u00e0 SPI (in Hz) da utilizzare durante la comunicazione con il # dispositivo. L'impostazione predefinita dipende dal tipo di dispositivo. #spi_bus: # Se il microcontrollore supporta pi\u00f9 bus SPI, \u00e8 possibile specificare # qui il nome del bus del microcontrollore. L'impostazione predefinita # dipende dal tipo di microcontrollore. #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # Specificare i parametri di cui sopra per utilizzare \"SPI basato su # software\". Questa modalit\u00e0 non richiede il supporto hardware del # microcontrollore (in genere \u00e8 possibile utilizzare qualsiasi pin generico). # L'impostazione predefinita \u00e8 di non utilizzare \"spi software\".","title":"Impostazioni SPI comuni"},{"location":"Config_Reference.html#impostazioni-i2c-comuni","text":"I seguenti parametri sono generalmente disponibili per i dispositivi che utilizzano un bus I2C. Tieni presente che l'attuale supporto del microcontrollore di Klipper per I2C generalmente non tollera il rumore di linea. Errori imprevisti sui cavi I2C potrebbero far s\u00ec che Klipper sollevi un errore di runtime. Il supporto di Klipper per il ripristino degli errori varia a seconda del tipo di microcontrollore. In genere si consiglia di utilizzare solo dispositivi I2C che si trovano sullo stesso circuito stampato del microcontrollore. Most Klipper micro-controller implementations only support an i2c_speed of 100000 ( standard mode , 100kbit/s). The Klipper \"Linux\" micro-controller supports a 400000 speed ( fast mode , 400kbit/s), but it must be set in the operating system and the i2c_speed parameter is otherwise ignored. The Klipper \"RP2040\" micro-controller and ATmega AVR family and some STM32 (F0, G0, G4, L4, F7, H7) support a rate of 400000 via the i2c_speed parameter. All other Klipper micro-controllers use a 100000 rate and ignore the i2c_speed parameter. #i2c_address: # The i2c address of the device. This must specified as a decimal # number (not in hex). The default depends on the type of device. #i2c_mcu: # The name of the micro-controller that the chip is connected to. # The default is \"mcu\". #i2c_bus: # If the micro-controller supports multiple I2C busses then one may # specify the micro-controller bus name here. The default depends on # the type of micro-controller. #i2c_software_scl_pin: #i2c_software_sda_pin: # Specify these parameters to use micro-controller software based # I2C \"bit-banging\" support. The two parameters should the two pins # on the micro-controller to use for the scl and sda wires. The # default is to use hardware based I2C support as specified by the # i2c_bus parameter. #i2c_speed: # The I2C speed (in Hz) to use when communicating with the device. # The Klipper implementation on most micro-controllers is hard-coded # to 100000 and changing this value has no effect. The default is # 100000. Linux, RP2040 and ATmega support 400000.","title":"Impostazioni I2C comuni"},{"location":"Config_checks.html","text":"Controlli della configurazione \u00b6 Questo documento fornisce una lista di step per confermare le impostazioni dei pin nel file printer.cfg di Klipper. \u00c8 una buona idea eseguire questi passi dopo aver seguito i passi nel documento di installazione . In alcuni passaggi di questa guida, potrebbe essere necessario modificare il file di configurazione di Klipper. Assicuratevi di dare il comando RESTART, dopo ogni modifica al file di configurazione, per accertarsi che le modifiche abbiano effetto(scrivere \"restart\" nella scheda del terminale di Octoprint e cliccare su INVIA). E' anche consigliabile utilizzare il comando STATUS, dopo ogni RESTART, per verificare che il file di configurazione sia stato caricato correttamente. Verifica delle temperature \u00b6 Inizia verificando che le temperature siano riportate correttamente. Naviga nella sezione della temperatura nell'interfaccia utente. Verifica che la temperatura del nozzle e del letto (se possibile) sono presenti e non aumentino. Nel caso aumentino, togli corrente alla stampante. Se le temperature non sono accurate, ricontrolla le impostazioni del nozzle e del letto chiamate \"sensor_type\" e \"sensor_pin\". Verifica M112 \u00b6 Naviga nella console dei comandi e invia un comando M112 nel terminale. Questo comando chiede a Klipper di andare in uno stato di spegnimento. Ci\u00f2 causer\u00e0 un errore, che potr\u00e0 essere risolto con l'esecuzione di un comando \"FIRMWARE_RESTART\" nella console. Anche octoprint richieder\u00e0 una riconessione. Poi vai nella sezione delle temperature e verifica che esse continuino ad aggiornarsi e non incrementino. Se le temperature incrementano togliere immediatamente corrente alla stampante. Verifica i riscaldatori \u00b6 Naviga nella sezione contenente il grafico delle temperature ed inserisci 50 seguito dall\u2019 tasto enter nel riquadro della temperatura dell\u2019extruder. La curva del grafico della temperatura dell\u2019exruder dovrebbe iniziare ad aumentare (in un tempo di circa 30 secondi) per arrivare ai 50 gradi impostati. Quindi posizionarsi sul e selezionare \u201cOff\u201d. Dopo alcuni minuti la temperature dovrebbe scendere e tornare al valore iniziale di temperatura ambiente. Se la temperatura non dovesse aumentare bisogna verificare il settaggio Se la stampante ha il piatto riscaldato, eseguire nuovamente il test indicato in precedenza ma per il piatto. Verifica il pin di abilitazione del motore passo-passo \u00b6 Verifica che gli assi della stampante possano muoversi liberamente (I motori sono disabilitati). In caso contrario, inviare un comando M84 per disabilitare i motori. Se un asse qualunque non si potesse muovere liberamente, verificare la configurazione stepper \"enable_pin\" per gli assi in questione.Nella maggior parte dei driver per motori passo-passo, il pin di abilitazione del motore \u00e8 \"attivo basso\" e pertanto il pin di abilitazione deve essere preceduto da un \"!\" (ad esempio, \"enable_pin: !PA1\"). Verifica i finecorsa \u00b6 Muovi manualmente tutti gli assi della stamapante in modo che nessuno sia in contatto con gli ensdstop. Digita il comando QUERY_ENDSTOPS attraverso la consolle di comando. Dovrebbe essere visualizzato lo stato corrente degli endstop che dovrebbe essere per tutti e tre \"open\" (aperto). Per ogni endstop, digita di nuovo il comando QUERY_ENDSTOPS mentre manualmente chiudi, uno alla volta, gli endstop. Il comando QUERY_ENDSTOPS dovrebbe riportare l'endstop chiuso manualmente come \"TRIGGERED\". Se l'endstop appare invertito (riporta \"open\" quando chiuso e viceversa) allora aggiungi \"!\" alla definizione del pin corrispondente (per esempio \"endstop_pin: ^PA2 \") o rimuovi il punto esclamativo \"!\" se \u00e8 presente. Se il segnale del finecorsa non cambia , pu\u00f2 significare che il fine corsa \u00e8 collegato a un pin diverso. Tuttavia, potrebbe essere necessaria una modifica all'impostazione pullup del pin (il '^' all'inizio del istruzione \"endstop_pin\".La maggior parte delle stampanti utilizzano un resistore pullup e l'istruzione '^' dovrebbe essere presente). Verifica dei motori passo-passo \u00b6 Use the STEPPER_BUZZ command to verify the connectivity of each stepper motor. Start by manually positioning the given axis to a midway point and then run STEPPER_BUZZ STEPPER=stepper_x in the command console. The STEPPER_BUZZ command will cause the given stepper to move one millimeter in a positive direction and then it will return to its starting position. (If the endstop is defined at position_endstop=0 then at the start of each movement the stepper will move away from the endstop.) It will perform this oscillation ten times. Se il motore passo-passo non si muove , verifica le impostazioni \"enable_pin\" e \"step_pin\" sul driver. Se il motore passo-passo si muove ma non torna nella sua posizione originale, verificare l'impostazione \"dir_pin\". Se il motore passo-passo oscilla in una direzione errata, generalmente sta a significare che \u00e8 necessario invertire il \"dir_pin\" del l'asse. Questo viene fatto aggiungendo un istruzione '!' alla \"dir_pin\" nel file di configurazione della stampante (o rimuovendolo se ne esiste gi\u00e0 presente). Se il motore passo-passo si muove di pi\u00f9 o di meno di un millimetro, verificare l'impostazione \"rotation_distance\". Eseguire il test sopra descritto per ogni motore passo-passo definito nel file di configurazione. (Impostare il parametro STEPPER del comando STEPPER_BUZZ sul nome della sezione di configurazione da testare.) Se non \u00e8 presente il filamento nell'estrusore, \u00e8 possibile utilizzare STEPPER_BUZZ per verificare la connessione del motore dell'estrusore (usare STEPPER=estrusore). In caso contrario, \u00e8 meglio testare il motore dell'estrusore per conto suo (vedere la sezione successiva). Dopo aver verificato tutti i finecorsa e aver verificato tutti i motori passo-passo, \u00e8 necessario testare il sistema di homing. Scrivere un comando G28 per portare a home tutti gli assi. Rimuovere l'alimentazione dalla stampante se l'istruzione non funziona correttamente. Se necessario, ripetere i passaggi di verifica del finecorsa e del motore passo-passo. Verifica il motore dell'estrusore \u00b6 To test the extruder motor it will be necessary to heat the extruder to a printing temperature. Navigate to the temperature graph section and select a target temperature from the temperature drop-down box (or manually enter an appropriate temperature). Wait for the printer to reach the desired temperature. Then navigate to the command console and click the \"Extrude\" button. Verify that the extruder motor turns in the correct direction. If it does not, see the troubleshooting tips in the previous section to confirm the \"enable_pin\", \"step_pin\", and \"dir_pin\" settings for the extruder. Calibrare le impostazioni del PID \u00b6 Klipper supporta il sistema controllo PID per iriscaldatori dell'estrusore e del piatto. Per utilizzare questo sistema di controllo, \u00e8 necessario calibrare le impostazioni PID su ciascuna stampante (le impostazioni PID presenti in altri firmware o nei file di configurazione di esempio spesso funzionano male). To calibrate the extruder, navigate to the command console and run the PID_CALIBRATE command. For example: PID_CALIBRATE HEATER=extruder TARGET=170 Al termine del test di ottimizzazione, eseguire l'istruzione SAVE_CONFIG per aggiornare il file printer.cfg con le nuove impostazioni PID. Se la stampante ha un piatto riscaldato ed \u00e8 dotato di azionamento con funzione PWM (Pulse Width Modulation), si consiglia di utilizzare il controllo PID anche per il piatto. (Quando il riscaldatore del piatto \u00e8 controllato utilizzando l'algoritmo PID, potrebbe accendersi e spegnersi dieci volte al secondo, il che potrebbe non essere adatto per i riscaldatori che utilizzano un rel\u00e8 elettromeccanico.) Un tipico comando per calibrazione PID del piatto \u00e8: PID_CALIBRATE HEATER=heater_bed TARGET= 60 Passi sucessivi \u00b6 Questa guida ha lo scopo di aiutare la verifica delle impostazioni di base riferite ai pin presenti nel file di configurazione di Klipper. Assicurati di leggere la guida bed leveling . Consulta anche il documento Slicers per informazioni sulla configurazione di un software slicer con Klipper. Dopo aver verificato che la stampa di base funziona, \u00e8 una buona prassi procedere con la calibrazione avanzamento pressione . Potrebbe essere necessario eseguire altri tipi di calibrazione di dettaglio in riferimento alla stampante: sono disponibili numerose guide online per questo scopo (ad esempio, eseguire una ricerca sul Web per \"calibrazione della stampante 3d\"). Ad esempio, se si verifica l'effetto chiamato risonanza, \u00e8 possibile provare a seguire la calibrazione tramite l'istruzione compensazione della risonanza .","title":"Controlli della configurazione"},{"location":"Config_checks.html#controlli-della-configurazione","text":"Questo documento fornisce una lista di step per confermare le impostazioni dei pin nel file printer.cfg di Klipper. \u00c8 una buona idea eseguire questi passi dopo aver seguito i passi nel documento di installazione . In alcuni passaggi di questa guida, potrebbe essere necessario modificare il file di configurazione di Klipper. Assicuratevi di dare il comando RESTART, dopo ogni modifica al file di configurazione, per accertarsi che le modifiche abbiano effetto(scrivere \"restart\" nella scheda del terminale di Octoprint e cliccare su INVIA). E' anche consigliabile utilizzare il comando STATUS, dopo ogni RESTART, per verificare che il file di configurazione sia stato caricato correttamente.","title":"Controlli della configurazione"},{"location":"Config_checks.html#verifica-delle-temperature","text":"Inizia verificando che le temperature siano riportate correttamente. Naviga nella sezione della temperatura nell'interfaccia utente. Verifica che la temperatura del nozzle e del letto (se possibile) sono presenti e non aumentino. Nel caso aumentino, togli corrente alla stampante. Se le temperature non sono accurate, ricontrolla le impostazioni del nozzle e del letto chiamate \"sensor_type\" e \"sensor_pin\".","title":"Verifica delle temperature"},{"location":"Config_checks.html#verifica-m112","text":"Naviga nella console dei comandi e invia un comando M112 nel terminale. Questo comando chiede a Klipper di andare in uno stato di spegnimento. Ci\u00f2 causer\u00e0 un errore, che potr\u00e0 essere risolto con l'esecuzione di un comando \"FIRMWARE_RESTART\" nella console. Anche octoprint richieder\u00e0 una riconessione. Poi vai nella sezione delle temperature e verifica che esse continuino ad aggiornarsi e non incrementino. Se le temperature incrementano togliere immediatamente corrente alla stampante.","title":"Verifica M112"},{"location":"Config_checks.html#verifica-i-riscaldatori","text":"Naviga nella sezione contenente il grafico delle temperature ed inserisci 50 seguito dall\u2019 tasto enter nel riquadro della temperatura dell\u2019extruder. La curva del grafico della temperatura dell\u2019exruder dovrebbe iniziare ad aumentare (in un tempo di circa 30 secondi) per arrivare ai 50 gradi impostati. Quindi posizionarsi sul e selezionare \u201cOff\u201d. Dopo alcuni minuti la temperature dovrebbe scendere e tornare al valore iniziale di temperatura ambiente. Se la temperatura non dovesse aumentare bisogna verificare il settaggio Se la stampante ha il piatto riscaldato, eseguire nuovamente il test indicato in precedenza ma per il piatto.","title":"Verifica i riscaldatori"},{"location":"Config_checks.html#verifica-il-pin-di-abilitazione-del-motore-passo-passo","text":"Verifica che gli assi della stampante possano muoversi liberamente (I motori sono disabilitati). In caso contrario, inviare un comando M84 per disabilitare i motori. Se un asse qualunque non si potesse muovere liberamente, verificare la configurazione stepper \"enable_pin\" per gli assi in questione.Nella maggior parte dei driver per motori passo-passo, il pin di abilitazione del motore \u00e8 \"attivo basso\" e pertanto il pin di abilitazione deve essere preceduto da un \"!\" (ad esempio, \"enable_pin: !PA1\").","title":"Verifica il pin di abilitazione del motore passo-passo"},{"location":"Config_checks.html#verifica-i-finecorsa","text":"Muovi manualmente tutti gli assi della stamapante in modo che nessuno sia in contatto con gli ensdstop. Digita il comando QUERY_ENDSTOPS attraverso la consolle di comando. Dovrebbe essere visualizzato lo stato corrente degli endstop che dovrebbe essere per tutti e tre \"open\" (aperto). Per ogni endstop, digita di nuovo il comando QUERY_ENDSTOPS mentre manualmente chiudi, uno alla volta, gli endstop. Il comando QUERY_ENDSTOPS dovrebbe riportare l'endstop chiuso manualmente come \"TRIGGERED\". Se l'endstop appare invertito (riporta \"open\" quando chiuso e viceversa) allora aggiungi \"!\" alla definizione del pin corrispondente (per esempio \"endstop_pin: ^PA2 \") o rimuovi il punto esclamativo \"!\" se \u00e8 presente. Se il segnale del finecorsa non cambia , pu\u00f2 significare che il fine corsa \u00e8 collegato a un pin diverso. Tuttavia, potrebbe essere necessaria una modifica all'impostazione pullup del pin (il '^' all'inizio del istruzione \"endstop_pin\".La maggior parte delle stampanti utilizzano un resistore pullup e l'istruzione '^' dovrebbe essere presente).","title":"Verifica i finecorsa"},{"location":"Config_checks.html#verifica-dei-motori-passo-passo","text":"Use the STEPPER_BUZZ command to verify the connectivity of each stepper motor. Start by manually positioning the given axis to a midway point and then run STEPPER_BUZZ STEPPER=stepper_x in the command console. The STEPPER_BUZZ command will cause the given stepper to move one millimeter in a positive direction and then it will return to its starting position. (If the endstop is defined at position_endstop=0 then at the start of each movement the stepper will move away from the endstop.) It will perform this oscillation ten times. Se il motore passo-passo non si muove , verifica le impostazioni \"enable_pin\" e \"step_pin\" sul driver. Se il motore passo-passo si muove ma non torna nella sua posizione originale, verificare l'impostazione \"dir_pin\". Se il motore passo-passo oscilla in una direzione errata, generalmente sta a significare che \u00e8 necessario invertire il \"dir_pin\" del l'asse. Questo viene fatto aggiungendo un istruzione '!' alla \"dir_pin\" nel file di configurazione della stampante (o rimuovendolo se ne esiste gi\u00e0 presente). Se il motore passo-passo si muove di pi\u00f9 o di meno di un millimetro, verificare l'impostazione \"rotation_distance\". Eseguire il test sopra descritto per ogni motore passo-passo definito nel file di configurazione. (Impostare il parametro STEPPER del comando STEPPER_BUZZ sul nome della sezione di configurazione da testare.) Se non \u00e8 presente il filamento nell'estrusore, \u00e8 possibile utilizzare STEPPER_BUZZ per verificare la connessione del motore dell'estrusore (usare STEPPER=estrusore). In caso contrario, \u00e8 meglio testare il motore dell'estrusore per conto suo (vedere la sezione successiva). Dopo aver verificato tutti i finecorsa e aver verificato tutti i motori passo-passo, \u00e8 necessario testare il sistema di homing. Scrivere un comando G28 per portare a home tutti gli assi. Rimuovere l'alimentazione dalla stampante se l'istruzione non funziona correttamente. Se necessario, ripetere i passaggi di verifica del finecorsa e del motore passo-passo.","title":"Verifica dei motori passo-passo"},{"location":"Config_checks.html#verifica-il-motore-dellestrusore","text":"To test the extruder motor it will be necessary to heat the extruder to a printing temperature. Navigate to the temperature graph section and select a target temperature from the temperature drop-down box (or manually enter an appropriate temperature). Wait for the printer to reach the desired temperature. Then navigate to the command console and click the \"Extrude\" button. Verify that the extruder motor turns in the correct direction. If it does not, see the troubleshooting tips in the previous section to confirm the \"enable_pin\", \"step_pin\", and \"dir_pin\" settings for the extruder.","title":"Verifica il motore dell'estrusore"},{"location":"Config_checks.html#calibrare-le-impostazioni-del-pid","text":"Klipper supporta il sistema controllo PID per iriscaldatori dell'estrusore e del piatto. Per utilizzare questo sistema di controllo, \u00e8 necessario calibrare le impostazioni PID su ciascuna stampante (le impostazioni PID presenti in altri firmware o nei file di configurazione di esempio spesso funzionano male). To calibrate the extruder, navigate to the command console and run the PID_CALIBRATE command. For example: PID_CALIBRATE HEATER=extruder TARGET=170 Al termine del test di ottimizzazione, eseguire l'istruzione SAVE_CONFIG per aggiornare il file printer.cfg con le nuove impostazioni PID. Se la stampante ha un piatto riscaldato ed \u00e8 dotato di azionamento con funzione PWM (Pulse Width Modulation), si consiglia di utilizzare il controllo PID anche per il piatto. (Quando il riscaldatore del piatto \u00e8 controllato utilizzando l'algoritmo PID, potrebbe accendersi e spegnersi dieci volte al secondo, il che potrebbe non essere adatto per i riscaldatori che utilizzano un rel\u00e8 elettromeccanico.) Un tipico comando per calibrazione PID del piatto \u00e8: PID_CALIBRATE HEATER=heater_bed TARGET= 60","title":"Calibrare le impostazioni del PID"},{"location":"Config_checks.html#passi-sucessivi","text":"Questa guida ha lo scopo di aiutare la verifica delle impostazioni di base riferite ai pin presenti nel file di configurazione di Klipper. Assicurati di leggere la guida bed leveling . Consulta anche il documento Slicers per informazioni sulla configurazione di un software slicer con Klipper. Dopo aver verificato che la stampa di base funziona, \u00e8 una buona prassi procedere con la calibrazione avanzamento pressione . Potrebbe essere necessario eseguire altri tipi di calibrazione di dettaglio in riferimento alla stampante: sono disponibili numerose guide online per questo scopo (ad esempio, eseguire una ricerca sul Web per \"calibrazione della stampante 3d\"). Ad esempio, se si verifica l'effetto chiamato risonanza, \u00e8 possibile provare a seguire la calibrazione tramite l'istruzione compensazione della risonanza .","title":"Passi sucessivi"},{"location":"Contact.html","text":"Contatti \u00b6 Questo documento fornisce informazioni di contatto per Klipper. Forum della comunit\u00e0 Chat Discord Ho una domanda su Klipper Ho una richiesta per una funzionalit\u00e0 Aiuto! Non funziona! I found a bug in the Klipper software Sto apportando modifiche che vorrei includere in Klipper Klipper github Forum della Comunit\u00e0 \u00b6 C'\u00e8 un server Klipper Community Discourse server per discussioni su Klipper. Chat Discord \u00b6 C'\u00e8 un serve Discord dedicato a Klipper a: https://discord.klipper3d.org . Questo server \u00e8 gestito da una comunit\u00e0 di appassionati di Klipper dediti alle discussioni su Klipper. Consente agli utenti di chattare con altri utenti in tempo reale. Ho una domanda su Klipper \u00b6 Molte domande che riceviamo hanno gi\u00e0 una risposta nella Klipper documentation . Per favore assicurati di leggere la documentazione e di seguire le indicazioni fornite. \u00c8 anche possibile cercare domande simili nel Klipper Community Forum . Se sei interessato a condividere le tue conoscenze ed esperienze con altri utenti di Klipper, puoi unirti al Klipper Community Forum o Klipper Discord Chat . Entrambe sono comunit\u00e0 in cui gli utenti di Klipper possono discutere di Klipper con altri utenti. Molte domande che riceviamo sono domande generiche sulla stampa 3D che non sono specifiche di Klipper. Se hai una domanda generica o stai riscontrando problemi di stampa generici, probabilmente otterrai una risposta migliore chiedendo in un forum generale sulla stampa 3D o in un forum dedicato all'hardware della tua stampante. Ho una richiesta per una funzionalit\u00e0 \u00b6 Tutte le nuove funzionalit\u00e0 richiedono qualcuno interessato e in grado di implementare tale funzionalit\u00e0. Se sei interessato ad aiutare a implementare o testare una nuova funzionalit\u00e0, puoi cercare gli sviluppi coinvolti nel Klipper Community Forum . C'\u00e8 anche Klipper Discord Chat per le discussioni tra i collaboratori. Aiuto! Non funziona! \u00b6 Sfortunatamente, riceviamo molte pi\u00f9 richieste di aiuto di quante potremmo eventualmente rispondere. La maggior parte delle segnalazioni di problemi che vediamo vengono infine rintracciate in: Piccoli nell'hardware, o Non seguendo tutti i passaggi descritti nella documentazione di Klipper. In caso di problemi, ti consigliamo di leggere attentamente la Klipper documentation e di verificare che tutti i passaggi siano stati seguiti. Se si verifica un problema di stampa, si consiglia di ispezionare attentamente l'hardware della stampante (tutti i giunti, i cavi, le viti, ecc.) e verificare che non vi siano anomalie. Scopriamo che la maggior parte dei problemi di stampa non sono correlati al software Klipper. Se trovi un problema con l'hardware della stampante, probabilmente otterrai una risposta migliore cercando in un forum generale di stampa 3D o in un forum dedicato all'hardware della tua stampante. \u00c8 anche possibile cercare problemi simili in Klipper Community Forum . Se sei interessato a condividere le tue conoscenze ed esperienze con altri utenti di Klipper, puoi unirti al Klipper Community Forum o Klipper Discord Chat . Entrambe sono comunit\u00e0 in cui gli utenti di Klipper possono discutere di Klipper con altri utenti. Ho trovato un bug nel software Klipper \u00b6 Klipper \u00e8 un progetto open-source ed apprezziamo quando i collaboratori diagnosticano errori nel software. I problemi devono essere segnalati nel Klipper Community Forum . Ci sono informazioni importanti che saranno necessarie per correggere un bug. Per favore segui questi passaggi: Assicurati di eseguire codice non modificato da https://github.com/Klipper3d/klipper . Se il codice \u00e8 stato modificato o \u00e8 stato ottenuto da un'altra fonte, \u00e8 necessario riprodurre il problema sul codice non modificato da https://github.com/Klipper3d/klipper prima della segnalazione. Se possibile, eseguire un comando M112 immediatamente dopo che si \u00e8 verificato l'evento indesiderato. Ci\u00f2 fa s\u00ec che Klipper entri in uno \"shutdown state\" e causer\u00e0 la scrittura di ulteriori informazioni di debug nel file di registro. Ottieni il log file di Klipper dell'evento. Il file di registro \u00e8 stato progettato per rispondere alle domande pi\u00f9 comuni degli sviluppatori di Klipper sul software e sul suo ambiente (versione del software, tipo di hardware, configurazione, tempistica degli eventi e centinaia di altre domande). Il log file di Klipper si trova in /tmp/klippy.log sul computer \"host\" di Klipper (il Raspberry Pi). Un comando o utility \"scp\" o \"sftp\" \u00e8 necessario per copiare questo file di registro sul computer desktop. L'utilit\u00e0 \"scp\" viene fornita di serie con i desktop Linux e MacOS. Ci sono utilit\u00e0 scp disponibili gratuitamente per altri desktop (ad es. WinSCP). Se si utilizza un'interfaccia grafica scp che non pu\u00f2 copiare direttamente /tmp/klippy.log , fare clic ripetutamente su .. o cartella principale fino ad arrivare alla directory principale, fare clic sulla cartella tmp , quindi seleziona il file klippy.log . Copia il lof file sul desktop in modo che possa essere allegato a una segnalazione di problema. Non modificare in alcun modo il log file; non editare o ritagliare il log file. Solo il file di log completo non modificato fornisce le informazioni necessarie. \u00c8 una buona idea comprimere il file di registro con zip o gzip. Apri un nuovo topic sul Klipper Community Forum e fornisci una descrizione chiara del problema. Altri contributori di Klipper dovranno capire quali passi sono stati compiuti, quale era il risultato desiderato e quale risultato si \u00e8 effettivamente verificato. Il file di registro compresso di Klipper dovrebbe essere allegato a quel topic. Sto apportando modifiche che vorrei includere in Klipper \u00b6 Klipper \u00e8 un software open-source e apprezziamo i nuovi contributi. I nuovi contributi (sia per il codice che per la documentazione) vengono inviati tramite Github Pull Requests. Vedere [ CONTRIBUTING document per informazioni importanti. Ci sono diversi documenti per sviluppatori . Se hai domande sul codice, puoi anche chiedere nel Klipper Community Forum o nella Klipper Community Discord . Klipper github \u00b6 Klipper github pu\u00f2 essere utilizzato dai contributori per condividere lo stato del loro lavoro per migliorare Klipper. Ci si aspetta che la persona che apre un ticket github stia lavorando attivamente all'attivit\u00e0 specificata e sar\u00e0 quella che eseguir\u00e0 tutto il lavoro necessario per realizzarla. Il github di Klipper non viene utilizzato per richieste, n\u00e9 per segnalare bug, n\u00e9 per porre domande. Usa invece il Klipper Community Forum o la Klipper Community Discord .","title":"Contatti"},{"location":"Contact.html#contatti","text":"Questo documento fornisce informazioni di contatto per Klipper. Forum della comunit\u00e0 Chat Discord Ho una domanda su Klipper Ho una richiesta per una funzionalit\u00e0 Aiuto! Non funziona! I found a bug in the Klipper software Sto apportando modifiche che vorrei includere in Klipper Klipper github","title":"Contatti"},{"location":"Contact.html#forum-della-comunita","text":"C'\u00e8 un server Klipper Community Discourse server per discussioni su Klipper.","title":"Forum della Comunit\u00e0"},{"location":"Contact.html#chat-discord","text":"C'\u00e8 un serve Discord dedicato a Klipper a: https://discord.klipper3d.org . Questo server \u00e8 gestito da una comunit\u00e0 di appassionati di Klipper dediti alle discussioni su Klipper. Consente agli utenti di chattare con altri utenti in tempo reale.","title":"Chat Discord"},{"location":"Contact.html#ho-una-domanda-su-klipper","text":"Molte domande che riceviamo hanno gi\u00e0 una risposta nella Klipper documentation . Per favore assicurati di leggere la documentazione e di seguire le indicazioni fornite. \u00c8 anche possibile cercare domande simili nel Klipper Community Forum . Se sei interessato a condividere le tue conoscenze ed esperienze con altri utenti di Klipper, puoi unirti al Klipper Community Forum o Klipper Discord Chat . Entrambe sono comunit\u00e0 in cui gli utenti di Klipper possono discutere di Klipper con altri utenti. Molte domande che riceviamo sono domande generiche sulla stampa 3D che non sono specifiche di Klipper. Se hai una domanda generica o stai riscontrando problemi di stampa generici, probabilmente otterrai una risposta migliore chiedendo in un forum generale sulla stampa 3D o in un forum dedicato all'hardware della tua stampante.","title":"Ho una domanda su Klipper"},{"location":"Contact.html#ho-una-richiesta-per-una-funzionalita","text":"Tutte le nuove funzionalit\u00e0 richiedono qualcuno interessato e in grado di implementare tale funzionalit\u00e0. Se sei interessato ad aiutare a implementare o testare una nuova funzionalit\u00e0, puoi cercare gli sviluppi coinvolti nel Klipper Community Forum . C'\u00e8 anche Klipper Discord Chat per le discussioni tra i collaboratori.","title":"Ho una richiesta per una funzionalit\u00e0"},{"location":"Contact.html#aiuto-non-funziona","text":"Sfortunatamente, riceviamo molte pi\u00f9 richieste di aiuto di quante potremmo eventualmente rispondere. La maggior parte delle segnalazioni di problemi che vediamo vengono infine rintracciate in: Piccoli nell'hardware, o Non seguendo tutti i passaggi descritti nella documentazione di Klipper. In caso di problemi, ti consigliamo di leggere attentamente la Klipper documentation e di verificare che tutti i passaggi siano stati seguiti. Se si verifica un problema di stampa, si consiglia di ispezionare attentamente l'hardware della stampante (tutti i giunti, i cavi, le viti, ecc.) e verificare che non vi siano anomalie. Scopriamo che la maggior parte dei problemi di stampa non sono correlati al software Klipper. Se trovi un problema con l'hardware della stampante, probabilmente otterrai una risposta migliore cercando in un forum generale di stampa 3D o in un forum dedicato all'hardware della tua stampante. \u00c8 anche possibile cercare problemi simili in Klipper Community Forum . Se sei interessato a condividere le tue conoscenze ed esperienze con altri utenti di Klipper, puoi unirti al Klipper Community Forum o Klipper Discord Chat . Entrambe sono comunit\u00e0 in cui gli utenti di Klipper possono discutere di Klipper con altri utenti.","title":"Aiuto! Non funziona!"},{"location":"Contact.html#ho-trovato-un-bug-nel-software-klipper","text":"Klipper \u00e8 un progetto open-source ed apprezziamo quando i collaboratori diagnosticano errori nel software. I problemi devono essere segnalati nel Klipper Community Forum . Ci sono informazioni importanti che saranno necessarie per correggere un bug. Per favore segui questi passaggi: Assicurati di eseguire codice non modificato da https://github.com/Klipper3d/klipper . Se il codice \u00e8 stato modificato o \u00e8 stato ottenuto da un'altra fonte, \u00e8 necessario riprodurre il problema sul codice non modificato da https://github.com/Klipper3d/klipper prima della segnalazione. Se possibile, eseguire un comando M112 immediatamente dopo che si \u00e8 verificato l'evento indesiderato. Ci\u00f2 fa s\u00ec che Klipper entri in uno \"shutdown state\" e causer\u00e0 la scrittura di ulteriori informazioni di debug nel file di registro. Ottieni il log file di Klipper dell'evento. Il file di registro \u00e8 stato progettato per rispondere alle domande pi\u00f9 comuni degli sviluppatori di Klipper sul software e sul suo ambiente (versione del software, tipo di hardware, configurazione, tempistica degli eventi e centinaia di altre domande). Il log file di Klipper si trova in /tmp/klippy.log sul computer \"host\" di Klipper (il Raspberry Pi). Un comando o utility \"scp\" o \"sftp\" \u00e8 necessario per copiare questo file di registro sul computer desktop. L'utilit\u00e0 \"scp\" viene fornita di serie con i desktop Linux e MacOS. Ci sono utilit\u00e0 scp disponibili gratuitamente per altri desktop (ad es. WinSCP). Se si utilizza un'interfaccia grafica scp che non pu\u00f2 copiare direttamente /tmp/klippy.log , fare clic ripetutamente su .. o cartella principale fino ad arrivare alla directory principale, fare clic sulla cartella tmp , quindi seleziona il file klippy.log . Copia il lof file sul desktop in modo che possa essere allegato a una segnalazione di problema. Non modificare in alcun modo il log file; non editare o ritagliare il log file. Solo il file di log completo non modificato fornisce le informazioni necessarie. \u00c8 una buona idea comprimere il file di registro con zip o gzip. Apri un nuovo topic sul Klipper Community Forum e fornisci una descrizione chiara del problema. Altri contributori di Klipper dovranno capire quali passi sono stati compiuti, quale era il risultato desiderato e quale risultato si \u00e8 effettivamente verificato. Il file di registro compresso di Klipper dovrebbe essere allegato a quel topic.","title":"Ho trovato un bug nel software Klipper"},{"location":"Contact.html#sto-apportando-modifiche-che-vorrei-includere-in-klipper","text":"Klipper \u00e8 un software open-source e apprezziamo i nuovi contributi. I nuovi contributi (sia per il codice che per la documentazione) vengono inviati tramite Github Pull Requests. Vedere [ CONTRIBUTING document per informazioni importanti. Ci sono diversi documenti per sviluppatori . Se hai domande sul codice, puoi anche chiedere nel Klipper Community Forum o nella Klipper Community Discord .","title":"Sto apportando modifiche che vorrei includere in Klipper"},{"location":"Contact.html#klipper-github","text":"Klipper github pu\u00f2 essere utilizzato dai contributori per condividere lo stato del loro lavoro per migliorare Klipper. Ci si aspetta che la persona che apre un ticket github stia lavorando attivamente all'attivit\u00e0 specificata e sar\u00e0 quella che eseguir\u00e0 tutto il lavoro necessario per realizzarla. Il github di Klipper non viene utilizzato per richieste, n\u00e9 per segnalare bug, n\u00e9 per porre domande. Usa invece il Klipper Community Forum o la Klipper Community Discord .","title":"Klipper github"},{"location":"Debugging.html","text":"Debugging \u00b6 Questo documento descrive alcuni degli strumenti di debug di Klipper. Esecuzione dei test di regressione \u00b6 Il repository principale di Klipper GitHub utilizza \"github actions\" per eseguire una serie di test di regressione. Pu\u00f2 essere utile eseguire alcuni di questi test in locale. Il sorgente \"controllo spazi bianchi\" pu\u00f2 essere eseguito con: ./scripts/check_whitespace.sh La suite di test di regressione Klippy richiede \"dizionari di dati\" da molte piattaforme. Il modo pi\u00f9 semplice per ottenerli \u00e8 scaricarli da github . Una volta scaricati i dizionari di dati, utilizzare quanto segue per eseguire la suite di regressione: tar xfz klipper-dict-20??????.tar.gz ~/klippy-env/bin/python ~/klipper/scripts/test_klippy.py -d dict/ ~/klipper/test/klippy/*.test Invio manuale di comandi al microcontrollore \u00b6 Normalmente, il processo host klippy.py verrebbe utilizzato per tradurre i comandi gcode in comandi del microcontrollore Klipper. Tuttavia, \u00e8 anche possibile inviare manualmente questi comandi MCU (funzioni contrassegnate con la macro DECL_COMMAND() nel codice sorgente di Klipper). Per farlo, esegui: ~/klippy-env/bin/python ./klippy/console.py /tmp/pseudoserial Vedere il comando \"HELP\" all'interno dello strumento per ulteriori informazioni sulla sua funzionalit\u00e0. Sono disponibili alcune opzioni della riga di comando. Per ulteriori informazioni esegui: ~/klippy-env/bin/python ./klippy/console.py --help Traduzione di file gcode in comandi del microcontrollore \u00b6 Il codice host Klippy pu\u00f2 essere eseguito in modalit\u00e0 batch per produrre i comandi del microcontrollore di basso livello associati a un file gcode. L'ispezione di questi comandi di basso livello \u00e8 utile quando si cerca di comprendere le azioni dell'hardware di basso livello. Pu\u00f2 anche essere utile confrontare la differenza nei comandi del microcontrollore dopo una modifica del codice. Per eseguire Klippy in questa modalit\u00e0 batch, \u00e8 necessario un passaggio per generare il \"dizionario dati\" del microcontrollore. Questo viene fatto compilando il codice del microcontrollore per ottenere il file out/klipper.dict : make menuconfig make Una volta fatto quanto sopra \u00e8 possibile eseguire Klipper in modalit\u00e0 batch (vedi installazione per i passaggi necessari per costruire l'ambiente virtuale python e un file printer.cfg): ~/klippy-env/bin/python ./klippy/klippy.py ~/printer.cfg -i test.gcode -o test.serial -v -d out/klipper.dict Quanto sopra produrr\u00e0 un file test.serial con output seriale binario. Questo output pu\u00f2 essere tradotto in testo leggibile con: ~/klippy-env/bin/python ./klippy/parsedump.py out/klipper.dict test.serial > test.txt Il file risultante test.txt contiene un elenco leggibile di comandi del microcontrollore. La modalit\u00e0 batch disabilita alcuni comandi di risposta/richiesta per funzionare. Di conseguenza, ci saranno alcune differenze tra i comandi effettivi e l'output sopra. I dati generati sono utili per il test e l'ispezione; non \u00e8 utile per l'invio a un vero microcontrollore. Analisi del movimento e registrazione dei dati \u00b6 Klipper supporta la registrazione della cronologia dei movimenti interni, che pu\u00f2 essere analizzata in seguito. Per utilizzare questa funzione, Klipper deve essere avviato con Server API abilitato. La registrazione dei dati \u00e8 abilitata con lo strumento data_logger.py . Per esempio: ~/klipper/scripts/motan/data_logger.py /tmp/klippy_uds mylog Questo comando si collegher\u00e0 al Klipper API Server, sottoscriver\u00e0 le informazioni sullo stato e sul movimento e registrer\u00e0 i risultati. Vengono generati due file: un file di dati compresso e un file di indice (ad esempio, mylog.json.gz e mylog.index.gz ). Dopo aver avviato la registrazione, \u00e8 possibile completare le stampe e altre azioni: la registrazione continuer\u00e0 in background. Al termine della registrazione, premi ctrl-c per uscire dallo strumento data_logger.py . I file risultanti possono essere letti e rappresentati graficamente utilizzando lo strumento motan_graph.py . Per generare grafici su un Raspberry Pi, \u00e8 necessario un passaggio per installare il pacchetto \"matplotlib\": sudo apt-get update sudo apt-get install python-matplotlib Tuttavia, potrebbe essere pi\u00f9 conveniente copiare i file di dati su una macchina di classe desktop insieme al codice Python nella directory scripts/motan/ . Gli script di analisi del movimento dovrebbero essere eseguiti su qualsiasi macchina con una versione recente di Python e Matplotlib installata. I grafici possono essere generati con un comando come il seguente: ~/klipper/scripts/motan/motan_graph.py mylog -o mygraph.png One can use the -g option to specify the datasets to graph (it takes a Python literal containing a list of lists). For example: ~/klipper/scripts/motan/motan_graph.py mylog -g '[[\"trapq(toolhead,velocity)\"], [\"trapq(toolhead,accel)\"]]' L'elenco dei set di dati disponibili pu\u00f2 essere trovato usando l'opzione -l , ad esempio: ~/klipper/scripts/motan/motan_graph.py -l \u00c8 anche possibile specificare le opzioni di stampa matplotlib per ogni set di dati: ~/klipper/scripts/motan/motan_graph.py mylog -g '[[\"trapq(toolhead,velocity)?color=red&alpha=0.4\"]]' Sono disponibili molte opzioni di matplotlib; alcuni esempi sono \"color\", \"label\", \"alpha\" e \"linestyle\". Lo strumento motan_graph.py supporta molte altre opzioni della riga di comando: usa l'opzione --help per vedere un elenco. Pu\u00f2 anche essere conveniente visualizzare/modificare lo stesso script motan_graph.py . I log di dati grezzi prodotti dallo strumento data_logger.py seguono il formato descritto in Server API . Pu\u00f2 essere utile ispezionare i dati con un comando Unix come il seguente: gunzip < mylog.json.gz | tr '\\03' '\\n' | less Generare di grafici di carico \u00b6 Il file di registro di Klippy (/tmp/klippy.log) memorizza le statistiche sulla larghezza di banda, sul carico del microcontrollore e sul carico del buffer dell'host. Pu\u00f2 essere utile rappresentare graficamente queste statistiche dopo una stampa. Per generare un grafico, \u00e8 necessario un passaggio una tantum per installare il pacchetto \"matplotlib\": sudo apt-get update sudo apt-get install python-matplotlib Quindi i grafici possono essere prodotti con: ~/klipper/scripts/graphstats.py /tmp/klippy.log -o loadgraph.png Si pu\u00f2 quindi visualizzare il file loadgraph.png risultante. Possono essere prodotti diversi grafici. Per ulteriori informazioni esegui: ~/klipper/scripts/graphstats.py --help Estrazione di informazioni dal file klippy.log \u00b6 Anche il file di registro di Klippy (/tmp/klippy.log) contiene informazioni di debug. Esiste uno script logextract.py che pu\u00f2 essere utile quando si analizza l'arresto di un microcontrollore o un problema simile. In genere viene eseguito con qualcosa come: mkdir work_directory cd work_directory cp /tmp/klippy.log . ~/klipper/scripts/logextract.py ./klippy.log Lo script estrarr\u00e0 il file di configurazione della stampante ed estrarr\u00e0 le informazioni di arresto dell'MCU. I dump delle informazioni da un arresto dell'MCU (se presente) verranno riordinati in base al timestamp per facilitare la diagnosi degli scenari di causa ed effetto. Test con simulavr \u00b6 Lo strumento simulavr consente di simulare un microcontrollore Atmel ATmega. Questa sezione descrive come eseguire test di file gcode tramite simulavr. Si consiglia di eseguirlo su una macchina di classe desktop (non un Raspberry Pi) poich\u00e9 richiede una CPU significativa per funzionare in modo efficiente. Per utilizzare simulavr, scarica il pacchetto simulavr e compila con il supporto python. Nota che il sistema di build potrebbe aver bisogno di alcuni pacchetti (come swig) installati per costruire il modulo python. git clone git://git.savannah.nongnu.org/simulavr.git cd simulavr make python make build Assicurati che un file come ./build/pysimulavr/_pysimulavr.*.so sia presente dopo la compilazione di cui sopra: ls ./build/pysimulavr/_pysimulavr.*.so Questo comando dovrebbe segnalare un file specifico (ad esempio ./build/pysimulavr/_pysimulavr.cpython-39-x86_64-linux-gnu.so ) e non un errore. Se utilizzi un sistema basato su Debian (Debian, Ubuntu, ecc.) puoi installare i seguenti pacchetti e generare file *.deb per l'installazione di simulavr a livello di sistema: sudo apt update sudo apt install g++ make cmake swig rst2pdf help2man texinfo make cfgclean python debian sudo dpkg -i build/debian/python3-simulavr*.deb Per compilare Klipper per l'uso in simulavr, eseguire: cd /path/to/klipper make menuconfig e compilare il software del microcontrollore per un AVR atmega644p e selezionare il supporto per l'emulazione del software SIMULAVR. Quindi si pu\u00f2 compilare Klipper (eseguire make ) e quindi avviare la simulazione con: PYTHONPATH=/path/to/simulavr/build/pysimulavr/ ./scripts/avrsim.py out/klipper.elf Nota che se hai installato python3-simulavr a livello di sistema, non \u00e8 necessario impostare PYTHONPATH e puoi semplicemente eseguire il simulatore come ./scripts/avrsim.py out/klipper.elf Quindi, con simulavr in esecuzione in un'altra finestra, \u00e8 possibile eseguire quanto segue per leggere gcode da un file (ad es. \"test.gcode\"), elaborarlo con Klippy e inviarlo a Klipper in esecuzione in simulavr (vedere installazione per i passaggi necessari per costruire l'ambiente virtuale Python): ~/klippy-env/bin/python ./klippy/klippy.py config/generic-simulavr.cfg -i test.gcode -v Utilizzo di simulavr con gtkwave \u00b6 Una caratteristica utile di simulavr \u00e8 la sua capacit\u00e0 di creare file di generazione di onde di segnale con l'esatta sincronizzazione degli eventi. Per fare ci\u00f2, segui le istruzioni sopra, ma esegui avrsim.py con una riga di comando come la seguente: PYTHONPATH=/path/to/simulavr/src/python/ ./scripts/avrsim.py out/klipper.elf -t PORTA.PORT,PORTC.PORT Quanto sopra creerebbe un file avrsim.vcd con informazioni su ogni modifica ai GPIO su PORTA e PORTB. Questo potrebbe quindi essere visualizzato usando gtkwave con: gtkwave avrsim.vcd","title":"Debugging"},{"location":"Debugging.html#debugging","text":"Questo documento descrive alcuni degli strumenti di debug di Klipper.","title":"Debugging"},{"location":"Debugging.html#esecuzione-dei-test-di-regressione","text":"Il repository principale di Klipper GitHub utilizza \"github actions\" per eseguire una serie di test di regressione. Pu\u00f2 essere utile eseguire alcuni di questi test in locale. Il sorgente \"controllo spazi bianchi\" pu\u00f2 essere eseguito con: ./scripts/check_whitespace.sh La suite di test di regressione Klippy richiede \"dizionari di dati\" da molte piattaforme. Il modo pi\u00f9 semplice per ottenerli \u00e8 scaricarli da github . Una volta scaricati i dizionari di dati, utilizzare quanto segue per eseguire la suite di regressione: tar xfz klipper-dict-20??????.tar.gz ~/klippy-env/bin/python ~/klipper/scripts/test_klippy.py -d dict/ ~/klipper/test/klippy/*.test","title":"Esecuzione dei test di regressione"},{"location":"Debugging.html#invio-manuale-di-comandi-al-microcontrollore","text":"Normalmente, il processo host klippy.py verrebbe utilizzato per tradurre i comandi gcode in comandi del microcontrollore Klipper. Tuttavia, \u00e8 anche possibile inviare manualmente questi comandi MCU (funzioni contrassegnate con la macro DECL_COMMAND() nel codice sorgente di Klipper). Per farlo, esegui: ~/klippy-env/bin/python ./klippy/console.py /tmp/pseudoserial Vedere il comando \"HELP\" all'interno dello strumento per ulteriori informazioni sulla sua funzionalit\u00e0. Sono disponibili alcune opzioni della riga di comando. Per ulteriori informazioni esegui: ~/klippy-env/bin/python ./klippy/console.py --help","title":"Invio manuale di comandi al microcontrollore"},{"location":"Debugging.html#traduzione-di-file-gcode-in-comandi-del-microcontrollore","text":"Il codice host Klippy pu\u00f2 essere eseguito in modalit\u00e0 batch per produrre i comandi del microcontrollore di basso livello associati a un file gcode. L'ispezione di questi comandi di basso livello \u00e8 utile quando si cerca di comprendere le azioni dell'hardware di basso livello. Pu\u00f2 anche essere utile confrontare la differenza nei comandi del microcontrollore dopo una modifica del codice. Per eseguire Klippy in questa modalit\u00e0 batch, \u00e8 necessario un passaggio per generare il \"dizionario dati\" del microcontrollore. Questo viene fatto compilando il codice del microcontrollore per ottenere il file out/klipper.dict : make menuconfig make Una volta fatto quanto sopra \u00e8 possibile eseguire Klipper in modalit\u00e0 batch (vedi installazione per i passaggi necessari per costruire l'ambiente virtuale python e un file printer.cfg): ~/klippy-env/bin/python ./klippy/klippy.py ~/printer.cfg -i test.gcode -o test.serial -v -d out/klipper.dict Quanto sopra produrr\u00e0 un file test.serial con output seriale binario. Questo output pu\u00f2 essere tradotto in testo leggibile con: ~/klippy-env/bin/python ./klippy/parsedump.py out/klipper.dict test.serial > test.txt Il file risultante test.txt contiene un elenco leggibile di comandi del microcontrollore. La modalit\u00e0 batch disabilita alcuni comandi di risposta/richiesta per funzionare. Di conseguenza, ci saranno alcune differenze tra i comandi effettivi e l'output sopra. I dati generati sono utili per il test e l'ispezione; non \u00e8 utile per l'invio a un vero microcontrollore.","title":"Traduzione di file gcode in comandi del microcontrollore"},{"location":"Debugging.html#analisi-del-movimento-e-registrazione-dei-dati","text":"Klipper supporta la registrazione della cronologia dei movimenti interni, che pu\u00f2 essere analizzata in seguito. Per utilizzare questa funzione, Klipper deve essere avviato con Server API abilitato. La registrazione dei dati \u00e8 abilitata con lo strumento data_logger.py . Per esempio: ~/klipper/scripts/motan/data_logger.py /tmp/klippy_uds mylog Questo comando si collegher\u00e0 al Klipper API Server, sottoscriver\u00e0 le informazioni sullo stato e sul movimento e registrer\u00e0 i risultati. Vengono generati due file: un file di dati compresso e un file di indice (ad esempio, mylog.json.gz e mylog.index.gz ). Dopo aver avviato la registrazione, \u00e8 possibile completare le stampe e altre azioni: la registrazione continuer\u00e0 in background. Al termine della registrazione, premi ctrl-c per uscire dallo strumento data_logger.py . I file risultanti possono essere letti e rappresentati graficamente utilizzando lo strumento motan_graph.py . Per generare grafici su un Raspberry Pi, \u00e8 necessario un passaggio per installare il pacchetto \"matplotlib\": sudo apt-get update sudo apt-get install python-matplotlib Tuttavia, potrebbe essere pi\u00f9 conveniente copiare i file di dati su una macchina di classe desktop insieme al codice Python nella directory scripts/motan/ . Gli script di analisi del movimento dovrebbero essere eseguiti su qualsiasi macchina con una versione recente di Python e Matplotlib installata. I grafici possono essere generati con un comando come il seguente: ~/klipper/scripts/motan/motan_graph.py mylog -o mygraph.png One can use the -g option to specify the datasets to graph (it takes a Python literal containing a list of lists). For example: ~/klipper/scripts/motan/motan_graph.py mylog -g '[[\"trapq(toolhead,velocity)\"], [\"trapq(toolhead,accel)\"]]' L'elenco dei set di dati disponibili pu\u00f2 essere trovato usando l'opzione -l , ad esempio: ~/klipper/scripts/motan/motan_graph.py -l \u00c8 anche possibile specificare le opzioni di stampa matplotlib per ogni set di dati: ~/klipper/scripts/motan/motan_graph.py mylog -g '[[\"trapq(toolhead,velocity)?color=red&alpha=0.4\"]]' Sono disponibili molte opzioni di matplotlib; alcuni esempi sono \"color\", \"label\", \"alpha\" e \"linestyle\". Lo strumento motan_graph.py supporta molte altre opzioni della riga di comando: usa l'opzione --help per vedere un elenco. Pu\u00f2 anche essere conveniente visualizzare/modificare lo stesso script motan_graph.py . I log di dati grezzi prodotti dallo strumento data_logger.py seguono il formato descritto in Server API . Pu\u00f2 essere utile ispezionare i dati con un comando Unix come il seguente: gunzip < mylog.json.gz | tr '\\03' '\\n' | less","title":"Analisi del movimento e registrazione dei dati"},{"location":"Debugging.html#generare-di-grafici-di-carico","text":"Il file di registro di Klippy (/tmp/klippy.log) memorizza le statistiche sulla larghezza di banda, sul carico del microcontrollore e sul carico del buffer dell'host. Pu\u00f2 essere utile rappresentare graficamente queste statistiche dopo una stampa. Per generare un grafico, \u00e8 necessario un passaggio una tantum per installare il pacchetto \"matplotlib\": sudo apt-get update sudo apt-get install python-matplotlib Quindi i grafici possono essere prodotti con: ~/klipper/scripts/graphstats.py /tmp/klippy.log -o loadgraph.png Si pu\u00f2 quindi visualizzare il file loadgraph.png risultante. Possono essere prodotti diversi grafici. Per ulteriori informazioni esegui: ~/klipper/scripts/graphstats.py --help","title":"Generare di grafici di carico"},{"location":"Debugging.html#estrazione-di-informazioni-dal-file-klippylog","text":"Anche il file di registro di Klippy (/tmp/klippy.log) contiene informazioni di debug. Esiste uno script logextract.py che pu\u00f2 essere utile quando si analizza l'arresto di un microcontrollore o un problema simile. In genere viene eseguito con qualcosa come: mkdir work_directory cd work_directory cp /tmp/klippy.log . ~/klipper/scripts/logextract.py ./klippy.log Lo script estrarr\u00e0 il file di configurazione della stampante ed estrarr\u00e0 le informazioni di arresto dell'MCU. I dump delle informazioni da un arresto dell'MCU (se presente) verranno riordinati in base al timestamp per facilitare la diagnosi degli scenari di causa ed effetto.","title":"Estrazione di informazioni dal file klippy.log"},{"location":"Debugging.html#test-con-simulavr","text":"Lo strumento simulavr consente di simulare un microcontrollore Atmel ATmega. Questa sezione descrive come eseguire test di file gcode tramite simulavr. Si consiglia di eseguirlo su una macchina di classe desktop (non un Raspberry Pi) poich\u00e9 richiede una CPU significativa per funzionare in modo efficiente. Per utilizzare simulavr, scarica il pacchetto simulavr e compila con il supporto python. Nota che il sistema di build potrebbe aver bisogno di alcuni pacchetti (come swig) installati per costruire il modulo python. git clone git://git.savannah.nongnu.org/simulavr.git cd simulavr make python make build Assicurati che un file come ./build/pysimulavr/_pysimulavr.*.so sia presente dopo la compilazione di cui sopra: ls ./build/pysimulavr/_pysimulavr.*.so Questo comando dovrebbe segnalare un file specifico (ad esempio ./build/pysimulavr/_pysimulavr.cpython-39-x86_64-linux-gnu.so ) e non un errore. Se utilizzi un sistema basato su Debian (Debian, Ubuntu, ecc.) puoi installare i seguenti pacchetti e generare file *.deb per l'installazione di simulavr a livello di sistema: sudo apt update sudo apt install g++ make cmake swig rst2pdf help2man texinfo make cfgclean python debian sudo dpkg -i build/debian/python3-simulavr*.deb Per compilare Klipper per l'uso in simulavr, eseguire: cd /path/to/klipper make menuconfig e compilare il software del microcontrollore per un AVR atmega644p e selezionare il supporto per l'emulazione del software SIMULAVR. Quindi si pu\u00f2 compilare Klipper (eseguire make ) e quindi avviare la simulazione con: PYTHONPATH=/path/to/simulavr/build/pysimulavr/ ./scripts/avrsim.py out/klipper.elf Nota che se hai installato python3-simulavr a livello di sistema, non \u00e8 necessario impostare PYTHONPATH e puoi semplicemente eseguire il simulatore come ./scripts/avrsim.py out/klipper.elf Quindi, con simulavr in esecuzione in un'altra finestra, \u00e8 possibile eseguire quanto segue per leggere gcode da un file (ad es. \"test.gcode\"), elaborarlo con Klippy e inviarlo a Klipper in esecuzione in simulavr (vedere installazione per i passaggi necessari per costruire l'ambiente virtuale Python): ~/klippy-env/bin/python ./klippy/klippy.py config/generic-simulavr.cfg -i test.gcode -v","title":"Test con simulavr"},{"location":"Debugging.html#utilizzo-di-simulavr-con-gtkwave","text":"Una caratteristica utile di simulavr \u00e8 la sua capacit\u00e0 di creare file di generazione di onde di segnale con l'esatta sincronizzazione degli eventi. Per fare ci\u00f2, segui le istruzioni sopra, ma esegui avrsim.py con una riga di comando come la seguente: PYTHONPATH=/path/to/simulavr/src/python/ ./scripts/avrsim.py out/klipper.elf -t PORTA.PORT,PORTC.PORT Quanto sopra creerebbe un file avrsim.vcd con informazioni su ogni modifica ai GPIO su PORTA e PORTB. Questo potrebbe quindi essere visualizzato usando gtkwave con: gtkwave avrsim.vcd","title":"Utilizzo di simulavr con gtkwave"},{"location":"Delta_Calibrate.html","text":"Calibrazione delta \u00b6 Questo documento descrive il sistema di calibrazione automatica di Klipper per stampanti \"delta\". La calibrazione delta implica la ricerca delle posizioni dei finecorsa della torre, degli angoli della torre, del raggio delta e delle lunghezze del braccio delta. Queste impostazioni controllano il movimento della stampante su una stampante delta. Ognuno di questi parametri ha un impatto non evidente e non lineare ed \u00e8 difficile calibrarli manualmente. Al contrario, il codice di calibrazione del software pu\u00f2 fornire risultati eccellenti in pochi minuti di tempo. Non \u00e8 necessario alcun hardware di rilevamento speciale. In definitiva, la calibrazione delta dipende dalla precisione degli interruttori di fine corsa della torre. Se si utilizzano i driver per motori passo-passo Trinamic, considerare l'abilitazione del rilevamento fase endstop per migliorare la precisione di tali interruttori. Sonda automatica vs manuale \u00b6 Klipper supporta la calibrazione dei parametri delta tramite un metodo di sonda manuale o tramite una sonda Z automatica. Numerosi kit di stampanti delta sono dotati di sonde Z automatiche che non sono sufficientemente accurate (in particolare, piccole differenze nella lunghezza del braccio possono causare l'inclinazione dell'effettore che pu\u00f2 distorcere una sonda automatica). Se si utilizza una sonda automatica, prima calibrare la sonda e quindi verificare la presenza di un bias posizione sonda . Se la sonda automatica ha una polarizzazione superiore a 25 micron (0,025 mm), utilizzare invece la sonda manuale. Il probing manuale richiede solo pochi minuti ed elimina l'errore introdotto dalla sonda. Se si utilizza una sonda montata sul lato dell'hotend (ovvero ha un offset X o Y), tenere presente che l'esecuzione della calibrazione delta invalider\u00e0 i risultati della calibrazione della sonda. Questi tipi di sonde sono raramente adatti per l'uso su un delta (poich\u00e9 una minore inclinazione dell'effettore risulter\u00e0 in una distorsione della posizione della sonda). Se si utilizza comunque la sonda, assicurarsi di eseguire nuovamente la calibrazione della sonda dopo qualsiasi calibrazione delta. Calibrazione delta di base \u00b6 Klipper ha un comando DELTA_CALIBRATE che pu\u00f2 eseguire la calibrazione delta di base. Questo comando sonda sette diversi punti sul letto e calcola nuovi valori per gli angoli della torre, i punti terminali della torre e il raggio delta. Per eseguire questa calibrazione devono essere forniti i parametri delta iniziali (lunghezze dei bracci, raggio e posizioni dei finecorsa) e devono avere una precisione di pochi millimetri. La maggior parte dei kit della stampante delta fornisce questi parametri: configurare la stampante con queste impostazioni predefinite iniziali e quindi eseguire il comando DELTA_CALIBRATE come descritto di seguito. Se non sono disponibili impostazioni predefinite, cercare online una guida alla calibrazione delta che possa fornire un punto di partenza di base. Durante il processo di calibrazione delta potrebbe essere necessario che la stampante sondi al di sotto di quello che altrimenti sarebbe considerato il piano del piatto. \u00c8 tipico consentire ci\u00f2 durante la calibrazione aggiornando la configurazione in modo che minimum_z_position=-5 della stampante. (Una volta completata la calibrazione, \u00e8 possibile rimuovere questa impostazione dalla configurazione.) Ci sono due modi per eseguire la procedura: probing manuale ( DELTA_CALIBRATE METHOD=manual ) e automatica ( DELTA_CALIBRATE ). Il metodo di rilevamento manuale sposter\u00e0 la testa vicino al piatto e quindi attender\u00e0 che l'utente segua i passaggi descritti in \"test della carta\" per determinare la distanza effettiva tra l'ugello e letto nel luogo indicato. Per eseguire la misura di base, assicurati che la configurazione abbia una sezione [delta_calibrate] definita e quindi esegui lo strumento: G28 DELTA_CALIBRATE METHOD=manual Dopo aver sondato i sette punti verranno calcolati i nuovi parametri delta. Salva e applica questi parametri eseguendo: SAVE_CONFIG La calibrazione di base dovrebbe fornire parametri delta sufficientemente accurati per la stampa di base. Se si tratta di una nuova stampante, questo \u00e8 un buon momento per stampare alcuni oggetti di base e verificarne la funzionalit\u00e0 generale. Calibrazione delta migliorata \u00b6 La calibrazione delta di base generalmente fa un buon lavoro nel calcolo dei parametri delta in modo tale che l'ugello sia alla distanza corretta dal letto. Tuttavia, non tenta di calibrare la precisione dimensionale X e Y. \u00c8 una buona idea eseguire una calibrazione delta avanzata per verificare l'accuratezza dimensionale. Questa procedura di calibrazione richiede la stampa di un oggetto di prova e la misurazione di parti di tale oggetto di prova con un calibro digitale. Prima di eseguire una calibrazione delta avanzata, \u00e8 necessario eseguire la calibrazione delta di base (tramite il comando DELTA_CALIBRATE) e salvare i risultati (tramite il comando SAVE_CONFIG). Assicurati che non siano state apportate modifiche degne di nota alla configurazione della stampante n\u00e9 all'hardware dall'ultima esecuzione di una calibrazione delta di base (se non sei sicuro, esegui nuovamente la calibrazione delta di base , incluso SAVE_CONFIG, appena prima della stampa l'oggetto di prova descritto di seguito.) Usa uno slicer per generare il G-code dal file docs/prints/calibrate_size.stl . Estrudere l'oggetto a bassa velocit\u00e0 (ad es. 40 mm/s). Se possibile, usa una plastica rigida (come il PLA) per l'oggetto. L'oggetto ha un diametro di 140 mm. Se questo \u00e8 troppo grande per la stampante, \u00e8 possibile ridimensionarlo (ma assicurati di ridimensionare uniformemente entrambi gli assi X e Y). Se la stampante supporta stampe significativamente pi\u00f9 grandi, \u00e8 anche possibile aumentare le dimensioni di questo oggetto. Un formato pi\u00f9 grande pu\u00f2 migliorare la precisione della misurazione, ma una buona adesione di stampa \u00e8 pi\u00f9 importante di un formato di stampa pi\u00f9 grande. Stampa l'oggetto di prova e attendi che si raffreddi completamente. I comandi descritti di seguito devono essere eseguiti con le stesse impostazioni della stampante utilizzate per stampare l'oggetto di calibrazione (non eseguire DELTA_CALIBRATE tra la stampa e la misurazione, o fare qualcosa che altrimenti modificherebbe la configurazione della stampante). Se possibile, esegui le misurazioni descritte di seguito mentre l'oggetto \u00e8 ancora attaccato al piano di stampa, ma non preoccuparti se la parte si stacca dal letto: cerca solo di evitare di piegare l'oggetto durante l'esecuzione delle misurazioni. Inizia misurando la distanza tra il pilastro centrale e il pilastro accanto all'etichetta \"A\" (che dovrebbe anche puntare verso la torre \"A\"). Quindi procedere in senso antiorario e misurare le distanze tra il pilastro centrale e gli altri pilastri (distanza dal centro al pilastro attraverso l'etichetta C, distanza dal centro al pilastro con l'etichetta B, ecc.). Inserisci questi parametri in Klipper con un elenco separato da virgole di numeri in virgola mobile: DELTA_ANALYZE CENTER_DISTS=<a_dist>,<far_c_dist>,<b_dist>,<far_a_dist>,<c_dist>,<far_b_dist> Fornisci i valori senza spazi tra di loro. Quindi misurare la distanza tra il montante A e il montante di fronte all'etichetta C. Quindi andare in senso antiorario e misurare la distanza tra il pilastro di fronte a C e il pilastro B, la distanza tra il pilastro B e il pilastro di fronte a A, e cos\u00ec via. Inserisci questi parametri in Klipper: DELTA_ANALYZE OUTER_DISTS=<a_to_far_c>,<far_c_to_b>,<b_to_far_a>,<far_a_to_c>,<c_to_far_b>,<far_b_to_a> A questo punto va bene rimuovere l'oggetto dal letto. Le misure finali sono dei pilastri stessi. Misurare la dimensione del pilastro centrale lungo il raggio A, poi il raggio B e poi il raggio C. Inseriscili in Klipper: DELTA_ANALYZE CENTER_PILLAR_WIDTHS=<a>,<b>,<c> Le misure finali sono dei pilastri esterni. Inizia misurando la distanza del pilastro A lungo la linea da A al pilastro di fronte a C. Quindi andare in senso antiorario e misurare i restanti pilastri esterni (pilastro di fronte a C lungo la linea a B, pilastro B lungo la linea a pilastro di fronte ad A, ecc.). E inseriscili in Klipper: DELTA_ANALYZE OUTER_PILLAR_WIDTHS=<a>,<far_c>,<b>,<far_a>,<c>,<far_b> Se l'oggetto \u00e8 stato ridimensionato a una dimensione inferiore o superiore, fornire il fattore di scala utilizzato durante il taglio dell'oggetto: DELTA_ANALYZE SCALE=1.0 (Un valore di scala di 2,0 significherebbe che l'oggetto \u00e8 il doppio della sua dimensione originale, 0,5 sarebbe la met\u00e0 della sua dimensione originale.) Infine, esegui la calibrazione delta avanzata eseguendo: DELTA_ANALYZE CALIBRATE=extended Il completamento di questo comando pu\u00f2 richiedere diversi minuti. Dopo il completamento, calcoler\u00e0 i parametri delta aggiornati (raggio delta, angoli della torre, posizioni dei finecorsa e lunghezze dei bracci). Utilizzare il comando SAVE_CONFIG per salvare e applicare le impostazioni: SAVE_CONFIG Il comando SAVE_CONFIG salver\u00e0 sia i parametri delta aggiornati che le informazioni dalle misurazioni della distanza. Anche i futuri comandi DELTA_CALIBRATE utilizzeranno queste informazioni sulla distanza. Non tentare di reinserire le misurazioni grezze della distanza dopo aver eseguito SAVE_CONFIG, poich\u00e9 questo comando modifica la configurazione della stampante e le misurazioni grezze non vengono pi\u00f9 applicate. Note aggiuntive \u00b6 Se la stampante delta ha una buona precisione dimensionale, la distanza tra due pilastri qualsiasi dovrebbe essere di circa 74 mm e la larghezza di ogni pilastro dovrebbe essere di circa 9 mm. (In particolare, l'obiettivo \u00e8 che la distanza tra due pilastri qualsiasi meno la larghezza di uno dei pilastri sia esattamente 65 mm.) In caso di imprecisione dimensionale nella parte, la routine DELTA_ANALYZE calcoler\u00e0 nuovi parametri delta utilizzando entrambe le misurazioni della distanza e le misurazioni dell'altezza precedenti dall'ultimo comando DELTA_CALIBRATE. DELTA_ANALYZE pu\u00f2 produrre parametri delta sorprendenti. Ad esempio, pu\u00f2 suggerire lunghezze dei bracci che non corrispondono alle lunghezze effettive dei bracci della stampante. Nonostante ci\u00f2, i test hanno dimostrato che DELTA_ANALYZE produce spesso risultati superiori. Si ritiene che i parametri delta calcolati siano in grado di tenere conto di lievi errori in altre parti dell'hardware. Ad esempio, piccole differenze nella lunghezza del braccio possono comportare un'inclinazione dell'effettore e parte di tale inclinazione pu\u00f2 essere spiegata regolando i parametri della lunghezza del braccio. Utilizzo della mesh del piatto su un delta \u00b6 \u00c8 possibile utilizzare bed mesh su un delta. Tuttavia, \u00e8 importante ottenere una buona calibrazione delta prima di abilitare una mesh del letto. L'esecuzione della mesh del letto con una scarsa calibrazione delta comporter\u00e0 risultati confusi e scarsi. Si noti che l'esecuzione della calibrazione delta invalider\u00e0 qualsiasi mesh del piatto precedentemente ottenuto. Dopo aver eseguito una nuova calibrazione delta, assicurati di eseguire nuovamente BED_MESH_CALIBRATE.","title":"Calibrazione delta"},{"location":"Delta_Calibrate.html#calibrazione-delta","text":"Questo documento descrive il sistema di calibrazione automatica di Klipper per stampanti \"delta\". La calibrazione delta implica la ricerca delle posizioni dei finecorsa della torre, degli angoli della torre, del raggio delta e delle lunghezze del braccio delta. Queste impostazioni controllano il movimento della stampante su una stampante delta. Ognuno di questi parametri ha un impatto non evidente e non lineare ed \u00e8 difficile calibrarli manualmente. Al contrario, il codice di calibrazione del software pu\u00f2 fornire risultati eccellenti in pochi minuti di tempo. Non \u00e8 necessario alcun hardware di rilevamento speciale. In definitiva, la calibrazione delta dipende dalla precisione degli interruttori di fine corsa della torre. Se si utilizzano i driver per motori passo-passo Trinamic, considerare l'abilitazione del rilevamento fase endstop per migliorare la precisione di tali interruttori.","title":"Calibrazione delta"},{"location":"Delta_Calibrate.html#sonda-automatica-vs-manuale","text":"Klipper supporta la calibrazione dei parametri delta tramite un metodo di sonda manuale o tramite una sonda Z automatica. Numerosi kit di stampanti delta sono dotati di sonde Z automatiche che non sono sufficientemente accurate (in particolare, piccole differenze nella lunghezza del braccio possono causare l'inclinazione dell'effettore che pu\u00f2 distorcere una sonda automatica). Se si utilizza una sonda automatica, prima calibrare la sonda e quindi verificare la presenza di un bias posizione sonda . Se la sonda automatica ha una polarizzazione superiore a 25 micron (0,025 mm), utilizzare invece la sonda manuale. Il probing manuale richiede solo pochi minuti ed elimina l'errore introdotto dalla sonda. Se si utilizza una sonda montata sul lato dell'hotend (ovvero ha un offset X o Y), tenere presente che l'esecuzione della calibrazione delta invalider\u00e0 i risultati della calibrazione della sonda. Questi tipi di sonde sono raramente adatti per l'uso su un delta (poich\u00e9 una minore inclinazione dell'effettore risulter\u00e0 in una distorsione della posizione della sonda). Se si utilizza comunque la sonda, assicurarsi di eseguire nuovamente la calibrazione della sonda dopo qualsiasi calibrazione delta.","title":"Sonda automatica vs manuale"},{"location":"Delta_Calibrate.html#calibrazione-delta-di-base","text":"Klipper ha un comando DELTA_CALIBRATE che pu\u00f2 eseguire la calibrazione delta di base. Questo comando sonda sette diversi punti sul letto e calcola nuovi valori per gli angoli della torre, i punti terminali della torre e il raggio delta. Per eseguire questa calibrazione devono essere forniti i parametri delta iniziali (lunghezze dei bracci, raggio e posizioni dei finecorsa) e devono avere una precisione di pochi millimetri. La maggior parte dei kit della stampante delta fornisce questi parametri: configurare la stampante con queste impostazioni predefinite iniziali e quindi eseguire il comando DELTA_CALIBRATE come descritto di seguito. Se non sono disponibili impostazioni predefinite, cercare online una guida alla calibrazione delta che possa fornire un punto di partenza di base. Durante il processo di calibrazione delta potrebbe essere necessario che la stampante sondi al di sotto di quello che altrimenti sarebbe considerato il piano del piatto. \u00c8 tipico consentire ci\u00f2 durante la calibrazione aggiornando la configurazione in modo che minimum_z_position=-5 della stampante. (Una volta completata la calibrazione, \u00e8 possibile rimuovere questa impostazione dalla configurazione.) Ci sono due modi per eseguire la procedura: probing manuale ( DELTA_CALIBRATE METHOD=manual ) e automatica ( DELTA_CALIBRATE ). Il metodo di rilevamento manuale sposter\u00e0 la testa vicino al piatto e quindi attender\u00e0 che l'utente segua i passaggi descritti in \"test della carta\" per determinare la distanza effettiva tra l'ugello e letto nel luogo indicato. Per eseguire la misura di base, assicurati che la configurazione abbia una sezione [delta_calibrate] definita e quindi esegui lo strumento: G28 DELTA_CALIBRATE METHOD=manual Dopo aver sondato i sette punti verranno calcolati i nuovi parametri delta. Salva e applica questi parametri eseguendo: SAVE_CONFIG La calibrazione di base dovrebbe fornire parametri delta sufficientemente accurati per la stampa di base. Se si tratta di una nuova stampante, questo \u00e8 un buon momento per stampare alcuni oggetti di base e verificarne la funzionalit\u00e0 generale.","title":"Calibrazione delta di base"},{"location":"Delta_Calibrate.html#calibrazione-delta-migliorata","text":"La calibrazione delta di base generalmente fa un buon lavoro nel calcolo dei parametri delta in modo tale che l'ugello sia alla distanza corretta dal letto. Tuttavia, non tenta di calibrare la precisione dimensionale X e Y. \u00c8 una buona idea eseguire una calibrazione delta avanzata per verificare l'accuratezza dimensionale. Questa procedura di calibrazione richiede la stampa di un oggetto di prova e la misurazione di parti di tale oggetto di prova con un calibro digitale. Prima di eseguire una calibrazione delta avanzata, \u00e8 necessario eseguire la calibrazione delta di base (tramite il comando DELTA_CALIBRATE) e salvare i risultati (tramite il comando SAVE_CONFIG). Assicurati che non siano state apportate modifiche degne di nota alla configurazione della stampante n\u00e9 all'hardware dall'ultima esecuzione di una calibrazione delta di base (se non sei sicuro, esegui nuovamente la calibrazione delta di base , incluso SAVE_CONFIG, appena prima della stampa l'oggetto di prova descritto di seguito.) Usa uno slicer per generare il G-code dal file docs/prints/calibrate_size.stl . Estrudere l'oggetto a bassa velocit\u00e0 (ad es. 40 mm/s). Se possibile, usa una plastica rigida (come il PLA) per l'oggetto. L'oggetto ha un diametro di 140 mm. Se questo \u00e8 troppo grande per la stampante, \u00e8 possibile ridimensionarlo (ma assicurati di ridimensionare uniformemente entrambi gli assi X e Y). Se la stampante supporta stampe significativamente pi\u00f9 grandi, \u00e8 anche possibile aumentare le dimensioni di questo oggetto. Un formato pi\u00f9 grande pu\u00f2 migliorare la precisione della misurazione, ma una buona adesione di stampa \u00e8 pi\u00f9 importante di un formato di stampa pi\u00f9 grande. Stampa l'oggetto di prova e attendi che si raffreddi completamente. I comandi descritti di seguito devono essere eseguiti con le stesse impostazioni della stampante utilizzate per stampare l'oggetto di calibrazione (non eseguire DELTA_CALIBRATE tra la stampa e la misurazione, o fare qualcosa che altrimenti modificherebbe la configurazione della stampante). Se possibile, esegui le misurazioni descritte di seguito mentre l'oggetto \u00e8 ancora attaccato al piano di stampa, ma non preoccuparti se la parte si stacca dal letto: cerca solo di evitare di piegare l'oggetto durante l'esecuzione delle misurazioni. Inizia misurando la distanza tra il pilastro centrale e il pilastro accanto all'etichetta \"A\" (che dovrebbe anche puntare verso la torre \"A\"). Quindi procedere in senso antiorario e misurare le distanze tra il pilastro centrale e gli altri pilastri (distanza dal centro al pilastro attraverso l'etichetta C, distanza dal centro al pilastro con l'etichetta B, ecc.). Inserisci questi parametri in Klipper con un elenco separato da virgole di numeri in virgola mobile: DELTA_ANALYZE CENTER_DISTS=<a_dist>,<far_c_dist>,<b_dist>,<far_a_dist>,<c_dist>,<far_b_dist> Fornisci i valori senza spazi tra di loro. Quindi misurare la distanza tra il montante A e il montante di fronte all'etichetta C. Quindi andare in senso antiorario e misurare la distanza tra il pilastro di fronte a C e il pilastro B, la distanza tra il pilastro B e il pilastro di fronte a A, e cos\u00ec via. Inserisci questi parametri in Klipper: DELTA_ANALYZE OUTER_DISTS=<a_to_far_c>,<far_c_to_b>,<b_to_far_a>,<far_a_to_c>,<c_to_far_b>,<far_b_to_a> A questo punto va bene rimuovere l'oggetto dal letto. Le misure finali sono dei pilastri stessi. Misurare la dimensione del pilastro centrale lungo il raggio A, poi il raggio B e poi il raggio C. Inseriscili in Klipper: DELTA_ANALYZE CENTER_PILLAR_WIDTHS=<a>,<b>,<c> Le misure finali sono dei pilastri esterni. Inizia misurando la distanza del pilastro A lungo la linea da A al pilastro di fronte a C. Quindi andare in senso antiorario e misurare i restanti pilastri esterni (pilastro di fronte a C lungo la linea a B, pilastro B lungo la linea a pilastro di fronte ad A, ecc.). E inseriscili in Klipper: DELTA_ANALYZE OUTER_PILLAR_WIDTHS=<a>,<far_c>,<b>,<far_a>,<c>,<far_b> Se l'oggetto \u00e8 stato ridimensionato a una dimensione inferiore o superiore, fornire il fattore di scala utilizzato durante il taglio dell'oggetto: DELTA_ANALYZE SCALE=1.0 (Un valore di scala di 2,0 significherebbe che l'oggetto \u00e8 il doppio della sua dimensione originale, 0,5 sarebbe la met\u00e0 della sua dimensione originale.) Infine, esegui la calibrazione delta avanzata eseguendo: DELTA_ANALYZE CALIBRATE=extended Il completamento di questo comando pu\u00f2 richiedere diversi minuti. Dopo il completamento, calcoler\u00e0 i parametri delta aggiornati (raggio delta, angoli della torre, posizioni dei finecorsa e lunghezze dei bracci). Utilizzare il comando SAVE_CONFIG per salvare e applicare le impostazioni: SAVE_CONFIG Il comando SAVE_CONFIG salver\u00e0 sia i parametri delta aggiornati che le informazioni dalle misurazioni della distanza. Anche i futuri comandi DELTA_CALIBRATE utilizzeranno queste informazioni sulla distanza. Non tentare di reinserire le misurazioni grezze della distanza dopo aver eseguito SAVE_CONFIG, poich\u00e9 questo comando modifica la configurazione della stampante e le misurazioni grezze non vengono pi\u00f9 applicate.","title":"Calibrazione delta migliorata"},{"location":"Delta_Calibrate.html#note-aggiuntive","text":"Se la stampante delta ha una buona precisione dimensionale, la distanza tra due pilastri qualsiasi dovrebbe essere di circa 74 mm e la larghezza di ogni pilastro dovrebbe essere di circa 9 mm. (In particolare, l'obiettivo \u00e8 che la distanza tra due pilastri qualsiasi meno la larghezza di uno dei pilastri sia esattamente 65 mm.) In caso di imprecisione dimensionale nella parte, la routine DELTA_ANALYZE calcoler\u00e0 nuovi parametri delta utilizzando entrambe le misurazioni della distanza e le misurazioni dell'altezza precedenti dall'ultimo comando DELTA_CALIBRATE. DELTA_ANALYZE pu\u00f2 produrre parametri delta sorprendenti. Ad esempio, pu\u00f2 suggerire lunghezze dei bracci che non corrispondono alle lunghezze effettive dei bracci della stampante. Nonostante ci\u00f2, i test hanno dimostrato che DELTA_ANALYZE produce spesso risultati superiori. Si ritiene che i parametri delta calcolati siano in grado di tenere conto di lievi errori in altre parti dell'hardware. Ad esempio, piccole differenze nella lunghezza del braccio possono comportare un'inclinazione dell'effettore e parte di tale inclinazione pu\u00f2 essere spiegata regolando i parametri della lunghezza del braccio.","title":"Note aggiuntive"},{"location":"Delta_Calibrate.html#utilizzo-della-mesh-del-piatto-su-un-delta","text":"\u00c8 possibile utilizzare bed mesh su un delta. Tuttavia, \u00e8 importante ottenere una buona calibrazione delta prima di abilitare una mesh del letto. L'esecuzione della mesh del letto con una scarsa calibrazione delta comporter\u00e0 risultati confusi e scarsi. Si noti che l'esecuzione della calibrazione delta invalider\u00e0 qualsiasi mesh del piatto precedentemente ottenuto. Dopo aver eseguito una nuova calibrazione delta, assicurati di eseguire nuovamente BED_MESH_CALIBRATE.","title":"Utilizzo della mesh del piatto su un delta"},{"location":"Eddy_Probe.html","text":"Eddy Current Inductive probe \u00b6 This document describes how to use an eddy current inductive probe in Klipper. Currently, an eddy current probe can not be used for Z homing. The sensor can only be used for Z probing. Start by declaring a probe_eddy_current config section in the printer.cfg file. It is recommended to set the z_offset to 0.5mm. It is typical for the sensor to require an x_offset and y_offset . If these values are not known, one should estimate the values during initial calibration. The first step in calibration is to determine the appropriate DRIVE_CURRENT for the sensor. Home the printer and navigate the toolhead so that the sensor is near the center of the bed and is about 20mm above the bed. Then issue an LDC_CALIBRATE_DRIVE_CURRENT CHIP=<config_name> command. For example, if the config section was named [probe_eddy_current my_eddy_probe] then one would run LDC_CALIBRATE_DRIVE_CURRENT CHIP=my_eddy_probe . This command should complete in a few seconds. After it completes, issue a SAVE_CONFIG command to save the results to the printer.cfg and restart. The second step in calibration is to correlate the sensor readings to the corresponding Z heights. Home the printer and navigate the toolhead so that the nozzle is near the center of the bed. Then run an PROBE_EDDY_CURRENT_CALIBRATE CHIP=my_eddy_probe command. Once the tool starts, follow the steps described at \"the paper test\" to determine the actual distance between the nozzle and bed at the given location. Once those steps are complete one can ACCEPT the position. The tool will then move the the toolhead so that the sensor is above the point where the nozzle used to be and run a series of movements to correlate the sensor to Z positions. This will take a couple of minutes. After the tool completes, issue a SAVE_CONFIG command to save the results to the printer.cfg and restart. After initial calibration it is a good idea to verify that the x_offset and y_offset are accurate. Follow the steps to calibrate probe x and y offsets . If either the x_offset or y_offset is modified then be sure to run the PROBE_EDDY_CURRENT_CALIBRATE command (as described above) after making the change. Once calibration is complete, one may use all the standard Klipper tools that use a Z probe. Note that eddy current sensors (and inductive probes in general) are susceptible to \"thermal drift\". That is, changes in temperature can result in changes in reported Z height. Changes in either the bed surface temperature or sensor hardware temperature can skew the results. It is important that calibration and probing is only done when the printer is at a stable temperature. Thermal Drift Calibration \u00b6 As with all inductive probes, eddy current probes are subject to significant thermal drift. If the eddy probe has a temperature sensor on the coil it is possible to configure a [temperature_probe] to report coil temperature and enable software drift compensation. To link a temperature probe to an eddy current probe the [temperature_probe] section must share a name with the [probe_eddy_current] section. For example: [probe_eddy_current my_probe] # eddy probe configuration... [temperature_probe my_probe] # temperature probe configuration... See the configuration reference for further details on how to configure a temperature_probe . It is advised to configure the calibration_position , calibration_extruder_temp , extruder_heating_z , and calibration_bed_temp options, as doing so will automate some of the steps outlined below. If the printer to be calibrated is enclosed, it is strongly recommended to set the max_validation_temp option to a value between 100 and 120. Eddy probe manufacturers may offer a stock drift calibration that can be manually added to drift_calibration option of the [probe_eddy_current] section. If they do not, or if the stock calibration does not perform well on your system, the temperature_probe module offers a manual calibration procedure via the TEMPERATURE_PROBE_CALIBRATE gcode command. Prior to performing calibration the user should have an idea of what the maximum attainable temperature probe coil temperature is. This temperature should be used to set the TARGET parameter of the TEMPERATURE_PROBE_CALIBRATE command. The goal is to calibrate across the widest temperature range possible, thus its desirable to start with the printer cold and finish with the coil at the maximum temperature it can reach. Once a [temperature_probe] is configured, the following steps may be taken to perform thermal drift calibration: The probe must be calibrated using PROBE_EDDY_CURRENT_CALIBRATE when a [temperature_probe] is configured and linked. This captures the temperature during calibration which is necessary to perform thermal drift compensation. Make sure the nozzle is free of debris and filament. The bed, nozzle, and probe coil should be cold prior to calibration. The following steps are required if the calibration_position , calibration_extruder_temp , and extruder_heating_z options in [temperature_probe] are NOT configured: Move the tool to the center of the bed. Z should be 30mm+ above the bed. Heat the extruder to a temperature above the maximum safe bed temperature. 150-170C should be sufficient for most configurations. The purpose of heating the extruder is to avoid nozzle expansion during calibration. When the extruder temperature has settled, move the Z axis down to about 1mm above the bed. Start drift calibration. If the probe's name is my_probe and the maximum probe temperature we can achieve is 80C, the appropriate gcode command is TEMPERATURE_PROBE_CALIBRATE PROBE=my_probe TARGET=80 . If configured, the tool will move to the X,Y coordinate specified by the calibration_position and the Z value specified by extruder_heating_z . After heating the extruder to the specified temperature the tool will move to the Z value specified by the calibration_position . The procedure will request a manual probe. Perform the manual probe with the paper test and ACCEPT . The calibration procedure will take the first set of samples with the probe then park the probe in the heating position. If the calibration_bed_temp is NOT configured turn on the bed heat to the maximum safe temperature. Otherwise this step will be performed automatically. By default the calibration procedure will request a manual probe every 2C between samples until the TARGET is reached. The temperature delta between samples can be customized by setting the STEP parameter in TEMPERATURE_PROBE_CALIBRATE . Care should be taken when setting a custom STEP value, a value too high may request too few samples resulting in a poor calibration. The following additional gcode commands are available during drift calibration: TEMPERATURE_PROBE_NEXT may be used to force a new sample before the step delta has been reached. TEMPERATURE_PROBE_COMPLETE may be used to complete calibration before the TARGET has been reached. ABORT may be used to end calibration and discard results. When calibration is finished use SAVE_CONFIG to store the drift calibration. As one may conclude, the calibration process outlined above is more challenging and time consuming than most other procedures. It may require practice and several attempts to achieve an optimal calibration.","title":"Eddy Current Inductive probe"},{"location":"Eddy_Probe.html#eddy-current-inductive-probe","text":"This document describes how to use an eddy current inductive probe in Klipper. Currently, an eddy current probe can not be used for Z homing. The sensor can only be used for Z probing. Start by declaring a probe_eddy_current config section in the printer.cfg file. It is recommended to set the z_offset to 0.5mm. It is typical for the sensor to require an x_offset and y_offset . If these values are not known, one should estimate the values during initial calibration. The first step in calibration is to determine the appropriate DRIVE_CURRENT for the sensor. Home the printer and navigate the toolhead so that the sensor is near the center of the bed and is about 20mm above the bed. Then issue an LDC_CALIBRATE_DRIVE_CURRENT CHIP=<config_name> command. For example, if the config section was named [probe_eddy_current my_eddy_probe] then one would run LDC_CALIBRATE_DRIVE_CURRENT CHIP=my_eddy_probe . This command should complete in a few seconds. After it completes, issue a SAVE_CONFIG command to save the results to the printer.cfg and restart. The second step in calibration is to correlate the sensor readings to the corresponding Z heights. Home the printer and navigate the toolhead so that the nozzle is near the center of the bed. Then run an PROBE_EDDY_CURRENT_CALIBRATE CHIP=my_eddy_probe command. Once the tool starts, follow the steps described at \"the paper test\" to determine the actual distance between the nozzle and bed at the given location. Once those steps are complete one can ACCEPT the position. The tool will then move the the toolhead so that the sensor is above the point where the nozzle used to be and run a series of movements to correlate the sensor to Z positions. This will take a couple of minutes. After the tool completes, issue a SAVE_CONFIG command to save the results to the printer.cfg and restart. After initial calibration it is a good idea to verify that the x_offset and y_offset are accurate. Follow the steps to calibrate probe x and y offsets . If either the x_offset or y_offset is modified then be sure to run the PROBE_EDDY_CURRENT_CALIBRATE command (as described above) after making the change. Once calibration is complete, one may use all the standard Klipper tools that use a Z probe. Note that eddy current sensors (and inductive probes in general) are susceptible to \"thermal drift\". That is, changes in temperature can result in changes in reported Z height. Changes in either the bed surface temperature or sensor hardware temperature can skew the results. It is important that calibration and probing is only done when the printer is at a stable temperature.","title":"Eddy Current Inductive probe"},{"location":"Eddy_Probe.html#thermal-drift-calibration","text":"As with all inductive probes, eddy current probes are subject to significant thermal drift. If the eddy probe has a temperature sensor on the coil it is possible to configure a [temperature_probe] to report coil temperature and enable software drift compensation. To link a temperature probe to an eddy current probe the [temperature_probe] section must share a name with the [probe_eddy_current] section. For example: [probe_eddy_current my_probe] # eddy probe configuration... [temperature_probe my_probe] # temperature probe configuration... See the configuration reference for further details on how to configure a temperature_probe . It is advised to configure the calibration_position , calibration_extruder_temp , extruder_heating_z , and calibration_bed_temp options, as doing so will automate some of the steps outlined below. If the printer to be calibrated is enclosed, it is strongly recommended to set the max_validation_temp option to a value between 100 and 120. Eddy probe manufacturers may offer a stock drift calibration that can be manually added to drift_calibration option of the [probe_eddy_current] section. If they do not, or if the stock calibration does not perform well on your system, the temperature_probe module offers a manual calibration procedure via the TEMPERATURE_PROBE_CALIBRATE gcode command. Prior to performing calibration the user should have an idea of what the maximum attainable temperature probe coil temperature is. This temperature should be used to set the TARGET parameter of the TEMPERATURE_PROBE_CALIBRATE command. The goal is to calibrate across the widest temperature range possible, thus its desirable to start with the printer cold and finish with the coil at the maximum temperature it can reach. Once a [temperature_probe] is configured, the following steps may be taken to perform thermal drift calibration: The probe must be calibrated using PROBE_EDDY_CURRENT_CALIBRATE when a [temperature_probe] is configured and linked. This captures the temperature during calibration which is necessary to perform thermal drift compensation. Make sure the nozzle is free of debris and filament. The bed, nozzle, and probe coil should be cold prior to calibration. The following steps are required if the calibration_position , calibration_extruder_temp , and extruder_heating_z options in [temperature_probe] are NOT configured: Move the tool to the center of the bed. Z should be 30mm+ above the bed. Heat the extruder to a temperature above the maximum safe bed temperature. 150-170C should be sufficient for most configurations. The purpose of heating the extruder is to avoid nozzle expansion during calibration. When the extruder temperature has settled, move the Z axis down to about 1mm above the bed. Start drift calibration. If the probe's name is my_probe and the maximum probe temperature we can achieve is 80C, the appropriate gcode command is TEMPERATURE_PROBE_CALIBRATE PROBE=my_probe TARGET=80 . If configured, the tool will move to the X,Y coordinate specified by the calibration_position and the Z value specified by extruder_heating_z . After heating the extruder to the specified temperature the tool will move to the Z value specified by the calibration_position . The procedure will request a manual probe. Perform the manual probe with the paper test and ACCEPT . The calibration procedure will take the first set of samples with the probe then park the probe in the heating position. If the calibration_bed_temp is NOT configured turn on the bed heat to the maximum safe temperature. Otherwise this step will be performed automatically. By default the calibration procedure will request a manual probe every 2C between samples until the TARGET is reached. The temperature delta between samples can be customized by setting the STEP parameter in TEMPERATURE_PROBE_CALIBRATE . Care should be taken when setting a custom STEP value, a value too high may request too few samples resulting in a poor calibration. The following additional gcode commands are available during drift calibration: TEMPERATURE_PROBE_NEXT may be used to force a new sample before the step delta has been reached. TEMPERATURE_PROBE_COMPLETE may be used to complete calibration before the TARGET has been reached. ABORT may be used to end calibration and discard results. When calibration is finished use SAVE_CONFIG to store the drift calibration. As one may conclude, the calibration process outlined above is more challenging and time consuming than most other procedures. It may require practice and several attempts to achieve an optimal calibration.","title":"Thermal Drift Calibration"},{"location":"Endstop_Phase.html","text":"Fase di fine corsa \u00b6 Questo documento descrive il sistema di finecorsa di Klipper regolato sulla fase degli stepper. Questa funzionalit\u00e0 pu\u00f2 migliorare la precisione degli interruttori di fine corsa tradizionali. \u00c8 particolarmente utile quando si utilizza un driver per motori passo-passo Trinamic con configurazione runtime. Un tipico interruttore di fine corsa ha una precisione di circa 100 micron. (Ogni volta l'interruttore pu\u00f2 attivarsi leggermente prima o leggermente dopo.) Sebbene si tratti di un errore relativamente piccolo, pu\u00f2 causare artefatti indesiderati. In particolare, questa deviazione di posizione pu\u00f2 essere evidente quando si stampa il primo strato di un oggetto. Al contrario, i tipici motori passo-passo possono ottenere una precisione significativamente maggiore. Il meccanismo di fine corsa con regolazione della fase pu\u00f2 utilizzare la precisione dei motori passo-passo per migliorare la precisione degli interruttori di fine corsa. Un motore passo-passo si muove ciclicamente attraverso una serie di fasi fino a completare quattro \"passi completi\". Quindi, un motore passo-passo che utilizza 16 micro-passi avrebbe 64 fasi e quando si muove in direzione positiva passerebbe in rassegna le fasi: 0, 1, 2, ... 61, 62, 63, 0, 1, 2, ecc. Fondamentalmente, quando il motore passo-passo si trova in una posizione particolare su una guida lineare, dovrebbe essere sempre nella stessa fase passo-passo. Pertanto, quando un carrello fa scattare l'interruttore di fine corsa, lo stepper che controlla quel carrello dovrebbe essere sempre nella stessa fase del motore passo-passo. Il sistema di fase finecorsa di Klipper combina la fase del motore con l'attivazione del finecorsa per migliorare la precisione. Per utilizzare questa funzionalit\u00e0 \u00e8 necessario essere in grado di identificare la fase del motore passo-passo. Se si utilizzano i driver Trinamic TMC2130, TMC2208, TMC2224 o TMC2660 in modalit\u00e0 di configurazione runtime (cio\u00e8 non in modalit\u00e0 stand-alone), Klipper pu\u00f2 interrogare la fase stepper dal driver. (\u00c8 anche possibile utilizzare questo sistema su driver stepper tradizionali se \u00e8 possibile ripristinare in modo affidabile i driver stepper - vedere sotto per i dettagli.) Taratura fasi dei finecorsa \u00b6 Se si utilizzano driver Trinamic per motori passo-passo in configurazione runtime, \u00e8 possibile calibrare le fasi di fine corsa utilizzando il comando ENDSTOP_PHASE_CALIBRATE. Inizia aggiungendo quanto segue al file di configurazione: [endstop_phase] Quindi RIAVVIARE la stampante ed eseguire un comando G28 seguito da un comando ENDSTOP_PHASE_CALIBRATE . Quindi spostare la testina in una nuova posizione ed eseguire nuovamente G28 . Prova a spostare la testina in diverse posizioni ed esegui nuovamente G28 da ciascuna posizione. Esegui almeno cinque comandi G28 . Dopo aver eseguito quanto sopra, il comando ENDSTOP_PHASE_CALIBRATE riporter\u00e0 spesso la stessa (o quasi) fase per lo stepper. Questa fase pu\u00f2 essere salvata nel file di configurazione in modo che tutti i futuri comandi G28 utilizzino quella fase. (Quindi, nelle future operazioni di homing, Klipper otterr\u00e0 la stessa posizione anche se il finecorsa si attiva un po' prima o un po' dopo.) Per salvare la fase di fine corsa per un particolare motore passo-passo, eseguire qualcosa di simile a: ENDSTOP_PHASE_CALIBRATE STEPPER=stepper_z Esegui quanto sopra per tutti gli stepper che desideri salvare. Tipicamente, si usa questo su stepper_z per stampanti cartesiane e corexy e per stepper_a, stepper_b e stepper_c su stampanti delta. Infine, eseguire quanto segue per aggiornare il file di configurazione con i dati: SAVE_CONFIG Note aggiuntive \u00b6 Questa funzione \u00e8 particolarmente utile sulle stampanti delta e sul fine corsa Z delle stampanti cartesiane/corexy. \u00c8 possibile utilizzare questa funzione sui fine corsa XY delle stampanti cartesiane, ma ci\u00f2 non \u00e8 particolarmente utile poich\u00e9 \u00e8 improbabile che un errore minore nella posizione dell'arresto X/Y influisca sulla qualit\u00e0 di stampa. Non \u00e8 valido utilizzare questa funzione sugli arresti XY delle stampanti corexy (poich\u00e9 la posizione XY non \u00e8 determinata da un singolo stepper sulla cinematica corexy). Non \u00e8 valido utilizzare questa funzione su una stampante che utilizza un fine corsa Z \"probe:z_virtual_endstop\" (poich\u00e9 la fase stepper \u00e8 stabile solo se il fine corsa si trova in una posizione statica su una guida). Dopo aver calibrato la fase del finecorsa, se il finecorsa viene successivamente spostato o regolato, sar\u00e0 necessario ricalibrarlo. Rimuovere i dati di calibrazione dal file di configurazione ed eseguire nuovamente i passaggi precedenti. Per utilizzare questo sistema, il finecorsa deve essere sufficientemente preciso da identificare la posizione dello stepper entro due \"passi completi\". Quindi, ad esempio, se uno stepper utilizza 16 micropassi con una distanza del passo di 0,005 mm, il finecorsa deve avere una precisione di almeno 0,160 mm. Se si ottengono messaggi di errore di tipo \"Finecorsa stepper_z non corretto\", potrebbero essere dovuti a un finecorsa che non \u00e8 sufficientemente accurato. Se la ricalibrazione non aiuta, disabilitare le regolazioni della fase finecorsa rimuovendole dal file di configurazione. Se si utilizza un tradizionale asse Z controllato da stepper (come su una stampante cartesiana o corexy) insieme alle tradizionali viti di livellamento del letto, \u00e8 anche possibile utilizzare questo sistema per fare in modo che ogni strato di stampa venga eseguito su un confine \"passo completo\" . Per abilitare questa funzione, assicurati che lo slicer del G-Code sia configurato con un'altezza del livello che sia un multiplo di un \"passo completo\", abilita manualmente l'opzione endstop_align_zero nella sezione di configurazione endstop_phase (vedi config reference per ulteriori dettagli), quindi livellare nuovamente le viti del piatto. \u00c8 possibile utilizzare questo sistema con driver per motori passo-passo tradizionali (non Trinamici). Tuttavia, per fare ci\u00f2 \u00e8 necessario assicurarsi che i driver del motore passo-passo vengano ripristinati ogni volta che viene ripristinato il microcontrollore. (Se i due vengono sempre ripristinati insieme, Klipper pu\u00f2 determinare la fase dello stepper tracciando il numero totale di passaggi che ha comandato allo stepper di muoversi.) Attualmente, l'unico modo per farlo in modo affidabile \u00e8 se sia il microcontrollore che il motore passo-passo i driver siano alimentati esclusivamente da USB e che l'alimentazione USB sia fornita da un host in esecuzione su un Raspberry Pi. In questa situazione \u00e8 possibile specificare una configurazione mcu con \"restart_method: rpi_usb\" - quell'opzione far\u00e0 in modo che il microcontrollore venga sempre ripristinato tramite un ripristino dell'alimentazione USB, il che farebbe in modo che sia il microcontrollore che i driver del motore passo-passo siano resettare insieme. Se si utilizza questo meccanismo, \u00e8 necessario configurare manualmente le sezioni di configurazione \"trigger_phase\" (consultare config reference per i dettagli).","title":"Fase di fine corsa"},{"location":"Endstop_Phase.html#fase-di-fine-corsa","text":"Questo documento descrive il sistema di finecorsa di Klipper regolato sulla fase degli stepper. Questa funzionalit\u00e0 pu\u00f2 migliorare la precisione degli interruttori di fine corsa tradizionali. \u00c8 particolarmente utile quando si utilizza un driver per motori passo-passo Trinamic con configurazione runtime. Un tipico interruttore di fine corsa ha una precisione di circa 100 micron. (Ogni volta l'interruttore pu\u00f2 attivarsi leggermente prima o leggermente dopo.) Sebbene si tratti di un errore relativamente piccolo, pu\u00f2 causare artefatti indesiderati. In particolare, questa deviazione di posizione pu\u00f2 essere evidente quando si stampa il primo strato di un oggetto. Al contrario, i tipici motori passo-passo possono ottenere una precisione significativamente maggiore. Il meccanismo di fine corsa con regolazione della fase pu\u00f2 utilizzare la precisione dei motori passo-passo per migliorare la precisione degli interruttori di fine corsa. Un motore passo-passo si muove ciclicamente attraverso una serie di fasi fino a completare quattro \"passi completi\". Quindi, un motore passo-passo che utilizza 16 micro-passi avrebbe 64 fasi e quando si muove in direzione positiva passerebbe in rassegna le fasi: 0, 1, 2, ... 61, 62, 63, 0, 1, 2, ecc. Fondamentalmente, quando il motore passo-passo si trova in una posizione particolare su una guida lineare, dovrebbe essere sempre nella stessa fase passo-passo. Pertanto, quando un carrello fa scattare l'interruttore di fine corsa, lo stepper che controlla quel carrello dovrebbe essere sempre nella stessa fase del motore passo-passo. Il sistema di fase finecorsa di Klipper combina la fase del motore con l'attivazione del finecorsa per migliorare la precisione. Per utilizzare questa funzionalit\u00e0 \u00e8 necessario essere in grado di identificare la fase del motore passo-passo. Se si utilizzano i driver Trinamic TMC2130, TMC2208, TMC2224 o TMC2660 in modalit\u00e0 di configurazione runtime (cio\u00e8 non in modalit\u00e0 stand-alone), Klipper pu\u00f2 interrogare la fase stepper dal driver. (\u00c8 anche possibile utilizzare questo sistema su driver stepper tradizionali se \u00e8 possibile ripristinare in modo affidabile i driver stepper - vedere sotto per i dettagli.)","title":"Fase di fine corsa"},{"location":"Endstop_Phase.html#taratura-fasi-dei-finecorsa","text":"Se si utilizzano driver Trinamic per motori passo-passo in configurazione runtime, \u00e8 possibile calibrare le fasi di fine corsa utilizzando il comando ENDSTOP_PHASE_CALIBRATE. Inizia aggiungendo quanto segue al file di configurazione: [endstop_phase] Quindi RIAVVIARE la stampante ed eseguire un comando G28 seguito da un comando ENDSTOP_PHASE_CALIBRATE . Quindi spostare la testina in una nuova posizione ed eseguire nuovamente G28 . Prova a spostare la testina in diverse posizioni ed esegui nuovamente G28 da ciascuna posizione. Esegui almeno cinque comandi G28 . Dopo aver eseguito quanto sopra, il comando ENDSTOP_PHASE_CALIBRATE riporter\u00e0 spesso la stessa (o quasi) fase per lo stepper. Questa fase pu\u00f2 essere salvata nel file di configurazione in modo che tutti i futuri comandi G28 utilizzino quella fase. (Quindi, nelle future operazioni di homing, Klipper otterr\u00e0 la stessa posizione anche se il finecorsa si attiva un po' prima o un po' dopo.) Per salvare la fase di fine corsa per un particolare motore passo-passo, eseguire qualcosa di simile a: ENDSTOP_PHASE_CALIBRATE STEPPER=stepper_z Esegui quanto sopra per tutti gli stepper che desideri salvare. Tipicamente, si usa questo su stepper_z per stampanti cartesiane e corexy e per stepper_a, stepper_b e stepper_c su stampanti delta. Infine, eseguire quanto segue per aggiornare il file di configurazione con i dati: SAVE_CONFIG","title":"Taratura fasi dei finecorsa"},{"location":"Endstop_Phase.html#note-aggiuntive","text":"Questa funzione \u00e8 particolarmente utile sulle stampanti delta e sul fine corsa Z delle stampanti cartesiane/corexy. \u00c8 possibile utilizzare questa funzione sui fine corsa XY delle stampanti cartesiane, ma ci\u00f2 non \u00e8 particolarmente utile poich\u00e9 \u00e8 improbabile che un errore minore nella posizione dell'arresto X/Y influisca sulla qualit\u00e0 di stampa. Non \u00e8 valido utilizzare questa funzione sugli arresti XY delle stampanti corexy (poich\u00e9 la posizione XY non \u00e8 determinata da un singolo stepper sulla cinematica corexy). Non \u00e8 valido utilizzare questa funzione su una stampante che utilizza un fine corsa Z \"probe:z_virtual_endstop\" (poich\u00e9 la fase stepper \u00e8 stabile solo se il fine corsa si trova in una posizione statica su una guida). Dopo aver calibrato la fase del finecorsa, se il finecorsa viene successivamente spostato o regolato, sar\u00e0 necessario ricalibrarlo. Rimuovere i dati di calibrazione dal file di configurazione ed eseguire nuovamente i passaggi precedenti. Per utilizzare questo sistema, il finecorsa deve essere sufficientemente preciso da identificare la posizione dello stepper entro due \"passi completi\". Quindi, ad esempio, se uno stepper utilizza 16 micropassi con una distanza del passo di 0,005 mm, il finecorsa deve avere una precisione di almeno 0,160 mm. Se si ottengono messaggi di errore di tipo \"Finecorsa stepper_z non corretto\", potrebbero essere dovuti a un finecorsa che non \u00e8 sufficientemente accurato. Se la ricalibrazione non aiuta, disabilitare le regolazioni della fase finecorsa rimuovendole dal file di configurazione. Se si utilizza un tradizionale asse Z controllato da stepper (come su una stampante cartesiana o corexy) insieme alle tradizionali viti di livellamento del letto, \u00e8 anche possibile utilizzare questo sistema per fare in modo che ogni strato di stampa venga eseguito su un confine \"passo completo\" . Per abilitare questa funzione, assicurati che lo slicer del G-Code sia configurato con un'altezza del livello che sia un multiplo di un \"passo completo\", abilita manualmente l'opzione endstop_align_zero nella sezione di configurazione endstop_phase (vedi config reference per ulteriori dettagli), quindi livellare nuovamente le viti del piatto. \u00c8 possibile utilizzare questo sistema con driver per motori passo-passo tradizionali (non Trinamici). Tuttavia, per fare ci\u00f2 \u00e8 necessario assicurarsi che i driver del motore passo-passo vengano ripristinati ogni volta che viene ripristinato il microcontrollore. (Se i due vengono sempre ripristinati insieme, Klipper pu\u00f2 determinare la fase dello stepper tracciando il numero totale di passaggi che ha comandato allo stepper di muoversi.) Attualmente, l'unico modo per farlo in modo affidabile \u00e8 se sia il microcontrollore che il motore passo-passo i driver siano alimentati esclusivamente da USB e che l'alimentazione USB sia fornita da un host in esecuzione su un Raspberry Pi. In questa situazione \u00e8 possibile specificare una configurazione mcu con \"restart_method: rpi_usb\" - quell'opzione far\u00e0 in modo che il microcontrollore venga sempre ripristinato tramite un ripristino dell'alimentazione USB, il che farebbe in modo che sia il microcontrollore che i driver del motore passo-passo siano resettare insieme. Se si utilizza questo meccanismo, \u00e8 necessario configurare manualmente le sezioni di configurazione \"trigger_phase\" (consultare config reference per i dettagli).","title":"Note aggiuntive"},{"location":"Example_Configs.html","text":"Esempi di configurazioni \u00b6 Questo documento contiene le linee guida per contribuire a creare un esempio di configurazione di Klipper nella repository github di Klipper (situato nella directory config ). Nota che il server Klipper Community Discourse \u00e8 anche una risorsa utile per trovare e condividere file di configurazione. Linee guida \u00b6 Seleziona il prefisso del nome del file di configurazione appropriato: Il prefisso printer viene utilizzato per le stampanti stock vendute da un produttore tradizionale. Il prefisso generic viene utilizzato per una scheda per stampante 3d che pu\u00f2 essere utilizzata in molti diversi tipi di stampanti. Il prefisso kit \u00e8 per le stampanti 3d assemblate secondo una specifica ampiamente utilizzata. Queste stampanti \"kit\" sono generalmente distinte dalle normali \"stampanti\" in quanto non sono vendute da un produttore. Il prefisso sample viene utilizzato per i \"ritagli\" di configurazione che \u00e8 possibile copiare e incollare nel file di configurazione principale. Il prefisso example viene utilizzato per descrivere la cinematica della stampante. Questo tipo di configurazione viene in genere aggiunto solo insieme al codice per un nuovo tipo di cinematica della stampante. Tutti i file di configurazione devono terminare con un suffisso .cfg . I file di configurazione della stampante devono terminare con un anno seguito da .cfg (ad es. -2019.cfg ). In questo caso, l'anno \u00e8 un anno approssimativo in cui \u00e8 stata venduta la stampante specificata. Non utilizzare spazi o caratteri speciali nel nome del file di configurazione. Il nome del file deve contenere solo i caratteri A-Z , a-z , 0-9 , - e . . Klipper deve essere in grado di avviare il file di configurazione di esempio printer , generic e kit senza errori. Questi file di configurazione devono essere aggiunti al test di regressione test/klippy/printers.test . Aggiungi nuovi file di configurazione a quel test case nella sezione appropriata e in ordine alfabetico all'interno di quella sezione. La configurazione di esempio dovrebbe essere per la configurazione \"stock\" della stampante. (Ci sono troppe configurazioni \"personalizzate\" da tenere traccia nel repository principale di Klipper.) Allo stesso modo, aggiungiamo solo file di configurazione di esempio per stampanti, kit e schede che hanno la popolarit\u00e0 principale (ad esempio, dovrebbero essercene almeno 100 in uso attivo). Prendi in considerazione l'utilizzo del server Klipper Community Discourse per altre configurazioni. Only specify those devices present on the given printer or board. Do not specify settings specific to your particular setup. For generic config files, only those devices on the mainboard should be described. For example, it would not make sense to add a display config section to a \"generic\" config as there is no way to know if the board will be attached to that type of display. If the board has a specific hardware port to facilitate an optional peripheral (eg, a bltouch port) then one can add a \"commented out\" config section for the given device. Non specificare pressure_advance in una configurazione di esempio, poich\u00e9 quel valore \u00e8 specifico del filamento, non dell'hardware della stampante. Allo stesso modo, non specificare le impostazioni max_extrude_only_velocity n\u00e9 max_extrude_only_accel . Non specificare una sezione di configurazione contenente un percorso host o hardware host. Ad esempio, non specificare le sezioni di configurazione [virtual_sdcard] n\u00e9 [temperature_host] . Definire solo le macro che utilizzano funzionalit\u00e0 specifiche per la stampante specificata o per definire i G-code comunemente emessi dagli slicer configurati per la stampante specificata. Where possible, it is best to use the same wording, phrasing, indentation, and section ordering as the existing config files. The top of each config file should list the type of micro-controller the user should select during \"make menuconfig\". It should also have a reference to \"docs/Config_Reference.md\". Non copiare la documentazione sul campo nei file di configurazione di esempio. (In questo modo si crea un onere di manutenzione poich\u00e9 un aggiornamento della documentazione richiederebbe quindi la modifica in molti punti.) I file di configurazione di esempio non devono contenere una sezione \"SAVE_CONFIG\". Se necessario, copiare i campi rilevanti dalla sezione SAVE_CONFIG alla sezione appropriata nell'area di configurazione principale. Usa la sintassi field: value invece di field=value . Quando si aggiunge la rotation_distance a un estrusore \u00e8 preferibile specificare un gear_ratio se l'estrusore ha un meccanismo di ingranaggi. Ci aspettiamo che la rotation_distance nelle configurazioni di esempio sia correlata alla circonferenza dell'ingranaggio nell'estrusore: normalmente \u00e8 nell'intervallo da 20 a 35 mm. Quando si specifica un gear_ratio \u00e8 preferibile specificare gli ingranaggi effettivi sul meccanismo (ad esempio, preferire gear_ratio: 80:20 su gear_ratio: 4:1 ). Per ulteriori informazioni, vedere il documento sulla distanza di rotazione . Evitare di definire valori di campo impostati sul valore predefinito. Ad esempio, non si dovrebbe specificare min_extrude_temp: 170 poich\u00e9 questo \u00e8 gi\u00e0 il valore predefinito. Ove possibile, le righe non devono superare le 80 colonne. Evita di aggiungere messaggi di attribuzione o revisione ai file di configurazione. (Ad esempio, evita di aggiungere righe come \"questo file \u00e8 stato creato da...\".) Inserisci l'attribuzione e cambia la cronologia nel messaggio di commit git. Non utilizzare alcuna funzionalit\u00e0 deprecata nel file di configurazione di esempio. Non disabilitare un sistema di sicurezza predefinito in un file di configurazione di esempio. Ad esempio, una configurazione non dovrebbe specificare una max_extrude_cross_section personalizzata. Non abilitare le funzionalit\u00e0 di debug. Ad esempio, non dovrebbe esserci una sezione di configurazione force_move . Tutte le schede note supportate da Klipper possono utilizzare la velocit\u00e0 di trasmissione seriale predefinita di 250000. Non consigliare una velocit\u00e0 di trasmissione diversa in un file di configurazione di esempio. I file di configurazione di esempio vengono inviati creando una \"richiesta pull\" di github. Si prega di seguire anche le indicazioni nel documento per contributi .","title":"Esempi di configurazioni"},{"location":"Example_Configs.html#esempi-di-configurazioni","text":"Questo documento contiene le linee guida per contribuire a creare un esempio di configurazione di Klipper nella repository github di Klipper (situato nella directory config ). Nota che il server Klipper Community Discourse \u00e8 anche una risorsa utile per trovare e condividere file di configurazione.","title":"Esempi di configurazioni"},{"location":"Example_Configs.html#linee-guida","text":"Seleziona il prefisso del nome del file di configurazione appropriato: Il prefisso printer viene utilizzato per le stampanti stock vendute da un produttore tradizionale. Il prefisso generic viene utilizzato per una scheda per stampante 3d che pu\u00f2 essere utilizzata in molti diversi tipi di stampanti. Il prefisso kit \u00e8 per le stampanti 3d assemblate secondo una specifica ampiamente utilizzata. Queste stampanti \"kit\" sono generalmente distinte dalle normali \"stampanti\" in quanto non sono vendute da un produttore. Il prefisso sample viene utilizzato per i \"ritagli\" di configurazione che \u00e8 possibile copiare e incollare nel file di configurazione principale. Il prefisso example viene utilizzato per descrivere la cinematica della stampante. Questo tipo di configurazione viene in genere aggiunto solo insieme al codice per un nuovo tipo di cinematica della stampante. Tutti i file di configurazione devono terminare con un suffisso .cfg . I file di configurazione della stampante devono terminare con un anno seguito da .cfg (ad es. -2019.cfg ). In questo caso, l'anno \u00e8 un anno approssimativo in cui \u00e8 stata venduta la stampante specificata. Non utilizzare spazi o caratteri speciali nel nome del file di configurazione. Il nome del file deve contenere solo i caratteri A-Z , a-z , 0-9 , - e . . Klipper deve essere in grado di avviare il file di configurazione di esempio printer , generic e kit senza errori. Questi file di configurazione devono essere aggiunti al test di regressione test/klippy/printers.test . Aggiungi nuovi file di configurazione a quel test case nella sezione appropriata e in ordine alfabetico all'interno di quella sezione. La configurazione di esempio dovrebbe essere per la configurazione \"stock\" della stampante. (Ci sono troppe configurazioni \"personalizzate\" da tenere traccia nel repository principale di Klipper.) Allo stesso modo, aggiungiamo solo file di configurazione di esempio per stampanti, kit e schede che hanno la popolarit\u00e0 principale (ad esempio, dovrebbero essercene almeno 100 in uso attivo). Prendi in considerazione l'utilizzo del server Klipper Community Discourse per altre configurazioni. Only specify those devices present on the given printer or board. Do not specify settings specific to your particular setup. For generic config files, only those devices on the mainboard should be described. For example, it would not make sense to add a display config section to a \"generic\" config as there is no way to know if the board will be attached to that type of display. If the board has a specific hardware port to facilitate an optional peripheral (eg, a bltouch port) then one can add a \"commented out\" config section for the given device. Non specificare pressure_advance in una configurazione di esempio, poich\u00e9 quel valore \u00e8 specifico del filamento, non dell'hardware della stampante. Allo stesso modo, non specificare le impostazioni max_extrude_only_velocity n\u00e9 max_extrude_only_accel . Non specificare una sezione di configurazione contenente un percorso host o hardware host. Ad esempio, non specificare le sezioni di configurazione [virtual_sdcard] n\u00e9 [temperature_host] . Definire solo le macro che utilizzano funzionalit\u00e0 specifiche per la stampante specificata o per definire i G-code comunemente emessi dagli slicer configurati per la stampante specificata. Where possible, it is best to use the same wording, phrasing, indentation, and section ordering as the existing config files. The top of each config file should list the type of micro-controller the user should select during \"make menuconfig\". It should also have a reference to \"docs/Config_Reference.md\". Non copiare la documentazione sul campo nei file di configurazione di esempio. (In questo modo si crea un onere di manutenzione poich\u00e9 un aggiornamento della documentazione richiederebbe quindi la modifica in molti punti.) I file di configurazione di esempio non devono contenere una sezione \"SAVE_CONFIG\". Se necessario, copiare i campi rilevanti dalla sezione SAVE_CONFIG alla sezione appropriata nell'area di configurazione principale. Usa la sintassi field: value invece di field=value . Quando si aggiunge la rotation_distance a un estrusore \u00e8 preferibile specificare un gear_ratio se l'estrusore ha un meccanismo di ingranaggi. Ci aspettiamo che la rotation_distance nelle configurazioni di esempio sia correlata alla circonferenza dell'ingranaggio nell'estrusore: normalmente \u00e8 nell'intervallo da 20 a 35 mm. Quando si specifica un gear_ratio \u00e8 preferibile specificare gli ingranaggi effettivi sul meccanismo (ad esempio, preferire gear_ratio: 80:20 su gear_ratio: 4:1 ). Per ulteriori informazioni, vedere il documento sulla distanza di rotazione . Evitare di definire valori di campo impostati sul valore predefinito. Ad esempio, non si dovrebbe specificare min_extrude_temp: 170 poich\u00e9 questo \u00e8 gi\u00e0 il valore predefinito. Ove possibile, le righe non devono superare le 80 colonne. Evita di aggiungere messaggi di attribuzione o revisione ai file di configurazione. (Ad esempio, evita di aggiungere righe come \"questo file \u00e8 stato creato da...\".) Inserisci l'attribuzione e cambia la cronologia nel messaggio di commit git. Non utilizzare alcuna funzionalit\u00e0 deprecata nel file di configurazione di esempio. Non disabilitare un sistema di sicurezza predefinito in un file di configurazione di esempio. Ad esempio, una configurazione non dovrebbe specificare una max_extrude_cross_section personalizzata. Non abilitare le funzionalit\u00e0 di debug. Ad esempio, non dovrebbe esserci una sezione di configurazione force_move . Tutte le schede note supportate da Klipper possono utilizzare la velocit\u00e0 di trasmissione seriale predefinita di 250000. Non consigliare una velocit\u00e0 di trasmissione diversa in un file di configurazione di esempio. I file di configurazione di esempio vengono inviati creando una \"richiesta pull\" di github. Si prega di seguire anche le indicazioni nel documento per contributi .","title":"Linee guida"},{"location":"Exclude_Object.html","text":"Escludi oggetti \u00b6 The [exclude_object] module allows Klipper to exclude objects while a print is in progress. To enable this feature include an exclude_object config section (also see the command reference and sample-macros.cfg file for a Marlin/RepRapFirmware compatible M486 G-Code macro.) A differenza di altre opzioni del firmware della stampante 3D, una stampante che esegue Klipper utilizza una suite di componenti e gli utenti hanno molte opzioni tra cui scegliere. Pertanto, al fine di fornire un'esperienza utente coerente, il modulo [exclude_object] stabilir\u00e0 un contratto o una sorta di API. Il contratto copre il contenuto del file gcode, come viene controllato lo stato interno del modulo e come tale stato viene fornito ai client. Panoramica del flusso di lavoro \u00b6 Un tipico flusso di lavoro per la stampa di un file potrebbe essere simile a: Lo slicing \u00e8 completato e il file viene caricato per la stampa. Durante il caricamento, il file viene elaborato e gli indicatori [exclude_object] vengono aggiunti al file. In alternativa, i filtri dei dati possono essere configurati per preparare i marcatori di esclusione degli oggetti in modo nativo o nella propria fase di pre-elaborazione. All'avvio della stampa, Klipper ripristiner\u00e0 [exclude_object] status . Quando Klipper elabora il blocco EXCLUDE_OBJECT_DEFINE , aggiorner\u00e0 lo stato con gli oggetti conosciuti e lo passer\u00e0 ai client. Il client pu\u00f2 utilizzare tali informazioni per presentare un'interfaccia all'utente in modo che sia possibile tenere traccia dei progressi. Klipper aggiorner\u00e0 lo stato per includere l'oggetto attualmente in stampa che il client pu\u00f2 utilizzare per scopi di visualizzazione. Se l'utente richiede la cancellazione di un oggetto, il client invier\u00e0 un comando EXCLUDE_OBJECT NAME=<nome> a Klipper. Quando Klipper elabora il comando, aggiunger\u00e0 l'oggetto all'elenco degli oggetti esclusi e aggiorner\u00e0 lo stato per i client. Il client ricever\u00e0 lo stato aggiornato da Klipper e potr\u00e0 utilizzare tali informazioni per aggiornare lo stato dell'oggetto nell'interfaccia utente. Al termine della stampa, lo stato [exclude_object] continuer\u00e0 a essere disponibile fino a quando un'altra azione non lo reimposta. Il file GCode \u00b6 L'elaborazione specializzata del gcode necessaria per supportare l'esclusione di oggetti non rientra negli obiettivi di progettazione principali di Klipper. Pertanto, questo modulo richiede che il file venga elaborato prima di essere inviato a Klipper per la stampa. L'utilizzo di uno script di post-elaborazione nello slicer o il middleware che elabora il file durante il caricamento sono due possibilit\u00e0 per preparare il file per Klipper. Uno script di post-elaborazione di riferimento \u00e8 disponibile sia come eseguibile che come libreria Python, vedere cancelobject-preprocessor . Definizioni di oggetti \u00b6 Il comando EXCLUDE_OBJECT_DEFINE viene utilizzato per fornire un riepilogo di ogni oggetto nel file gcode da stampare. Fornisce un riepilogo di un oggetto nel file. Gli oggetti non hanno bisogno di essere definiti per essere referenziati da altri comandi. Lo scopo principale di questo comando \u00e8 fornire informazioni all'interfaccia utente senza dover analizzare l'intero file gcode. Le definizioni degli oggetti sono denominate per consentire agli utenti di selezionare facilmente un oggetto da escludere e possono essere forniti metadati aggiuntivi per consentire la visualizzazione grafica dell'annullamento. I metadati attualmente definiti includono una coordinata X,Y \"CENTRO\" e un elenco \"POLYGON\" di punti X,Y che rappresentano un contorno minimo dell'oggetto. Potrebbe trattarsi di un semplice riquadro di delimitazione o di uno guscio complicato per mostrare visualizzazioni pi\u00f9 dettagliate degli oggetti stampati. Soprattutto quando i file gcode includono pi\u00f9 parti con regioni di delimitazione sovrapposte, i punti centrali diventano difficili da distinguere visivamente. POLYGONS deve essere un array compatibile con json di tuple punto [X,Y] senza spazi. Ulteriori parametri verranno salvati come stringhe nella definizione dell'oggetto e forniti negli aggiornamenti di stato. EXCLUDE_OBJECT_DEFINE NAME=calibration_pyramid CENTER=50,50 POLYGON=[[40,40],[50,60],[60,40]] All available G-Code commands are documented in the G-Code Reference Informazioni sullo stato \u00b6 The state of this module is provided to clients by the exclude_object status . Lo stato viene ripristinato quando: Il firmware di Klipper viene riavviato. C'\u00e8 un reset della [virtual_sdcard] . In particolare, questo viene ripristinato da Klipper all'inizio di una stampa. Quando viene emesso un comando EXCLUDE_OBJECT_DEFINE RESET=1 . L'elenco degli oggetti definiti \u00e8 rappresentato nel campo di stato exclude_object.objects . In un file gcode ben definito, questo sar\u00e0 fatto con i comandi EXCLUDE_OBJECT_DEFINE all'inizio del file. Ci\u00f2 fornir\u00e0 ai client i nomi e le coordinate degli oggetti in modo che l'interfaccia utente possa fornire una rappresentazione grafica degli oggetti, se lo si desidera. Man mano che la stampa procede, il campo di stato exclude_object.current_object verr\u00e0 aggiornato mentre Klipper elabora i comandi EXCLUDE_OBJECT_START e EXCLUDE_OBJECT_END . Il campo oggetto_corrente sar\u00e0 impostato anche se l'oggetto \u00e8 stato escluso. Gli oggetti non definiti contrassegnati con un EXCLUDE_OBJECT_START verranno aggiunti agli oggetti conosciuti per facilitare i suggerimenti dell'interfaccia utente, senza metadati aggiuntivi. Quando vengono emessi i comandi EXCLUDE_OBJECT , l'elenco degli oggetti esclusi viene fornito nell'array exclude_object.excluded_objects . Poich\u00e9 Klipper guarda avanti per elaborare il prossimo gcode, potrebbe esserci un ritardo tra l'emissione del comando e l'aggiornamento dello stato.","title":"Escludi oggetti"},{"location":"Exclude_Object.html#escludi-oggetti","text":"The [exclude_object] module allows Klipper to exclude objects while a print is in progress. To enable this feature include an exclude_object config section (also see the command reference and sample-macros.cfg file for a Marlin/RepRapFirmware compatible M486 G-Code macro.) A differenza di altre opzioni del firmware della stampante 3D, una stampante che esegue Klipper utilizza una suite di componenti e gli utenti hanno molte opzioni tra cui scegliere. Pertanto, al fine di fornire un'esperienza utente coerente, il modulo [exclude_object] stabilir\u00e0 un contratto o una sorta di API. Il contratto copre il contenuto del file gcode, come viene controllato lo stato interno del modulo e come tale stato viene fornito ai client.","title":"Escludi oggetti"},{"location":"Exclude_Object.html#panoramica-del-flusso-di-lavoro","text":"Un tipico flusso di lavoro per la stampa di un file potrebbe essere simile a: Lo slicing \u00e8 completato e il file viene caricato per la stampa. Durante il caricamento, il file viene elaborato e gli indicatori [exclude_object] vengono aggiunti al file. In alternativa, i filtri dei dati possono essere configurati per preparare i marcatori di esclusione degli oggetti in modo nativo o nella propria fase di pre-elaborazione. All'avvio della stampa, Klipper ripristiner\u00e0 [exclude_object] status . Quando Klipper elabora il blocco EXCLUDE_OBJECT_DEFINE , aggiorner\u00e0 lo stato con gli oggetti conosciuti e lo passer\u00e0 ai client. Il client pu\u00f2 utilizzare tali informazioni per presentare un'interfaccia all'utente in modo che sia possibile tenere traccia dei progressi. Klipper aggiorner\u00e0 lo stato per includere l'oggetto attualmente in stampa che il client pu\u00f2 utilizzare per scopi di visualizzazione. Se l'utente richiede la cancellazione di un oggetto, il client invier\u00e0 un comando EXCLUDE_OBJECT NAME=<nome> a Klipper. Quando Klipper elabora il comando, aggiunger\u00e0 l'oggetto all'elenco degli oggetti esclusi e aggiorner\u00e0 lo stato per i client. Il client ricever\u00e0 lo stato aggiornato da Klipper e potr\u00e0 utilizzare tali informazioni per aggiornare lo stato dell'oggetto nell'interfaccia utente. Al termine della stampa, lo stato [exclude_object] continuer\u00e0 a essere disponibile fino a quando un'altra azione non lo reimposta.","title":"Panoramica del flusso di lavoro"},{"location":"Exclude_Object.html#il-file-gcode","text":"L'elaborazione specializzata del gcode necessaria per supportare l'esclusione di oggetti non rientra negli obiettivi di progettazione principali di Klipper. Pertanto, questo modulo richiede che il file venga elaborato prima di essere inviato a Klipper per la stampa. L'utilizzo di uno script di post-elaborazione nello slicer o il middleware che elabora il file durante il caricamento sono due possibilit\u00e0 per preparare il file per Klipper. Uno script di post-elaborazione di riferimento \u00e8 disponibile sia come eseguibile che come libreria Python, vedere cancelobject-preprocessor .","title":"Il file GCode"},{"location":"Exclude_Object.html#definizioni-di-oggetti","text":"Il comando EXCLUDE_OBJECT_DEFINE viene utilizzato per fornire un riepilogo di ogni oggetto nel file gcode da stampare. Fornisce un riepilogo di un oggetto nel file. Gli oggetti non hanno bisogno di essere definiti per essere referenziati da altri comandi. Lo scopo principale di questo comando \u00e8 fornire informazioni all'interfaccia utente senza dover analizzare l'intero file gcode. Le definizioni degli oggetti sono denominate per consentire agli utenti di selezionare facilmente un oggetto da escludere e possono essere forniti metadati aggiuntivi per consentire la visualizzazione grafica dell'annullamento. I metadati attualmente definiti includono una coordinata X,Y \"CENTRO\" e un elenco \"POLYGON\" di punti X,Y che rappresentano un contorno minimo dell'oggetto. Potrebbe trattarsi di un semplice riquadro di delimitazione o di uno guscio complicato per mostrare visualizzazioni pi\u00f9 dettagliate degli oggetti stampati. Soprattutto quando i file gcode includono pi\u00f9 parti con regioni di delimitazione sovrapposte, i punti centrali diventano difficili da distinguere visivamente. POLYGONS deve essere un array compatibile con json di tuple punto [X,Y] senza spazi. Ulteriori parametri verranno salvati come stringhe nella definizione dell'oggetto e forniti negli aggiornamenti di stato. EXCLUDE_OBJECT_DEFINE NAME=calibration_pyramid CENTER=50,50 POLYGON=[[40,40],[50,60],[60,40]] All available G-Code commands are documented in the G-Code Reference","title":"Definizioni di oggetti"},{"location":"Exclude_Object.html#informazioni-sullo-stato","text":"The state of this module is provided to clients by the exclude_object status . Lo stato viene ripristinato quando: Il firmware di Klipper viene riavviato. C'\u00e8 un reset della [virtual_sdcard] . In particolare, questo viene ripristinato da Klipper all'inizio di una stampa. Quando viene emesso un comando EXCLUDE_OBJECT_DEFINE RESET=1 . L'elenco degli oggetti definiti \u00e8 rappresentato nel campo di stato exclude_object.objects . In un file gcode ben definito, questo sar\u00e0 fatto con i comandi EXCLUDE_OBJECT_DEFINE all'inizio del file. Ci\u00f2 fornir\u00e0 ai client i nomi e le coordinate degli oggetti in modo che l'interfaccia utente possa fornire una rappresentazione grafica degli oggetti, se lo si desidera. Man mano che la stampa procede, il campo di stato exclude_object.current_object verr\u00e0 aggiornato mentre Klipper elabora i comandi EXCLUDE_OBJECT_START e EXCLUDE_OBJECT_END . Il campo oggetto_corrente sar\u00e0 impostato anche se l'oggetto \u00e8 stato escluso. Gli oggetti non definiti contrassegnati con un EXCLUDE_OBJECT_START verranno aggiunti agli oggetti conosciuti per facilitare i suggerimenti dell'interfaccia utente, senza metadati aggiuntivi. Quando vengono emessi i comandi EXCLUDE_OBJECT , l'elenco degli oggetti esclusi viene fornito nell'array exclude_object.excluded_objects . Poich\u00e9 Klipper guarda avanti per elaborare il prossimo gcode, potrebbe esserci un ritardo tra l'emissione del comando e l'aggiornamento dello stato.","title":"Informazioni sullo stato"},{"location":"FAQ.html","text":"Domande frequenti \u00b6 Come posso donare al progetto? \u00b6 Grazie per il vostro sostegno. Per informazioni, vedere la Pagina degli sponsor . Come faccio a calcolare il parametro di configurazione rotation_distance? \u00b6 Vedere il rotation distance document . Dov'\u00e8 la mia porta seriale? \u00b6 Il modo generico per trovare una porta seriale USB \u00e8 eseguire ls /dev/serial/by-id/* da un terminale ssh sulla macchina host. Probabilmente produrr\u00e0 un output simile al seguente: /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 Il nome trovato nel comando precedente \u00e8 stabile ed \u00e8 possibile utilizzarlo nel file di configurazione e durante il flashing del codice del microcontrollore. Ad esempio, un comando flash potrebbe essere simile a: sudo service klipper stop make flash FLASH_DEVICE=/dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 sudo service klipper start e la configurazione aggiornata potrebbe essere simile a: [mcu] serial: /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 Assicurati di copiare e incollare il nome dal comando \"ls\" che hai eseguito sopra poich\u00e9 il nome sar\u00e0 diverso per ciascuna stampante. Se stai usando pi\u00f9 microcontrollori e non hanno ID univoci (comune sulle schede con un chip USB CH340), segui invece le indicazioni sopra usando il comando ls /dev/serial/by-path/* . Quando il microcontrollore si riavvia, il dispositivo cambia in /dev/ttyUSB1 \u00b6 egui le istruzioni nella sezione \" Where's my serial port? \" per evitare che ci\u00f2 accada. Il comando \"make flash\" non funziona \u00b6 Il codice tenta di eseguire il flashing del dispositivo utilizzando il metodo pi\u00f9 comune per ciascuna piattaforma. Sfortunatamente, c'\u00e8 molta variabilit\u00e0 nei metodi di flashing, quindi il comando \"make flash\" potrebbe non funzionare su tutte le schede. Se si verifica un errore intermittente o si dispone di una configurazione standard, ricontrolla che Klipper non sia in esecuzione durante il flashing (sudo service klipper stop), assicurati che OctoPrint non stia tentando di connettersi direttamente al dispositivo (apri il scheda Connessione nella pagina Web e fare clic su Disconnetti se la porta seriale \u00e8 impostata sul dispositivo) e assicurarsi che FLASH_DEVICE sia impostato correttamente per la scheda (consultare la question above . Tuttavia, se \"make flash\" non funziona per la tua scheda, dovrai eseguire il flashing manualmente. Verificare se nella config directory \u00e8 presente un file di configurazione con istruzioni specifiche per il flashing del dispositivo. Inoltre, controlla la documentazione del produttore della scheda per vedere se descrive come eseguire il flashing del dispositivo. Infine, potrebbe essere possibile eseguire manualmente il flashing del dispositivo utilizzando strumenti come \"avrdude\" o \"bossac\" - vedere il bootloader document per ulteriori informazioni. Come posso modificare la velocit\u00e0 di trasmissione seriale? \u00b6 Il baud rate consigliato per Klipper \u00e8 250000. Questo baud rate funziona bene su tutte le schede di microcontrollore supportate da Klipper. Se hai trovato una guida online che consiglia una velocit\u00e0 di trasmissione diversa, ignora quella parte della guida e continua con il valore predefinito di 250000. Se si desidera comunque modificare il baud rate, sar\u00e0 necessario configurare la nuova velocit\u00e0 nel microcontrollore (durante make menuconfig ) e il codice aggiornato dovr\u00e0 essere compilato e flashato sul microcontrollore. Anche il file Klipper printer.cfg dovr\u00e0 essere aggiornato in modo che corrisponda a tale velocit\u00e0 di trasmissione (consultare il config reference per i dettagli). Per esempio: [mcu] baud: 250000 La velocit\u00e0 di trasmissione mostrata sulla pagina Web di OctoPrint non ha alcun impatto sulla velocit\u00e0 di trasmissione interna del microcontrollore Klipper. Impostare sempre la velocit\u00e0 di trasmissione OctoPrint su 250000 quando si utilizza Klipper. La velocit\u00e0 in baud del microcontrollore Klipper non \u00e8 correlata alla velocit\u00e0 in baud del bootloader del microcontrollore. Vedere il bootloader document per ulteriori informazioni sui bootloader. Posso eseguire Klipper su qualcosa di diverso da un Raspberry Pi 3? \u00b6 L'hardware consigliato \u00e8 un Raspberry Pi 2, Raspberry Pi 3 o Raspberry Pi 4. Klipper funzioner\u00e0 su un Raspberry Pi 1 e su Raspberry Pi Zero, ma queste schede non hanno una potenza di elaborazione sufficiente per eseguire bene OctoPrint. \u00c8 normale che si verifichino interruzioni di stampa su queste macchine pi\u00f9 lente quando si stampa direttamente da OctoPrint. (La stampante potrebbe muoversi pi\u00f9 velocemente di quanto OctoPrint possa inviare comandi di movimento.) Se desideri comunque eseguire su una di queste schede pi\u00f9 lente, considera l'utilizzo della funzione \"virtual_sdcard\" durante la stampa (consulta config reference per dettagli). Per l'esecuzione su Beaglebone, vedere le Istruzioni di installazione specifiche di Beaglebone . Klipper \u00e8 stato eseguito su altre macchine. Il software host Klipper richiede solo Python in esecuzione su un computer Linux (o simile). Tuttavia, se desideri eseguirlo su una macchina diversa, avrai bisogno della conoscenza dell'amministratore Linux per installare i prerequisiti di sistema per quella particolare macchina. Consulta lo script install-octopi.sh per ulteriori informazioni sui passaggi necessari. Se stai cercando di eseguire il software host Klipper su un chip di fascia bassa, tieni presente che, come minimo, \u00e8 necessaria una macchina con hardware a \"virgola mobile a doppia precisione\". Se stai cercando di eseguire il software host Klipper su un desktop generico condiviso o una macchina di classe server, tieni presente che Klipper ha alcuni requisiti di scheduling in tempo reale. Se, durante una stampa, il computer host esegue anche un'intensa attivit\u00e0 di elaborazione generica (come deframmentazione di un disco rigido, rendering 3D, scambi pesanti e cos\u00ec via), Klipper potrebbe segnalare errori di stampa. Nota: se non stai utilizzando un'immagine OctoPi, tieni presente che diverse distribuzioni Linux abilitano un pacchetto \"ModemManager\" (o simile) che pu\u00f2 interrompere la comunicazione seriale. (Il che pu\u00f2 far s\u00ec che Klipper riporti errori apparentemente casuali \"Comunicazione persa con MCU\".) Se installi Klipper su una di queste distribuzioni potresti dover disabilitare quel pacchetto. Posso eseguire pi\u00f9 istanze di Klipper sulla stessa macchina host? \u00b6 \u00c8 possibile eseguire pi\u00f9 istanze del software host Klipper, ma per farlo \u00e8 necessaria la conoscenza dell'amministratore Linux. Gli script di installazione di Klipper determinano l'esecuzione del seguente comando Unix: ~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer.cfg -l /tmp/klippy.log \u00c8 possibile eseguire pi\u00f9 istanze del comando precedente purch\u00e9 ogni istanza abbia il proprio file di configurazione della stampante, il proprio file di registro e il proprio pseudo-tty. Per esempio: ~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer2.cfg -l /tmp/klippy2.log -I /tmp/printer2 Se scegli di farlo, dovrai implementare gli script di avvio, arresto e installazione necessari (se presenti). Lo script install-octopi.sh e lo script klipper-start.sh possono essere utili come esempi. Devo usare OctoPrint? \u00b6 Il software Klipper non dipende da OctoPrint. \u00c8 possibile utilizzare un software alternativo per inviare comandi a Klipper, ma ci\u00f2 richiede la conoscenza dell'amministratore Linux. Klipper crea una \"porta seriale virtuale\" tramite il file \"/tmp/printer\" ed emula una classica interfaccia seriale per stampante 3D tramite quel file. In generale, un software alternativo pu\u00f2 funzionare con Klipper purch\u00e9 possa essere configurato per utilizzare \"/tmp/printer\" per la porta seriale della stampante. Perch\u00e9 non riesco a spostare lo stepper prima di riposizionare la stampante? \u00b6 Il codice fa questo per ridurre la possibilit\u00e0 di comandare accidentalmente la testa nel piatto o altri limiti. Una volta che la stampante \u00e8 stata localizzata, il software tenta di verificare che ogni mossa rientri nella posizione_min/max definita nel file di configurazione. Se i motori sono disabilitati (tramite un comando M84 o M18), i motori dovranno essere nuovamente riposizionati prima del movimento. Se desideri spostare la testina dopo aver annullato una stampa tramite OctoPrint, considera di modificare la sequenza di annullamento di OctoPrint per farlo per te. \u00c8 configurato in OctoPrint tramite un browser web in: Impostazioni-> Script GCODE | Settings->GCODE Scripts Se desideri spostare la testina al termine di una stampa, considera di aggiungere il movimento desiderato alla sezione \"G-code personalizzato\" del tuo slicer. Se la stampante richiede un movimento aggiuntivo come parte del processo stesso di homing (o fondamentalmente non ha un processo di homing), considera l'utilizzo di una sezione safe_z_home o homing_override nel file di configurazione. Se \u00e8 necessario spostare uno stepper per scopi diagnostici o di debug, considerare l'aggiunta di una sezione force_move al file di configurazione. Vedere config reference per ulteriori dettagli su queste opzioni. Perch\u00e9 Z position_endstop \u00e8 impostato su 0.5 nelle configurazioni predefinite? \u00b6 Per le stampanti cartesiane Z position_endstop specifica la distanza dell'ugello dal piatto quando si attiva ilfinecorsa. Se possibile, si consiglia di utilizzare un finecorsa Z-max e di tornare a casa lontano dal piatto (in quanto ci\u00f2 riduce il rischio di collisioni con il piatto). Tuttavia, se ci si deve avvicinare al piatto, si consiglia di posizionare il finecorsa in modo che si attivi quando la bocchetta \u00e8 ancora a una piccola distanza dal piatto. In questo modo, durante l'homing dell'asse, si fermer\u00e0 prima che l'ugello tocchi il letto. Per ulteriori informazioni, vedere il bed level document . Ho convertito la mia configurazione da Marlin e gli assi X/Y funzionano bene, ma ottengo solo un rumore stridente durante homing dell'asse Z \u00b6 Risposta breve: in primo luogo, assicurati di aver verificato la configurazione dello stepper come descritto nel config check document . Se il problema persiste, provare a ridurre l'impostazione max_z_velocity nella configurazione della stampante. Risposta lunga: in pratica Marlin pu\u00f2 in genere fare solo un passo a una velocit\u00e0 di circa 10000 passi al secondo. Se gli viene richiesto di muoversi a una velocit\u00e0 che richiederebbe una velocit\u00e0 di passo pi\u00f9 alta, Marlin generalmente far\u00e0 un passo pi\u00f9 veloce possibile. Klipper \u00e8 in grado di raggiungere velocit\u00e0 di passo molto pi\u00f9 elevate, ma il motore passo-passo potrebbe non avere una coppia sufficiente per muoversi a una velocit\u00e0 pi\u00f9 elevata. Quindi, per un asse Z con un rapporto di trasmissione elevato o un'impostazione di micropassi elevata, l'effettiva velocit\u00e0 max_z_ottenibile potrebbe essere inferiore a quella configurata in Marlin. Il mio driver TMC del motore si spegne nel mezzo di una stampa \u00b6 Se si utilizza il driver TMC2208 (o TMC2224) in \"modalit\u00e0 standalone\", assicurarsi di utilizzare l' latest version of Klipper . Una soluzione alternativa per un problema del driver \"stealthchop\" TMC2208 \u00e8 stata aggiunta a Klipper a met\u00e0 marzo del 2020. Continuo a ricevere errori casuali \"Comunicazione persa con MCU\" |\"Lost communication with MCU\" \u00b6 Ci\u00f2 \u00e8 comunemente causato da errori hardware sulla connessione USB tra la macchina host e il microcontrollore. Cose da cercare: Utilizzare un cavo USB di buona qualit\u00e0 tra la macchina host e il microcontrollore. Assicurati che i connettori siano ben saldi. Se si utilizza un Raspberry Pi, utilizzare un alimentatore di buona qualit\u00e0 per il Raspberry Pi e utilizzare un cavo USB di buona qualit\u00e0 per collegare quell'alimentatore al Pi. Se ricevi avvisi di \"sottotensione\" da OctoPrint, questo \u00e8 correlato all'alimentatore e deve essere risolto. Assicurarsi che l'alimentazione della stampante non sia sovraccarica. (Le fluttuazioni di alimentazione del chip USB del microcontrollore possono comportare il reset di quel chip.) Verificare che i cavi dello stepper, del riscaldatore e di altri cavi della stampante non siano arricciati o sfilacciati. (Il movimento della stampante pu\u00f2 sollecitare un cavo difettoso causandone la perdita di contatto, un cortocircuito breve o la generazione di rumore eccessivo.) Sono stati segnalati rumori USB elevati quando sia l'alimentazione della stampante che l'alimentazione a 5 V dell'host sono mescolate. (Se si scopre che il microcontrollore si accende quando l'alimentazione della stampante \u00e8 accesa o il cavo USB \u00e8 collegato, significa che gli alimentatori da 5 V vengono mescolati.) Pu\u00f2 essere utile configurare il microcontrollore da utilizzare alimentazione da una sola fonte. (In alternativa, se la scheda del microcontrollore non \u00e8 in grado di configurare la sua fonte di alimentazione, \u00e8 possibile modificare un cavo USB in modo che non trasmetta alimentazione a 5V tra l'host e il microcontrollore.) Il mio Raspberry Pi continua a riavviarsi durante le stampe \u00b6 Questo \u00e8 molto probabilmente dovuto alle fluttuazioni di tensione. Segui gli stessi passaggi per la risoluzione dei problemi per un errore \"Comunicazione persa con MCU\" . Quando imposto restart_method=command il mio dispositivo AVR si blocca al riavvio \u00b6 Alcune vecchie versioni del bootloader AVR hanno un bug noto nella gestione degli eventi di watchdog. Questo in genere si manifesta quando il file printer.cfg ha restart_method impostato su \"command\". Quando si verifica il bug, il dispositivo AVR non risponder\u00e0 fino a quando l'alimentazione non viene rimossa e ricollegata al dispositivo (anche i LED di alimentazione o di stato potrebbero lampeggiare ripetutamente fino a quando l'alimentazione non viene rimossa). La soluzione alternativa \u00e8 utilizzare un restart_method diverso da \"command\" o eseguire il flashing di un bootloader aggiornato sul dispositivo AVR. Il flashing di un nuovo bootloader \u00e8 un passaggio che in genere richiede un programmatore esterno: vedere Bootloaders per ulteriori dettagli. I riscaldatori verranno lasciati accesi se il Raspberry Pi si arresta in modo anomalo? \u00b6 Il software \u00e8 stato progettato per impedirlo. Una volta che l'host abilita un riscaldatore, il software host deve confermare tale abilitazione ogni 5 secondi. Se il microcontrollore non riceve una conferma ogni 5 secondi, entra in uno stato di \"spegnimento\" progettato per spegnere tutti i riscaldatori e i motori passo-passo. Per ulteriori dettagli, vedere il comando \"config_digital_out\" nel documento Comandi MCU . Inoltre, il software del microcontrollore \u00e8 configurato con un intervallo di temperatura minimo e massimo per ciascun riscaldatore all'avvio (consultare i parametri min_temp e max_temp in config reference per i dettagli). Se il microcontrollore rileva che la temperatura \u00e8 al di fuori di tale intervallo, entrer\u00e0 anche in uno stato di \"spegnimento\". Separatamente, il software host implementa anche il codice per verificare che i riscaldatori e i sensori di temperatura funzionino correttamente. Vedere il riferimento di configurazione per ulteriori dettagli. Come posso convertire un numero di pin Marlin in un nome pin di Klipper? \u00b6 Risposta breve: una mappatura \u00e8 disponibile nel file sample-aliases.cfg . Usa quel file come guida per trovare i nomi effettivi dei pin del microcontrollorei. (\u00c8 anche possibile copiare la relativa sezione di configurazione board_pins nel file di configurazione e utilizzare gli alias nella configurazione, ma \u00e8 preferibile tradurre e utilizzare i nomi dei pin del microcontrollore effettivi.) Nota che il file sample-aliases.cfg usa nomi di pin che iniziano con il prefisso \"ar\" invece di \"D\" (ad esempio, il pin Arduino D23 \u00e8 alias Klipper ar23 ) e il prefisso \"analog\" invece di \"A \" (ad esempio, il pin Arduino A14 \u00e8 alias di Klipper analog14 ). Risposta lunga: Klipper utilizza i nomi dei pin standard definiti dal microcontrollore. Sui chip Atmega questi pin hardware hanno nomi come PA4 , PC7 o PD2 . Tempo fa, il progetto Arduino ha deciso di evitare di utilizzare i nomi hardware standard a favore dei propri nomi pin basati su numeri incrementali: questi nomi Arduino generalmente assomigliano a \"D23\" o \"A14\". Questa \u00e8 stata una scelta sfortunata che ha portato a una grande confusione. In particolare, i numeri dei pin di Arduino spesso non si traducono negli stessi nomi hardware. Ad esempio, D21 \u00e8 PD0 su una comune scheda Arduino, ma \u00e8 PC7 su un'altra comune scheda Arduino. Per evitare questa confusione, il codice di base di Klipper utilizza i nomi dei pin standard definiti dal microcontrollore. Devo collegare il mio dispositivo a un tipo specifico di pin del microcontrollore? \u00b6 Dipende dal tipo di dispositivo e dal tipo di pin: Pin ADC (o pin analogici): per termistori e sensori \"analogici\" simili, il dispositivo deve essere collegato a un pin compatibile con \"analogico\" o \"ADC\" sul microcontrollore. Se configuri Klipper per utilizzare un pin che non \u00e8 compatibile con l'analogico, Klipper segnaler\u00e0 un errore \"Non un pin ADC valido\". Pin PWM (o pin Timer): Klipper non utilizza PWM hardware per impostazione predefinita per nessun dispositivo. Quindi, in generale, \u00e8 possibile collegare riscaldatori, ventole e dispositivi simili a qualsiasi pin IO generico. Tuttavia, le ventole e i dispositivi output_pin possono essere opzionalmente configurati per utilizzare hardware_pwm: True , nel qual caso il microcontrollore deve supportare PWM hardware sul pin (altrimenti, Klipper segnaler\u00e0 un errore \"pin PWM non valido\"). Pin IRQ (o pin di interrupt): Klipper non utilizza gli interrupt hardware sui pin IO, quindi non \u00e8 mai necessario collegare un dispositivo a uno di questi pin del microcontrollore. Pin SPI: quando si utilizza l'SPI hardware, \u00e8 necessario collegare i pin ai pin SPI del microcontrollore. Tuttavia, la maggior parte dei dispositivi pu\u00f2 essere configurata per utilizzare \"SPI software\", nel qual caso \u00e8 possibile utilizzare qualsiasi pin IO generico. Pin I2C: quando si utilizza I2C \u00e8 necessario collegare i pin ai pin compatibili con I2C del microcontrollore. Altri dispositivi possono essere collegati a qualsiasi pin IO generico. Ad esempio, stepper, riscaldatori, ventole, sonde Z, servocomandi, LED, comuni display LCD hd44780/st7920, la linea di controllo Trinamic UART pu\u00f2 essere collegata a qualsiasi pin IO generico. Come posso annullare una richiesta di \"attesa temperatura\" M109/M190? \u00b6 Passare alla scheda del terminale OctoPrint ed emettere un comando M112 nel terminale. Il comando M112 far\u00e0 entrare Klipper in uno stato di \"arresto\" e causer\u00e0 la disconnessione di OctoPrint da Klipper. Passare all'area di connessione di OctoPrint e fare clic su \"Connetti\" per fare in modo che OctoPrint si riconnetta. Torna alla scheda del terminale ed emetti un comando FIRMWARE_RESTART per cancellare lo stato di errore di Klipper. Dopo aver completato questa sequenza, la precedente richiesta di riscaldamento verr\u00e0 annullata e potrebbe essere avviata una nuova stampa. Posso scoprire se la stampante ha perso dei passaggi? \u00b6 In un certo senso s\u00ec. Avviare la stampante, emettere un comando GET_POSITION , eseguire la stampa, tornare a casa ed emettere un altro GET_POSITION . Quindi confronta i valori nella riga mcu: . Questo potrebbe essere utile per regolare impostazioni come correnti, accelerazioni e velocit\u00e0 del motore passo-passo senza dover effettivamente stampare qualcosa e sprecare il filamento: basta eseguire alcuni movimenti ad alta velocit\u00e0 tra i comandi GET_POSITION . Si noti che gli stessi interruttori di fine corsa tendono a attivarsi in posizioni leggermente diverse, quindi una differenza di un paio di micropassi \u00e8 probabilmente il risultato di imprecisioni di fine corsa. Un motore passo-passo stesso pu\u00f2 perdere passi solo con incrementi di 4 passi completi. (Quindi, se si utilizzano 16 micropassi, un passo perso sullo stepper comporterebbe lo spegnimento del contatore di passi \"mcu:\" di un multiplo di 64 micropassi.) Perch\u00e9 Klipper segnala errori? Ho perso la mia stampa! \u00b6 Risposta breve: vogliamo sapere se le nostre stampanti rilevano un problema in modo che il problema sottostante possa essere risolto e possiamo ottenere stampe di ottima qualit\u00e0. Non vogliamo assolutamente che le nostre stampanti producano in silenzio stampe di bassa qualit\u00e0. Risposta lunga: Klipper \u00e8 stato progettato per risolvere automaticamente molti problemi transitori. Ad esempio, rileva automaticamente gli errori di comunicazione e li ritrasmette; pianifica le azioni in anticipo e bufferizza i comandi su pi\u00f9 livelli per consentire tempi precisi anche con interferenze intermittenti. Tuttavia, se il software rileva un errore dal quale non pu\u00f2 essere ripristinato, se gli viene ordinato di eseguire un'azione non valida o se rileva che \u00e8 irrimediabilmente incapace di eseguire l'attivit\u00e0 comandata, Klipper segnaler\u00e0 un errore. In queste situazioni c'\u00e8 un alto rischio di produrre una stampa di bassa qualit\u00e0 (o peggio). Si spera che avvisare gli utenti consentir\u00e0 loro di risolvere il problema sottostante e migliorare la qualit\u00e0 complessiva delle loro stampe. Ci sono alcune domande correlate: perch\u00e9 Klipper non mette invece in pausa la stampa? Segnalare invece un avviso? Verificare la presenza di errori prima della stampa? Ignorare gli errori nei comandi digitati dall'utente? eccetera? Attualmente Klipper legge i comandi utilizzando il protocollo G-Code e sfortunatamente il protocollo di comando G-Code non \u00e8 sufficientemente flessibile per rendere pratiche queste alternative oggi. C'\u00e8 l'interesse degli sviluppatori nel migliorare l'esperienza dell'utente durante eventi anomali, ma si prevede che ci\u00f2 richieder\u00e0 un notevole lavoro infrastrutturale (incluso un passaggio dal G-Code). Come si esegue l'aggiornamento al software pi\u00f9 recente? \u00b6 Il primo passaggio per l'aggiornamento del software consiste nell'esaminare l'ultimo documento config changes . A volte, vengono apportate modifiche al software che richiedono agli utenti di aggiornare le proprie impostazioni come parte di un aggiornamento del software. \u00c8 una buona idea rivedere questo documento prima dell'aggiornamento. Quando sei pronto per l'aggiornamento, il metodo generale \u00e8 quello di entrare in Raspberry Pi ed eseguire: cd ~/klipper git pull ~/klipper/scripts/install-octopi.sh Quindi si pu\u00f2 ricompilare e flashare il codice del microcontrollore. Per esempio: make menuconfig make clean make sudo service klipper stop make flash FLASH_DEVICE=/dev/ttyACM0 sudo service klipper start Tuttavia, capita spesso che cambi solo il software host. In questo caso \u00e8 possibile aggiornare e riavviare solo il software host con: cd ~/klipper git pull sudo service klipper restart Se dopo aver utilizzato questo collegamento il software avverte della necessit\u00e0 di eseguire il reflash del microcontrollore o si verifica qualche altro errore insolito, seguire i passaggi completi di aggiornamento descritti sopra. Se gli errori persistono, ricontrolla il documento config changes , poich\u00e9 potrebbe essere necessario modificare la configurazione della stampante. Si noti che i comandi g-code RESTART e FIRMWARE_RESTART non caricano il nuovo software: i comandi \"sudo service klipper restart\" e \"make flash\" di cui sopra sono necessari affinch\u00e9 una modifica del software abbia effetto. Come faccio a disinstallare Klipper? \u00b6 Dal alto del firmware, non deve succedere nulla di speciale. Basta seguire le indicazioni per il flashing del nuovo firmware. Dal lato del raspberry pi, uno script di disinstallazione \u00e8 disponibile in scripts/klipper-uninstall.sh . Per esempio: sudo ~/klipper/scripts/klipper-uninstall.sh rm -rf ~/klippy-env ~/klipper","title":"Domande frequenti"},{"location":"FAQ.html#domande-frequenti","text":"","title":"Domande frequenti"},{"location":"FAQ.html#come-posso-donare-al-progetto","text":"Grazie per il vostro sostegno. Per informazioni, vedere la Pagina degli sponsor .","title":"Come posso donare al progetto?"},{"location":"FAQ.html#come-faccio-a-calcolare-il-parametro-di-configurazione-rotation_distance","text":"Vedere il rotation distance document .","title":"Come faccio a calcolare il parametro di configurazione rotation_distance?"},{"location":"FAQ.html#dove-la-mia-porta-seriale","text":"Il modo generico per trovare una porta seriale USB \u00e8 eseguire ls /dev/serial/by-id/* da un terminale ssh sulla macchina host. Probabilmente produrr\u00e0 un output simile al seguente: /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 Il nome trovato nel comando precedente \u00e8 stabile ed \u00e8 possibile utilizzarlo nel file di configurazione e durante il flashing del codice del microcontrollore. Ad esempio, un comando flash potrebbe essere simile a: sudo service klipper stop make flash FLASH_DEVICE=/dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 sudo service klipper start e la configurazione aggiornata potrebbe essere simile a: [mcu] serial: /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 Assicurati di copiare e incollare il nome dal comando \"ls\" che hai eseguito sopra poich\u00e9 il nome sar\u00e0 diverso per ciascuna stampante. Se stai usando pi\u00f9 microcontrollori e non hanno ID univoci (comune sulle schede con un chip USB CH340), segui invece le indicazioni sopra usando il comando ls /dev/serial/by-path/* .","title":"Dov'\u00e8 la mia porta seriale?"},{"location":"FAQ.html#quando-il-microcontrollore-si-riavvia-il-dispositivo-cambia-in-devttyusb1","text":"egui le istruzioni nella sezione \" Where's my serial port? \" per evitare che ci\u00f2 accada.","title":"Quando il microcontrollore si riavvia, il dispositivo cambia in /dev/ttyUSB1"},{"location":"FAQ.html#il-comando-make-flash-non-funziona","text":"Il codice tenta di eseguire il flashing del dispositivo utilizzando il metodo pi\u00f9 comune per ciascuna piattaforma. Sfortunatamente, c'\u00e8 molta variabilit\u00e0 nei metodi di flashing, quindi il comando \"make flash\" potrebbe non funzionare su tutte le schede. Se si verifica un errore intermittente o si dispone di una configurazione standard, ricontrolla che Klipper non sia in esecuzione durante il flashing (sudo service klipper stop), assicurati che OctoPrint non stia tentando di connettersi direttamente al dispositivo (apri il scheda Connessione nella pagina Web e fare clic su Disconnetti se la porta seriale \u00e8 impostata sul dispositivo) e assicurarsi che FLASH_DEVICE sia impostato correttamente per la scheda (consultare la question above . Tuttavia, se \"make flash\" non funziona per la tua scheda, dovrai eseguire il flashing manualmente. Verificare se nella config directory \u00e8 presente un file di configurazione con istruzioni specifiche per il flashing del dispositivo. Inoltre, controlla la documentazione del produttore della scheda per vedere se descrive come eseguire il flashing del dispositivo. Infine, potrebbe essere possibile eseguire manualmente il flashing del dispositivo utilizzando strumenti come \"avrdude\" o \"bossac\" - vedere il bootloader document per ulteriori informazioni.","title":"Il comando \"make flash\" non funziona"},{"location":"FAQ.html#come-posso-modificare-la-velocita-di-trasmissione-seriale","text":"Il baud rate consigliato per Klipper \u00e8 250000. Questo baud rate funziona bene su tutte le schede di microcontrollore supportate da Klipper. Se hai trovato una guida online che consiglia una velocit\u00e0 di trasmissione diversa, ignora quella parte della guida e continua con il valore predefinito di 250000. Se si desidera comunque modificare il baud rate, sar\u00e0 necessario configurare la nuova velocit\u00e0 nel microcontrollore (durante make menuconfig ) e il codice aggiornato dovr\u00e0 essere compilato e flashato sul microcontrollore. Anche il file Klipper printer.cfg dovr\u00e0 essere aggiornato in modo che corrisponda a tale velocit\u00e0 di trasmissione (consultare il config reference per i dettagli). Per esempio: [mcu] baud: 250000 La velocit\u00e0 di trasmissione mostrata sulla pagina Web di OctoPrint non ha alcun impatto sulla velocit\u00e0 di trasmissione interna del microcontrollore Klipper. Impostare sempre la velocit\u00e0 di trasmissione OctoPrint su 250000 quando si utilizza Klipper. La velocit\u00e0 in baud del microcontrollore Klipper non \u00e8 correlata alla velocit\u00e0 in baud del bootloader del microcontrollore. Vedere il bootloader document per ulteriori informazioni sui bootloader.","title":"Come posso modificare la velocit\u00e0 di trasmissione seriale?"},{"location":"FAQ.html#posso-eseguire-klipper-su-qualcosa-di-diverso-da-un-raspberry-pi-3","text":"L'hardware consigliato \u00e8 un Raspberry Pi 2, Raspberry Pi 3 o Raspberry Pi 4. Klipper funzioner\u00e0 su un Raspberry Pi 1 e su Raspberry Pi Zero, ma queste schede non hanno una potenza di elaborazione sufficiente per eseguire bene OctoPrint. \u00c8 normale che si verifichino interruzioni di stampa su queste macchine pi\u00f9 lente quando si stampa direttamente da OctoPrint. (La stampante potrebbe muoversi pi\u00f9 velocemente di quanto OctoPrint possa inviare comandi di movimento.) Se desideri comunque eseguire su una di queste schede pi\u00f9 lente, considera l'utilizzo della funzione \"virtual_sdcard\" durante la stampa (consulta config reference per dettagli). Per l'esecuzione su Beaglebone, vedere le Istruzioni di installazione specifiche di Beaglebone . Klipper \u00e8 stato eseguito su altre macchine. Il software host Klipper richiede solo Python in esecuzione su un computer Linux (o simile). Tuttavia, se desideri eseguirlo su una macchina diversa, avrai bisogno della conoscenza dell'amministratore Linux per installare i prerequisiti di sistema per quella particolare macchina. Consulta lo script install-octopi.sh per ulteriori informazioni sui passaggi necessari. Se stai cercando di eseguire il software host Klipper su un chip di fascia bassa, tieni presente che, come minimo, \u00e8 necessaria una macchina con hardware a \"virgola mobile a doppia precisione\". Se stai cercando di eseguire il software host Klipper su un desktop generico condiviso o una macchina di classe server, tieni presente che Klipper ha alcuni requisiti di scheduling in tempo reale. Se, durante una stampa, il computer host esegue anche un'intensa attivit\u00e0 di elaborazione generica (come deframmentazione di un disco rigido, rendering 3D, scambi pesanti e cos\u00ec via), Klipper potrebbe segnalare errori di stampa. Nota: se non stai utilizzando un'immagine OctoPi, tieni presente che diverse distribuzioni Linux abilitano un pacchetto \"ModemManager\" (o simile) che pu\u00f2 interrompere la comunicazione seriale. (Il che pu\u00f2 far s\u00ec che Klipper riporti errori apparentemente casuali \"Comunicazione persa con MCU\".) Se installi Klipper su una di queste distribuzioni potresti dover disabilitare quel pacchetto.","title":"Posso eseguire Klipper su qualcosa di diverso da un Raspberry Pi 3?"},{"location":"FAQ.html#posso-eseguire-piu-istanze-di-klipper-sulla-stessa-macchina-host","text":"\u00c8 possibile eseguire pi\u00f9 istanze del software host Klipper, ma per farlo \u00e8 necessaria la conoscenza dell'amministratore Linux. Gli script di installazione di Klipper determinano l'esecuzione del seguente comando Unix: ~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer.cfg -l /tmp/klippy.log \u00c8 possibile eseguire pi\u00f9 istanze del comando precedente purch\u00e9 ogni istanza abbia il proprio file di configurazione della stampante, il proprio file di registro e il proprio pseudo-tty. Per esempio: ~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer2.cfg -l /tmp/klippy2.log -I /tmp/printer2 Se scegli di farlo, dovrai implementare gli script di avvio, arresto e installazione necessari (se presenti). Lo script install-octopi.sh e lo script klipper-start.sh possono essere utili come esempi.","title":"Posso eseguire pi\u00f9 istanze di Klipper sulla stessa macchina host?"},{"location":"FAQ.html#devo-usare-octoprint","text":"Il software Klipper non dipende da OctoPrint. \u00c8 possibile utilizzare un software alternativo per inviare comandi a Klipper, ma ci\u00f2 richiede la conoscenza dell'amministratore Linux. Klipper crea una \"porta seriale virtuale\" tramite il file \"/tmp/printer\" ed emula una classica interfaccia seriale per stampante 3D tramite quel file. In generale, un software alternativo pu\u00f2 funzionare con Klipper purch\u00e9 possa essere configurato per utilizzare \"/tmp/printer\" per la porta seriale della stampante.","title":"Devo usare OctoPrint?"},{"location":"FAQ.html#perche-non-riesco-a-spostare-lo-stepper-prima-di-riposizionare-la-stampante","text":"Il codice fa questo per ridurre la possibilit\u00e0 di comandare accidentalmente la testa nel piatto o altri limiti. Una volta che la stampante \u00e8 stata localizzata, il software tenta di verificare che ogni mossa rientri nella posizione_min/max definita nel file di configurazione. Se i motori sono disabilitati (tramite un comando M84 o M18), i motori dovranno essere nuovamente riposizionati prima del movimento. Se desideri spostare la testina dopo aver annullato una stampa tramite OctoPrint, considera di modificare la sequenza di annullamento di OctoPrint per farlo per te. \u00c8 configurato in OctoPrint tramite un browser web in: Impostazioni-> Script GCODE | Settings->GCODE Scripts Se desideri spostare la testina al termine di una stampa, considera di aggiungere il movimento desiderato alla sezione \"G-code personalizzato\" del tuo slicer. Se la stampante richiede un movimento aggiuntivo come parte del processo stesso di homing (o fondamentalmente non ha un processo di homing), considera l'utilizzo di una sezione safe_z_home o homing_override nel file di configurazione. Se \u00e8 necessario spostare uno stepper per scopi diagnostici o di debug, considerare l'aggiunta di una sezione force_move al file di configurazione. Vedere config reference per ulteriori dettagli su queste opzioni.","title":"Perch\u00e9 non riesco a spostare lo stepper prima di riposizionare la stampante?"},{"location":"FAQ.html#perche-z-position_endstop-e-impostato-su-05-nelle-configurazioni-predefinite","text":"Per le stampanti cartesiane Z position_endstop specifica la distanza dell'ugello dal piatto quando si attiva ilfinecorsa. Se possibile, si consiglia di utilizzare un finecorsa Z-max e di tornare a casa lontano dal piatto (in quanto ci\u00f2 riduce il rischio di collisioni con il piatto). Tuttavia, se ci si deve avvicinare al piatto, si consiglia di posizionare il finecorsa in modo che si attivi quando la bocchetta \u00e8 ancora a una piccola distanza dal piatto. In questo modo, durante l'homing dell'asse, si fermer\u00e0 prima che l'ugello tocchi il letto. Per ulteriori informazioni, vedere il bed level document .","title":"Perch\u00e9 Z position_endstop \u00e8 impostato su 0.5 nelle configurazioni predefinite?"},{"location":"FAQ.html#ho-convertito-la-mia-configurazione-da-marlin-e-gli-assi-xy-funzionano-bene-ma-ottengo-solo-un-rumore-stridente-durante-homing-dellasse-z","text":"Risposta breve: in primo luogo, assicurati di aver verificato la configurazione dello stepper come descritto nel config check document . Se il problema persiste, provare a ridurre l'impostazione max_z_velocity nella configurazione della stampante. Risposta lunga: in pratica Marlin pu\u00f2 in genere fare solo un passo a una velocit\u00e0 di circa 10000 passi al secondo. Se gli viene richiesto di muoversi a una velocit\u00e0 che richiederebbe una velocit\u00e0 di passo pi\u00f9 alta, Marlin generalmente far\u00e0 un passo pi\u00f9 veloce possibile. Klipper \u00e8 in grado di raggiungere velocit\u00e0 di passo molto pi\u00f9 elevate, ma il motore passo-passo potrebbe non avere una coppia sufficiente per muoversi a una velocit\u00e0 pi\u00f9 elevata. Quindi, per un asse Z con un rapporto di trasmissione elevato o un'impostazione di micropassi elevata, l'effettiva velocit\u00e0 max_z_ottenibile potrebbe essere inferiore a quella configurata in Marlin.","title":"Ho convertito la mia configurazione da Marlin e gli assi X/Y funzionano bene, ma ottengo solo un rumore stridente durante homing dell'asse Z"},{"location":"FAQ.html#il-mio-driver-tmc-del-motore-si-spegne-nel-mezzo-di-una-stampa","text":"Se si utilizza il driver TMC2208 (o TMC2224) in \"modalit\u00e0 standalone\", assicurarsi di utilizzare l' latest version of Klipper . Una soluzione alternativa per un problema del driver \"stealthchop\" TMC2208 \u00e8 stata aggiunta a Klipper a met\u00e0 marzo del 2020.","title":"Il mio driver TMC del motore si spegne nel mezzo di una stampa"},{"location":"FAQ.html#continuo-a-ricevere-errori-casuali-comunicazione-persa-con-mcu-lost-communication-with-mcu","text":"Ci\u00f2 \u00e8 comunemente causato da errori hardware sulla connessione USB tra la macchina host e il microcontrollore. Cose da cercare: Utilizzare un cavo USB di buona qualit\u00e0 tra la macchina host e il microcontrollore. Assicurati che i connettori siano ben saldi. Se si utilizza un Raspberry Pi, utilizzare un alimentatore di buona qualit\u00e0 per il Raspberry Pi e utilizzare un cavo USB di buona qualit\u00e0 per collegare quell'alimentatore al Pi. Se ricevi avvisi di \"sottotensione\" da OctoPrint, questo \u00e8 correlato all'alimentatore e deve essere risolto. Assicurarsi che l'alimentazione della stampante non sia sovraccarica. (Le fluttuazioni di alimentazione del chip USB del microcontrollore possono comportare il reset di quel chip.) Verificare che i cavi dello stepper, del riscaldatore e di altri cavi della stampante non siano arricciati o sfilacciati. (Il movimento della stampante pu\u00f2 sollecitare un cavo difettoso causandone la perdita di contatto, un cortocircuito breve o la generazione di rumore eccessivo.) Sono stati segnalati rumori USB elevati quando sia l'alimentazione della stampante che l'alimentazione a 5 V dell'host sono mescolate. (Se si scopre che il microcontrollore si accende quando l'alimentazione della stampante \u00e8 accesa o il cavo USB \u00e8 collegato, significa che gli alimentatori da 5 V vengono mescolati.) Pu\u00f2 essere utile configurare il microcontrollore da utilizzare alimentazione da una sola fonte. (In alternativa, se la scheda del microcontrollore non \u00e8 in grado di configurare la sua fonte di alimentazione, \u00e8 possibile modificare un cavo USB in modo che non trasmetta alimentazione a 5V tra l'host e il microcontrollore.)","title":"Continuo a ricevere errori casuali \"Comunicazione persa con MCU\" |\"Lost communication with MCU\""},{"location":"FAQ.html#il-mio-raspberry-pi-continua-a-riavviarsi-durante-le-stampe","text":"Questo \u00e8 molto probabilmente dovuto alle fluttuazioni di tensione. Segui gli stessi passaggi per la risoluzione dei problemi per un errore \"Comunicazione persa con MCU\" .","title":"Il mio Raspberry Pi continua a riavviarsi durante le stampe"},{"location":"FAQ.html#quando-imposto-restart_methodcommand-il-mio-dispositivo-avr-si-blocca-al-riavvio","text":"Alcune vecchie versioni del bootloader AVR hanno un bug noto nella gestione degli eventi di watchdog. Questo in genere si manifesta quando il file printer.cfg ha restart_method impostato su \"command\". Quando si verifica il bug, il dispositivo AVR non risponder\u00e0 fino a quando l'alimentazione non viene rimossa e ricollegata al dispositivo (anche i LED di alimentazione o di stato potrebbero lampeggiare ripetutamente fino a quando l'alimentazione non viene rimossa). La soluzione alternativa \u00e8 utilizzare un restart_method diverso da \"command\" o eseguire il flashing di un bootloader aggiornato sul dispositivo AVR. Il flashing di un nuovo bootloader \u00e8 un passaggio che in genere richiede un programmatore esterno: vedere Bootloaders per ulteriori dettagli.","title":"Quando imposto restart_method=command il mio dispositivo AVR si blocca al riavvio"},{"location":"FAQ.html#i-riscaldatori-verranno-lasciati-accesi-se-il-raspberry-pi-si-arresta-in-modo-anomalo","text":"Il software \u00e8 stato progettato per impedirlo. Una volta che l'host abilita un riscaldatore, il software host deve confermare tale abilitazione ogni 5 secondi. Se il microcontrollore non riceve una conferma ogni 5 secondi, entra in uno stato di \"spegnimento\" progettato per spegnere tutti i riscaldatori e i motori passo-passo. Per ulteriori dettagli, vedere il comando \"config_digital_out\" nel documento Comandi MCU . Inoltre, il software del microcontrollore \u00e8 configurato con un intervallo di temperatura minimo e massimo per ciascun riscaldatore all'avvio (consultare i parametri min_temp e max_temp in config reference per i dettagli). Se il microcontrollore rileva che la temperatura \u00e8 al di fuori di tale intervallo, entrer\u00e0 anche in uno stato di \"spegnimento\". Separatamente, il software host implementa anche il codice per verificare che i riscaldatori e i sensori di temperatura funzionino correttamente. Vedere il riferimento di configurazione per ulteriori dettagli.","title":"I riscaldatori verranno lasciati accesi se il Raspberry Pi si arresta in modo anomalo?"},{"location":"FAQ.html#come-posso-convertire-un-numero-di-pin-marlin-in-un-nome-pin-di-klipper","text":"Risposta breve: una mappatura \u00e8 disponibile nel file sample-aliases.cfg . Usa quel file come guida per trovare i nomi effettivi dei pin del microcontrollorei. (\u00c8 anche possibile copiare la relativa sezione di configurazione board_pins nel file di configurazione e utilizzare gli alias nella configurazione, ma \u00e8 preferibile tradurre e utilizzare i nomi dei pin del microcontrollore effettivi.) Nota che il file sample-aliases.cfg usa nomi di pin che iniziano con il prefisso \"ar\" invece di \"D\" (ad esempio, il pin Arduino D23 \u00e8 alias Klipper ar23 ) e il prefisso \"analog\" invece di \"A \" (ad esempio, il pin Arduino A14 \u00e8 alias di Klipper analog14 ). Risposta lunga: Klipper utilizza i nomi dei pin standard definiti dal microcontrollore. Sui chip Atmega questi pin hardware hanno nomi come PA4 , PC7 o PD2 . Tempo fa, il progetto Arduino ha deciso di evitare di utilizzare i nomi hardware standard a favore dei propri nomi pin basati su numeri incrementali: questi nomi Arduino generalmente assomigliano a \"D23\" o \"A14\". Questa \u00e8 stata una scelta sfortunata che ha portato a una grande confusione. In particolare, i numeri dei pin di Arduino spesso non si traducono negli stessi nomi hardware. Ad esempio, D21 \u00e8 PD0 su una comune scheda Arduino, ma \u00e8 PC7 su un'altra comune scheda Arduino. Per evitare questa confusione, il codice di base di Klipper utilizza i nomi dei pin standard definiti dal microcontrollore.","title":"Come posso convertire un numero di pin Marlin in un nome pin di Klipper?"},{"location":"FAQ.html#devo-collegare-il-mio-dispositivo-a-un-tipo-specifico-di-pin-del-microcontrollore","text":"Dipende dal tipo di dispositivo e dal tipo di pin: Pin ADC (o pin analogici): per termistori e sensori \"analogici\" simili, il dispositivo deve essere collegato a un pin compatibile con \"analogico\" o \"ADC\" sul microcontrollore. Se configuri Klipper per utilizzare un pin che non \u00e8 compatibile con l'analogico, Klipper segnaler\u00e0 un errore \"Non un pin ADC valido\". Pin PWM (o pin Timer): Klipper non utilizza PWM hardware per impostazione predefinita per nessun dispositivo. Quindi, in generale, \u00e8 possibile collegare riscaldatori, ventole e dispositivi simili a qualsiasi pin IO generico. Tuttavia, le ventole e i dispositivi output_pin possono essere opzionalmente configurati per utilizzare hardware_pwm: True , nel qual caso il microcontrollore deve supportare PWM hardware sul pin (altrimenti, Klipper segnaler\u00e0 un errore \"pin PWM non valido\"). Pin IRQ (o pin di interrupt): Klipper non utilizza gli interrupt hardware sui pin IO, quindi non \u00e8 mai necessario collegare un dispositivo a uno di questi pin del microcontrollore. Pin SPI: quando si utilizza l'SPI hardware, \u00e8 necessario collegare i pin ai pin SPI del microcontrollore. Tuttavia, la maggior parte dei dispositivi pu\u00f2 essere configurata per utilizzare \"SPI software\", nel qual caso \u00e8 possibile utilizzare qualsiasi pin IO generico. Pin I2C: quando si utilizza I2C \u00e8 necessario collegare i pin ai pin compatibili con I2C del microcontrollore. Altri dispositivi possono essere collegati a qualsiasi pin IO generico. Ad esempio, stepper, riscaldatori, ventole, sonde Z, servocomandi, LED, comuni display LCD hd44780/st7920, la linea di controllo Trinamic UART pu\u00f2 essere collegata a qualsiasi pin IO generico.","title":"Devo collegare il mio dispositivo a un tipo specifico di pin del microcontrollore?"},{"location":"FAQ.html#come-posso-annullare-una-richiesta-di-attesa-temperatura-m109m190","text":"Passare alla scheda del terminale OctoPrint ed emettere un comando M112 nel terminale. Il comando M112 far\u00e0 entrare Klipper in uno stato di \"arresto\" e causer\u00e0 la disconnessione di OctoPrint da Klipper. Passare all'area di connessione di OctoPrint e fare clic su \"Connetti\" per fare in modo che OctoPrint si riconnetta. Torna alla scheda del terminale ed emetti un comando FIRMWARE_RESTART per cancellare lo stato di errore di Klipper. Dopo aver completato questa sequenza, la precedente richiesta di riscaldamento verr\u00e0 annullata e potrebbe essere avviata una nuova stampa.","title":"Come posso annullare una richiesta di \"attesa temperatura\" M109/M190?"},{"location":"FAQ.html#posso-scoprire-se-la-stampante-ha-perso-dei-passaggi","text":"In un certo senso s\u00ec. Avviare la stampante, emettere un comando GET_POSITION , eseguire la stampa, tornare a casa ed emettere un altro GET_POSITION . Quindi confronta i valori nella riga mcu: . Questo potrebbe essere utile per regolare impostazioni come correnti, accelerazioni e velocit\u00e0 del motore passo-passo senza dover effettivamente stampare qualcosa e sprecare il filamento: basta eseguire alcuni movimenti ad alta velocit\u00e0 tra i comandi GET_POSITION . Si noti che gli stessi interruttori di fine corsa tendono a attivarsi in posizioni leggermente diverse, quindi una differenza di un paio di micropassi \u00e8 probabilmente il risultato di imprecisioni di fine corsa. Un motore passo-passo stesso pu\u00f2 perdere passi solo con incrementi di 4 passi completi. (Quindi, se si utilizzano 16 micropassi, un passo perso sullo stepper comporterebbe lo spegnimento del contatore di passi \"mcu:\" di un multiplo di 64 micropassi.)","title":"Posso scoprire se la stampante ha perso dei passaggi?"},{"location":"FAQ.html#perche-klipper-segnala-errori-ho-perso-la-mia-stampa","text":"Risposta breve: vogliamo sapere se le nostre stampanti rilevano un problema in modo che il problema sottostante possa essere risolto e possiamo ottenere stampe di ottima qualit\u00e0. Non vogliamo assolutamente che le nostre stampanti producano in silenzio stampe di bassa qualit\u00e0. Risposta lunga: Klipper \u00e8 stato progettato per risolvere automaticamente molti problemi transitori. Ad esempio, rileva automaticamente gli errori di comunicazione e li ritrasmette; pianifica le azioni in anticipo e bufferizza i comandi su pi\u00f9 livelli per consentire tempi precisi anche con interferenze intermittenti. Tuttavia, se il software rileva un errore dal quale non pu\u00f2 essere ripristinato, se gli viene ordinato di eseguire un'azione non valida o se rileva che \u00e8 irrimediabilmente incapace di eseguire l'attivit\u00e0 comandata, Klipper segnaler\u00e0 un errore. In queste situazioni c'\u00e8 un alto rischio di produrre una stampa di bassa qualit\u00e0 (o peggio). Si spera che avvisare gli utenti consentir\u00e0 loro di risolvere il problema sottostante e migliorare la qualit\u00e0 complessiva delle loro stampe. Ci sono alcune domande correlate: perch\u00e9 Klipper non mette invece in pausa la stampa? Segnalare invece un avviso? Verificare la presenza di errori prima della stampa? Ignorare gli errori nei comandi digitati dall'utente? eccetera? Attualmente Klipper legge i comandi utilizzando il protocollo G-Code e sfortunatamente il protocollo di comando G-Code non \u00e8 sufficientemente flessibile per rendere pratiche queste alternative oggi. C'\u00e8 l'interesse degli sviluppatori nel migliorare l'esperienza dell'utente durante eventi anomali, ma si prevede che ci\u00f2 richieder\u00e0 un notevole lavoro infrastrutturale (incluso un passaggio dal G-Code).","title":"Perch\u00e9 Klipper segnala errori? Ho perso la mia stampa!"},{"location":"FAQ.html#come-si-esegue-laggiornamento-al-software-piu-recente","text":"Il primo passaggio per l'aggiornamento del software consiste nell'esaminare l'ultimo documento config changes . A volte, vengono apportate modifiche al software che richiedono agli utenti di aggiornare le proprie impostazioni come parte di un aggiornamento del software. \u00c8 una buona idea rivedere questo documento prima dell'aggiornamento. Quando sei pronto per l'aggiornamento, il metodo generale \u00e8 quello di entrare in Raspberry Pi ed eseguire: cd ~/klipper git pull ~/klipper/scripts/install-octopi.sh Quindi si pu\u00f2 ricompilare e flashare il codice del microcontrollore. Per esempio: make menuconfig make clean make sudo service klipper stop make flash FLASH_DEVICE=/dev/ttyACM0 sudo service klipper start Tuttavia, capita spesso che cambi solo il software host. In questo caso \u00e8 possibile aggiornare e riavviare solo il software host con: cd ~/klipper git pull sudo service klipper restart Se dopo aver utilizzato questo collegamento il software avverte della necessit\u00e0 di eseguire il reflash del microcontrollore o si verifica qualche altro errore insolito, seguire i passaggi completi di aggiornamento descritti sopra. Se gli errori persistono, ricontrolla il documento config changes , poich\u00e9 potrebbe essere necessario modificare la configurazione della stampante. Si noti che i comandi g-code RESTART e FIRMWARE_RESTART non caricano il nuovo software: i comandi \"sudo service klipper restart\" e \"make flash\" di cui sopra sono necessari affinch\u00e9 una modifica del software abbia effetto.","title":"Come si esegue l'aggiornamento al software pi\u00f9 recente?"},{"location":"FAQ.html#come-faccio-a-disinstallare-klipper","text":"Dal alto del firmware, non deve succedere nulla di speciale. Basta seguire le indicazioni per il flashing del nuovo firmware. Dal lato del raspberry pi, uno script di disinstallazione \u00e8 disponibile in scripts/klipper-uninstall.sh . Per esempio: sudo ~/klipper/scripts/klipper-uninstall.sh rm -rf ~/klippy-env ~/klipper","title":"Come faccio a disinstallare Klipper?"},{"location":"Features.html","text":"Caratteristiche \u00b6 Klipper ha diverse caratteristiche interessanti: Movimento passo-passo di alta precisione. Klipper utilizza un processore applicativo (come un Raspberry Pi a basso costo) per calcolare i movimenti della stampante. Il processore dell'applicazione determina quando far avanzare ciascun motore passo-passo, comprime quegli eventi, li trasmette al microcontrollore e quindi il microcontrollore esegue ogni evento all'ora richiesta. Ogni evento stepper \u00e8 programmato con una precisione di 25 microsecondi o superiore. Il software non utilizza stime cinematiche (come l'algoritmo di Bresenham), ma calcola tempi di passo precisi in base alla fisica dell'accelerazione e alla fisica della cinematica della macchina. Il movimento passo-passo pi\u00f9 preciso garantisce un funzionamento della stampante pi\u00f9 silenzioso e stabile. Le migliori prestazioni della categoria. Klipper \u00e8 in grado di raggiungere velocit\u00e0 di passo elevate sia sui microcontrollori nuovi che su quelli vecchi. Anche i vecchi microcontrollori a 8 bit possono ottenere velocit\u00e0 superiori a 175.000 passi al secondo. Sui microcontrollori pi\u00f9 recenti sono possibili diversi milioni di passi al secondo. Velocit\u00e0 di stepper pi\u00f9 elevate consentono velocit\u00e0 di stampa pi\u00f9 elevate. La temporizzazione degli eventi dello stepper rimane precisa anche a velocit\u00e0 elevate, migliorando la stabilit\u00e0 generale. Klipper supporta stampanti con pi\u00f9 microcontrollori. Ad esempio, un microcontrollore potrebbe essere utilizzato per controllare un estrusore, mentre un altro controlla i riscaldatori della stampante, mentre un terzo controlla il resto della stampante. Il software host Klipper implementa la sincronizzazione dell'orologio per tenere conto della deriva dell'orologio tra i microcontrollori. Non \u00e8 necessario alcun codice speciale per abilitare pi\u00f9 microcontrollori: sono necessarie solo alcune righe in pi\u00f9 nel file di configurazione. Configurazione tramite semplice file. Non \u00e8 necessario eseguire il reflash del microcontrollore per modificare un'impostazione. Tutta la configurazione di Klipper \u00e8 memorizzata in un file di configurazione standard che pu\u00f2 essere facilmente modificato. Ci\u00f2 semplifica la configurazione e la manutenzione dell'hardware. Klipper supporta \"Smooth Pressure Advance\", un meccanismo per tenere conto degli effetti della pressione all'interno di un estrusore. Ci\u00f2 riduce la \"melma\" dell'estrusore e migliora la qualit\u00e0 degli angoli di stampa. L'implementazione di Klipper non introduce variazioni istantanee della velocit\u00e0 dell'estrusore, il che migliora la stabilit\u00e0 e la robustezza complessive. Klipper supporta \"Input Shaping\" per ridurre l'impatto delle vibrazioni sulla qualit\u00e0 di stampa. Ci\u00f2 pu\u00f2 ridurre o eliminare il \"ringing\" (noto anche come \"ghosting\", \"eco\" o \"increspatura\") nelle stampe. Pu\u00f2 anche consentire di ottenere velocit\u00e0 di stampa pi\u00f9 elevate pur mantenendo un'elevata qualit\u00e0 di stampa. Klipper utilizza un \"risolutore iterativo\" per calcolare sequenze temporali precisi da semplici equazioni cinematiche. Ci\u00f2 semplifica il porting di Klipper su nuovi tipi di robot e mantiene i tempi precisi anche con cinematiche complesse (non \u00e8 necessaria la \"segmentazione della linea\"). Klipper \u00e8 indipendente dall'hardware. Si dovrebbe ottenere la stessa tempistica precisa indipendentemente dall'hardware dell'elettronica di basso livello. Il codice del microcontrollore Klipper \u00e8 progettato per seguire fedelmente la pianificazione fornita dal software host Klipper (o avvisare in modo evidente l'utente se non \u00e8 in grado di farlo). Ci\u00f2 semplifica l'utilizzo dell'hardware disponibile, l'aggiornamento al nuovo hardware e la fiducia nell'hardware. Codice portatile. Klipper funziona su microcontrollori basati su ARM, AVR e PRU. Le stampanti esistenti in stile \"reprap\" possono eseguire Klipper senza modifiche hardware: basta aggiungere un Raspberry Pi. Il layout del codice interno di Klipper semplifica il supporto anche di altre architetture di microcontrollori. Codice pi\u00f9 semplice. Klipper utilizza un linguaggio di alto livello (Python) per la maggior parte del codice. Gli algoritmi cinematici, l'analisi del G-code, gli algoritmi di riscaldamento e termistore, ecc. sono tutti scritti in Python. Ci\u00f2 semplifica lo sviluppo di nuove funzionalit\u00e0. Macro programmabili personalizzate. \u00c8 possibile definire nuovi comandi G-Code nel file di configurazione della stampante (non sono necessarie modifiche al codice). Questi comandi sono programmabili, consentendo loro di produrre azioni diverse a seconda dello stato della stampante. Server API integrato. Oltre all'interfaccia G-Code standard, Klipper supporta una ricca interfaccia applicativa basata su JSON. Ci\u00f2 consente ai programmatori di creare applicazioni esterne con un controllo dettagliato della stampante. Caratteristiche aggiuntive \u00b6 Klipper supporta molte funzionalit\u00e0 standard della stampante 3D: Diverse interfacce web disponibili. Funziona con Randa, Fluidd, OctoPrint e altri. Ci\u00f2 consente di controllare la stampante utilizzando un normale browser web. Lo stesso Raspberry Pi che esegue Klipper pu\u00f2 anche eseguire l'interfaccia web. Supporto G-code standard. Sono supportati i comandi G-code comuni prodotti dai tipici \"slicer\" (SuperSlicer, Cura, PrusaSlicer, ecc.). Supporto per pi\u00f9 estrusori. Sono supportati anche estrusori con riscaldatori condivisi ed estrusori su carrelli indipendenti (IDEX). Supporto per stampanti cartesiane, delta, corexy, corexz, hybrid-corexy, hybrid-corexz, deltesian, rotary delta, polar e cable winch. Supporto per il livellamento automatico del letto. Klipper pu\u00f2 essere configurato per il rilevamento di base dell'inclinazione del piatto o per il livellamento del piatto a mesh completa. Se il piatto utilizza pi\u00f9 stepper Z, Klipper pu\u00f2 anche livellare manipolando in modo indipendente gli stepper Z. Sono supportate la maggior parte delle sonde di altezza Z, comprese le sonde BL-Touch e le sonde servoattivate. Supporto per la calibrazione delta automatica. Lo strumento di calibrazione pu\u00f2 eseguire la calibrazione dell'altezza di base e una calibrazione avanzata delle dimensioni X e Y. La calibrazione pu\u00f2 essere eseguita con una sonda di altezza Z o tramite tastatura manuale. Supporto \"escludi oggetto\" in fase di esecuzione. Se configurato, questo modulo pu\u00f2 facilitare l'annullamento di un solo oggetto in una stampa multiparte. Supporto per sensori di temperatura comuni (ad es. termistori comuni, AD595, AD597, AD849x, PT100, PT1000, MAX6675, MAX31855, MAX31856, MAX31865, BME280, HTU21D, DS18B20 e LM75). \u00c8 inoltre possibile configurare termistori personalizzati e sensori di temperatura analogici personalizzati. \u00c8 possibile monitorare il sensore di temperatura del microcontrollore interno e il sensore di temperatura interna di un Raspberry Pi. Protezione del riscaldatore termico di base abilitata di default. Supporto per ventole standard, ventole per ugelli e ventole a temperatura controllata. Non \u00e8 necessario mantenere le ventole in funzione quando la stampante \u00e8 inattiva. La velocit\u00e0 della ventola pu\u00f2 essere monitorata su ventole dotate di contagiri. Supporto per la configurazione in fase di esecuzione dei driver per motori passo-passo TMC2130, TMC2208/TMC2224, TMC2209, TMC2660 e TMC5160. \u00c8 inoltre disponibile il supporto per il controllo corrente dei tradizionali driver passo-passo tramite i pin AD5206, DAC084S085, MCP4451, MCP4728, MCP4018 e PWM. Supporto per comuni display LCD collegati direttamente alla stampante. \u00c8 disponibile anche un menu predefinito. Il contenuto del display e del menu pu\u00f2 essere completamente personalizzato tramite il file di configurazione. Accelerazione costante e supporto \"look-ahead\". Tutti i movimenti della stampante accelereranno gradualmente dall'arresto alla velocit\u00e0 di crociera, quindi decelereranno fino all'arresto. Il flusso in entrata dei comandi di movimento del G-code viene messo in coda e analizzato: l'accelerazione tra i movimenti in una direzione simile sar\u00e0 ottimizzata per ridurre gli arresti di stampa e migliorare il tempo di stampa complessivo. Klipper implementa un algoritmo \"stepper phase endstop\" che pu\u00f2 migliorare la precisione dei tipici interruttori endstop. Se regolato correttamente, pu\u00f2 migliorare l'adesione del primo strato di stampa. Supporto per sensori di presenza del filamento, sensori di movimento del filamento e sensori di larghezza del filamento. Supporto per misurare e registrare l'accelerazione utilizzando gli accelerometri adxl345, mpu9250 e mpu6050. Supporto per limitare la velocit\u00e0 massima di brevi spostamenti a \"zigzag\" per ridurre le vibrazioni e il rumore della stampante. Per ulteriori informazioni, vedere il documento cinematica . Sono disponibili file di configurazione di esempio per molte stampanti comuni. Controllare la directory di configurazione per un elenco. Per iniziare con Klipper, leggi la guida installazione . Benchmark dei passi \u00b6 Di seguito sono riportati i risultati dei test delle prestazioni degli stepper. I numeri visualizzati rappresentano il numero totale di passi al secondo sul microcontrollore. Microcontrollore 1 stepper attivo 3 stepper attivi 16Mhz AVR 157K 99K 20Mhz AVR 196K 123K SAMD21 686K 471K STM32F042 814K 578K Beaglebone PRU 866K 708K STM32G0B1 1103K 790K STM32F103 1180K 818K SAM3X8E 1273K 981K SAM4S8C 1690K 1385K LPC1768 1923K 1351K LPC1769 2353K 1622K RP2040 2400K 1636K SAM4E8E 2500K 1674K SAMD51 3077K 1885K AR100 3529K 2507K STM32F407 3652K 2459K STM32F446 3913K 2634K RP2350 4167K 2663K SAME70 6667K 4737K STM32H743 9091K 6061K Se non sei sicuro del microcontrollore su una particolare scheda, trova il file di configurazione appropriato e cerca il nome del microcontrollore nei commenti nella parte superiore di quel file. Ulteriori dettagli sui benchmark sono disponibili nel documento Benchmarks .","title":"Caratteristiche"},{"location":"Features.html#caratteristiche","text":"Klipper ha diverse caratteristiche interessanti: Movimento passo-passo di alta precisione. Klipper utilizza un processore applicativo (come un Raspberry Pi a basso costo) per calcolare i movimenti della stampante. Il processore dell'applicazione determina quando far avanzare ciascun motore passo-passo, comprime quegli eventi, li trasmette al microcontrollore e quindi il microcontrollore esegue ogni evento all'ora richiesta. Ogni evento stepper \u00e8 programmato con una precisione di 25 microsecondi o superiore. Il software non utilizza stime cinematiche (come l'algoritmo di Bresenham), ma calcola tempi di passo precisi in base alla fisica dell'accelerazione e alla fisica della cinematica della macchina. Il movimento passo-passo pi\u00f9 preciso garantisce un funzionamento della stampante pi\u00f9 silenzioso e stabile. Le migliori prestazioni della categoria. Klipper \u00e8 in grado di raggiungere velocit\u00e0 di passo elevate sia sui microcontrollori nuovi che su quelli vecchi. Anche i vecchi microcontrollori a 8 bit possono ottenere velocit\u00e0 superiori a 175.000 passi al secondo. Sui microcontrollori pi\u00f9 recenti sono possibili diversi milioni di passi al secondo. Velocit\u00e0 di stepper pi\u00f9 elevate consentono velocit\u00e0 di stampa pi\u00f9 elevate. La temporizzazione degli eventi dello stepper rimane precisa anche a velocit\u00e0 elevate, migliorando la stabilit\u00e0 generale. Klipper supporta stampanti con pi\u00f9 microcontrollori. Ad esempio, un microcontrollore potrebbe essere utilizzato per controllare un estrusore, mentre un altro controlla i riscaldatori della stampante, mentre un terzo controlla il resto della stampante. Il software host Klipper implementa la sincronizzazione dell'orologio per tenere conto della deriva dell'orologio tra i microcontrollori. Non \u00e8 necessario alcun codice speciale per abilitare pi\u00f9 microcontrollori: sono necessarie solo alcune righe in pi\u00f9 nel file di configurazione. Configurazione tramite semplice file. Non \u00e8 necessario eseguire il reflash del microcontrollore per modificare un'impostazione. Tutta la configurazione di Klipper \u00e8 memorizzata in un file di configurazione standard che pu\u00f2 essere facilmente modificato. Ci\u00f2 semplifica la configurazione e la manutenzione dell'hardware. Klipper supporta \"Smooth Pressure Advance\", un meccanismo per tenere conto degli effetti della pressione all'interno di un estrusore. Ci\u00f2 riduce la \"melma\" dell'estrusore e migliora la qualit\u00e0 degli angoli di stampa. L'implementazione di Klipper non introduce variazioni istantanee della velocit\u00e0 dell'estrusore, il che migliora la stabilit\u00e0 e la robustezza complessive. Klipper supporta \"Input Shaping\" per ridurre l'impatto delle vibrazioni sulla qualit\u00e0 di stampa. Ci\u00f2 pu\u00f2 ridurre o eliminare il \"ringing\" (noto anche come \"ghosting\", \"eco\" o \"increspatura\") nelle stampe. Pu\u00f2 anche consentire di ottenere velocit\u00e0 di stampa pi\u00f9 elevate pur mantenendo un'elevata qualit\u00e0 di stampa. Klipper utilizza un \"risolutore iterativo\" per calcolare sequenze temporali precisi da semplici equazioni cinematiche. Ci\u00f2 semplifica il porting di Klipper su nuovi tipi di robot e mantiene i tempi precisi anche con cinematiche complesse (non \u00e8 necessaria la \"segmentazione della linea\"). Klipper \u00e8 indipendente dall'hardware. Si dovrebbe ottenere la stessa tempistica precisa indipendentemente dall'hardware dell'elettronica di basso livello. Il codice del microcontrollore Klipper \u00e8 progettato per seguire fedelmente la pianificazione fornita dal software host Klipper (o avvisare in modo evidente l'utente se non \u00e8 in grado di farlo). Ci\u00f2 semplifica l'utilizzo dell'hardware disponibile, l'aggiornamento al nuovo hardware e la fiducia nell'hardware. Codice portatile. Klipper funziona su microcontrollori basati su ARM, AVR e PRU. Le stampanti esistenti in stile \"reprap\" possono eseguire Klipper senza modifiche hardware: basta aggiungere un Raspberry Pi. Il layout del codice interno di Klipper semplifica il supporto anche di altre architetture di microcontrollori. Codice pi\u00f9 semplice. Klipper utilizza un linguaggio di alto livello (Python) per la maggior parte del codice. Gli algoritmi cinematici, l'analisi del G-code, gli algoritmi di riscaldamento e termistore, ecc. sono tutti scritti in Python. Ci\u00f2 semplifica lo sviluppo di nuove funzionalit\u00e0. Macro programmabili personalizzate. \u00c8 possibile definire nuovi comandi G-Code nel file di configurazione della stampante (non sono necessarie modifiche al codice). Questi comandi sono programmabili, consentendo loro di produrre azioni diverse a seconda dello stato della stampante. Server API integrato. Oltre all'interfaccia G-Code standard, Klipper supporta una ricca interfaccia applicativa basata su JSON. Ci\u00f2 consente ai programmatori di creare applicazioni esterne con un controllo dettagliato della stampante.","title":"Caratteristiche"},{"location":"Features.html#caratteristiche-aggiuntive","text":"Klipper supporta molte funzionalit\u00e0 standard della stampante 3D: Diverse interfacce web disponibili. Funziona con Randa, Fluidd, OctoPrint e altri. Ci\u00f2 consente di controllare la stampante utilizzando un normale browser web. Lo stesso Raspberry Pi che esegue Klipper pu\u00f2 anche eseguire l'interfaccia web. Supporto G-code standard. Sono supportati i comandi G-code comuni prodotti dai tipici \"slicer\" (SuperSlicer, Cura, PrusaSlicer, ecc.). Supporto per pi\u00f9 estrusori. Sono supportati anche estrusori con riscaldatori condivisi ed estrusori su carrelli indipendenti (IDEX). Supporto per stampanti cartesiane, delta, corexy, corexz, hybrid-corexy, hybrid-corexz, deltesian, rotary delta, polar e cable winch. Supporto per il livellamento automatico del letto. Klipper pu\u00f2 essere configurato per il rilevamento di base dell'inclinazione del piatto o per il livellamento del piatto a mesh completa. Se il piatto utilizza pi\u00f9 stepper Z, Klipper pu\u00f2 anche livellare manipolando in modo indipendente gli stepper Z. Sono supportate la maggior parte delle sonde di altezza Z, comprese le sonde BL-Touch e le sonde servoattivate. Supporto per la calibrazione delta automatica. Lo strumento di calibrazione pu\u00f2 eseguire la calibrazione dell'altezza di base e una calibrazione avanzata delle dimensioni X e Y. La calibrazione pu\u00f2 essere eseguita con una sonda di altezza Z o tramite tastatura manuale. Supporto \"escludi oggetto\" in fase di esecuzione. Se configurato, questo modulo pu\u00f2 facilitare l'annullamento di un solo oggetto in una stampa multiparte. Supporto per sensori di temperatura comuni (ad es. termistori comuni, AD595, AD597, AD849x, PT100, PT1000, MAX6675, MAX31855, MAX31856, MAX31865, BME280, HTU21D, DS18B20 e LM75). \u00c8 inoltre possibile configurare termistori personalizzati e sensori di temperatura analogici personalizzati. \u00c8 possibile monitorare il sensore di temperatura del microcontrollore interno e il sensore di temperatura interna di un Raspberry Pi. Protezione del riscaldatore termico di base abilitata di default. Supporto per ventole standard, ventole per ugelli e ventole a temperatura controllata. Non \u00e8 necessario mantenere le ventole in funzione quando la stampante \u00e8 inattiva. La velocit\u00e0 della ventola pu\u00f2 essere monitorata su ventole dotate di contagiri. Supporto per la configurazione in fase di esecuzione dei driver per motori passo-passo TMC2130, TMC2208/TMC2224, TMC2209, TMC2660 e TMC5160. \u00c8 inoltre disponibile il supporto per il controllo corrente dei tradizionali driver passo-passo tramite i pin AD5206, DAC084S085, MCP4451, MCP4728, MCP4018 e PWM. Supporto per comuni display LCD collegati direttamente alla stampante. \u00c8 disponibile anche un menu predefinito. Il contenuto del display e del menu pu\u00f2 essere completamente personalizzato tramite il file di configurazione. Accelerazione costante e supporto \"look-ahead\". Tutti i movimenti della stampante accelereranno gradualmente dall'arresto alla velocit\u00e0 di crociera, quindi decelereranno fino all'arresto. Il flusso in entrata dei comandi di movimento del G-code viene messo in coda e analizzato: l'accelerazione tra i movimenti in una direzione simile sar\u00e0 ottimizzata per ridurre gli arresti di stampa e migliorare il tempo di stampa complessivo. Klipper implementa un algoritmo \"stepper phase endstop\" che pu\u00f2 migliorare la precisione dei tipici interruttori endstop. Se regolato correttamente, pu\u00f2 migliorare l'adesione del primo strato di stampa. Supporto per sensori di presenza del filamento, sensori di movimento del filamento e sensori di larghezza del filamento. Supporto per misurare e registrare l'accelerazione utilizzando gli accelerometri adxl345, mpu9250 e mpu6050. Supporto per limitare la velocit\u00e0 massima di brevi spostamenti a \"zigzag\" per ridurre le vibrazioni e il rumore della stampante. Per ulteriori informazioni, vedere il documento cinematica . Sono disponibili file di configurazione di esempio per molte stampanti comuni. Controllare la directory di configurazione per un elenco. Per iniziare con Klipper, leggi la guida installazione .","title":"Caratteristiche aggiuntive"},{"location":"Features.html#benchmark-dei-passi","text":"Di seguito sono riportati i risultati dei test delle prestazioni degli stepper. I numeri visualizzati rappresentano il numero totale di passi al secondo sul microcontrollore. Microcontrollore 1 stepper attivo 3 stepper attivi 16Mhz AVR 157K 99K 20Mhz AVR 196K 123K SAMD21 686K 471K STM32F042 814K 578K Beaglebone PRU 866K 708K STM32G0B1 1103K 790K STM32F103 1180K 818K SAM3X8E 1273K 981K SAM4S8C 1690K 1385K LPC1768 1923K 1351K LPC1769 2353K 1622K RP2040 2400K 1636K SAM4E8E 2500K 1674K SAMD51 3077K 1885K AR100 3529K 2507K STM32F407 3652K 2459K STM32F446 3913K 2634K RP2350 4167K 2663K SAME70 6667K 4737K STM32H743 9091K 6061K Se non sei sicuro del microcontrollore su una particolare scheda, trova il file di configurazione appropriato e cerca il nome del microcontrollore nei commenti nella parte superiore di quel file. Ulteriori dettagli sui benchmark sono disponibili nel documento Benchmarks .","title":"Benchmark dei passi"},{"location":"G-Codes.html","text":"G-Codes \u00b6 Questo documento descrive i comandi che Klipper supporta. Questi sono i comandi che si possono inserire nella scheda del terminale OctoPrint. Comandi G-Code \u00b6 Klipper supporta i seguenti comandi G-Code standard: Movimento (G0 or G1): G1 [X<pos>] [Y<pos>] [Z<pos>] [E<pos>] [F<speed>] Sosta: G4 P<millisecondi> Sposta all'origine: G28 [X] [Y] [Z] Spegnere i motori: M18 o M84 Attendi che li movimenti correnti finiscano: M400 Utilizzare distanze assolute/relative per l'estrusione: M82 , M83 Usa coordinate assolute/relative: G90 , G91 Impostare la posizione: G92 [X<pos>] [Y<pos>] [Z<pos>] [E<pos>] Impostare la percentuale di override del fattore di velocit\u00e0: M220 S<percentuale> Imposta la percentuale di sostituzione del fattore di estrusione: M221 S<percentuale> Impostare l'accelerazione: M204 S<valore> OPPURE M204 P<valore> T<valore> Nota: se S non viene specificato e vengono specificati sia P che T, l'accelerazione viene impostata al minimo di P e T. Se viene specificato solo uno di P o T, il comando non ha effetto. Ottieni la temperatura dell'estrusore: M105 Imposta la temperatura dell'estrusore: M104 [T<index>] [S<temperatura>] Imposta la temperatura dell'estrusore e attende: M109 [T<index>] S<temperatura> Nota: M109 attende sempre che la temperatura si assesti al valore richiesto Imposta la temperatura del piatto: M140 [S<temperatura>] Imposta la temperatura del piatto e attende: M190 S<temperatura> Nota: M190 attende sempre che la temperatura si assesti al valore richiesto Imposta la velocit\u00e0 della ventola: M106 S<valore> Spegnere la ventola: M107 Arresto di emergenza: M112 Ottieni la posizione attuale: M114 Ottieni la versione del firmware: M115 Per ulteriori dettagli sui comandi precedenti, vedere la documentazione RepRap G-Code . L'obiettivo di Klipper \u00e8 supportare i comandi G-Code prodotti da comuni software di terze parti (ad es. OctoPrint, Printrun, Slic3r, Cura, ecc.) nelle loro configurazioni standard. Non \u00e8 un obiettivo supportare ogni possibile comando G-Code. Invece, Klipper preferisce comandi leggibili dall'uomo \"comandi G-Code estesi\" . Allo stesso modo, l'output del terminale G-Code \u00e8 inteso solo per essere leggibile dall'uomo - vedere il documento del server API se si controlla Klipper da un software esterno. Se si necessita di un comando G-Code meno comune, potrebbe essere possibile implementarlo con una [sezione di configurazione gcode_macro] personalizzata (Config_Reference.md#gcode_macro). Ad esempio, si potrebbe usare questo per implementare: G12 , G29 , G30 , G31 , M42 , M80 , M81 , T1 , ecc. Comandi aggiuntivi \u00b6 Klipper utilizza comandi G-Code \"estesi\" per la configurazione e lo stato generale. Questi comandi estesi seguono tutti un formato simile: iniziano con un nome di comando e possono essere seguiti da uno o pi\u00f9 parametri. Ad esempio: SET_SERVO SERVO=mioservo ANGLE=5.3 . In questo documento, i comandi ed i parametri sono mostrati in maiuscolo, tuttavia non fanno distinzione tra maiuscole e minuscole. (Quindi, \"SET_SERVO\" e \"set_servo\" eseguono entrambi lo stesso comando.) Questa sezione \u00e8 organizzata in base al nome del modulo Klipper, che generalmente segue i nomi delle sezioni specificati nel file di configurazione della stampante . Si noti che alcuni moduli vengono caricati automaticamente. [adxl345] \u00b6 I seguenti comandi sono disponibili quando una sezione di configurazione adxl345 \u00e8 abilitata. ACCELEROMETER_MEASURE \u00b6 ACCELEROMETER_MEASURE [CHIP=<config_name>] [NAME=<value>] : Avvia le misurazioni dell'accelerometro al numero richiesto di campioni al secondo. Se CHIP non \u00e8 specificato, il valore predefinito \u00e8 \"adxl345\". Il comando funziona in modalit\u00e0 start-stop: alla prima esecuzione avvia le misure, alla successiva esecuzione le interrompe. I risultati delle misurazioni vengono scritti in un file denominato /tmp/adxl345-<chip>-<name>.csv dove <chip> \u00e8 il nome del chip dell'accelerometro ( my_chip_name da [adxl345 my_chip_name] ) e <name> \u00e8 il parametro NAME facoltativo. Se NAME non \u00e8 specificato, il valore predefinito \u00e8 l'ora corrente nel formato \"AAAAMMGG_HHMMSS\". Se l'accelerometro non ha un nome nella sua sezione di configurazione (semplicemente [adxl345] ), allora la parte <chip> del nome non viene generata. ACCELEROMETER_QUERY \u00b6 ACCELEROMETER_QUERY [CHIP=<config_name>] [RATE=<value>] : interroga l'accelerometro per il valore corrente. Se CHIP non \u00e8 specificato, il valore predefinito \u00e8 \"adxl345\". Se RATE non \u00e8 specificato, viene utilizzato il valore predefinito. Questo comando \u00e8 utile per testare la connessione all'accelerometro ADXL345: uno dei valori restituiti dovrebbe essere un'accelerazione di caduta libera (+/- un po' di rumore del chip). ACCELEROMETER_DEBUG_READ \u00b6 ACCELEROMETER_DEBUG_READ [CHIP=<config_name>] REG=<register> : interroga l'ADXL345 register \"register\" (es. 44 o 0x2C). Pu\u00f2 essere utile per scopi di debug. ACCELEROMETER_DEBUG_WRITE \u00b6 ACCELEROMETER_DEBUG_WRITE [CHIP=<nome_config>] REG=<register> VAL=<value> : Scrive il valore \"value\" grezzo in un registro \"register\". Sia \"value\" che \"registrer\" possono essere un numero intero decimale o esadecimale. Usare con cura e fare riferimento alla scheda tecnica ADXL345 per riferimento. [angle] \u00b6 I seguenti comandi sono disponibili quando una sezione di configurazione dell'angolo \u00e8 abilitata. ANGLE_CALIBRATE \u00b6 ANGLE_CALIBRATE CHIP=<chip_name> : Esegue la calibrazione dell'angolo sul sensore dato (deve esserci una sezione di configurazione [angle chip_name] che ha specificato un parametro stepper ). IMPORTANTE - questo strumento comander\u00e0 al motore passo-passo di muoversi senza controllare i normali limiti della cinematica. Idealmente, il motore dovrebbe essere scollegato da qualsiasi carrello della stampante prima di eseguire la calibrazione. Se non \u00e8 possibile scollegare lo stepper dalla stampante, assicurarsi che il carrello sia vicino al centro della sua guida prima di iniziare la calibrazione. (Il motore passo-passo pu\u00f2 spostarsi avanti o indietro di due rotazioni complete durante questo test.) Dopo aver completato questo test, utilizzare il comando SAVE_CONFIG per salvare i dati di calibrazione nel file di configurazione. Per utilizzare questo strumento \u00e8 necessario installare il pacchetto Python \"numpy\" (consultare il measuring resonance document per ulteriori informazioni). ANGLE_CHIP_CALIBRATE \u00b6 ANGLE_CHIP_CALIBRATE CHIP=<chip_name> : Perform internal sensor calibration, if implemented (MT6826S/MT6835). MT68XX : The motor should be disconnected from any printer carriage before performing calibration. After calibration, the sensor should be reset by disconnecting the power. ANGLE_DEBUG_READ \u00b6 ANGLE_DEBUG_READ CHIP=<config_name> REG=<register> : Interroga il registro del sensore \"register\" (ad es. 44 o 0x2C). Pu\u00f2 essere utile per scopi di debug. Questo \u00e8 disponibile solo per i chip tle5012b. ANGLE_DEBUG_WRITE \u00b6 ANGLE_DEBUG_WRITE CHIP=<config_name> REG=<register> VAL=<value> : scrive il valore \"value\" grezzo nel registro \"register\". Sia \"value\" che \"register\" possono essere un numero intero decimale o esadecimale. Usare con cautela e fare riferimento alla scheda tecnica del sensore per riferimento. Questo \u00e8 disponibile solo per i chip tle5012b. [axis_twist_compensation] \u00b6 The following commands are available when the axis_twist_compensation config section is enabled. AXIS_TWIST_COMPENSATION_CALIBRATE \u00b6 AXIS_TWIST_COMPENSATION_CALIBRATE [AXIS=<X|Y>] [AUTO=<True|False>] [SAMPLE_COUNT=<value>] Calibrates axis twist compensation by specifying the target axis or enabling automatic calibration. AXIS: Define the axis ( X or Y ) for which the twist compensation will be calibrated. If not specified, the axis defaults to 'X' . AUTO: Enables automatic calibration mode. When AUTO=True , the calibration will run for both the X and Y axes. In this mode, AXIS cannot be specified. If both AXIS and AUTO are provided, an error will be raised. [bed_mesh] \u00b6 I seguenti comandi sono disponibili quando la sezione di configurazione bed_mesh \u00e8 abilitata (consultare anche la guida della mesh del letto ). BED_MESH_CALIBRATE \u00b6 BED_MESH_CALIBRATE [PROFILE=<name>] [METHOD=manual] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] [<mesh_parameter>=<value>] [ADAPTIVE=1] [ADAPTIVE_MARGIN=<value>] : This command probes the bed using generated points specified by the parameters in the config. After probing, a mesh is generated and z-movement is adjusted according to the mesh. The mesh will be saved into a profile specified by the PROFILE parameter, or default if unspecified. See the PROBE command for details on the optional probe parameters. If METHOD=manual is specified then the manual probing tool is activated - see the MANUAL_PROBE command above for details on the additional commands available while this tool is active. The optional HORIZONTAL_MOVE_Z value overrides the horizontal_move_z option specified in the config file. If ADAPTIVE=1 is specified then the objects defined by the Gcode file being printed will be used to define the probed area. The optional ADAPTIVE_MARGIN value overrides the adaptive_margin option specified in the config file. BED_MESH_OUTPUT \u00b6 BED_MESH_OUTPUT PGP=[<0:1>] : questo comando restituisce i valori z sondati e i valori mesh correnti al terminale. Se viene specificato PGP=1, le coordinate X, Y generate da bed_mesh, insieme ai relativi indici associati, verranno inviate al terminale. BED_MESH_MAP \u00b6 BED_MESH_MAP : Come per BED_MESH_OUTPUT, questo comando stampa lo stato corrente della mesh sul terminale. Invece di stampare i valori in un formato leggibile, lo stato viene serializzato in formato json. Ci\u00f2 consente ai plug-in di Octoprint di acquisire facilmente i dati e generare mappe di altezza che si approssimano la superficie del piatto. BED_MESH_CLEAR \u00b6 BED_MESH_CLEAR : questo comando cancella la mesh e rimuove tutte le regolazioni z. Si consiglia di inserirlo nella parte finale del gcode. BED_MESH_PROFILE \u00b6 BED_MESH_PROFILE LOAD=<name> SAVE=<name> REMOVE=<name> : questo comando fornisce la gestione del profilo per lo stato della mesh. LOAD ripristiner\u00e0 lo stato della mesh dal profilo corrispondente al nome fornito. SAVE salver\u00e0 lo stato della mesh corrente in un profilo che corrisponde al nome fornito. Rimuovi eliminer\u00e0 il profilo corrispondente al nome fornito dalla memoria persistente. Si noti che dopo aver eseguito le operazioni SAVE o REMOVE \u00e8 necessario eseguire il gcode SAVE_CONFIG per rendere permanenti le modifiche alla memoria persistente. BED_MESH_OFFSET \u00b6 BED_MESH_OFFSET [X=<value>] [Y=<value>] [ZFADE=<value] : Applies X, Y, and/or ZFADE offsets to the mesh lookup. This is useful for printers with independent extruders, as an offset is necessary to produce correct Z adjustment after a tool change. Note that a ZFADE offset does not apply additional z-adjustment directly, it is used to correct the fade calculation when a gcode offset has been applied to the Z axis. [bed_screws] \u00b6 I seguenti comandi sono disponibili quando la sezione di configurazione bed_screws \u00e8 abilitata (consultare anche la manual level guide ). BED_SCREWS_ADJUST \u00b6 BED_SCREWS_ADJUST : questo comando richiamer\u00e0 lo strumento di regolazione delle viti del piatto. Comander\u00e0 l'ugello in posizioni diverse (come definito nel file di configurazione) e consentir\u00e0 di effettuare regolazioni alle viti del piatto in modo che il piatto sia a una distanza costante dall'ugello. [bed_tilt] \u00b6 I seguenti comandi sono disponibili quando la sezione di configurazione inclinazione_piatto \u00e8 abilitata. BED_TILT_CALIBRATE \u00b6 BED_TILT_CALIBRATE [METHOD=manual] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] : questo comando sonda i punti specificati nella configurazione e quindi consiglia le regolazioni aggiornate dell'inclinazione x e y. Vedere il comando PROBE per i dettagli sui parametri opzionali della sonda. Se viene specificato METHOD=manual, viene attivato lo strumento di rilevamento manuale: vedere il comando MANUAL_PROBE sopra per dettagli sui comandi aggiuntivi disponibili mentre questo strumento \u00e8 attivo. Il valore opzionale HORIZONTAL_MOVE_Z sovrascrive l'opzione horizontal_move_z specificata nel file di configurazione. [bltouch] \u00b6 Il comando seguente \u00e8 disponibile quando \u00e8 abilitata una sezione di configurazione bltouch (vedere anche la Guida BL-Touch ). BLTOUCH_DEBUG \u00b6 BLTOUCH_DEBUG COMMAND=<command> : Invia un comando al BLTouch. Pu\u00f2 essere utile per il debug. I comandi disponibili sono: pin_down , touch_mode , pin_up , self_test , reset . Un BL-Touch V3.0 o V3.1 pu\u00f2 anche supportare i comandi set_5V_output_mode , set_OD_output_mode , output_mode_store . BLTOUCH_STORE \u00b6 BLTOUCH_STORE MODE=<output_mode> : memorizza una modalit\u00e0 di output nella EEPROM di un BLTouch V3.1 Le modalit\u00e0 di output disponibili sono: 5V , OD [configfile] \u00b6 Il modulo configfile viene caricato automaticamente. SAVE_CONFIG \u00b6 SAVE_CONFIG : questo comando sovrascriver\u00e0 il file di configurazione della stampante principale e riavvier\u00e0 il software host. Questo comando viene utilizzato insieme ad altri comandi di calibrazione per memorizzare i risultati dei test di calibrazione. [delayed_gcode] \u00b6 Il comando seguente \u00e8 abilitato se \u00e8 stata abilitata una sezione di configurazione di gcode ritardata (consultare anche la guida ai modelli ). UPDATE_DELAYED_GCODE \u00b6 UPDATE_DELAYED_GCODE [ID=<nome>] [DURATION=<secondi>] : aggiorna la durata del ritardo per il [gcode_ritardato] identificato e avvia il timer per l'esecuzione di gcode. Un valore di 0 annuller\u00e0 l'esecuzione di un gcode ritardato in sospeso. [delta_calibrate] \u00b6 I seguenti comandi sono disponibili quando la sezione di configurazione delta_calibrate \u00e8 abilitata (consultare anche la guida alla calibrazione delta ). DELTA_CALIBRATE \u00b6 DELTA_CALIBRATE [METHOD=manual] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] : questo comando sonda sette punti sul piatto e consiglia le posizioni aggiornate dei finecorsa, gli angoli della torre e il raggio. Vedere il comando PROBE per i dettagli sui parametri opzionali della sonda. Se viene specificato METHOD=manual, viene attivato lo strumento di rilevamento manuale: vedere il comando MANUAL_PROBE sopra per dettagli sui comandi aggiuntivi disponibili mentre questo strumento \u00e8 attivo. Il valore opzionale HORIZONTAL_MOVE_Z sovrascrive l'opzione horizontal_move_z specificata nel file di configurazione. DELTA_ANALYZE \u00b6 DELTA_ANALYZE : questo comando viene utilizzato durante la calibrazione avanzata delle stampanti delta. Vedere Delta Calibrate per i dettagli. [display] \u00b6 Il comando seguente \u00e8 disponibile quando \u00e8 abilitata una sezione di configurazione display . SET_DISPLAY_GROUP \u00b6 SET_DISPLAY_GROUP [DISPLAY=<display>] GROUP=<group> : Imposta il gruppo di visualizzazione attivo di un display LCD. Ci\u00f2 consente di definire pi\u00f9 gruppi di dati di visualizzazione nella configurazione, ad es. [display_data <group> <elementname>] e passare da uno all'altro usando questo comando gcode esteso. Se DISPLAY non \u00e8 specificato, l'impostazione predefinita \u00e8 \"display\" (il display principale). [display_status] \u00b6 Il modulo display_status viene caricato automaticamente se una sezione di configurazione display \u00e8 abilitata. Fornisce i seguenti comandi G-Code standard: Messaggio visualizzato: M117 <messaggio> Imposta la percentuale di costruzione: M73 P<percentuale> Viene inoltre fornito il seguente comando G-Code esteso: SET_DISPLAY_TEXT MSG=<messaggio> : esegue l'equivalente di M117, impostando il MSG fornito come messaggio visualizzato. Se MSG viene omesso, il display verr\u00e0 cancellato. [dual_carriage] \u00b6 Il comando seguente \u00e8 disponibile quando la sezione di configurazione dual_carriage \u00e8 abilitata. SET_DUAL_CARRIAGE \u00b6 SET_DUAL_CARRIAGE CARRIAGE=[0|1] [MODE=[PRIMARY|COPY|MIRROR]] : This command will change the mode of the specified carriage. If no MODE is provided it defaults to PRIMARY . Setting the mode to PRIMARY deactivates the other carriage and makes the specified carriage execute subsequent G-Code commands as-is. COPY and MIRROR modes are supported only for CARRIAGE=1 . When set to either of these modes, carriage 1 will then track the subsequent moves of the carriage 0 and either copy relative movements of it (in COPY mode) or execute them in the opposite (mirror) direction (in MIRROR mode). SAVE_DUAL_CARRIAGE_STATE \u00b6 SAVE_DUAL_CARRIAGE_STATE [NAME=<state_name>] : Save the current positions of the dual carriages and their modes. Saving and restoring DUAL_CARRIAGE state can be useful in scripts and macros, as well as in homing routine overrides. If NAME is provided it allows one to name the saved state to the given string. If NAME is not provided it defaults to \"default\". RESTORE_DUAL_CARRIAGE_STATE \u00b6 RESTORE_DUAL_CARRIAGE_STATE [NAME=<state_name>] [MOVE=[0|1] [MOVE_SPEED=<speed>]] : Restore the previously saved positions of the dual carriages and their modes, unless \"MOVE=0\" is specified, in which case only the saved modes will be restored, but not the positions of the carriages. If positions are being restored and \"MOVE_SPEED\" is specified, then the toolhead moves will be performed with the given speed (in mm/s); otherwise the toolhead move will use the rail homing speed. Note that the carriages restore their positions only over their own axis, which may be necessary to correctly restore COPY and MIRROR mode of the dual carraige. [endstop_phase] \u00b6 I seguenti comandi sono disponibili quando una sezione di configurazione endstop_phase \u00e8 abilitata (consultare anche la guida alla fase endstop ). ENDSTOP_PHASE_CALIBRATE \u00b6 ENDSTOP_PHASE_CALIBRATE [STEPPER=<config_name>] : Se non viene fornito alcun parametro STEPPER, questo comando riporter\u00e0 le statistiche sulle fasi stepper dell'arresto durante le precedenti operazioni di homing. Quando viene fornito un parametro STEPPER, fa in modo che l'impostazione della fase di fine corsa fornita sia scritta nel file di configurazione (insieme al comando SAVE_CONFIG). [exclude_object] \u00b6 I seguenti comandi sono disponibili quando \u00e8 abilitata una exclude_object config section (consultare anche la exclude object guide ): EXCLUDE_OBJECT \u00b6 EXCLUDE_OBJECT [NAME=object_name] [CURRENT=1] [RESET=1] : Senza parametri, questo restituir\u00e0 un elenco di tutti gli oggetti attualmente esclusi. Quando viene fornito il parametro NAME , l'oggetto denominato verr\u00e0 escluso dalla stampa. Quando viene fornito il parametro CURRENT , l'oggetto corrente verr\u00e0 escluso dalla stampa. Quando viene fornito il parametro RESET l'elenco degli oggetti esclusi verr\u00e0 cancellato. Inoltre l'inclusione di NAME ripristiner\u00e0 solo l'oggetto denominato. Questo pu\u00f2 causare errori di stampa, se i livelli sono gi\u00e0 stati saltati. EXCLUDE_OBJECT_DEFINE \u00b6 EXCLUDE_OBJECT_DEFINE [NAME=object_name [CENTER=X,Y] [POLYGON=[[x,y],...]] [RESET=1] [JSON=1] : fornisce un riepilogo di un oggetto nel file. Senza parametri forniti, questo elencher\u00e0 gli oggetti definiti noti a Klipper. Restituisce un elenco di stringhe, a meno che non venga fornito il parametro JSON , quando restituir\u00e0 i dettagli dell'oggetto in formato json. Quando il parametro NAME \u00e8 incluso, definisce un oggetto da escludere. NAME : questo parametro \u00e8 obbligatorio. \u00c8 l'identificatore utilizzato da altri comandi in questo modulo. CENTER : una coordinata X,Y per l'oggetto. POLYGON : Un array di coordinate X,Y che fornisce un contorno per l'oggetto. Quando viene fornito il parametro RESET , tutti gli oggetti definiti verranno cancellati e il modulo [exclude_object] verr\u00e0 ripristinato. EXCLUDE_OBJECT_START \u00b6 EXCLUDE_OBJECT_START NAME=object_name : questo comando prende un parametro NAME e marca l'inizio del gcode per un oggetto sul livello corrente. EXCLUDE_OBJECT_END \u00b6 EXCLUDE_OBJECT_END [NAME=object_name] : Denota la fine del gcode dell'oggetto per il livello. \u00c8 accoppiato con EXCLUDE_OBJECT_START . Un parametro NAME \u00e8 facoltativo e avviser\u00e0 solo quando il nome fornito non corrisponde all'oggetto corrente. [extruder] \u00b6 I seguenti comandi sono disponibili se una sezione di configurazione dell'estrusore \u00e8 abilitata: ACTIVATE_EXTRUDER \u00b6 ACTIVATE_EXTRUDER EXTRUDER=<config_name> : in una stampante con pi\u00f9 sezioni di configurazione extruder , questo comando cambia l'hotend attivo. SET_PRESSURE_ADVANCE \u00b6 SET_PRESSURE_ADVANCE [EXTRUDER=<config_name>] [ADVANCE=<pressure_advance>] [SMOOTH_TIME=<pressure_advance_smooth_time>] : Imposta i parametri di pressure advance delleo stepper di un estrusore (come definito in un estrusore o [ extruder_stepper] (sezione di configurazione Config_Reference.md#extruder_stepper). Se EXTRUDER non \u00e8 specificato, per impostazione predefinita viene utilizzato lo stepper definito nell'hotend attivo. SET_EXTRUDER_ROTATION_DISTANCE \u00b6 SET_EXTRUDER_ROTATION_DISTANCE EXTRUDER=<config_name> [DISTANCE=<distance>] : Imposta un nuovo valore per la \"distanza di rotazione\" dello stepper dell'estrusore fornito (come definito in un extruder o extruder_stepper sezione di configurazione). Se la distanza di rotazione \u00e8 un numero negativo, il movimento passo-passo verr\u00e0 invertito (rispetto alla direzione passo-passo specificata nel file di configurazione). Le impostazioni modificate non vengono mantenute al ripristino di Klipper. Usare con cautela poich\u00e9 piccole modifiche possono causare una pressione eccessiva tra l'estrusore e l'hotend. Eseguire una corretta calibrazione con il filamento prima dell'uso. Se il valore 'DISTANZA' non viene fornito, questo comando restituir\u00e0 la distanza di rotazione corrente. SYNC_EXTRUDER_MOTION \u00b6 SYNC_EXTRUDER_MOTION EXTRUDER=<nome> MOTION_QUEUE=<nome> : questo comando attiver\u00e0 lo stepper specificato da EXTRUDER (come definito in un extruder o extruder_stepper config sezione) per sincronizzarsi con il movimento di un estrusore specificato da MOTION_QUEUE (come definito in una sezione di configurazione estrusore ). Se MOTION_QUEUE \u00e8 una stringa vuota, lo stepper verr\u00e0 desincronizzato da tutti i movimenti dell'estrusore. [fan_generic] \u00b6 Il comando seguente \u00e8 disponibile quando una sezione di configurazione fan_generic \u00e8 abilitata. SET_FAN_SPEED \u00b6 SET_FAN_SPEED FAN=config_name SPEED=<velocit\u00e0> Questo comando imposta la velocit\u00e0 di una ventola. \"velocit\u00e0\" deve essere compresa tra 0.0 e 1.0. SET_FAN_SPEED PIN=config_name TEMPLATE=<template_name> [<param_x>=<literal>] : If TEMPLATE is specified then it assigns a display_template to the given fan. For example, if one defined a [display_template my_fan_template] config section then one could assign TEMPLATE=my_fan_template here. The display_template should produce a string containing a floating point number with the desired value. The template will be continuously evaluated and the fan will be automatically set to the resulting speed. One may set display_template parameters to use during template evaluation (parameters will be parsed as Python literals). If TEMPLATE is an empty string then this command will clear any previous template assigned to the pin (one can then use SET_FAN_SPEED commands to manage the values directly). [filament_switch_sensor] \u00b6 Il comando seguente \u00e8 disponibile quando \u00e8 abilitata una sezione di configurazione filament_switch_sensor o filament_motion_sensor . QUERY_FILAMENT_SENSOR \u00b6 QUERY_FILAMENT_SENSOR SENSOR=<sensor_name> : Interroga lo stato del sensore di filamento. I dati visualizzati sul terminale dipenderanno dal tipo di sensore definito nella configurazione. SET_FILAMENT_SENSOR \u00b6 SET_FILAMENT_SENSOR SENSOR=<nome_sensore> ENABLE=[0|1] : Attiva/disattiva il sensore di filamento. Se ENABLE \u00e8 impostato su 0, il sensore di filamento sar\u00e0 disabilitato, se impostato su 1 sar\u00e0 abilitato. [firmware_retraction] \u00b6 I seguenti comandi G-Code standard sono disponibili quando la sezione di configurazione firmware_retraction \u00e8 abilitata. Questi comandi consentono di utilizzare la funzione di retraction del firmware disponibile in molti slicer, per ridurre lo stringing durante gli spostamenti di non estrusione da una parte all'altra della stampa. Configurando opportunamente la pressure advance si riduce la lunghezza della retrazione richiesta. G10 : Ritrae l'estrusore utilizzando i parametri attualmente configurati. G11 : Ritira l'estrusore utilizzando i parametri attualmente configurati. Sono inoltre disponibili i seguenti comandi aggiuntivi. SET_RETRACTION \u00b6 SET_RETRACTION [RETRACT_LENGTH=<mm>] [RETRACT_SPEED=<mm/s>] [UNRETRACT_EXTRA_LENGTH=<mm>] [UNRETRACT_SPEED=<mm/s>] : regola i parametri utilizzati dalla retrazione. RETRACT_LENGTH determina la lunghezza del filamento da ritrarre e estrudere. La velocit\u00e0 di retrazione viene regolata tramite RETRACT_SPEED, ed \u00e8 generalmente impostata su un valore relativamente alto. La velocit\u00e0 di annullamento viene regolata tramite UNRETRACT_SPEED e non \u00e8 particolarmente critica, sebbene spesso inferiore a RETRACT_SPEED. In alcuni casi \u00e8 utile aggiungere una piccola quantit\u00e0 di lunghezza aggiuntiva all'annullamento della retrazione, e questa viene impostata tramite UNRETRACT_EXTRA_LENGTH. SET_RETRACTION \u00e8 comunemente impostato come parte della configurazione dello slicer per filamento, poich\u00e9 filamenti diversi richiedono impostazioni dei parametri diverse. GET_RETRACTION \u00b6 GET_RETRACTION : interroga i parametri correnti utilizzati dal firmware per retrazione e li visualizza sul terminale. [force_move] \u00b6 Il modulo force_move viene caricato automaticamente, tuttavia alcuni comandi richiedono l'impostazione di enable_force_move in printer config . STEPPER_BUZZ \u00b6 STEPPER_BUZZ STEPPER=<nome_config> : sposta lo stepper dato in avanti di 1 mm e poi indietro di 1 mm, ripetuto 10 volte. Questo \u00e8 uno strumento diagnostico per aiutare a verificare la connettivit\u00e0 stepper. FORCE_MOVE \u00b6 FORCE_MOVE STEPPER=<nome_config> DISTANCE=<value> VELOCITY=<value> [ACCEL=<value>] : Questo comando sposter\u00e0 forzatamente lo stepper dato della distanza data (in mm) alla velocit\u00e0 costante data (in mm/ S). Se viene specificato ACCEL ed \u00e8 maggiore di zero, verr\u00e0 utilizzata l'accelerazione data (in mm/s^2); altrimenti non viene eseguita alcuna accelerazione. Non vengono effettuati controlli sui limiti; non vengono effettuati aggiornamenti cinematici; altri stepper paralleli su un asse non verranno spostati. Prestare attenzione poich\u00e9 un comando errato potrebbe causare danni! L'uso di questo comando metter\u00e0 quasi sicuramente la cinematica di basso livello in uno stato errato; emettere un G28 in seguito per ripristinare la cinematica. Questo comando \u00e8 destinato alla diagnostica e al debug di basso livello. SET_KINEMATIC_POSITION \u00b6 SET_KINEMATIC_POSITION [X=<value>] [Y=<value>] [Z=<value>] [CLEAR=<[X][Y][Z]>] : Force the low-level kinematic code to believe the toolhead is at the given cartesian position. This is a diagnostic and debugging command; use SET_GCODE_OFFSET and/or G92 for regular axis transformations. If an axis is not specified then it will default to the position that the head was last commanded to. Setting an incorrect or invalid position may lead to internal software errors. Use the CLEAR parameter to forget the homing state for the given axes. Note that CLEAR will not override the previous functionality; if an axis is not specified to CLEAR it will have its kinematic position set as per above. This command may invalidate future boundary checks; issue a G28 afterwards to reset the kinematics. [gcode] \u00b6 Il modulo gcode viene caricato automaticamente. RESTART \u00b6 RESTART : Ci\u00f2 far\u00e0 s\u00ec che il software host ricarichi la sua configurazione ed esegua un ripristino interno. Questo comando non canceller\u00e0 lo stato di errore dal microcontrollore (vedi FIRMWARE_RESTART) n\u00e9 caricher\u00e0 nuovo software (vedi FAQ ) . FIRMWARE_RESTART \u00b6 FIRMWARE_RESTART : Questo \u00e8 simile a un comando RESTART, ma cancella anche qualsiasi stato di errore dal microcontrollore. STATUS \u00b6 STATUS : segnala lo stato del software host di Klipper. HELP \u00b6 HELP : riporta l'elenco dei comandi G-Code estesi disponibili. [gcode_arcs] \u00b6 I seguenti comandi G-Code standard sono disponibili se una sezione di configurazione gcode_arcs \u00e8 abilitata: Movimento dell'arco in senso orario (G2), Movimento dell'arco in senso antiorario (G3): G2|G3 [X<pos>] [Y<pos>] [Z<pos>] [E<pos>] [F<velocit\u00e0>] I<valore> J<valore>|I<valore> K<valore>|J<valore> K<valore> Selezione del piano dell'arco: G17 (piano XY), G18 (piano XZ), G19 (piano YZ) [gcode_macro] \u00b6 Il comando seguente \u00e8 disponibile quando \u00e8 abilitata una sezione di configurazione gcode_macro (consultare anche la guida ai modelli di comando ). SET_GCODE_VARIABLE \u00b6 SET_GCODE_VARIABLE MACRO=<nome_macro> VARIABLE=<nome> VALUE=<valore> : questo comando consente di modificare il valore di una variabile gcode_macro in fase di esecuzione. Il VALUE fornito viene analizzato come un valore literal in Python. [gcode_move] \u00b6 Il modulo gcode_move viene caricato automaticamente. GET_POSITION \u00b6 GET_POSITION`: Restituisce informazioni sulla posizione corrente della testa di stampa. Per ulteriori informazioni, vedere la documentazione per gli sviluppatori di GET_POSITION output . SET_GCODE_OFFSET \u00b6 SET_GCODE_OFFSET [X=<pos>|X_ADJUST=<regola>] [Y=<pos>|Y_ADJUST=<regola>] [Z=<pos>|Z_ADJUST=<regola>] [MOVE=1 [MOVE_SPEED=<velocit\u00e0 >]] : imposta un offset di posizione da applicare ai futuri comandi G-Code. Questo \u00e8 comunemente usato per cambiare virtualmente l'offset del letto Z o per impostare gli offset XY degli ugelli quando si cambia estrusore. Ad esempio, se viene inviato \"SET_GCODE_OFFSET Z=0.2\", i futuri movimenti G-Code avranno 0.2 mm aggiunti alla loro altezza Z. Se vengono utilizzati i parametri di stile X_ADJUST, la regolazione verr\u00e0 aggiunta a qualsiasi offset esistente (ad esempio, \"SET_GCODE_OFFSET Z=-0.2\" seguito da \"SET_GCODE_OFFSET Z_ADJUST=0.3\" risulter\u00e0 in un offset Z totale di 0.1). Se viene specificato \"MOVE=1\", verr\u00e0 emesso un movimento della testa di stampa per applicare l'offset specificato (altrimenti l'offset avr\u00e0 effetto sul successivo movimento assoluto del codice G che specifica l'asse dato). Se viene specificato \"MOVE_SPEED\", lo spostamento della testa utensile verr\u00e0 eseguito con la velocit\u00e0 data (in mm/s); in caso contrario, il movimento della testa utensile utilizzer\u00e0 l'ultima velocit\u00e0 del G-code specificata. SAVE_GCODE_STATE \u00b6 SAVE_GCODE_STATE [NAME=<nome_stato>] : salva lo stato di analisi delle coordinate del G-code corrente. Il salvataggio e il ripristino dello stato del G-code \u00e8 utile negli script e nelle macro. Questo comando salva la modalit\u00e0 di coordinate assolute del G-code corrente (G90/G91), la modalit\u00e0 di estrusione assoluta (M82/M83), l'origine (G92), l'offset (SET_GCODE_OFFSET), l'override della velocit\u00e0 (M220), l'override dell'estrusore (M221), la velocit\u00e0 di spostamento , la posizione XYZ corrente e la posizione relativa dell'estrusore \"E\". Se viene fornito NAME, consente di assegnare un nome allo stato salvato alla stringa data. Se NAME non viene fornito, il valore predefinito \u00e8 \"predefinito\". RESTORE_GCODE_STATE \u00b6 RESTORE_GCODE_STATE [NAME=<nome_stato>] [MOVE=1 [MOVE_SPEED=<velocit\u00e0>]] : ripristina uno stato precedentemente salvato tramite SAVE_GCODE_STATE. Se viene specificato \"MOVE=1\", verr\u00e0 emesso un movimento della testa utensile per tornare alla posizione XYZ precedente. Se viene specificato \"MOVE_SPEED\", lo spostamento della testa utensile verr\u00e0 eseguito con la velocit\u00e0 data (in mm/s); in caso contrario, lo spostamento della testa utensile utilizzer\u00e0 la velocit\u00e0 del codice g ripristinata. [hall_filament_width_sensor] \u00b6 I seguenti comandi sono disponibili quando la sezione di configurazione del sensore di larghezza del filamento tsl1401cl o sezione di configurazione del sensore di larghezza del filamento hall \u00e8 abilitata (consultare anche Sensore di larghezza del filamento TSLl401CL e Hall Filament Width Sensor ): QUERY_FILAMENT_WIDTH \u00b6 QUERY_FILAMENT_WIDTH : Restituisce lo spessore del filamento misurato. RESET_FILAMENT_WIDTH_SENSOR \u00b6 RESET_FILAMENT_WIDTH_SENSOR : Cancella tutte le letture del sensore. Utile dopo il cambio del filamento. DISABLE_FILAMENT_WIDTH_SENSOR \u00b6 DISABLE_FILAMENT_WIDTH_SENSOR : Spegnere il sensore di larghezza del filamento e smettere di usarlo per il controllo del flusso. ENABLE_FILAMENT_WIDTH_SENSOR \u00b6 ENABLE_FILAMENT_WIDTH_SENSOR : attiva il sensore di larghezza del filamento e inizia a usarlo per il controllo del flusso. QUERY_RAW_FILAMENT_WIDTH \u00b6 QUERY_RAW_FILAMENT_WIDTH : Restituisce le letture del canale ADC corrente e il valore grezzo (raw) del sensore per i punti di calibrazione. ENABLE_FILAMENT_WIDTH_LOG \u00b6 ENABLE_FILAMENT_WIDTH_LOG : attiva la registrazione del diametro del filamento. DISABLE_FILAMENT_WIDTH_LOG \u00b6 DISABLE_FILAMENT_WIDTH_LOG : Disattiva la registrazione del diametro del filamento. [heaters] \u00b6 Il modulo heaters viene caricato automaticamente se un riscaldatore \u00e8 definito nel file di configurazione. TURN_OFF_HEATERS \u00b6 TURN_OFF_HEATERS : Spegni tutti i riscaldatori. TEMPERATURE_WAIT \u00b6 TEMPERATURE_WAIT SENSOR=<config_name> [MINIMUM=<target>] [MAXIMUM=<target>] : Attendere fino a quando il sensore di temperatura specificato \u00e8 pari o superiore al MINIMO fornito e/o pari o inferiore al MASSIMO fornito. SET_HEATER_TEMPERATURE \u00b6 SET_HEATER_TEMPERATURE HEATER=<nome_riscaldatore> [TARGET=<temperatura_destinata>] : Imposta la temperatura target per un riscaldatore. Se non viene fornita una temperatura target, il target \u00e8 0. [idle_timeout] \u00b6 Il modulo idle_timeout viene caricato automaticamente. SET_IDLE_TIMEOUT \u00b6 SET_IDLE_TIMEOUT [TIMEOUT=<timeout>] : consente all'utente di impostare il timeout di inattivit\u00e0 (in secondi). [input_shaper] \u00b6 Il comando seguente \u00e8 abilitato se \u00e8 stata abilitata una sezione di configurazione di input_shaper (consultare anche la guida alla compensazione della risonanza ). SET_INPUT_SHAPER \u00b6 SET_INPUT_SHAPER [SHAPER_FREQ_X=<shaper_freq_x>] [SHAPER_FREQ_Y=<shaper_freq_y>] [DAMPING_RATIO_X=<damping_ratio_x>] [DAMPING_RATIO_Y=<damping_ratio_y>] [SHAPER_TYPE=<shaper>] [SHAPER_TYPE_X=<shaper_type_x>] [SHAPER_TYPE=<shaper_TYPE_X=<shaper_type_x>] [SHAPER_TYPE=<shaper_type_y=<shaper_type_x> ] : Modifica i parametri dell'input shaper. Si noti che il parametro SHAPER_TYPE reimposta l'input shaper per entrambi gli assi X e Y anche se sono stati configurati tipi di shaper diversi nella sezione [input_shaper]. SHAPER_TYPE non pu\u00f2 essere utilizzato insieme a uno dei parametri SHAPER_TYPE_X e SHAPER_TYPE_Y. Vedere config reference per maggiori dettagli su ciascuno di questi parametri. [manual_probe] \u00b6 Il modulo manual_probe viene caricato automaticamente. MANUAL_PROBE \u00b6 MANUAL_PROBE [SPEED=<speed>] : esegue uno script di supporto utile per misurare l'altezza dell'ugello in una determinata posizione. Se viene specificato SPEED, imposta la velocit\u00e0 dei comandi TESTZ (il valore predefinito \u00e8 5mm/s). Durante una sonda manuale, sono disponibili i seguenti comandi aggiuntivi: ACCEPT : questo comando accetta la posizione Z corrente e conclude il probing manuale. ABORT : questo comando termina lo strumento di probing manuale. TESTZ Z=<valore> : questo comando sposta l'ugello verso l'alto o verso il basso della quantit\u00e0 specificata in \"valore\". Ad esempio, TESTZ Z=-.1 sposterebbe l'ugello verso il basso di .1 mm mentre TESTZ Z=.1 sposterebbe l'ugello verso l'alto di .1 mm. Il valore pu\u00f2 anche essere + , - , ++ o -- per spostare l'ugello verso l'alto o verso il basso di un importo rispetto ai tentativi precedenti. Z_ENDSTOP_CALIBRATE \u00b6 Z_ENDSTOP_CALIBRATE [SPEED=<speed>] : esegue uno script di supporto utile per calibrare un'impostazione di configurazione Z position_endstop. Vedere il comando MANUAL_PROBE per i dettagli sui parametri e sui comandi aggiuntivi disponibili mentre lo strumento \u00e8 attivo. Z_OFFSET_APPLY_ENDSTOP \u00b6 Z_OFFSET_APPLY_ENDSTOP : prende l'offset Z Gcode corrente (noto anche come babystepping) e lo sottrae da stepper_z endstop_position. Questa azione per prendere un valore di babystep utilizzato di frequente e \"renderlo permanente\". Richiede un SAVE_CONFIG per avere effetto. [Stepper manuali] \u00b6 Il comando seguente \u00e8 disponibile quando una sezione di configurazione stepper_manuale \u00e8 abilitata. MANUAL_STEPPER \u00b6 MANUAL_STEPPER STEPPER=nome_config [ENABLE=[0|1]] [SET_POSITION=<pos>] [SPEED=<velocit\u00e0>] [ACCEL=<accelerazione>] [MOVE=<pos> [STOP_ON_ENDSTOP=[1|2|- 1|-2]] [SYNC=0]] : Questo comando alterer\u00e0 lo stato dello stepper. Utilizzare il parametro ENABLE per abilitare/disabilitare lo stepper. Utilizzare il parametro SET_POSITION per forzare lo stepper a pensare di trovarsi nella posizione data. Utilizzare il parametro MOVE per richiedere un movimento alla posizione data. Se viene specificato SPEED e/o ACCEL, verranno utilizzati i valori forniti al posto dei valori predefiniti specificati nel file di configurazione. Se viene specificato un ACCEL pari a zero, non verr\u00e0 eseguita alcuna accelerazione. Se viene specificato STOP_ON_ENDSTOP=1, lo spostamento terminer\u00e0 in anticipo se l'endstop segnala come attivato (usa STOP_ON_ENDSTOP=2 per completare lo spostamento senza errori anche se l'endstop non si attiva, usa -1 o -2 per interrompere quando l'endstop segnala non innescato). Normalmente i futuri comandi G-Code verranno programmati per essere eseguiti dopo il completamento del movimento passo-passo, tuttavia se un movimento passo-passo manuale utilizza SYNC=0, i futuri comandi di movimento G-Code potrebbero essere eseguiti in parallelo con il movimento passo-passo. [mcp4018] \u00b6 Il comando seguente \u00e8 disponibile quando una sezione di configurazione mcp4018 \u00e8 abilitata. SET_DIGIPOT \u00b6 SET_DIGIPOT DIGIPOT=config_name WIPER=<value> : Questo comando cambier\u00e0 il valore corrente del digipot. Questo valore dovrebbe essere in genere compreso tra 0.0 e 1.0, a meno che non sia definita una 'scale' nella configurazione. Quando viene definita 'scale', questo valore dovrebbe essere compreso tra 0,0 e 'scale'. [led] \u00b6 Il comando seguente \u00e8 disponibile quando una qualsiasi delle sezioni di configurazione led \u00e8 abilitata. SET_LED \u00b6 SET_LED LED=<nome_config> ROSSO=<valore> VERDE=<valore> BLU=<valore> BIANCO=<valore> [INDEX=<indice>] [TRANSMIT=0] [SYNC=1] : Imposta il LED in output. Ogni colore <valore> deve essere compreso tra 0,0 e 1,0. L'opzione BIANCO \u00e8 valida solo su LED RGBW. Se il LED supporta pi\u00f9 chip in una catena daisy-chain, \u00e8 possibile specificare INDEX per modificare il colore del solo chip specificato (1 per il primo chip, 2 per il secondo, ecc.). Se INDEX non viene fornito, tutti i LED nella catena verranno impostati sul colore fornito. Se viene specificato TRANSMIT=0, il cambio colore verr\u00e0 effettuato solo sul successivo comando SET_LED che non specifica TRANSMIT=0; questo pu\u00f2 essere utile in combinazione con il parametro INDEX per raggruppare pi\u00f9 aggiornamenti in una catena. Per impostazione predefinita, il comando SET_LED sincronizzer\u00e0 le modifiche con altri comandi gcode in corso. Ci\u00f2 pu\u00f2 comportare un comportamento indesiderato se i LED vengono impostati mentre la stampante non sta stampando in quanto reimposta il timeout di inattivit\u00e0. Se non \u00e8 necessaria una tempistica attenta, \u00e8 possibile specificare il parametro SYNC=0 opzionale per applicare le modifiche senza ripristinare il timeout di inattivit\u00e0. SET_LED_TEMPLATE \u00b6 SET_LED_TEMPLATE LED=<nome_led> TEMPLATE=<nome_modello> [<param_x>=<letterale>] [INDEX=<indice>] : Assegna un modello_visualizzazione a un dato LED . Ad esempio, se si definisce una sezione di configurazione [display_template my_led_template] allora si potrebbe assegnare TEMPLATE=my_led_template qui. Il display_template dovrebbe produrre una stringa separata da virgole contenente quattro numeri in virgola mobile corrispondenti alle impostazioni dei colori rosso, verde, blu e bianco. Il modello verr\u00e0 continuamente valutato e il LED verr\u00e0 impostato automaticamente sui colori risultanti. \u00c8 possibile impostare i parametri display_template da utilizzare durante la valutazione del modello (i parametri verranno analizzati come valori letterali Python). Se INDEX non \u00e8 specificato, tutti i chip nella catena dei LED verranno impostati sul modello, altrimenti verr\u00e0 aggiornato solo il chip con l'indice specificato. Se TEMPLATE \u00e8 una stringa vuota, questo comando canceller\u00e0 qualsiasi modello precedente assegnato al LED (\u00e8 quindi possibile utilizzare i comandi SET_LED per gestire le impostazioni del colore del LED). [output_pin] \u00b6 Il comando seguente \u00e8 disponibile quando una sezione di configurazione pin_output \u00e8 abilitata. SET_PIN \u00b6 SET_PIN PIN=config_name VALUE=<value> : Set the pin to the given output VALUE . VALUE should be 0 or 1 for \"digital\" output pins. For PWM pins, set to a value between 0.0 and 1.0, or between 0.0 and scale if a scale is configured in the output_pin config section. SET_PIN PIN=config_name TEMPLATE=<template_name> [<param_x>=<literal>] : If TEMPLATE is specified then it assigns a display_template to the given pin. For example, if one defined a [display_template my_pin_template] config section then one could assign TEMPLATE=my_pin_template here. The display_template should produce a string containing a floating point number with the desired value. The template will be continuously evaluated and the pin will be automatically set to the resulting value. One may set display_template parameters to use during template evaluation (parameters will be parsed as Python literals). If TEMPLATE is an empty string then this command will clear any previous template assigned to the pin (one can then use SET_PIN commands to manage the values directly). [palette2] \u00b6 I seguenti comandi sono disponibili quando la sezione di configurazione della palette2 \u00e8 abilitata. Le stampe di Palette funzionano incorporando speciali OCodes (Codici Omega) nel file GCode: O1 ... O32 : Questi codici vengono letti dal flusso GCode ed elaborati da questo modulo e passati al dispositivo Palette 2. Sono inoltre disponibili i seguenti comandi aggiuntivi. PALETTE_CONNECT \u00b6 PALETTE_CONNECT : questo comando inizializza la connessione con la Palette 2. PALETTE_DISCONNECT \u00b6 PALETTE_DISCONNECT : questo comando si disconnette dalla Palette 2. PALETTE_CLEAR \u00b6 PALETTE_CLEAR : questo comando indica alla Palette 2 di cancellare tutti i percorsi di input e output del filamento. PALETTE_CUT \u00b6 PALETTE_CUT : Questo comando indica alla Palette 2 di tagliare il filamento attualmente caricato nello splice core. PALETTE_SMART_LOAD \u00b6 PALETTE_SMART_LOAD : Questo comando avvia la sequenza di caricamento intelligente sulla Palette 2. Il filamento viene caricato automaticamente estrudendolo alla distanza calibrata sul dispositivo per la stampante e istruisce la Palette 2 una volta completato il caricamento. Questo comando equivale a premere Smart Load direttamente sullo schermo della Palette 2 dopo che il caricamento del filamento \u00e8 stato completato. [pid_calibrate] \u00b6 Il modulo pid_calibrate viene caricato automaticamente se nel file di configurazione \u00e8 definito un riscaldatore. PID_CALIBRATE \u00b6 PID_CALIBRATE HEATER=<nome_config> TARGET=<temperatura> [WRITE_FILE=1] : esegue un test di calibrazione PID. Il riscaldatore specificato verr\u00e0 abilitato fino al raggiungimento della temperatura target specificata, quindi il riscaldatore verr\u00e0 spento e acceso per diversi cicli. Se il parametro WRITE_FILE \u00e8 abilitato, verr\u00e0 creato il file /tmp/heattest.txt con un log di tutti i campioni di temperatura prelevati durante il test. [pause_resume] \u00b6 I seguenti comandi sono disponibili quando la pause_resume config section \u00e8 abilitata: PAUSE \u00b6 PAUSE : mette in pausa la stampa corrente. La posizione attuale viene acquisita per la ripresa al ripristino. RESUME \u00b6 RESUME [VELOCITY=<value>] : riprende la stampa da una pausa, ripristinando prima la posizione precedentemente acquisita. Il parametro VELOCITY determina la velocit\u00e0 alla quale l'utensile deve tornare alla posizione originale acquisita. CLEAR_PAUSE \u00b6 CLEAR_PAUSE : cancella lo stato di pausa corrente senza riprendere la stampa. Questo \u00e8 utile se si decide di annullare una stampa dopo un PAUSE. Si consiglia di aggiungerlo al gcode iniziale per assicurarsi che lo stato in pausa sia aggiornato per ogni stampa. CANCEL_PRINT \u00b6 CANCEL_PRINT : Annulla la stampa corrente. [print_stats] \u00b6 Il modulo print_stats viene caricato automaticamente. SET_PRINT_STATS_INFO \u00b6 SET_PRINT_STATS_INFO [TOTAL_LAYER=<total_layer_count>] [CURRENT_LAYER= <current_layer>] : passa le informazioni sulo slicer come il layer attivo ed il totale a Klipper. Aggiungi SET_PRINT_STATS_INFO [TOTAL_LAYER=<total_layer_count>] alla sezione gcode di inizio del tuo slicer e SET_PRINT_STATS_INFO [CURRENT_LAYER= <current_layer>] alla sezione gcode di cambio livello per passare le informazioni sul livello dal tuo slicer a Klipper. [probe] \u00b6 I seguenti comandi sono disponibili quando \u00e8 abilitata una sezione di configurazione della sonda o una sezione di configurazione di bltouch (consultare anche la guida alla calibrazione della sonda ). sonda \u00b6 PROBE [PROBE_SPEED=<mm/s>] [LIFT_SPEED=<mm/s>] [SAMPLES=<count>] [SAMPLE_RETRACT_DIST=<mm>] [SAMPLES_TOLERANCE=<mm>] [SAMPLES_TOLERANCE_RETRIES=<count>] [SAMPLES_RESULT=median|average] : Sposta il nozzle verso il basso finch\u00e9 la sonda non scatta. Se viene fornito uno qualsiasi dei parametri opzionali, sovrascrive l'impostazione equivalente nella sezione probe config section . QUERY_PROBE \u00b6 QUERY_PROBE : Riporta lo stato corrente della sonda (\"triggered\" o \"open\"). PROBE_ACCURACY \u00b6 PROBE_ACCURACY [PROBE_SPEED=<mm/s>] [SAMPLES=<count>] [SAMPLE_RETRACT_DIST=<mm>] : Calcola la deviazione massima, minima, media, mediana e standard di pi\u00f9 campionamentidella sonda. Per impostazione predefinita, vengono presi 10 CAMPIONI. In caso contrario, i parametri opzionali sono impostati per default sulla loro impostazione equivalente nella sezione di configurazione della sonda. PROBE_CALIBRATE \u00b6 PROBE_CALIBRATE [SPEED=<speed>] [<probe_parameter>=<value>] : Eseguire uno script di aiuto utile per calibrare l'offset z della sonda. Vedere il comando PROBE per i dettagli sui parametri opzionali della sonda. Vedere il comando MANUAL_PROBE per i dettagli del parametro SPEED e sui comandi aggiuntivi disponibili mentre lo strumento \u00e8 attivo. Nota che il comando PROBE_CALIBRATE utilizza la variabile di velocit\u00e0 per spostarsi in direzione XY e Z. Z_OFFSET_APPLY_PROBE \u00b6 Z_OFFSET_APPLY_PROBE : prende l'offset Z Gcode corrente (aka, babystepping) e lo sottrae dallo z_offset della sonda. Questo per prendere un valore di babystep utilizzato di frequente e \"renderlo permanente\". Richiede un SAVE_CONFIG per avere effetto. [probe_eddy_current] \u00b6 The following commands are available when a probe_eddy_current config section is enabled. PROBE_EDDY_CURRENT_CALIBRATE \u00b6 PROBE_EDDY_CURRENT_CALIBRATE CHIP=<config_name> : This starts a tool that calibrates the sensor resonance frequencies to corresponding Z heights. The tool will take a couple of minutes to complete. After completion, use the SAVE_CONFIG command to store the results in the printer.cfg file. LDC_CALIBRATE_DRIVE_CURRENT \u00b6 LDC_CALIBRATE_DRIVE_CURRENT CHIP=<config_name> This tool will calibrate the ldc1612 DRIVE_CURRENT0 register. Prior to using this tool, move the sensor so that it is near the center of the bed and about 20mm above the bed surface. Run this command to determine an appropriate DRIVE_CURRENT for the sensor. After running this command use the SAVE_CONFIG command to store that new setting in the printer.cfg config file. [pwm_cycle_time] \u00b6 The following command is available when a pwm_cycle_time config section is enabled. SET_PIN \u00b6 SET_PIN PIN=config_name VALUE=<value> [CYCLE_TIME=<cycle_time>] : This command works similarly to output_pin SET_PIN commands. The command here supports setting an explicit cycle time using the CYCLE_TIME parameter (specified in seconds). Note that the CYCLE_TIME parameter is not stored between SET_PIN commands (any SET_PIN command without an explicit CYCLE_TIME parameter will use the cycle_time specified in the pwm_cycle_time config section). [quad_gantry_level] \u00b6 The following commands are available when the quad_gantry_level config section is enabled. QUAD_GANTRY_LEVEL \u00b6 QUAD_GANTRY_LEVEL [RETRIES=<value>] [RETRY_TOLERANCE=<value>] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] : This command will probe the points specified in the config and then make independent adjustments to each Z stepper to compensate for tilt. See the PROBE command for details on the optional probe parameters. The optional RETRIES , RETRY_TOLERANCE , and HORIZONTAL_MOVE_Z values override those options specified in the config file. [query_adc] \u00b6 Il modulo query_adc viene caricato automaticamente. QUERY_ADC \u00b6 QUERY_ADC [NAME=<config_name>] [PULLUP=<value>] : Riporta l'ultimo valore analogico ricevuto per un pin analogico configurato. Se NAME non viene fornito, viene riportato l'elenco dei nomi dei convertitori adc disponibili. Se viene fornito PULLUP (come valore in Ohm), viene riportato il valore analogico grezzo insieme alla resistenza equivalente dato quel pullup specificato. [query_endstops] \u00b6 Il modulo query_endstops viene caricato automaticamente. I seguenti comandi G-Code standard sono attualmente disponibili, ma non \u00e8 consigliabile utilizzarli: Ottieni lo stato del finecorsa: M119 (usa invece QUERY_ENDSTOPS.) QUERY_ENDSTOPS \u00b6 QUERY_ENDSTOPS : Rilevare i finecorsa degli assi e segnala se sono \"attivate\" o in uno stato \"aperto\". Questo comando viene in genere utilizzato per verificare che un finecorsa funzioni correttamente. [resonance_tester] \u00b6 I seguenti comandi sono disponibili quando una sezione di configurazione di tester_risonanza \u00e8 abilitata (consultare anche la guida alle risonanze di misurazione ). MEASURE_AXES_NOISE \u00b6 MEASURE_AXES_NOISE : misura ed riporta il rumore per tutti gli assi di tutti i chip dell'accelerometro abilitati. TEST_RESONANCES \u00b6 TEST_RESONANCES AXIS=<axis> [OUTPUT=<resonances,raw_data>] [NAME=<name>] [FREQ_START=<min_freq>] [FREQ_END=<max_freq>] [ACCEL_PER_HZ=<accel_per_hz>] [HZ_PER_SEC=<hz_per_sec>] [CHIPS=<chip_name>] [POINT=x,y,z] [INPUT_SHAPING=<0:1>] : Runs the resonance test in all configured probe points for the requested \"axis\" and measures the acceleration using the accelerometer chips configured for the respective axis. \"axis\" can either be X or Y, or specify an arbitrary direction as AXIS=dx,dy , where dx and dy are floating point numbers defining a direction vector (e.g. AXIS=X , AXIS=Y , or AXIS=1,-1 to define a diagonal direction). Note that AXIS=dx,dy and AXIS=-dx,-dy is equivalent. chip_name can be one or more configured accel chips, delimited with comma, for example CHIPS=\"adxl345, adxl345 rpi\" . If POINT is specified it will override the point(s) configured in [resonance_tester] . If INPUT_SHAPING=0 or not set(default), disables input shaping for the resonance testing, because it is not valid to run the resonance testing with the input shaper enabled. OUTPUT parameter is a comma-separated list of which outputs will be written. If raw_data is requested, then the raw accelerometer data is written into a file or a series of files /tmp/raw_data_<axis>_[<chip_name>_][<point>_]<name>.csv with ( <point>_ part of the name generated only if more than 1 probe point is configured or POINT is specified). If resonances is specified, the frequency response is calculated (across all probe points) and written into /tmp/resonances_<axis>_<name>.csv file. If unset, OUTPUT defaults to resonances , and NAME defaults to the current time in \"YYYYMMDD_HHMMSS\" format. SHAPER_CALIBRATE \u00b6 SHAPER_CALIBRATE [AXIS=<axis>] [NAME=<name>] [FREQ_START=<min_freq>] [FREQ_END=<max_freq>] [ACCEL_PER_HZ=<accel_per_hz>][HZ_PER_SEC=<hz_per_sec>] [CHIPS=<chip_name>] [MAX_SMOOTHING=<max_smoothing>] [INPUT_SHAPING=<0:1>] : Similarly to TEST_RESONANCES , runs the resonance test as configured, and tries to find the optimal parameters for the input shaper for the requested axis (or both X and Y axes if AXIS parameter is unset). If MAX_SMOOTHING is unset, its value is taken from [resonance_tester] section, with the default being unset. See the Max smoothing of the measuring resonances guide for more information on the use of this feature. The results of the tuning are printed to the console, and the frequency responses and the different input shapers values are written to a CSV file(s) /tmp/calibration_data_<axis>_<name>.csv . Unless specified, NAME defaults to the current time in \"YYYYMMDD_HHMMSS\" format. Note that the suggested input shaper parameters can be persisted in the config by issuing SAVE_CONFIG command, and if [input_shaper] was already enabled previously, these parameters take effect immediately. [respond] \u00b6 I seguenti comandi G-Code standard sono disponibili quando la sezione di configurazione di risposta \u00e8 abilitata: M118 <messaggio> : fa eco al messaggio preceduto dal prefisso predefinito configurato (o echo: se non \u00e8 configurato alcun prefisso). Sono inoltre disponibili i seguenti comandi aggiuntivi. RESPOND \u00b6 RESPOND MSG=\"<message>\" : echo il messaggio preceduto dal prefisso predefinito configurato (o echo: se non \u00e8 configurato alcun prefisso). RESPOND TYPE=echo MSG=\"<message>\" : echo del messaggio preceduto da echo: . RESPOND TYPE=echo_no_space MSG=\"<messaggio>\" : fa eco al messaggio preceduto da echo: senza uno spazio tra prefisso e messaggio, utile per la compatibilit\u00e0 con alcuni plugin di octoprint che prevedono una formattazione molto specifica. RESPOND TYPE=command MSG=\"<message>\" : echo il messaggio preceduto da // . OctoPrint pu\u00f2 essere configurato per rispondere a questi messaggi (ad es. RESPOND TYPE=command MSG=action:pause ). RESPOND TYPE=error MSG=\"<messaggio>\" : fa eco al messaggio preceduto da !! . RESPOND PREFIX=<prefix> MSG=\"<message>\" : echo il messaggio preceduto da <prefix> . (Il parametro PREFIX avr\u00e0 la priorit\u00e0 sul parametro TYPE ) [save_variables] \u00b6 Il comando seguente \u00e8 abilitato se \u00e8 stata abilitata una sezione di configurazione save_variables . SAVE_VARIABLE \u00b6 SAVE_VARIABLE VARIABLE=<nome> VALUE=<valore> : salva la variabile su disco in modo che possa essere utilizzata tra i riavvii. Tutte le variabili memorizzate vengono caricate nel dict printer.save_variables.variables all'avvio e possono essere utilizzate nelle macro gcode. Il VALUE fornito viene analizzato come un valore letterale Python. [screws_tilt_adjust] \u00b6 I seguenti comandi sono disponibili quando la sezione di configurazione viti_tilt_adjust \u00e8 abilitata (consultare anche la manual level guide ). SCREWS_TILT_CALCULATE \u00b6 SCREWS_TILT_CALCULATE [DIRECTION=CW|CCW] [MAX_DEVIATION=<valore>] [HORIZONTAL_MOVE_Z=<valore>] [<probe_parameter>=<valore>] : questo comando richiamer\u00e0 lo strumento di regolazione delle viti del piatto. Comander\u00e0 l'ugello in posizioni diverse (come definito nel file di configurazione) sondando l'altezza z e calcoler\u00e0 il numero di giri della manopola per regolare il livello del piatto. Se \u00e8 specificata DIREZIONE, i giri della manopola saranno tutti nella stessa direzione, in senso orario (CW) o antiorario (CCW). Vedere il comando PROBE per i dettagli sui parametri opzionali della sonda. IMPORTANTE: DEVI sempre eseguire un G28 prima di utilizzare questo comando. Se viene specificato MAX_DEVIATION, il comando generer\u00e0 un errore gcode se qualsiasi differenza nell'altezza della vite rispetto all'altezza della vite di base \u00e8 maggiore del valore fornito. Il valore opzionale HORIZONTAL_MOVE_Z sovrascrive l'opzione horizontal_move_z specificata nel file di configurazione. [sdcard_loop] \u00b6 Quando la sezione di configurazione sdcard_loop \u00e8 abilitata, sono disponibili i seguenti comandi estesi. SDCARD_LOOP_BEGIN \u00b6 SDCARD_LOOP_BEGIN COUNT=<count> : inizia una sezione in loop nella stampa SD. Un conteggio pari a 0 indica che la sezione deve essere ripetuta indefinitamente. SDCARD_LOOP_END \u00b6 SDCARD_LOOP_END : termina una sezione in loop nella stampa SD. SDCARD_LOOP_DESIST \u00b6 SDCARD_LOOP_DESIST : completa i loop esistenti senza ulteriori iterazioni. [servo] \u00b6 I seguenti comandi sono disponibili quando una sezione di configurazione servo \u00e8 abilitata. SET_SERVO \u00b6 SET_SERVO SERVO=nome_config [ANGLE=<gradi> | WIDTH=<secondi>] : Imposta la posizione del servo sull'angolo dato (in gradi) o sulla larghezza dell'impulso (in secondi). Usa WIDTH=0 per disabilitare l'uscita servo. [skew_correction] \u00b6 I seguenti comandi sono disponibili quando \u00e8 abilitata la sezione config_correzione_asimmetria (consultare anche la guida Correzione_asimmetria ). SET_SKEW \u00b6 SET_SKEW [XY=<ac_length,bd_length,ad_length>] [XZ=<ac,bd,ad>] [YZ=<ac,bd,ad>] [CLEAR=<0|1>] : Configura il modulo [correzione_inclinazione ] con misure (in mm) tratte da una stampa di calibrazione. Si possono inserire misure per qualsiasi combinazione di piani, i piani non inseriti manterranno il loro valore attuale. Se viene immesso CLEAR=1 , tutta la correzione dell'inclinazione sar\u00e0 disabilitata. GET_CURRENT_SKEW \u00b6 GET_CURRENT_SKEW : Riporta l'inclinazione corrente della stampante per ciascun piano sia in radianti che in gradi. L'inclinazione viene calcolata in base ai parametri forniti tramite il gcode SET_SKEW . CALC_MEASURED_SKEW \u00b6 CALC_MEASURED_SKEW [AC=<ac_length>] [BD=<bd_length>] [AD=<ad_length>] : calcola e riporta l'inclinazione (in radianti e gradi) in base a una stampa di test misurata. Questo pu\u00f2 essere utile per determinare l'inclinazione corrente della stampante dopo che \u00e8 stata applicata la correzione. Pu\u00f2 anche essere utile prima di applicare la correzione per determinare se \u00e8 necessaria la correzione dell'inclinazione. Vedere Correzione inclinazione per i dettagli su oggetti e misurazioni di calibrazione inclinazione. SKEW_PROFILE \u00b6 SKEW_PROFILE [LOAD=<nome>] [SAVE=<nome>] [REMOVE=<nome>] : Gestione del profilo per correzione_inclinazione. LOAD ripristiner\u00e0 lo stato di inclinazione dal profilo corrispondente al nome fornito. SAVE salver\u00e0 lo stato di inclinazione corrente in un profilo che corrisponde al nome fornito. REMOVE eliminer\u00e0 il profilo corrispondente al nome fornito dalla memoria persistente. Si noti che dopo aver eseguito le operazioni SAVE o REMOVE \u00e8 necessario eseguire il gcode SAVE_CONFIG per rendere permanenti le modifiche alla memoria persistente. [smart_effector] \u00b6 Sono disponibili diversi comandi quando una sezione di configurazione smart_effector \u00e8 abilitata. Assicurati di controllare la documentazione ufficiale per Smart Effector su Duet3D Wiki prima di modificare i parametri di Smart Effector. Controllare anche la guida alla calibrazione della sonda . SET_SMART_EFFECTOR \u00b6 SET_SMART_EFFECTOR [SENSITIVITY=<sensibilit\u00e0>] [ACCEL=<accel>] [RECOVERY_TIME=<tempo>] : imposta i parametri di Smart Effector. Quando viene specificato SENSITIVITY , il rispettivo valore viene scritto nella EEPROM dello SmartEffector (richiede che sia fornito control_pin ). I valori di <sensibilit\u00e0> accettabili sono 0..255, il valore predefinito \u00e8 50. Valori inferiori richiedono una minore forza di contatto dell'ugello per attivarsi (ma esiste un rischio maggiore di falso trigger a causa delle vibrazioni durante la tastatura) e valori pi\u00f9 alti riducono il falso trigger (ma richiede una maggiore forza di contatto per attivarsi). Poich\u00e9 la sensibilit\u00e0 viene scritta nella EEPROM, viene conservata dopo lo spegnimento e quindi non \u00e8 necessario configurarla ad ogni avvio della stampante. ACCEL e RECOVERY_TIME consentono di sovrascrivere i parametri corrispondenti in fase di esecuzione, vedere la sezione di configurazione di Smart Effector per maggiori informazioni su quei parametri. RESET_SMART_EFFECTOR \u00b6 RESET_SMART_EFFECTOR : Ripristina la sensibilit\u00e0 di Smart Effector alle impostazioni di fabbrica. Richiede che il relativo control_pin sia fornito nella sezione di configurazione. [stepper_enable] \u00b6 Il modulo stepper_enable viene caricato automaticamente. SET_STEPPER_ENABLE \u00b6 SET_STEPPER_ENABLE STEPPER=<nome_config> ENABLE=[0|1] : Abilita o disabilita solo lo stepper dato. Questo \u00e8 uno strumento diagnostico e di debug e deve essere utilizzato con cautela. La disabilitazione di un motore dell'asse non ripristina le informazioni di homing. Lo spostamento manuale di uno stepper disabilitato pu\u00f2 causare l'azionamento del motore della macchina al di fuori dei limiti di sicurezza. Ci\u00f2 pu\u00f2 causare danni ai componenti dell'asse, al hotend e alla superficie di stampa. [temperature_fan] \u00b6 Il comando seguente \u00e8 disponibile quando una sezione di configurazione della ventola_temperatura \u00e8 abilitata. SET_TEMPERATURE_FAN_TARGET \u00b6 SET_TEMPERATURE_FAN_TARGET temperature_fan=<temperature_fan_name> [target=<target_temperature>] [min_speed=<min_speed>] [max_speed=<max_speed>] : Imposta la temperatura target per una temperature_fan. Se non viene fornito un target, viene impostato sulla temperatura specificata nel file di configurazione. Se le velocit\u00e0 non vengono fornite, non viene applicata alcuna modifica. [tmcXXXX] \u00b6 I seguenti comandi sono disponibili quando una qualsiasi delle tmcXXXX config section \u00e8 abilitata. DUMP_TMC \u00b6 DUMP_TMC STEPPER=<nome> [REGISTER=<nome>] : questo comando legger\u00e0 tutti i registri del driver TMC e riporter\u00e0 i loro valori. Se viene fornito un REGISTER, verr\u00e0 eseguito il dump solo del registro specificato. INIT_TMC \u00b6 INIT_TMC STEPPER=<nome> : questo comando inizializzer\u00e0 i registri TMC. Necessario per riattivare il driver se l'alimentazione al chip viene spenta e poi riaccesa. SET_TMC_CURRENT \u00b6 SET_TMC_CURRENT STEPPER=<nome> CURRENT=<amp> HOLDCURRENT=<amp> : regola le correnti di funzionamento e mantenimento del driver TMC. HOLDCURRENT non \u00e8 applicabile ai driver tmc2660. Quando utilizzato su un driver che dispone del campo globalscaler (tmc5160 e tmc2240), se si utilizza StealthChop2, lo stepper deve essere tenuto fermo per >130 ms in modo che il driver esegua la calibrazione AT#1. SET_TMC_FIELD \u00b6 SET_TMC_FIELD STEPPER=<nome> FIELD=<campo> VALUE=<valore> VELOCITY=<valore> : Ci\u00f2 modificher\u00e0 il valore del campo di registro specificato del driver TMC. Questo comando \u00e8 destinato solo alla diagnostica e al debug di basso livello poich\u00e9 la modifica dei campi durante l'esecuzione pu\u00f2 portare a comportamenti indesiderati e potenzialmente pericolosi della stampante. Le modifiche permanenti dovrebbero invece essere apportate utilizzando il file di configurazione della stampante. Non vengono eseguiti controlli di integrit\u00e0 per i valori specificati. \u00c8 anche possibile specificare una VELOCIT\u00c0 invece di un VALORE. Questa velocit\u00e0 viene convertita nella rappresentazione del valore basata su TSTEP a 20 bit. Utilizzare l'argomento VELOCIT\u00c0 solo per i campi che rappresentano velocit\u00e0. [toolhead] \u00b6 Il modulo toolhead viene caricato automaticamente. SET_VELOCITY_LIMIT \u00b6 SET_VELOCITY_LIMIT [VELOCITY=<value>] [ACCEL=<value>] [MINIMUM_CRUISE_RATIO=<value>] [SQUARE_CORNER_VELOCITY=<value>] : This command can alter the velocity limits that were specified in the printer config file. See the printer config section for a description of each parameter. [tuning_tower] \u00b6 Il modulo tuning_tower viene caricato automaticamente. TUNING_TOWER \u00b6 TUNING_TOWER COMMAND=<comando> PARAMETER=<nome> START=<valore> [SKIP=<valore>] [FACTOR=<valore> [BAND=<valore>]] | [STEP_DELTA=<valore> STEP_HEIGHT=<valore>] : Uno strumento per regolare un parametro su ciascuna altezza Z durante una stampa. Lo strumento eseguir\u00e0 il dato COMMAND con il dato PARAMETER assegnato a un valore che varia con Z secondo una formula. Usa FACTOR se utilizzerai un righello o calibri per misurare l'altezza Z del valore ottimale, o STEP_DELTA e STEP_HEIGHT se il modello della torre di regolazione ha bande di valori discreti come \u00e8 comune con le torri della temperatura. Se viene specificato SKIP=<valore> , il processo di ottimizzazione non inizia finch\u00e9 non viene raggiunta l'altezza Z <valore> , e al di sotto di essa il valore sar\u00e0 impostato su START ; in questo caso, la z_height usata nelle formule seguenti \u00e8 in realt\u00e0 max(z - skip, 0) . Ci sono tre possibili combinazioni di opzioni: FACTOR : Il valore cambia a una velocit\u00e0 di factor per millimetro. La formula utilizzata \u00e8: valore = inizio + fattore * z_altezza . \u00c8 possibile inserire l'altezza Z ottimale direttamente nella formula per determinare il valore del parametro ottimale. FACTOR e BAND : il valore cambia a una velocit\u00e0 media di factor per millimetro, ma in bande discrete in cui la regolazione verr\u00e0 effettuata solo ogni BAND millimetri di altezza Z. La formula utilizzata \u00e8: value = start + factor * ((floor(z_height / band) + .5) * band) . STEP_DELTA e STEP_HEIGHT : il valore cambia di STEP_DELTA ogni STEP_HEIGHT millimetri. La formula utilizzata \u00e8: value = start + step_delta * floor(z_height / step_height) . Puoi semplicemente contare le bande o leggere le etichette della torre di tuning per determinare il valore ottimale. [virtual_sdcard] \u00b6 Klipper supporta i seguenti comandi G-Code standard se la sezione di configurazione di virtual_sdcard \u00e8 abilitata: Elenco scheda SD: M20 Inizializza scheda SD: M21 Selezionare il file SD: M23 <nomefile> Avvia/riprendi la stampa SD: M24 Sospendi la stampa SD: M25 Impostare la posizione SD: M26 S<offset> Riporta lo stato di stampa SD: M27 Inoltre, quando la sezione di configurazione \"virtual_sdcard\" \u00e8 abilitata, sono disponibili i seguenti comandi estesi. SDCARD_PRINT_FILE \u00b6 SDCARD_PRINT_FILE FILENAME=<nomefile> : carica un file e avvia la stampa SD. SDCARD_RESET_FILE \u00b6 SDCARD_RESET_FILE : Scarica il file e cancella lo stato SD. [z_thermal_adjust] \u00b6 I seguenti comandi sono disponibili quando la sezione z_thermal_adjust config \u00e8 abilitata. SET_Z_THERMAL_ADJUST \u00b6 SET_Z_THERMAL_ADJUST [ENABLE=<0:1>] [TEMP_COEFF=<valore>] [REF_TEMP=<valore>] : Abilita o disabilita la regolazione termica Z con ENABLE . La disabilitazione non rimuove alcuna regolazione gi\u00e0 applicata, ma congela il valore di regolazione corrente - questo impedisce il movimento Z verso il basso potenzialmente pericoloso. La riattivazione pu\u00f2 potenzialmente causare il movimento dell'utensile verso l'alto quando la regolazione viene aggiornata e applicata. TEMP_COEFF consente la regolazione in tempo reale del coefficiente di temperatura di regolazione (cio\u00e8 il parametro di configurazione TEMP_COEFF ). I valori TEMP_COEFF non vengono salvati nella configurazione. REF_TEMP sovrascrive manualmente la temperatura di riferimento tipicamente impostata durante l'homing (per l'uso, ad esempio, in routine di homing non standard) - verr\u00e0 ripristinata automaticamente durante l'homing. [z_tilt] \u00b6 I seguenti comandi sono disponibili quando la sezione z_tilt config \u00e8 abilitata. Z_TILT_ADJUST \u00b6 Z_TILT_ADJUST [RETRIES=<value>] [RETRY_TOLERANCE=<value>] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] : This command will probe the points specified in the config and then make independent adjustments to each Z stepper to compensate for tilt. See the PROBE command for details on the optional probe parameters. The optional RETRIES , RETRY_TOLERANCE , and HORIZONTAL_MOVE_Z values override those options specified in the config file. [temperature_probe] \u00b6 The following commands are available when a temperature_probe config section is enabled. TEMPERATURE_PROBE_CALIBRATE \u00b6 TEMPERATURE_PROBE_CALIBRATE [PROBE=<probe name>] [TARGET=<value>] [STEP=<value>] : Initiates probe drift calibration for eddy current based probes. The TARGET is a target temperature for the last sample. When the temperature recorded during a sample exceeds the TARGET calibration will complete. The STEP parameter sets temperature delta (in C) between samples. After a sample has been taken, this delta is used to schedule a call to TEMPERATURE_PROBE_NEXT . The default STEP is 2. TEMPERATURE_PROBE_NEXT \u00b6 TEMPERATURE_PROBE_NEXT : After calibration has started this command is run to take the next sample. It is automatically scheduled to run when the delta specified by STEP has been reached, however its also possible to manually run this command to force a new sample. This command is only available during calibration. TEMPERATURE_PROBE_COMPLETE: \u00b6 TEMPERATURE_PROBE_COMPLETE : Can be used to end calibration and save the current result before the TARGET temperature is reached. This command is only available during calibration. ABORT \u00b6 ABORT : Aborts the calibration process, discarding the current results. This command is only available during drift calibration. TEMPERATURE_PROBE_ENABLE \u00b6 TEMPERATURE_PROBE_ENABLE ENABLE=[0|1] : Sets temperature drift compensation on or off. If ENABLE is set to 0, drift compensation will be disabled, if set to 1 it is enabled.","title":"G-Codes"},{"location":"G-Codes.html#g-codes","text":"Questo documento descrive i comandi che Klipper supporta. Questi sono i comandi che si possono inserire nella scheda del terminale OctoPrint.","title":"G-Codes"},{"location":"G-Codes.html#comandi-g-code","text":"Klipper supporta i seguenti comandi G-Code standard: Movimento (G0 or G1): G1 [X<pos>] [Y<pos>] [Z<pos>] [E<pos>] [F<speed>] Sosta: G4 P<millisecondi> Sposta all'origine: G28 [X] [Y] [Z] Spegnere i motori: M18 o M84 Attendi che li movimenti correnti finiscano: M400 Utilizzare distanze assolute/relative per l'estrusione: M82 , M83 Usa coordinate assolute/relative: G90 , G91 Impostare la posizione: G92 [X<pos>] [Y<pos>] [Z<pos>] [E<pos>] Impostare la percentuale di override del fattore di velocit\u00e0: M220 S<percentuale> Imposta la percentuale di sostituzione del fattore di estrusione: M221 S<percentuale> Impostare l'accelerazione: M204 S<valore> OPPURE M204 P<valore> T<valore> Nota: se S non viene specificato e vengono specificati sia P che T, l'accelerazione viene impostata al minimo di P e T. Se viene specificato solo uno di P o T, il comando non ha effetto. Ottieni la temperatura dell'estrusore: M105 Imposta la temperatura dell'estrusore: M104 [T<index>] [S<temperatura>] Imposta la temperatura dell'estrusore e attende: M109 [T<index>] S<temperatura> Nota: M109 attende sempre che la temperatura si assesti al valore richiesto Imposta la temperatura del piatto: M140 [S<temperatura>] Imposta la temperatura del piatto e attende: M190 S<temperatura> Nota: M190 attende sempre che la temperatura si assesti al valore richiesto Imposta la velocit\u00e0 della ventola: M106 S<valore> Spegnere la ventola: M107 Arresto di emergenza: M112 Ottieni la posizione attuale: M114 Ottieni la versione del firmware: M115 Per ulteriori dettagli sui comandi precedenti, vedere la documentazione RepRap G-Code . L'obiettivo di Klipper \u00e8 supportare i comandi G-Code prodotti da comuni software di terze parti (ad es. OctoPrint, Printrun, Slic3r, Cura, ecc.) nelle loro configurazioni standard. Non \u00e8 un obiettivo supportare ogni possibile comando G-Code. Invece, Klipper preferisce comandi leggibili dall'uomo \"comandi G-Code estesi\" . Allo stesso modo, l'output del terminale G-Code \u00e8 inteso solo per essere leggibile dall'uomo - vedere il documento del server API se si controlla Klipper da un software esterno. Se si necessita di un comando G-Code meno comune, potrebbe essere possibile implementarlo con una [sezione di configurazione gcode_macro] personalizzata (Config_Reference.md#gcode_macro). Ad esempio, si potrebbe usare questo per implementare: G12 , G29 , G30 , G31 , M42 , M80 , M81 , T1 , ecc.","title":"Comandi G-Code"},{"location":"G-Codes.html#comandi-aggiuntivi","text":"Klipper utilizza comandi G-Code \"estesi\" per la configurazione e lo stato generale. Questi comandi estesi seguono tutti un formato simile: iniziano con un nome di comando e possono essere seguiti da uno o pi\u00f9 parametri. Ad esempio: SET_SERVO SERVO=mioservo ANGLE=5.3 . In questo documento, i comandi ed i parametri sono mostrati in maiuscolo, tuttavia non fanno distinzione tra maiuscole e minuscole. (Quindi, \"SET_SERVO\" e \"set_servo\" eseguono entrambi lo stesso comando.) Questa sezione \u00e8 organizzata in base al nome del modulo Klipper, che generalmente segue i nomi delle sezioni specificati nel file di configurazione della stampante . Si noti che alcuni moduli vengono caricati automaticamente.","title":"Comandi aggiuntivi"},{"location":"G-Codes.html#adxl345","text":"I seguenti comandi sono disponibili quando una sezione di configurazione adxl345 \u00e8 abilitata.","title":"[adxl345]"},{"location":"G-Codes.html#accelerometer_measure","text":"ACCELEROMETER_MEASURE [CHIP=<config_name>] [NAME=<value>] : Avvia le misurazioni dell'accelerometro al numero richiesto di campioni al secondo. Se CHIP non \u00e8 specificato, il valore predefinito \u00e8 \"adxl345\". Il comando funziona in modalit\u00e0 start-stop: alla prima esecuzione avvia le misure, alla successiva esecuzione le interrompe. I risultati delle misurazioni vengono scritti in un file denominato /tmp/adxl345-<chip>-<name>.csv dove <chip> \u00e8 il nome del chip dell'accelerometro ( my_chip_name da [adxl345 my_chip_name] ) e <name> \u00e8 il parametro NAME facoltativo. Se NAME non \u00e8 specificato, il valore predefinito \u00e8 l'ora corrente nel formato \"AAAAMMGG_HHMMSS\". Se l'accelerometro non ha un nome nella sua sezione di configurazione (semplicemente [adxl345] ), allora la parte <chip> del nome non viene generata.","title":"ACCELEROMETER_MEASURE"},{"location":"G-Codes.html#accelerometer_query","text":"ACCELEROMETER_QUERY [CHIP=<config_name>] [RATE=<value>] : interroga l'accelerometro per il valore corrente. Se CHIP non \u00e8 specificato, il valore predefinito \u00e8 \"adxl345\". Se RATE non \u00e8 specificato, viene utilizzato il valore predefinito. Questo comando \u00e8 utile per testare la connessione all'accelerometro ADXL345: uno dei valori restituiti dovrebbe essere un'accelerazione di caduta libera (+/- un po' di rumore del chip).","title":"ACCELEROMETER_QUERY"},{"location":"G-Codes.html#accelerometer_debug_read","text":"ACCELEROMETER_DEBUG_READ [CHIP=<config_name>] REG=<register> : interroga l'ADXL345 register \"register\" (es. 44 o 0x2C). Pu\u00f2 essere utile per scopi di debug.","title":"ACCELEROMETER_DEBUG_READ"},{"location":"G-Codes.html#accelerometer_debug_write","text":"ACCELEROMETER_DEBUG_WRITE [CHIP=<nome_config>] REG=<register> VAL=<value> : Scrive il valore \"value\" grezzo in un registro \"register\". Sia \"value\" che \"registrer\" possono essere un numero intero decimale o esadecimale. Usare con cura e fare riferimento alla scheda tecnica ADXL345 per riferimento.","title":"ACCELEROMETER_DEBUG_WRITE"},{"location":"G-Codes.html#angle","text":"I seguenti comandi sono disponibili quando una sezione di configurazione dell'angolo \u00e8 abilitata.","title":"[angle]"},{"location":"G-Codes.html#angle_calibrate","text":"ANGLE_CALIBRATE CHIP=<chip_name> : Esegue la calibrazione dell'angolo sul sensore dato (deve esserci una sezione di configurazione [angle chip_name] che ha specificato un parametro stepper ). IMPORTANTE - questo strumento comander\u00e0 al motore passo-passo di muoversi senza controllare i normali limiti della cinematica. Idealmente, il motore dovrebbe essere scollegato da qualsiasi carrello della stampante prima di eseguire la calibrazione. Se non \u00e8 possibile scollegare lo stepper dalla stampante, assicurarsi che il carrello sia vicino al centro della sua guida prima di iniziare la calibrazione. (Il motore passo-passo pu\u00f2 spostarsi avanti o indietro di due rotazioni complete durante questo test.) Dopo aver completato questo test, utilizzare il comando SAVE_CONFIG per salvare i dati di calibrazione nel file di configurazione. Per utilizzare questo strumento \u00e8 necessario installare il pacchetto Python \"numpy\" (consultare il measuring resonance document per ulteriori informazioni).","title":"ANGLE_CALIBRATE"},{"location":"G-Codes.html#angle_chip_calibrate","text":"ANGLE_CHIP_CALIBRATE CHIP=<chip_name> : Perform internal sensor calibration, if implemented (MT6826S/MT6835). MT68XX : The motor should be disconnected from any printer carriage before performing calibration. After calibration, the sensor should be reset by disconnecting the power.","title":"ANGLE_CHIP_CALIBRATE"},{"location":"G-Codes.html#angle_debug_read","text":"ANGLE_DEBUG_READ CHIP=<config_name> REG=<register> : Interroga il registro del sensore \"register\" (ad es. 44 o 0x2C). Pu\u00f2 essere utile per scopi di debug. Questo \u00e8 disponibile solo per i chip tle5012b.","title":"ANGLE_DEBUG_READ"},{"location":"G-Codes.html#angle_debug_write","text":"ANGLE_DEBUG_WRITE CHIP=<config_name> REG=<register> VAL=<value> : scrive il valore \"value\" grezzo nel registro \"register\". Sia \"value\" che \"register\" possono essere un numero intero decimale o esadecimale. Usare con cautela e fare riferimento alla scheda tecnica del sensore per riferimento. Questo \u00e8 disponibile solo per i chip tle5012b.","title":"ANGLE_DEBUG_WRITE"},{"location":"G-Codes.html#axis_twist_compensation","text":"The following commands are available when the axis_twist_compensation config section is enabled.","title":"[axis_twist_compensation]"},{"location":"G-Codes.html#axis_twist_compensation_calibrate","text":"AXIS_TWIST_COMPENSATION_CALIBRATE [AXIS=<X|Y>] [AUTO=<True|False>] [SAMPLE_COUNT=<value>] Calibrates axis twist compensation by specifying the target axis or enabling automatic calibration. AXIS: Define the axis ( X or Y ) for which the twist compensation will be calibrated. If not specified, the axis defaults to 'X' . AUTO: Enables automatic calibration mode. When AUTO=True , the calibration will run for both the X and Y axes. In this mode, AXIS cannot be specified. If both AXIS and AUTO are provided, an error will be raised.","title":"AXIS_TWIST_COMPENSATION_CALIBRATE"},{"location":"G-Codes.html#bed_mesh","text":"I seguenti comandi sono disponibili quando la sezione di configurazione bed_mesh \u00e8 abilitata (consultare anche la guida della mesh del letto ).","title":"[bed_mesh]"},{"location":"G-Codes.html#bed_mesh_calibrate","text":"BED_MESH_CALIBRATE [PROFILE=<name>] [METHOD=manual] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] [<mesh_parameter>=<value>] [ADAPTIVE=1] [ADAPTIVE_MARGIN=<value>] : This command probes the bed using generated points specified by the parameters in the config. After probing, a mesh is generated and z-movement is adjusted according to the mesh. The mesh will be saved into a profile specified by the PROFILE parameter, or default if unspecified. See the PROBE command for details on the optional probe parameters. If METHOD=manual is specified then the manual probing tool is activated - see the MANUAL_PROBE command above for details on the additional commands available while this tool is active. The optional HORIZONTAL_MOVE_Z value overrides the horizontal_move_z option specified in the config file. If ADAPTIVE=1 is specified then the objects defined by the Gcode file being printed will be used to define the probed area. The optional ADAPTIVE_MARGIN value overrides the adaptive_margin option specified in the config file.","title":"BED_MESH_CALIBRATE"},{"location":"G-Codes.html#bed_mesh_output","text":"BED_MESH_OUTPUT PGP=[<0:1>] : questo comando restituisce i valori z sondati e i valori mesh correnti al terminale. Se viene specificato PGP=1, le coordinate X, Y generate da bed_mesh, insieme ai relativi indici associati, verranno inviate al terminale.","title":"BED_MESH_OUTPUT"},{"location":"G-Codes.html#bed_mesh_map","text":"BED_MESH_MAP : Come per BED_MESH_OUTPUT, questo comando stampa lo stato corrente della mesh sul terminale. Invece di stampare i valori in un formato leggibile, lo stato viene serializzato in formato json. Ci\u00f2 consente ai plug-in di Octoprint di acquisire facilmente i dati e generare mappe di altezza che si approssimano la superficie del piatto.","title":"BED_MESH_MAP"},{"location":"G-Codes.html#bed_mesh_clear","text":"BED_MESH_CLEAR : questo comando cancella la mesh e rimuove tutte le regolazioni z. Si consiglia di inserirlo nella parte finale del gcode.","title":"BED_MESH_CLEAR"},{"location":"G-Codes.html#bed_mesh_profile","text":"BED_MESH_PROFILE LOAD=<name> SAVE=<name> REMOVE=<name> : questo comando fornisce la gestione del profilo per lo stato della mesh. LOAD ripristiner\u00e0 lo stato della mesh dal profilo corrispondente al nome fornito. SAVE salver\u00e0 lo stato della mesh corrente in un profilo che corrisponde al nome fornito. Rimuovi eliminer\u00e0 il profilo corrispondente al nome fornito dalla memoria persistente. Si noti che dopo aver eseguito le operazioni SAVE o REMOVE \u00e8 necessario eseguire il gcode SAVE_CONFIG per rendere permanenti le modifiche alla memoria persistente.","title":"BED_MESH_PROFILE"},{"location":"G-Codes.html#bed_mesh_offset","text":"BED_MESH_OFFSET [X=<value>] [Y=<value>] [ZFADE=<value] : Applies X, Y, and/or ZFADE offsets to the mesh lookup. This is useful for printers with independent extruders, as an offset is necessary to produce correct Z adjustment after a tool change. Note that a ZFADE offset does not apply additional z-adjustment directly, it is used to correct the fade calculation when a gcode offset has been applied to the Z axis.","title":"BED_MESH_OFFSET"},{"location":"G-Codes.html#bed_screws","text":"I seguenti comandi sono disponibili quando la sezione di configurazione bed_screws \u00e8 abilitata (consultare anche la manual level guide ).","title":"[bed_screws]"},{"location":"G-Codes.html#bed_screws_adjust","text":"BED_SCREWS_ADJUST : questo comando richiamer\u00e0 lo strumento di regolazione delle viti del piatto. Comander\u00e0 l'ugello in posizioni diverse (come definito nel file di configurazione) e consentir\u00e0 di effettuare regolazioni alle viti del piatto in modo che il piatto sia a una distanza costante dall'ugello.","title":"BED_SCREWS_ADJUST"},{"location":"G-Codes.html#bed_tilt","text":"I seguenti comandi sono disponibili quando la sezione di configurazione inclinazione_piatto \u00e8 abilitata.","title":"[bed_tilt]"},{"location":"G-Codes.html#bed_tilt_calibrate","text":"BED_TILT_CALIBRATE [METHOD=manual] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] : questo comando sonda i punti specificati nella configurazione e quindi consiglia le regolazioni aggiornate dell'inclinazione x e y. Vedere il comando PROBE per i dettagli sui parametri opzionali della sonda. Se viene specificato METHOD=manual, viene attivato lo strumento di rilevamento manuale: vedere il comando MANUAL_PROBE sopra per dettagli sui comandi aggiuntivi disponibili mentre questo strumento \u00e8 attivo. Il valore opzionale HORIZONTAL_MOVE_Z sovrascrive l'opzione horizontal_move_z specificata nel file di configurazione.","title":"BED_TILT_CALIBRATE"},{"location":"G-Codes.html#bltouch","text":"Il comando seguente \u00e8 disponibile quando \u00e8 abilitata una sezione di configurazione bltouch (vedere anche la Guida BL-Touch ).","title":"[bltouch]"},{"location":"G-Codes.html#bltouch_debug","text":"BLTOUCH_DEBUG COMMAND=<command> : Invia un comando al BLTouch. Pu\u00f2 essere utile per il debug. I comandi disponibili sono: pin_down , touch_mode , pin_up , self_test , reset . Un BL-Touch V3.0 o V3.1 pu\u00f2 anche supportare i comandi set_5V_output_mode , set_OD_output_mode , output_mode_store .","title":"BLTOUCH_DEBUG"},{"location":"G-Codes.html#bltouch_store","text":"BLTOUCH_STORE MODE=<output_mode> : memorizza una modalit\u00e0 di output nella EEPROM di un BLTouch V3.1 Le modalit\u00e0 di output disponibili sono: 5V , OD","title":"BLTOUCH_STORE"},{"location":"G-Codes.html#configfile","text":"Il modulo configfile viene caricato automaticamente.","title":"[configfile]"},{"location":"G-Codes.html#save_config","text":"SAVE_CONFIG : questo comando sovrascriver\u00e0 il file di configurazione della stampante principale e riavvier\u00e0 il software host. Questo comando viene utilizzato insieme ad altri comandi di calibrazione per memorizzare i risultati dei test di calibrazione.","title":"SAVE_CONFIG"},{"location":"G-Codes.html#delayed_gcode","text":"Il comando seguente \u00e8 abilitato se \u00e8 stata abilitata una sezione di configurazione di gcode ritardata (consultare anche la guida ai modelli ).","title":"[delayed_gcode]"},{"location":"G-Codes.html#update_delayed_gcode","text":"UPDATE_DELAYED_GCODE [ID=<nome>] [DURATION=<secondi>] : aggiorna la durata del ritardo per il [gcode_ritardato] identificato e avvia il timer per l'esecuzione di gcode. Un valore di 0 annuller\u00e0 l'esecuzione di un gcode ritardato in sospeso.","title":"UPDATE_DELAYED_GCODE"},{"location":"G-Codes.html#delta_calibrate","text":"I seguenti comandi sono disponibili quando la sezione di configurazione delta_calibrate \u00e8 abilitata (consultare anche la guida alla calibrazione delta ).","title":"[delta_calibrate]"},{"location":"G-Codes.html#delta_calibrate_1","text":"DELTA_CALIBRATE [METHOD=manual] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] : questo comando sonda sette punti sul piatto e consiglia le posizioni aggiornate dei finecorsa, gli angoli della torre e il raggio. Vedere il comando PROBE per i dettagli sui parametri opzionali della sonda. Se viene specificato METHOD=manual, viene attivato lo strumento di rilevamento manuale: vedere il comando MANUAL_PROBE sopra per dettagli sui comandi aggiuntivi disponibili mentre questo strumento \u00e8 attivo. Il valore opzionale HORIZONTAL_MOVE_Z sovrascrive l'opzione horizontal_move_z specificata nel file di configurazione.","title":"DELTA_CALIBRATE"},{"location":"G-Codes.html#delta_analyze","text":"DELTA_ANALYZE : questo comando viene utilizzato durante la calibrazione avanzata delle stampanti delta. Vedere Delta Calibrate per i dettagli.","title":"DELTA_ANALYZE"},{"location":"G-Codes.html#display","text":"Il comando seguente \u00e8 disponibile quando \u00e8 abilitata una sezione di configurazione display .","title":"[display]"},{"location":"G-Codes.html#set_display_group","text":"SET_DISPLAY_GROUP [DISPLAY=<display>] GROUP=<group> : Imposta il gruppo di visualizzazione attivo di un display LCD. Ci\u00f2 consente di definire pi\u00f9 gruppi di dati di visualizzazione nella configurazione, ad es. [display_data <group> <elementname>] e passare da uno all'altro usando questo comando gcode esteso. Se DISPLAY non \u00e8 specificato, l'impostazione predefinita \u00e8 \"display\" (il display principale).","title":"SET_DISPLAY_GROUP"},{"location":"G-Codes.html#display_status","text":"Il modulo display_status viene caricato automaticamente se una sezione di configurazione display \u00e8 abilitata. Fornisce i seguenti comandi G-Code standard: Messaggio visualizzato: M117 <messaggio> Imposta la percentuale di costruzione: M73 P<percentuale> Viene inoltre fornito il seguente comando G-Code esteso: SET_DISPLAY_TEXT MSG=<messaggio> : esegue l'equivalente di M117, impostando il MSG fornito come messaggio visualizzato. Se MSG viene omesso, il display verr\u00e0 cancellato.","title":"[display_status]"},{"location":"G-Codes.html#dual_carriage","text":"Il comando seguente \u00e8 disponibile quando la sezione di configurazione dual_carriage \u00e8 abilitata.","title":"[dual_carriage]"},{"location":"G-Codes.html#set_dual_carriage","text":"SET_DUAL_CARRIAGE CARRIAGE=[0|1] [MODE=[PRIMARY|COPY|MIRROR]] : This command will change the mode of the specified carriage. If no MODE is provided it defaults to PRIMARY . Setting the mode to PRIMARY deactivates the other carriage and makes the specified carriage execute subsequent G-Code commands as-is. COPY and MIRROR modes are supported only for CARRIAGE=1 . When set to either of these modes, carriage 1 will then track the subsequent moves of the carriage 0 and either copy relative movements of it (in COPY mode) or execute them in the opposite (mirror) direction (in MIRROR mode).","title":"SET_DUAL_CARRIAGE"},{"location":"G-Codes.html#save_dual_carriage_state","text":"SAVE_DUAL_CARRIAGE_STATE [NAME=<state_name>] : Save the current positions of the dual carriages and their modes. Saving and restoring DUAL_CARRIAGE state can be useful in scripts and macros, as well as in homing routine overrides. If NAME is provided it allows one to name the saved state to the given string. If NAME is not provided it defaults to \"default\".","title":"SAVE_DUAL_CARRIAGE_STATE"},{"location":"G-Codes.html#restore_dual_carriage_state","text":"RESTORE_DUAL_CARRIAGE_STATE [NAME=<state_name>] [MOVE=[0|1] [MOVE_SPEED=<speed>]] : Restore the previously saved positions of the dual carriages and their modes, unless \"MOVE=0\" is specified, in which case only the saved modes will be restored, but not the positions of the carriages. If positions are being restored and \"MOVE_SPEED\" is specified, then the toolhead moves will be performed with the given speed (in mm/s); otherwise the toolhead move will use the rail homing speed. Note that the carriages restore their positions only over their own axis, which may be necessary to correctly restore COPY and MIRROR mode of the dual carraige.","title":"RESTORE_DUAL_CARRIAGE_STATE"},{"location":"G-Codes.html#endstop_phase","text":"I seguenti comandi sono disponibili quando una sezione di configurazione endstop_phase \u00e8 abilitata (consultare anche la guida alla fase endstop ).","title":"[endstop_phase]"},{"location":"G-Codes.html#endstop_phase_calibrate","text":"ENDSTOP_PHASE_CALIBRATE [STEPPER=<config_name>] : Se non viene fornito alcun parametro STEPPER, questo comando riporter\u00e0 le statistiche sulle fasi stepper dell'arresto durante le precedenti operazioni di homing. Quando viene fornito un parametro STEPPER, fa in modo che l'impostazione della fase di fine corsa fornita sia scritta nel file di configurazione (insieme al comando SAVE_CONFIG).","title":"ENDSTOP_PHASE_CALIBRATE"},{"location":"G-Codes.html#exclude_object","text":"I seguenti comandi sono disponibili quando \u00e8 abilitata una exclude_object config section (consultare anche la exclude object guide ):","title":"[exclude_object]"},{"location":"G-Codes.html#exclude_object_1","text":"EXCLUDE_OBJECT [NAME=object_name] [CURRENT=1] [RESET=1] : Senza parametri, questo restituir\u00e0 un elenco di tutti gli oggetti attualmente esclusi. Quando viene fornito il parametro NAME , l'oggetto denominato verr\u00e0 escluso dalla stampa. Quando viene fornito il parametro CURRENT , l'oggetto corrente verr\u00e0 escluso dalla stampa. Quando viene fornito il parametro RESET l'elenco degli oggetti esclusi verr\u00e0 cancellato. Inoltre l'inclusione di NAME ripristiner\u00e0 solo l'oggetto denominato. Questo pu\u00f2 causare errori di stampa, se i livelli sono gi\u00e0 stati saltati.","title":"EXCLUDE_OBJECT"},{"location":"G-Codes.html#exclude_object_define","text":"EXCLUDE_OBJECT_DEFINE [NAME=object_name [CENTER=X,Y] [POLYGON=[[x,y],...]] [RESET=1] [JSON=1] : fornisce un riepilogo di un oggetto nel file. Senza parametri forniti, questo elencher\u00e0 gli oggetti definiti noti a Klipper. Restituisce un elenco di stringhe, a meno che non venga fornito il parametro JSON , quando restituir\u00e0 i dettagli dell'oggetto in formato json. Quando il parametro NAME \u00e8 incluso, definisce un oggetto da escludere. NAME : questo parametro \u00e8 obbligatorio. \u00c8 l'identificatore utilizzato da altri comandi in questo modulo. CENTER : una coordinata X,Y per l'oggetto. POLYGON : Un array di coordinate X,Y che fornisce un contorno per l'oggetto. Quando viene fornito il parametro RESET , tutti gli oggetti definiti verranno cancellati e il modulo [exclude_object] verr\u00e0 ripristinato.","title":"EXCLUDE_OBJECT_DEFINE"},{"location":"G-Codes.html#exclude_object_start","text":"EXCLUDE_OBJECT_START NAME=object_name : questo comando prende un parametro NAME e marca l'inizio del gcode per un oggetto sul livello corrente.","title":"EXCLUDE_OBJECT_START"},{"location":"G-Codes.html#exclude_object_end","text":"EXCLUDE_OBJECT_END [NAME=object_name] : Denota la fine del gcode dell'oggetto per il livello. \u00c8 accoppiato con EXCLUDE_OBJECT_START . Un parametro NAME \u00e8 facoltativo e avviser\u00e0 solo quando il nome fornito non corrisponde all'oggetto corrente.","title":"EXCLUDE_OBJECT_END"},{"location":"G-Codes.html#extruder","text":"I seguenti comandi sono disponibili se una sezione di configurazione dell'estrusore \u00e8 abilitata:","title":"[extruder]"},{"location":"G-Codes.html#activate_extruder","text":"ACTIVATE_EXTRUDER EXTRUDER=<config_name> : in una stampante con pi\u00f9 sezioni di configurazione extruder , questo comando cambia l'hotend attivo.","title":"ACTIVATE_EXTRUDER"},{"location":"G-Codes.html#set_pressure_advance","text":"SET_PRESSURE_ADVANCE [EXTRUDER=<config_name>] [ADVANCE=<pressure_advance>] [SMOOTH_TIME=<pressure_advance_smooth_time>] : Imposta i parametri di pressure advance delleo stepper di un estrusore (come definito in un estrusore o [ extruder_stepper] (sezione di configurazione Config_Reference.md#extruder_stepper). Se EXTRUDER non \u00e8 specificato, per impostazione predefinita viene utilizzato lo stepper definito nell'hotend attivo.","title":"SET_PRESSURE_ADVANCE"},{"location":"G-Codes.html#set_extruder_rotation_distance","text":"SET_EXTRUDER_ROTATION_DISTANCE EXTRUDER=<config_name> [DISTANCE=<distance>] : Imposta un nuovo valore per la \"distanza di rotazione\" dello stepper dell'estrusore fornito (come definito in un extruder o extruder_stepper sezione di configurazione). Se la distanza di rotazione \u00e8 un numero negativo, il movimento passo-passo verr\u00e0 invertito (rispetto alla direzione passo-passo specificata nel file di configurazione). Le impostazioni modificate non vengono mantenute al ripristino di Klipper. Usare con cautela poich\u00e9 piccole modifiche possono causare una pressione eccessiva tra l'estrusore e l'hotend. Eseguire una corretta calibrazione con il filamento prima dell'uso. Se il valore 'DISTANZA' non viene fornito, questo comando restituir\u00e0 la distanza di rotazione corrente.","title":"SET_EXTRUDER_ROTATION_DISTANCE"},{"location":"G-Codes.html#sync_extruder_motion","text":"SYNC_EXTRUDER_MOTION EXTRUDER=<nome> MOTION_QUEUE=<nome> : questo comando attiver\u00e0 lo stepper specificato da EXTRUDER (come definito in un extruder o extruder_stepper config sezione) per sincronizzarsi con il movimento di un estrusore specificato da MOTION_QUEUE (come definito in una sezione di configurazione estrusore ). Se MOTION_QUEUE \u00e8 una stringa vuota, lo stepper verr\u00e0 desincronizzato da tutti i movimenti dell'estrusore.","title":"SYNC_EXTRUDER_MOTION"},{"location":"G-Codes.html#fan_generic","text":"Il comando seguente \u00e8 disponibile quando una sezione di configurazione fan_generic \u00e8 abilitata.","title":"[fan_generic]"},{"location":"G-Codes.html#set_fan_speed","text":"SET_FAN_SPEED FAN=config_name SPEED=<velocit\u00e0> Questo comando imposta la velocit\u00e0 di una ventola. \"velocit\u00e0\" deve essere compresa tra 0.0 e 1.0. SET_FAN_SPEED PIN=config_name TEMPLATE=<template_name> [<param_x>=<literal>] : If TEMPLATE is specified then it assigns a display_template to the given fan. For example, if one defined a [display_template my_fan_template] config section then one could assign TEMPLATE=my_fan_template here. The display_template should produce a string containing a floating point number with the desired value. The template will be continuously evaluated and the fan will be automatically set to the resulting speed. One may set display_template parameters to use during template evaluation (parameters will be parsed as Python literals). If TEMPLATE is an empty string then this command will clear any previous template assigned to the pin (one can then use SET_FAN_SPEED commands to manage the values directly).","title":"SET_FAN_SPEED"},{"location":"G-Codes.html#filament_switch_sensor","text":"Il comando seguente \u00e8 disponibile quando \u00e8 abilitata una sezione di configurazione filament_switch_sensor o filament_motion_sensor .","title":"[filament_switch_sensor]"},{"location":"G-Codes.html#query_filament_sensor","text":"QUERY_FILAMENT_SENSOR SENSOR=<sensor_name> : Interroga lo stato del sensore di filamento. I dati visualizzati sul terminale dipenderanno dal tipo di sensore definito nella configurazione.","title":"QUERY_FILAMENT_SENSOR"},{"location":"G-Codes.html#set_filament_sensor","text":"SET_FILAMENT_SENSOR SENSOR=<nome_sensore> ENABLE=[0|1] : Attiva/disattiva il sensore di filamento. Se ENABLE \u00e8 impostato su 0, il sensore di filamento sar\u00e0 disabilitato, se impostato su 1 sar\u00e0 abilitato.","title":"SET_FILAMENT_SENSOR"},{"location":"G-Codes.html#firmware_retraction","text":"I seguenti comandi G-Code standard sono disponibili quando la sezione di configurazione firmware_retraction \u00e8 abilitata. Questi comandi consentono di utilizzare la funzione di retraction del firmware disponibile in molti slicer, per ridurre lo stringing durante gli spostamenti di non estrusione da una parte all'altra della stampa. Configurando opportunamente la pressure advance si riduce la lunghezza della retrazione richiesta. G10 : Ritrae l'estrusore utilizzando i parametri attualmente configurati. G11 : Ritira l'estrusore utilizzando i parametri attualmente configurati. Sono inoltre disponibili i seguenti comandi aggiuntivi.","title":"[firmware_retraction]"},{"location":"G-Codes.html#set_retraction","text":"SET_RETRACTION [RETRACT_LENGTH=<mm>] [RETRACT_SPEED=<mm/s>] [UNRETRACT_EXTRA_LENGTH=<mm>] [UNRETRACT_SPEED=<mm/s>] : regola i parametri utilizzati dalla retrazione. RETRACT_LENGTH determina la lunghezza del filamento da ritrarre e estrudere. La velocit\u00e0 di retrazione viene regolata tramite RETRACT_SPEED, ed \u00e8 generalmente impostata su un valore relativamente alto. La velocit\u00e0 di annullamento viene regolata tramite UNRETRACT_SPEED e non \u00e8 particolarmente critica, sebbene spesso inferiore a RETRACT_SPEED. In alcuni casi \u00e8 utile aggiungere una piccola quantit\u00e0 di lunghezza aggiuntiva all'annullamento della retrazione, e questa viene impostata tramite UNRETRACT_EXTRA_LENGTH. SET_RETRACTION \u00e8 comunemente impostato come parte della configurazione dello slicer per filamento, poich\u00e9 filamenti diversi richiedono impostazioni dei parametri diverse.","title":"SET_RETRACTION"},{"location":"G-Codes.html#get_retraction","text":"GET_RETRACTION : interroga i parametri correnti utilizzati dal firmware per retrazione e li visualizza sul terminale.","title":"GET_RETRACTION"},{"location":"G-Codes.html#force_move","text":"Il modulo force_move viene caricato automaticamente, tuttavia alcuni comandi richiedono l'impostazione di enable_force_move in printer config .","title":"[force_move]"},{"location":"G-Codes.html#stepper_buzz","text":"STEPPER_BUZZ STEPPER=<nome_config> : sposta lo stepper dato in avanti di 1 mm e poi indietro di 1 mm, ripetuto 10 volte. Questo \u00e8 uno strumento diagnostico per aiutare a verificare la connettivit\u00e0 stepper.","title":"STEPPER_BUZZ"},{"location":"G-Codes.html#force_move_1","text":"FORCE_MOVE STEPPER=<nome_config> DISTANCE=<value> VELOCITY=<value> [ACCEL=<value>] : Questo comando sposter\u00e0 forzatamente lo stepper dato della distanza data (in mm) alla velocit\u00e0 costante data (in mm/ S). Se viene specificato ACCEL ed \u00e8 maggiore di zero, verr\u00e0 utilizzata l'accelerazione data (in mm/s^2); altrimenti non viene eseguita alcuna accelerazione. Non vengono effettuati controlli sui limiti; non vengono effettuati aggiornamenti cinematici; altri stepper paralleli su un asse non verranno spostati. Prestare attenzione poich\u00e9 un comando errato potrebbe causare danni! L'uso di questo comando metter\u00e0 quasi sicuramente la cinematica di basso livello in uno stato errato; emettere un G28 in seguito per ripristinare la cinematica. Questo comando \u00e8 destinato alla diagnostica e al debug di basso livello.","title":"FORCE_MOVE"},{"location":"G-Codes.html#set_kinematic_position","text":"SET_KINEMATIC_POSITION [X=<value>] [Y=<value>] [Z=<value>] [CLEAR=<[X][Y][Z]>] : Force the low-level kinematic code to believe the toolhead is at the given cartesian position. This is a diagnostic and debugging command; use SET_GCODE_OFFSET and/or G92 for regular axis transformations. If an axis is not specified then it will default to the position that the head was last commanded to. Setting an incorrect or invalid position may lead to internal software errors. Use the CLEAR parameter to forget the homing state for the given axes. Note that CLEAR will not override the previous functionality; if an axis is not specified to CLEAR it will have its kinematic position set as per above. This command may invalidate future boundary checks; issue a G28 afterwards to reset the kinematics.","title":"SET_KINEMATIC_POSITION"},{"location":"G-Codes.html#gcode","text":"Il modulo gcode viene caricato automaticamente.","title":"[gcode]"},{"location":"G-Codes.html#restart","text":"RESTART : Ci\u00f2 far\u00e0 s\u00ec che il software host ricarichi la sua configurazione ed esegua un ripristino interno. Questo comando non canceller\u00e0 lo stato di errore dal microcontrollore (vedi FIRMWARE_RESTART) n\u00e9 caricher\u00e0 nuovo software (vedi FAQ ) .","title":"RESTART"},{"location":"G-Codes.html#firmware_restart","text":"FIRMWARE_RESTART : Questo \u00e8 simile a un comando RESTART, ma cancella anche qualsiasi stato di errore dal microcontrollore.","title":"FIRMWARE_RESTART"},{"location":"G-Codes.html#status","text":"STATUS : segnala lo stato del software host di Klipper.","title":"STATUS"},{"location":"G-Codes.html#help","text":"HELP : riporta l'elenco dei comandi G-Code estesi disponibili.","title":"HELP"},{"location":"G-Codes.html#gcode_arcs","text":"I seguenti comandi G-Code standard sono disponibili se una sezione di configurazione gcode_arcs \u00e8 abilitata: Movimento dell'arco in senso orario (G2), Movimento dell'arco in senso antiorario (G3): G2|G3 [X<pos>] [Y<pos>] [Z<pos>] [E<pos>] [F<velocit\u00e0>] I<valore> J<valore>|I<valore> K<valore>|J<valore> K<valore> Selezione del piano dell'arco: G17 (piano XY), G18 (piano XZ), G19 (piano YZ)","title":"[gcode_arcs]"},{"location":"G-Codes.html#gcode_macro","text":"Il comando seguente \u00e8 disponibile quando \u00e8 abilitata una sezione di configurazione gcode_macro (consultare anche la guida ai modelli di comando ).","title":"[gcode_macro]"},{"location":"G-Codes.html#set_gcode_variable","text":"SET_GCODE_VARIABLE MACRO=<nome_macro> VARIABLE=<nome> VALUE=<valore> : questo comando consente di modificare il valore di una variabile gcode_macro in fase di esecuzione. Il VALUE fornito viene analizzato come un valore literal in Python.","title":"SET_GCODE_VARIABLE"},{"location":"G-Codes.html#gcode_move","text":"Il modulo gcode_move viene caricato automaticamente.","title":"[gcode_move]"},{"location":"G-Codes.html#get_position","text":"GET_POSITION`: Restituisce informazioni sulla posizione corrente della testa di stampa. Per ulteriori informazioni, vedere la documentazione per gli sviluppatori di GET_POSITION output .","title":"GET_POSITION"},{"location":"G-Codes.html#set_gcode_offset","text":"SET_GCODE_OFFSET [X=<pos>|X_ADJUST=<regola>] [Y=<pos>|Y_ADJUST=<regola>] [Z=<pos>|Z_ADJUST=<regola>] [MOVE=1 [MOVE_SPEED=<velocit\u00e0 >]] : imposta un offset di posizione da applicare ai futuri comandi G-Code. Questo \u00e8 comunemente usato per cambiare virtualmente l'offset del letto Z o per impostare gli offset XY degli ugelli quando si cambia estrusore. Ad esempio, se viene inviato \"SET_GCODE_OFFSET Z=0.2\", i futuri movimenti G-Code avranno 0.2 mm aggiunti alla loro altezza Z. Se vengono utilizzati i parametri di stile X_ADJUST, la regolazione verr\u00e0 aggiunta a qualsiasi offset esistente (ad esempio, \"SET_GCODE_OFFSET Z=-0.2\" seguito da \"SET_GCODE_OFFSET Z_ADJUST=0.3\" risulter\u00e0 in un offset Z totale di 0.1). Se viene specificato \"MOVE=1\", verr\u00e0 emesso un movimento della testa di stampa per applicare l'offset specificato (altrimenti l'offset avr\u00e0 effetto sul successivo movimento assoluto del codice G che specifica l'asse dato). Se viene specificato \"MOVE_SPEED\", lo spostamento della testa utensile verr\u00e0 eseguito con la velocit\u00e0 data (in mm/s); in caso contrario, il movimento della testa utensile utilizzer\u00e0 l'ultima velocit\u00e0 del G-code specificata.","title":"SET_GCODE_OFFSET"},{"location":"G-Codes.html#save_gcode_state","text":"SAVE_GCODE_STATE [NAME=<nome_stato>] : salva lo stato di analisi delle coordinate del G-code corrente. Il salvataggio e il ripristino dello stato del G-code \u00e8 utile negli script e nelle macro. Questo comando salva la modalit\u00e0 di coordinate assolute del G-code corrente (G90/G91), la modalit\u00e0 di estrusione assoluta (M82/M83), l'origine (G92), l'offset (SET_GCODE_OFFSET), l'override della velocit\u00e0 (M220), l'override dell'estrusore (M221), la velocit\u00e0 di spostamento , la posizione XYZ corrente e la posizione relativa dell'estrusore \"E\". Se viene fornito NAME, consente di assegnare un nome allo stato salvato alla stringa data. Se NAME non viene fornito, il valore predefinito \u00e8 \"predefinito\".","title":"SAVE_GCODE_STATE"},{"location":"G-Codes.html#restore_gcode_state","text":"RESTORE_GCODE_STATE [NAME=<nome_stato>] [MOVE=1 [MOVE_SPEED=<velocit\u00e0>]] : ripristina uno stato precedentemente salvato tramite SAVE_GCODE_STATE. Se viene specificato \"MOVE=1\", verr\u00e0 emesso un movimento della testa utensile per tornare alla posizione XYZ precedente. Se viene specificato \"MOVE_SPEED\", lo spostamento della testa utensile verr\u00e0 eseguito con la velocit\u00e0 data (in mm/s); in caso contrario, lo spostamento della testa utensile utilizzer\u00e0 la velocit\u00e0 del codice g ripristinata.","title":"RESTORE_GCODE_STATE"},{"location":"G-Codes.html#hall_filament_width_sensor","text":"I seguenti comandi sono disponibili quando la sezione di configurazione del sensore di larghezza del filamento tsl1401cl o sezione di configurazione del sensore di larghezza del filamento hall \u00e8 abilitata (consultare anche Sensore di larghezza del filamento TSLl401CL e Hall Filament Width Sensor ):","title":"[hall_filament_width_sensor]"},{"location":"G-Codes.html#query_filament_width","text":"QUERY_FILAMENT_WIDTH : Restituisce lo spessore del filamento misurato.","title":"QUERY_FILAMENT_WIDTH"},{"location":"G-Codes.html#reset_filament_width_sensor","text":"RESET_FILAMENT_WIDTH_SENSOR : Cancella tutte le letture del sensore. Utile dopo il cambio del filamento.","title":"RESET_FILAMENT_WIDTH_SENSOR"},{"location":"G-Codes.html#disable_filament_width_sensor","text":"DISABLE_FILAMENT_WIDTH_SENSOR : Spegnere il sensore di larghezza del filamento e smettere di usarlo per il controllo del flusso.","title":"DISABLE_FILAMENT_WIDTH_SENSOR"},{"location":"G-Codes.html#enable_filament_width_sensor","text":"ENABLE_FILAMENT_WIDTH_SENSOR : attiva il sensore di larghezza del filamento e inizia a usarlo per il controllo del flusso.","title":"ENABLE_FILAMENT_WIDTH_SENSOR"},{"location":"G-Codes.html#query_raw_filament_width","text":"QUERY_RAW_FILAMENT_WIDTH : Restituisce le letture del canale ADC corrente e il valore grezzo (raw) del sensore per i punti di calibrazione.","title":"QUERY_RAW_FILAMENT_WIDTH"},{"location":"G-Codes.html#enable_filament_width_log","text":"ENABLE_FILAMENT_WIDTH_LOG : attiva la registrazione del diametro del filamento.","title":"ENABLE_FILAMENT_WIDTH_LOG"},{"location":"G-Codes.html#disable_filament_width_log","text":"DISABLE_FILAMENT_WIDTH_LOG : Disattiva la registrazione del diametro del filamento.","title":"DISABLE_FILAMENT_WIDTH_LOG"},{"location":"G-Codes.html#heaters","text":"Il modulo heaters viene caricato automaticamente se un riscaldatore \u00e8 definito nel file di configurazione.","title":"[heaters]"},{"location":"G-Codes.html#turn_off_heaters","text":"TURN_OFF_HEATERS : Spegni tutti i riscaldatori.","title":"TURN_OFF_HEATERS"},{"location":"G-Codes.html#temperature_wait","text":"TEMPERATURE_WAIT SENSOR=<config_name> [MINIMUM=<target>] [MAXIMUM=<target>] : Attendere fino a quando il sensore di temperatura specificato \u00e8 pari o superiore al MINIMO fornito e/o pari o inferiore al MASSIMO fornito.","title":"TEMPERATURE_WAIT"},{"location":"G-Codes.html#set_heater_temperature","text":"SET_HEATER_TEMPERATURE HEATER=<nome_riscaldatore> [TARGET=<temperatura_destinata>] : Imposta la temperatura target per un riscaldatore. Se non viene fornita una temperatura target, il target \u00e8 0.","title":"SET_HEATER_TEMPERATURE"},{"location":"G-Codes.html#idle_timeout","text":"Il modulo idle_timeout viene caricato automaticamente.","title":"[idle_timeout]"},{"location":"G-Codes.html#set_idle_timeout","text":"SET_IDLE_TIMEOUT [TIMEOUT=<timeout>] : consente all'utente di impostare il timeout di inattivit\u00e0 (in secondi).","title":"SET_IDLE_TIMEOUT"},{"location":"G-Codes.html#input_shaper","text":"Il comando seguente \u00e8 abilitato se \u00e8 stata abilitata una sezione di configurazione di input_shaper (consultare anche la guida alla compensazione della risonanza ).","title":"[input_shaper]"},{"location":"G-Codes.html#set_input_shaper","text":"SET_INPUT_SHAPER [SHAPER_FREQ_X=<shaper_freq_x>] [SHAPER_FREQ_Y=<shaper_freq_y>] [DAMPING_RATIO_X=<damping_ratio_x>] [DAMPING_RATIO_Y=<damping_ratio_y>] [SHAPER_TYPE=<shaper>] [SHAPER_TYPE_X=<shaper_type_x>] [SHAPER_TYPE=<shaper_TYPE_X=<shaper_type_x>] [SHAPER_TYPE=<shaper_type_y=<shaper_type_x> ] : Modifica i parametri dell'input shaper. Si noti che il parametro SHAPER_TYPE reimposta l'input shaper per entrambi gli assi X e Y anche se sono stati configurati tipi di shaper diversi nella sezione [input_shaper]. SHAPER_TYPE non pu\u00f2 essere utilizzato insieme a uno dei parametri SHAPER_TYPE_X e SHAPER_TYPE_Y. Vedere config reference per maggiori dettagli su ciascuno di questi parametri.","title":"SET_INPUT_SHAPER"},{"location":"G-Codes.html#manual_probe","text":"Il modulo manual_probe viene caricato automaticamente.","title":"[manual_probe]"},{"location":"G-Codes.html#manual_probe_1","text":"MANUAL_PROBE [SPEED=<speed>] : esegue uno script di supporto utile per misurare l'altezza dell'ugello in una determinata posizione. Se viene specificato SPEED, imposta la velocit\u00e0 dei comandi TESTZ (il valore predefinito \u00e8 5mm/s). Durante una sonda manuale, sono disponibili i seguenti comandi aggiuntivi: ACCEPT : questo comando accetta la posizione Z corrente e conclude il probing manuale. ABORT : questo comando termina lo strumento di probing manuale. TESTZ Z=<valore> : questo comando sposta l'ugello verso l'alto o verso il basso della quantit\u00e0 specificata in \"valore\". Ad esempio, TESTZ Z=-.1 sposterebbe l'ugello verso il basso di .1 mm mentre TESTZ Z=.1 sposterebbe l'ugello verso l'alto di .1 mm. Il valore pu\u00f2 anche essere + , - , ++ o -- per spostare l'ugello verso l'alto o verso il basso di un importo rispetto ai tentativi precedenti.","title":"MANUAL_PROBE"},{"location":"G-Codes.html#z_endstop_calibrate","text":"Z_ENDSTOP_CALIBRATE [SPEED=<speed>] : esegue uno script di supporto utile per calibrare un'impostazione di configurazione Z position_endstop. Vedere il comando MANUAL_PROBE per i dettagli sui parametri e sui comandi aggiuntivi disponibili mentre lo strumento \u00e8 attivo.","title":"Z_ENDSTOP_CALIBRATE"},{"location":"G-Codes.html#z_offset_apply_endstop","text":"Z_OFFSET_APPLY_ENDSTOP : prende l'offset Z Gcode corrente (noto anche come babystepping) e lo sottrae da stepper_z endstop_position. Questa azione per prendere un valore di babystep utilizzato di frequente e \"renderlo permanente\". Richiede un SAVE_CONFIG per avere effetto.","title":"Z_OFFSET_APPLY_ENDSTOP"},{"location":"G-Codes.html#stepper-manuali","text":"Il comando seguente \u00e8 disponibile quando una sezione di configurazione stepper_manuale \u00e8 abilitata.","title":"[Stepper manuali]"},{"location":"G-Codes.html#manual_stepper","text":"MANUAL_STEPPER STEPPER=nome_config [ENABLE=[0|1]] [SET_POSITION=<pos>] [SPEED=<velocit\u00e0>] [ACCEL=<accelerazione>] [MOVE=<pos> [STOP_ON_ENDSTOP=[1|2|- 1|-2]] [SYNC=0]] : Questo comando alterer\u00e0 lo stato dello stepper. Utilizzare il parametro ENABLE per abilitare/disabilitare lo stepper. Utilizzare il parametro SET_POSITION per forzare lo stepper a pensare di trovarsi nella posizione data. Utilizzare il parametro MOVE per richiedere un movimento alla posizione data. Se viene specificato SPEED e/o ACCEL, verranno utilizzati i valori forniti al posto dei valori predefiniti specificati nel file di configurazione. Se viene specificato un ACCEL pari a zero, non verr\u00e0 eseguita alcuna accelerazione. Se viene specificato STOP_ON_ENDSTOP=1, lo spostamento terminer\u00e0 in anticipo se l'endstop segnala come attivato (usa STOP_ON_ENDSTOP=2 per completare lo spostamento senza errori anche se l'endstop non si attiva, usa -1 o -2 per interrompere quando l'endstop segnala non innescato). Normalmente i futuri comandi G-Code verranno programmati per essere eseguiti dopo il completamento del movimento passo-passo, tuttavia se un movimento passo-passo manuale utilizza SYNC=0, i futuri comandi di movimento G-Code potrebbero essere eseguiti in parallelo con il movimento passo-passo.","title":"MANUAL_STEPPER"},{"location":"G-Codes.html#mcp4018","text":"Il comando seguente \u00e8 disponibile quando una sezione di configurazione mcp4018 \u00e8 abilitata.","title":"[mcp4018]"},{"location":"G-Codes.html#set_digipot","text":"SET_DIGIPOT DIGIPOT=config_name WIPER=<value> : Questo comando cambier\u00e0 il valore corrente del digipot. Questo valore dovrebbe essere in genere compreso tra 0.0 e 1.0, a meno che non sia definita una 'scale' nella configurazione. Quando viene definita 'scale', questo valore dovrebbe essere compreso tra 0,0 e 'scale'.","title":"SET_DIGIPOT"},{"location":"G-Codes.html#led","text":"Il comando seguente \u00e8 disponibile quando una qualsiasi delle sezioni di configurazione led \u00e8 abilitata.","title":"[led]"},{"location":"G-Codes.html#set_led","text":"SET_LED LED=<nome_config> ROSSO=<valore> VERDE=<valore> BLU=<valore> BIANCO=<valore> [INDEX=<indice>] [TRANSMIT=0] [SYNC=1] : Imposta il LED in output. Ogni colore <valore> deve essere compreso tra 0,0 e 1,0. L'opzione BIANCO \u00e8 valida solo su LED RGBW. Se il LED supporta pi\u00f9 chip in una catena daisy-chain, \u00e8 possibile specificare INDEX per modificare il colore del solo chip specificato (1 per il primo chip, 2 per il secondo, ecc.). Se INDEX non viene fornito, tutti i LED nella catena verranno impostati sul colore fornito. Se viene specificato TRANSMIT=0, il cambio colore verr\u00e0 effettuato solo sul successivo comando SET_LED che non specifica TRANSMIT=0; questo pu\u00f2 essere utile in combinazione con il parametro INDEX per raggruppare pi\u00f9 aggiornamenti in una catena. Per impostazione predefinita, il comando SET_LED sincronizzer\u00e0 le modifiche con altri comandi gcode in corso. Ci\u00f2 pu\u00f2 comportare un comportamento indesiderato se i LED vengono impostati mentre la stampante non sta stampando in quanto reimposta il timeout di inattivit\u00e0. Se non \u00e8 necessaria una tempistica attenta, \u00e8 possibile specificare il parametro SYNC=0 opzionale per applicare le modifiche senza ripristinare il timeout di inattivit\u00e0.","title":"SET_LED"},{"location":"G-Codes.html#set_led_template","text":"SET_LED_TEMPLATE LED=<nome_led> TEMPLATE=<nome_modello> [<param_x>=<letterale>] [INDEX=<indice>] : Assegna un modello_visualizzazione a un dato LED . Ad esempio, se si definisce una sezione di configurazione [display_template my_led_template] allora si potrebbe assegnare TEMPLATE=my_led_template qui. Il display_template dovrebbe produrre una stringa separata da virgole contenente quattro numeri in virgola mobile corrispondenti alle impostazioni dei colori rosso, verde, blu e bianco. Il modello verr\u00e0 continuamente valutato e il LED verr\u00e0 impostato automaticamente sui colori risultanti. \u00c8 possibile impostare i parametri display_template da utilizzare durante la valutazione del modello (i parametri verranno analizzati come valori letterali Python). Se INDEX non \u00e8 specificato, tutti i chip nella catena dei LED verranno impostati sul modello, altrimenti verr\u00e0 aggiornato solo il chip con l'indice specificato. Se TEMPLATE \u00e8 una stringa vuota, questo comando canceller\u00e0 qualsiasi modello precedente assegnato al LED (\u00e8 quindi possibile utilizzare i comandi SET_LED per gestire le impostazioni del colore del LED).","title":"SET_LED_TEMPLATE"},{"location":"G-Codes.html#output_pin","text":"Il comando seguente \u00e8 disponibile quando una sezione di configurazione pin_output \u00e8 abilitata.","title":"[output_pin]"},{"location":"G-Codes.html#set_pin","text":"SET_PIN PIN=config_name VALUE=<value> : Set the pin to the given output VALUE . VALUE should be 0 or 1 for \"digital\" output pins. For PWM pins, set to a value between 0.0 and 1.0, or between 0.0 and scale if a scale is configured in the output_pin config section. SET_PIN PIN=config_name TEMPLATE=<template_name> [<param_x>=<literal>] : If TEMPLATE is specified then it assigns a display_template to the given pin. For example, if one defined a [display_template my_pin_template] config section then one could assign TEMPLATE=my_pin_template here. The display_template should produce a string containing a floating point number with the desired value. The template will be continuously evaluated and the pin will be automatically set to the resulting value. One may set display_template parameters to use during template evaluation (parameters will be parsed as Python literals). If TEMPLATE is an empty string then this command will clear any previous template assigned to the pin (one can then use SET_PIN commands to manage the values directly).","title":"SET_PIN"},{"location":"G-Codes.html#palette2","text":"I seguenti comandi sono disponibili quando la sezione di configurazione della palette2 \u00e8 abilitata. Le stampe di Palette funzionano incorporando speciali OCodes (Codici Omega) nel file GCode: O1 ... O32 : Questi codici vengono letti dal flusso GCode ed elaborati da questo modulo e passati al dispositivo Palette 2. Sono inoltre disponibili i seguenti comandi aggiuntivi.","title":"[palette2]"},{"location":"G-Codes.html#palette_connect","text":"PALETTE_CONNECT : questo comando inizializza la connessione con la Palette 2.","title":"PALETTE_CONNECT"},{"location":"G-Codes.html#palette_disconnect","text":"PALETTE_DISCONNECT : questo comando si disconnette dalla Palette 2.","title":"PALETTE_DISCONNECT"},{"location":"G-Codes.html#palette_clear","text":"PALETTE_CLEAR : questo comando indica alla Palette 2 di cancellare tutti i percorsi di input e output del filamento.","title":"PALETTE_CLEAR"},{"location":"G-Codes.html#palette_cut","text":"PALETTE_CUT : Questo comando indica alla Palette 2 di tagliare il filamento attualmente caricato nello splice core.","title":"PALETTE_CUT"},{"location":"G-Codes.html#palette_smart_load","text":"PALETTE_SMART_LOAD : Questo comando avvia la sequenza di caricamento intelligente sulla Palette 2. Il filamento viene caricato automaticamente estrudendolo alla distanza calibrata sul dispositivo per la stampante e istruisce la Palette 2 una volta completato il caricamento. Questo comando equivale a premere Smart Load direttamente sullo schermo della Palette 2 dopo che il caricamento del filamento \u00e8 stato completato.","title":"PALETTE_SMART_LOAD"},{"location":"G-Codes.html#pid_calibrate","text":"Il modulo pid_calibrate viene caricato automaticamente se nel file di configurazione \u00e8 definito un riscaldatore.","title":"[pid_calibrate]"},{"location":"G-Codes.html#pid_calibrate_1","text":"PID_CALIBRATE HEATER=<nome_config> TARGET=<temperatura> [WRITE_FILE=1] : esegue un test di calibrazione PID. Il riscaldatore specificato verr\u00e0 abilitato fino al raggiungimento della temperatura target specificata, quindi il riscaldatore verr\u00e0 spento e acceso per diversi cicli. Se il parametro WRITE_FILE \u00e8 abilitato, verr\u00e0 creato il file /tmp/heattest.txt con un log di tutti i campioni di temperatura prelevati durante il test.","title":"PID_CALIBRATE"},{"location":"G-Codes.html#pause_resume","text":"I seguenti comandi sono disponibili quando la pause_resume config section \u00e8 abilitata:","title":"[pause_resume]"},{"location":"G-Codes.html#pause","text":"PAUSE : mette in pausa la stampa corrente. La posizione attuale viene acquisita per la ripresa al ripristino.","title":"PAUSE"},{"location":"G-Codes.html#resume","text":"RESUME [VELOCITY=<value>] : riprende la stampa da una pausa, ripristinando prima la posizione precedentemente acquisita. Il parametro VELOCITY determina la velocit\u00e0 alla quale l'utensile deve tornare alla posizione originale acquisita.","title":"RESUME"},{"location":"G-Codes.html#clear_pause","text":"CLEAR_PAUSE : cancella lo stato di pausa corrente senza riprendere la stampa. Questo \u00e8 utile se si decide di annullare una stampa dopo un PAUSE. Si consiglia di aggiungerlo al gcode iniziale per assicurarsi che lo stato in pausa sia aggiornato per ogni stampa.","title":"CLEAR_PAUSE"},{"location":"G-Codes.html#cancel_print","text":"CANCEL_PRINT : Annulla la stampa corrente.","title":"CANCEL_PRINT"},{"location":"G-Codes.html#print_stats","text":"Il modulo print_stats viene caricato automaticamente.","title":"[print_stats]"},{"location":"G-Codes.html#set_print_stats_info","text":"SET_PRINT_STATS_INFO [TOTAL_LAYER=<total_layer_count>] [CURRENT_LAYER= <current_layer>] : passa le informazioni sulo slicer come il layer attivo ed il totale a Klipper. Aggiungi SET_PRINT_STATS_INFO [TOTAL_LAYER=<total_layer_count>] alla sezione gcode di inizio del tuo slicer e SET_PRINT_STATS_INFO [CURRENT_LAYER= <current_layer>] alla sezione gcode di cambio livello per passare le informazioni sul livello dal tuo slicer a Klipper.","title":"SET_PRINT_STATS_INFO"},{"location":"G-Codes.html#probe","text":"I seguenti comandi sono disponibili quando \u00e8 abilitata una sezione di configurazione della sonda o una sezione di configurazione di bltouch (consultare anche la guida alla calibrazione della sonda ).","title":"[probe]"},{"location":"G-Codes.html#sonda","text":"PROBE [PROBE_SPEED=<mm/s>] [LIFT_SPEED=<mm/s>] [SAMPLES=<count>] [SAMPLE_RETRACT_DIST=<mm>] [SAMPLES_TOLERANCE=<mm>] [SAMPLES_TOLERANCE_RETRIES=<count>] [SAMPLES_RESULT=median|average] : Sposta il nozzle verso il basso finch\u00e9 la sonda non scatta. Se viene fornito uno qualsiasi dei parametri opzionali, sovrascrive l'impostazione equivalente nella sezione probe config section .","title":"sonda"},{"location":"G-Codes.html#query_probe","text":"QUERY_PROBE : Riporta lo stato corrente della sonda (\"triggered\" o \"open\").","title":"QUERY_PROBE"},{"location":"G-Codes.html#probe_accuracy","text":"PROBE_ACCURACY [PROBE_SPEED=<mm/s>] [SAMPLES=<count>] [SAMPLE_RETRACT_DIST=<mm>] : Calcola la deviazione massima, minima, media, mediana e standard di pi\u00f9 campionamentidella sonda. Per impostazione predefinita, vengono presi 10 CAMPIONI. In caso contrario, i parametri opzionali sono impostati per default sulla loro impostazione equivalente nella sezione di configurazione della sonda.","title":"PROBE_ACCURACY"},{"location":"G-Codes.html#probe_calibrate","text":"PROBE_CALIBRATE [SPEED=<speed>] [<probe_parameter>=<value>] : Eseguire uno script di aiuto utile per calibrare l'offset z della sonda. Vedere il comando PROBE per i dettagli sui parametri opzionali della sonda. Vedere il comando MANUAL_PROBE per i dettagli del parametro SPEED e sui comandi aggiuntivi disponibili mentre lo strumento \u00e8 attivo. Nota che il comando PROBE_CALIBRATE utilizza la variabile di velocit\u00e0 per spostarsi in direzione XY e Z.","title":"PROBE_CALIBRATE"},{"location":"G-Codes.html#z_offset_apply_probe","text":"Z_OFFSET_APPLY_PROBE : prende l'offset Z Gcode corrente (aka, babystepping) e lo sottrae dallo z_offset della sonda. Questo per prendere un valore di babystep utilizzato di frequente e \"renderlo permanente\". Richiede un SAVE_CONFIG per avere effetto.","title":"Z_OFFSET_APPLY_PROBE"},{"location":"G-Codes.html#probe_eddy_current","text":"The following commands are available when a probe_eddy_current config section is enabled.","title":"[probe_eddy_current]"},{"location":"G-Codes.html#probe_eddy_current_calibrate","text":"PROBE_EDDY_CURRENT_CALIBRATE CHIP=<config_name> : This starts a tool that calibrates the sensor resonance frequencies to corresponding Z heights. The tool will take a couple of minutes to complete. After completion, use the SAVE_CONFIG command to store the results in the printer.cfg file.","title":"PROBE_EDDY_CURRENT_CALIBRATE"},{"location":"G-Codes.html#ldc_calibrate_drive_current","text":"LDC_CALIBRATE_DRIVE_CURRENT CHIP=<config_name> This tool will calibrate the ldc1612 DRIVE_CURRENT0 register. Prior to using this tool, move the sensor so that it is near the center of the bed and about 20mm above the bed surface. Run this command to determine an appropriate DRIVE_CURRENT for the sensor. After running this command use the SAVE_CONFIG command to store that new setting in the printer.cfg config file.","title":"LDC_CALIBRATE_DRIVE_CURRENT"},{"location":"G-Codes.html#pwm_cycle_time","text":"The following command is available when a pwm_cycle_time config section is enabled.","title":"[pwm_cycle_time]"},{"location":"G-Codes.html#set_pin_1","text":"SET_PIN PIN=config_name VALUE=<value> [CYCLE_TIME=<cycle_time>] : This command works similarly to output_pin SET_PIN commands. The command here supports setting an explicit cycle time using the CYCLE_TIME parameter (specified in seconds). Note that the CYCLE_TIME parameter is not stored between SET_PIN commands (any SET_PIN command without an explicit CYCLE_TIME parameter will use the cycle_time specified in the pwm_cycle_time config section).","title":"SET_PIN"},{"location":"G-Codes.html#quad_gantry_level","text":"The following commands are available when the quad_gantry_level config section is enabled.","title":"[quad_gantry_level]"},{"location":"G-Codes.html#quad_gantry_level_1","text":"QUAD_GANTRY_LEVEL [RETRIES=<value>] [RETRY_TOLERANCE=<value>] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] : This command will probe the points specified in the config and then make independent adjustments to each Z stepper to compensate for tilt. See the PROBE command for details on the optional probe parameters. The optional RETRIES , RETRY_TOLERANCE , and HORIZONTAL_MOVE_Z values override those options specified in the config file.","title":"QUAD_GANTRY_LEVEL"},{"location":"G-Codes.html#query_adc","text":"Il modulo query_adc viene caricato automaticamente.","title":"[query_adc]"},{"location":"G-Codes.html#query_adc_1","text":"QUERY_ADC [NAME=<config_name>] [PULLUP=<value>] : Riporta l'ultimo valore analogico ricevuto per un pin analogico configurato. Se NAME non viene fornito, viene riportato l'elenco dei nomi dei convertitori adc disponibili. Se viene fornito PULLUP (come valore in Ohm), viene riportato il valore analogico grezzo insieme alla resistenza equivalente dato quel pullup specificato.","title":"QUERY_ADC"},{"location":"G-Codes.html#query_endstops","text":"Il modulo query_endstops viene caricato automaticamente. I seguenti comandi G-Code standard sono attualmente disponibili, ma non \u00e8 consigliabile utilizzarli: Ottieni lo stato del finecorsa: M119 (usa invece QUERY_ENDSTOPS.)","title":"[query_endstops]"},{"location":"G-Codes.html#query_endstops_1","text":"QUERY_ENDSTOPS : Rilevare i finecorsa degli assi e segnala se sono \"attivate\" o in uno stato \"aperto\". Questo comando viene in genere utilizzato per verificare che un finecorsa funzioni correttamente.","title":"QUERY_ENDSTOPS"},{"location":"G-Codes.html#resonance_tester","text":"I seguenti comandi sono disponibili quando una sezione di configurazione di tester_risonanza \u00e8 abilitata (consultare anche la guida alle risonanze di misurazione ).","title":"[resonance_tester]"},{"location":"G-Codes.html#measure_axes_noise","text":"MEASURE_AXES_NOISE : misura ed riporta il rumore per tutti gli assi di tutti i chip dell'accelerometro abilitati.","title":"MEASURE_AXES_NOISE"},{"location":"G-Codes.html#test_resonances","text":"TEST_RESONANCES AXIS=<axis> [OUTPUT=<resonances,raw_data>] [NAME=<name>] [FREQ_START=<min_freq>] [FREQ_END=<max_freq>] [ACCEL_PER_HZ=<accel_per_hz>] [HZ_PER_SEC=<hz_per_sec>] [CHIPS=<chip_name>] [POINT=x,y,z] [INPUT_SHAPING=<0:1>] : Runs the resonance test in all configured probe points for the requested \"axis\" and measures the acceleration using the accelerometer chips configured for the respective axis. \"axis\" can either be X or Y, or specify an arbitrary direction as AXIS=dx,dy , where dx and dy are floating point numbers defining a direction vector (e.g. AXIS=X , AXIS=Y , or AXIS=1,-1 to define a diagonal direction). Note that AXIS=dx,dy and AXIS=-dx,-dy is equivalent. chip_name can be one or more configured accel chips, delimited with comma, for example CHIPS=\"adxl345, adxl345 rpi\" . If POINT is specified it will override the point(s) configured in [resonance_tester] . If INPUT_SHAPING=0 or not set(default), disables input shaping for the resonance testing, because it is not valid to run the resonance testing with the input shaper enabled. OUTPUT parameter is a comma-separated list of which outputs will be written. If raw_data is requested, then the raw accelerometer data is written into a file or a series of files /tmp/raw_data_<axis>_[<chip_name>_][<point>_]<name>.csv with ( <point>_ part of the name generated only if more than 1 probe point is configured or POINT is specified). If resonances is specified, the frequency response is calculated (across all probe points) and written into /tmp/resonances_<axis>_<name>.csv file. If unset, OUTPUT defaults to resonances , and NAME defaults to the current time in \"YYYYMMDD_HHMMSS\" format.","title":"TEST_RESONANCES"},{"location":"G-Codes.html#shaper_calibrate","text":"SHAPER_CALIBRATE [AXIS=<axis>] [NAME=<name>] [FREQ_START=<min_freq>] [FREQ_END=<max_freq>] [ACCEL_PER_HZ=<accel_per_hz>][HZ_PER_SEC=<hz_per_sec>] [CHIPS=<chip_name>] [MAX_SMOOTHING=<max_smoothing>] [INPUT_SHAPING=<0:1>] : Similarly to TEST_RESONANCES , runs the resonance test as configured, and tries to find the optimal parameters for the input shaper for the requested axis (or both X and Y axes if AXIS parameter is unset). If MAX_SMOOTHING is unset, its value is taken from [resonance_tester] section, with the default being unset. See the Max smoothing of the measuring resonances guide for more information on the use of this feature. The results of the tuning are printed to the console, and the frequency responses and the different input shapers values are written to a CSV file(s) /tmp/calibration_data_<axis>_<name>.csv . Unless specified, NAME defaults to the current time in \"YYYYMMDD_HHMMSS\" format. Note that the suggested input shaper parameters can be persisted in the config by issuing SAVE_CONFIG command, and if [input_shaper] was already enabled previously, these parameters take effect immediately.","title":"SHAPER_CALIBRATE"},{"location":"G-Codes.html#respond","text":"I seguenti comandi G-Code standard sono disponibili quando la sezione di configurazione di risposta \u00e8 abilitata: M118 <messaggio> : fa eco al messaggio preceduto dal prefisso predefinito configurato (o echo: se non \u00e8 configurato alcun prefisso). Sono inoltre disponibili i seguenti comandi aggiuntivi.","title":"[respond]"},{"location":"G-Codes.html#respond_1","text":"RESPOND MSG=\"<message>\" : echo il messaggio preceduto dal prefisso predefinito configurato (o echo: se non \u00e8 configurato alcun prefisso). RESPOND TYPE=echo MSG=\"<message>\" : echo del messaggio preceduto da echo: . RESPOND TYPE=echo_no_space MSG=\"<messaggio>\" : fa eco al messaggio preceduto da echo: senza uno spazio tra prefisso e messaggio, utile per la compatibilit\u00e0 con alcuni plugin di octoprint che prevedono una formattazione molto specifica. RESPOND TYPE=command MSG=\"<message>\" : echo il messaggio preceduto da // . OctoPrint pu\u00f2 essere configurato per rispondere a questi messaggi (ad es. RESPOND TYPE=command MSG=action:pause ). RESPOND TYPE=error MSG=\"<messaggio>\" : fa eco al messaggio preceduto da !! . RESPOND PREFIX=<prefix> MSG=\"<message>\" : echo il messaggio preceduto da <prefix> . (Il parametro PREFIX avr\u00e0 la priorit\u00e0 sul parametro TYPE )","title":"RESPOND"},{"location":"G-Codes.html#save_variables","text":"Il comando seguente \u00e8 abilitato se \u00e8 stata abilitata una sezione di configurazione save_variables .","title":"[save_variables]"},{"location":"G-Codes.html#save_variable","text":"SAVE_VARIABLE VARIABLE=<nome> VALUE=<valore> : salva la variabile su disco in modo che possa essere utilizzata tra i riavvii. Tutte le variabili memorizzate vengono caricate nel dict printer.save_variables.variables all'avvio e possono essere utilizzate nelle macro gcode. Il VALUE fornito viene analizzato come un valore letterale Python.","title":"SAVE_VARIABLE"},{"location":"G-Codes.html#screws_tilt_adjust","text":"I seguenti comandi sono disponibili quando la sezione di configurazione viti_tilt_adjust \u00e8 abilitata (consultare anche la manual level guide ).","title":"[screws_tilt_adjust]"},{"location":"G-Codes.html#screws_tilt_calculate","text":"SCREWS_TILT_CALCULATE [DIRECTION=CW|CCW] [MAX_DEVIATION=<valore>] [HORIZONTAL_MOVE_Z=<valore>] [<probe_parameter>=<valore>] : questo comando richiamer\u00e0 lo strumento di regolazione delle viti del piatto. Comander\u00e0 l'ugello in posizioni diverse (come definito nel file di configurazione) sondando l'altezza z e calcoler\u00e0 il numero di giri della manopola per regolare il livello del piatto. Se \u00e8 specificata DIREZIONE, i giri della manopola saranno tutti nella stessa direzione, in senso orario (CW) o antiorario (CCW). Vedere il comando PROBE per i dettagli sui parametri opzionali della sonda. IMPORTANTE: DEVI sempre eseguire un G28 prima di utilizzare questo comando. Se viene specificato MAX_DEVIATION, il comando generer\u00e0 un errore gcode se qualsiasi differenza nell'altezza della vite rispetto all'altezza della vite di base \u00e8 maggiore del valore fornito. Il valore opzionale HORIZONTAL_MOVE_Z sovrascrive l'opzione horizontal_move_z specificata nel file di configurazione.","title":"SCREWS_TILT_CALCULATE"},{"location":"G-Codes.html#sdcard_loop","text":"Quando la sezione di configurazione sdcard_loop \u00e8 abilitata, sono disponibili i seguenti comandi estesi.","title":"[sdcard_loop]"},{"location":"G-Codes.html#sdcard_loop_begin","text":"SDCARD_LOOP_BEGIN COUNT=<count> : inizia una sezione in loop nella stampa SD. Un conteggio pari a 0 indica che la sezione deve essere ripetuta indefinitamente.","title":"SDCARD_LOOP_BEGIN"},{"location":"G-Codes.html#sdcard_loop_end","text":"SDCARD_LOOP_END : termina una sezione in loop nella stampa SD.","title":"SDCARD_LOOP_END"},{"location":"G-Codes.html#sdcard_loop_desist","text":"SDCARD_LOOP_DESIST : completa i loop esistenti senza ulteriori iterazioni.","title":"SDCARD_LOOP_DESIST"},{"location":"G-Codes.html#servo","text":"I seguenti comandi sono disponibili quando una sezione di configurazione servo \u00e8 abilitata.","title":"[servo]"},{"location":"G-Codes.html#set_servo","text":"SET_SERVO SERVO=nome_config [ANGLE=<gradi> | WIDTH=<secondi>] : Imposta la posizione del servo sull'angolo dato (in gradi) o sulla larghezza dell'impulso (in secondi). Usa WIDTH=0 per disabilitare l'uscita servo.","title":"SET_SERVO"},{"location":"G-Codes.html#skew_correction","text":"I seguenti comandi sono disponibili quando \u00e8 abilitata la sezione config_correzione_asimmetria (consultare anche la guida Correzione_asimmetria ).","title":"[skew_correction]"},{"location":"G-Codes.html#set_skew","text":"SET_SKEW [XY=<ac_length,bd_length,ad_length>] [XZ=<ac,bd,ad>] [YZ=<ac,bd,ad>] [CLEAR=<0|1>] : Configura il modulo [correzione_inclinazione ] con misure (in mm) tratte da una stampa di calibrazione. Si possono inserire misure per qualsiasi combinazione di piani, i piani non inseriti manterranno il loro valore attuale. Se viene immesso CLEAR=1 , tutta la correzione dell'inclinazione sar\u00e0 disabilitata.","title":"SET_SKEW"},{"location":"G-Codes.html#get_current_skew","text":"GET_CURRENT_SKEW : Riporta l'inclinazione corrente della stampante per ciascun piano sia in radianti che in gradi. L'inclinazione viene calcolata in base ai parametri forniti tramite il gcode SET_SKEW .","title":"GET_CURRENT_SKEW"},{"location":"G-Codes.html#calc_measured_skew","text":"CALC_MEASURED_SKEW [AC=<ac_length>] [BD=<bd_length>] [AD=<ad_length>] : calcola e riporta l'inclinazione (in radianti e gradi) in base a una stampa di test misurata. Questo pu\u00f2 essere utile per determinare l'inclinazione corrente della stampante dopo che \u00e8 stata applicata la correzione. Pu\u00f2 anche essere utile prima di applicare la correzione per determinare se \u00e8 necessaria la correzione dell'inclinazione. Vedere Correzione inclinazione per i dettagli su oggetti e misurazioni di calibrazione inclinazione.","title":"CALC_MEASURED_SKEW"},{"location":"G-Codes.html#skew_profile","text":"SKEW_PROFILE [LOAD=<nome>] [SAVE=<nome>] [REMOVE=<nome>] : Gestione del profilo per correzione_inclinazione. LOAD ripristiner\u00e0 lo stato di inclinazione dal profilo corrispondente al nome fornito. SAVE salver\u00e0 lo stato di inclinazione corrente in un profilo che corrisponde al nome fornito. REMOVE eliminer\u00e0 il profilo corrispondente al nome fornito dalla memoria persistente. Si noti che dopo aver eseguito le operazioni SAVE o REMOVE \u00e8 necessario eseguire il gcode SAVE_CONFIG per rendere permanenti le modifiche alla memoria persistente.","title":"SKEW_PROFILE"},{"location":"G-Codes.html#smart_effector","text":"Sono disponibili diversi comandi quando una sezione di configurazione smart_effector \u00e8 abilitata. Assicurati di controllare la documentazione ufficiale per Smart Effector su Duet3D Wiki prima di modificare i parametri di Smart Effector. Controllare anche la guida alla calibrazione della sonda .","title":"[smart_effector]"},{"location":"G-Codes.html#set_smart_effector","text":"SET_SMART_EFFECTOR [SENSITIVITY=<sensibilit\u00e0>] [ACCEL=<accel>] [RECOVERY_TIME=<tempo>] : imposta i parametri di Smart Effector. Quando viene specificato SENSITIVITY , il rispettivo valore viene scritto nella EEPROM dello SmartEffector (richiede che sia fornito control_pin ). I valori di <sensibilit\u00e0> accettabili sono 0..255, il valore predefinito \u00e8 50. Valori inferiori richiedono una minore forza di contatto dell'ugello per attivarsi (ma esiste un rischio maggiore di falso trigger a causa delle vibrazioni durante la tastatura) e valori pi\u00f9 alti riducono il falso trigger (ma richiede una maggiore forza di contatto per attivarsi). Poich\u00e9 la sensibilit\u00e0 viene scritta nella EEPROM, viene conservata dopo lo spegnimento e quindi non \u00e8 necessario configurarla ad ogni avvio della stampante. ACCEL e RECOVERY_TIME consentono di sovrascrivere i parametri corrispondenti in fase di esecuzione, vedere la sezione di configurazione di Smart Effector per maggiori informazioni su quei parametri.","title":"SET_SMART_EFFECTOR"},{"location":"G-Codes.html#reset_smart_effector","text":"RESET_SMART_EFFECTOR : Ripristina la sensibilit\u00e0 di Smart Effector alle impostazioni di fabbrica. Richiede che il relativo control_pin sia fornito nella sezione di configurazione.","title":"RESET_SMART_EFFECTOR"},{"location":"G-Codes.html#stepper_enable","text":"Il modulo stepper_enable viene caricato automaticamente.","title":"[stepper_enable]"},{"location":"G-Codes.html#set_stepper_enable","text":"SET_STEPPER_ENABLE STEPPER=<nome_config> ENABLE=[0|1] : Abilita o disabilita solo lo stepper dato. Questo \u00e8 uno strumento diagnostico e di debug e deve essere utilizzato con cautela. La disabilitazione di un motore dell'asse non ripristina le informazioni di homing. Lo spostamento manuale di uno stepper disabilitato pu\u00f2 causare l'azionamento del motore della macchina al di fuori dei limiti di sicurezza. Ci\u00f2 pu\u00f2 causare danni ai componenti dell'asse, al hotend e alla superficie di stampa.","title":"SET_STEPPER_ENABLE"},{"location":"G-Codes.html#temperature_fan","text":"Il comando seguente \u00e8 disponibile quando una sezione di configurazione della ventola_temperatura \u00e8 abilitata.","title":"[temperature_fan]"},{"location":"G-Codes.html#set_temperature_fan_target","text":"SET_TEMPERATURE_FAN_TARGET temperature_fan=<temperature_fan_name> [target=<target_temperature>] [min_speed=<min_speed>] [max_speed=<max_speed>] : Imposta la temperatura target per una temperature_fan. Se non viene fornito un target, viene impostato sulla temperatura specificata nel file di configurazione. Se le velocit\u00e0 non vengono fornite, non viene applicata alcuna modifica.","title":"SET_TEMPERATURE_FAN_TARGET"},{"location":"G-Codes.html#tmcxxxx","text":"I seguenti comandi sono disponibili quando una qualsiasi delle tmcXXXX config section \u00e8 abilitata.","title":"[tmcXXXX]"},{"location":"G-Codes.html#dump_tmc","text":"DUMP_TMC STEPPER=<nome> [REGISTER=<nome>] : questo comando legger\u00e0 tutti i registri del driver TMC e riporter\u00e0 i loro valori. Se viene fornito un REGISTER, verr\u00e0 eseguito il dump solo del registro specificato.","title":"DUMP_TMC"},{"location":"G-Codes.html#init_tmc","text":"INIT_TMC STEPPER=<nome> : questo comando inizializzer\u00e0 i registri TMC. Necessario per riattivare il driver se l'alimentazione al chip viene spenta e poi riaccesa.","title":"INIT_TMC"},{"location":"G-Codes.html#set_tmc_current","text":"SET_TMC_CURRENT STEPPER=<nome> CURRENT=<amp> HOLDCURRENT=<amp> : regola le correnti di funzionamento e mantenimento del driver TMC. HOLDCURRENT non \u00e8 applicabile ai driver tmc2660. Quando utilizzato su un driver che dispone del campo globalscaler (tmc5160 e tmc2240), se si utilizza StealthChop2, lo stepper deve essere tenuto fermo per >130 ms in modo che il driver esegua la calibrazione AT#1.","title":"SET_TMC_CURRENT"},{"location":"G-Codes.html#set_tmc_field","text":"SET_TMC_FIELD STEPPER=<nome> FIELD=<campo> VALUE=<valore> VELOCITY=<valore> : Ci\u00f2 modificher\u00e0 il valore del campo di registro specificato del driver TMC. Questo comando \u00e8 destinato solo alla diagnostica e al debug di basso livello poich\u00e9 la modifica dei campi durante l'esecuzione pu\u00f2 portare a comportamenti indesiderati e potenzialmente pericolosi della stampante. Le modifiche permanenti dovrebbero invece essere apportate utilizzando il file di configurazione della stampante. Non vengono eseguiti controlli di integrit\u00e0 per i valori specificati. \u00c8 anche possibile specificare una VELOCIT\u00c0 invece di un VALORE. Questa velocit\u00e0 viene convertita nella rappresentazione del valore basata su TSTEP a 20 bit. Utilizzare l'argomento VELOCIT\u00c0 solo per i campi che rappresentano velocit\u00e0.","title":"SET_TMC_FIELD"},{"location":"G-Codes.html#toolhead","text":"Il modulo toolhead viene caricato automaticamente.","title":"[toolhead]"},{"location":"G-Codes.html#set_velocity_limit","text":"SET_VELOCITY_LIMIT [VELOCITY=<value>] [ACCEL=<value>] [MINIMUM_CRUISE_RATIO=<value>] [SQUARE_CORNER_VELOCITY=<value>] : This command can alter the velocity limits that were specified in the printer config file. See the printer config section for a description of each parameter.","title":"SET_VELOCITY_LIMIT"},{"location":"G-Codes.html#tuning_tower","text":"Il modulo tuning_tower viene caricato automaticamente.","title":"[tuning_tower]"},{"location":"G-Codes.html#tuning_tower_1","text":"TUNING_TOWER COMMAND=<comando> PARAMETER=<nome> START=<valore> [SKIP=<valore>] [FACTOR=<valore> [BAND=<valore>]] | [STEP_DELTA=<valore> STEP_HEIGHT=<valore>] : Uno strumento per regolare un parametro su ciascuna altezza Z durante una stampa. Lo strumento eseguir\u00e0 il dato COMMAND con il dato PARAMETER assegnato a un valore che varia con Z secondo una formula. Usa FACTOR se utilizzerai un righello o calibri per misurare l'altezza Z del valore ottimale, o STEP_DELTA e STEP_HEIGHT se il modello della torre di regolazione ha bande di valori discreti come \u00e8 comune con le torri della temperatura. Se viene specificato SKIP=<valore> , il processo di ottimizzazione non inizia finch\u00e9 non viene raggiunta l'altezza Z <valore> , e al di sotto di essa il valore sar\u00e0 impostato su START ; in questo caso, la z_height usata nelle formule seguenti \u00e8 in realt\u00e0 max(z - skip, 0) . Ci sono tre possibili combinazioni di opzioni: FACTOR : Il valore cambia a una velocit\u00e0 di factor per millimetro. La formula utilizzata \u00e8: valore = inizio + fattore * z_altezza . \u00c8 possibile inserire l'altezza Z ottimale direttamente nella formula per determinare il valore del parametro ottimale. FACTOR e BAND : il valore cambia a una velocit\u00e0 media di factor per millimetro, ma in bande discrete in cui la regolazione verr\u00e0 effettuata solo ogni BAND millimetri di altezza Z. La formula utilizzata \u00e8: value = start + factor * ((floor(z_height / band) + .5) * band) . STEP_DELTA e STEP_HEIGHT : il valore cambia di STEP_DELTA ogni STEP_HEIGHT millimetri. La formula utilizzata \u00e8: value = start + step_delta * floor(z_height / step_height) . Puoi semplicemente contare le bande o leggere le etichette della torre di tuning per determinare il valore ottimale.","title":"TUNING_TOWER"},{"location":"G-Codes.html#virtual_sdcard","text":"Klipper supporta i seguenti comandi G-Code standard se la sezione di configurazione di virtual_sdcard \u00e8 abilitata: Elenco scheda SD: M20 Inizializza scheda SD: M21 Selezionare il file SD: M23 <nomefile> Avvia/riprendi la stampa SD: M24 Sospendi la stampa SD: M25 Impostare la posizione SD: M26 S<offset> Riporta lo stato di stampa SD: M27 Inoltre, quando la sezione di configurazione \"virtual_sdcard\" \u00e8 abilitata, sono disponibili i seguenti comandi estesi.","title":"[virtual_sdcard]"},{"location":"G-Codes.html#sdcard_print_file","text":"SDCARD_PRINT_FILE FILENAME=<nomefile> : carica un file e avvia la stampa SD.","title":"SDCARD_PRINT_FILE"},{"location":"G-Codes.html#sdcard_reset_file","text":"SDCARD_RESET_FILE : Scarica il file e cancella lo stato SD.","title":"SDCARD_RESET_FILE"},{"location":"G-Codes.html#z_thermal_adjust","text":"I seguenti comandi sono disponibili quando la sezione z_thermal_adjust config \u00e8 abilitata.","title":"[z_thermal_adjust]"},{"location":"G-Codes.html#set_z_thermal_adjust","text":"SET_Z_THERMAL_ADJUST [ENABLE=<0:1>] [TEMP_COEFF=<valore>] [REF_TEMP=<valore>] : Abilita o disabilita la regolazione termica Z con ENABLE . La disabilitazione non rimuove alcuna regolazione gi\u00e0 applicata, ma congela il valore di regolazione corrente - questo impedisce il movimento Z verso il basso potenzialmente pericoloso. La riattivazione pu\u00f2 potenzialmente causare il movimento dell'utensile verso l'alto quando la regolazione viene aggiornata e applicata. TEMP_COEFF consente la regolazione in tempo reale del coefficiente di temperatura di regolazione (cio\u00e8 il parametro di configurazione TEMP_COEFF ). I valori TEMP_COEFF non vengono salvati nella configurazione. REF_TEMP sovrascrive manualmente la temperatura di riferimento tipicamente impostata durante l'homing (per l'uso, ad esempio, in routine di homing non standard) - verr\u00e0 ripristinata automaticamente durante l'homing.","title":"SET_Z_THERMAL_ADJUST"},{"location":"G-Codes.html#z_tilt","text":"I seguenti comandi sono disponibili quando la sezione z_tilt config \u00e8 abilitata.","title":"[z_tilt]"},{"location":"G-Codes.html#z_tilt_adjust","text":"Z_TILT_ADJUST [RETRIES=<value>] [RETRY_TOLERANCE=<value>] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] : This command will probe the points specified in the config and then make independent adjustments to each Z stepper to compensate for tilt. See the PROBE command for details on the optional probe parameters. The optional RETRIES , RETRY_TOLERANCE , and HORIZONTAL_MOVE_Z values override those options specified in the config file.","title":"Z_TILT_ADJUST"},{"location":"G-Codes.html#temperature_probe","text":"The following commands are available when a temperature_probe config section is enabled.","title":"[temperature_probe]"},{"location":"G-Codes.html#temperature_probe_calibrate","text":"TEMPERATURE_PROBE_CALIBRATE [PROBE=<probe name>] [TARGET=<value>] [STEP=<value>] : Initiates probe drift calibration for eddy current based probes. The TARGET is a target temperature for the last sample. When the temperature recorded during a sample exceeds the TARGET calibration will complete. The STEP parameter sets temperature delta (in C) between samples. After a sample has been taken, this delta is used to schedule a call to TEMPERATURE_PROBE_NEXT . The default STEP is 2.","title":"TEMPERATURE_PROBE_CALIBRATE"},{"location":"G-Codes.html#temperature_probe_next","text":"TEMPERATURE_PROBE_NEXT : After calibration has started this command is run to take the next sample. It is automatically scheduled to run when the delta specified by STEP has been reached, however its also possible to manually run this command to force a new sample. This command is only available during calibration.","title":"TEMPERATURE_PROBE_NEXT"},{"location":"G-Codes.html#temperature_probe_complete","text":"TEMPERATURE_PROBE_COMPLETE : Can be used to end calibration and save the current result before the TARGET temperature is reached. This command is only available during calibration.","title":"TEMPERATURE_PROBE_COMPLETE:"},{"location":"G-Codes.html#abort","text":"ABORT : Aborts the calibration process, discarding the current results. This command is only available during drift calibration.","title":"ABORT"},{"location":"G-Codes.html#temperature_probe_enable","text":"TEMPERATURE_PROBE_ENABLE ENABLE=[0|1] : Sets temperature drift compensation on or off. If ENABLE is set to 0, drift compensation will be disabled, if set to 1 it is enabled.","title":"TEMPERATURE_PROBE_ENABLE"},{"location":"Hall_Filament_Width_Sensor.html","text":"Sensore di Hall per larghezza del filamento \u00b6 Questo documento descrive il modulo host del sensore di larghezza del filamento. L'hardware utilizzato per lo sviluppo di questo modulo host si basa su due sensori lineari Hall (ad esempio SS49e). I sensori nel corpo si trovano sui lati opposti. Principio di funzionamento: due sensori Hall funzionano in modalit\u00e0 differenziale, la deriva della temperatura \u00e8 la stessa per il sensore. Non \u00e8 necessaria una speciale compensazione della temperatura. Puoi trovare i design su Thingiverse , un video di assemblaggio \u00e8 disponibile anche su Youtube Per utilizzare il sensore di larghezza del filamento Hall, leggere Config Reference e G-Code documentation . Come funziona? \u00b6 Il sensore genera due uscite analogiche in base alla larghezza calcolata del filamento. La somma della tensione di uscita \u00e8 sempre uguale alla larghezza del filamento rilevato. Il modulo host monitora le variazioni di tensione e regola il moltiplicatore di estrusione. Utilizzo il connettore aux2 su una scheda simile alle ramps con i pin analog11 e analog12. \u00c8 possibile utilizzare pin diversi e schede diverse. Modello per variabili di menu \u00b6 [menu __main __filament __width_current] type: command enable: {'hall_filament_width_sensor' in printer} name: Dia: {'%.2F' % printer.hall_filament_width_sensor.Diameter} index: 0 [menu __main __filament __raw_width_current] type: command enable: {'hall_filament_width_sensor' in printer} name: Raw: {'%4.0F' % printer.hall_filament_width_sensor.Raw} index: 1 Procedura di calibrazione \u00b6 Per ottenere il valore grezzo del sensore \u00e8 possibile utilizzare la voce di menu o il comando QUERY_RAW_FILAMENT_WIDTH nel terminale. Inserire la prima barra di calibrazione (dimensione 1,5 mm) ottenere il primo valore grezzo del sensore Inserire la seconda barra di calibrazione (dimensione 2,0 mm) per ottenere il secondo valore grezzo del sensore Salva i valori grezzi del sensore nel parametro di configurazione Raw_dia1 e Raw_dia2 Come abilitare il sensore \u00b6 Per impostazione predefinita, il sensore \u00e8 disabilitato all'accensione. Per abilitare il sensore, emettere il comando ENABLE_FILAMENT_WIDTH_SENSOR o impostare il parametro enable su true . Registrazione \u00b6 Per impostazione predefinita, la registrazione del diametro \u00e8 disabilitata all'accensione. Emettere il comando ENABLE_FILAMENT_WIDTH_LOG per avviare la registrazione ed emettere il comando DISABLE_FILAMENT_WIDTH_LOG per interrompere la registrazione. Per abilitare la registrazione all'accensione, impostare il parametro logging su true . Il diametro del filamento viene registrato con un intervallo di misurazione (10 mm per impostazione predefinita).","title":"Sensore di Hall per larghezza del filamento"},{"location":"Hall_Filament_Width_Sensor.html#sensore-di-hall-per-larghezza-del-filamento","text":"Questo documento descrive il modulo host del sensore di larghezza del filamento. L'hardware utilizzato per lo sviluppo di questo modulo host si basa su due sensori lineari Hall (ad esempio SS49e). I sensori nel corpo si trovano sui lati opposti. Principio di funzionamento: due sensori Hall funzionano in modalit\u00e0 differenziale, la deriva della temperatura \u00e8 la stessa per il sensore. Non \u00e8 necessaria una speciale compensazione della temperatura. Puoi trovare i design su Thingiverse , un video di assemblaggio \u00e8 disponibile anche su Youtube Per utilizzare il sensore di larghezza del filamento Hall, leggere Config Reference e G-Code documentation .","title":"Sensore di Hall per larghezza del filamento"},{"location":"Hall_Filament_Width_Sensor.html#come-funziona","text":"Il sensore genera due uscite analogiche in base alla larghezza calcolata del filamento. La somma della tensione di uscita \u00e8 sempre uguale alla larghezza del filamento rilevato. Il modulo host monitora le variazioni di tensione e regola il moltiplicatore di estrusione. Utilizzo il connettore aux2 su una scheda simile alle ramps con i pin analog11 e analog12. \u00c8 possibile utilizzare pin diversi e schede diverse.","title":"Come funziona?"},{"location":"Hall_Filament_Width_Sensor.html#modello-per-variabili-di-menu","text":"[menu __main __filament __width_current] type: command enable: {'hall_filament_width_sensor' in printer} name: Dia: {'%.2F' % printer.hall_filament_width_sensor.Diameter} index: 0 [menu __main __filament __raw_width_current] type: command enable: {'hall_filament_width_sensor' in printer} name: Raw: {'%4.0F' % printer.hall_filament_width_sensor.Raw} index: 1","title":"Modello per variabili di menu"},{"location":"Hall_Filament_Width_Sensor.html#procedura-di-calibrazione","text":"Per ottenere il valore grezzo del sensore \u00e8 possibile utilizzare la voce di menu o il comando QUERY_RAW_FILAMENT_WIDTH nel terminale. Inserire la prima barra di calibrazione (dimensione 1,5 mm) ottenere il primo valore grezzo del sensore Inserire la seconda barra di calibrazione (dimensione 2,0 mm) per ottenere il secondo valore grezzo del sensore Salva i valori grezzi del sensore nel parametro di configurazione Raw_dia1 e Raw_dia2","title":"Procedura di calibrazione"},{"location":"Hall_Filament_Width_Sensor.html#come-abilitare-il-sensore","text":"Per impostazione predefinita, il sensore \u00e8 disabilitato all'accensione. Per abilitare il sensore, emettere il comando ENABLE_FILAMENT_WIDTH_SENSOR o impostare il parametro enable su true .","title":"Come abilitare il sensore"},{"location":"Hall_Filament_Width_Sensor.html#registrazione","text":"Per impostazione predefinita, la registrazione del diametro \u00e8 disabilitata all'accensione. Emettere il comando ENABLE_FILAMENT_WIDTH_LOG per avviare la registrazione ed emettere il comando DISABLE_FILAMENT_WIDTH_LOG per interrompere la registrazione. Per abilitare la registrazione all'accensione, impostare il parametro logging su true . Il diametro del filamento viene registrato con un intervallo di misurazione (10 mm per impostazione predefinita).","title":"Registrazione"},{"location":"Installation.html","text":"Installazione \u00b6 These instructions assume the software will run on a linux based host running a Klipper compatible front end. It is recommended that a SBC(Small Board Computer) such as a Raspberry Pi or Debian based Linux device be used as the host machine (see the FAQ for other options). For the purposes of these instructions host relates to the Linux device and mcu relates to the printboard. SBC relates to the term Small Board Computer such as the Raspberry Pi. Ottenere un file di configurazione di Klipper \u00b6 Most Klipper settings are determined by a \"printer configuration file\" printer.cfg, that will be stored on the host. An appropriate configuration file can often be found by looking in the Klipper config directory for a file starting with a \"printer-\" prefix that corresponds to the target printer. The Klipper configuration file contains technical information about the printer that will be needed during the installation. Se non c'\u00e8 un file di configurazione della stampante appropriato nella directory di configurazione di Klipper, prova a cercare nel sito web del produttore della stampante per vedere se hanno un file di configurazione di Klipper appropriato. Se non \u00e8 possibile trovare alcun file di configurazione per la stampante, ma si conosce il tipo di scheda di controllo della stampante, cercare un file di configurazione appropriato che inizi con un prefisso \"generico-\". Questi file di esempio della scheda della stampante dovrebbero consentire di completare correttamente l'installazione iniziale, ma richiederanno alcune personalizzazioni per ottenere la funzionalit\u00e0 completa della stampante. \u00c8 anche possibile definire da zero una nuova configurazione della stampante. Tuttavia, ci\u00f2 richiede una conoscenza tecnica significativa sulla stampante e la sua elettronica. Si consiglia alla maggior parte degli utenti di iniziare con un file di configurazione appropriato. Se si crea un nuovo file di configurazione della stampante personalizzato, iniziare con l'esempio pi\u00f9 vicino file di configurazione e utilizzare Klipper riferimento alla configurazione per ulteriori informazioni. Interacting with Klipper \u00b6 Klipper is a 3d printer firmware, so it needs some way for the user to interact with it. Currently the best choices are front ends that retrieve information through the Moonraker web API and there is also the option to use Octoprint to control Klipper. The choice is up to the user on what to use, but the underlying Klipper is the same in all cases. We encourage users to research the options available and make an informed decision. Obtaining an OS image for SBC's \u00b6 There are many ways to obtain an OS image for Klipper for SBC use, most depend on what front end you wish to use. Some manafactures of these SBC boards also provide their own Klipper-centric images. The two main Moonraker based front ends are Fluidd and Mainsail , the latter of which has a premade install image \"MainsailOS\" , this has the option for Raspberry Pi and some OrangePi varianta. Fluidd can be installed via KIAUH(Klipper Install And Update Helper), which is explained below and is a 3rd party installer for all things Klipper. OctoPrint can be installed via the popular OctoPi image or via KIAUH, this process is explained in Installing via KIAUH \u00b6 Normally you would start with a base image for your SBC, RPiOS Lite for example, or in the case of a x86 Linux device, Ubuntu Server. Please note that Desktop variants are not recommended due to certain helper programs that can stop some Klipper functions working and even mask access to some print boards. KIAUH can be used to install Klipper and its associated programs on a variety of Linux based systems that run a form of Debian. More information can be found at https://github.com/dw-0/kiauh Compilare il firmware e flashare il microcontrollore \u00b6 To compile the micro-controller code, start by running these commands on your host device: cd ~/klipper/ make menuconfig I commenti nella parte superiore del file di configurazione della stampante dovrebbero descrivere le impostazioni che devono essere impostate durante \"make menuconfig\". Apri il file in un browser web o in un editor di testo e cerca queste istruzioni nella parte superiore del file. Una volta configurate le impostazioni \"menuconfig\" appropriate, premere \"Q\" per uscire, quindi \"Y\" per salvare. Quindi esegui: make Se i commenti nella parte superiore del file di configurazione della stampante descrivono i passaggi personalizzati per il \"flash\" dell'immagine finale sulla scheda di controllo della stampante, segui questi passaggi e poi procedi con configurazione OctoPrint . In caso contrario, i seguenti passaggi vengono spesso utilizzati per eseguire il \"flash\" della scheda di controllo della stampante. Innanzitutto \u00e8 necessario determinare la porta seriale collegata al microcontrollore. Esegui quanto segue: ls /dev/serial/by-id/* Dovrebbe venire riportato qualcosa di simile a questo: /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 It's common for each printer to have its own unique serial port name. This unique name will be used when flashing the micro-controller. It's possible there may be multiple lines in the above output - if so, choose the line corresponding to the micro-controller. If many items are listed and the choice is ambiguous, unplug the board and run the command again, the missing item will be your print board(see the FAQ for more information). For common micro-controllers with STM32 or clone chips, LPC chips and others it is usual that these need an initial Klipper flash via SD card. When flashing with this method, it is important to make sure that the print board is not connected with USB to the host, due to some boards being able to feed power back to the board and stopping a flash from occuring. For common micro-controllers using Atmega chips, for example the 2560, the code can be flashed with something similar to: sudo service klipper stop make flash FLASH_DEVICE=/dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 sudo service klipper start Assicurati di mettere al posto di FLASH_DEVICE il nome della porta seriale associato alla stampante. For common micro-controllers using RP2040 chips, the code can be flashed with something similar to: sudo service klipper stop make flash FLASH_DEVICE=first sudo service klipper start It is important to note that RP2040 chips may need to be put into Boot mode before this operation. Configurare Klipper \u00b6 The next step is to copy the printer configuration file to the host. Arguably the easiest way to set the Klipper configuration file is using the built in editors in Mainsail or Fluidd. These will allow the user to open the configuration examples and save them to be printer.cfg. Another option is to use a desktop editor that supports editing files over the \"scp\" and/or \"sftp\" protocols. There are freely available tools that support this (eg, Notepad++, WinSCP, and Cyberduck). Load the printer config file in the editor and then save it as a file named \"printer.cfg\" in the home directory of the pi user (ie, /home/pi/printer.cfg). Alternatively, one can also copy and edit the file directly on the host via ssh. That may look something like the following (be sure to update the command to use the appropriate printer config filename): cp ~/klipper/config/example-cartesian.cfg ~/printer.cfg nano ~/printer.cfg \u00c8 comune che ogni stampante abbia il proprio nome univoco per il microcontrollore. Il nome potrebbe cambiare dopo aver eseguito il flashing di Klipper, quindi ripeti questi passaggi anche se erano gi\u00e0 stati eseguiti durante il flashing. Eseguire: ls /dev/serial/by-id/* Dovrebbe venire riportato qualcosa di simile a questo: /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 Quindi aggiorna il file di configurazione con il nome univoco. Ad esempio, aggiorna la sezione [mcu] in modo che assomigli a qualcosa di simile a: [mcu] serial: /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 After creating and editing the file it will be necessary to issue a \"restart\" command in the command console to load the config. A \"status\" command will report the printer is ready if the Klipper config file is successfully read and the micro-controller is successfully found and configured. Quando si personalizza il file di configurazione della stampante, non \u00e8 raro che Klipper segnali un errore di configurazione. Se si verifica un errore, apportare le correzioni necessarie al file di configurazione della stampante ed eseguire il \"restart\" finch\u00e9 \"status\" non segnala che la stampante \u00e8 pronta. Klipper reports error messages via the command console and via pop up in Fluidd and Mainsail. The \"status\" command can be used to re-report error messages. A log is available and usually located in ~/printer_data/logs this is named klippy.log Dopo che Klipper ha segnalato che la stampante \u00e8 pronta, vai al config check document per eseguire alcuni controlli di base sulle definizioni nel file di configurazione. Vedere i documentation reference per altre informazioni.","title":"Installazione"},{"location":"Installation.html#installazione","text":"These instructions assume the software will run on a linux based host running a Klipper compatible front end. It is recommended that a SBC(Small Board Computer) such as a Raspberry Pi or Debian based Linux device be used as the host machine (see the FAQ for other options). For the purposes of these instructions host relates to the Linux device and mcu relates to the printboard. SBC relates to the term Small Board Computer such as the Raspberry Pi.","title":"Installazione"},{"location":"Installation.html#ottenere-un-file-di-configurazione-di-klipper","text":"Most Klipper settings are determined by a \"printer configuration file\" printer.cfg, that will be stored on the host. An appropriate configuration file can often be found by looking in the Klipper config directory for a file starting with a \"printer-\" prefix that corresponds to the target printer. The Klipper configuration file contains technical information about the printer that will be needed during the installation. Se non c'\u00e8 un file di configurazione della stampante appropriato nella directory di configurazione di Klipper, prova a cercare nel sito web del produttore della stampante per vedere se hanno un file di configurazione di Klipper appropriato. Se non \u00e8 possibile trovare alcun file di configurazione per la stampante, ma si conosce il tipo di scheda di controllo della stampante, cercare un file di configurazione appropriato che inizi con un prefisso \"generico-\". Questi file di esempio della scheda della stampante dovrebbero consentire di completare correttamente l'installazione iniziale, ma richiederanno alcune personalizzazioni per ottenere la funzionalit\u00e0 completa della stampante. \u00c8 anche possibile definire da zero una nuova configurazione della stampante. Tuttavia, ci\u00f2 richiede una conoscenza tecnica significativa sulla stampante e la sua elettronica. Si consiglia alla maggior parte degli utenti di iniziare con un file di configurazione appropriato. Se si crea un nuovo file di configurazione della stampante personalizzato, iniziare con l'esempio pi\u00f9 vicino file di configurazione e utilizzare Klipper riferimento alla configurazione per ulteriori informazioni.","title":"Ottenere un file di configurazione di Klipper"},{"location":"Installation.html#interacting-with-klipper","text":"Klipper is a 3d printer firmware, so it needs some way for the user to interact with it. Currently the best choices are front ends that retrieve information through the Moonraker web API and there is also the option to use Octoprint to control Klipper. The choice is up to the user on what to use, but the underlying Klipper is the same in all cases. We encourage users to research the options available and make an informed decision.","title":"Interacting with Klipper"},{"location":"Installation.html#obtaining-an-os-image-for-sbcs","text":"There are many ways to obtain an OS image for Klipper for SBC use, most depend on what front end you wish to use. Some manafactures of these SBC boards also provide their own Klipper-centric images. The two main Moonraker based front ends are Fluidd and Mainsail , the latter of which has a premade install image \"MainsailOS\" , this has the option for Raspberry Pi and some OrangePi varianta. Fluidd can be installed via KIAUH(Klipper Install And Update Helper), which is explained below and is a 3rd party installer for all things Klipper. OctoPrint can be installed via the popular OctoPi image or via KIAUH, this process is explained in","title":"Obtaining an OS image for SBC's"},{"location":"Installation.html#installing-via-kiauh","text":"Normally you would start with a base image for your SBC, RPiOS Lite for example, or in the case of a x86 Linux device, Ubuntu Server. Please note that Desktop variants are not recommended due to certain helper programs that can stop some Klipper functions working and even mask access to some print boards. KIAUH can be used to install Klipper and its associated programs on a variety of Linux based systems that run a form of Debian. More information can be found at https://github.com/dw-0/kiauh","title":"Installing via KIAUH"},{"location":"Installation.html#compilare-il-firmware-e-flashare-il-microcontrollore","text":"To compile the micro-controller code, start by running these commands on your host device: cd ~/klipper/ make menuconfig I commenti nella parte superiore del file di configurazione della stampante dovrebbero descrivere le impostazioni che devono essere impostate durante \"make menuconfig\". Apri il file in un browser web o in un editor di testo e cerca queste istruzioni nella parte superiore del file. Una volta configurate le impostazioni \"menuconfig\" appropriate, premere \"Q\" per uscire, quindi \"Y\" per salvare. Quindi esegui: make Se i commenti nella parte superiore del file di configurazione della stampante descrivono i passaggi personalizzati per il \"flash\" dell'immagine finale sulla scheda di controllo della stampante, segui questi passaggi e poi procedi con configurazione OctoPrint . In caso contrario, i seguenti passaggi vengono spesso utilizzati per eseguire il \"flash\" della scheda di controllo della stampante. Innanzitutto \u00e8 necessario determinare la porta seriale collegata al microcontrollore. Esegui quanto segue: ls /dev/serial/by-id/* Dovrebbe venire riportato qualcosa di simile a questo: /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 It's common for each printer to have its own unique serial port name. This unique name will be used when flashing the micro-controller. It's possible there may be multiple lines in the above output - if so, choose the line corresponding to the micro-controller. If many items are listed and the choice is ambiguous, unplug the board and run the command again, the missing item will be your print board(see the FAQ for more information). For common micro-controllers with STM32 or clone chips, LPC chips and others it is usual that these need an initial Klipper flash via SD card. When flashing with this method, it is important to make sure that the print board is not connected with USB to the host, due to some boards being able to feed power back to the board and stopping a flash from occuring. For common micro-controllers using Atmega chips, for example the 2560, the code can be flashed with something similar to: sudo service klipper stop make flash FLASH_DEVICE=/dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 sudo service klipper start Assicurati di mettere al posto di FLASH_DEVICE il nome della porta seriale associato alla stampante. For common micro-controllers using RP2040 chips, the code can be flashed with something similar to: sudo service klipper stop make flash FLASH_DEVICE=first sudo service klipper start It is important to note that RP2040 chips may need to be put into Boot mode before this operation.","title":"Compilare il firmware e flashare il microcontrollore"},{"location":"Installation.html#configurare-klipper","text":"The next step is to copy the printer configuration file to the host. Arguably the easiest way to set the Klipper configuration file is using the built in editors in Mainsail or Fluidd. These will allow the user to open the configuration examples and save them to be printer.cfg. Another option is to use a desktop editor that supports editing files over the \"scp\" and/or \"sftp\" protocols. There are freely available tools that support this (eg, Notepad++, WinSCP, and Cyberduck). Load the printer config file in the editor and then save it as a file named \"printer.cfg\" in the home directory of the pi user (ie, /home/pi/printer.cfg). Alternatively, one can also copy and edit the file directly on the host via ssh. That may look something like the following (be sure to update the command to use the appropriate printer config filename): cp ~/klipper/config/example-cartesian.cfg ~/printer.cfg nano ~/printer.cfg \u00c8 comune che ogni stampante abbia il proprio nome univoco per il microcontrollore. Il nome potrebbe cambiare dopo aver eseguito il flashing di Klipper, quindi ripeti questi passaggi anche se erano gi\u00e0 stati eseguiti durante il flashing. Eseguire: ls /dev/serial/by-id/* Dovrebbe venire riportato qualcosa di simile a questo: /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 Quindi aggiorna il file di configurazione con il nome univoco. Ad esempio, aggiorna la sezione [mcu] in modo che assomigli a qualcosa di simile a: [mcu] serial: /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 After creating and editing the file it will be necessary to issue a \"restart\" command in the command console to load the config. A \"status\" command will report the printer is ready if the Klipper config file is successfully read and the micro-controller is successfully found and configured. Quando si personalizza il file di configurazione della stampante, non \u00e8 raro che Klipper segnali un errore di configurazione. Se si verifica un errore, apportare le correzioni necessarie al file di configurazione della stampante ed eseguire il \"restart\" finch\u00e9 \"status\" non segnala che la stampante \u00e8 pronta. Klipper reports error messages via the command console and via pop up in Fluidd and Mainsail. The \"status\" command can be used to re-report error messages. A log is available and usually located in ~/printer_data/logs this is named klippy.log Dopo che Klipper ha segnalato che la stampante \u00e8 pronta, vai al config check document per eseguire alcuni controlli di base sulle definizioni nel file di configurazione. Vedere i documentation reference per altre informazioni.","title":"Configurare Klipper"},{"location":"Kinematics.html","text":"Cinematica \u00b6 Questo documento \u00e8 una panoramica su come Klipper implementa la movimentazione del sistema meccanico(la sua cinematica ). Questi contenuti potrebbero interessare sia gli sviluppatori che intendono lacorare sul software Klipper che gli utenti che desiderano comprendere meglio il funzionamento delle proprie macchine. Accelerazione \u00b6 Klipper utilizza uno schema ad accelerazione costrante ogni qualvolta la testa di stampa cambia velocit\u00e0 - la velocit\u00e0 viene gradualmente variata fino a raggiungere la nuova velocit\u00e0 invece di strattonare direttamente alla nuova velocit\u00e0. Klipper mantiene sempre l'accelerazione tra la testa di stampa e la stampa. Il filamento in uscita dall'ugello pu\u00f2 essere piuttosto fragile, rapidi sobbalzi e/o cambi di flusso di estrusione portano a cattiva qualit\u00e0 di stampa e bassa adesione al piano di stampa. Anche quando non viene estruso filamento, se l'ugello si trova allo stesso livello della stampa, un repentino cambio di velocit\u00e0 potrebbe disturbare il filamento appena depositato. Limitare i cambi di velocit\u00e0 della testa di stampa relativamente alla stampa riduce il rischio di rovinare la stampa. \u00c8 anche importante limitare l'accelerazione in modo da evitare che i motori stepper perdano passi e per ridurre le sollecitazioni alla macchina. Klipper limita la coppia su ciascuno stepper mediante la limitazione dell'accelerazione sulla testina di stampa. Imporre l'accelerazione alla testa di stampa ha la conseguenza naturale di limitare la coppia degli stepper che la muovono (l'inverso non \u00e8 sempre vero). Klipper implementa l'accelerazione costante. La formula chiave per l'accelerazione costante \u00e8: velocit\u00e0(tempo) = velocit\u00e0_inizio + accelerazione*tempo Generatore di trapezoide \u00b6 Klipper utilizza un \"generatore di trapezoide\" di tipo tradizionale per modellare il movimento - ogni movimento ha una velocit\u00e0 iniziale, accelera verso la velocit\u00e0 di crociera ad accelerazione costante, prosegue a velocit\u00e0 costante ed infine decelera fino alla velocit\u00e0 finale ad accelerazione costante. Viene detto \"generatore di trapezoide\" perch\u00e9 il diagramma di velocit\u00e0 del movimento sembra un trapezoide. La velocit\u00e0 di crociera \u00e8 sempre maggiore o uguale sia alla velocit\u00e0 iniziale che a quella finale. La fase di accelerazione potrebbe avere durata zero (se la velocit\u00e0 iniziale \u00e8 uguale alla velocit\u00e0 di crociera), la fase di movimento a valocit\u00e0 costante potrebbe avere durata zero (se il movimento inizia a decelerare subito l'accelerazione) e/o la fase di decelerazione potrebbe avere durata zero (se la velocit\u00e0 finale \u00e8 uguale alla velocit\u00e0 di crociera). Look-ahead (Precalcolo) \u00b6 Il sistema di \"look-ahead\" (precalcolo) \u00e8 usato per determinare le velocit\u00e0 nelle giunzioni tra movimenti (cornering speed). Consideriamo questi due movimenti sul piano XY: Nella situazione sopra descritta \u00e8 possibile decelerare completamente dopo il primo movimento e poi accelerare all'inizio del movimento successivo; per\u00f2 questo non \u00e8 un comportamento ideale dato che continue accelerazioni e decelerazioni aumentano il tempo di stampa e continue variazioni nel flusso dell'estrusore peggiorano la qualit\u00e0 di stampa. Per risolvere questo problema, la funzione \"look-ahead\" (precalcolo) accoda i movimenti da eseguire ed analizza gli angoli tra essi per calcolare la velocit\u00e0 da usare nella giunzione tra due movimenti. Se il prossimo movimento \u00e8 all'incirca nella stessa direzione del precedente, la testina di stampa deve rallentare molto poco (se non per nulla). Se per\u00f2 il prossimo movimento forma un angolo acuto (la testina deve praticamente invertire la direzione di marcia), la velocit\u00e0 alla giunzione sar\u00e0 piccola. Le velocit\u00e0 di giunzione sono determinate utilizzando \"accelerazione centripeta approssimata\". Meglio su descritto dall'autore . Tuttavia, in Klipper, le velocit\u00e0 di giunzione sono configurate specificando la velocit\u00e0 desiderata che dovrebbe avere un angolo di 90\u00b0 (la \"velocit\u00e0 dell'angolo retto\") e da quella vengono derivate le velocit\u00e0 di giunzione per altri angoli. Formula chiave per il look-ahead: velocit\u00e0_finale^2 = velocit\u00e0_iniziale^2 + 2*accelerazione*distanza_movimento Minimum cruise ratio \u00b6 Klipper implementa anche un meccanismo per smussare i movimenti di brevi movimenti a \"zigzag\". Considera i seguenti movimenti: In the above, the frequent changes from acceleration to deceleration can cause the machine to vibrate which causes stress on the machine and increases the noise. Klipper implements a mechanism to ensure there is always some movement at a cruising speed between acceleration and deceleration. This is done by reducing the top speed of some moves (or sequence of moves) to ensure there is a minimum distance traveled at cruising speed relative to the distance traveled during acceleration and deceleration. Klipper implements this feature by tracking both a regular move acceleration as well as a virtual \"acceleration to deceleration\" rate: Specifically, the code calculates what the velocity of each move would be if it were limited to this virtual \"acceleration to deceleration\" rate. In the above picture the dashed gray lines represent this virtual acceleration rate for the first move. If a move can not reach its full cruising speed using this virtual acceleration rate then its top speed is reduced to the maximum speed it could obtain at this virtual acceleration rate. For most moves the limit will be at or above the move's existing limits and no change in behavior is induced. For short zigzag moves, however, this limit reduces the top speed. Note that it does not change the actual acceleration within the move - the move continues to use the normal acceleration scheme up to its adjusted top-speed. Generazione di passi \u00b6 Una volta completato il processo di look-ahead, il movimento della testina di stampa per il dato spostamento \u00e8 completamente noto (tempo, posizione iniziale, posizione finale, velocit\u00e0 in ogni punto) ed \u00e8 possibile generare i tempi di passaggio per lo spostamento. Questo processo viene eseguito all'interno di \"classi cinematiche\" nel codice di Klipper. Al di fuori di queste classi cinematiche, tutto viene tracciato in millimetri, secondi e nello spazio delle coordinate cartesiane. \u00c8 compito delle classi cinematiche convertire da questo sistema di coordinate generico alle specifiche hardware di una particolare stampante. Klipper utilizza un risolutore iterativo per generare i tempi dei passo per ogni stepper. Il codice contiene le formule per calcolare le coordinate cartesiane ideali della testa in ogni momento e ha le formule cinematiche per calcolare le posizioni ideali dello stepper in base a quelle coordinate cartesiane. Con queste formule, Klipper pu\u00f2 determinare il tempo ideale in cui lo stepper dovrebbe trovarsi in ogni posizione del passo. I passaggi indicati vengono quindi programmati in questi orari calcolati. La formula chiave per determinare la distanza che un movimento deve percorrere con un'accelerazione costante \u00e8: distanza_movimento = (velocita_iniziale + .5 * accelerazione *durata_movimento) * durata_movimento e la formula chiave per il movimento a velocit\u00e0 costante \u00e8: distanza_movimento = velocit\u00e0_crociera * durata_movimento Le formule chiave per determinare la coordinata cartesiana di un movimento data una distanza di movimento sono: cartesian_x_position = start_x + move_distance * total_x_movement / total_movement cartesian_y_position = start_y + move_distance * total_y_movement / total_movement cartesian_z_position = start_z + move_distance * total_z_movement / total_movement Robot Cartesiani \u00b6 La generazione di passaggi per stampanti cartesiane \u00e8 il caso pi\u00f9 semplice. Il movimento su ciascun asse \u00e8 direttamente correlato al movimento nello spazio cartesiano. Formule chiave: stepper_x_position = cartesian_x_position stepper_y_position = cartesian_y_position stepper_z_position = cartesian_z_position Robot CoreXY \u00b6 La generazione di passaggi su una macchina CoreXY \u00e8 solo un po' pi\u00f9 complessa dei robot cartesiani di base. Le formule chiave sono: stepper_a_position = cartesian_x_position + cartesian_y_position stepper_b_position = cartesian_x_position - cartesian_y_position stepper_z_position = cartesian_z_position Robot Delta \u00b6 La generazione di passi su un robot delta si basa sul teorema di Pitagora: stepper_position = (sqrt(arm_length^2 - (cartesian_x_position - tower_x_position)^2 - (cartesian_y_position - tower_y_position)^2) + cartesian_z_position) Limiti di accelerazione del motore passo-passo \u00b6 Con la cinematica delta \u00e8 possibile che un movimento che sta accelerando nello spazio cartesiano richieda un'accelerazione su un particolare motore passo-passo maggiore dell'accelerazione del movimento. Ci\u00f2 pu\u00f2 verificarsi quando un braccio dello stepper \u00e8 pi\u00f9 orizzontale che verticale e la linea di movimento passa vicino alla torre dello stepper. Sebbene questi movimenti possano richiedere un'accelerazione del motore passo-passo maggiore dell'accelerazione di movimento massima configurata della stampante, la massa effettiva spostata da quel passo-passo sarebbe inferiore. Pertanto la maggiore accelerazione stepper non si traduce in una coppia stepper significativamente pi\u00f9 elevata ed \u00e8 quindi considerata innocua. Tuttavia, per evitare casi estremi, Klipper impone un limite massimo all'accelerazione stepper di tre volte l'accelerazione di movimento massima configurata della stampante. (Allo stesso modo, la velocit\u00e0 massima dello stepper \u00e8 limitata a tre volte la velocit\u00e0 massima di spostamento.) Per far rispettare questo limite, i movimenti sul bordo estremo dell'inviluppo (dove un braccio dello stepper pu\u00f2 essere quasi orizzontale) avranno un massima accelerazione e velocit\u00e0. Cinematica dell'estrusore \u00b6 Klipper implementa il movimento dell'estrusore nella propria classe cinematica. Poich\u00e9 i tempi e la velocit\u00e0 di ogni movimento della testina di stampa sono completamente noti per ogni movimento, \u00e8 possibile calcolare i tempi di passaggio per l'estrusore indipendentemente dai calcoli del tempo di passaggio del movimento della testina di stampa. Il movimento di base dell'estrusore \u00e8 semplice da calcolare. La generazione del tempo di passaggio utilizza le stesse formule utilizzate dai robot cartesiani: stepper_position = requested_e_position Anticipo di pressione \u00b6 La sperimentazione ha dimostrato che \u00e8 possibile migliorare la modellazione dell'estrusore oltre la formula di base dell'estrusore. Nel caso ideale, mentre un movimento di estrusione avanza, lo stesso volume di filamento dovrebbe essere depositato in ogni punto lungo il movimento e non dovrebbe esserci volume estruso dopo il movimento. Sfortunatamente, \u00e8 comune scoprire che le formule di estrusione di base fanno s\u00ec che una quantit\u00e0 insufficiente di filamento fuoriesca dall'estrusore all'inizio dei movimenti di estrusione e che il filamento in eccesso venga estruso al termine dell'estrusione. Questo \u00e8 spesso indicato come \"melma\" \"ooze\". Il sistema di \"pressure advance\" tenta di spiegare ci\u00f2 utilizzando un modello diverso per l'estrusore. Invece di credere ingenuamente che ogni mm^3 di filamento alimentato nell'estrusore comporter\u00e0 l'uscita immediata di quella quantit\u00e0 di mm^3 dall'estrusore, utilizza un modello basato sulla pressione. La pressione aumenta quando il filamento viene spinto nell'estrusore (come in Legge di Hook ) e la pressione necessaria per estrudere \u00e8 dominata dalla portata attraverso l'orifizio dell'ugello (come nella legge di Poiseuille ). L'idea chiave \u00e8 che la relazione tra filamento, pressione e portata pu\u00f2 essere modellata utilizzando un coefficiente lineare: pa_position = nominal_position + pressure_advance_coefficient * nominal_velocity Per informazioni su come trovare questo coefficiente di anticipo della pressione, vedere il documento Pressure Advance . La formula di base del pressure advance pu\u00f2 far s\u00ec che il motore dell'estrusore apporti improvvisi cambiamenti di velocit\u00e0. Klipper implementa la \"smussatura\" del movimento dell'estrusore per evitarlo. Il grafico sopra mostra un esempio di due movimenti di estrusione con una velocit\u00e0 in curva diversa da zero tra di loro. Si noti che il sistema di pressure advance fa s\u00ec che il filamento aggiuntivo venga spinto nell'estrusore durante l'accelerazione. Maggiore \u00e8 la portata del filamento desiderata, pi\u00f9 filamento deve essere spinto durante l'accelerazione per tenere conto della pressione. Durante la decelerazione della testa il filamento extra viene retratto (l'estrusore avr\u00e0 una velocit\u00e0 negativa). Lo \"smussamento\" viene implementato utilizzando una media pesata della posizione dell'estrusore in un breve periodo di tempo (come specificato dal parametro di configurazione pressure_advance_smooth_time ). Questa media pu\u00f2 estendersi su pi\u00f9 mosse del codice G. Notare come il motore dell'estrusore inizier\u00e0 a muoversi prima dell'inizio nominale del primo movimento di estrusione e continuer\u00e0 a muoversi dopo la fine nominale dell'ultimo movimento di estrusione. Formula chiave per \"smoothed pressure advance\": smooth_pa_position(t) = ( definitive_integral(pa_position(x) * (smooth_time/2 - abs(t - x)) * dx, from=t-smooth_time/2, to=t+smooth_time/2) / (smooth_time/2)^2 )","title":"Cinematica"},{"location":"Kinematics.html#cinematica","text":"Questo documento \u00e8 una panoramica su come Klipper implementa la movimentazione del sistema meccanico(la sua cinematica ). Questi contenuti potrebbero interessare sia gli sviluppatori che intendono lacorare sul software Klipper che gli utenti che desiderano comprendere meglio il funzionamento delle proprie macchine.","title":"Cinematica"},{"location":"Kinematics.html#accelerazione","text":"Klipper utilizza uno schema ad accelerazione costrante ogni qualvolta la testa di stampa cambia velocit\u00e0 - la velocit\u00e0 viene gradualmente variata fino a raggiungere la nuova velocit\u00e0 invece di strattonare direttamente alla nuova velocit\u00e0. Klipper mantiene sempre l'accelerazione tra la testa di stampa e la stampa. Il filamento in uscita dall'ugello pu\u00f2 essere piuttosto fragile, rapidi sobbalzi e/o cambi di flusso di estrusione portano a cattiva qualit\u00e0 di stampa e bassa adesione al piano di stampa. Anche quando non viene estruso filamento, se l'ugello si trova allo stesso livello della stampa, un repentino cambio di velocit\u00e0 potrebbe disturbare il filamento appena depositato. Limitare i cambi di velocit\u00e0 della testa di stampa relativamente alla stampa riduce il rischio di rovinare la stampa. \u00c8 anche importante limitare l'accelerazione in modo da evitare che i motori stepper perdano passi e per ridurre le sollecitazioni alla macchina. Klipper limita la coppia su ciascuno stepper mediante la limitazione dell'accelerazione sulla testina di stampa. Imporre l'accelerazione alla testa di stampa ha la conseguenza naturale di limitare la coppia degli stepper che la muovono (l'inverso non \u00e8 sempre vero). Klipper implementa l'accelerazione costante. La formula chiave per l'accelerazione costante \u00e8: velocit\u00e0(tempo) = velocit\u00e0_inizio + accelerazione*tempo","title":"Accelerazione"},{"location":"Kinematics.html#generatore-di-trapezoide","text":"Klipper utilizza un \"generatore di trapezoide\" di tipo tradizionale per modellare il movimento - ogni movimento ha una velocit\u00e0 iniziale, accelera verso la velocit\u00e0 di crociera ad accelerazione costante, prosegue a velocit\u00e0 costante ed infine decelera fino alla velocit\u00e0 finale ad accelerazione costante. Viene detto \"generatore di trapezoide\" perch\u00e9 il diagramma di velocit\u00e0 del movimento sembra un trapezoide. La velocit\u00e0 di crociera \u00e8 sempre maggiore o uguale sia alla velocit\u00e0 iniziale che a quella finale. La fase di accelerazione potrebbe avere durata zero (se la velocit\u00e0 iniziale \u00e8 uguale alla velocit\u00e0 di crociera), la fase di movimento a valocit\u00e0 costante potrebbe avere durata zero (se il movimento inizia a decelerare subito l'accelerazione) e/o la fase di decelerazione potrebbe avere durata zero (se la velocit\u00e0 finale \u00e8 uguale alla velocit\u00e0 di crociera).","title":"Generatore di trapezoide"},{"location":"Kinematics.html#look-ahead-precalcolo","text":"Il sistema di \"look-ahead\" (precalcolo) \u00e8 usato per determinare le velocit\u00e0 nelle giunzioni tra movimenti (cornering speed). Consideriamo questi due movimenti sul piano XY: Nella situazione sopra descritta \u00e8 possibile decelerare completamente dopo il primo movimento e poi accelerare all'inizio del movimento successivo; per\u00f2 questo non \u00e8 un comportamento ideale dato che continue accelerazioni e decelerazioni aumentano il tempo di stampa e continue variazioni nel flusso dell'estrusore peggiorano la qualit\u00e0 di stampa. Per risolvere questo problema, la funzione \"look-ahead\" (precalcolo) accoda i movimenti da eseguire ed analizza gli angoli tra essi per calcolare la velocit\u00e0 da usare nella giunzione tra due movimenti. Se il prossimo movimento \u00e8 all'incirca nella stessa direzione del precedente, la testina di stampa deve rallentare molto poco (se non per nulla). Se per\u00f2 il prossimo movimento forma un angolo acuto (la testina deve praticamente invertire la direzione di marcia), la velocit\u00e0 alla giunzione sar\u00e0 piccola. Le velocit\u00e0 di giunzione sono determinate utilizzando \"accelerazione centripeta approssimata\". Meglio su descritto dall'autore . Tuttavia, in Klipper, le velocit\u00e0 di giunzione sono configurate specificando la velocit\u00e0 desiderata che dovrebbe avere un angolo di 90\u00b0 (la \"velocit\u00e0 dell'angolo retto\") e da quella vengono derivate le velocit\u00e0 di giunzione per altri angoli. Formula chiave per il look-ahead: velocit\u00e0_finale^2 = velocit\u00e0_iniziale^2 + 2*accelerazione*distanza_movimento","title":"Look-ahead (Precalcolo)"},{"location":"Kinematics.html#minimum-cruise-ratio","text":"Klipper implementa anche un meccanismo per smussare i movimenti di brevi movimenti a \"zigzag\". Considera i seguenti movimenti: In the above, the frequent changes from acceleration to deceleration can cause the machine to vibrate which causes stress on the machine and increases the noise. Klipper implements a mechanism to ensure there is always some movement at a cruising speed between acceleration and deceleration. This is done by reducing the top speed of some moves (or sequence of moves) to ensure there is a minimum distance traveled at cruising speed relative to the distance traveled during acceleration and deceleration. Klipper implements this feature by tracking both a regular move acceleration as well as a virtual \"acceleration to deceleration\" rate: Specifically, the code calculates what the velocity of each move would be if it were limited to this virtual \"acceleration to deceleration\" rate. In the above picture the dashed gray lines represent this virtual acceleration rate for the first move. If a move can not reach its full cruising speed using this virtual acceleration rate then its top speed is reduced to the maximum speed it could obtain at this virtual acceleration rate. For most moves the limit will be at or above the move's existing limits and no change in behavior is induced. For short zigzag moves, however, this limit reduces the top speed. Note that it does not change the actual acceleration within the move - the move continues to use the normal acceleration scheme up to its adjusted top-speed.","title":"Minimum cruise ratio"},{"location":"Kinematics.html#generazione-di-passi","text":"Una volta completato il processo di look-ahead, il movimento della testina di stampa per il dato spostamento \u00e8 completamente noto (tempo, posizione iniziale, posizione finale, velocit\u00e0 in ogni punto) ed \u00e8 possibile generare i tempi di passaggio per lo spostamento. Questo processo viene eseguito all'interno di \"classi cinematiche\" nel codice di Klipper. Al di fuori di queste classi cinematiche, tutto viene tracciato in millimetri, secondi e nello spazio delle coordinate cartesiane. \u00c8 compito delle classi cinematiche convertire da questo sistema di coordinate generico alle specifiche hardware di una particolare stampante. Klipper utilizza un risolutore iterativo per generare i tempi dei passo per ogni stepper. Il codice contiene le formule per calcolare le coordinate cartesiane ideali della testa in ogni momento e ha le formule cinematiche per calcolare le posizioni ideali dello stepper in base a quelle coordinate cartesiane. Con queste formule, Klipper pu\u00f2 determinare il tempo ideale in cui lo stepper dovrebbe trovarsi in ogni posizione del passo. I passaggi indicati vengono quindi programmati in questi orari calcolati. La formula chiave per determinare la distanza che un movimento deve percorrere con un'accelerazione costante \u00e8: distanza_movimento = (velocita_iniziale + .5 * accelerazione *durata_movimento) * durata_movimento e la formula chiave per il movimento a velocit\u00e0 costante \u00e8: distanza_movimento = velocit\u00e0_crociera * durata_movimento Le formule chiave per determinare la coordinata cartesiana di un movimento data una distanza di movimento sono: cartesian_x_position = start_x + move_distance * total_x_movement / total_movement cartesian_y_position = start_y + move_distance * total_y_movement / total_movement cartesian_z_position = start_z + move_distance * total_z_movement / total_movement","title":"Generazione di passi"},{"location":"Kinematics.html#robot-cartesiani","text":"La generazione di passaggi per stampanti cartesiane \u00e8 il caso pi\u00f9 semplice. Il movimento su ciascun asse \u00e8 direttamente correlato al movimento nello spazio cartesiano. Formule chiave: stepper_x_position = cartesian_x_position stepper_y_position = cartesian_y_position stepper_z_position = cartesian_z_position","title":"Robot Cartesiani"},{"location":"Kinematics.html#robot-corexy","text":"La generazione di passaggi su una macchina CoreXY \u00e8 solo un po' pi\u00f9 complessa dei robot cartesiani di base. Le formule chiave sono: stepper_a_position = cartesian_x_position + cartesian_y_position stepper_b_position = cartesian_x_position - cartesian_y_position stepper_z_position = cartesian_z_position","title":"Robot CoreXY"},{"location":"Kinematics.html#robot-delta","text":"La generazione di passi su un robot delta si basa sul teorema di Pitagora: stepper_position = (sqrt(arm_length^2 - (cartesian_x_position - tower_x_position)^2 - (cartesian_y_position - tower_y_position)^2) + cartesian_z_position)","title":"Robot Delta"},{"location":"Kinematics.html#limiti-di-accelerazione-del-motore-passo-passo","text":"Con la cinematica delta \u00e8 possibile che un movimento che sta accelerando nello spazio cartesiano richieda un'accelerazione su un particolare motore passo-passo maggiore dell'accelerazione del movimento. Ci\u00f2 pu\u00f2 verificarsi quando un braccio dello stepper \u00e8 pi\u00f9 orizzontale che verticale e la linea di movimento passa vicino alla torre dello stepper. Sebbene questi movimenti possano richiedere un'accelerazione del motore passo-passo maggiore dell'accelerazione di movimento massima configurata della stampante, la massa effettiva spostata da quel passo-passo sarebbe inferiore. Pertanto la maggiore accelerazione stepper non si traduce in una coppia stepper significativamente pi\u00f9 elevata ed \u00e8 quindi considerata innocua. Tuttavia, per evitare casi estremi, Klipper impone un limite massimo all'accelerazione stepper di tre volte l'accelerazione di movimento massima configurata della stampante. (Allo stesso modo, la velocit\u00e0 massima dello stepper \u00e8 limitata a tre volte la velocit\u00e0 massima di spostamento.) Per far rispettare questo limite, i movimenti sul bordo estremo dell'inviluppo (dove un braccio dello stepper pu\u00f2 essere quasi orizzontale) avranno un massima accelerazione e velocit\u00e0.","title":"Limiti di accelerazione del motore passo-passo"},{"location":"Kinematics.html#cinematica-dellestrusore","text":"Klipper implementa il movimento dell'estrusore nella propria classe cinematica. Poich\u00e9 i tempi e la velocit\u00e0 di ogni movimento della testina di stampa sono completamente noti per ogni movimento, \u00e8 possibile calcolare i tempi di passaggio per l'estrusore indipendentemente dai calcoli del tempo di passaggio del movimento della testina di stampa. Il movimento di base dell'estrusore \u00e8 semplice da calcolare. La generazione del tempo di passaggio utilizza le stesse formule utilizzate dai robot cartesiani: stepper_position = requested_e_position","title":"Cinematica dell'estrusore"},{"location":"Kinematics.html#anticipo-di-pressione","text":"La sperimentazione ha dimostrato che \u00e8 possibile migliorare la modellazione dell'estrusore oltre la formula di base dell'estrusore. Nel caso ideale, mentre un movimento di estrusione avanza, lo stesso volume di filamento dovrebbe essere depositato in ogni punto lungo il movimento e non dovrebbe esserci volume estruso dopo il movimento. Sfortunatamente, \u00e8 comune scoprire che le formule di estrusione di base fanno s\u00ec che una quantit\u00e0 insufficiente di filamento fuoriesca dall'estrusore all'inizio dei movimenti di estrusione e che il filamento in eccesso venga estruso al termine dell'estrusione. Questo \u00e8 spesso indicato come \"melma\" \"ooze\". Il sistema di \"pressure advance\" tenta di spiegare ci\u00f2 utilizzando un modello diverso per l'estrusore. Invece di credere ingenuamente che ogni mm^3 di filamento alimentato nell'estrusore comporter\u00e0 l'uscita immediata di quella quantit\u00e0 di mm^3 dall'estrusore, utilizza un modello basato sulla pressione. La pressione aumenta quando il filamento viene spinto nell'estrusore (come in Legge di Hook ) e la pressione necessaria per estrudere \u00e8 dominata dalla portata attraverso l'orifizio dell'ugello (come nella legge di Poiseuille ). L'idea chiave \u00e8 che la relazione tra filamento, pressione e portata pu\u00f2 essere modellata utilizzando un coefficiente lineare: pa_position = nominal_position + pressure_advance_coefficient * nominal_velocity Per informazioni su come trovare questo coefficiente di anticipo della pressione, vedere il documento Pressure Advance . La formula di base del pressure advance pu\u00f2 far s\u00ec che il motore dell'estrusore apporti improvvisi cambiamenti di velocit\u00e0. Klipper implementa la \"smussatura\" del movimento dell'estrusore per evitarlo. Il grafico sopra mostra un esempio di due movimenti di estrusione con una velocit\u00e0 in curva diversa da zero tra di loro. Si noti che il sistema di pressure advance fa s\u00ec che il filamento aggiuntivo venga spinto nell'estrusore durante l'accelerazione. Maggiore \u00e8 la portata del filamento desiderata, pi\u00f9 filamento deve essere spinto durante l'accelerazione per tenere conto della pressione. Durante la decelerazione della testa il filamento extra viene retratto (l'estrusore avr\u00e0 una velocit\u00e0 negativa). Lo \"smussamento\" viene implementato utilizzando una media pesata della posizione dell'estrusore in un breve periodo di tempo (come specificato dal parametro di configurazione pressure_advance_smooth_time ). Questa media pu\u00f2 estendersi su pi\u00f9 mosse del codice G. Notare come il motore dell'estrusore inizier\u00e0 a muoversi prima dell'inizio nominale del primo movimento di estrusione e continuer\u00e0 a muoversi dopo la fine nominale dell'ultimo movimento di estrusione. Formula chiave per \"smoothed pressure advance\": smooth_pa_position(t) = ( definitive_integral(pa_position(x) * (smooth_time/2 - abs(t - x)) * dx, from=t-smooth_time/2, to=t+smooth_time/2) / (smooth_time/2)^2 )","title":"Anticipo di pressione"},{"location":"MCU_Commands.html","text":"Comandi MCU \u00b6 Questo documento fornisce informazioni sui comandi di basso livello del microcontrollore che sono inviati dal software \"host\" Klipper e processati dal software del microcontrollore Klipper. Questo documento non \u00e8 un riferimento autorevole per questi comandi, n\u00e9 una lista esclusiva di tutti i comandi disponibili. Questo documento pu\u00f2 essere utile per gli sviluppatori interessati a comprendere i comandi di basso livello del microcontrollore. Vedere il documento protocol per ulteriori informazioni sul formato dei comandi e sulla loro trasmissione. I comandi qui sono descritti usando la loro sintassi di stile \"printf\" - per chi non ha familiarit\u00e0 con quel formato, basta notare che dove si vede una sequenza '%...' dovrebbe essere sostituita con un intero reale. Ad esempio, una descrizione con \"count=%c\" potrebbe essere sostituita con il testo \"count=10\". Si noti che i parametri considerati \"enumerazioni\" (vedere il documento di protocollo sopra) assumono un valore stringa che viene automaticamente convertito in un valore intero per il microcontrollore. Questo \u00e8 comune con i parametri denominati \"pin\" (o che hanno il suffisso \"_pin\"). Comandi di avvio \u00b6 Potrebbe essere necessario eseguire determinate azioni una tantum per configurare il microcontrollore e le sue periferiche. Questa sezione elenca i comandi comuni disponibili a tale scopo. A differenza della maggior parte dei comandi del microcontrollore, questi comandi vengono eseguiti non appena vengono ricevuti e non richiedono alcuna configurazione particolare. Comandi di avvio comuni: set_digital_out pin=%u value=%c : Questo comando configura immediatamente il pin dato come un GPIO di uscita digitale e lo imposta su un livello basso (valore=0) o alto (valore=1). Questo comando pu\u00f2 essere utile per configurare il valore iniziale dei LED e per configurare il valore iniziale dei pin micro-stepping del driver stepper. set_pwm_out pin=%u cycle_ticks=%u value=%hu : Questo comando configurer\u00e0 immediatamente il pin dato per utilizzare la modulazione di larghezza di impulso (PWM) basata sull'hardware con il numero specificato di cycle_tick. Il \"cycle_ticks\" \u00e8 il numero di tick di clock dell'MCU per cui ogni ciclo di accensione e spegnimento dovrebbe durare. \u00c8 possibile utilizzare un valore cycle_ticks pari a 1 per richiedere il tempo di ciclo pi\u00f9 rapido possibile. Il parametro \"value\" \u00e8 compreso tra 0 e 255 con 0 che indica uno stato completamente spento e 255 indica uno stato completamente acceso. Questo comando pu\u00f2 essere utile per abilitare le ventole di raffreddamento della CPU e degli ugelli. Configurazione di basso livello del microcontrollore \u00b6 La maggior parte dei comandi nel microcontrollore richiede una configurazione iniziale prima di poter essere richiamati correttamente. Questa sezione fornisce una panoramica del processo di configurazione. Questa sezione e le sezioni seguenti sono probabilmente di interesse solo per gli sviluppatori interessati ai dettagli interni di Klipper. Quando l'host si connette per la prima volta al microcontrollore, inizia sempre ottenendo un dizionario di dati (vedi protocol per ulteriori informazioni). Dopo aver ottenuto il dizionario dei dati, l'host verificher\u00e0 se il microcontrollore \u00e8 in uno stato \"configurato\" e in caso contrario lo configurer\u00e0. La configurazione prevede le seguenti fasi: get_config : L'host si avvia controllando se il microcontrollore \u00e8 gi\u00e0 configurato. Il microcontrollore risponde a questo comando con un messaggio di risposta \"config\". Il software del microcontrollore si avvia sempre in uno stato non configurato all'accensione. Rimane in questo stato fino a quando l'host non completa i processi di configurazione (emettendo un comando finalize_config). Se il microcontrollore \u00e8 gi\u00e0 configurato da una sessione precedente (ed \u00e8 configurato con le impostazioni desiderate), non sono necessarie ulteriori azioni da parte dell'host e il processo di configurazione termina correttamente. allocate_oids count=%c : Questo comando viene emesso per informare il microcontrollore del numero massimo di ID oggetto (oid) che l'host richiede. \u00c8 valido solo per emettere questo comando una volta. Un oid \u00e8 un identificatore intero allocato a ogni stepper, ogni endstop e ogni pin gpio schedulabile. L'host determina in anticipo il numero di oid necessari per far funzionare l'hardware e lo passa al microcontrollore in modo che possa allocare memoria sufficiente per memorizzare una mappatura dall'oid all'oggetto interno. config_XXX oid=%c ... : Per convenzione qualsiasi comando che inizia con il prefisso \"config_\" crea un nuovo oggetto microcontrollore e gli assegna l'oid dato. Ad esempio, il comando config_digital_out configurer\u00e0 il pin specificato come GPIO di output digitale e creer\u00e0 un oggetto interno che l'host pu\u00f2 utilizzare per pianificare le modifiche al GPIO specificato. Il parametro oid passato al comando config viene selezionato dall'host e deve essere compreso tra zero e il conteggio massimo fornito nel comando allocate_oids. I comandi di configurazione possono essere eseguiti solo quando il microcontrollore non \u00e8 in uno stato configurato (cio\u00e8 prima dell'invio da parte dell'host di finalize_config) e dopo che \u00e8 stato inviato il comando allocate_oids. finalize_config crc=%u : Il comando finalize_config trasferisce il microcontrollore da uno stato non configurato a uno stato configurato. Il parametro crc passato al microcontrollore viene archiviato e restituito all'host nei messaggi di risposta \"config\". Per convenzione, l'host prende un CRC a 32bit della configurazione che richieder\u00e0 e all'avvio delle successive sessioni di comunicazione verifica che il CRC memorizzato nel microcontrollore corrisponda esattamente al CRC desiderato. Se il CRC non corrisponde, l'host sa che il microcontrollore non \u00e8 stato configurato nello stato desiderato dall'host. Oggetti comuni del microcontrollore \u00b6 Questa sezione elenca alcuni comandi di configurazione comunemente usati. config_digital_out oid=%c pin=%u value=%c default_value=%c max_duration=%u : Questo comando crea un oggetto microcontrollore interno per il dato 'pin' GPIO. Il pin verr\u00e0 configurato in modalit\u00e0 di uscita digitale e impostato su un valore iniziale come specificato da 'value' (0 per basso, 1 per alto). La creazione di un oggetto digital_out consente all'host di pianificare gli aggiornamenti GPIO per il pin specificato a orari specificati (consultare il comando queue_digital_out descritto di seguito). Se il software del microcontrollore entra in modalit\u00e0 di spegnimento, tutti gli oggetti digital_out configurati verranno impostati su 'default_value'. Il parametro 'max_duration' viene utilizzato per implementare un controllo di sicurezza: se \u00e8 diverso da zero, \u00e8 il numero massimo di tick di clock che l'host pu\u00f2 impostare il GPIO specificato su un valore non predefinito senza ulteriori aggiornamenti. Ad esempio, se default_value \u00e8 zero e max_duration \u00e8 16000, se l'host imposta gpio su un valore di uno, deve pianificare un altro aggiornamento del pin gpio (su zero o su uno) entro 16000 tick di clock. Questa funzione di sicurezza pu\u00f2 essere utilizzata con i pin del riscaldatore per garantire che l'host non abiliti il riscaldatore e quindi vada offline. config_pwm_out oid=%c pin=%u cycle_ticks=%u value=%hu default_value=%hu max_duration=%u : Questo comando crea un oggetto interno per i pin PWM hardware per i quali l'host pu\u00f2 pianificare gli aggiornamenti. Il suo utilizzo \u00e8 analogo a config_digital_out - vedere la descrizione dei comandi 'set_pwm_out' e 'config_digital_out' per la descrizione dei parametri. config_analog_in oid=%c pin=%u : Questo comando viene utilizzato per configurare un pin nella modalit\u00e0 di campionamento analogico. Una volta configurato, il pin pu\u00f2 essere campionato a intervalli regolari utilizzando il comando query_analog_in (vedi sotto). config_stepper oid=%c step_pin=%c dir_pin=%c invert_step=%c step_pulse_ticks=%u : Questo comando crea un oggetto stepper interno. I parametri 'step_pin' e 'dir_pin' specificano rispettivamente i pin del passo e della direzione; questo comando li configurer\u00e0 in modalit\u00e0 uscita digitale. Il parametro 'invert_step' specifica se un passo si verifica su un fronte di salita (invert_step=0) o discendente (invert_step=1). Il parametro 'step_pulse_ticks' specifica la durata minima dell'impulso di passo. Se l'mcu esporta la costante 'STEPPER_BOTH_EDGE=1', l'impostazione di step_pulse_ticks=0 e invert_step=-1 imposter\u00e0 il passaggio su entrambi i fronti di salita e di discesa dello step pin. config_endstop oid=%c pin=%c pull_up=%c stepper_count=%c : Questo comando crea un oggetto \"finecorsa\" interno. Viene utilizzato per specificare i relativi pin e per abilitare le operazioni di \"homing\" (vedere il comando endstop_home di seguito). Il comando configurer\u00e0 il pin specificato nella modalit\u00e0 di input digitale. Il parametro 'pull_up' determina se i resistori pullup forniti dall'hardware per il pin (se disponibili) saranno abilitati. Il parametro 'stepper_count' specifica il numero massimo di stepper che potrebbe essere necessario arrestare questo endstop durante un'operazione di homing (vedere endstop_home di seguito). config_spi oid=%c bus=%u pin=%u mode=%u rate=%u shutdown_msg=%*s : Questo comando crea un oggetto SPI interno. Viene utilizzato con i comandi spi_transfer e spi_send (vedi sotto). Il \"bus\" identifica il bus SPI da utilizzare (se il microcontrollore ha pi\u00f9 di un bus SPI disponibile). Il \"pin\" specifica il pin di selezione del chip (CS) per il dispositivo. La \"modalit\u00e0\" \u00e8 la modalit\u00e0 SPI (dovrebbe essere compresa tra 0 e 3). Il parametro \"rate\" specifica la velocit\u00e0 del bus SPI (in cicli al secondo). Infine, \"shutdown_msg\" \u00e8 un comando SPI da inviare al dispositivo specificato se il microcontrollore entra in uno stato di spegnimento. config_spi_without_cs oid=%c bus=%u mode=%u rate=%u shutdown_msg=%*s : Questo comando \u00e8 simile a config_spi, ma senza una definizione di pin CS. \u00c8 utile per i dispositivi SPI che non dispongono di una linea di selezione del chip. Comandi comuni \u00b6 Questa sezione elenca alcuni comandi comunemente usati durante il run-time. \u00c8 probabilmente di interesse solo per gli sviluppatori che cercano di ottenere informazioni su Klipper. set_digital_out_pwm_cycle oid=%c cycle_ticks=%u : Questo comando configura un pin come uscita digitale (come creato da config_digital_out) per usare \"software PWM\". 'cycle_ticks' \u00e8 il numero di tick di clock per il ciclo PWM. Poich\u00e9 la commutazione dell'uscita \u00e8 implementata nel software del microcontrollore, si consiglia che 'cycle_ticks' corrisponda a un tempo di 10 ms o superiore. queue_digital_out oid=%c clock=%u on_ticks=%u : Questo comando pianificher\u00e0 una modifica a un pin GPIO dell'uscita digitale per un orario specifico. Per utilizzare questo comando \u00e8 necessario che durante la configurazione del microcontrollore sia stato emesso un comando 'config_digital_out' con lo stesso parametro 'oid'. Se \u00e8 stato chiamato 'set_digital_out_pwm_cycle', allora 'on_ticks' \u00e8 la durata di attivazione (in tick di clock) per il ciclo pwm. Altrimenti, 'on_ticks' dovrebbe essere 0 (per bassa tensione) o 1 (per alta tensione). queue_pwm_out oid=%c clock=%u value=%hu : Pianifica una modifica a un pin di uscita PWM hardware. Per ulteriori informazioni, vedere i comandi 'queue_digital_out' e 'config_pwm_out'. query_analog_in oid=%c clock=%u sample_ticks=%u sample_count=%c rest_ticks=%u min_value=%hu max_value=%hu : Questo comando imposta una pianificazione ricorrente di campionamenti di un ingresso analogico. Per utilizzare questo comando \u00e8 necessario che durante la configurazione del microcontrollore sia stato emesso un comando 'config_analog_in' con lo stesso parametro 'oid'. I campioni inizieranno a partire dall'ora 'clock', riporter\u00e0 sul valore ottenuto ogni tick di clock 'rest_ticks', sovracampioner\u00e0 il numero di 'sample_count' e metter\u00e0 in pausa il numero di tick di clock 'sample_ticks' tra i sovacampionamenti. I parametri 'min_value' e 'max_value' implementano una funzione di sicurezza: il software del microcontrollore verificher\u00e0 che il valore campionato (dopo qualsiasi sovracampionamento) sia sempre compreso nell'intervallo fornito. Questo \u00e8 destinato all'uso con pin collegati a termistori che controllano i riscaldatori: pu\u00f2 essere utilizzato per verificare che un riscaldatore rientri in un intervallo di temperatura. get_clock : Questo comando fa s\u00ec che il microcontrollore generi un messaggio di risposta \"clock\". L'host invia questo comando una volta al secondo per ottenere il valore dell'orologio del microcontrollore e per stimare la deriva tra gli orologi dell'host e del microcontrollore. Consente all'host di stimare con precisione l'orologio del microcontrollore. Comandi motori passopasso \u00b6 queue_step oid=%c interval=%u count=%hu add=%hi : Questo comando pianifica il 'conteggio' del numero di passi per il dato stepper, con 'intervallo' il numero di tick di clock tra ogni passo. Il primo passo sar\u00e0 il numero \"intervallo\" di tick di clock dall'ultimo passo programmato per il dato stepper. Se 'add' \u00e8 diverso da zero, l'intervallo verr\u00e0 regolato in base all'importo di 'add' dopo ogni passaggio. Questo comando aggiunge la sequenza intervallo/conteggio/aggiunta data a una coda per stepper. Potrebbero esserci centinaia di queste sequenze in coda durante il normale funzionamento. La nuova sequenza viene aggiunta alla fine della coda e quando ogni sequenza completa il suo numero di \"conteggi\" di passaggi viene estratta dalla parte anteriore della coda. Questo sistema consente al microcontrollore di mettere in coda potenzialmente centinaia di migliaia di passaggi, il tutto con tempi di pianificazione affidabili e prevedibili. set_next_step_dir oid=%c dir=%c : Questo comando specifica il valore del dir_pin che verr\u00e0 utilizzato dal comando queue_step successivo. reset_step_clock oid=%c clock=%u : Normalmente, la temporizzazione del passo \u00e8 relativo all'ultimo passo per un dato stepper. Questo comando azzera l'orologio in modo che il passo successivo sia relativo all'ora fornita. L'host di solito invia questo comando solo all'inizio di una stampa. stepper_get_position oid=%c : Questo comando fa s\u00ec che il microcontrollore generi un messaggio di risposta \"stepper_position\" con la posizione corrente dello stepper. La posizione \u00e8 il numero totale di passi generati con dir=1 meno il numero totale di passi generati con dir=0. endstop_home oid=%c clock=%u sample_ticks=%u sample_count=%c rest_ticks=%u pin_value=%c : Questo comando viene utilizzato durante le operazioni di \"homing\" dello stepper. Per utilizzare questo comando \u00e8 necessario che durante la configurazione del microcontrollore sia stato emesso un comando 'config_endstop' con lo stesso parametro 'oid'. Quando viene invocato questo comando, il microcontrollore campiona il pin finecorsa ogni tick di clock \"rest_ticks\" e controlla se ha un valore uguale a \"pin_value\". Se il valore corrisponde (e continua a corrispondere per 'sample_count' campioni aggiuntivi separati da 'sample_ticks'), la coda di movimento per lo stepper associato verr\u00e0 cancellata e lo stepper si arrester\u00e0 immediatamente. L'host utilizza questo comando per implementare l'homing: l'host indica al finecorsa di eseguire il campionamento per il trigger endstop e quindi emette una serie di comandi queue_step per spostare uno stepper verso il finecorsa. Una volta che lo stepper raggiunge il finecorsa, il trigger verr\u00e0 rilevato, il movimento verr\u00e0 interrotto e l'host verr\u00e0 informato. Coda movimento \u00b6 Ogni comando queue_step utilizza una voce nella \"coda di movimento\" del microcontrollore. Questa coda viene allocata quando riceve il comando \"finalize_config\" e segnala il numero di voci di coda disponibili nei messaggi di risposta \"config\". \u00c8 responsabilit\u00e0 dell'host assicurarsi che ci sia spazio disponibile nella coda prima di inviare un comando queue_step. L'host esegue questa operazione calcolando il completamento di ciascun comando queue_step e pianificando di conseguenza i nuovi comandi queue_step. Comandi SPI \u00b6 spi_transfer oid=%c data=%*s : questo comando fa s\u00ec che il microcontrollore invii dati 'data' al dispositivo spi specificato da 'oid' e genera un messaggio di risposta \"spi_transfer_response\" con i dati restituiti durante la trasmissione . spi_send oid=%c data=%*s : Questo comando \u00e8 simile a \"spi_transfer\", ma non genera un messaggio \"spi_transfer_response\".","title":"Comandi MCU"},{"location":"MCU_Commands.html#comandi-mcu","text":"Questo documento fornisce informazioni sui comandi di basso livello del microcontrollore che sono inviati dal software \"host\" Klipper e processati dal software del microcontrollore Klipper. Questo documento non \u00e8 un riferimento autorevole per questi comandi, n\u00e9 una lista esclusiva di tutti i comandi disponibili. Questo documento pu\u00f2 essere utile per gli sviluppatori interessati a comprendere i comandi di basso livello del microcontrollore. Vedere il documento protocol per ulteriori informazioni sul formato dei comandi e sulla loro trasmissione. I comandi qui sono descritti usando la loro sintassi di stile \"printf\" - per chi non ha familiarit\u00e0 con quel formato, basta notare che dove si vede una sequenza '%...' dovrebbe essere sostituita con un intero reale. Ad esempio, una descrizione con \"count=%c\" potrebbe essere sostituita con il testo \"count=10\". Si noti che i parametri considerati \"enumerazioni\" (vedere il documento di protocollo sopra) assumono un valore stringa che viene automaticamente convertito in un valore intero per il microcontrollore. Questo \u00e8 comune con i parametri denominati \"pin\" (o che hanno il suffisso \"_pin\").","title":"Comandi MCU"},{"location":"MCU_Commands.html#comandi-di-avvio","text":"Potrebbe essere necessario eseguire determinate azioni una tantum per configurare il microcontrollore e le sue periferiche. Questa sezione elenca i comandi comuni disponibili a tale scopo. A differenza della maggior parte dei comandi del microcontrollore, questi comandi vengono eseguiti non appena vengono ricevuti e non richiedono alcuna configurazione particolare. Comandi di avvio comuni: set_digital_out pin=%u value=%c : Questo comando configura immediatamente il pin dato come un GPIO di uscita digitale e lo imposta su un livello basso (valore=0) o alto (valore=1). Questo comando pu\u00f2 essere utile per configurare il valore iniziale dei LED e per configurare il valore iniziale dei pin micro-stepping del driver stepper. set_pwm_out pin=%u cycle_ticks=%u value=%hu : Questo comando configurer\u00e0 immediatamente il pin dato per utilizzare la modulazione di larghezza di impulso (PWM) basata sull'hardware con il numero specificato di cycle_tick. Il \"cycle_ticks\" \u00e8 il numero di tick di clock dell'MCU per cui ogni ciclo di accensione e spegnimento dovrebbe durare. \u00c8 possibile utilizzare un valore cycle_ticks pari a 1 per richiedere il tempo di ciclo pi\u00f9 rapido possibile. Il parametro \"value\" \u00e8 compreso tra 0 e 255 con 0 che indica uno stato completamente spento e 255 indica uno stato completamente acceso. Questo comando pu\u00f2 essere utile per abilitare le ventole di raffreddamento della CPU e degli ugelli.","title":"Comandi di avvio"},{"location":"MCU_Commands.html#configurazione-di-basso-livello-del-microcontrollore","text":"La maggior parte dei comandi nel microcontrollore richiede una configurazione iniziale prima di poter essere richiamati correttamente. Questa sezione fornisce una panoramica del processo di configurazione. Questa sezione e le sezioni seguenti sono probabilmente di interesse solo per gli sviluppatori interessati ai dettagli interni di Klipper. Quando l'host si connette per la prima volta al microcontrollore, inizia sempre ottenendo un dizionario di dati (vedi protocol per ulteriori informazioni). Dopo aver ottenuto il dizionario dei dati, l'host verificher\u00e0 se il microcontrollore \u00e8 in uno stato \"configurato\" e in caso contrario lo configurer\u00e0. La configurazione prevede le seguenti fasi: get_config : L'host si avvia controllando se il microcontrollore \u00e8 gi\u00e0 configurato. Il microcontrollore risponde a questo comando con un messaggio di risposta \"config\". Il software del microcontrollore si avvia sempre in uno stato non configurato all'accensione. Rimane in questo stato fino a quando l'host non completa i processi di configurazione (emettendo un comando finalize_config). Se il microcontrollore \u00e8 gi\u00e0 configurato da una sessione precedente (ed \u00e8 configurato con le impostazioni desiderate), non sono necessarie ulteriori azioni da parte dell'host e il processo di configurazione termina correttamente. allocate_oids count=%c : Questo comando viene emesso per informare il microcontrollore del numero massimo di ID oggetto (oid) che l'host richiede. \u00c8 valido solo per emettere questo comando una volta. Un oid \u00e8 un identificatore intero allocato a ogni stepper, ogni endstop e ogni pin gpio schedulabile. L'host determina in anticipo il numero di oid necessari per far funzionare l'hardware e lo passa al microcontrollore in modo che possa allocare memoria sufficiente per memorizzare una mappatura dall'oid all'oggetto interno. config_XXX oid=%c ... : Per convenzione qualsiasi comando che inizia con il prefisso \"config_\" crea un nuovo oggetto microcontrollore e gli assegna l'oid dato. Ad esempio, il comando config_digital_out configurer\u00e0 il pin specificato come GPIO di output digitale e creer\u00e0 un oggetto interno che l'host pu\u00f2 utilizzare per pianificare le modifiche al GPIO specificato. Il parametro oid passato al comando config viene selezionato dall'host e deve essere compreso tra zero e il conteggio massimo fornito nel comando allocate_oids. I comandi di configurazione possono essere eseguiti solo quando il microcontrollore non \u00e8 in uno stato configurato (cio\u00e8 prima dell'invio da parte dell'host di finalize_config) e dopo che \u00e8 stato inviato il comando allocate_oids. finalize_config crc=%u : Il comando finalize_config trasferisce il microcontrollore da uno stato non configurato a uno stato configurato. Il parametro crc passato al microcontrollore viene archiviato e restituito all'host nei messaggi di risposta \"config\". Per convenzione, l'host prende un CRC a 32bit della configurazione che richieder\u00e0 e all'avvio delle successive sessioni di comunicazione verifica che il CRC memorizzato nel microcontrollore corrisponda esattamente al CRC desiderato. Se il CRC non corrisponde, l'host sa che il microcontrollore non \u00e8 stato configurato nello stato desiderato dall'host.","title":"Configurazione di basso livello del microcontrollore"},{"location":"MCU_Commands.html#oggetti-comuni-del-microcontrollore","text":"Questa sezione elenca alcuni comandi di configurazione comunemente usati. config_digital_out oid=%c pin=%u value=%c default_value=%c max_duration=%u : Questo comando crea un oggetto microcontrollore interno per il dato 'pin' GPIO. Il pin verr\u00e0 configurato in modalit\u00e0 di uscita digitale e impostato su un valore iniziale come specificato da 'value' (0 per basso, 1 per alto). La creazione di un oggetto digital_out consente all'host di pianificare gli aggiornamenti GPIO per il pin specificato a orari specificati (consultare il comando queue_digital_out descritto di seguito). Se il software del microcontrollore entra in modalit\u00e0 di spegnimento, tutti gli oggetti digital_out configurati verranno impostati su 'default_value'. Il parametro 'max_duration' viene utilizzato per implementare un controllo di sicurezza: se \u00e8 diverso da zero, \u00e8 il numero massimo di tick di clock che l'host pu\u00f2 impostare il GPIO specificato su un valore non predefinito senza ulteriori aggiornamenti. Ad esempio, se default_value \u00e8 zero e max_duration \u00e8 16000, se l'host imposta gpio su un valore di uno, deve pianificare un altro aggiornamento del pin gpio (su zero o su uno) entro 16000 tick di clock. Questa funzione di sicurezza pu\u00f2 essere utilizzata con i pin del riscaldatore per garantire che l'host non abiliti il riscaldatore e quindi vada offline. config_pwm_out oid=%c pin=%u cycle_ticks=%u value=%hu default_value=%hu max_duration=%u : Questo comando crea un oggetto interno per i pin PWM hardware per i quali l'host pu\u00f2 pianificare gli aggiornamenti. Il suo utilizzo \u00e8 analogo a config_digital_out - vedere la descrizione dei comandi 'set_pwm_out' e 'config_digital_out' per la descrizione dei parametri. config_analog_in oid=%c pin=%u : Questo comando viene utilizzato per configurare un pin nella modalit\u00e0 di campionamento analogico. Una volta configurato, il pin pu\u00f2 essere campionato a intervalli regolari utilizzando il comando query_analog_in (vedi sotto). config_stepper oid=%c step_pin=%c dir_pin=%c invert_step=%c step_pulse_ticks=%u : Questo comando crea un oggetto stepper interno. I parametri 'step_pin' e 'dir_pin' specificano rispettivamente i pin del passo e della direzione; questo comando li configurer\u00e0 in modalit\u00e0 uscita digitale. Il parametro 'invert_step' specifica se un passo si verifica su un fronte di salita (invert_step=0) o discendente (invert_step=1). Il parametro 'step_pulse_ticks' specifica la durata minima dell'impulso di passo. Se l'mcu esporta la costante 'STEPPER_BOTH_EDGE=1', l'impostazione di step_pulse_ticks=0 e invert_step=-1 imposter\u00e0 il passaggio su entrambi i fronti di salita e di discesa dello step pin. config_endstop oid=%c pin=%c pull_up=%c stepper_count=%c : Questo comando crea un oggetto \"finecorsa\" interno. Viene utilizzato per specificare i relativi pin e per abilitare le operazioni di \"homing\" (vedere il comando endstop_home di seguito). Il comando configurer\u00e0 il pin specificato nella modalit\u00e0 di input digitale. Il parametro 'pull_up' determina se i resistori pullup forniti dall'hardware per il pin (se disponibili) saranno abilitati. Il parametro 'stepper_count' specifica il numero massimo di stepper che potrebbe essere necessario arrestare questo endstop durante un'operazione di homing (vedere endstop_home di seguito). config_spi oid=%c bus=%u pin=%u mode=%u rate=%u shutdown_msg=%*s : Questo comando crea un oggetto SPI interno. Viene utilizzato con i comandi spi_transfer e spi_send (vedi sotto). Il \"bus\" identifica il bus SPI da utilizzare (se il microcontrollore ha pi\u00f9 di un bus SPI disponibile). Il \"pin\" specifica il pin di selezione del chip (CS) per il dispositivo. La \"modalit\u00e0\" \u00e8 la modalit\u00e0 SPI (dovrebbe essere compresa tra 0 e 3). Il parametro \"rate\" specifica la velocit\u00e0 del bus SPI (in cicli al secondo). Infine, \"shutdown_msg\" \u00e8 un comando SPI da inviare al dispositivo specificato se il microcontrollore entra in uno stato di spegnimento. config_spi_without_cs oid=%c bus=%u mode=%u rate=%u shutdown_msg=%*s : Questo comando \u00e8 simile a config_spi, ma senza una definizione di pin CS. \u00c8 utile per i dispositivi SPI che non dispongono di una linea di selezione del chip.","title":"Oggetti comuni del microcontrollore"},{"location":"MCU_Commands.html#comandi-comuni","text":"Questa sezione elenca alcuni comandi comunemente usati durante il run-time. \u00c8 probabilmente di interesse solo per gli sviluppatori che cercano di ottenere informazioni su Klipper. set_digital_out_pwm_cycle oid=%c cycle_ticks=%u : Questo comando configura un pin come uscita digitale (come creato da config_digital_out) per usare \"software PWM\". 'cycle_ticks' \u00e8 il numero di tick di clock per il ciclo PWM. Poich\u00e9 la commutazione dell'uscita \u00e8 implementata nel software del microcontrollore, si consiglia che 'cycle_ticks' corrisponda a un tempo di 10 ms o superiore. queue_digital_out oid=%c clock=%u on_ticks=%u : Questo comando pianificher\u00e0 una modifica a un pin GPIO dell'uscita digitale per un orario specifico. Per utilizzare questo comando \u00e8 necessario che durante la configurazione del microcontrollore sia stato emesso un comando 'config_digital_out' con lo stesso parametro 'oid'. Se \u00e8 stato chiamato 'set_digital_out_pwm_cycle', allora 'on_ticks' \u00e8 la durata di attivazione (in tick di clock) per il ciclo pwm. Altrimenti, 'on_ticks' dovrebbe essere 0 (per bassa tensione) o 1 (per alta tensione). queue_pwm_out oid=%c clock=%u value=%hu : Pianifica una modifica a un pin di uscita PWM hardware. Per ulteriori informazioni, vedere i comandi 'queue_digital_out' e 'config_pwm_out'. query_analog_in oid=%c clock=%u sample_ticks=%u sample_count=%c rest_ticks=%u min_value=%hu max_value=%hu : Questo comando imposta una pianificazione ricorrente di campionamenti di un ingresso analogico. Per utilizzare questo comando \u00e8 necessario che durante la configurazione del microcontrollore sia stato emesso un comando 'config_analog_in' con lo stesso parametro 'oid'. I campioni inizieranno a partire dall'ora 'clock', riporter\u00e0 sul valore ottenuto ogni tick di clock 'rest_ticks', sovracampioner\u00e0 il numero di 'sample_count' e metter\u00e0 in pausa il numero di tick di clock 'sample_ticks' tra i sovacampionamenti. I parametri 'min_value' e 'max_value' implementano una funzione di sicurezza: il software del microcontrollore verificher\u00e0 che il valore campionato (dopo qualsiasi sovracampionamento) sia sempre compreso nell'intervallo fornito. Questo \u00e8 destinato all'uso con pin collegati a termistori che controllano i riscaldatori: pu\u00f2 essere utilizzato per verificare che un riscaldatore rientri in un intervallo di temperatura. get_clock : Questo comando fa s\u00ec che il microcontrollore generi un messaggio di risposta \"clock\". L'host invia questo comando una volta al secondo per ottenere il valore dell'orologio del microcontrollore e per stimare la deriva tra gli orologi dell'host e del microcontrollore. Consente all'host di stimare con precisione l'orologio del microcontrollore.","title":"Comandi comuni"},{"location":"MCU_Commands.html#comandi-motori-passopasso","text":"queue_step oid=%c interval=%u count=%hu add=%hi : Questo comando pianifica il 'conteggio' del numero di passi per il dato stepper, con 'intervallo' il numero di tick di clock tra ogni passo. Il primo passo sar\u00e0 il numero \"intervallo\" di tick di clock dall'ultimo passo programmato per il dato stepper. Se 'add' \u00e8 diverso da zero, l'intervallo verr\u00e0 regolato in base all'importo di 'add' dopo ogni passaggio. Questo comando aggiunge la sequenza intervallo/conteggio/aggiunta data a una coda per stepper. Potrebbero esserci centinaia di queste sequenze in coda durante il normale funzionamento. La nuova sequenza viene aggiunta alla fine della coda e quando ogni sequenza completa il suo numero di \"conteggi\" di passaggi viene estratta dalla parte anteriore della coda. Questo sistema consente al microcontrollore di mettere in coda potenzialmente centinaia di migliaia di passaggi, il tutto con tempi di pianificazione affidabili e prevedibili. set_next_step_dir oid=%c dir=%c : Questo comando specifica il valore del dir_pin che verr\u00e0 utilizzato dal comando queue_step successivo. reset_step_clock oid=%c clock=%u : Normalmente, la temporizzazione del passo \u00e8 relativo all'ultimo passo per un dato stepper. Questo comando azzera l'orologio in modo che il passo successivo sia relativo all'ora fornita. L'host di solito invia questo comando solo all'inizio di una stampa. stepper_get_position oid=%c : Questo comando fa s\u00ec che il microcontrollore generi un messaggio di risposta \"stepper_position\" con la posizione corrente dello stepper. La posizione \u00e8 il numero totale di passi generati con dir=1 meno il numero totale di passi generati con dir=0. endstop_home oid=%c clock=%u sample_ticks=%u sample_count=%c rest_ticks=%u pin_value=%c : Questo comando viene utilizzato durante le operazioni di \"homing\" dello stepper. Per utilizzare questo comando \u00e8 necessario che durante la configurazione del microcontrollore sia stato emesso un comando 'config_endstop' con lo stesso parametro 'oid'. Quando viene invocato questo comando, il microcontrollore campiona il pin finecorsa ogni tick di clock \"rest_ticks\" e controlla se ha un valore uguale a \"pin_value\". Se il valore corrisponde (e continua a corrispondere per 'sample_count' campioni aggiuntivi separati da 'sample_ticks'), la coda di movimento per lo stepper associato verr\u00e0 cancellata e lo stepper si arrester\u00e0 immediatamente. L'host utilizza questo comando per implementare l'homing: l'host indica al finecorsa di eseguire il campionamento per il trigger endstop e quindi emette una serie di comandi queue_step per spostare uno stepper verso il finecorsa. Una volta che lo stepper raggiunge il finecorsa, il trigger verr\u00e0 rilevato, il movimento verr\u00e0 interrotto e l'host verr\u00e0 informato.","title":"Comandi motori passopasso"},{"location":"MCU_Commands.html#coda-movimento","text":"Ogni comando queue_step utilizza una voce nella \"coda di movimento\" del microcontrollore. Questa coda viene allocata quando riceve il comando \"finalize_config\" e segnala il numero di voci di coda disponibili nei messaggi di risposta \"config\". \u00c8 responsabilit\u00e0 dell'host assicurarsi che ci sia spazio disponibile nella coda prima di inviare un comando queue_step. L'host esegue questa operazione calcolando il completamento di ciascun comando queue_step e pianificando di conseguenza i nuovi comandi queue_step.","title":"Coda movimento"},{"location":"MCU_Commands.html#comandi-spi","text":"spi_transfer oid=%c data=%*s : questo comando fa s\u00ec che il microcontrollore invii dati 'data' al dispositivo spi specificato da 'oid' e genera un messaggio di risposta \"spi_transfer_response\" con i dati restituiti durante la trasmissione . spi_send oid=%c data=%*s : Questo comando \u00e8 simile a \"spi_transfer\", ma non genera un messaggio \"spi_transfer_response\".","title":"Comandi SPI"},{"location":"Manual_Level.html","text":"Livellamento manuale \u00b6 Questo documento descrive gli strumenti per la calibrazione di un finecorsa Z e per l'esecuzione delle regolazioni delle viti di livellamento del piatto. Calibrazione di un finecorsa Z \u00b6 Una posizione precisa del fine corsa Z \u00e8 fondamentale per ottenere stampe di alta qualit\u00e0. Si noti, tuttavia, che la precisione dell'interruttore di fine corsa Z stesso pu\u00f2 essere un fattore limitante. Se si utilizzano i driver per motori passo-passo Trinamic, considerare l'abilitazione del rilevamento fase finecorsa per migliorare la precisione dell'interruttore. Per eseguire una calibrazione del fine corsa Z, portare la stampante in posizione di partenza, comandare alla testina di spostarsi in una posizione Z che sia almeno cinque millimetri sopra il piatto (se non lo \u00e8 gi\u00e0), comandare alla testina di spostarsi in una posizione XY vicino al centro di piatto, quindi vai alla scheda del terminale OctoPrint ed esegui: Z_ENDSTOP_CALIBRATE Quindi segui i passaggi descritti in \"the paper test\" per determinare la distanza effettiva tra l'ugello e il piatto in una determinata posizione. Una volta completati questi passaggi, \u00e8 possibile \"ACCETTARE\" la posizione e salvare i risultati nel file di configurazione con: SAVE_CONFIG \u00c8 preferibile utilizzare un interruttore di fine corsa Z sull'estremit\u00e0 opposta dell'asse Z rispetto al piatto. (L'allontanamento dal piatto \u00e8 pi\u00f9 robusto in quanto generalmente \u00e8 sempre sicuro mettere a home la Z.) Tuttavia, se si deve tornare a home verso il piatto, si consiglia di regolare il finecorsa in modo che si attivi a una piccola distanza (ad es. 0,5 mm ) sopra il piatto. Quasi tutti gli interruttori di fine corsa possono essere premuti in sicurezza a una piccola distanza oltre il punto di attivazione. Fatto ci\u00f2, si dovrebbe scoprire che il comando Z_ENDSTOP_CALIBRATE riporta un piccolo valore positivo (ad esempio, .5mm) per Z position_endstop. L'attivazione del fine corsa mentre si \u00e8 ancora a una certa distanza dal piatto riduce il rischio di incidenti involontari del piatto. Alcune stampanti hanno la capacit\u00e0 di regolare manualmente la posizione dell'interruttore di fine corsa fisico. Tuttavia, si consiglia di eseguire il posizionamento del finecorsa Z nel software con Klipper: una volta che la posizione fisica del finecorsa \u00e8 in una posizione comoda, \u00e8 possibile apportare ulteriori modifiche eseguendo Z_ENDSTOP_CALIBRATE o aggiornando manualmente Z position_endstop nel file di configurazione. Regolazione delle viti di livellamento del piatto \u00b6 Il segreto per ottenere un buon livellamento del piatto con le viti di livellamento \u00e8 utilizzare il sistema di movimento ad alta precisione della stampante durante il processo di livellamento del piatto stesso. Questo viene fatto comandando l'ugello in una posizione vicino a ciascuna vite del piatto e quindi regolando quella vite fino a quando il piatto non \u00e8 a una distanza prestabilita dall'ugello. Klipper ha uno strumento per aiutare con questo. Per utilizzare lo strumento \u00e8 necessario specificare la posizione XY di ciascuna vite. Questo viene fatto creando una sezione di configurazione [bed_screws] . Ad esempio, potrebbe sembrare qualcosa di simile a: [bed_screws] screw1: 100, 50 screw2: 100, 150 screw3: 150, 100 Se una vite del piatto \u00e8 sotto il piatto, specificare la posizione XY direttamente sopra la vite. Se la vite \u00e8 fuori dal piatto, specificare una posizione XY pi\u00f9 vicina alla vite che sia ancora all'interno del raggio del piatto. Una volta che il file di configurazione \u00e8 pronto, esegui RESTART per caricare quella configurazione, quindi puoi avviare lo strumento eseguendo: BED_SCREWS_ADJUST Questo strumento sposter\u00e0 l'ugello della stampante in ciascuna posizione XY della vite e quindi sposter\u00e0 l'ugello a un'altezza Z=0. A questo punto si pu\u00f2 utilizzare la \"prova della carta\" per regolare la vite del piatto direttamente sotto l'ugello. Vedere le informazioni descritte in \"the paper test\" , ma regolare la vite del piatto invece di comandare l'ugello ad altezze diverse. Regolare la vite del piatto finch\u00e9 non c'\u00e8 una piccola quantit\u00e0 di attrito quando si spinge la carta avanti e indietro. Una volta che la vite \u00e8 stata regolata in modo da avvertire una piccola quantit\u00e0 di attrito, eseguire il comando ACCEPT o ADJUSTED . Utilizzare il comando ADJUSTED se la vite del piatto necessita di una regolazione (in genere qualcosa di pi\u00f9 di circa 1/8 di giro della vite). Utilizzare il comando ACCEPT se non sono necessarie modifiche significative. Entrambi i comandi faranno s\u00ec che lo strumento proceda alla vite successiva. (Quando viene utilizzato un comando ADJUSTED , lo strumento pianificher\u00e0 un ciclo aggiuntivo di regolazioni delle viti di appoggio; lo strumento viene completato correttamente quando tutte le viti di appoggio vengono verificate e non richiedono regolazioni significative.) \u00c8 possibile utilizzare il comando 'ABORT' per uscire lo strumento in anticipo. Questo sistema funziona al meglio quando la stampante ha una superficie di stampa piatta (come il vetro) e ha binari diritti. Dopo aver completato con successo lo strumento di livellamento del piatto, il piatto dovrebbe essere pronto per la stampa. Regolazione fine della vite del piatto \u00b6 Se la stampante utilizza tre viti del piatto e tutte e tre le viti sono sotto il piatto, potrebbe essere possibile eseguire una seconda fase di livellamento del piatto \"ad alta precisione\". Questo viene fatto comandando l'ugello in punti in cui il piatto si sposta di una distanza maggiore con ciascuna regolazione della vite del piatto. Ad esempio, considera un piatto con viti nelle posizioni A, B e C: Per ogni regolazione effettuata alla vite del piatto nella posizione C, il piatto osciller\u00e0 lungo un pendolo definito dalle restanti due viti del piatto (mostrate qui come una linea verde). In questa situazione, ogni regolazione della vite del piatto in C sposter\u00e0 il letto nella posizione D di una quantit\u00e0 maggiore rispetto a C. \u00c8 quindi possibile effettuare una regolazione della vite C migliorata quando l'ugello \u00e8 in posizione D. Per abilitare questa funzione, si dovrebbero determinare le coordinate dell'ugello aggiuntive e aggiungerle al file di configurazione. Ad esempio, potrebbe essere simile a: [bed_screws] screw1: 100, 50 screw1_fine_adjust: 0, 0 screw2: 100, 150 screw2_fine_adjust: 300, 300 screw3: 150, 100 screw3_fine_adjust: 0, 100 Quando questa funzione \u00e8 abilitata, lo strumento BED_SCREWS_ADJUST richieder\u00e0 prima le regolazioni grossolane direttamente sopra ogni posizione della vite e, una volta accettate, richieder\u00e0 le regolazioni fini nelle posizioni aggiuntive. Continua a usare ACCEPT e ADJUSTED in ogni posizione. Regolazione delle viti di livellamento del piatto mediante la sonda del piatto \u00b6 Questo \u00e8 un altro modo per calibrare il livello del piatto utilizzando la sonda del piatto. Per utilizzarlo \u00e8 necessario disporre di una sonda Z (BL Touch, Sensore induttivo, ecc). Per abilitare questa funzione, si dovrebbero determinare le coordinate dell'ugello in modo tale che la sonda Z sia sopra le viti, quindi aggiungerle al file di configurazione. Ad esempio, potrebbe essere simile a: [screws_tilt_adjust] screw1: -5, 30 screw1_name: front left screw screw2: 155, 30 screw2_name: front right screw screw3: 155, 190 screw3_name: rear right screw screw4: -5, 190 screw4_name: rear left screw horizontal_move_z: 10. speed: 50. screw_thread: CW-M3 La vite1 \u00e8 sempre il punto di riferimento per le altre, quindi il sistema presume che la vite1 sia all'altezza corretta. Eseguire sempre prima G28 e poi eseguire SCREWS_TILT_CALCULATE - dovrebbe produrre un output simile a: Send: G28 Recv: ok Send: SCREWS_TILT_CALCULATE Recv: // 01:20 means 1 full turn and 20 minutes, CW=clockwise, CCW=counter-clockwise Recv: // front left screw (base) : x=-5.0, y=30.0, z=2.48750 Recv: // front right screw : x=155.0, y=30.0, z=2.36000 : adjust CW 01:15 Recv: // rear right screw : y=155.0, y=190.0, z=2.71500 : adjust CCW 00:50 Recv: // read left screw : x=-5.0, y=190.0, z=2.47250 : adjust CW 00:02 Recv: ok Ci\u00f2 significa che: la vite anteriore sinistra \u00e8 il punto di riferimento non devi cambiarla. la vite anteriore destra deve essere ruotata in senso orario di 1 giro completo e un quarto di giro la vite posteriore destra deve essere ruotata in senso antiorario per '50 minuti' la vite posteriore sinistra deve essere ruotata in senso orario '2 minuti' (non serve va bene) Si noti che \"minuti\" si riferisce ai \"minuti di un quadrante\". Quindi, ad esempio, 15 minuti sono un quarto di giro completo. Ripeti il processo pi\u00f9 volte fino a ottenere un piatto ben livellato, normalmente quando tutte le regolazioni richiedono meno di 6 minuti. Se si utilizza una sonda montata sul lato dell'hotend (ovvero, ha un offset X o Y), tenere presente che la regolazione dell'inclinazione del piatto invalider\u00e0 qualsiasi precedente calibrazione della sonda eseguita con unpiatto inclinato. Assicurarsi di eseguire calibrazione sonda dopo aver regolato le viti del piatto. Il parametro MAX_DEVIATION \u00e8 utile quando viene utilizzata una mesh del piatto salvata, per garantire che il livello del pitto non si sia spostato troppo lontano da dove si trovava quando \u00e8 stata creata la mesh. Ad esempio, SCREWS_TILT_CALCULATE MAX_DEVIATION=0.01 pu\u00f2 essere aggiunto al gcode iniziale personalizzato dello slicer prima del caricamento della mesh. Interromper\u00e0 la stampa se viene superato il limite configurato (0,01 mm in questo esempio), dando all'utente la possibilit\u00e0 di regolare le viti e riavviare la stampa. Il parametro DIRECTION \u00e8 utile se puoi ruotare le viti di regolazione del piatto in una sola direzione. Ad esempio, potresti avere viti che iniziano a stringere nella posizione pi\u00f9 bassa (o pi\u00f9 alta) possibile, che possono essere ruotate solo in una sola direzione, per alzare (o abbassare) il piatto. Se puoi girare le viti solo in senso orario, esegui SCREWS_TILT_CALCULATE DIRECTION=CW . Se puoi ruotarli solo in senso antiorario, esegui SCREWS_TILT_CALCULATE DIRECTION=CCW . Verr\u00e0 scelto un punto di riferimento idoneo in modo tale che il piatto possa essere livellato ruotando tutte le viti nella direzione indicata.","title":"Livellamento manuale"},{"location":"Manual_Level.html#livellamento-manuale","text":"Questo documento descrive gli strumenti per la calibrazione di un finecorsa Z e per l'esecuzione delle regolazioni delle viti di livellamento del piatto.","title":"Livellamento manuale"},{"location":"Manual_Level.html#calibrazione-di-un-finecorsa-z","text":"Una posizione precisa del fine corsa Z \u00e8 fondamentale per ottenere stampe di alta qualit\u00e0. Si noti, tuttavia, che la precisione dell'interruttore di fine corsa Z stesso pu\u00f2 essere un fattore limitante. Se si utilizzano i driver per motori passo-passo Trinamic, considerare l'abilitazione del rilevamento fase finecorsa per migliorare la precisione dell'interruttore. Per eseguire una calibrazione del fine corsa Z, portare la stampante in posizione di partenza, comandare alla testina di spostarsi in una posizione Z che sia almeno cinque millimetri sopra il piatto (se non lo \u00e8 gi\u00e0), comandare alla testina di spostarsi in una posizione XY vicino al centro di piatto, quindi vai alla scheda del terminale OctoPrint ed esegui: Z_ENDSTOP_CALIBRATE Quindi segui i passaggi descritti in \"the paper test\" per determinare la distanza effettiva tra l'ugello e il piatto in una determinata posizione. Una volta completati questi passaggi, \u00e8 possibile \"ACCETTARE\" la posizione e salvare i risultati nel file di configurazione con: SAVE_CONFIG \u00c8 preferibile utilizzare un interruttore di fine corsa Z sull'estremit\u00e0 opposta dell'asse Z rispetto al piatto. (L'allontanamento dal piatto \u00e8 pi\u00f9 robusto in quanto generalmente \u00e8 sempre sicuro mettere a home la Z.) Tuttavia, se si deve tornare a home verso il piatto, si consiglia di regolare il finecorsa in modo che si attivi a una piccola distanza (ad es. 0,5 mm ) sopra il piatto. Quasi tutti gli interruttori di fine corsa possono essere premuti in sicurezza a una piccola distanza oltre il punto di attivazione. Fatto ci\u00f2, si dovrebbe scoprire che il comando Z_ENDSTOP_CALIBRATE riporta un piccolo valore positivo (ad esempio, .5mm) per Z position_endstop. L'attivazione del fine corsa mentre si \u00e8 ancora a una certa distanza dal piatto riduce il rischio di incidenti involontari del piatto. Alcune stampanti hanno la capacit\u00e0 di regolare manualmente la posizione dell'interruttore di fine corsa fisico. Tuttavia, si consiglia di eseguire il posizionamento del finecorsa Z nel software con Klipper: una volta che la posizione fisica del finecorsa \u00e8 in una posizione comoda, \u00e8 possibile apportare ulteriori modifiche eseguendo Z_ENDSTOP_CALIBRATE o aggiornando manualmente Z position_endstop nel file di configurazione.","title":"Calibrazione di un finecorsa Z"},{"location":"Manual_Level.html#regolazione-delle-viti-di-livellamento-del-piatto","text":"Il segreto per ottenere un buon livellamento del piatto con le viti di livellamento \u00e8 utilizzare il sistema di movimento ad alta precisione della stampante durante il processo di livellamento del piatto stesso. Questo viene fatto comandando l'ugello in una posizione vicino a ciascuna vite del piatto e quindi regolando quella vite fino a quando il piatto non \u00e8 a una distanza prestabilita dall'ugello. Klipper ha uno strumento per aiutare con questo. Per utilizzare lo strumento \u00e8 necessario specificare la posizione XY di ciascuna vite. Questo viene fatto creando una sezione di configurazione [bed_screws] . Ad esempio, potrebbe sembrare qualcosa di simile a: [bed_screws] screw1: 100, 50 screw2: 100, 150 screw3: 150, 100 Se una vite del piatto \u00e8 sotto il piatto, specificare la posizione XY direttamente sopra la vite. Se la vite \u00e8 fuori dal piatto, specificare una posizione XY pi\u00f9 vicina alla vite che sia ancora all'interno del raggio del piatto. Una volta che il file di configurazione \u00e8 pronto, esegui RESTART per caricare quella configurazione, quindi puoi avviare lo strumento eseguendo: BED_SCREWS_ADJUST Questo strumento sposter\u00e0 l'ugello della stampante in ciascuna posizione XY della vite e quindi sposter\u00e0 l'ugello a un'altezza Z=0. A questo punto si pu\u00f2 utilizzare la \"prova della carta\" per regolare la vite del piatto direttamente sotto l'ugello. Vedere le informazioni descritte in \"the paper test\" , ma regolare la vite del piatto invece di comandare l'ugello ad altezze diverse. Regolare la vite del piatto finch\u00e9 non c'\u00e8 una piccola quantit\u00e0 di attrito quando si spinge la carta avanti e indietro. Una volta che la vite \u00e8 stata regolata in modo da avvertire una piccola quantit\u00e0 di attrito, eseguire il comando ACCEPT o ADJUSTED . Utilizzare il comando ADJUSTED se la vite del piatto necessita di una regolazione (in genere qualcosa di pi\u00f9 di circa 1/8 di giro della vite). Utilizzare il comando ACCEPT se non sono necessarie modifiche significative. Entrambi i comandi faranno s\u00ec che lo strumento proceda alla vite successiva. (Quando viene utilizzato un comando ADJUSTED , lo strumento pianificher\u00e0 un ciclo aggiuntivo di regolazioni delle viti di appoggio; lo strumento viene completato correttamente quando tutte le viti di appoggio vengono verificate e non richiedono regolazioni significative.) \u00c8 possibile utilizzare il comando 'ABORT' per uscire lo strumento in anticipo. Questo sistema funziona al meglio quando la stampante ha una superficie di stampa piatta (come il vetro) e ha binari diritti. Dopo aver completato con successo lo strumento di livellamento del piatto, il piatto dovrebbe essere pronto per la stampa.","title":"Regolazione delle viti di livellamento del piatto"},{"location":"Manual_Level.html#regolazione-fine-della-vite-del-piatto","text":"Se la stampante utilizza tre viti del piatto e tutte e tre le viti sono sotto il piatto, potrebbe essere possibile eseguire una seconda fase di livellamento del piatto \"ad alta precisione\". Questo viene fatto comandando l'ugello in punti in cui il piatto si sposta di una distanza maggiore con ciascuna regolazione della vite del piatto. Ad esempio, considera un piatto con viti nelle posizioni A, B e C: Per ogni regolazione effettuata alla vite del piatto nella posizione C, il piatto osciller\u00e0 lungo un pendolo definito dalle restanti due viti del piatto (mostrate qui come una linea verde). In questa situazione, ogni regolazione della vite del piatto in C sposter\u00e0 il letto nella posizione D di una quantit\u00e0 maggiore rispetto a C. \u00c8 quindi possibile effettuare una regolazione della vite C migliorata quando l'ugello \u00e8 in posizione D. Per abilitare questa funzione, si dovrebbero determinare le coordinate dell'ugello aggiuntive e aggiungerle al file di configurazione. Ad esempio, potrebbe essere simile a: [bed_screws] screw1: 100, 50 screw1_fine_adjust: 0, 0 screw2: 100, 150 screw2_fine_adjust: 300, 300 screw3: 150, 100 screw3_fine_adjust: 0, 100 Quando questa funzione \u00e8 abilitata, lo strumento BED_SCREWS_ADJUST richieder\u00e0 prima le regolazioni grossolane direttamente sopra ogni posizione della vite e, una volta accettate, richieder\u00e0 le regolazioni fini nelle posizioni aggiuntive. Continua a usare ACCEPT e ADJUSTED in ogni posizione.","title":"Regolazione fine della vite del piatto"},{"location":"Manual_Level.html#regolazione-delle-viti-di-livellamento-del-piatto-mediante-la-sonda-del-piatto","text":"Questo \u00e8 un altro modo per calibrare il livello del piatto utilizzando la sonda del piatto. Per utilizzarlo \u00e8 necessario disporre di una sonda Z (BL Touch, Sensore induttivo, ecc). Per abilitare questa funzione, si dovrebbero determinare le coordinate dell'ugello in modo tale che la sonda Z sia sopra le viti, quindi aggiungerle al file di configurazione. Ad esempio, potrebbe essere simile a: [screws_tilt_adjust] screw1: -5, 30 screw1_name: front left screw screw2: 155, 30 screw2_name: front right screw screw3: 155, 190 screw3_name: rear right screw screw4: -5, 190 screw4_name: rear left screw horizontal_move_z: 10. speed: 50. screw_thread: CW-M3 La vite1 \u00e8 sempre il punto di riferimento per le altre, quindi il sistema presume che la vite1 sia all'altezza corretta. Eseguire sempre prima G28 e poi eseguire SCREWS_TILT_CALCULATE - dovrebbe produrre un output simile a: Send: G28 Recv: ok Send: SCREWS_TILT_CALCULATE Recv: // 01:20 means 1 full turn and 20 minutes, CW=clockwise, CCW=counter-clockwise Recv: // front left screw (base) : x=-5.0, y=30.0, z=2.48750 Recv: // front right screw : x=155.0, y=30.0, z=2.36000 : adjust CW 01:15 Recv: // rear right screw : y=155.0, y=190.0, z=2.71500 : adjust CCW 00:50 Recv: // read left screw : x=-5.0, y=190.0, z=2.47250 : adjust CW 00:02 Recv: ok Ci\u00f2 significa che: la vite anteriore sinistra \u00e8 il punto di riferimento non devi cambiarla. la vite anteriore destra deve essere ruotata in senso orario di 1 giro completo e un quarto di giro la vite posteriore destra deve essere ruotata in senso antiorario per '50 minuti' la vite posteriore sinistra deve essere ruotata in senso orario '2 minuti' (non serve va bene) Si noti che \"minuti\" si riferisce ai \"minuti di un quadrante\". Quindi, ad esempio, 15 minuti sono un quarto di giro completo. Ripeti il processo pi\u00f9 volte fino a ottenere un piatto ben livellato, normalmente quando tutte le regolazioni richiedono meno di 6 minuti. Se si utilizza una sonda montata sul lato dell'hotend (ovvero, ha un offset X o Y), tenere presente che la regolazione dell'inclinazione del piatto invalider\u00e0 qualsiasi precedente calibrazione della sonda eseguita con unpiatto inclinato. Assicurarsi di eseguire calibrazione sonda dopo aver regolato le viti del piatto. Il parametro MAX_DEVIATION \u00e8 utile quando viene utilizzata una mesh del piatto salvata, per garantire che il livello del pitto non si sia spostato troppo lontano da dove si trovava quando \u00e8 stata creata la mesh. Ad esempio, SCREWS_TILT_CALCULATE MAX_DEVIATION=0.01 pu\u00f2 essere aggiunto al gcode iniziale personalizzato dello slicer prima del caricamento della mesh. Interromper\u00e0 la stampa se viene superato il limite configurato (0,01 mm in questo esempio), dando all'utente la possibilit\u00e0 di regolare le viti e riavviare la stampa. Il parametro DIRECTION \u00e8 utile se puoi ruotare le viti di regolazione del piatto in una sola direzione. Ad esempio, potresti avere viti che iniziano a stringere nella posizione pi\u00f9 bassa (o pi\u00f9 alta) possibile, che possono essere ruotate solo in una sola direzione, per alzare (o abbassare) il piatto. Se puoi girare le viti solo in senso orario, esegui SCREWS_TILT_CALCULATE DIRECTION=CW . Se puoi ruotarli solo in senso antiorario, esegui SCREWS_TILT_CALCULATE DIRECTION=CCW . Verr\u00e0 scelto un punto di riferimento idoneo in modo tale che il piatto possa essere livellato ruotando tutte le viti nella direzione indicata.","title":"Regolazione delle viti di livellamento del piatto mediante la sonda del piatto"},{"location":"Measuring_Resonances.html","text":"Misurazione delle risonanze \u00b6 Klipper has built-in support for the ADXL345, MPU-9250, LIS2DW and LIS3DH compatible accelerometers which can be used to measure resonance frequencies of the printer for different axes, and auto-tune input shapers to compensate for resonances. Note that using accelerometers requires some soldering and crimping. The ADXL345 can be connected to the SPI interface of a Raspberry Pi or MCU board (it needs to be reasonably fast). The MPU family can be connected to the I2C interface of a Raspberry Pi directly, or to an I2C interface of an MCU board that supports 400kbit/s fast mode in Klipper. The LIS2DW and LIS3DH can be connected to either SPI or I2C with the same considerations as above. When sourcing accelerometers, be aware that there are a variety of different PCB board designs and different clones of them. If it is going to be connected to a 5V printer MCU ensure it has a voltage regulator and level shifters. For ADXL345s, make sure that the board supports SPI mode (a small number of boards appear to be hard-configured for I2C by pulling SDO to GND). For MPU-9250/MPU-9255/MPU-6515/MPU-6050/MPU-6500s and LIS2DW/LIS3DH there are also a variety of board designs and clones with different I2C pull-up resistors which will need supplementing. MCUs with Klipper I2C fast-mode Support \u00b6 MCU Family MCU(s) Tested MCU(s) with Support Raspberry Pi 3B+, Pico 3A, 3A+, 3B, 4 AVR ATmega ATmega328p ATmega32u4, ATmega128, ATmega168, ATmega328, ATmega644p, ATmega1280, ATmega1284, ATmega2560 AVR AT90 - AT90usb646, AT90usb1286 SAMD SAMC21G18 SAMC21G18, SAMD21G18, SAMD21E18, SAMD21J18, SAMD21E15, SAMD51G19, SAMD51J19, SAMD51N19, SAMD51P20, SAME51J19, SAME51N19, SAME54P20 Istruzioni per l'installazione \u00b6 Cablaggio \u00b6 An ethernet cable with shielded twisted pairs (cat5e or better) is recommended for signal integrity over a long distance. If you still experience signal integrity issues (SPI/I2C errors): Double check the wiring with a digital multimeter for: Correct connections when turned off (continuity) Correct power and ground voltages I2C only: Check the SCL and SDA lines' resistances to 3.3V are in the range of 900 ohms to 1.8K For full technical details consult chapter 7 of the I2C-bus specification and user manual UM10204 for fast-mode Shorten the cable Connect ethernet cable shielding only to the MCU board/Pi ground. Ricontrolla il cablaggio prima di accendere per evitare di danneggiare il tuo MCU/Raspberry Pi o l'accelerometro. Accelerometri SPI \u00b6 Suggested twisted pair order for three twisted pairs: GND+MISO 3.3V+MOSI SCLK+CS Note that unlike a cable shield, GND must be connected at both ends. ADXL345 \u00b6 Diretto a Raspberry Pi \u00b6 Note: Many MCUs will work with an ADXL345 in SPI mode (e.g. Pi Pico), wiring and configuration will vary according to your specific board and available pins. Devi connettere ADXL345 al tuo Raspberry Pi tramite SPI. Si noti che la connessione I2C, suggerita dalla documentazione di ADXL345, ha un throughput troppo basso e non funzioner\u00e0 . Lo schema di connessione consigliato: ADXL345 pin RPi pin Nome pin RPi 3V3 (or VCC) 01 3.3V DC power GND 06 Ground CS 24 GPIO08 (SPI0_CE0_N) SDO 21 GPIO09 (SPI0_MISO) SDA 19 GPIO10 (SPI0_MOSI) SCL 23 GPIO11 (SPI0_SCLK) Schemi collegamenti Fritzing per alcune delle schede ADXL345: Utilizzo di Raspberry Pi Pico \u00b6 Puoi collegare ADXL345 al tuo Raspberry Pi Pico e quindi collegare Pico al tuo Raspberry Pi tramite USB. Ci\u00f2 semplifica il riutilizzo dell'accelerometro su altri dispositivi Klipper, poich\u00e9 puoi connetterti tramite USB anzich\u00e9 GPIO. Il Pico non ha molta potenza di elaborazione, quindi assicurati che stia solo eseguendo l'accelerometro e non svolga altre funzioni. Per evitare danni al tuo RPi assicurati di collegare l'ADXL345 solo a 3,3 V. A seconda del layout della scheda, potrebbe essere presente un cambio di livello, che rende i 5 V pericolosi per il tuo RPi. ADXL345 pin pin Pico Nome pin Pico 3V3 (or VCC) 36 3.3V DC power GND 38 Ground CS 2 GP1 (SPI0_CSn) SDO 1 GP0 (SPI0_RX) SDA 5 GP3 (SPI0_TX) SCL 4 GP2 (SPI0_SCK) Schemi di collegamento per alcune schede ADXL345: Accelerometri I2C \u00b6 Suggested twisted pair order for three pairs (preferred): 3.3V+GND SDA+GND SCL+GND or for two pairs: 3.3V+SDA GND+SCL Note that unlike a cable shield, any GND(s) should be connected at both ends. MPU-9250/MPU-9255/MPU-6515/MPU-6050/MPU-6500 \u00b6 These accelerometers have been tested to work over I2C on the RPi, RP2040 (Pico) and AVR at 400kbit/s ( fast mode ). Some MPU accelerometer modules include pull-ups, but some are too large at 10K and must be changed or supplemented by smaller parallel resistors. Schema di connessione consigliato per I2C su Raspberry Pi: pin MPU-9250 RPi pin Nome pin RPi VCC 01 3.3v alimentazione DC GND 09 Ground SDA 03 GPIO02 (SDA1) SCL 05 GPIO03 (SCL1) The RPi has buit-in 1.8K pull-ups on both SCL and SDA. Recommended connection scheme for I2C (i2c0a) on the RP2040: pin MPU-9250 pin RP2040 RP2040 pin name VCC 36 3v3 GND 38 Ground SDA 01 GP0 (I2C0 SDA) SCL 02 GP1 (I2C0 SCL) The Pico does not include any built-in I2C pull-up resistors. Recommended connection scheme for I2C(TWI) on the AVR ATmega328P Arduino Nano: \u00b6 pin MPU-9250 Atmega328P TQFP32 pin Atmega328P pin name Arduino Nano pin VCC 39 - - GND 38 Ground GND SDA 27 SDA A4 SCL 28 SCL A5 The Arduino Nano does not include any built-in pull-up resistors nor a 3.3V power pin. Montaggio dell'accelerometro \u00b6 L'accelerometro deve essere collegato alla testa di stampa. \u00c8 necessario progettare un supporto adeguato che si adatti alla propria stampante 3D. \u00c8 meglio allineare gli assi dell'accelerometro con gli assi della stampante (ma se lo rende pi\u00f9 comodo, gli assi possono essere scambiati - cio\u00e8 non c'\u00e8 bisogno di allineare l'asse X con X e cos\u00ec via - dovrebbe andare bene anche se l'asse Z di l'accelerometro \u00e8 l'asse X della stampante, ecc.). Un esempio di montaggio di ADXL345 su SmartEffect: Si noti che su una stampante con piatto mobile \u00e8 necessario progettare 2 supporti: uno per la testina e uno per il piatto, ed eseguire le misurazioni due volte. Per maggiori dettagli, vedere la sezione corrispondente. Attenzione: assicurati che l'accelerometro e le eventuali viti che lo tengono in posizione non tocchino parti metalliche della stampante. Fondamentalmente, il supporto deve essere progettato in modo tale da garantire l'isolamento elettrico dell'accelerometro dal telaio della stampante. Non riuscendo a garantire che pu\u00f2 creare un loop di massa nel sistema che potrebbe danneggiare l'elettronica. Installazione software \u00b6 Si noti che le misurazioni della risonanza e la calibrazione automatica dello shaper richiedono dipendenze software aggiuntive non installate per impostazione predefinita. Innanzitutto, esegui sul tuo Raspberry Pi i seguenti comandi: sudo apt update sudo apt install python3-numpy python3-matplotlib libatlas-base-dev libopenblas-dev Quindi, per installare NumPy nell'ambiente Klipper, esegui il comando: ~/klippy-env/bin/pip install -v \"numpy<1.26\" Note that, depending on the performance of the CPU, it may take a lot of time, up to 10-20 minutes. Be patient and wait for the completion of the installation. On some occasions, if the board has too little RAM the installation may fail and you will need to enable swap. Also note the forced version, due to newer versions of NumPY having requirements that may not be satisfied in some klipper python environments. Once installed please check that no errors show from the command: ~/klippy-env/bin/python -c 'import numpy;' The correct output should simply be a new line. Configura ADXL345 con RPi \u00b6 First, check and follow the instructions in the RPi Microcontroller document to setup the \"linux mcu\" on the Raspberry Pi. This will configure a second Klipper instance that runs on your Pi. Assicurati che il driver SPI di Linux sia abilitato eseguendo sudo raspi-config e abilitando SPI nel menu \"Opzioni di interfaccia\". Aggiungere quanto segue al file printer.cfg: [mcu rpi] serial: /tmp/klipper_host_mcu [adxl345] cs_pin: rpi:None [resonance_tester] accel_chip: adxl345 probe_points: 100, 100, 20 # un esempio Si consiglia di iniziare con 1 punto sonda, al centro del piano di stampa, leggermente al di sopra di esso. Configura ADXL345 con Pi Pico \u00b6 Aggiorna il firmware Pico \u00b6 Sul tuo Raspberry Pi, compila il firmware per Pico. cd ~/klipper make clean make menuconfig Ora, tenendo premuto il pulsante BOOTSEL sul Pico, collega il Pico al Raspberry Pi tramite USB. Compilare e eseguire il flashing del firmware. make flash FLASH_DEVICE=first Se fallisce, ti verr\u00e0 detto quale FLASH_DEVICE utilizzare. In questo esempio si tratta di make flash FLASH_DEVICE=2e8a:0003 . Configura la connessione \u00b6 Il Pico ora si riavvier\u00e0 con il nuovo firmware e dovrebbe apparire come dispositivo seriale. Trova il dispositivo pico seriale con ls /dev/serial/by-id/* . Ora puoi aggiungere un file adxl.cfg con le seguenti impostazioni: [mcu adxl] # Cambia <mySerial> con quello che hai trovato sopra. Per esempio, # usb-Klipper_rp2040_E661640843545B2E-if00 serial: /dev/serial/by-id/usb-Klipper_rp2040_<mySerial> [adxl345] cs_pin: adxl:gpio1 spi_bus: spi0a axes_map: x,z,y [resonance_tester] accel_chip: adxl345 probe_points: # Da qualche parte leggermente sopra la met\u00e0 del piano di stampa 147,154, 20 [output_pin power_mode] #Migliora la stabilit\u00e0 dell' alimentazione pin: adxl:gpio23 Se imposti la configurazione di ADXL345 in un file separato, come mostrato sopra, ti consigliamo di modificare anche il file printer.cfg per includere questo: [include adxl.cfg] # Commenta questo quando scolleghi l'accelerometro Riavvia Klipper tramite il comando RESTART . Configure LIS2DW series over SPI \u00b6 [mcu lis] # Change <mySerial> to whatever you found above. For example, # usb-Klipper_rp2040_E661640843545B2E-if00 serial: /dev/serial/by-id/usb-Klipper_rp2040_<mySerial> [lis2dw] cs_pin: lis:gpio1 spi_bus: spi0a axes_map: x,z,y [resonance_tester] accel_chip: lis2dw probe_points: # Somewhere slightly above the middle of your print bed 147,154, 20 Configura la serie MPU-6000/9000 con RPi \u00b6 Assicurati che il driver Linux I2C sia abilitato e che la velocit\u00e0 di trasmissione sia impostata su 400000 (consulta la sezione Abilitazione di I2C per ulteriori dettagli). Quindi, aggiungi quanto segue a printer.cfg: [mcu rpi] serial: /tmp/klipper_host_mcu [mpu9250] i2c_mcu: rpi i2c_bus: i2c.1 [resonance_tester] accel_chip: mpu9250 probe_points: 100, 100, 20 # un esempio Configure MPU-9520 Compatibles With Pico \u00b6 Pico I2C is set to 400000 on default. Simply add the following to the printer.cfg: [mcu pico] serial: /dev/serial/by-id/<your Pico's serial ID> [mpu9250] i2c_mcu: pico i2c_bus: i2c0a [resonance_tester] accel_chip: mpu9250 probe_points: 100, 100, 20 # an example [static_digital_output pico_3V3pwm] # Improve power stability pins: pico:gpio23 Configure MPU-9520 Compatibles with AVR \u00b6 AVR I2C will be set to 400000 by the mpu9250 option. Simply add the following to the printer.cfg: [mcu nano] serial: /dev/serial/by-id/<your nano's serial ID> [mpu9250] i2c_mcu: nano [resonance_tester] accel_chip: mpu9250 probe_points: 100, 100, 20 # an example Riavvia Klipper tramite il comando RESTART . Misurare le risonanze \u00b6 Controllo della configurazione \u00b6 Ora puoi testare una connessione. Per \"per piatti non scorrevoli\" (es. un accelerometro), in Octoprint, inserisci ACCELEROMETER_QUERY Per \"piatti scorrevoli\" (ad es. pi\u00f9 di un accelerometro), immettere ACCELEROMETER_QUERY CHIP=<chip> dove <chip> \u00e8 il nome del chip immesso, ad es. CHIP=piatto (vedi: bed-slinger ) per tutti i chip dell'accelerometro installati. Dovresti vedere le misurazioni attuali dall'accelerometro, inclusa l'accelerazione di caduta libera, ad es. Recv: // adxl345 values (x, y, z): 470.719200, 941.438400, 9728.196800 Se ricevi un errore del tipo ID adxl345 non valido (ottenuto xx vs e5) , dove xx \u00e8 un altro ID, riprova immediatamente. Si \u00e8 verificato un problema con l'inizializzazione SPI. Se ricevi ancora un errore, \u00e8 indicativo del problema di connessione con ADXL345 o del sensore difettoso. Ricontrolla l'alimentazione, il cablaggio (che corrisponda agli schemi, nessun filo sia rotto o allentato, ecc.) e la qualit\u00e0 della saldatura. If you are using a MPU-9250 compatible accelerometer and it shows up as mpu-unknown , use with caution! They are probably refurbished chips! Quindi, prova a eseguire MEASURE_AXES_NOISE in Octoprint, dovresti ottenere alcuni numeri di riferimento per il rumore dell'accelerometro sugli assi (dovrebbe essere compreso tra ~1-100). Un rumore degli assi troppo elevato (ad es. 1000 e pi\u00f9) pu\u00f2 essere indicativo di problemi con il sensore, problemi con la sua alimentazione o ventole sbilanciate troppo rumorose su una stampante 3D. Misurare le risonanze \u00b6 Ora puoi eseguire alcuni test realistici. Esegui il seguente comando: TEST_RESONANCES AXIS=X Nota che creer\u00e0 vibrazioni sull'asse X. Disabiliter\u00e0 anche l'input shaping se era stato abilitato in precedenza, poich\u00e9 non \u00e8 valido eseguire il test di risonanza con l'input shaper abilitato. Attenzione! Assicurati di osservare la stampante per la prima volta, per assicurarti che le vibrazioni non diventino troppo violente (il comando M112 pu\u00f2 essere utilizzato per interrompere il test in caso di emergenza; si spera che non si verifichi questo per\u00f2). Se le vibrazioni diventano troppo forti, puoi provare a specificare un valore inferiore al valore predefinito per il parametro accel_per_hz nella sezione [resonance_tester] , ad es. [resonance_tester] accel_chip: adxl345 accel_per_hz: 50 # default \u00e8 75 probe_points: ... Se funziona per l'asse X, esegui anche per l'asse Y: TEST_RESONANCES AXIS=Y This will generate 2 CSV files ( /tmp/resonances_x_*.csv and /tmp/resonances_y_*.csv ). These files can be processed with the stand-alone script on a Raspberry Pi. This script is intended to be run with a single CSV file for each axis measured, although it can be used with multiple CSV files if you desire to average the results. Averaging results can be useful, for example, if resonance tests were done at multiple test points. Delete the extra CSV files if you do not desire to average them. ~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o /tmp/shaper_calibrate_x.png ~/klipper/scripts/calibrate_shaper.py /tmp/resonances_y_*.csv -o /tmp/shaper_calibrate_y.png Questo script generer\u00e0 i grafici /tmp/shaper_calibrate_x.png e /tmp/shaper_calibrate_y.png con le risposte in frequenza. Riceverai anche le frequenze suggerite per ogni input shaper, nonch\u00e9 quale input shaper \u00e8 consigliato per la tua configurazione. Per esempio: Fitted shaper 'zv' frequency = 34.4 Hz (vibrations = 4.0%, smoothing ~= 0.132) To avoid too much smoothing with 'zv', suggested max_accel <= 4500 mm/sec^2 Fitted shaper 'mzv' frequency = 34.6 Hz (vibrations = 0.0%, smoothing ~= 0.170) To avoid too much smoothing with 'mzv', suggested max_accel <= 3500 mm/sec^2 Fitted shaper 'ei' frequency = 41.4 Hz (vibrations = 0.0%, smoothing ~= 0.188) To avoid too much smoothing with 'ei', suggested max_accel <= 3200 mm/sec^2 Fitted shaper '2hump_ei' frequency = 51.8 Hz (vibrations = 0.0%, smoothing ~= 0.201) To avoid too much smoothing with '2hump_ei', suggested max_accel <= 3000 mm/sec^2 Fitted shaper '3hump_ei' frequency = 61.8 Hz (vibrations = 0.0%, smoothing ~= 0.215) To avoid too much smoothing with '3hump_ei', suggested max_accel <= 2800 mm/sec^2 Recommended shaper is mzv @ 34.6 Hz La configurazione suggerita pu\u00f2 essere aggiunta alla sezione [input_shaper] di printer.cfg , ad esempio: [input_shaper] shaper_freq_x: ... shaper_type_x: ... shaper_freq_y: 34.6 shaper_type_y: mzv [printer] max_accel: 3000 # non dovrebbe superare il max_accel stimato per gli assi X e Y oppure puoi scegliere tu stesso un'altra configurazione in base ai grafici generati: i picchi nella densit\u00e0 spettrale di potenza sui grafici corrispondono alle frequenze di risonanza della stampante. Nota che in alternativa puoi eseguire la calibrazione automatica dell input shaper da Klipper directly , che pu\u00f2 essere conveniente, ad esempio, per la re-calibration . Stampanti con piatto scorrevole \u00b6 Se la tua stampante ha un piatto scorrevole, dovrai cambiare la posizione dell'accelerometro tra le misurazioni per gli assi X e Y: misurare le risonanze dell'asse X con l'accelerometro collegato alla testa di stampa e le risonanze dell'asse Y - al piatto. However, you can also connect two accelerometers simultaneously, though the ADXL345 must be connected to different boards (say, to an RPi and printer MCU board), or to two different physical SPI interfaces on the same board (rarely available). Then they can be configured in the following manner: [adxl345 hotend] # Supponendo che il chip \"hotend\" sia collegato a un RPi cs_pin: rpi:None [adxl345 bed] # Supponendo che il chip `bed` sia collegato a una scheda MCU della stampante cs_pin: ... # Pin di selezione chip SPI (CS) della scheda stampante [resonance_tester] # Assumendo la configurazione tipo della stampante con piatto scorrevole accel_chip_x: adxl345 hotend accel_chip_y: adxl345 bed probe_points: ... Two MPUs can share one I2C bus, but they cannot measure simultaneously as the 400kbit/s I2C bus is not fast enough. One must have its AD0 pin pulled-down to 0V (address 104) and the other its AD0 pin pulled-up to 3.3V (address 105): [mpu9250 hotend] i2c_mcu: rpi i2c_bus: i2c.1 i2c_address: 104 # This MPU has pin AD0 pulled low [mpu9250 bed] i2c_mcu: rpi i2c_bus: i2c.1 i2c_address: 105 # This MPU has pin AD0 pulled high [resonance_tester] # Assuming the typical setup of the bed slinger printer accel_chip_x: mpu9250 hotend accel_chip_y: mpu9250 bed probe_points: ... [Test with each MPU individually before connecting both to the bus for easy debugging.] Quindi i comandi TEST_RESONANCES AXIS=X e TEST_RESONANCES AXIS=Y utilizzeranno l'accelerometro corretto per ciascun asse. Max smoothing \u00b6 Tieni presente che lo input shaper pu\u00f2 creare un po' di smoothing nelle parti. La regolazione automatica del input shaper eseguita dallo script calibrate_shaper.py o dal comando SHAPER_CALIBRATE cercano di non esacerbare lo smoothing, ma allo stesso tempo cercano di ridurre al minimo le vibrazioni risultanti. A volte possono fare una scelta non ottimale della frequenza dello shaper, o forse semplicemente preferisci avere meno smoothing in alcune parti a scapito di maggiori vibrazioni residue. In questi casi \u00e8 possibile richiedere di limitare lo smoothing massimo dal input shaper. Consideriamo i seguenti risultati della sintonizzazione automatica: Fitted shaper 'zv' frequency = 57.8 Hz (vibrations = 20.3%, smoothing ~= 0.053) To avoid too much smoothing with 'zv', suggested max_accel <= 13000 mm/sec^2 Fitted shaper 'mzv' frequency = 34.8 Hz (vibrations = 3.6%, smoothing ~= 0.168) To avoid too much smoothing with 'mzv', suggested max_accel <= 3600 mm/sec^2 Fitted shaper 'ei' frequency = 48.8 Hz (vibrations = 4.9%, smoothing ~= 0.135) To avoid too much smoothing with 'ei', suggested max_accel <= 4400 mm/sec^2 Fitted shaper '2hump_ei' frequency = 45.2 Hz (vibrations = 0.1%, smoothing ~= 0.264) To avoid too much smoothing with '2hump_ei', suggested max_accel <= 2200 mm/sec^2 Fitted shaper '3hump_ei' frequency = 48.0 Hz (vibrations = 0.0%, smoothing ~= 0.356) To avoid too much smoothing with '3hump_ei', suggested max_accel <= 1500 mm/sec^2 Recommended shaper is 2hump_ei @ 45.2 Hz Si noti che i valori di smoothing riportati sono alcuni valori proiettati. Questi valori possono essere utilizzati per confrontare diverse configurazioni: maggiore \u00e8 il valore, maggiore sar\u00e0 la levigatura creata da uno shaper. Tuttavia, questi punteggi di smoothing non rappresentano alcuna misura reale dello smoothing, perch\u00e9 lo smoothing effettivo dipende dai parametri max_accel e square_corner_velocity . Pertanto, \u00e8 necessario eseguire alcune stampe di prova per vedere quanta smoothing crea esattamente una configurazione scelta. Nell'esempio sopra i parametri dello shaper suggeriti non sono male, ma cosa succede se si desidera ottenere meno smooting sull'asse X? Puoi provare a limitare lo smoothing massimo dello shaper usando il seguente comando: ~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o /tmp/shaper_calibrate_x.png --max_smoothing=0.2 che limita lo smoothing a un punteggio di 0.2. Ora puoi ottenere il seguente risultato: Fitted shaper 'zv' frequency = 55.4 Hz (vibrations = 19.7%, smoothing ~= 0.057) To avoid too much smoothing with 'zv', suggested max_accel <= 12000 mm/sec^2 Fitted shaper 'mzv' frequency = 34.6 Hz (vibrations = 3.6%, smoothing ~= 0.170) To avoid too much smoothing with 'mzv', suggested max_accel <= 3500 mm/sec^2 Fitted shaper 'ei' frequency = 48.2 Hz (vibrations = 4.8%, smoothing ~= 0.139) To avoid too much smoothing with 'ei', suggested max_accel <= 4300 mm/sec^2 Fitted shaper '2hump_ei' frequency = 52.0 Hz (vibrations = 2.7%, smoothing ~= 0.200) To avoid too much smoothing with '2hump_ei', suggested max_accel <= 3000 mm/sec^2 Fitted shaper '3hump_ei' frequency = 72.6 Hz (vibrations = 1.4%, smoothing ~= 0.155) To avoid too much smoothing with '3hump_ei', suggested max_accel <= 3900 mm/sec^2 Recommended shaper is 3hump_ei @ 72.6 Hz Se si confronta con i parametri suggeriti in precedenza, le vibrazioni sono un po' maggiori, ma lo smoothing \u00e8 notevolmente inferiore rispetto a prima, consentendo un'accelerazione massima maggiore. Quando si decide quale parametro max_smoothing scegliere, \u00e8 possibile utilizzare un approccio per tentativi. Prova alcuni valori diversi e guarda quali risultati ottieni. Si noti che lo smoothing effettivo prodotto dall'input shaper dipende principalmente dalla frequenza di risonanza pi\u00f9 bassa della stampante: maggiore \u00e8 la frequenza della risonanza pi\u00f9 bassa, minore \u00e8 lo smoothing. Pertanto, se si richiede allo script di trovare una configurazione dell'input shaper con lo smoothing irrealisticamente piccolo, sar\u00e0 a scapito di un aumento del ringing alle frequenze di risonanza pi\u00f9 basse (che sono, in genere, anche pi\u00f9 visibili nelle stampe). Quindi, ricontrolla sempre le vibrazioni rimanenti previste riportate dallo script e assicurati che non siano troppo alte. Nota che se hai scelto un buon valore max_smoothing per entrambi gli assi, puoi salvarlo in printer.cfg come [resonance_tester] accel_chip: ... probe_points: ... max_smoothing: 0.25 # un esempio Quindi, se riesegui l'autotuning dello shaper di input usando il comando Klipper SHAPER_CALIBRATE in futuro, utilizzer\u00e0 il valore max_smoothing memorizzato come riferimento. Seleziona max_accel \u00b6 Poich\u00e9 l'input shaper pu\u00f2 creare un po' di smussamento nelle parti, specialmente ad accelerazioni elevate, sar\u00e0 comunque necessario scegliere il valore max_accel che non crei troppo smussamento \"smoothing\" nelle parti stampate. Uno script di calibrazione fornisce una stima per il parametro max_accel che non dovrebbe creare un smoothing eccessivo. Si noti che il max_accel visualizzato dallo script di calibrazione \u00e8 solo un massimo teorico al quale il rispettivo shaper \u00e8 ancora in grado di lavorare senza produrre troppo smoothing. Non \u00e8 affatto una raccomandazione impostare questa accelerazione per la stampa. L'accelerazione massima che la stampante \u00e8 in grado di sostenere dipende dalle sue propriet\u00e0 meccaniche e dalla coppia massima dei motori passo-passo utilizzati. Pertanto, si suggerisce di impostare max_accel nella sezione [printer] che non superi i valori stimati per gli assi X e Y, probabilmente con un margine di sicurezza conservativo. In alternativa, segui questa parte della guida all'ottimizzazione dello input shaper e stampa il modello di test per scegliere sperimentalmente il parametro max_accel . Lo stesso avviso vale per lo input shaper auto-calibration con il comando SHAPER_CALIBRATE : \u00e8 comunque necessario scegliere il giusto valore di max_accel dopo l'auto-calibrazione, e il i limiti di accelerazione non verranno applicati automaticamente. Keep in mind that the maximum acceleration without too much smoothing depends on the square_corner_velocity . The general recommendation is not to change it from its default value 5.0, and this is the value used by default by the calibrate_shaper.py script. If you did change it though, you should inform the script about it by passing --square_corner_velocity=... parameter, e.g. ~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o /tmp/shaper_calibrate_x.png --square_corner_velocity=10.0 so that it can calculate the maximum acceleration recommendations correctly. Note that the SHAPER_CALIBRATE command already takes the configured square_corner_velocity parameter into account, and there is no need to specify it explicitly. Se stai eseguendo una ricalibrazione dello shaper e lo smoothing riportato per la configurazione dello shaper suggerita \u00e8 quasi lo stesso di quello ottenuto durante la calibrazione precedente, questo passaggio pu\u00f2 essere saltato. Unreliable measurements of resonance frequencies \u00b6 Sometimes the resonance measurements can produce bogus results, leading to the incorrect suggestions for the input shapers. This can be caused by a variety of reasons, including running fans on the toolhead, incorrect position or non-rigid mounting of the accelerometer, or mechanical problems such as loose belts or binding or bumpy axis. Keep in mind that all fans should be disabled for resonance testing, especially the noisy ones, and that the accelerometer should be rigidly mounted on the corresponding moving part (e.g. on the bed itself for the bed slinger, or on the extruder of the printer itself and not the carriage, and some people get better results by mounting the accelerometer on the nozzle itself). As for mechanical problems, the user should inspect if there is any fault that can be fixed with a moving axis (e.g. linear guide rails cleaned up and lubricated and V-slot wheels tension adjusted correctly). If none of that helps, a user may try the other shapers from the produced list besides the one recommended by default. Test di assi personalizzati \u00b6 Il comando TEST_RESONANCES supporta assi personalizzati. Anche se questo non \u00e8 molto utile per la calibrazione del input shaper, pu\u00f2 essere utilizzato per studiare in profondit\u00e0 le risonanze della stampante e per controllare, ad esempio, la tensione della cinghia. Per controllare la tensione della cinghia sulle stampanti CoreXY, eseguire TEST_RESONANCES AXIS=1,1 OUTPUT=raw_data TEST_RESONANCES AXIS=1,-1 OUTPUT=raw_data e usa graph_accelerometer.py per elaborare i file generati, ad es. ~/klipper/scripts/graph_accelerometer.py -c /tmp/raw_data_axis*.csv -o /tmp/resonances.png che generer\u00e0 /tmp/resonances.png confrontando le risonanze. Per le stampanti Delta con la posizione della torre predefinita (torre A ~= 210 gradi, B ~= 330 gradi e C ~= 90 gradi), eseguire TEST_RESONANCES AXIS=0,1 OUTPUT=raw_data TEST_RESONANCES AXIS=-0.866025404,-0.5 OUTPUT=raw_data TEST_RESONANCES AXIS=0.866025404,-0.5 OUTPUT=raw_data e quindi utilizzare lo stesso comando ~/klipper/scripts/graph_accelerometer.py -c /tmp/raw_data_axis*.csv -o /tmp/resonances.png per generare /tmp/resonances.png confrontando le risonanze. Calibrazione automatica Input Shaper \u00b6 Oltre a scegliere manualmente i parametri appropriati per la funzione di input shaper, \u00e8 anche possibile eseguire l'autotuning per l'input shaper direttamente da Klipper. Esegui il seguente comando tramite il terminale Octoprint: SHAPER_CALIBRATE Questo eseguir\u00e0 il test completo per entrambi gli assi e generer\u00e0 l'output csv ( /tmp/calibration_data_*.csv per impostazione predefinita) per la risposta in frequenza e gli input shaper suggeriti. Riceverai anche le frequenze suggerite per ciascun input shaper, nonch\u00e9 quale input shaper \u00e8 consigliato per la tua configurazione, sulla console Octoprint. Per esempio: Calculating the best input shaper parameters for y axis Fitted shaper 'zv' frequency = 39.0 Hz (vibrations = 13.2%, smoothing ~= 0.105) To avoid too much smoothing with 'zv', suggested max_accel <= 5900 mm/sec^2 Fitted shaper 'mzv' frequency = 36.8 Hz (vibrations = 1.7%, smoothing ~= 0.150) To avoid too much smoothing with 'mzv', suggested max_accel <= 4000 mm/sec^2 Fitted shaper 'ei' frequency = 36.6 Hz (vibrations = 2.2%, smoothing ~= 0.240) To avoid too much smoothing with 'ei', suggested max_accel <= 2500 mm/sec^2 Fitted shaper '2hump_ei' frequency = 48.0 Hz (vibrations = 0.0%, smoothing ~= 0.234) To avoid too much smoothing with '2hump_ei', suggested max_accel <= 2500 mm/sec^2 Fitted shaper '3hump_ei' frequency = 59.0 Hz (vibrations = 0.0%, smoothing ~= 0.235) To avoid too much smoothing with '3hump_ei', suggested max_accel <= 2500 mm/sec^2 Recommended shaper_type_y = mzv, shaper_freq_y = 36.8 Hz Se sei d'accordo con i parametri suggeriti, puoi eseguire ora SAVE_CONFIG per salvarli e riavviare Klipper. Nota che questo non aggiorner\u00e0 il valore max_accel nella sezione [printer] . Dovresti aggiornarlo manualmente seguendo le considerazioni nella sezione Selecting max_accel . Se la tua stampante \u00e8 una stampante a piatto mobile, puoi specificare quale asse testare, in modo da poter cambiare il punto di montaggio dell'accelerometro tra i test (per impostazione predefinita, il test viene eseguito per entrambi gli assi): SHAPER_CALIBRATE AXIS=Y \u00c8 possibile eseguire SAVE_CONFIG due volte, dopo aver calibrato ciascun asse. Tuttavia, se hai collegato due accelerometri contemporaneamente, esegui semplicemente SHAPER_CALIBRATE senza specificare un asse per calibrare l' input shaper per entrambi gli assi in una volta sola. Input Shaper ricalibrazione \u00b6 Il comando SHAPER_CALIBRATE pu\u00f2 essere utilizzato anche per ricalibrare lo shaper di input in futuro, specialmente se vengono apportate alcune modifiche alla stampante che possono influire sulla sua cinematica. \u00c8 possibile eseguire nuovamente la calibrazione completa utilizzando il comando SHAPER_CALIBRATE , o limitare l'autocalibrazione a un singolo asse fornendo il parametro AXIS= , come SHAPER_CALIBRATE AXIS=X Attenzione! Non \u00e8 consigliabile eseguire la calibrazione automatica del modellatore molto frequentemente (ad esempio prima di ogni stampa o ogni giorno). Per determinare le frequenze di risonanza, l'autocalibrazione crea vibrazioni intense su ciascuno degli assi. Generalmente le stampanti 3D non sono progettate per resistere ad un\u2019esposizione prolungata a vibrazioni vicine alle frequenze di risonanza. Ci\u00f2 potrebbe aumentare l'usura dei componenti della stampante e ridurne la durata. Esiste anche un rischio maggiore che alcune parti si svitino o si allentino. Controllare sempre che tutte le parti della stampante (comprese quelle che normalmente potrebbero non muoversi) siano fissate saldamente in posizione dopo ogni regolazione automatica. Inoltre, a causa di un po' di rumore nelle misurazioni, \u00e8 possibile che i risultati dell'ottimizzazione siano leggermente diversi da una calibrazione all'altra. Tuttavia, non ci si aspetta che il rumore influisca troppo sulla qualit\u00e0 di stampa. Tuttavia, si consiglia comunque di ricontrollare i parametri suggeriti e di stampare alcune stampe di prova prima di utilizzarli per confermare che siano corretti. Elaborazione offline dei dati dell'accelerometro \u00b6 \u00c8 possibile generare i dati grezzi dell'accelerometro ed elaborarli offline (ad esempio su una macchina host), ad esempio per trovare risonanze. Per fare ci\u00f2, esegui i seguenti comandi tramite il terminale Octoprint: SET_INPUT_SHAPER SHAPER_FREQ_X=0 SHAPER_FREQ_Y=0 TEST_RESONANCES AXIS=X OUTPUT=raw_data ignorando eventuali errori per il comando SET_INPUT_SHAPER . Per il comando TEST_RESONANCES , specificare l'asse di test desiderato. I dati grezzi verranno scritti nella directory /tmp sull'RPi. I dati grezzi possono anche essere ottenuti eseguendo il comando ACCELEROMETER_MEASURE due volte durante una normale attivit\u00e0 della stampante: prima per avviare le misurazioni, quindi per interromperle e scrivere il file di output. Fare riferimento a G-Codes per maggiori dettagli. I dati possono essere elaborati successivamente dai seguenti script: scripts/graph_accelerometer.py e scripts/calibrate_shaper.py . Entrambi accettano uno o pi\u00f9 file CSV non elaborati come input a seconda della modalit\u00e0. Lo script graph_accelerometer.py supporta diverse modalit\u00e0 operative: tracciando i dati grezzi dell'accelerometro (usa il parametro -r ), \u00e8 supportato solo 1 input; tracciando una risposta in frequenza (non sono richiesti parametri aggiuntivi), se sono specificati pi\u00f9 ingressi, viene calcolata la risposta in frequenza media; confronto della risposta in frequenza tra pi\u00f9 ingressi (usare il parametro -c ); puoi inoltre specificare quale asse dell'accelerometro considerare tramite il parametro -a x , -a y o -a z (se non specificato, viene utilizzata la somma delle vibrazioni per tutti gli assi); tracciando lo spettrogramma (usare il parametro -s ), \u00e8 supportato solo 1 input; \u00e8 inoltre possibile specificare quale asse dell'accelerometro considerare tramite il parametro -a x , -a y o -a z (se non specificato, viene utilizzata la somma delle vibrazioni per tutti gli assi). Si noti che lo script graph_accelerometer.py supporta solo i file raw_data*.csv e non i file resonances*.csv o calibration_data*.csv. Per esempio, ~/klipper/scripts/graph_accelerometer.py /tmp/raw_data_x_*.csv -o /tmp/resonances_x.png -c -a z traccer\u00e0 il confronto di diversi file /tmp/raw_data_x_*.csv per l'asse Z con il file /tmp/resonances_x.png . Lo script shaper_calibrate.py accetta 1 o pi\u00f9 input e pu\u00f2 eseguire l'ottimizzazione automatica dello shaper di input e suggerire i parametri migliori che funzionano bene per tutti gli input forniti. Stampa i parametri suggeriti sulla console e pu\u00f2 inoltre generare il grafico se viene fornito il parametro -o output.png , o il file CSV se viene specificato il parametro -c output.csv . Fornire diversi input allo script shaper_calibrate.py pu\u00f2 essere utile se si esegue un'ottimizzazione avanzata degli shaper di input, ad esempio: Esecuzione di TEST_RESONANCES AXIS=X OUTPUT=raw_data (e asse Y ) per un singolo asse due volte su una stampante con piatto scorrevole con l'accelerometro collegato alla testa di stampa la prima volta e l'accelerometro collegato al piatto la seconda volta in modo da rilevare le risonanze incrociate degli assi e tentare di cancellarle con gli input shaper. Esecuzione di TEST_RESONANCES AXIS=Y OUTPUT=raw_data due volte su un supporto da piatto con un piatto di vetro e una superficie magnetica (che \u00e8 pi\u00f9 leggera) per trovare i parametri dello shaper di input che funzionano bene per qualsiasi configurazione della superficie di stampa. Combinazione dei dati di risonanza da pi\u00f9 punti di test. Combinando i dati di risonanza da 2 assi (ad es. su una stampante con piatto scorrevole per configurare input_shaper dell'asse X dalle risonanze degli assi X e Y per annullare le vibrazioni del piatto nel caso in cui l'ugello \"cattura\" una stampa quando si sposta nella direzione dell'asse X ).","title":"Misurazione delle risonanze"},{"location":"Measuring_Resonances.html#misurazione-delle-risonanze","text":"Klipper has built-in support for the ADXL345, MPU-9250, LIS2DW and LIS3DH compatible accelerometers which can be used to measure resonance frequencies of the printer for different axes, and auto-tune input shapers to compensate for resonances. Note that using accelerometers requires some soldering and crimping. The ADXL345 can be connected to the SPI interface of a Raspberry Pi or MCU board (it needs to be reasonably fast). The MPU family can be connected to the I2C interface of a Raspberry Pi directly, or to an I2C interface of an MCU board that supports 400kbit/s fast mode in Klipper. The LIS2DW and LIS3DH can be connected to either SPI or I2C with the same considerations as above. When sourcing accelerometers, be aware that there are a variety of different PCB board designs and different clones of them. If it is going to be connected to a 5V printer MCU ensure it has a voltage regulator and level shifters. For ADXL345s, make sure that the board supports SPI mode (a small number of boards appear to be hard-configured for I2C by pulling SDO to GND). For MPU-9250/MPU-9255/MPU-6515/MPU-6050/MPU-6500s and LIS2DW/LIS3DH there are also a variety of board designs and clones with different I2C pull-up resistors which will need supplementing.","title":"Misurazione delle risonanze"},{"location":"Measuring_Resonances.html#mcus-with-klipper-i2c-fast-mode-support","text":"MCU Family MCU(s) Tested MCU(s) with Support Raspberry Pi 3B+, Pico 3A, 3A+, 3B, 4 AVR ATmega ATmega328p ATmega32u4, ATmega128, ATmega168, ATmega328, ATmega644p, ATmega1280, ATmega1284, ATmega2560 AVR AT90 - AT90usb646, AT90usb1286 SAMD SAMC21G18 SAMC21G18, SAMD21G18, SAMD21E18, SAMD21J18, SAMD21E15, SAMD51G19, SAMD51J19, SAMD51N19, SAMD51P20, SAME51J19, SAME51N19, SAME54P20","title":"MCUs with Klipper I2C fast-mode Support"},{"location":"Measuring_Resonances.html#istruzioni-per-linstallazione","text":"","title":"Istruzioni per l'installazione"},{"location":"Measuring_Resonances.html#cablaggio","text":"An ethernet cable with shielded twisted pairs (cat5e or better) is recommended for signal integrity over a long distance. If you still experience signal integrity issues (SPI/I2C errors): Double check the wiring with a digital multimeter for: Correct connections when turned off (continuity) Correct power and ground voltages I2C only: Check the SCL and SDA lines' resistances to 3.3V are in the range of 900 ohms to 1.8K For full technical details consult chapter 7 of the I2C-bus specification and user manual UM10204 for fast-mode Shorten the cable Connect ethernet cable shielding only to the MCU board/Pi ground. Ricontrolla il cablaggio prima di accendere per evitare di danneggiare il tuo MCU/Raspberry Pi o l'accelerometro.","title":"Cablaggio"},{"location":"Measuring_Resonances.html#accelerometri-spi","text":"Suggested twisted pair order for three twisted pairs: GND+MISO 3.3V+MOSI SCLK+CS Note that unlike a cable shield, GND must be connected at both ends.","title":"Accelerometri SPI"},{"location":"Measuring_Resonances.html#adxl345","text":"","title":"ADXL345"},{"location":"Measuring_Resonances.html#diretto-a-raspberry-pi","text":"Note: Many MCUs will work with an ADXL345 in SPI mode (e.g. Pi Pico), wiring and configuration will vary according to your specific board and available pins. Devi connettere ADXL345 al tuo Raspberry Pi tramite SPI. Si noti che la connessione I2C, suggerita dalla documentazione di ADXL345, ha un throughput troppo basso e non funzioner\u00e0 . Lo schema di connessione consigliato: ADXL345 pin RPi pin Nome pin RPi 3V3 (or VCC) 01 3.3V DC power GND 06 Ground CS 24 GPIO08 (SPI0_CE0_N) SDO 21 GPIO09 (SPI0_MISO) SDA 19 GPIO10 (SPI0_MOSI) SCL 23 GPIO11 (SPI0_SCLK) Schemi collegamenti Fritzing per alcune delle schede ADXL345:","title":"Diretto a Raspberry Pi"},{"location":"Measuring_Resonances.html#utilizzo-di-raspberry-pi-pico","text":"Puoi collegare ADXL345 al tuo Raspberry Pi Pico e quindi collegare Pico al tuo Raspberry Pi tramite USB. Ci\u00f2 semplifica il riutilizzo dell'accelerometro su altri dispositivi Klipper, poich\u00e9 puoi connetterti tramite USB anzich\u00e9 GPIO. Il Pico non ha molta potenza di elaborazione, quindi assicurati che stia solo eseguendo l'accelerometro e non svolga altre funzioni. Per evitare danni al tuo RPi assicurati di collegare l'ADXL345 solo a 3,3 V. A seconda del layout della scheda, potrebbe essere presente un cambio di livello, che rende i 5 V pericolosi per il tuo RPi. ADXL345 pin pin Pico Nome pin Pico 3V3 (or VCC) 36 3.3V DC power GND 38 Ground CS 2 GP1 (SPI0_CSn) SDO 1 GP0 (SPI0_RX) SDA 5 GP3 (SPI0_TX) SCL 4 GP2 (SPI0_SCK) Schemi di collegamento per alcune schede ADXL345:","title":"Utilizzo di Raspberry Pi Pico"},{"location":"Measuring_Resonances.html#accelerometri-i2c","text":"Suggested twisted pair order for three pairs (preferred): 3.3V+GND SDA+GND SCL+GND or for two pairs: 3.3V+SDA GND+SCL Note that unlike a cable shield, any GND(s) should be connected at both ends.","title":"Accelerometri I2C"},{"location":"Measuring_Resonances.html#mpu-9250mpu-9255mpu-6515mpu-6050mpu-6500","text":"These accelerometers have been tested to work over I2C on the RPi, RP2040 (Pico) and AVR at 400kbit/s ( fast mode ). Some MPU accelerometer modules include pull-ups, but some are too large at 10K and must be changed or supplemented by smaller parallel resistors. Schema di connessione consigliato per I2C su Raspberry Pi: pin MPU-9250 RPi pin Nome pin RPi VCC 01 3.3v alimentazione DC GND 09 Ground SDA 03 GPIO02 (SDA1) SCL 05 GPIO03 (SCL1) The RPi has buit-in 1.8K pull-ups on both SCL and SDA. Recommended connection scheme for I2C (i2c0a) on the RP2040: pin MPU-9250 pin RP2040 RP2040 pin name VCC 36 3v3 GND 38 Ground SDA 01 GP0 (I2C0 SDA) SCL 02 GP1 (I2C0 SCL) The Pico does not include any built-in I2C pull-up resistors.","title":"MPU-9250/MPU-9255/MPU-6515/MPU-6050/MPU-6500"},{"location":"Measuring_Resonances.html#recommended-connection-scheme-for-i2ctwi-on-the-avr-atmega328p-arduino-nano","text":"pin MPU-9250 Atmega328P TQFP32 pin Atmega328P pin name Arduino Nano pin VCC 39 - - GND 38 Ground GND SDA 27 SDA A4 SCL 28 SCL A5 The Arduino Nano does not include any built-in pull-up resistors nor a 3.3V power pin.","title":"Recommended connection scheme for I2C(TWI) on the AVR ATmega328P Arduino Nano:"},{"location":"Measuring_Resonances.html#montaggio-dellaccelerometro","text":"L'accelerometro deve essere collegato alla testa di stampa. \u00c8 necessario progettare un supporto adeguato che si adatti alla propria stampante 3D. \u00c8 meglio allineare gli assi dell'accelerometro con gli assi della stampante (ma se lo rende pi\u00f9 comodo, gli assi possono essere scambiati - cio\u00e8 non c'\u00e8 bisogno di allineare l'asse X con X e cos\u00ec via - dovrebbe andare bene anche se l'asse Z di l'accelerometro \u00e8 l'asse X della stampante, ecc.). Un esempio di montaggio di ADXL345 su SmartEffect: Si noti che su una stampante con piatto mobile \u00e8 necessario progettare 2 supporti: uno per la testina e uno per il piatto, ed eseguire le misurazioni due volte. Per maggiori dettagli, vedere la sezione corrispondente. Attenzione: assicurati che l'accelerometro e le eventuali viti che lo tengono in posizione non tocchino parti metalliche della stampante. Fondamentalmente, il supporto deve essere progettato in modo tale da garantire l'isolamento elettrico dell'accelerometro dal telaio della stampante. Non riuscendo a garantire che pu\u00f2 creare un loop di massa nel sistema che potrebbe danneggiare l'elettronica.","title":"Montaggio dell'accelerometro"},{"location":"Measuring_Resonances.html#installazione-software","text":"Si noti che le misurazioni della risonanza e la calibrazione automatica dello shaper richiedono dipendenze software aggiuntive non installate per impostazione predefinita. Innanzitutto, esegui sul tuo Raspberry Pi i seguenti comandi: sudo apt update sudo apt install python3-numpy python3-matplotlib libatlas-base-dev libopenblas-dev Quindi, per installare NumPy nell'ambiente Klipper, esegui il comando: ~/klippy-env/bin/pip install -v \"numpy<1.26\" Note that, depending on the performance of the CPU, it may take a lot of time, up to 10-20 minutes. Be patient and wait for the completion of the installation. On some occasions, if the board has too little RAM the installation may fail and you will need to enable swap. Also note the forced version, due to newer versions of NumPY having requirements that may not be satisfied in some klipper python environments. Once installed please check that no errors show from the command: ~/klippy-env/bin/python -c 'import numpy;' The correct output should simply be a new line.","title":"Installazione software"},{"location":"Measuring_Resonances.html#configura-adxl345-con-rpi","text":"First, check and follow the instructions in the RPi Microcontroller document to setup the \"linux mcu\" on the Raspberry Pi. This will configure a second Klipper instance that runs on your Pi. Assicurati che il driver SPI di Linux sia abilitato eseguendo sudo raspi-config e abilitando SPI nel menu \"Opzioni di interfaccia\". Aggiungere quanto segue al file printer.cfg: [mcu rpi] serial: /tmp/klipper_host_mcu [adxl345] cs_pin: rpi:None [resonance_tester] accel_chip: adxl345 probe_points: 100, 100, 20 # un esempio Si consiglia di iniziare con 1 punto sonda, al centro del piano di stampa, leggermente al di sopra di esso.","title":"Configura ADXL345 con RPi"},{"location":"Measuring_Resonances.html#configura-adxl345-con-pi-pico","text":"","title":"Configura ADXL345 con Pi Pico"},{"location":"Measuring_Resonances.html#aggiorna-il-firmware-pico","text":"Sul tuo Raspberry Pi, compila il firmware per Pico. cd ~/klipper make clean make menuconfig Ora, tenendo premuto il pulsante BOOTSEL sul Pico, collega il Pico al Raspberry Pi tramite USB. Compilare e eseguire il flashing del firmware. make flash FLASH_DEVICE=first Se fallisce, ti verr\u00e0 detto quale FLASH_DEVICE utilizzare. In questo esempio si tratta di make flash FLASH_DEVICE=2e8a:0003 .","title":"Aggiorna il firmware Pico"},{"location":"Measuring_Resonances.html#configura-la-connessione","text":"Il Pico ora si riavvier\u00e0 con il nuovo firmware e dovrebbe apparire come dispositivo seriale. Trova il dispositivo pico seriale con ls /dev/serial/by-id/* . Ora puoi aggiungere un file adxl.cfg con le seguenti impostazioni: [mcu adxl] # Cambia <mySerial> con quello che hai trovato sopra. Per esempio, # usb-Klipper_rp2040_E661640843545B2E-if00 serial: /dev/serial/by-id/usb-Klipper_rp2040_<mySerial> [adxl345] cs_pin: adxl:gpio1 spi_bus: spi0a axes_map: x,z,y [resonance_tester] accel_chip: adxl345 probe_points: # Da qualche parte leggermente sopra la met\u00e0 del piano di stampa 147,154, 20 [output_pin power_mode] #Migliora la stabilit\u00e0 dell' alimentazione pin: adxl:gpio23 Se imposti la configurazione di ADXL345 in un file separato, come mostrato sopra, ti consigliamo di modificare anche il file printer.cfg per includere questo: [include adxl.cfg] # Commenta questo quando scolleghi l'accelerometro Riavvia Klipper tramite il comando RESTART .","title":"Configura la connessione"},{"location":"Measuring_Resonances.html#configure-lis2dw-series-over-spi","text":"[mcu lis] # Change <mySerial> to whatever you found above. For example, # usb-Klipper_rp2040_E661640843545B2E-if00 serial: /dev/serial/by-id/usb-Klipper_rp2040_<mySerial> [lis2dw] cs_pin: lis:gpio1 spi_bus: spi0a axes_map: x,z,y [resonance_tester] accel_chip: lis2dw probe_points: # Somewhere slightly above the middle of your print bed 147,154, 20","title":"Configure LIS2DW series over SPI"},{"location":"Measuring_Resonances.html#configura-la-serie-mpu-60009000-con-rpi","text":"Assicurati che il driver Linux I2C sia abilitato e che la velocit\u00e0 di trasmissione sia impostata su 400000 (consulta la sezione Abilitazione di I2C per ulteriori dettagli). Quindi, aggiungi quanto segue a printer.cfg: [mcu rpi] serial: /tmp/klipper_host_mcu [mpu9250] i2c_mcu: rpi i2c_bus: i2c.1 [resonance_tester] accel_chip: mpu9250 probe_points: 100, 100, 20 # un esempio","title":"Configura la serie MPU-6000/9000 con RPi"},{"location":"Measuring_Resonances.html#configure-mpu-9520-compatibles-with-pico","text":"Pico I2C is set to 400000 on default. Simply add the following to the printer.cfg: [mcu pico] serial: /dev/serial/by-id/<your Pico's serial ID> [mpu9250] i2c_mcu: pico i2c_bus: i2c0a [resonance_tester] accel_chip: mpu9250 probe_points: 100, 100, 20 # an example [static_digital_output pico_3V3pwm] # Improve power stability pins: pico:gpio23","title":"Configure MPU-9520 Compatibles With Pico"},{"location":"Measuring_Resonances.html#configure-mpu-9520-compatibles-with-avr","text":"AVR I2C will be set to 400000 by the mpu9250 option. Simply add the following to the printer.cfg: [mcu nano] serial: /dev/serial/by-id/<your nano's serial ID> [mpu9250] i2c_mcu: nano [resonance_tester] accel_chip: mpu9250 probe_points: 100, 100, 20 # an example Riavvia Klipper tramite il comando RESTART .","title":"Configure MPU-9520 Compatibles with AVR"},{"location":"Measuring_Resonances.html#misurare-le-risonanze","text":"","title":"Misurare le risonanze"},{"location":"Measuring_Resonances.html#controllo-della-configurazione","text":"Ora puoi testare una connessione. Per \"per piatti non scorrevoli\" (es. un accelerometro), in Octoprint, inserisci ACCELEROMETER_QUERY Per \"piatti scorrevoli\" (ad es. pi\u00f9 di un accelerometro), immettere ACCELEROMETER_QUERY CHIP=<chip> dove <chip> \u00e8 il nome del chip immesso, ad es. CHIP=piatto (vedi: bed-slinger ) per tutti i chip dell'accelerometro installati. Dovresti vedere le misurazioni attuali dall'accelerometro, inclusa l'accelerazione di caduta libera, ad es. Recv: // adxl345 values (x, y, z): 470.719200, 941.438400, 9728.196800 Se ricevi un errore del tipo ID adxl345 non valido (ottenuto xx vs e5) , dove xx \u00e8 un altro ID, riprova immediatamente. Si \u00e8 verificato un problema con l'inizializzazione SPI. Se ricevi ancora un errore, \u00e8 indicativo del problema di connessione con ADXL345 o del sensore difettoso. Ricontrolla l'alimentazione, il cablaggio (che corrisponda agli schemi, nessun filo sia rotto o allentato, ecc.) e la qualit\u00e0 della saldatura. If you are using a MPU-9250 compatible accelerometer and it shows up as mpu-unknown , use with caution! They are probably refurbished chips! Quindi, prova a eseguire MEASURE_AXES_NOISE in Octoprint, dovresti ottenere alcuni numeri di riferimento per il rumore dell'accelerometro sugli assi (dovrebbe essere compreso tra ~1-100). Un rumore degli assi troppo elevato (ad es. 1000 e pi\u00f9) pu\u00f2 essere indicativo di problemi con il sensore, problemi con la sua alimentazione o ventole sbilanciate troppo rumorose su una stampante 3D.","title":"Controllo della configurazione"},{"location":"Measuring_Resonances.html#misurare-le-risonanze_1","text":"Ora puoi eseguire alcuni test realistici. Esegui il seguente comando: TEST_RESONANCES AXIS=X Nota che creer\u00e0 vibrazioni sull'asse X. Disabiliter\u00e0 anche l'input shaping se era stato abilitato in precedenza, poich\u00e9 non \u00e8 valido eseguire il test di risonanza con l'input shaper abilitato. Attenzione! Assicurati di osservare la stampante per la prima volta, per assicurarti che le vibrazioni non diventino troppo violente (il comando M112 pu\u00f2 essere utilizzato per interrompere il test in caso di emergenza; si spera che non si verifichi questo per\u00f2). Se le vibrazioni diventano troppo forti, puoi provare a specificare un valore inferiore al valore predefinito per il parametro accel_per_hz nella sezione [resonance_tester] , ad es. [resonance_tester] accel_chip: adxl345 accel_per_hz: 50 # default \u00e8 75 probe_points: ... Se funziona per l'asse X, esegui anche per l'asse Y: TEST_RESONANCES AXIS=Y This will generate 2 CSV files ( /tmp/resonances_x_*.csv and /tmp/resonances_y_*.csv ). These files can be processed with the stand-alone script on a Raspberry Pi. This script is intended to be run with a single CSV file for each axis measured, although it can be used with multiple CSV files if you desire to average the results. Averaging results can be useful, for example, if resonance tests were done at multiple test points. Delete the extra CSV files if you do not desire to average them. ~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o /tmp/shaper_calibrate_x.png ~/klipper/scripts/calibrate_shaper.py /tmp/resonances_y_*.csv -o /tmp/shaper_calibrate_y.png Questo script generer\u00e0 i grafici /tmp/shaper_calibrate_x.png e /tmp/shaper_calibrate_y.png con le risposte in frequenza. Riceverai anche le frequenze suggerite per ogni input shaper, nonch\u00e9 quale input shaper \u00e8 consigliato per la tua configurazione. Per esempio: Fitted shaper 'zv' frequency = 34.4 Hz (vibrations = 4.0%, smoothing ~= 0.132) To avoid too much smoothing with 'zv', suggested max_accel <= 4500 mm/sec^2 Fitted shaper 'mzv' frequency = 34.6 Hz (vibrations = 0.0%, smoothing ~= 0.170) To avoid too much smoothing with 'mzv', suggested max_accel <= 3500 mm/sec^2 Fitted shaper 'ei' frequency = 41.4 Hz (vibrations = 0.0%, smoothing ~= 0.188) To avoid too much smoothing with 'ei', suggested max_accel <= 3200 mm/sec^2 Fitted shaper '2hump_ei' frequency = 51.8 Hz (vibrations = 0.0%, smoothing ~= 0.201) To avoid too much smoothing with '2hump_ei', suggested max_accel <= 3000 mm/sec^2 Fitted shaper '3hump_ei' frequency = 61.8 Hz (vibrations = 0.0%, smoothing ~= 0.215) To avoid too much smoothing with '3hump_ei', suggested max_accel <= 2800 mm/sec^2 Recommended shaper is mzv @ 34.6 Hz La configurazione suggerita pu\u00f2 essere aggiunta alla sezione [input_shaper] di printer.cfg , ad esempio: [input_shaper] shaper_freq_x: ... shaper_type_x: ... shaper_freq_y: 34.6 shaper_type_y: mzv [printer] max_accel: 3000 # non dovrebbe superare il max_accel stimato per gli assi X e Y oppure puoi scegliere tu stesso un'altra configurazione in base ai grafici generati: i picchi nella densit\u00e0 spettrale di potenza sui grafici corrispondono alle frequenze di risonanza della stampante. Nota che in alternativa puoi eseguire la calibrazione automatica dell input shaper da Klipper directly , che pu\u00f2 essere conveniente, ad esempio, per la re-calibration .","title":"Misurare le risonanze"},{"location":"Measuring_Resonances.html#stampanti-con-piatto-scorrevole","text":"Se la tua stampante ha un piatto scorrevole, dovrai cambiare la posizione dell'accelerometro tra le misurazioni per gli assi X e Y: misurare le risonanze dell'asse X con l'accelerometro collegato alla testa di stampa e le risonanze dell'asse Y - al piatto. However, you can also connect two accelerometers simultaneously, though the ADXL345 must be connected to different boards (say, to an RPi and printer MCU board), or to two different physical SPI interfaces on the same board (rarely available). Then they can be configured in the following manner: [adxl345 hotend] # Supponendo che il chip \"hotend\" sia collegato a un RPi cs_pin: rpi:None [adxl345 bed] # Supponendo che il chip `bed` sia collegato a una scheda MCU della stampante cs_pin: ... # Pin di selezione chip SPI (CS) della scheda stampante [resonance_tester] # Assumendo la configurazione tipo della stampante con piatto scorrevole accel_chip_x: adxl345 hotend accel_chip_y: adxl345 bed probe_points: ... Two MPUs can share one I2C bus, but they cannot measure simultaneously as the 400kbit/s I2C bus is not fast enough. One must have its AD0 pin pulled-down to 0V (address 104) and the other its AD0 pin pulled-up to 3.3V (address 105): [mpu9250 hotend] i2c_mcu: rpi i2c_bus: i2c.1 i2c_address: 104 # This MPU has pin AD0 pulled low [mpu9250 bed] i2c_mcu: rpi i2c_bus: i2c.1 i2c_address: 105 # This MPU has pin AD0 pulled high [resonance_tester] # Assuming the typical setup of the bed slinger printer accel_chip_x: mpu9250 hotend accel_chip_y: mpu9250 bed probe_points: ... [Test with each MPU individually before connecting both to the bus for easy debugging.] Quindi i comandi TEST_RESONANCES AXIS=X e TEST_RESONANCES AXIS=Y utilizzeranno l'accelerometro corretto per ciascun asse.","title":"Stampanti con piatto scorrevole"},{"location":"Measuring_Resonances.html#max-smoothing","text":"Tieni presente che lo input shaper pu\u00f2 creare un po' di smoothing nelle parti. La regolazione automatica del input shaper eseguita dallo script calibrate_shaper.py o dal comando SHAPER_CALIBRATE cercano di non esacerbare lo smoothing, ma allo stesso tempo cercano di ridurre al minimo le vibrazioni risultanti. A volte possono fare una scelta non ottimale della frequenza dello shaper, o forse semplicemente preferisci avere meno smoothing in alcune parti a scapito di maggiori vibrazioni residue. In questi casi \u00e8 possibile richiedere di limitare lo smoothing massimo dal input shaper. Consideriamo i seguenti risultati della sintonizzazione automatica: Fitted shaper 'zv' frequency = 57.8 Hz (vibrations = 20.3%, smoothing ~= 0.053) To avoid too much smoothing with 'zv', suggested max_accel <= 13000 mm/sec^2 Fitted shaper 'mzv' frequency = 34.8 Hz (vibrations = 3.6%, smoothing ~= 0.168) To avoid too much smoothing with 'mzv', suggested max_accel <= 3600 mm/sec^2 Fitted shaper 'ei' frequency = 48.8 Hz (vibrations = 4.9%, smoothing ~= 0.135) To avoid too much smoothing with 'ei', suggested max_accel <= 4400 mm/sec^2 Fitted shaper '2hump_ei' frequency = 45.2 Hz (vibrations = 0.1%, smoothing ~= 0.264) To avoid too much smoothing with '2hump_ei', suggested max_accel <= 2200 mm/sec^2 Fitted shaper '3hump_ei' frequency = 48.0 Hz (vibrations = 0.0%, smoothing ~= 0.356) To avoid too much smoothing with '3hump_ei', suggested max_accel <= 1500 mm/sec^2 Recommended shaper is 2hump_ei @ 45.2 Hz Si noti che i valori di smoothing riportati sono alcuni valori proiettati. Questi valori possono essere utilizzati per confrontare diverse configurazioni: maggiore \u00e8 il valore, maggiore sar\u00e0 la levigatura creata da uno shaper. Tuttavia, questi punteggi di smoothing non rappresentano alcuna misura reale dello smoothing, perch\u00e9 lo smoothing effettivo dipende dai parametri max_accel e square_corner_velocity . Pertanto, \u00e8 necessario eseguire alcune stampe di prova per vedere quanta smoothing crea esattamente una configurazione scelta. Nell'esempio sopra i parametri dello shaper suggeriti non sono male, ma cosa succede se si desidera ottenere meno smooting sull'asse X? Puoi provare a limitare lo smoothing massimo dello shaper usando il seguente comando: ~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o /tmp/shaper_calibrate_x.png --max_smoothing=0.2 che limita lo smoothing a un punteggio di 0.2. Ora puoi ottenere il seguente risultato: Fitted shaper 'zv' frequency = 55.4 Hz (vibrations = 19.7%, smoothing ~= 0.057) To avoid too much smoothing with 'zv', suggested max_accel <= 12000 mm/sec^2 Fitted shaper 'mzv' frequency = 34.6 Hz (vibrations = 3.6%, smoothing ~= 0.170) To avoid too much smoothing with 'mzv', suggested max_accel <= 3500 mm/sec^2 Fitted shaper 'ei' frequency = 48.2 Hz (vibrations = 4.8%, smoothing ~= 0.139) To avoid too much smoothing with 'ei', suggested max_accel <= 4300 mm/sec^2 Fitted shaper '2hump_ei' frequency = 52.0 Hz (vibrations = 2.7%, smoothing ~= 0.200) To avoid too much smoothing with '2hump_ei', suggested max_accel <= 3000 mm/sec^2 Fitted shaper '3hump_ei' frequency = 72.6 Hz (vibrations = 1.4%, smoothing ~= 0.155) To avoid too much smoothing with '3hump_ei', suggested max_accel <= 3900 mm/sec^2 Recommended shaper is 3hump_ei @ 72.6 Hz Se si confronta con i parametri suggeriti in precedenza, le vibrazioni sono un po' maggiori, ma lo smoothing \u00e8 notevolmente inferiore rispetto a prima, consentendo un'accelerazione massima maggiore. Quando si decide quale parametro max_smoothing scegliere, \u00e8 possibile utilizzare un approccio per tentativi. Prova alcuni valori diversi e guarda quali risultati ottieni. Si noti che lo smoothing effettivo prodotto dall'input shaper dipende principalmente dalla frequenza di risonanza pi\u00f9 bassa della stampante: maggiore \u00e8 la frequenza della risonanza pi\u00f9 bassa, minore \u00e8 lo smoothing. Pertanto, se si richiede allo script di trovare una configurazione dell'input shaper con lo smoothing irrealisticamente piccolo, sar\u00e0 a scapito di un aumento del ringing alle frequenze di risonanza pi\u00f9 basse (che sono, in genere, anche pi\u00f9 visibili nelle stampe). Quindi, ricontrolla sempre le vibrazioni rimanenti previste riportate dallo script e assicurati che non siano troppo alte. Nota che se hai scelto un buon valore max_smoothing per entrambi gli assi, puoi salvarlo in printer.cfg come [resonance_tester] accel_chip: ... probe_points: ... max_smoothing: 0.25 # un esempio Quindi, se riesegui l'autotuning dello shaper di input usando il comando Klipper SHAPER_CALIBRATE in futuro, utilizzer\u00e0 il valore max_smoothing memorizzato come riferimento.","title":"Max smoothing"},{"location":"Measuring_Resonances.html#seleziona-max_accel","text":"Poich\u00e9 l'input shaper pu\u00f2 creare un po' di smussamento nelle parti, specialmente ad accelerazioni elevate, sar\u00e0 comunque necessario scegliere il valore max_accel che non crei troppo smussamento \"smoothing\" nelle parti stampate. Uno script di calibrazione fornisce una stima per il parametro max_accel che non dovrebbe creare un smoothing eccessivo. Si noti che il max_accel visualizzato dallo script di calibrazione \u00e8 solo un massimo teorico al quale il rispettivo shaper \u00e8 ancora in grado di lavorare senza produrre troppo smoothing. Non \u00e8 affatto una raccomandazione impostare questa accelerazione per la stampa. L'accelerazione massima che la stampante \u00e8 in grado di sostenere dipende dalle sue propriet\u00e0 meccaniche e dalla coppia massima dei motori passo-passo utilizzati. Pertanto, si suggerisce di impostare max_accel nella sezione [printer] che non superi i valori stimati per gli assi X e Y, probabilmente con un margine di sicurezza conservativo. In alternativa, segui questa parte della guida all'ottimizzazione dello input shaper e stampa il modello di test per scegliere sperimentalmente il parametro max_accel . Lo stesso avviso vale per lo input shaper auto-calibration con il comando SHAPER_CALIBRATE : \u00e8 comunque necessario scegliere il giusto valore di max_accel dopo l'auto-calibrazione, e il i limiti di accelerazione non verranno applicati automaticamente. Keep in mind that the maximum acceleration without too much smoothing depends on the square_corner_velocity . The general recommendation is not to change it from its default value 5.0, and this is the value used by default by the calibrate_shaper.py script. If you did change it though, you should inform the script about it by passing --square_corner_velocity=... parameter, e.g. ~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o /tmp/shaper_calibrate_x.png --square_corner_velocity=10.0 so that it can calculate the maximum acceleration recommendations correctly. Note that the SHAPER_CALIBRATE command already takes the configured square_corner_velocity parameter into account, and there is no need to specify it explicitly. Se stai eseguendo una ricalibrazione dello shaper e lo smoothing riportato per la configurazione dello shaper suggerita \u00e8 quasi lo stesso di quello ottenuto durante la calibrazione precedente, questo passaggio pu\u00f2 essere saltato.","title":"Seleziona max_accel"},{"location":"Measuring_Resonances.html#unreliable-measurements-of-resonance-frequencies","text":"Sometimes the resonance measurements can produce bogus results, leading to the incorrect suggestions for the input shapers. This can be caused by a variety of reasons, including running fans on the toolhead, incorrect position or non-rigid mounting of the accelerometer, or mechanical problems such as loose belts or binding or bumpy axis. Keep in mind that all fans should be disabled for resonance testing, especially the noisy ones, and that the accelerometer should be rigidly mounted on the corresponding moving part (e.g. on the bed itself for the bed slinger, or on the extruder of the printer itself and not the carriage, and some people get better results by mounting the accelerometer on the nozzle itself). As for mechanical problems, the user should inspect if there is any fault that can be fixed with a moving axis (e.g. linear guide rails cleaned up and lubricated and V-slot wheels tension adjusted correctly). If none of that helps, a user may try the other shapers from the produced list besides the one recommended by default.","title":"Unreliable measurements of resonance frequencies"},{"location":"Measuring_Resonances.html#test-di-assi-personalizzati","text":"Il comando TEST_RESONANCES supporta assi personalizzati. Anche se questo non \u00e8 molto utile per la calibrazione del input shaper, pu\u00f2 essere utilizzato per studiare in profondit\u00e0 le risonanze della stampante e per controllare, ad esempio, la tensione della cinghia. Per controllare la tensione della cinghia sulle stampanti CoreXY, eseguire TEST_RESONANCES AXIS=1,1 OUTPUT=raw_data TEST_RESONANCES AXIS=1,-1 OUTPUT=raw_data e usa graph_accelerometer.py per elaborare i file generati, ad es. ~/klipper/scripts/graph_accelerometer.py -c /tmp/raw_data_axis*.csv -o /tmp/resonances.png che generer\u00e0 /tmp/resonances.png confrontando le risonanze. Per le stampanti Delta con la posizione della torre predefinita (torre A ~= 210 gradi, B ~= 330 gradi e C ~= 90 gradi), eseguire TEST_RESONANCES AXIS=0,1 OUTPUT=raw_data TEST_RESONANCES AXIS=-0.866025404,-0.5 OUTPUT=raw_data TEST_RESONANCES AXIS=0.866025404,-0.5 OUTPUT=raw_data e quindi utilizzare lo stesso comando ~/klipper/scripts/graph_accelerometer.py -c /tmp/raw_data_axis*.csv -o /tmp/resonances.png per generare /tmp/resonances.png confrontando le risonanze.","title":"Test di assi personalizzati"},{"location":"Measuring_Resonances.html#calibrazione-automatica-input-shaper","text":"Oltre a scegliere manualmente i parametri appropriati per la funzione di input shaper, \u00e8 anche possibile eseguire l'autotuning per l'input shaper direttamente da Klipper. Esegui il seguente comando tramite il terminale Octoprint: SHAPER_CALIBRATE Questo eseguir\u00e0 il test completo per entrambi gli assi e generer\u00e0 l'output csv ( /tmp/calibration_data_*.csv per impostazione predefinita) per la risposta in frequenza e gli input shaper suggeriti. Riceverai anche le frequenze suggerite per ciascun input shaper, nonch\u00e9 quale input shaper \u00e8 consigliato per la tua configurazione, sulla console Octoprint. Per esempio: Calculating the best input shaper parameters for y axis Fitted shaper 'zv' frequency = 39.0 Hz (vibrations = 13.2%, smoothing ~= 0.105) To avoid too much smoothing with 'zv', suggested max_accel <= 5900 mm/sec^2 Fitted shaper 'mzv' frequency = 36.8 Hz (vibrations = 1.7%, smoothing ~= 0.150) To avoid too much smoothing with 'mzv', suggested max_accel <= 4000 mm/sec^2 Fitted shaper 'ei' frequency = 36.6 Hz (vibrations = 2.2%, smoothing ~= 0.240) To avoid too much smoothing with 'ei', suggested max_accel <= 2500 mm/sec^2 Fitted shaper '2hump_ei' frequency = 48.0 Hz (vibrations = 0.0%, smoothing ~= 0.234) To avoid too much smoothing with '2hump_ei', suggested max_accel <= 2500 mm/sec^2 Fitted shaper '3hump_ei' frequency = 59.0 Hz (vibrations = 0.0%, smoothing ~= 0.235) To avoid too much smoothing with '3hump_ei', suggested max_accel <= 2500 mm/sec^2 Recommended shaper_type_y = mzv, shaper_freq_y = 36.8 Hz Se sei d'accordo con i parametri suggeriti, puoi eseguire ora SAVE_CONFIG per salvarli e riavviare Klipper. Nota che questo non aggiorner\u00e0 il valore max_accel nella sezione [printer] . Dovresti aggiornarlo manualmente seguendo le considerazioni nella sezione Selecting max_accel . Se la tua stampante \u00e8 una stampante a piatto mobile, puoi specificare quale asse testare, in modo da poter cambiare il punto di montaggio dell'accelerometro tra i test (per impostazione predefinita, il test viene eseguito per entrambi gli assi): SHAPER_CALIBRATE AXIS=Y \u00c8 possibile eseguire SAVE_CONFIG due volte, dopo aver calibrato ciascun asse. Tuttavia, se hai collegato due accelerometri contemporaneamente, esegui semplicemente SHAPER_CALIBRATE senza specificare un asse per calibrare l' input shaper per entrambi gli assi in una volta sola.","title":"Calibrazione automatica Input Shaper"},{"location":"Measuring_Resonances.html#input-shaper-ricalibrazione","text":"Il comando SHAPER_CALIBRATE pu\u00f2 essere utilizzato anche per ricalibrare lo shaper di input in futuro, specialmente se vengono apportate alcune modifiche alla stampante che possono influire sulla sua cinematica. \u00c8 possibile eseguire nuovamente la calibrazione completa utilizzando il comando SHAPER_CALIBRATE , o limitare l'autocalibrazione a un singolo asse fornendo il parametro AXIS= , come SHAPER_CALIBRATE AXIS=X Attenzione! Non \u00e8 consigliabile eseguire la calibrazione automatica del modellatore molto frequentemente (ad esempio prima di ogni stampa o ogni giorno). Per determinare le frequenze di risonanza, l'autocalibrazione crea vibrazioni intense su ciascuno degli assi. Generalmente le stampanti 3D non sono progettate per resistere ad un\u2019esposizione prolungata a vibrazioni vicine alle frequenze di risonanza. Ci\u00f2 potrebbe aumentare l'usura dei componenti della stampante e ridurne la durata. Esiste anche un rischio maggiore che alcune parti si svitino o si allentino. Controllare sempre che tutte le parti della stampante (comprese quelle che normalmente potrebbero non muoversi) siano fissate saldamente in posizione dopo ogni regolazione automatica. Inoltre, a causa di un po' di rumore nelle misurazioni, \u00e8 possibile che i risultati dell'ottimizzazione siano leggermente diversi da una calibrazione all'altra. Tuttavia, non ci si aspetta che il rumore influisca troppo sulla qualit\u00e0 di stampa. Tuttavia, si consiglia comunque di ricontrollare i parametri suggeriti e di stampare alcune stampe di prova prima di utilizzarli per confermare che siano corretti.","title":"Input Shaper ricalibrazione"},{"location":"Measuring_Resonances.html#elaborazione-offline-dei-dati-dellaccelerometro","text":"\u00c8 possibile generare i dati grezzi dell'accelerometro ed elaborarli offline (ad esempio su una macchina host), ad esempio per trovare risonanze. Per fare ci\u00f2, esegui i seguenti comandi tramite il terminale Octoprint: SET_INPUT_SHAPER SHAPER_FREQ_X=0 SHAPER_FREQ_Y=0 TEST_RESONANCES AXIS=X OUTPUT=raw_data ignorando eventuali errori per il comando SET_INPUT_SHAPER . Per il comando TEST_RESONANCES , specificare l'asse di test desiderato. I dati grezzi verranno scritti nella directory /tmp sull'RPi. I dati grezzi possono anche essere ottenuti eseguendo il comando ACCELEROMETER_MEASURE due volte durante una normale attivit\u00e0 della stampante: prima per avviare le misurazioni, quindi per interromperle e scrivere il file di output. Fare riferimento a G-Codes per maggiori dettagli. I dati possono essere elaborati successivamente dai seguenti script: scripts/graph_accelerometer.py e scripts/calibrate_shaper.py . Entrambi accettano uno o pi\u00f9 file CSV non elaborati come input a seconda della modalit\u00e0. Lo script graph_accelerometer.py supporta diverse modalit\u00e0 operative: tracciando i dati grezzi dell'accelerometro (usa il parametro -r ), \u00e8 supportato solo 1 input; tracciando una risposta in frequenza (non sono richiesti parametri aggiuntivi), se sono specificati pi\u00f9 ingressi, viene calcolata la risposta in frequenza media; confronto della risposta in frequenza tra pi\u00f9 ingressi (usare il parametro -c ); puoi inoltre specificare quale asse dell'accelerometro considerare tramite il parametro -a x , -a y o -a z (se non specificato, viene utilizzata la somma delle vibrazioni per tutti gli assi); tracciando lo spettrogramma (usare il parametro -s ), \u00e8 supportato solo 1 input; \u00e8 inoltre possibile specificare quale asse dell'accelerometro considerare tramite il parametro -a x , -a y o -a z (se non specificato, viene utilizzata la somma delle vibrazioni per tutti gli assi). Si noti che lo script graph_accelerometer.py supporta solo i file raw_data*.csv e non i file resonances*.csv o calibration_data*.csv. Per esempio, ~/klipper/scripts/graph_accelerometer.py /tmp/raw_data_x_*.csv -o /tmp/resonances_x.png -c -a z traccer\u00e0 il confronto di diversi file /tmp/raw_data_x_*.csv per l'asse Z con il file /tmp/resonances_x.png . Lo script shaper_calibrate.py accetta 1 o pi\u00f9 input e pu\u00f2 eseguire l'ottimizzazione automatica dello shaper di input e suggerire i parametri migliori che funzionano bene per tutti gli input forniti. Stampa i parametri suggeriti sulla console e pu\u00f2 inoltre generare il grafico se viene fornito il parametro -o output.png , o il file CSV se viene specificato il parametro -c output.csv . Fornire diversi input allo script shaper_calibrate.py pu\u00f2 essere utile se si esegue un'ottimizzazione avanzata degli shaper di input, ad esempio: Esecuzione di TEST_RESONANCES AXIS=X OUTPUT=raw_data (e asse Y ) per un singolo asse due volte su una stampante con piatto scorrevole con l'accelerometro collegato alla testa di stampa la prima volta e l'accelerometro collegato al piatto la seconda volta in modo da rilevare le risonanze incrociate degli assi e tentare di cancellarle con gli input shaper. Esecuzione di TEST_RESONANCES AXIS=Y OUTPUT=raw_data due volte su un supporto da piatto con un piatto di vetro e una superficie magnetica (che \u00e8 pi\u00f9 leggera) per trovare i parametri dello shaper di input che funzionano bene per qualsiasi configurazione della superficie di stampa. Combinazione dei dati di risonanza da pi\u00f9 punti di test. Combinando i dati di risonanza da 2 assi (ad es. su una stampante con piatto scorrevole per configurare input_shaper dell'asse X dalle risonanze degli assi X e Y per annullare le vibrazioni del piatto nel caso in cui l'ugello \"cattura\" una stampa quando si sposta nella direzione dell'asse X ).","title":"Elaborazione offline dei dati dell'accelerometro"},{"location":"Multi_MCU_Homing.html","text":"Homing e Probing con microcontrollore multiplo \u00b6 Klipper sopporta un meccanismo per homing con un fine corsa collegato a un micro controllore mentre i motori passo-passo sono collegati ad un controllore diverso. Questa modalit\u00e0 \u00e8 definita Homing multi-mcu. Questa funzione \u00e8 usata quando una sonda Z \u00e8 collegata ad un differente controllore rispetto ai motori dell'asse Z. Questa funzione pu\u00f2 essere utile per semplificare il cablaggio, poich\u00e9 potrebbe essere pi\u00f9 conveniente collegare un finecorsa o una sonda a un microcontrollore pi\u00f9 vicino. Tuttavia, l'utilizzo di questa funzione pu\u00f2 comportare un \"overshoot\" dei motori passo-passo durante le operazioni di homing o con sonda. L' 'overshoot' si verifica a causa di possibili ritardi nella trasmissione del messaggio tra il microcontrollore che controlla il finecorsa e i microcontrollori che muovono i motori passo-passo. Il codice Klipper \u00e8 progettato per limitare questo ritardo a non pi\u00f9 di 25 ms. (Quando \u00e8 attivato l'homing multi-mcu, i microcontrollori inviano messaggi di stato periodici e controllano che i messaggi di stato corrispondenti vengano ricevuti entro 25 ms.) Quindi, ad esempio, se si esegue l'homing a 10 mm/s, \u00e8 possibile un superamento fino a 0,250 mm (10 mm/s * .025s == 0,250 mm). \u00c8 necessario prestare attenzione durante la configurazione dell'homing multi-mcu per tenere conto di questo tipo di overshoot. L'uso di velocit\u00e0 di riferimento o di sonda pi\u00f9 lente pu\u00f2 ridurre la sovraelongazione (overshot). La sovraelongazione 'overshot' del motore passo-passo non dovrebbe influire negativamente sulla precisione della procedura di homing e di sonda. Il codice Klipper rilever\u00e0 il superamento e ne terr\u00e0 conto nei suoi calcoli. Tuttavia, \u00e8 importante che il design dell'hardware sia in grado di gestire l'overshoot senza causare danni alla macchina. In order to use this \"multi-mcu homing\" capability the hardware must have predictably low latency between the host computer and all of the micro-controllers. Typically the round-trip time must be consistently less than 10ms. High latency (even for short periods) is likely to result in homing failures. Should high latency result in a failure (or if some other communication issue is detected) then Klipper will raise a \"Communication timeout during homing\" error. Si noti che un asse con pi\u00f9 stepper (ad esempio, stepper_z e stepper_z1 ) deve trovarsi sullo stesso microcontrollore per poter utilizzare l'homing multi-mcu. Ad esempio, se un endstop si trova su un microcontrollore separato da stepper_z allora stepper_z1 deve trovarsi sullo stesso microcontrollore di stepper_z .","title":"Homing e Probing con microcontrollore multiplo"},{"location":"Multi_MCU_Homing.html#homing-e-probing-con-microcontrollore-multiplo","text":"Klipper sopporta un meccanismo per homing con un fine corsa collegato a un micro controllore mentre i motori passo-passo sono collegati ad un controllore diverso. Questa modalit\u00e0 \u00e8 definita Homing multi-mcu. Questa funzione \u00e8 usata quando una sonda Z \u00e8 collegata ad un differente controllore rispetto ai motori dell'asse Z. Questa funzione pu\u00f2 essere utile per semplificare il cablaggio, poich\u00e9 potrebbe essere pi\u00f9 conveniente collegare un finecorsa o una sonda a un microcontrollore pi\u00f9 vicino. Tuttavia, l'utilizzo di questa funzione pu\u00f2 comportare un \"overshoot\" dei motori passo-passo durante le operazioni di homing o con sonda. L' 'overshoot' si verifica a causa di possibili ritardi nella trasmissione del messaggio tra il microcontrollore che controlla il finecorsa e i microcontrollori che muovono i motori passo-passo. Il codice Klipper \u00e8 progettato per limitare questo ritardo a non pi\u00f9 di 25 ms. (Quando \u00e8 attivato l'homing multi-mcu, i microcontrollori inviano messaggi di stato periodici e controllano che i messaggi di stato corrispondenti vengano ricevuti entro 25 ms.) Quindi, ad esempio, se si esegue l'homing a 10 mm/s, \u00e8 possibile un superamento fino a 0,250 mm (10 mm/s * .025s == 0,250 mm). \u00c8 necessario prestare attenzione durante la configurazione dell'homing multi-mcu per tenere conto di questo tipo di overshoot. L'uso di velocit\u00e0 di riferimento o di sonda pi\u00f9 lente pu\u00f2 ridurre la sovraelongazione (overshot). La sovraelongazione 'overshot' del motore passo-passo non dovrebbe influire negativamente sulla precisione della procedura di homing e di sonda. Il codice Klipper rilever\u00e0 il superamento e ne terr\u00e0 conto nei suoi calcoli. Tuttavia, \u00e8 importante che il design dell'hardware sia in grado di gestire l'overshoot senza causare danni alla macchina. In order to use this \"multi-mcu homing\" capability the hardware must have predictably low latency between the host computer and all of the micro-controllers. Typically the round-trip time must be consistently less than 10ms. High latency (even for short periods) is likely to result in homing failures. Should high latency result in a failure (or if some other communication issue is detected) then Klipper will raise a \"Communication timeout during homing\" error. Si noti che un asse con pi\u00f9 stepper (ad esempio, stepper_z e stepper_z1 ) deve trovarsi sullo stesso microcontrollore per poter utilizzare l'homing multi-mcu. Ad esempio, se un endstop si trova su un microcontrollore separato da stepper_z allora stepper_z1 deve trovarsi sullo stesso microcontrollore di stepper_z .","title":"Homing e Probing con microcontrollore multiplo"},{"location":"Navigation.html","text":"Documentazione Klipper Installazione e configurazione Riferimenti di configurazione Livello del piatto Compensazione della risonanza Template dei comandi Documentazione per sviluppatori Documenti specifici del dispositivo","title":"Navigation"},{"location":"OctoPrint.html","text":"OctoPrint for Klipper \u00b6 Klipper has a few options for its front ends, Octoprint was the first and original front end for Klipper. This document will give a brief overview of installing with this option. Install with OctoPi \u00b6 Start by installing OctoPi on the Raspberry Pi computer. Use OctoPi v0.17.0 or later - see the OctoPi releases for release information. One should verify that OctoPi boots and that the OctoPrint web server works. After connecting to the OctoPrint web page, follow the prompt to upgrade OctoPrint if needed. After installing OctoPi and upgrading OctoPrint, it will be necessary to ssh into the target machine to run a handful of system commands. Start by running these commands on your host device: If you do not have git installed, please do so with: sudo apt install git then proceed: cd ~ git clone https://github.com/Klipper3d/klipper ./klipper/scripts/install-octopi.sh The above will download Klipper, install the needed system dependencies, setup Klipper to run at system startup, and start the Klipper host software. It will require an internet connection and it may take a few minutes to complete. Installing with KIAUH \u00b6 KIAUH can be used to install OctoPrint on a variety of Linux based systems that run a form of Debian. More information can be found at https://github.com/dw-0/kiauh Configuring OctoPrint to use Klipper \u00b6 The OctoPrint web server needs to be configured to communicate with the Klipper host software. Using a web browser, login to the OctoPrint web page and then configure the following items: Navigate to the Settings tab (the wrench icon at the top of the page). Under \"Serial Connection\" in \"Additional serial ports\" add: ~/printer_data/comms/klippy.serial Then click \"Save\". In some older setups this address may be /tmp/printer Enter the Settings tab again and under \"Serial Connection\" change the \"Serial Port\" setting to the one added above. In the Settings tab, navigate to the \"Behavior\" sub-tab and select the \"Cancel any ongoing prints but stay connected to the printer\" option. Click \"Save\". From the main page, under the \"Connection\" section (at the top left of the page) make sure the \"Serial Port\" is set to the new additional one added and click \"Connect\". (If it is not in the available selection then try reloading the page.) Once connected, navigate to the \"Terminal\" tab and type \"status\" (without the quotes) into the command entry box and click \"Send\". The terminal window will likely report there is an error opening the config file - that means OctoPrint is successfully communicating with Klipper. Please proceed to and the Building and flashing the micro-controller section","title":"OctoPrint for Klipper"},{"location":"OctoPrint.html#octoprint-for-klipper","text":"Klipper has a few options for its front ends, Octoprint was the first and original front end for Klipper. This document will give a brief overview of installing with this option.","title":"OctoPrint for Klipper"},{"location":"OctoPrint.html#install-with-octopi","text":"Start by installing OctoPi on the Raspberry Pi computer. Use OctoPi v0.17.0 or later - see the OctoPi releases for release information. One should verify that OctoPi boots and that the OctoPrint web server works. After connecting to the OctoPrint web page, follow the prompt to upgrade OctoPrint if needed. After installing OctoPi and upgrading OctoPrint, it will be necessary to ssh into the target machine to run a handful of system commands. Start by running these commands on your host device: If you do not have git installed, please do so with: sudo apt install git then proceed: cd ~ git clone https://github.com/Klipper3d/klipper ./klipper/scripts/install-octopi.sh The above will download Klipper, install the needed system dependencies, setup Klipper to run at system startup, and start the Klipper host software. It will require an internet connection and it may take a few minutes to complete.","title":"Install with OctoPi"},{"location":"OctoPrint.html#installing-with-kiauh","text":"KIAUH can be used to install OctoPrint on a variety of Linux based systems that run a form of Debian. More information can be found at https://github.com/dw-0/kiauh","title":"Installing with KIAUH"},{"location":"OctoPrint.html#configuring-octoprint-to-use-klipper","text":"The OctoPrint web server needs to be configured to communicate with the Klipper host software. Using a web browser, login to the OctoPrint web page and then configure the following items: Navigate to the Settings tab (the wrench icon at the top of the page). Under \"Serial Connection\" in \"Additional serial ports\" add: ~/printer_data/comms/klippy.serial Then click \"Save\". In some older setups this address may be /tmp/printer Enter the Settings tab again and under \"Serial Connection\" change the \"Serial Port\" setting to the one added above. In the Settings tab, navigate to the \"Behavior\" sub-tab and select the \"Cancel any ongoing prints but stay connected to the printer\" option. Click \"Save\". From the main page, under the \"Connection\" section (at the top left of the page) make sure the \"Serial Port\" is set to the new additional one added and click \"Connect\". (If it is not in the available selection then try reloading the page.) Once connected, navigate to the \"Terminal\" tab and type \"status\" (without the quotes) into the command entry box and click \"Send\". The terminal window will likely report there is an error opening the config file - that means OctoPrint is successfully communicating with Klipper. Please proceed to and the Building and flashing the micro-controller section","title":"Configuring OctoPrint to use Klipper"},{"location":"Overview.html","text":"Panoramica \u00b6 Benvenuto nella documentazione di Klipper. Se sei nuovo di Klipper, inizia con la documentazione su features e istallazione . Informazioni generali \u00b6 Caratteristiche : un elenco di funzionalit\u00e0 di alto livello in Klipper. FAQ : Domande frequenti. Releases : La storia delle versioni di Klipper. Modifiche alla configurazione : recenti modifiche al software che potrebbero richiedere agli utenti di aggiornare il file di configurazione della stampante. Contatto : Informazioni sulla segnalazione di bug e comunicazione generale con gli sviluppatori di Klipper. Installazione e configurazione \u00b6 Installazione : Guida all'installazione di Klipper. Octoprint : Guide to installing Octoprint with Klipper. Riferimento di configurazione : Descrizione dei parametri di configurazione. Distanza di rotazione : Calcolo del parametro stepper rotation_distance. Controlli di configurazione : verifica le impostazioni di base dei pin nel file di configurazione. Livello del piatto : Informazioni sul \"livellamento del piatto\" in Klipper. Calibrazione Delta : Calibrazione della cinematica delta. Calibrazione sonda : Calibrazione di sonde Z automatiche. BL-Touch : Configura una sonda Z \"BL-Touch\". Livello manuale : Calibrazione dei finecorsa Z (e simili). Maglia del letto : Correzione dell'altezza del piatto basata sulle posizioni XY. Endstop phase : Posizionamento finecorsa Z assistito da stepper. Compensazione torsione degli assi : Uno strumento per compensare letture inaccurate della sonda per torsioni dell'asse X. Compensazione della risonanza : Uno strumento per ridurre le risonanze nelle stampe. Misurare le risonanze : Informazioni sull'uso dell'hardware dell'accelerometro adxl345 per misurare le risonanze. Avanzamento pressione : Calibra la pressione dell'estrusore. Codici G : Informazioni sui comandi supportati da Klipper. Modelli di comando : Macro G-Code e valutazione condizionale. Riferimento stato : informazioni disponibili per le macro (e simili). Driver TMC : Uso dei driver Trinamic per motori passo-passo con Klipper. Multi-MCU Homing : Homing e probing utilizzando pi\u00f9 microcontrollori. Slicers : Configurare il software \"slicer\" per Klipper. Correzione dell'inclinazione : Regolazioni per assi non perfettamente squadrati. Strumenti PWM : Guida su come usare gli strumenti controllati da PWM come i laser o i mandrini. Exclude Object : La guida all'implementazione di Exclude Objects. Documentazione per sviluppatori \u00b6 Panoramica codice : Gli sviluppatori dovrebbero leggere prima questo. Cinematica : Dettagli tecnici su come Klipper implementa il movimento. Protocollo : Informazioni sul protocollo di messaggistica di basso livello tra host e microcontrollore. Server API : Informazioni sulle API di comando e controllo di Klipper. Comandi MCU : Una descrizione dei comandi di basso livello implementati nel software del microcontrollore. Protocollo bus CAN : formato del messaggio Klipper CAN bus. Debug : Informazioni su come testare e fare il debug di Klipper. Benchmarks : Informazioni sul metodo di benchmark Klipper. Contribuire : Informazioni su come presentare miglioramenti a Klipper. Packaging : informazioni sulla creazione di pacchetti del sistema operativo. Documenti specifici del dispositivo \u00b6 Configurazioni di esempio : Informazioni su come aggiungere un file di configurazione di esempio a Klipper. Aggiornamenti SDCard : esegui il flashing di un microcontrollore copiando un file binario su una scheda SD nel microcontrollore. Raspberry Pi come microcontrollore : Dettagli per controllare i dispositivi collegati ai pin GPIO di un Raspberry Pi. Beaglebone : Dettagli per l'esecuzione di Klipper sulla PRU Beaglebone. Bootloaders : Informazioni per gli sviluppatori sul flashing del microcontrollore. Bootloader Entry : Richiedere il bootloader. CAN bus : Informazioni sull'uso del CAN bus con Klipper. Risoluzione problemi CAN Bus : Suggerimenti per la risoluzione di problemi del CAN Bus. Sensore larghezza filamento TSL1401CL Sensore di larghezza del filamento Hall Eddy Current Inductive probe","title":"Panoramica"},{"location":"Overview.html#panoramica","text":"Benvenuto nella documentazione di Klipper. Se sei nuovo di Klipper, inizia con la documentazione su features e istallazione .","title":"Panoramica"},{"location":"Overview.html#informazioni-generali","text":"Caratteristiche : un elenco di funzionalit\u00e0 di alto livello in Klipper. FAQ : Domande frequenti. Releases : La storia delle versioni di Klipper. Modifiche alla configurazione : recenti modifiche al software che potrebbero richiedere agli utenti di aggiornare il file di configurazione della stampante. Contatto : Informazioni sulla segnalazione di bug e comunicazione generale con gli sviluppatori di Klipper.","title":"Informazioni generali"},{"location":"Overview.html#installazione-e-configurazione","text":"Installazione : Guida all'installazione di Klipper. Octoprint : Guide to installing Octoprint with Klipper. Riferimento di configurazione : Descrizione dei parametri di configurazione. Distanza di rotazione : Calcolo del parametro stepper rotation_distance. Controlli di configurazione : verifica le impostazioni di base dei pin nel file di configurazione. Livello del piatto : Informazioni sul \"livellamento del piatto\" in Klipper. Calibrazione Delta : Calibrazione della cinematica delta. Calibrazione sonda : Calibrazione di sonde Z automatiche. BL-Touch : Configura una sonda Z \"BL-Touch\". Livello manuale : Calibrazione dei finecorsa Z (e simili). Maglia del letto : Correzione dell'altezza del piatto basata sulle posizioni XY. Endstop phase : Posizionamento finecorsa Z assistito da stepper. Compensazione torsione degli assi : Uno strumento per compensare letture inaccurate della sonda per torsioni dell'asse X. Compensazione della risonanza : Uno strumento per ridurre le risonanze nelle stampe. Misurare le risonanze : Informazioni sull'uso dell'hardware dell'accelerometro adxl345 per misurare le risonanze. Avanzamento pressione : Calibra la pressione dell'estrusore. Codici G : Informazioni sui comandi supportati da Klipper. Modelli di comando : Macro G-Code e valutazione condizionale. Riferimento stato : informazioni disponibili per le macro (e simili). Driver TMC : Uso dei driver Trinamic per motori passo-passo con Klipper. Multi-MCU Homing : Homing e probing utilizzando pi\u00f9 microcontrollori. Slicers : Configurare il software \"slicer\" per Klipper. Correzione dell'inclinazione : Regolazioni per assi non perfettamente squadrati. Strumenti PWM : Guida su come usare gli strumenti controllati da PWM come i laser o i mandrini. Exclude Object : La guida all'implementazione di Exclude Objects.","title":"Installazione e configurazione"},{"location":"Overview.html#documentazione-per-sviluppatori","text":"Panoramica codice : Gli sviluppatori dovrebbero leggere prima questo. Cinematica : Dettagli tecnici su come Klipper implementa il movimento. Protocollo : Informazioni sul protocollo di messaggistica di basso livello tra host e microcontrollore. Server API : Informazioni sulle API di comando e controllo di Klipper. Comandi MCU : Una descrizione dei comandi di basso livello implementati nel software del microcontrollore. Protocollo bus CAN : formato del messaggio Klipper CAN bus. Debug : Informazioni su come testare e fare il debug di Klipper. Benchmarks : Informazioni sul metodo di benchmark Klipper. Contribuire : Informazioni su come presentare miglioramenti a Klipper. Packaging : informazioni sulla creazione di pacchetti del sistema operativo.","title":"Documentazione per sviluppatori"},{"location":"Overview.html#documenti-specifici-del-dispositivo","text":"Configurazioni di esempio : Informazioni su come aggiungere un file di configurazione di esempio a Klipper. Aggiornamenti SDCard : esegui il flashing di un microcontrollore copiando un file binario su una scheda SD nel microcontrollore. Raspberry Pi come microcontrollore : Dettagli per controllare i dispositivi collegati ai pin GPIO di un Raspberry Pi. Beaglebone : Dettagli per l'esecuzione di Klipper sulla PRU Beaglebone. Bootloaders : Informazioni per gli sviluppatori sul flashing del microcontrollore. Bootloader Entry : Richiedere il bootloader. CAN bus : Informazioni sull'uso del CAN bus con Klipper. Risoluzione problemi CAN Bus : Suggerimenti per la risoluzione di problemi del CAN Bus. Sensore larghezza filamento TSL1401CL Sensore di larghezza del filamento Hall Eddy Current Inductive probe","title":"Documenti specifici del dispositivo"},{"location":"Packaging.html","text":"Klipper packaging \u00b6 Klipper \u00e8 in qualche modo un'anomalia tra i programmi Python per quanto riguarda impacchettamento, in quanto non usa setuptools per costruire e installare. Alcune note riguardanti il modo migliore per impacchettarlo sono le seguenti: Moduli C \u00b6 Klipper utilizza un modulo C per gestire pi\u00f9 rapidamente alcuni calcoli cinematici. Questo modulo deve essere compilato al momento per evitare di introdurre una dipendenza di runtime da un compilatore. Per compilare il modulo C, esegui python2 klippy/chelper/__init__.py . Compilazione di codice python \u00b6 Molte distribuzioni hanno una politica di compilazione di tutto il codice Python prima del packaging per migliorare i tempi di avvio. Puoi farlo eseguendo python2 -m compileall klippy . Versione \u00b6 Se stai compilando un pacchetto di Klipper da git, \u00e8 normale non spedire una directory .git, quindi il controllo delle versioni deve essere gestito senza git. Per fare ci\u00f2, usa lo script fornito in scripts/make_version.py che dovrebbe essere eseguito come segue: python2 scripts/make_version.py YOURDISTRONAME > klippy/.version . Esempio di script di packaging \u00b6 klipper-git \u00e8 pacchettizzato per Arch Linux e ha un PKGBUILD (script di creazione del pacchetto) disponibile su Arch User Repository .","title":"Klipper packaging"},{"location":"Packaging.html#klipper-packaging","text":"Klipper \u00e8 in qualche modo un'anomalia tra i programmi Python per quanto riguarda impacchettamento, in quanto non usa setuptools per costruire e installare. Alcune note riguardanti il modo migliore per impacchettarlo sono le seguenti:","title":"Klipper packaging"},{"location":"Packaging.html#moduli-c","text":"Klipper utilizza un modulo C per gestire pi\u00f9 rapidamente alcuni calcoli cinematici. Questo modulo deve essere compilato al momento per evitare di introdurre una dipendenza di runtime da un compilatore. Per compilare il modulo C, esegui python2 klippy/chelper/__init__.py .","title":"Moduli C"},{"location":"Packaging.html#compilazione-di-codice-python","text":"Molte distribuzioni hanno una politica di compilazione di tutto il codice Python prima del packaging per migliorare i tempi di avvio. Puoi farlo eseguendo python2 -m compileall klippy .","title":"Compilazione di codice python"},{"location":"Packaging.html#versione","text":"Se stai compilando un pacchetto di Klipper da git, \u00e8 normale non spedire una directory .git, quindi il controllo delle versioni deve essere gestito senza git. Per fare ci\u00f2, usa lo script fornito in scripts/make_version.py che dovrebbe essere eseguito come segue: python2 scripts/make_version.py YOURDISTRONAME > klippy/.version .","title":"Versione"},{"location":"Packaging.html#esempio-di-script-di-packaging","text":"klipper-git \u00e8 pacchettizzato per Arch Linux e ha un PKGBUILD (script di creazione del pacchetto) disponibile su Arch User Repository .","title":"Esempio di script di packaging"},{"location":"Pressure_Advance.html","text":"Anticipo di pressione \u00b6 Questo documento fornisce informazioni sulla messa a punto della variabile di regolazione del \"pressure advance\" per un particolare ugello e filamento. La funzione di anticipo della pressione pu\u00f2 essere utile per ridurre le colature. Per maggiori informazioni su come viene implementato l'anticipo di pressione, vedere il documento kinematics . Regolazione della pressure advance \u00b6 Pressure advance fa due cose utili: riduce le colature durante i movimenti senza estrusione e riduce il blobbing durante le curve. Questa guida utilizza la seconda funzione (riduzione del blobbing durante le curve) come meccanismo per la messa a punto. Per calibrare la pressure advance, la stampante deve essere configurata e operativa poich\u00e9 il test di ottimizzazione prevede la stampa e l'ispezione di un oggetto di prova. \u00c8 una buona idea leggere questo documento per intero prima di eseguire il test. Usa uno slicer per generare il codice G per il grande cubo vuoto che si trova in docs/prints/square_tower.stl . Utilizzare una velocit\u00e0 elevata (ad es. 100 mm/s), riempimento zero e un'altezza dello strato grossolana (l'altezza dello strato dovrebbe essere circa il 75% del diametro dell'ugello). Assicurati che qualsiasi \"controllo dinamico dell'accelerazione\" sia disabilitato nello slicer. Prepararsi per il test emettendo il seguente comando G-Code: SET_VELOCITY_LIMIT SQUARE_CORNER_VELOCITY=1 ACCEL=500 Questo comando fa viaggiare l'ugello pi\u00f9 lentamente attraverso gli angoli per enfatizzare gli effetti della pressione dell'estrusore. Quindi per le stampanti con un estrusore a trasmissione diretta eseguire il comando: TUNING_TOWER COMMAND=SET_PRESSURE_ADVANCE PARAMETER=ADVANCE START=0 FACTOR=.005 Per estrusori bowden lunghi utilizzare: TUNING_TOWER COMMAND=SET_PRESSURE_ADVANCE PARAMETER=ADVANCE START=0 FACTOR=.020 Quindi stampare l'oggetto. Una volta stampata completamente, la stampa di prova avr\u00e0 il seguente aspetto: Il comando TUNING_TOWER sopra indica a Klipper di modificare l'impostazione pressure_advance su ogni strato della stampa. Gli strati pi\u00f9 alti nella stampa avranno un valore di anticipo della pressione maggiore impostato. Gli strati al di sotto dell'impostazione pressione_anticipo ideale avranno macchie agli angoli e gli strati al di sopra dell'impostazione ideale possono portare a angoli arrotondati e una scarsa estrusione all'angolo. \u00c8 possibile annullare la stampa in anticipo se si osserva che gli angoli non vengono pi\u00f9 stampati bene (e quindi si pu\u00f2 evitare di stampare livelli noti per essere al di sopra del valore di pressione_avanzamento ideale). Ispeziona la stampa e quindi utilizza un calibro digitale per trovare l'altezza con gli angoli della migliore qualit\u00e0. In caso di dubbio, preferire un'altezza inferiore. Il valore pressure_advance pu\u00f2 quindi essere calcolato come pressure_advance = <inizio> + <altezza_misurata> * <fattore> . (Ad esempio, 0 + 12.90 * .020 sarebbe .258 .) \u00c8 possibile scegliere impostazioni personalizzate per START e FACTOR se ci\u00f2 aiuta a identificare la migliore impostazione di anticipo della pressione. Quando si esegue questa operazione, assicurarsi di emettere il comando TUNING_TOWER all'inizio di ogni stampa di prova. I valori tipici di pressure advance sono compresi tra 0,050 e 1,000 (la fascia alta di solito solo con estrusori bowden). Se non vi \u00e8 alcun miglioramento significativo con un pressure advance fino a 1.000, \u00e8 improbabile che la pressure advance migliori la qualit\u00e0 delle stampe. Ritorno ad una configurazione di default con pressure advance disabilitato. Sebbene questo esercizio di messa a punto migliori direttamente la qualit\u00e0 degli angoli, vale la pena ricordare che una buona configurazione del pressure advance riduce anche gli ooze durante la stampa. Al termine di questo test, impostare pressure_advance = <calculated_value> nella sezione [extruder] del file di configurazione ed emettere un comando RESTART. Il comando RESTART canceller\u00e0 lo stato di test e riporter\u00e0 le velocit\u00e0 di accelerazione e in curva ai valori normali. Note importanti \u00b6 Il valore di pressure advance dipende dall'estrusore, dall'ugello e dal filamento. \u00c8 comune che filamenti di produttori diversi o con pigmenti diversi richiedano valori di pressure advance significativamente diversi. Pertanto, si dovrebbe calibrare pressure advance su ciascuna stampante e con ogni bobina di filamento. La temperatura di stampa e le velocit\u00e0 di estrusione possono influire sulla pressure advance. Assicurati di regolare extruder rotation_distance e nozzle temperature prima di regolare l'avanzamento della pressione. La stampa di prova \u00e8 progettata per funzionare con un'elevata portata dell'estrusore, ma per il resto con impostazioni dello slicer \"normali\". Un'elevata portata si ottiene utilizzando un'elevata velocit\u00e0 di stampa (ad es. 100 mm/s) e un'altezza dello strato grossolano (tipicamente circa il 75% del diametro dell'ugello). Altre impostazioni dello slicer dovrebbero essere simili alle loro impostazioni predefinite (ad esempio, perimetri di 2 o 3 linee, quantit\u00e0 di retrazione normale). Pu\u00f2 essere utile impostare la velocit\u00e0 del perimetro esterno in modo che sia la stessa velocit\u00e0 del resto della stampa, ma non \u00e8 un requisito. \u00c8 comune che la stampa di prova mostri un comportamento diverso su ciascun angolo. Spesso lo slicer provveder\u00e0 a cambiare i livelli in un angolo, il che pu\u00f2 comportare che quell'angolo sia significativamente diverso dai restanti tre angoli. Se ci\u00f2 si verifica, ignora quell'angolo e regola pressure advance utilizzando gli altri tre angoli. \u00c8 anche comune che gli angoli rimanenti varino leggermente. (Ci\u00f2 pu\u00f2 verificarsi a causa di piccole differenze nel modo in cui il telaio della stampante reagisce alle curve in determinate direzioni.) Prova a scegliere un valore che funzioni bene per tutti gli angoli rimanenti. In caso di dubbio, preferire un valore di pressure advance inferiore. Se viene utilizzato un valore di pressure advance (ad esempio, superiore a 0.200), \u00e8 possibile che l'estrusore salti quando torna alla normale accelerazione della stampante. Il sistema di pressure advance tiene conto della pressione spingendo il filamento extra durante l'accelerazione e ritraendo quel filamento durante la decelerazione. Con un'elevata accelerazione e un'elevata pressione di anticipo, l'estrusore potrebbe non avere una coppia sufficiente per spingere il filamento richiesto. In tal caso, utilizzare un valore di accelerazione inferiore o disattivare la pressure advance. Una volta che pressure advance \u00e8 stato regolato in Klipper, pu\u00f2 essere comunque utile configurare un piccolo valore di retrazione nello slicer (ad es. 0,75 mm) e utilizzare l'opzione \"pulizia in retrazione\" dello slicer, se disponibile. Queste impostazioni dello slicer possono aiutare a contrastare la trasudazione causata dalla coesione del filamento ( estratto dall'ugello a causa della viscosit\u00e0 della plastica). Si consiglia di disabilitare l'opzione \"Z-lift in retrazione\" dello slicer. Il sistema di pressure advance non modifica i tempi o il percorso della testa di stampa. Una stampa con pressure advance abilitato richieder\u00e0 lo stesso tempo di una stampa senza pressure advance. Inoltre, pressure advance non modifica la quantit\u00e0 totale di filamento estruso durante una stampa. L a pressure advance determina un movimento extra dell'estrusore durante l'accelerazione e la decelerazione del movimento. Un'impostazione di pressure advance molto elevata risulter\u00e0 in una quantit\u00e0 molto grande di movimento dell'estrusore durante l'accelerazione e la decelerazione e nessuna impostazione di configurazione pone un limite alla quantit\u00e0 di tale movimento.","title":"Anticipo di pressione"},{"location":"Pressure_Advance.html#anticipo-di-pressione","text":"Questo documento fornisce informazioni sulla messa a punto della variabile di regolazione del \"pressure advance\" per un particolare ugello e filamento. La funzione di anticipo della pressione pu\u00f2 essere utile per ridurre le colature. Per maggiori informazioni su come viene implementato l'anticipo di pressione, vedere il documento kinematics .","title":"Anticipo di pressione"},{"location":"Pressure_Advance.html#regolazione-della-pressure-advance","text":"Pressure advance fa due cose utili: riduce le colature durante i movimenti senza estrusione e riduce il blobbing durante le curve. Questa guida utilizza la seconda funzione (riduzione del blobbing durante le curve) come meccanismo per la messa a punto. Per calibrare la pressure advance, la stampante deve essere configurata e operativa poich\u00e9 il test di ottimizzazione prevede la stampa e l'ispezione di un oggetto di prova. \u00c8 una buona idea leggere questo documento per intero prima di eseguire il test. Usa uno slicer per generare il codice G per il grande cubo vuoto che si trova in docs/prints/square_tower.stl . Utilizzare una velocit\u00e0 elevata (ad es. 100 mm/s), riempimento zero e un'altezza dello strato grossolana (l'altezza dello strato dovrebbe essere circa il 75% del diametro dell'ugello). Assicurati che qualsiasi \"controllo dinamico dell'accelerazione\" sia disabilitato nello slicer. Prepararsi per il test emettendo il seguente comando G-Code: SET_VELOCITY_LIMIT SQUARE_CORNER_VELOCITY=1 ACCEL=500 Questo comando fa viaggiare l'ugello pi\u00f9 lentamente attraverso gli angoli per enfatizzare gli effetti della pressione dell'estrusore. Quindi per le stampanti con un estrusore a trasmissione diretta eseguire il comando: TUNING_TOWER COMMAND=SET_PRESSURE_ADVANCE PARAMETER=ADVANCE START=0 FACTOR=.005 Per estrusori bowden lunghi utilizzare: TUNING_TOWER COMMAND=SET_PRESSURE_ADVANCE PARAMETER=ADVANCE START=0 FACTOR=.020 Quindi stampare l'oggetto. Una volta stampata completamente, la stampa di prova avr\u00e0 il seguente aspetto: Il comando TUNING_TOWER sopra indica a Klipper di modificare l'impostazione pressure_advance su ogni strato della stampa. Gli strati pi\u00f9 alti nella stampa avranno un valore di anticipo della pressione maggiore impostato. Gli strati al di sotto dell'impostazione pressione_anticipo ideale avranno macchie agli angoli e gli strati al di sopra dell'impostazione ideale possono portare a angoli arrotondati e una scarsa estrusione all'angolo. \u00c8 possibile annullare la stampa in anticipo se si osserva che gli angoli non vengono pi\u00f9 stampati bene (e quindi si pu\u00f2 evitare di stampare livelli noti per essere al di sopra del valore di pressione_avanzamento ideale). Ispeziona la stampa e quindi utilizza un calibro digitale per trovare l'altezza con gli angoli della migliore qualit\u00e0. In caso di dubbio, preferire un'altezza inferiore. Il valore pressure_advance pu\u00f2 quindi essere calcolato come pressure_advance = <inizio> + <altezza_misurata> * <fattore> . (Ad esempio, 0 + 12.90 * .020 sarebbe .258 .) \u00c8 possibile scegliere impostazioni personalizzate per START e FACTOR se ci\u00f2 aiuta a identificare la migliore impostazione di anticipo della pressione. Quando si esegue questa operazione, assicurarsi di emettere il comando TUNING_TOWER all'inizio di ogni stampa di prova. I valori tipici di pressure advance sono compresi tra 0,050 e 1,000 (la fascia alta di solito solo con estrusori bowden). Se non vi \u00e8 alcun miglioramento significativo con un pressure advance fino a 1.000, \u00e8 improbabile che la pressure advance migliori la qualit\u00e0 delle stampe. Ritorno ad una configurazione di default con pressure advance disabilitato. Sebbene questo esercizio di messa a punto migliori direttamente la qualit\u00e0 degli angoli, vale la pena ricordare che una buona configurazione del pressure advance riduce anche gli ooze durante la stampa. Al termine di questo test, impostare pressure_advance = <calculated_value> nella sezione [extruder] del file di configurazione ed emettere un comando RESTART. Il comando RESTART canceller\u00e0 lo stato di test e riporter\u00e0 le velocit\u00e0 di accelerazione e in curva ai valori normali.","title":"Regolazione della pressure advance"},{"location":"Pressure_Advance.html#note-importanti","text":"Il valore di pressure advance dipende dall'estrusore, dall'ugello e dal filamento. \u00c8 comune che filamenti di produttori diversi o con pigmenti diversi richiedano valori di pressure advance significativamente diversi. Pertanto, si dovrebbe calibrare pressure advance su ciascuna stampante e con ogni bobina di filamento. La temperatura di stampa e le velocit\u00e0 di estrusione possono influire sulla pressure advance. Assicurati di regolare extruder rotation_distance e nozzle temperature prima di regolare l'avanzamento della pressione. La stampa di prova \u00e8 progettata per funzionare con un'elevata portata dell'estrusore, ma per il resto con impostazioni dello slicer \"normali\". Un'elevata portata si ottiene utilizzando un'elevata velocit\u00e0 di stampa (ad es. 100 mm/s) e un'altezza dello strato grossolano (tipicamente circa il 75% del diametro dell'ugello). Altre impostazioni dello slicer dovrebbero essere simili alle loro impostazioni predefinite (ad esempio, perimetri di 2 o 3 linee, quantit\u00e0 di retrazione normale). Pu\u00f2 essere utile impostare la velocit\u00e0 del perimetro esterno in modo che sia la stessa velocit\u00e0 del resto della stampa, ma non \u00e8 un requisito. \u00c8 comune che la stampa di prova mostri un comportamento diverso su ciascun angolo. Spesso lo slicer provveder\u00e0 a cambiare i livelli in un angolo, il che pu\u00f2 comportare che quell'angolo sia significativamente diverso dai restanti tre angoli. Se ci\u00f2 si verifica, ignora quell'angolo e regola pressure advance utilizzando gli altri tre angoli. \u00c8 anche comune che gli angoli rimanenti varino leggermente. (Ci\u00f2 pu\u00f2 verificarsi a causa di piccole differenze nel modo in cui il telaio della stampante reagisce alle curve in determinate direzioni.) Prova a scegliere un valore che funzioni bene per tutti gli angoli rimanenti. In caso di dubbio, preferire un valore di pressure advance inferiore. Se viene utilizzato un valore di pressure advance (ad esempio, superiore a 0.200), \u00e8 possibile che l'estrusore salti quando torna alla normale accelerazione della stampante. Il sistema di pressure advance tiene conto della pressione spingendo il filamento extra durante l'accelerazione e ritraendo quel filamento durante la decelerazione. Con un'elevata accelerazione e un'elevata pressione di anticipo, l'estrusore potrebbe non avere una coppia sufficiente per spingere il filamento richiesto. In tal caso, utilizzare un valore di accelerazione inferiore o disattivare la pressure advance. Una volta che pressure advance \u00e8 stato regolato in Klipper, pu\u00f2 essere comunque utile configurare un piccolo valore di retrazione nello slicer (ad es. 0,75 mm) e utilizzare l'opzione \"pulizia in retrazione\" dello slicer, se disponibile. Queste impostazioni dello slicer possono aiutare a contrastare la trasudazione causata dalla coesione del filamento ( estratto dall'ugello a causa della viscosit\u00e0 della plastica). Si consiglia di disabilitare l'opzione \"Z-lift in retrazione\" dello slicer. Il sistema di pressure advance non modifica i tempi o il percorso della testa di stampa. Una stampa con pressure advance abilitato richieder\u00e0 lo stesso tempo di una stampa senza pressure advance. Inoltre, pressure advance non modifica la quantit\u00e0 totale di filamento estruso durante una stampa. L a pressure advance determina un movimento extra dell'estrusore durante l'accelerazione e la decelerazione del movimento. Un'impostazione di pressure advance molto elevata risulter\u00e0 in una quantit\u00e0 molto grande di movimento dell'estrusore durante l'accelerazione e la decelerazione e nessuna impostazione di configurazione pone un limite alla quantit\u00e0 di tale movimento.","title":"Note importanti"},{"location":"Probe_Calibrate.html","text":"Calibrazione sonda \u00b6 Questo documento descrive il metodo per calibrare gli offset X, Y e Z di una \"sonda z automatica\" in Klipper. Questo \u00e8 utile per gli utenti che hanno una sezione [probe] o [bltouch] nel loro file di configurazione. Calibrazione degli offset X e Y della sonda \u00b6 Per calibrare l'offset X e Y, vai alla scheda \"Controllo\" di OctoPrint, avvia la stampante, quindi usa i pulsanti di spostamento di OctoPrint per spostare la testa in una posizione vicino al centro del piatto. Metti un pezzo di nastro adesivo blu (o simile) sul piatto sotto la sonda. Passare alla scheda \"Terminale\" di OctoPrint ed emettere un comando PROBE: PROBE Metti un segno sul nastro direttamente sotto il punto in cui si trova la sonda (o usa un metodo simile per annotare la posizione sul letto). Emettere un comando GET_POSITION e registrare la posizione XY della testa riportata da quel comando. Ad esempio se si vede: Recv: // toolhead: X:46.500000 Y:27.000000 Z:15.000000 E:0.000000 quindi si registrerebbe una posizione X della sonda di 46,5 e una posizione Y della sonda di 27. Dopo aver registrato la posizione della sonda, emettere una serie di comandi G1 fino a quando l'ugello si trova direttamente sopra il segno sul letto. Ad esempio, si potrebbe emettere: G1 F300 X57 Y30 Z15 per spostare l'ugello in una posizione X di 57 e Y di 30. Una volta trovata la posizione direttamente sopra il segno, utilizzare il comando GET_POSITION per segnalare quella posizione. Questa \u00e8 la posizione dell'ugello. L'offset_x \u00e8 quindi posizione_x_ugello - posizione_x_sonda e l'offset_y \u00e8 analogamente a posizione_y_ugello - posizione_y_sonda . Aggiorna il file printer.cfg con i valori indicati, rimuovi il nastro con i riferimento dal piatto, quindi esegui un comando RESTART in modo che i nuovi valori diventino effettivi. Calibrazione Z offset sonda \u00b6 Inserire una z_offset accurata per la sonda \u00e8 fondamentale per ottenere stampe di alta qualit\u00e0. Lo z_offset \u00e8 la distanza tra l'ugello e il letto quando la sonda si attiva. Lo strumento Klipper PROBE_CALIBRATE pu\u00f2 essere utilizzato per ottenere questo valore: eseguir\u00e0 una sonda automatica per misurare la posizione di trigger Z della sonda e quindi avvier\u00e0 una sonda manuale per ottenere l'altezza Z dell'ugello. La sonda z_offset verr\u00e0 quindi calcolata da queste misurazioni. Inizia spostando testa in una posizione vicino al centro del piatto. Passare alla scheda del terminale OctoPrint ed eseguire il comando PROBE_CALIBRATE per avviare lo strumento. Questo strumento eseguir\u00e0 una misura automatica con la sonda, quindi sollever\u00e0 la testina, sposter\u00e0 l'ugello sulla posizione del punto sonda e avvier\u00e0 lo strumento sonda manuale. Se l'ugello non si sposta in una posizione al di sopra del punto della sonda automatica, allora ANNULLA lo strumento sonda manuale ed eseguire la calibrazione dell'offset della sonda XY descritta sopra. Once the manual probe tool starts, follow the steps described at \"the paper test\" to determine the actual distance between the nozzle and bed at the given location. Once those steps are complete one can ACCEPT the position and save the results to the config file with: SAVE_CONFIG Si noti che se viene apportata una modifica al sistema di movimento della stampante, alla posizione dell'hotend o alla posizione della sonda, i risultati di PROBE_CALIBRATE verranno invalidati. Se la sonda ha un offset X o Y e l'inclinazione del letto viene modificata (ad es. regolando le viti del letto, eseguendo DELTA_CALIBRATE, eseguendo Z_TILT_ADJUST, eseguendo QUAD_GANTRY_LEVEL o simili), i risultati di PROBE_CALIBRATE verranno invalidati. Dopo aver apportato una qualsiasi delle modifiche di cui sopra, sar\u00e0 necessario eseguire nuovamente PROBE_CALIBRATE. Se i risultati di PROBE_CALIBRATE vengono invalidati, anche tutti i risultati precedenti di bed mesh ottenuti utilizzando la sonda vengono invalidati: sar\u00e0 necessario eseguire nuovamente BED_MESH_CALIBRATE dopo aver ricalibrato la sonda. Verifica di ripetibilit\u00e0 \u00b6 Dopo aver calibrato gli offset X, Y e Z della sonda, \u00e8 una buona idea verificare che la sonda fornisca risultati ripetibili. Inizia portando a home la stampante e quindi sposta la testa in una posizione vicino al centro del letto. Passare al terminale di OctoPrint ed eseguire il comando PROBE_ACCURACY . Questo comando eseguir\u00e0 il test con la sonda dieci volte e produrr\u00e0 un output simile al seguente: Recv: // probe accuracy: at X:0.000 Y:0.000 Z:10.000 Recv: // and read 10 times with speed of 5 mm/s Recv: // probe at -0.003,0.005 is z=2.506948 Recv: // probe at -0.003,0.005 is z=2.519448 Recv: // probe at -0.003,0.005 is z=2.519448 Recv: // probe at -0.003,0.005 is z=2.506948 Recv: // probe at -0.003,0.005 is z=2.519448 Recv: // probe at -0.003,0.005 is z=2.519448 Recv: // probe at -0.003,0.005 is z=2.506948 Recv: // probe at -0.003,0.005 is z=2.506948 Recv: // probe at -0.003,0.005 is z=2.519448 Recv: // probe at -0.003,0.005 is z=2.506948 Recv: // probe accuracy results: maximum 2.519448, minimum 2.506948, range 0.012500, average 2.513198, median 2.513198, standard deviation 0.006250 Idealmente lo strumento riporter\u00e0 un valore massimo e minimo identico. (Ovvero, idealmente la sonda ottiene un risultato identico su tutte e dieci le prove.) Tuttavia, \u00e8 normale che i valori minimo e massimo differiscano di una \"distanza di passo\" Z o fino a 5 micron (0,005 mm). Una \"distanza passo\" \u00e8 rotation_distance/(full_steps_per_rotation*microsteps) . La distanza tra il valore minimo e quello massimo \u00e8 chiamata intervallo. Quindi, nell'esempio precedente, poich\u00e9 la stampante utilizza una distanza di passo Z di 0,0125, un intervallo di 0,012500 sarebbe considerato normale. Se i risultati del test mostrano un valore di intervallo maggiore di 25 micron (0,025 mm), la sonda non ha una precisione sufficiente per le procedure tipiche di livellamento del piatto. Potrebbe essere possibile regolare la velocit\u00e0 della sonda e/o l'altezza di inizio della sonda per migliorare la ripetibilit\u00e0 della sonda. Il comando PROBE_ACCURACY consente di eseguire test con parametri diversi per vederne l'impatto - vedere il documento G-Codes per ulteriori dettagli. Se la sonda generalmente ottiene risultati ripetibili ma presenta un valore anomalo occasionale, potrebbe essere possibile tenerne conto utilizzando pi\u00f9 campioni su ciascuna sonda - leggere la descrizione dei parametri di configurazione dei campioni della sonda in riferimento di configurazione per maggiori dettagli. Se sono necessarie una nuova velocit\u00e0 della sonda, diversa quantit\u00e0 di campioni o altre impostazioni, aggiornare il file printer.cfg ed eseguire un comando RESTART . In tal caso, \u00e8 una buona idea anche calibrare z_offset di nuovo. Se non \u00e8 possibile ottenere risultati ripetibili, non utilizzare la sonda per livellare il letto. Klipper ha diversi strumenti manuali che possono essere utilizzati in alternativa: vedere il Bed Level document per ulteriori dettagli. Verifica scostamenti di posizione \u00b6 Alcune sonde possono avere una distorsione sistematica che altera i risultati della sonda in determinate posizioni della testa. Ad esempio, se il supporto della sonda si inclina leggermente durante lo spostamento lungo l'asse Y, la sonda potrebbe riportare risultati distorti in differenti posizioni Y. Questo \u00e8 un problema comune con le sonde sulle stampanti delta, tuttavia pu\u00f2 verificarsi su tutte le stampanti. Si pu\u00f2 verificare una distorsione di posizione utilizzando il comando PROBE_CALIBRATE per misurare l'offset z della sonda in varie posizioni X e Y. Idealmente, il probe z_offset sarebbe un valore costante in ogni posizione della stampante. Per le stampanti delta, prova a misurare z_offset in una posizione vicino alla torre A, in una posizione vicino alla torre B e in una posizione vicino alla torre C. Per stampanti cartesiane, corexy e simili, prova a misurare z_offset in posizioni vicino ai quattro angoli del letto. Prima di iniziare questo test, calibrare prima gli offset della sonda X, Y e Z come descritto all'inizio di questo documento. Quindi porta a home la stampante e vai alla prima posizione XY. Seguire i passaggi in calibrazione dell'offset Z della sonda per eseguire il comando PROBE_CALIBRATE , i comandi TESTZ e il comando ACCETTA , ma non eseguire SAVE_CONFIG . Nota lo z_offset segnalato trovato. Quindi passare alle altre posizioni XY, ripetere questi passaggi PROBE_CALIBRATE e annotare lo z_offset riportato. Se la differenza tra l'offset z minimo riportato e l'offset z massimo riportato \u00e8 maggiore di 25 micron (0,025 mm), la sonda non \u00e8 adatta per le tipiche procedure di livellamento del letto. Consultare il Bed Level document per sonde alternative manuali. Scostamenti per temperatura \u00b6 Molte sonde hanno una distorsione sistemica quando misurano a temperature diverse. Ad esempio, la sonda pu\u00f2 attivarsi costantemente a un'altezza inferiore quando la sonda si trova a una temperatura pi\u00f9 elevata. Si consiglia di eseguire le procedure di livellamento del piatto a una temperatura costante per tenere conto di questa distorsione. Ad esempio, usare sempre la sonda quando la stampante \u00e8 a temperatura ambiente oppure eseguire sempre la procedura dopo che la stampante ha raggiunto una temperatura costante. In entrambi i casi, \u00e8 una buona idea attendere diversi minuti dopo che \u00e8 stata raggiunta la temperatura desiderata, in modo che tutto apparato stampante sia alla temperatura desiderata costantemente. Per verificare la presenza di un errore per temperatura, iniziare con la stampante a temperatura ambiente e poi portare a home la stampante, spostare la testina in una posizione vicino al centro del letto ed eseguire il comando PROBE_ACCURACY . Nota i risultati. Quindi, senza eseguire l'homing o disabilitare i motori passo-passo, riscaldare l'ugello della stampante e il piatto alla temperatura di stampa ed eseguire nuovamente il comando PROBE_ACCURACY . Idealmente, il comando riporter\u00e0 risultati identici. Come sopra, se la sonda ha un errore causato dalla temperatura, fare attenzione a usare sempre la sonda a una temperatura costante stabile.","title":"Calibrazione sonda"},{"location":"Probe_Calibrate.html#calibrazione-sonda","text":"Questo documento descrive il metodo per calibrare gli offset X, Y e Z di una \"sonda z automatica\" in Klipper. Questo \u00e8 utile per gli utenti che hanno una sezione [probe] o [bltouch] nel loro file di configurazione.","title":"Calibrazione sonda"},{"location":"Probe_Calibrate.html#calibrazione-degli-offset-x-e-y-della-sonda","text":"Per calibrare l'offset X e Y, vai alla scheda \"Controllo\" di OctoPrint, avvia la stampante, quindi usa i pulsanti di spostamento di OctoPrint per spostare la testa in una posizione vicino al centro del piatto. Metti un pezzo di nastro adesivo blu (o simile) sul piatto sotto la sonda. Passare alla scheda \"Terminale\" di OctoPrint ed emettere un comando PROBE: PROBE Metti un segno sul nastro direttamente sotto il punto in cui si trova la sonda (o usa un metodo simile per annotare la posizione sul letto). Emettere un comando GET_POSITION e registrare la posizione XY della testa riportata da quel comando. Ad esempio se si vede: Recv: // toolhead: X:46.500000 Y:27.000000 Z:15.000000 E:0.000000 quindi si registrerebbe una posizione X della sonda di 46,5 e una posizione Y della sonda di 27. Dopo aver registrato la posizione della sonda, emettere una serie di comandi G1 fino a quando l'ugello si trova direttamente sopra il segno sul letto. Ad esempio, si potrebbe emettere: G1 F300 X57 Y30 Z15 per spostare l'ugello in una posizione X di 57 e Y di 30. Una volta trovata la posizione direttamente sopra il segno, utilizzare il comando GET_POSITION per segnalare quella posizione. Questa \u00e8 la posizione dell'ugello. L'offset_x \u00e8 quindi posizione_x_ugello - posizione_x_sonda e l'offset_y \u00e8 analogamente a posizione_y_ugello - posizione_y_sonda . Aggiorna il file printer.cfg con i valori indicati, rimuovi il nastro con i riferimento dal piatto, quindi esegui un comando RESTART in modo che i nuovi valori diventino effettivi.","title":"Calibrazione degli offset X e Y della sonda"},{"location":"Probe_Calibrate.html#calibrazione-z-offset-sonda","text":"Inserire una z_offset accurata per la sonda \u00e8 fondamentale per ottenere stampe di alta qualit\u00e0. Lo z_offset \u00e8 la distanza tra l'ugello e il letto quando la sonda si attiva. Lo strumento Klipper PROBE_CALIBRATE pu\u00f2 essere utilizzato per ottenere questo valore: eseguir\u00e0 una sonda automatica per misurare la posizione di trigger Z della sonda e quindi avvier\u00e0 una sonda manuale per ottenere l'altezza Z dell'ugello. La sonda z_offset verr\u00e0 quindi calcolata da queste misurazioni. Inizia spostando testa in una posizione vicino al centro del piatto. Passare alla scheda del terminale OctoPrint ed eseguire il comando PROBE_CALIBRATE per avviare lo strumento. Questo strumento eseguir\u00e0 una misura automatica con la sonda, quindi sollever\u00e0 la testina, sposter\u00e0 l'ugello sulla posizione del punto sonda e avvier\u00e0 lo strumento sonda manuale. Se l'ugello non si sposta in una posizione al di sopra del punto della sonda automatica, allora ANNULLA lo strumento sonda manuale ed eseguire la calibrazione dell'offset della sonda XY descritta sopra. Once the manual probe tool starts, follow the steps described at \"the paper test\" to determine the actual distance between the nozzle and bed at the given location. Once those steps are complete one can ACCEPT the position and save the results to the config file with: SAVE_CONFIG Si noti che se viene apportata una modifica al sistema di movimento della stampante, alla posizione dell'hotend o alla posizione della sonda, i risultati di PROBE_CALIBRATE verranno invalidati. Se la sonda ha un offset X o Y e l'inclinazione del letto viene modificata (ad es. regolando le viti del letto, eseguendo DELTA_CALIBRATE, eseguendo Z_TILT_ADJUST, eseguendo QUAD_GANTRY_LEVEL o simili), i risultati di PROBE_CALIBRATE verranno invalidati. Dopo aver apportato una qualsiasi delle modifiche di cui sopra, sar\u00e0 necessario eseguire nuovamente PROBE_CALIBRATE. Se i risultati di PROBE_CALIBRATE vengono invalidati, anche tutti i risultati precedenti di bed mesh ottenuti utilizzando la sonda vengono invalidati: sar\u00e0 necessario eseguire nuovamente BED_MESH_CALIBRATE dopo aver ricalibrato la sonda.","title":"Calibrazione Z offset sonda"},{"location":"Probe_Calibrate.html#verifica-di-ripetibilita","text":"Dopo aver calibrato gli offset X, Y e Z della sonda, \u00e8 una buona idea verificare che la sonda fornisca risultati ripetibili. Inizia portando a home la stampante e quindi sposta la testa in una posizione vicino al centro del letto. Passare al terminale di OctoPrint ed eseguire il comando PROBE_ACCURACY . Questo comando eseguir\u00e0 il test con la sonda dieci volte e produrr\u00e0 un output simile al seguente: Recv: // probe accuracy: at X:0.000 Y:0.000 Z:10.000 Recv: // and read 10 times with speed of 5 mm/s Recv: // probe at -0.003,0.005 is z=2.506948 Recv: // probe at -0.003,0.005 is z=2.519448 Recv: // probe at -0.003,0.005 is z=2.519448 Recv: // probe at -0.003,0.005 is z=2.506948 Recv: // probe at -0.003,0.005 is z=2.519448 Recv: // probe at -0.003,0.005 is z=2.519448 Recv: // probe at -0.003,0.005 is z=2.506948 Recv: // probe at -0.003,0.005 is z=2.506948 Recv: // probe at -0.003,0.005 is z=2.519448 Recv: // probe at -0.003,0.005 is z=2.506948 Recv: // probe accuracy results: maximum 2.519448, minimum 2.506948, range 0.012500, average 2.513198, median 2.513198, standard deviation 0.006250 Idealmente lo strumento riporter\u00e0 un valore massimo e minimo identico. (Ovvero, idealmente la sonda ottiene un risultato identico su tutte e dieci le prove.) Tuttavia, \u00e8 normale che i valori minimo e massimo differiscano di una \"distanza di passo\" Z o fino a 5 micron (0,005 mm). Una \"distanza passo\" \u00e8 rotation_distance/(full_steps_per_rotation*microsteps) . La distanza tra il valore minimo e quello massimo \u00e8 chiamata intervallo. Quindi, nell'esempio precedente, poich\u00e9 la stampante utilizza una distanza di passo Z di 0,0125, un intervallo di 0,012500 sarebbe considerato normale. Se i risultati del test mostrano un valore di intervallo maggiore di 25 micron (0,025 mm), la sonda non ha una precisione sufficiente per le procedure tipiche di livellamento del piatto. Potrebbe essere possibile regolare la velocit\u00e0 della sonda e/o l'altezza di inizio della sonda per migliorare la ripetibilit\u00e0 della sonda. Il comando PROBE_ACCURACY consente di eseguire test con parametri diversi per vederne l'impatto - vedere il documento G-Codes per ulteriori dettagli. Se la sonda generalmente ottiene risultati ripetibili ma presenta un valore anomalo occasionale, potrebbe essere possibile tenerne conto utilizzando pi\u00f9 campioni su ciascuna sonda - leggere la descrizione dei parametri di configurazione dei campioni della sonda in riferimento di configurazione per maggiori dettagli. Se sono necessarie una nuova velocit\u00e0 della sonda, diversa quantit\u00e0 di campioni o altre impostazioni, aggiornare il file printer.cfg ed eseguire un comando RESTART . In tal caso, \u00e8 una buona idea anche calibrare z_offset di nuovo. Se non \u00e8 possibile ottenere risultati ripetibili, non utilizzare la sonda per livellare il letto. Klipper ha diversi strumenti manuali che possono essere utilizzati in alternativa: vedere il Bed Level document per ulteriori dettagli.","title":"Verifica di ripetibilit\u00e0"},{"location":"Probe_Calibrate.html#verifica-scostamenti-di-posizione","text":"Alcune sonde possono avere una distorsione sistematica che altera i risultati della sonda in determinate posizioni della testa. Ad esempio, se il supporto della sonda si inclina leggermente durante lo spostamento lungo l'asse Y, la sonda potrebbe riportare risultati distorti in differenti posizioni Y. Questo \u00e8 un problema comune con le sonde sulle stampanti delta, tuttavia pu\u00f2 verificarsi su tutte le stampanti. Si pu\u00f2 verificare una distorsione di posizione utilizzando il comando PROBE_CALIBRATE per misurare l'offset z della sonda in varie posizioni X e Y. Idealmente, il probe z_offset sarebbe un valore costante in ogni posizione della stampante. Per le stampanti delta, prova a misurare z_offset in una posizione vicino alla torre A, in una posizione vicino alla torre B e in una posizione vicino alla torre C. Per stampanti cartesiane, corexy e simili, prova a misurare z_offset in posizioni vicino ai quattro angoli del letto. Prima di iniziare questo test, calibrare prima gli offset della sonda X, Y e Z come descritto all'inizio di questo documento. Quindi porta a home la stampante e vai alla prima posizione XY. Seguire i passaggi in calibrazione dell'offset Z della sonda per eseguire il comando PROBE_CALIBRATE , i comandi TESTZ e il comando ACCETTA , ma non eseguire SAVE_CONFIG . Nota lo z_offset segnalato trovato. Quindi passare alle altre posizioni XY, ripetere questi passaggi PROBE_CALIBRATE e annotare lo z_offset riportato. Se la differenza tra l'offset z minimo riportato e l'offset z massimo riportato \u00e8 maggiore di 25 micron (0,025 mm), la sonda non \u00e8 adatta per le tipiche procedure di livellamento del letto. Consultare il Bed Level document per sonde alternative manuali.","title":"Verifica scostamenti di posizione"},{"location":"Probe_Calibrate.html#scostamenti-per-temperatura","text":"Molte sonde hanno una distorsione sistemica quando misurano a temperature diverse. Ad esempio, la sonda pu\u00f2 attivarsi costantemente a un'altezza inferiore quando la sonda si trova a una temperatura pi\u00f9 elevata. Si consiglia di eseguire le procedure di livellamento del piatto a una temperatura costante per tenere conto di questa distorsione. Ad esempio, usare sempre la sonda quando la stampante \u00e8 a temperatura ambiente oppure eseguire sempre la procedura dopo che la stampante ha raggiunto una temperatura costante. In entrambi i casi, \u00e8 una buona idea attendere diversi minuti dopo che \u00e8 stata raggiunta la temperatura desiderata, in modo che tutto apparato stampante sia alla temperatura desiderata costantemente. Per verificare la presenza di un errore per temperatura, iniziare con la stampante a temperatura ambiente e poi portare a home la stampante, spostare la testina in una posizione vicino al centro del letto ed eseguire il comando PROBE_ACCURACY . Nota i risultati. Quindi, senza eseguire l'homing o disabilitare i motori passo-passo, riscaldare l'ugello della stampante e il piatto alla temperatura di stampa ed eseguire nuovamente il comando PROBE_ACCURACY . Idealmente, il comando riporter\u00e0 risultati identici. Come sopra, se la sonda ha un errore causato dalla temperatura, fare attenzione a usare sempre la sonda a una temperatura costante stabile.","title":"Scostamenti per temperatura"},{"location":"Protocol.html","text":"Protocollo \u00b6 Il protocollo di messaggistica Klipper viene utilizzato per la comunicazione di basso livello tra il software host Klipper e il software microcontrollore Klipper. Ad alto livello il protocollo pu\u00f2 essere pensato come una serie di stringhe di comando e risposta che vengono compresse, trasmesse e quindi elaborate sul lato ricevente. Una serie di esempio di comandi in formato non compresso leggibile dall'uomo potrebbe essere simile a: set_digital_out pin=PA3 value=1 set_digital_out pin=PA7 value=1 schedule_digital_out oid=8 clock=4000000 value=0 queue_step oid=7 interval=7458 count=10 add=331 queue_step oid=7 interval=11717 count=4 add=1281 Vedere il documento mcu commands per informazioni sui comandi disponibili. Vedere il documento debugging per informazioni su come tradurre un file G-Code nei corrispondenti comandi del microcontrollore leggibili dall'uomo. Questa pagina fornisce una descrizione di alto livello del protocollo di messaggistica Klipper. Descrive come i messaggi sono dichiarati, codificati in formato binario (lo schema di \"compressione\") e trasmessi. L'obiettivo del protocollo \u00e8 abilitare un canale di comunicazione privo di errori tra l'host e il microcontrollore che sia a bassa latenza, bassa larghezza di banda e bassa complessit\u00e0 per il microcontrollore. Interfaccia microcontrollore \u00b6 Il protocollo di trasmissione Klipper pu\u00f2 essere pensato come un meccanismo RPC tra microcontrollore e host. Il software del microcontrollore dichiara i comandi che l'host pu\u00f2 richiamare insieme ai messaggi di risposta che pu\u00f2 generare. L'host utilizza tali informazioni per comandare al microcontrollore di eseguire azioni e interpretare i risultati. Dichiarazione dei comandi \u00b6 Il software del microcontrollore dichiara un \"comando\" utilizzando la macro DECL_COMMAND() nel codice C. Per esempio: DECL_COMMAND(command_update_digital_out, \"update_digital_out oid=%c value=%c\"); Quanto sopra dichiara un comando denominato \"update_digital_out\". Ci\u00f2 consente all'host di \"richiamare\" questo comando che causerebbe l'esecuzione della funzione C command_update_digital_out() nel microcontrollore. Quanto sopra indica anche che il comando accetta due parametri interi. Quando viene eseguito il codice C command_update_digital_out(), verr\u00e0 passata una matrice contenente questi due numeri interi: il primo corrispondente all'\"oid\" e il secondo corrispondente al \"valore\". In generale, i parametri sono descritti con la sintassi di stile printf() (ad esempio, \"%u\"). La formattazione corrisponde direttamente alla visualizzazione leggibile dei comandi (ad es. \"update_digital_out oid=7 value=1\"). Nell'esempio precedente, \"value=\" \u00e8 un nome di parametro e \"%c\" indica che il parametro \u00e8 un numero intero. Internamente, il nome del parametro viene utilizzato solo come documentazione. In questo esempio, \"%c\" viene utilizzato anche come documentazione per indicare che l'intero previsto ha una dimensione di 1 byte (la dimensione intera dichiarata non influisce sull'analisi o sulla codifica). La build del microcontrollore raccoglier\u00e0 tutti i comandi dichiarati con DECL_COMMAND(), ne determiner\u00e0 i parametri e far\u00e0 in modo che siano richiamabili. Declaring responses \u00b6 Per inviare informazioni dal microcontrollore all'host viene generata una \"risposta\". Questi sono sia dichiarati che trasmessi usando la macro C sendf(). Per esempio: sendf(\"status clock=%u status=%c\", sched_read_time(), sched_is_shutdown()); Quanto sopra trasmette un messaggio di risposta di \"stato\" che contiene due parametri interi (\"clock\" e \"status\"). La build del microcontrollore trova automaticamente tutte le chiamate sendf() e genera codificatori per esse. Il primo parametro della funzione sendf() descrive la risposta ed \u00e8 nello stesso formato delle dichiarazioni di comando. L'host pu\u00f2 organizzare la registrazione di una funzione di richiamata per ogni risposta. Quindi, in effetti, i comandi consentono all'host di invocare le funzioni C nel microcontrollore e le risposte consentono al software del microcontrollore di richiamare il codice nell'host. La macro sendf() deve essere invocata solo da gestori di comandi o attivit\u00e0 e non deve essere invocata da interrupt o timer. Il codice non ha bisogno di emettere un sendf() in risposta a un comando ricevuto, non \u00e8 limitato nel numero di volte in cui sendf() pu\u00f2 essere invocato e pu\u00f2 invocare sendf() in qualsiasi momento da un task handler. Risposte in output \u00b6 Per semplificare il debug, esiste anche una funzione C output(). Per esempio: output(\"Il valore di%u \u00e8 %s con dimensione %u.\", x, buf, buf_len); La funzione output() \u00e8 simile nell'uso a printf() - \u00e8 intesa per generare e formattare messaggi arbitrari per il 'consumo umano'. Dichiarazione di enumerazioni \u00b6 Le enumerazioni consentono al codice host di utilizzare identificatori di stringa per i parametri che il microcontrollore gestisce come numeri interi. Sono dichiarati nel codice del microcontrollore, ad esempio: DECL_ENUMERATION(\"spi_bus\", \"spi\", 0); DECL_ENUMERATION_RANGE(\"pin\", \"PC0\", 16, 8); Se il primo esempio, la macro DECL_ENUMERATION() definisce un'enumerazione per qualsiasi messaggio di comando/risposta con nome parametro \"spi_bus\" o nome parametro con suffisso \"_spi_bus\". Per quei parametri la stringa \"spi\" \u00e8 un valore valido e verr\u00e0 trasmessa con un valore intero pari a zero. \u00c8 anche possibile dichiarare un intervallo di enumerazione. Nel secondo esempio, un parametro \"pin\" (o qualsiasi parametro con suffisso \"_pin\") accetterebbe PC0, PC1, PC2, ..., PC7 come valori validi. Le stringhe verranno trasmesse con numeri interi 16, 17, 18, ..., 23. Dichiarazione di costanti \u00b6 Le costanti possono anche essere esportate. Ad esempio, quanto segue: DECL_CONSTANT(\"SERIAL_BAUD\", 250000); esporterebbe una costante denominata \"SERIAL_BAUD\" con un valore di 250000 dal microcontrollore all'host. \u00c8 anche possibile dichiarare una costante che \u00e8 una stringa, ad esempio: DECL_CONSTANT_STR(\"MCU\", \"pru\"); Codifica dei messaggi di basso livello \u00b6 Per realizzare il meccanismo RPC di cui sopra, ogni comando e risposta viene codificato in un formato binario per la trasmissione. Questa sezione descrive il sistema di trasmissione. Blocchi di messaggi \u00b6 Tutti i dati inviati dall'host al microcontrollore e viceversa sono contenuti in \"blocchi di messaggi\". Un blocco di messaggi ha un'intestazione di due byte e un trailer di tre byte. Il formato di un blocco di messaggi \u00e8: <1 byte lunghezza><1 byte sequenza><n-byte contenuto><2 byte crc><1 byte sync> Il byte di lunghezza contiene il numero di byte nel blocco di messaggi inclusi i byte di intestazione e trailer (quindi la lunghezza minima del messaggio \u00e8 5 byte). La lunghezza massima del blocco di messaggi \u00e8 attualmente di 64 byte. Il byte di sequenza contiene un numero di sequenza di 4 bit nei bit di ordine inferiore e i bit di ordine superiore contengono sempre 0x10 (i bit di ordine superiore sono riservati per un uso futuro). I byte di contenuto contengono dati arbitrari e il relativo formato \u00e8 descritto nella sezione seguente. I byte crc contengono un CCITT CRC a 16 bit del blocco di messaggi inclusi i byte di intestazione ma esclusi i byte di trailer. Il byte di sincronizzazione \u00e8 0x7e. Il formato del blocco di messaggi si ispira ai telegrammi HDLC . Come in HDLC, il blocco di messaggi pu\u00f2 contenere facoltativamente un carattere di sincronizzazione aggiuntivo all'inizio del blocco. A differenza di HDLC, un carattere di sincronizzazione non \u00e8 esclusivo del framing e pu\u00f2 essere presente nel contenuto del blocco di messaggi. Contenuto del blocco messaggi \u00b6 Ogni blocco di messaggi inviato dall'host al microcontrollore contiene una serie di zero o pi\u00f9 comandi di messaggi. Ogni comando inizia con un Quantit\u00e0 a lunghezza variabile (VLQ) command-id seguito da zero o pi\u00f9 parametri VLQ per il comando dato. Ad esempio, i seguenti quattro comandi possono essere inseriti in un unico blocco di messaggi: update_digital_out oid=6 value=1 update_digital_out oid=5 value=0 get_config get_clock e codificato nei seguenti otto interi VLQ: <id_update_digital_out><6><1><id_update_digital_out><5><0><id_get_config><id_get_clock> Per codificare e analizzare il contenuto del messaggio, sia l'host che il microcontrollore devono concordare gli ID comando e il numero di parametri di ciascun comando. Quindi, nell'esempio sopra, sia l'host che il microcontrollore saprebbero che \"id_update_digital_out\" \u00e8 sempre seguito da due parametri e \"id_get_config\" e \"id_get_clock\" hanno zero parametri. L'host e il microcontrollore condividono un \"dizionario dei dati\" che mappa le descrizioni dei comandi (ad esempio, \"update_digital_out oid=%c value=%c\") ai loro ID di comando interi. Durante l'elaborazione dei dati, il parser sapr\u00e0 di aspettarsi un numero specifico di parametri codificati VLQ a seguito di un determinato ID comando. Il contenuto del messaggio per i blocchi inviati dal microcontrollore all'host segue lo stesso formato. Gli identificatori in questi messaggi sono \"ID di risposta\", ma servono allo stesso scopo e seguono le stesse regole di codifica. In pratica, i blocchi di messaggi inviati dal microcontrollore all'host non contengono mai pi\u00f9 di una risposta nel contenuto del blocco di messaggi. Quantit\u00e0 di lunghezza variabile \u00b6 Consulta l' articolo di Wikipedia per ulteriori informazioni sul formato generale degli interi codificati VLQ. Klipper utilizza uno schema di codifica che supporta numeri interi positivi e negativi. Gli interi prossimi allo zero utilizzano meno byte per codificare e gli interi positivi in genere codificano utilizzando meno byte degli interi negativi. La tabella seguente mostra il numero di byte che ogni intero impiega per codificare: Intero Dimensione codificata -32 .. 95 1 -4096 .. 12287 2 -524288 .. 1572863 3 -67108864 .. 201326591 4 -2147483648 .. 4294967295 5 Stringhe di lunghezza variabile \u00b6 Come eccezione alle regole di codifica precedenti, se un parametro di un comando o di una risposta \u00e8 una stringa dinamica, il parametro non viene codificato come un semplice intero VLQ. Invece viene codificato trasmettendo la lunghezza come intero codificato VLQ seguito dal contenuto stesso: <VLQ encoded length><n-byte contents> Le descrizioni dei comandi che si trovano nel dizionario dei dati consentono sia all'host che al microcontrollore di sapere quali parametri del comando utilizzano la semplice codifica VLQ e quali parametri utilizzano la codifica delle stringhe. Dizionario dati \u00b6 Affinch\u00e9 vengano stabilite comunicazioni significative tra microcontrollore e host, entrambe le parti devono concordare un \"dizionario dei dati\". Questo dizionario di dati contiene gli identificatori interi per comandi e risposte insieme alle relative descrizioni. La build del microcontrollore utilizza il contenuto delle macro DECL_COMMAND() e sendf() per generare il dizionario dei dati. La build assegna automaticamente identificatori univoci a ciascun comando e risposta. Questo sistema consente sia all'host che al codice del microcontrollore di utilizzare senza problemi nomi descrittivi leggibili dall'uomo pur utilizzando una larghezza di banda minima. L'host interroga il dizionario dei dati quando si connette per la prima volta al microcontrollore. Una volta che l'host ha scaricato il dizionario dei dati dal microcontrollore, utilizza quel dizionario dei dati per codificare tutti i comandi e per analizzare tutte le risposte dal microcontrollore. L'host deve quindi gestire un dizionario di dati dinamico. Tuttavia, per mantenere semplice il software del microcontrollore, il microcontrollore utilizza sempre il suo dizionario dati statico (compilato). Il dizionario dei dati viene interrogato inviando i comandi \"identify\" al microcontrollore. Il microcontrollore risponder\u00e0 a ogni comando di identificazione con un messaggio \"identify_response\". Poich\u00e9 questi due comandi sono necessari prima di ottenere il dizionario dei dati, i loro ID interi e tipi di parametri sono codificati sia nel microcontrollore che nell'host. L'ID della risposta \"identify_response\" \u00e8 0, l'ID del comando \"identify\" \u00e8 1. Oltre ad avere ID hardcoded, il comando di identificazione e la relativa risposta vengono dichiarati e trasmessi allo stesso modo degli altri comandi e risposte. Nessun altro comando o risposta \u00e8 hardcoded. Il formato del dizionario dei dati trasmessi stesso \u00e8 una stringa JSON compressa zlib. Il processo di compilazione del microcontrollore genera la stringa, la comprime e la memorizza nella sezione di testo del flash del microcontrollore. Il dizionario dei dati pu\u00f2 essere molto pi\u00f9 grande della dimensione massima del blocco del messaggio: l'host lo scarica inviando pi\u00f9 comandi di identificazione che richiedono blocchi progressivi del dizionario dei dati. Una volta ottenuti tutti i blocchi, l'host assembler\u00e0 i blocchi, decomprimer\u00e0 i dati e analizzer\u00e0 il contenuto. Oltre alle informazioni sul protocollo di comunicazione, il dizionario dei dati contiene anche la versione del software, le enumerazioni (come definite da DECL_ENUMERATION) e le costanti (come definite da DECL_CONSTANT). Flusso di messaggi \u00b6 I comandi dei messaggi inviati dall'host al microcontrollore sono concepiti per essere privi di errori. Il microcontrollore controller\u00e0 il CRC e i numeri di sequenza in ciascun blocco di messaggi per garantire che i comandi siano accurati e in ordine. Il microcontrollore elabora sempre i blocchi di messaggi in ordine - se riceve un blocco fuori ordine, lo scarter\u00e0 e tutti gli altri blocchi fuori ordine fino a quando non riceve blocchi con la sequenza corretta. Il codice host di basso livello implementa un sistema di ritrasmissione automatica per i blocchi di messaggi persi e corrotti inviati al microcontrollore. Per facilitare ci\u00f2, il microcontrollore trasmette un \"ack message block\" dopo ogni blocco di messaggio ricevuto con successo. L'host pianifica un timeout dopo l'invio di ogni blocco e lo ritrasmetter\u00e0 se il timeout scade senza ricevere un corrispondente \"ack\". Inoltre, se il microcontrollore rileva un blocco corrotto o fuori servizio, pu\u00f2 trasmettere un \"nak message block\" per facilitare una rapida ritrasmissione. Un \"ack\" \u00e8 un blocco di messaggi con contenuto vuoto (cio\u00e8 un blocco di messaggi di 5 byte) e un numero di sequenza maggiore dell'ultimo numero di sequenza dell'host ricevuto. Un \"nak\" \u00e8 un blocco di messaggi con contenuto vuoto e un numero di sequenza inferiore all'ultimo numero di sequenza host ricevuto. Il protocollo facilita un sistema di trasmissione \"finestra\" in modo che l'host possa avere molti blocchi di messaggi in sospeso in viaggio alla volta. (Questo \u00e8 in aggiunta ai molti comandi che possono essere presenti in un determinato blocco di messaggi.) Ci\u00f2 consente il massimo utilizzo della larghezza di banda anche in caso di latenza di trasmissione. Il meccanismo di timeout, ritrasmissione, windowing e ack si ispira a meccanismi simili in TCP . Nell'altra direzione, i blocchi di messaggi inviati dal microcontrollore all'host sono progettati per essere privi di errori, ma non hanno una trasmissione sicura. (Le risposte non dovrebbero essere danneggiate, ma potrebbero scomparire.) Questo viene fatto per mantenere semplice l'implementazione nel microcontrollore. Non esiste un sistema di ritrasmissione automatica delle risposte: ci si aspetta che il codice di alto livello sia in grado di gestire una risposta mancante occasionale (di solito richiedendo nuovamente il contenuto o impostando un programma ricorrente di trasmissione della risposta). Il campo del numero di sequenza nei blocchi di messaggi inviati all'host \u00e8 sempre uno maggiore dell'ultimo numero di sequenza di blocchi di messaggi ricevuti dall'host. Non viene utilizzato per tenere traccia di sequenze di blocchi di messaggi di risposta.","title":"Protocollo"},{"location":"Protocol.html#protocollo","text":"Il protocollo di messaggistica Klipper viene utilizzato per la comunicazione di basso livello tra il software host Klipper e il software microcontrollore Klipper. Ad alto livello il protocollo pu\u00f2 essere pensato come una serie di stringhe di comando e risposta che vengono compresse, trasmesse e quindi elaborate sul lato ricevente. Una serie di esempio di comandi in formato non compresso leggibile dall'uomo potrebbe essere simile a: set_digital_out pin=PA3 value=1 set_digital_out pin=PA7 value=1 schedule_digital_out oid=8 clock=4000000 value=0 queue_step oid=7 interval=7458 count=10 add=331 queue_step oid=7 interval=11717 count=4 add=1281 Vedere il documento mcu commands per informazioni sui comandi disponibili. Vedere il documento debugging per informazioni su come tradurre un file G-Code nei corrispondenti comandi del microcontrollore leggibili dall'uomo. Questa pagina fornisce una descrizione di alto livello del protocollo di messaggistica Klipper. Descrive come i messaggi sono dichiarati, codificati in formato binario (lo schema di \"compressione\") e trasmessi. L'obiettivo del protocollo \u00e8 abilitare un canale di comunicazione privo di errori tra l'host e il microcontrollore che sia a bassa latenza, bassa larghezza di banda e bassa complessit\u00e0 per il microcontrollore.","title":"Protocollo"},{"location":"Protocol.html#interfaccia-microcontrollore","text":"Il protocollo di trasmissione Klipper pu\u00f2 essere pensato come un meccanismo RPC tra microcontrollore e host. Il software del microcontrollore dichiara i comandi che l'host pu\u00f2 richiamare insieme ai messaggi di risposta che pu\u00f2 generare. L'host utilizza tali informazioni per comandare al microcontrollore di eseguire azioni e interpretare i risultati.","title":"Interfaccia microcontrollore"},{"location":"Protocol.html#dichiarazione-dei-comandi","text":"Il software del microcontrollore dichiara un \"comando\" utilizzando la macro DECL_COMMAND() nel codice C. Per esempio: DECL_COMMAND(command_update_digital_out, \"update_digital_out oid=%c value=%c\"); Quanto sopra dichiara un comando denominato \"update_digital_out\". Ci\u00f2 consente all'host di \"richiamare\" questo comando che causerebbe l'esecuzione della funzione C command_update_digital_out() nel microcontrollore. Quanto sopra indica anche che il comando accetta due parametri interi. Quando viene eseguito il codice C command_update_digital_out(), verr\u00e0 passata una matrice contenente questi due numeri interi: il primo corrispondente all'\"oid\" e il secondo corrispondente al \"valore\". In generale, i parametri sono descritti con la sintassi di stile printf() (ad esempio, \"%u\"). La formattazione corrisponde direttamente alla visualizzazione leggibile dei comandi (ad es. \"update_digital_out oid=7 value=1\"). Nell'esempio precedente, \"value=\" \u00e8 un nome di parametro e \"%c\" indica che il parametro \u00e8 un numero intero. Internamente, il nome del parametro viene utilizzato solo come documentazione. In questo esempio, \"%c\" viene utilizzato anche come documentazione per indicare che l'intero previsto ha una dimensione di 1 byte (la dimensione intera dichiarata non influisce sull'analisi o sulla codifica). La build del microcontrollore raccoglier\u00e0 tutti i comandi dichiarati con DECL_COMMAND(), ne determiner\u00e0 i parametri e far\u00e0 in modo che siano richiamabili.","title":"Dichiarazione dei comandi"},{"location":"Protocol.html#declaring-responses","text":"Per inviare informazioni dal microcontrollore all'host viene generata una \"risposta\". Questi sono sia dichiarati che trasmessi usando la macro C sendf(). Per esempio: sendf(\"status clock=%u status=%c\", sched_read_time(), sched_is_shutdown()); Quanto sopra trasmette un messaggio di risposta di \"stato\" che contiene due parametri interi (\"clock\" e \"status\"). La build del microcontrollore trova automaticamente tutte le chiamate sendf() e genera codificatori per esse. Il primo parametro della funzione sendf() descrive la risposta ed \u00e8 nello stesso formato delle dichiarazioni di comando. L'host pu\u00f2 organizzare la registrazione di una funzione di richiamata per ogni risposta. Quindi, in effetti, i comandi consentono all'host di invocare le funzioni C nel microcontrollore e le risposte consentono al software del microcontrollore di richiamare il codice nell'host. La macro sendf() deve essere invocata solo da gestori di comandi o attivit\u00e0 e non deve essere invocata da interrupt o timer. Il codice non ha bisogno di emettere un sendf() in risposta a un comando ricevuto, non \u00e8 limitato nel numero di volte in cui sendf() pu\u00f2 essere invocato e pu\u00f2 invocare sendf() in qualsiasi momento da un task handler.","title":"Declaring responses"},{"location":"Protocol.html#risposte-in-output","text":"Per semplificare il debug, esiste anche una funzione C output(). Per esempio: output(\"Il valore di%u \u00e8 %s con dimensione %u.\", x, buf, buf_len); La funzione output() \u00e8 simile nell'uso a printf() - \u00e8 intesa per generare e formattare messaggi arbitrari per il 'consumo umano'.","title":"Risposte in output"},{"location":"Protocol.html#dichiarazione-di-enumerazioni","text":"Le enumerazioni consentono al codice host di utilizzare identificatori di stringa per i parametri che il microcontrollore gestisce come numeri interi. Sono dichiarati nel codice del microcontrollore, ad esempio: DECL_ENUMERATION(\"spi_bus\", \"spi\", 0); DECL_ENUMERATION_RANGE(\"pin\", \"PC0\", 16, 8); Se il primo esempio, la macro DECL_ENUMERATION() definisce un'enumerazione per qualsiasi messaggio di comando/risposta con nome parametro \"spi_bus\" o nome parametro con suffisso \"_spi_bus\". Per quei parametri la stringa \"spi\" \u00e8 un valore valido e verr\u00e0 trasmessa con un valore intero pari a zero. \u00c8 anche possibile dichiarare un intervallo di enumerazione. Nel secondo esempio, un parametro \"pin\" (o qualsiasi parametro con suffisso \"_pin\") accetterebbe PC0, PC1, PC2, ..., PC7 come valori validi. Le stringhe verranno trasmesse con numeri interi 16, 17, 18, ..., 23.","title":"Dichiarazione di enumerazioni"},{"location":"Protocol.html#dichiarazione-di-costanti","text":"Le costanti possono anche essere esportate. Ad esempio, quanto segue: DECL_CONSTANT(\"SERIAL_BAUD\", 250000); esporterebbe una costante denominata \"SERIAL_BAUD\" con un valore di 250000 dal microcontrollore all'host. \u00c8 anche possibile dichiarare una costante che \u00e8 una stringa, ad esempio: DECL_CONSTANT_STR(\"MCU\", \"pru\");","title":"Dichiarazione di costanti"},{"location":"Protocol.html#codifica-dei-messaggi-di-basso-livello","text":"Per realizzare il meccanismo RPC di cui sopra, ogni comando e risposta viene codificato in un formato binario per la trasmissione. Questa sezione descrive il sistema di trasmissione.","title":"Codifica dei messaggi di basso livello"},{"location":"Protocol.html#blocchi-di-messaggi","text":"Tutti i dati inviati dall'host al microcontrollore e viceversa sono contenuti in \"blocchi di messaggi\". Un blocco di messaggi ha un'intestazione di due byte e un trailer di tre byte. Il formato di un blocco di messaggi \u00e8: <1 byte lunghezza><1 byte sequenza><n-byte contenuto><2 byte crc><1 byte sync> Il byte di lunghezza contiene il numero di byte nel blocco di messaggi inclusi i byte di intestazione e trailer (quindi la lunghezza minima del messaggio \u00e8 5 byte). La lunghezza massima del blocco di messaggi \u00e8 attualmente di 64 byte. Il byte di sequenza contiene un numero di sequenza di 4 bit nei bit di ordine inferiore e i bit di ordine superiore contengono sempre 0x10 (i bit di ordine superiore sono riservati per un uso futuro). I byte di contenuto contengono dati arbitrari e il relativo formato \u00e8 descritto nella sezione seguente. I byte crc contengono un CCITT CRC a 16 bit del blocco di messaggi inclusi i byte di intestazione ma esclusi i byte di trailer. Il byte di sincronizzazione \u00e8 0x7e. Il formato del blocco di messaggi si ispira ai telegrammi HDLC . Come in HDLC, il blocco di messaggi pu\u00f2 contenere facoltativamente un carattere di sincronizzazione aggiuntivo all'inizio del blocco. A differenza di HDLC, un carattere di sincronizzazione non \u00e8 esclusivo del framing e pu\u00f2 essere presente nel contenuto del blocco di messaggi.","title":"Blocchi di messaggi"},{"location":"Protocol.html#contenuto-del-blocco-messaggi","text":"Ogni blocco di messaggi inviato dall'host al microcontrollore contiene una serie di zero o pi\u00f9 comandi di messaggi. Ogni comando inizia con un Quantit\u00e0 a lunghezza variabile (VLQ) command-id seguito da zero o pi\u00f9 parametri VLQ per il comando dato. Ad esempio, i seguenti quattro comandi possono essere inseriti in un unico blocco di messaggi: update_digital_out oid=6 value=1 update_digital_out oid=5 value=0 get_config get_clock e codificato nei seguenti otto interi VLQ: <id_update_digital_out><6><1><id_update_digital_out><5><0><id_get_config><id_get_clock> Per codificare e analizzare il contenuto del messaggio, sia l'host che il microcontrollore devono concordare gli ID comando e il numero di parametri di ciascun comando. Quindi, nell'esempio sopra, sia l'host che il microcontrollore saprebbero che \"id_update_digital_out\" \u00e8 sempre seguito da due parametri e \"id_get_config\" e \"id_get_clock\" hanno zero parametri. L'host e il microcontrollore condividono un \"dizionario dei dati\" che mappa le descrizioni dei comandi (ad esempio, \"update_digital_out oid=%c value=%c\") ai loro ID di comando interi. Durante l'elaborazione dei dati, il parser sapr\u00e0 di aspettarsi un numero specifico di parametri codificati VLQ a seguito di un determinato ID comando. Il contenuto del messaggio per i blocchi inviati dal microcontrollore all'host segue lo stesso formato. Gli identificatori in questi messaggi sono \"ID di risposta\", ma servono allo stesso scopo e seguono le stesse regole di codifica. In pratica, i blocchi di messaggi inviati dal microcontrollore all'host non contengono mai pi\u00f9 di una risposta nel contenuto del blocco di messaggi.","title":"Contenuto del blocco messaggi"},{"location":"Protocol.html#quantita-di-lunghezza-variabile","text":"Consulta l' articolo di Wikipedia per ulteriori informazioni sul formato generale degli interi codificati VLQ. Klipper utilizza uno schema di codifica che supporta numeri interi positivi e negativi. Gli interi prossimi allo zero utilizzano meno byte per codificare e gli interi positivi in genere codificano utilizzando meno byte degli interi negativi. La tabella seguente mostra il numero di byte che ogni intero impiega per codificare: Intero Dimensione codificata -32 .. 95 1 -4096 .. 12287 2 -524288 .. 1572863 3 -67108864 .. 201326591 4 -2147483648 .. 4294967295 5","title":"Quantit\u00e0 di lunghezza variabile"},{"location":"Protocol.html#stringhe-di-lunghezza-variabile","text":"Come eccezione alle regole di codifica precedenti, se un parametro di un comando o di una risposta \u00e8 una stringa dinamica, il parametro non viene codificato come un semplice intero VLQ. Invece viene codificato trasmettendo la lunghezza come intero codificato VLQ seguito dal contenuto stesso: <VLQ encoded length><n-byte contents> Le descrizioni dei comandi che si trovano nel dizionario dei dati consentono sia all'host che al microcontrollore di sapere quali parametri del comando utilizzano la semplice codifica VLQ e quali parametri utilizzano la codifica delle stringhe.","title":"Stringhe di lunghezza variabile"},{"location":"Protocol.html#dizionario-dati","text":"Affinch\u00e9 vengano stabilite comunicazioni significative tra microcontrollore e host, entrambe le parti devono concordare un \"dizionario dei dati\". Questo dizionario di dati contiene gli identificatori interi per comandi e risposte insieme alle relative descrizioni. La build del microcontrollore utilizza il contenuto delle macro DECL_COMMAND() e sendf() per generare il dizionario dei dati. La build assegna automaticamente identificatori univoci a ciascun comando e risposta. Questo sistema consente sia all'host che al codice del microcontrollore di utilizzare senza problemi nomi descrittivi leggibili dall'uomo pur utilizzando una larghezza di banda minima. L'host interroga il dizionario dei dati quando si connette per la prima volta al microcontrollore. Una volta che l'host ha scaricato il dizionario dei dati dal microcontrollore, utilizza quel dizionario dei dati per codificare tutti i comandi e per analizzare tutte le risposte dal microcontrollore. L'host deve quindi gestire un dizionario di dati dinamico. Tuttavia, per mantenere semplice il software del microcontrollore, il microcontrollore utilizza sempre il suo dizionario dati statico (compilato). Il dizionario dei dati viene interrogato inviando i comandi \"identify\" al microcontrollore. Il microcontrollore risponder\u00e0 a ogni comando di identificazione con un messaggio \"identify_response\". Poich\u00e9 questi due comandi sono necessari prima di ottenere il dizionario dei dati, i loro ID interi e tipi di parametri sono codificati sia nel microcontrollore che nell'host. L'ID della risposta \"identify_response\" \u00e8 0, l'ID del comando \"identify\" \u00e8 1. Oltre ad avere ID hardcoded, il comando di identificazione e la relativa risposta vengono dichiarati e trasmessi allo stesso modo degli altri comandi e risposte. Nessun altro comando o risposta \u00e8 hardcoded. Il formato del dizionario dei dati trasmessi stesso \u00e8 una stringa JSON compressa zlib. Il processo di compilazione del microcontrollore genera la stringa, la comprime e la memorizza nella sezione di testo del flash del microcontrollore. Il dizionario dei dati pu\u00f2 essere molto pi\u00f9 grande della dimensione massima del blocco del messaggio: l'host lo scarica inviando pi\u00f9 comandi di identificazione che richiedono blocchi progressivi del dizionario dei dati. Una volta ottenuti tutti i blocchi, l'host assembler\u00e0 i blocchi, decomprimer\u00e0 i dati e analizzer\u00e0 il contenuto. Oltre alle informazioni sul protocollo di comunicazione, il dizionario dei dati contiene anche la versione del software, le enumerazioni (come definite da DECL_ENUMERATION) e le costanti (come definite da DECL_CONSTANT).","title":"Dizionario dati"},{"location":"Protocol.html#flusso-di-messaggi","text":"I comandi dei messaggi inviati dall'host al microcontrollore sono concepiti per essere privi di errori. Il microcontrollore controller\u00e0 il CRC e i numeri di sequenza in ciascun blocco di messaggi per garantire che i comandi siano accurati e in ordine. Il microcontrollore elabora sempre i blocchi di messaggi in ordine - se riceve un blocco fuori ordine, lo scarter\u00e0 e tutti gli altri blocchi fuori ordine fino a quando non riceve blocchi con la sequenza corretta. Il codice host di basso livello implementa un sistema di ritrasmissione automatica per i blocchi di messaggi persi e corrotti inviati al microcontrollore. Per facilitare ci\u00f2, il microcontrollore trasmette un \"ack message block\" dopo ogni blocco di messaggio ricevuto con successo. L'host pianifica un timeout dopo l'invio di ogni blocco e lo ritrasmetter\u00e0 se il timeout scade senza ricevere un corrispondente \"ack\". Inoltre, se il microcontrollore rileva un blocco corrotto o fuori servizio, pu\u00f2 trasmettere un \"nak message block\" per facilitare una rapida ritrasmissione. Un \"ack\" \u00e8 un blocco di messaggi con contenuto vuoto (cio\u00e8 un blocco di messaggi di 5 byte) e un numero di sequenza maggiore dell'ultimo numero di sequenza dell'host ricevuto. Un \"nak\" \u00e8 un blocco di messaggi con contenuto vuoto e un numero di sequenza inferiore all'ultimo numero di sequenza host ricevuto. Il protocollo facilita un sistema di trasmissione \"finestra\" in modo che l'host possa avere molti blocchi di messaggi in sospeso in viaggio alla volta. (Questo \u00e8 in aggiunta ai molti comandi che possono essere presenti in un determinato blocco di messaggi.) Ci\u00f2 consente il massimo utilizzo della larghezza di banda anche in caso di latenza di trasmissione. Il meccanismo di timeout, ritrasmissione, windowing e ack si ispira a meccanismi simili in TCP . Nell'altra direzione, i blocchi di messaggi inviati dal microcontrollore all'host sono progettati per essere privi di errori, ma non hanno una trasmissione sicura. (Le risposte non dovrebbero essere danneggiate, ma potrebbero scomparire.) Questo viene fatto per mantenere semplice l'implementazione nel microcontrollore. Non esiste un sistema di ritrasmissione automatica delle risposte: ci si aspetta che il codice di alto livello sia in grado di gestire una risposta mancante occasionale (di solito richiedendo nuovamente il contenuto o impostando un programma ricorrente di trasmissione della risposta). Il campo del numero di sequenza nei blocchi di messaggi inviati all'host \u00e8 sempre uno maggiore dell'ultimo numero di sequenza di blocchi di messaggi ricevuti dall'host. Non viene utilizzato per tenere traccia di sequenze di blocchi di messaggi di risposta.","title":"Flusso di messaggi"},{"location":"RPi_microcontroller.html","text":"Microcontrollore RPi \u00b6 Questo documento descrive il processo di esecuzione di Klipper su un RPi e usa lo stesso RPi come mcu secondario. Perch\u00e9 usare RPi come MCU secondario? \u00b6 Spesso gli MCU dedicati al controllo delle stampanti 3D hanno un numero limitato e preconfigurato di pin esposti per gestire le principali funzioni di stampa (resistenze termiche, estrusori, stepper...). L'utilizzo dell'RPi dove Klipper \u00e8 installato come MCU secondario d\u00e0 la possibilit\u00e0 di utilizzare direttamente i GPIO e i bus (i2c, spi) dell'RPi all'interno di klipper senza utilizzare plugin Octoprint (se utilizzati) o programmi esterni dando la possibilit\u00e0 di controllare tutto all'interno del GCODE di stampa. Attenzione : Se la tua piattaforma \u00e8 un Beaglebone e hai seguito correttamente i passi di installazione, la mcu linux \u00e8 gi\u00e0 installata e configurata per il tuo sistema. Installa lo script rc \u00b6 Se si desidera utilizzare l'host come MCU secondario, il processo di klipper_mcu deve essere eseguito prima del processo klippy. Dopo aver installato Klipper, installare lo script. eseguire: cd ~/klipper/ sudo cp ./scripts/klipper-mcu.service /etc/systemd/system/ sudo systemctl enable klipper-mcu.service Creazione del codice del microcontrollore \u00b6 Per compilare il codice del microcontrollore Klipper, iniziate configurandolo per il \"processo Linux\": cd ~/klipper/ make menuconfig Nel menu, impostate \"Microcontroller Architecture\" su \"Linux process\", poi salvate e uscite. Per compilare e installare il nuovo codice del microcontrollore, eseguire: sudo service klipper stop make flash sudo service klipper start Se klippy.log segnala un errore \"Autorizzazione negata\" quando si tenta di connettersi a /tmp/klipper_host_mcu , \u00e8 necessario aggiungere l'utente al gruppo tty. Il seguente comando aggiunger\u00e0 l'utente \"pi\" al gruppo tty: sudo usermod -a -G tty pi Configurazione rimanente \u00b6 Completare l'installazione configurando l'MCU secondario di Klipper seguendo le istruzioni in RaspberryPi sample config e Multi MCU sample config . Facoltativo: abilitazione di SPI \u00b6 Assicurati che il driver SPI di Linux sia abilitato eseguendo sudo raspi-config e abilitando SPI nel menu \"Opzioni di interfaccia\". Opzionale: abilitazione di I2C \u00b6 Assicurati che l'interfaccia Linux I2C sia abilitato eseguendo sudo raspi-config e abilitando I2C nel menu \"Opzioni di interfaccia\". Se si intende utilizzare I2C per l'accelerometro MPU, \u00e8 anche necessario impostare il baud rate su 400000: aggiungendo/deselezionando dtparam=i2c_arm=on,i2c_arm_baudrate=400000 in /boot/config.txt (o / boot/firmware/config.txt in alcune distribuzioni). Opzionale: Identificare il gpiochip corretto \u00b6 Su Raspberry Pi e su molti cloni i pin esposti sul GPIO appartengono al primo gpiochip. Possono quindi essere utilizzati su klipper semplicemente riferendoli con il nome gpio0..n . Tuttavia, ci sono casi in cui i pin esposti appartengono a gpiochip diversi dal primo. Ad esempio nel caso di alcuni modelli OrangePi o se viene utilizzato un Port Expander. In questi casi \u00e8 utile utilizzare i comandi per accedere al dispositivo a caratteri GPIO Linux per verificarne la configurazione. Per installare il Linux GPIO character device - binary su una distro basata su debian come octopi eseguire: sudo apt-get install gpiod Per controllare i gpiochip disponibili eseguire: gpiodetect Per verificare il numero di pin e la disponibilit\u00e0 dei pin: gpioinfo Il pin scelto pu\u00f2 quindi essere utilizzato all'interno della configurazione come gpiochip<n>/gpio<o> dove n \u00e8 il numero del chip visto dal comando gpiodetect e o \u00e8 il numero di riga visto dal comando gpioinfo . Attenzione: solo i gpio contrassegnati come inutilizzati possono essere utilizzati. Non \u00e8 possibile che una linea sia usata da pi\u00f9 processi contemporaneamente. Per esempio su un RPi 3B+ dove klipper usa il GPIO20 per un interruttore: $ gpiodetect gpiochip0 [pinctrl-bcm2835] (54 lines) gpiochip1 [raspberrypi-exp-gpio] (8 lines) $ gpioinfo gpiochip0 - 54 lines: line 0: unnamed unused input active-high line 1: unnamed unused input active-high line 2: unnamed unused input active-high line 3: unnamed unused input active-high line 4: unnamed unused input active-high line 5: unnamed unused input active-high line 6: unnamed unused input active-high line 7: unnamed unused input active-high line 8: unnamed unused input active-high line 9: unnamed unused input active-high line 10: unnamed unused input active-high line 11: unnamed unused input active-high line 12: unnamed unused input active-high line 13: unnamed unused input active-high line 14: unnamed unused input active-high line 15: unnamed unused input active-high line 16: unnamed unused input active-high line 17: unnamed unused input active-high line 18: unnamed unused input active-high line 19: unnamed unused input active-high line 20: unnamed \"klipper\" output active-high [used] line 21: unnamed unused input active-high line 22: unnamed unused input active-high line 23: unnamed unused input active-high line 24: unnamed unused input active-high line 25: unnamed unused input active-high line 26: unnamed unused input active-high line 27: unnamed unused input active-high line 28: unnamed unused input active-high line 29: unnamed \"led0\" output active-high [used] line 30: unnamed unused input active-high line 31: unnamed unused input active-high line 32: unnamed unused input active-high line 33: unnamed unused input active-high line 34: unnamed unused input active-high line 35: unnamed unused input active-high line 36: unnamed unused input active-high line 37: unnamed unused input active-high line 38: unnamed unused input active-high line 39: unnamed unused input active-high line 40: unnamed unused input active-high line 41: unnamed unused input active-high line 42: unnamed unused input active-high line 43: unnamed unused input active-high line 44: unnamed unused input active-high line 45: unnamed unused input active-high line 46: unnamed unused input active-high line 47: unnamed unused input active-high line 48: unnamed unused input active-high line 49: unnamed unused input active-high line 50: unnamed unused input active-high line 51: unnamed unused input active-high line 52: unnamed unused input active-high line 53: unnamed unused input active-high gpiochip1 - 8 lines: line 0: unnamed unused input active-high line 1: unnamed unused input active-high line 2: unnamed \"led1\" output active-low [used] line 3: unnamed unused input active-high line 4: unnamed unused input active-high line 5: unnamed unused input active-high line 6: unnamed unused input active-high line 7: unnamed unused input active-high Opzionale: Hardware PWM \u00b6 I Raspberry Pi hanno due canali PWM (PWM0 e PWM1) che sono esposti sull'intestazione o, in caso contrario, possono essere instradati ai pin gpio esistenti. Il demone mcu Linux utilizza l'interfaccia sysfs pwmchip per controllare i dispositivi hardware pwm sugli host Linux. L'interfaccia sysfs pwm non \u00e8 esposta per impostazione predefinita su un Raspberry e pu\u00f2 essere attivata aggiungendo una riga a /boot/config.txt : # Abilita l'interfaccia sysfs di pwmchip dtoverlay=pwm,pin=12,func=4 This example enables only PWM0 and routes it to gpio12. If both PWM channels need to be enabled you can use pwm-2chan : # Enable pwmchip sysfs interface dtoverlay=pwm-2chan,pin=12,func=4,pin2=13,func2=4 This example additionally enables PWM1 and routes it to gpio13. The overlay does not expose the pwm line on sysfs on boot and needs to be exported by echo'ing the number of the pwm channel to /sys/class/pwm/pwmchip0/export . This will create device /sys/class/pwm/pwmchip0/pwm0 in the filesystem. The easiest way to do this is by adding this to /etc/rc.local before the exit 0 line: # Enable pwmchip sysfs interface echo 0 > /sys/class/pwm/pwmchip0/export When using both PWM channels, the number of the second channel needs to be echo'd as well: # Enable pwmchip sysfs interface echo 0 > /sys/class/pwm/pwmchip0/export echo 1 > /sys/class/pwm/pwmchip0/export Con il sysfs a posto, potete ora utilizzare il canale o i canali pwm aggiungendo il seguente pezzo di configurazione al vostro printer.cfg : [output_pin caselight] pin: host:pwmchip0/pwm0 pwm: True hardware_pwm: True cycle_time: 0.000001 [output_pin beeper] pin: host:pwmchip0/pwm1 pwm: True hardware_pwm: True value: 0 shutdown_value: 0 cycle_time: 0.0005 This will add hardware pwm control to gpio12 and gpio13 on the Pi (because the overlay was configured to route pwm0 to pin=12 and pwm1 to pin=13). PWM0 pu\u00f2 essere indirizzato su gpio12 e gpio18, PWM1 pu\u00f2 essere indirizzato su gpio13 e gpio19: PWM gpio PIN Func 0 12 4 0 18 2 1 13 4 1 19 2","title":"Microcontrollore RPi"},{"location":"RPi_microcontroller.html#microcontrollore-rpi","text":"Questo documento descrive il processo di esecuzione di Klipper su un RPi e usa lo stesso RPi come mcu secondario.","title":"Microcontrollore RPi"},{"location":"RPi_microcontroller.html#perche-usare-rpi-come-mcu-secondario","text":"Spesso gli MCU dedicati al controllo delle stampanti 3D hanno un numero limitato e preconfigurato di pin esposti per gestire le principali funzioni di stampa (resistenze termiche, estrusori, stepper...). L'utilizzo dell'RPi dove Klipper \u00e8 installato come MCU secondario d\u00e0 la possibilit\u00e0 di utilizzare direttamente i GPIO e i bus (i2c, spi) dell'RPi all'interno di klipper senza utilizzare plugin Octoprint (se utilizzati) o programmi esterni dando la possibilit\u00e0 di controllare tutto all'interno del GCODE di stampa. Attenzione : Se la tua piattaforma \u00e8 un Beaglebone e hai seguito correttamente i passi di installazione, la mcu linux \u00e8 gi\u00e0 installata e configurata per il tuo sistema.","title":"Perch\u00e9 usare RPi come MCU secondario?"},{"location":"RPi_microcontroller.html#installa-lo-script-rc","text":"Se si desidera utilizzare l'host come MCU secondario, il processo di klipper_mcu deve essere eseguito prima del processo klippy. Dopo aver installato Klipper, installare lo script. eseguire: cd ~/klipper/ sudo cp ./scripts/klipper-mcu.service /etc/systemd/system/ sudo systemctl enable klipper-mcu.service","title":"Installa lo script rc"},{"location":"RPi_microcontroller.html#creazione-del-codice-del-microcontrollore","text":"Per compilare il codice del microcontrollore Klipper, iniziate configurandolo per il \"processo Linux\": cd ~/klipper/ make menuconfig Nel menu, impostate \"Microcontroller Architecture\" su \"Linux process\", poi salvate e uscite. Per compilare e installare il nuovo codice del microcontrollore, eseguire: sudo service klipper stop make flash sudo service klipper start Se klippy.log segnala un errore \"Autorizzazione negata\" quando si tenta di connettersi a /tmp/klipper_host_mcu , \u00e8 necessario aggiungere l'utente al gruppo tty. Il seguente comando aggiunger\u00e0 l'utente \"pi\" al gruppo tty: sudo usermod -a -G tty pi","title":"Creazione del codice del microcontrollore"},{"location":"RPi_microcontroller.html#configurazione-rimanente","text":"Completare l'installazione configurando l'MCU secondario di Klipper seguendo le istruzioni in RaspberryPi sample config e Multi MCU sample config .","title":"Configurazione rimanente"},{"location":"RPi_microcontroller.html#facoltativo-abilitazione-di-spi","text":"Assicurati che il driver SPI di Linux sia abilitato eseguendo sudo raspi-config e abilitando SPI nel menu \"Opzioni di interfaccia\".","title":"Facoltativo: abilitazione di SPI"},{"location":"RPi_microcontroller.html#opzionale-abilitazione-di-i2c","text":"Assicurati che l'interfaccia Linux I2C sia abilitato eseguendo sudo raspi-config e abilitando I2C nel menu \"Opzioni di interfaccia\". Se si intende utilizzare I2C per l'accelerometro MPU, \u00e8 anche necessario impostare il baud rate su 400000: aggiungendo/deselezionando dtparam=i2c_arm=on,i2c_arm_baudrate=400000 in /boot/config.txt (o / boot/firmware/config.txt in alcune distribuzioni).","title":"Opzionale: abilitazione di I2C"},{"location":"RPi_microcontroller.html#opzionale-identificare-il-gpiochip-corretto","text":"Su Raspberry Pi e su molti cloni i pin esposti sul GPIO appartengono al primo gpiochip. Possono quindi essere utilizzati su klipper semplicemente riferendoli con il nome gpio0..n . Tuttavia, ci sono casi in cui i pin esposti appartengono a gpiochip diversi dal primo. Ad esempio nel caso di alcuni modelli OrangePi o se viene utilizzato un Port Expander. In questi casi \u00e8 utile utilizzare i comandi per accedere al dispositivo a caratteri GPIO Linux per verificarne la configurazione. Per installare il Linux GPIO character device - binary su una distro basata su debian come octopi eseguire: sudo apt-get install gpiod Per controllare i gpiochip disponibili eseguire: gpiodetect Per verificare il numero di pin e la disponibilit\u00e0 dei pin: gpioinfo Il pin scelto pu\u00f2 quindi essere utilizzato all'interno della configurazione come gpiochip<n>/gpio<o> dove n \u00e8 il numero del chip visto dal comando gpiodetect e o \u00e8 il numero di riga visto dal comando gpioinfo . Attenzione: solo i gpio contrassegnati come inutilizzati possono essere utilizzati. Non \u00e8 possibile che una linea sia usata da pi\u00f9 processi contemporaneamente. Per esempio su un RPi 3B+ dove klipper usa il GPIO20 per un interruttore: $ gpiodetect gpiochip0 [pinctrl-bcm2835] (54 lines) gpiochip1 [raspberrypi-exp-gpio] (8 lines) $ gpioinfo gpiochip0 - 54 lines: line 0: unnamed unused input active-high line 1: unnamed unused input active-high line 2: unnamed unused input active-high line 3: unnamed unused input active-high line 4: unnamed unused input active-high line 5: unnamed unused input active-high line 6: unnamed unused input active-high line 7: unnamed unused input active-high line 8: unnamed unused input active-high line 9: unnamed unused input active-high line 10: unnamed unused input active-high line 11: unnamed unused input active-high line 12: unnamed unused input active-high line 13: unnamed unused input active-high line 14: unnamed unused input active-high line 15: unnamed unused input active-high line 16: unnamed unused input active-high line 17: unnamed unused input active-high line 18: unnamed unused input active-high line 19: unnamed unused input active-high line 20: unnamed \"klipper\" output active-high [used] line 21: unnamed unused input active-high line 22: unnamed unused input active-high line 23: unnamed unused input active-high line 24: unnamed unused input active-high line 25: unnamed unused input active-high line 26: unnamed unused input active-high line 27: unnamed unused input active-high line 28: unnamed unused input active-high line 29: unnamed \"led0\" output active-high [used] line 30: unnamed unused input active-high line 31: unnamed unused input active-high line 32: unnamed unused input active-high line 33: unnamed unused input active-high line 34: unnamed unused input active-high line 35: unnamed unused input active-high line 36: unnamed unused input active-high line 37: unnamed unused input active-high line 38: unnamed unused input active-high line 39: unnamed unused input active-high line 40: unnamed unused input active-high line 41: unnamed unused input active-high line 42: unnamed unused input active-high line 43: unnamed unused input active-high line 44: unnamed unused input active-high line 45: unnamed unused input active-high line 46: unnamed unused input active-high line 47: unnamed unused input active-high line 48: unnamed unused input active-high line 49: unnamed unused input active-high line 50: unnamed unused input active-high line 51: unnamed unused input active-high line 52: unnamed unused input active-high line 53: unnamed unused input active-high gpiochip1 - 8 lines: line 0: unnamed unused input active-high line 1: unnamed unused input active-high line 2: unnamed \"led1\" output active-low [used] line 3: unnamed unused input active-high line 4: unnamed unused input active-high line 5: unnamed unused input active-high line 6: unnamed unused input active-high line 7: unnamed unused input active-high","title":"Opzionale: Identificare il gpiochip corretto"},{"location":"RPi_microcontroller.html#opzionale-hardware-pwm","text":"I Raspberry Pi hanno due canali PWM (PWM0 e PWM1) che sono esposti sull'intestazione o, in caso contrario, possono essere instradati ai pin gpio esistenti. Il demone mcu Linux utilizza l'interfaccia sysfs pwmchip per controllare i dispositivi hardware pwm sugli host Linux. L'interfaccia sysfs pwm non \u00e8 esposta per impostazione predefinita su un Raspberry e pu\u00f2 essere attivata aggiungendo una riga a /boot/config.txt : # Abilita l'interfaccia sysfs di pwmchip dtoverlay=pwm,pin=12,func=4 This example enables only PWM0 and routes it to gpio12. If both PWM channels need to be enabled you can use pwm-2chan : # Enable pwmchip sysfs interface dtoverlay=pwm-2chan,pin=12,func=4,pin2=13,func2=4 This example additionally enables PWM1 and routes it to gpio13. The overlay does not expose the pwm line on sysfs on boot and needs to be exported by echo'ing the number of the pwm channel to /sys/class/pwm/pwmchip0/export . This will create device /sys/class/pwm/pwmchip0/pwm0 in the filesystem. The easiest way to do this is by adding this to /etc/rc.local before the exit 0 line: # Enable pwmchip sysfs interface echo 0 > /sys/class/pwm/pwmchip0/export When using both PWM channels, the number of the second channel needs to be echo'd as well: # Enable pwmchip sysfs interface echo 0 > /sys/class/pwm/pwmchip0/export echo 1 > /sys/class/pwm/pwmchip0/export Con il sysfs a posto, potete ora utilizzare il canale o i canali pwm aggiungendo il seguente pezzo di configurazione al vostro printer.cfg : [output_pin caselight] pin: host:pwmchip0/pwm0 pwm: True hardware_pwm: True cycle_time: 0.000001 [output_pin beeper] pin: host:pwmchip0/pwm1 pwm: True hardware_pwm: True value: 0 shutdown_value: 0 cycle_time: 0.0005 This will add hardware pwm control to gpio12 and gpio13 on the Pi (because the overlay was configured to route pwm0 to pin=12 and pwm1 to pin=13). PWM0 pu\u00f2 essere indirizzato su gpio12 e gpio18, PWM1 pu\u00f2 essere indirizzato su gpio13 e gpio19: PWM gpio PIN Func 0 12 4 0 18 2 1 13 4 1 19 2","title":"Opzionale: Hardware PWM"},{"location":"Releases.html","text":"Versioni \u00b6 Storico delle versioni di Klipper. Vedi installation per informazioni sull'installazione di Klipper. Klipper 0.11.0 \u00b6 Disponibile su 20221128. Modifiche principali in questa versione: Ottimizzazione \"passo su entrambi i lati\" del driver del motore passo-passo Trinamic. Supporto per Python3. Il codice host di Klipper verr\u00e0 eseguito con Python2 o Python3. Supporto bus CAN migliorato. Supporto per bus CAN su chip rp2040, stm32g0, stm32h7, same51 e same54. Supporto per la modalit\u00e0 \"Bridge da USB a CAN bus\". Supporto per il bootloader CanBoot. Supporto per accelerometri mpu9250 e mpu6050. Gestione degli errori migliorata per i sensori di temperatura max31856, max31855, max31865 e max6675. Ora \u00e8 possibile configurare i LED per l'aggiornamento durante i comandi G-Code di lunga durata utilizzando il supporto del \"template\" LED. Diversi miglioramenti del microcontrollore. Nuovo supporto per i chip stm32h743, stm32h750, stm32l412, stm32g0b1, same70, same51 e same54. Supporto per letture i2c su atsamd e stm32f0. Supporto hardware pwm su stm32. Invio di eventi basato sul segnale Linux mcu. Nuovo supporto rp2040 per \"make flash\", i2c ed errata USB rp2040-e5. Aggiunti nuovi moduli: angle, dac084S085, exclude_object, led, mpu9250, pca9632, smart_effector, z_thermal_adjust. Aggiunta nuova cinematica deltesiana. Nuovo strumento dump_mcu aggiunto. Correzione di diversi bug e pulizia del codice. Klipper 0.10.0 \u00b6 Disponibile su 20210929. Principali modifiche in questa versione: Supporto per \"Homing multi-MCU\". \u00c8 ora possibile collegare un motore passo-passo e il relativo fine corsa a microcontrollori separati. Ci\u00f2 semplifica il cablaggio delle sonde Z sulle \"schede portautensili\". Klipper ora ha un Community Discord Server e un Community Discourse Server . Il sito Web di Klipper ora utilizza l'infrastruttura \"mkdocs\". Esiste anche un progetto Klipper Translations . Supporto automatizzato per il flashing del firmware tramite sdcard su molte schede. Nuovo supporto cinematico per le stampanti \"Hybrid CoreXY\" e \"Hybrid CoreXZ\". Klipper ora usa rotation_distance per configurare le distanze di viaggio del motore passo-passo. Il codice host principale di Klipper ora pu\u00f2 comunicare direttamente con i microcontrollori utilizzando il bus CAN. Nuovo sistema di \"analisi del movimento\". Gli aggiornamenti di movimento interni di Klipper e i risultati dei sensori possono essere tracciati e registrati per l'analisi. I driver per motori passo-passo Trinamic sono ora costantemente monitorati per rilevare eventuali condizioni di errore. Supporto per il microcontrollore rp2040 (schede Raspberry Pi Pico). Il sistema \"make menuconfig\" ora utilizza kconfiglib. Molti moduli aggiuntivi aggiunti: ds18b20, duplicate_pin_override, filament_motion_sensor, palette2, motion_report, pca9533, pulse_counter, save_variables, sdcard_loop, temperature_host, temperature_mcu Correzione di diversi bug e pulizia del codice. Klipper 0.9.0 \u00b6 Disponibile su 20201020. Modifiche principali in questa versione: Supporto per \"Input Shaping\" - un meccanismo per contrastare la risonanza della stampante. Pu\u00f2 ridurre o eliminare il \"ringing\" nelle stampe. Nuovo sistema \"Smooth Pressure Advance\". Questo implementa \"Pressure Advance\" senza introdurre variazioni di velocit\u00e0 istantanee. Ora \u00e8 anche possibile regolare l'anticipo della pressione utilizzando un metodo \"Tuning Tower\". Nuovo server API \"webhook\". Ci\u00f2 fornisce un'interfaccia JSON programmabile a Klipper. Il display LCD e il menu sono ora configurabili utilizzando la lingua del modello Jinja2. I driver per motori passo-passo TMC2208 possono ora essere utilizzati in modalit\u00e0 \"standalone\" con Klipper. Supporto BL-Touch v3 migliorato. Identificazione USB migliorata. Klipper ora ha il proprio codice di identificazione USB e i microcontrollori possono ora riportare i loro numeri di serie univoci durante l'identificazione USB. Nuovo supporto cinematico per stampanti \"Rotary Delta\" e \"CoreXZ\". Miglioramenti del microcontrollore: supporto per stm32f070, supporto per stm32f207, supporto per pin GPIO su \"Linux MCU\", supporto per \"bootloader HID\" stm32, supporto per bootloader Chitu, supporto per bootloader MKS Robin. Gestione migliorata degli eventi di \"garbage collection\" di Python. Molti moduli aggiuntivi aggiunti: adc_scaled, adxl345, bme280, display_status, extruder_stepper, fan_generic, hall_filament_width_sensor, htu21d, homing_heaters, input_shaper, lm75, print_stats, resonance_tester, shaper_calibrate, query_adc, graph_accelerometer, graph_extruder, graph_motion, graph_shaper, graph_temp_sensor, whconsole Correzione di diversi bug e pulizia del codice. Klipper 0.9.1 \u00b6 Disponibile su 20201028. Versione contenente solo correzioni di bug. Klipper 0.8.0 \u00b6 Disponibile su 20191021. Modifiche principali in questa versione: Nuovo supporto per il modello dei comandi G-Code. Il G-Code nel file di configurazione viene ora valutato con il linguaggio dei template Jinja2. Miglioramenti ai driver per stepper Trinamic: Nuovo supporto per i driver TMC2209 e TMC5160. Migliorati i comandi G-Code DUMP_TMC, SET_TMC_CURRENT e INIT_TMC. Supporto migliorato per la gestione di TMC UART con un mux analogico. Supporto migliorato per homing, sonda e livellamento del piatto: Aggiunti nuovi moduli manual_probe, bed_screws, Screws_tilt_adjust, skew_correction, safe_z_home. Sondaggio multi-campione migliorato con logica mediana, media e tentativi. Documentazione migliorata per BL-Touch, calibrazione della sonda, calibrazione endstop, calibrazione delta, homing sensorless e calibrazione della fase finecorsa. Supporto della corsa di riferimento migliorato su un asse Z grande. Molti miglioramenti del microcontrollore Klipper: Klipper portato su: SAM3X8C, SAM4S8C, SAMD51, STM32F042, STM32F4 Nuove implementazioni del driver CDC USB su SAM3X, SAM4, STM32F4. Supporto avanzato per il flashing di Klipper su USB. Supporto SPI software. Filtraggio della temperatura notevolmente migliorato sull'LPC176x. Le impostazioni dei pin di uscita possono essere configurate nel microcontrollore. Nuovo sito web con la documentazione di Klipper: http://klipper3d.org/ Klipper ora ha un logo. Supporto sperimentale alla cinematica polare e \"cable winch\". Il file di configurazione ora pu\u00f2 includere altri file di configurazione. Molti moduli aggiuntivi aggiunti: board_pins, controller_fan, delay_gcode, dotstar, filament_switch_sensor, firmware_retraction, gcode_arcs, gcode_button, heater_generic, manual_stepper, mcp4018, mcp4728, neopixel, pause_resume, respond, temperature_sensor tsl1401cl_filament_width_sensor, tuning_tower Molti comandi aggiuntivi aggiunti: RESTORE_GCODE_STATE, SAVE_GCODE_STATE, SET_GCODE_VARIABLE, SET_HEATER_TEMPERATURE, SET_IDLE_TIMEOUT, SET_TEMPERATURE_FAN_TARGET Correzione di diversi bug e pulizia del codice. Klipper 0.7.0 \u00b6 Disponibile su 20181220. Modifiche principali in questa versione: Klipper ora supporta il livellamento del piatto \"mesh\" Nuovo supporto per la calibrazione delta \"potenziata\" (calibra le dimensioni x/y di stampa su stampanti delta) Supporto per la configurazione a runtime dei driver per motori passo-passo Trinamic (tmc2130, tmc2208, tmc2660) Migliorato il supporto del sensore di temperatura: MAX6675, MAX31855, MAX31856, MAX31865, termistori personalizzati, sensori stile pt100 comuni Diversi nuovi moduli: temperature_fan, sx1509, force_move, mcp4451, z_tilt, quad_gantry_level, endstop_phase, bltouch Aggiunti diversi nuovi comandi: SAVE_CONFIG, SET_PRESSURE_ADVANCE, SET_GCODE_OFFSET, SET_VELOCITY_LIMIT, STEPPER_BUZZ, TURN_OFF_HEATERS, M204, macro g-code personalizzate Supporto display LCD esteso: Supporto per i menu a runtime Nuove icone di visualizzazione Supporto per i display \"uc1701\" e \"ssd1306\" Supporto per microcontrollore aggiuntivo: Klipper portato su: LPC176x (Smoothieboards), SAM4E8E (Duet2), SAMD21 (Arduino Zero), STM32F103 (dispositivi \"blue pill\"), atmega32u4 Nuovo driver USB CDC generico implementato su AVR, LPC176x, SAMD21 e STM32F103 Miglioramenti delle prestazioni sui processori ARM Il codice della cinematica \u00e8 stato riscritto per utilizzare un \"risolutore iterativo\" Nuovi test case automatici per il software host Klipper Molti nuovi file di configurazione di esempio per le stampanti standard comuni Aggiornamenti della documentazione per bootloader, benchmarking, porting del microcontroller, controlli di configurazione, mappatura dei pin, impostazioni dello slicer, packaging e altro ancora Diverse correzioni di bug e pulizia del codice Klipper 0.6.0 \u00b6 Disponibile su 20180331. Modifiche principali in questa versione: Controlli avanzati dei guasti hardware del riscaldatore e del termistore Supporto per sonde Z Supporto iniziale per la calibrazione automatica dei parametri sulle delta (tramite un nuovo comando delta_calibrate) Supporto iniziale per la compensazione dell'inclinazione del piatto (tramite il comando bed_tilt_calibrate) Supporto iniziale per \"homing sicuro\" e di homing overrides Supporto iniziale per la visualizzazione dello stato sui display RepRapDiscount stile 2004 e 12864 Nuovi miglioramenti multi-estrusore: Supporto per riscaldatori condivisi Supporto iniziale per carrelli doppi Supporto per la configurazione di pi\u00f9 stepper per asse (ad es. doppia Z) Supporto per pin di output digitali e pwm personalizzati (con un nuovo comando SET_PIN) Supporto iniziale per una \"sdcard virtuale\" che consente di stampare direttamente da Klipper (aiuta su macchine troppo lente per eseguire bene OctoPrint) Supporto per impostare diverse lunghezze del braccio su ciascuna torre di una delta Supporto per i comandi G-Code M220/M221 (override del fattore di velocit\u00e0/override del fattore di estrusione) Diversi aggiornamenti della documentazione: Molti nuovi file di configurazione di esempio per le stampanti standard comuni Nuovo esempio di configurazione di MCU multipli Nuovo esempio di configurazione del sensore bltouch Nuove FAQ, controllo della configurazione e documenti G-Code Supporto iniziale per test di integrazione continui su tutti i commit di github Diverse correzioni di bug e pulizia del codice Klipper 0.5.0 \u00b6 Disponibile su 20171025. Modifiche principali in questa versione: Supporto per stampanti con pi\u00f9 estrusori. Supporto iniziale per l'esecuzione su Beaglebone PRU. Supporto iniziale per la scheda Replicape. Supporto iniziale per l'esecuzione del codice del microcontrollore in un processo Linux in tempo reale. Supporto per microcontrollori multipli. (Ad esempio, si potrebbe controllare un estrusore con un microcontrollore e il resto della stampante con un altro.) La sincronizzazione dell'orologio del software \u00e8 implementata per coordinare le azioni tra i microcontrollori. Miglioramenti delle prestazioni stepper (AVR da 20 Mhz fino a 189.000 passi al secondo). Supporto per il controllo dei servocomandi e supporto per la definizione delle ventole di raffreddamento degli ugelli. Diverse correzioni di bug e pulizia del codice Klipper 0.4.0 \u00b6 Disponibile su 20170503. Modifiche principali in questa versione: Installazione migliorata su macchine Raspberry Pi. La maggior parte dell'installazione \u00e8 ora basata su script. Supporto per la cinematica corexy Aggiornamenti della documentazione: nuovo documento Cinematica, nuova guida all'ottimizzazione di Pressure Advance, nuovi file di configurazione di esempio e altro ancora Miglioramenti delle prestazioni dello stepper (AVR da 20 Mhz su 175.000 passi al secondo, Arduino Due oltre 460.000) Supporto per il ripristino automatico del microcontrollore. Supporto per il ripristino tramite l'attivazione dell'alimentazione USB su Raspberry Pi. L'algoritmo di avanzamento della pressione ora funziona con il look-ahead per ridurre le variazioni di pressione in curva. Supporto per limitare la velocit\u00e0 massima di brevi movimenti a zigzag Supporto per sensori AD595 Diverse correzioni di bug e pulizia del codice Klipper 0.3.0 \u00b6 Disponibile su 20161223. Modifiche principali in questa versione: Documentazione migliorata Supporto per robot con cinematica delta Supporto per microcontrollore Arduino Due (ARM cortex-M3) Supporto USB per microcontrollori basati su AVR Supporto per l'algoritmo di \"pressure advance\": riduce la trasudazione durante le stampe. Nuova funzione \"stopper phased based\" - consente una maggiore precisione sull'homing. Supporto per comandi \"extended g-code\" come \"help\", \"restart\" e \"status\". Supporto per ricaricare la configurazione di Klipper e riavviare il software host emettendo un comando di \"restart\" dal terminale. Miglioramenti delle prestazioni stepper (AVR da 20 Mhz fino a 158.000 passi al secondo). Segnalazione errori migliorata. La maggior parte degli errori ora viene mostrata tramite il terminale insieme all'aiuto su come risolverli. Diverse correzioni di bug e pulizia del codice Klipper 0.2.0 \u00b6 Rilascio iniziale di Klipper. Disponibile su 20160525. Le principali funzionalit\u00e0 disponibili nella versione iniziale includono: Supporto di base per stampanti cartesiane (stepper, estrusore, piatto riscaldato, ventola di raffreddamento). Supporto per i comandi g-code comuni. Supporto per interfacciarsi con OctoPrint. Accelerazione e gestione lookahead Supporto per microcontrollori AVR tramite porte seriali standard","title":"Versioni"},{"location":"Releases.html#versioni","text":"Storico delle versioni di Klipper. Vedi installation per informazioni sull'installazione di Klipper.","title":"Versioni"},{"location":"Releases.html#klipper-0110","text":"Disponibile su 20221128. Modifiche principali in questa versione: Ottimizzazione \"passo su entrambi i lati\" del driver del motore passo-passo Trinamic. Supporto per Python3. Il codice host di Klipper verr\u00e0 eseguito con Python2 o Python3. Supporto bus CAN migliorato. Supporto per bus CAN su chip rp2040, stm32g0, stm32h7, same51 e same54. Supporto per la modalit\u00e0 \"Bridge da USB a CAN bus\". Supporto per il bootloader CanBoot. Supporto per accelerometri mpu9250 e mpu6050. Gestione degli errori migliorata per i sensori di temperatura max31856, max31855, max31865 e max6675. Ora \u00e8 possibile configurare i LED per l'aggiornamento durante i comandi G-Code di lunga durata utilizzando il supporto del \"template\" LED. Diversi miglioramenti del microcontrollore. Nuovo supporto per i chip stm32h743, stm32h750, stm32l412, stm32g0b1, same70, same51 e same54. Supporto per letture i2c su atsamd e stm32f0. Supporto hardware pwm su stm32. Invio di eventi basato sul segnale Linux mcu. Nuovo supporto rp2040 per \"make flash\", i2c ed errata USB rp2040-e5. Aggiunti nuovi moduli: angle, dac084S085, exclude_object, led, mpu9250, pca9632, smart_effector, z_thermal_adjust. Aggiunta nuova cinematica deltesiana. Nuovo strumento dump_mcu aggiunto. Correzione di diversi bug e pulizia del codice.","title":"Klipper 0.11.0"},{"location":"Releases.html#klipper-0100","text":"Disponibile su 20210929. Principali modifiche in questa versione: Supporto per \"Homing multi-MCU\". \u00c8 ora possibile collegare un motore passo-passo e il relativo fine corsa a microcontrollori separati. Ci\u00f2 semplifica il cablaggio delle sonde Z sulle \"schede portautensili\". Klipper ora ha un Community Discord Server e un Community Discourse Server . Il sito Web di Klipper ora utilizza l'infrastruttura \"mkdocs\". Esiste anche un progetto Klipper Translations . Supporto automatizzato per il flashing del firmware tramite sdcard su molte schede. Nuovo supporto cinematico per le stampanti \"Hybrid CoreXY\" e \"Hybrid CoreXZ\". Klipper ora usa rotation_distance per configurare le distanze di viaggio del motore passo-passo. Il codice host principale di Klipper ora pu\u00f2 comunicare direttamente con i microcontrollori utilizzando il bus CAN. Nuovo sistema di \"analisi del movimento\". Gli aggiornamenti di movimento interni di Klipper e i risultati dei sensori possono essere tracciati e registrati per l'analisi. I driver per motori passo-passo Trinamic sono ora costantemente monitorati per rilevare eventuali condizioni di errore. Supporto per il microcontrollore rp2040 (schede Raspberry Pi Pico). Il sistema \"make menuconfig\" ora utilizza kconfiglib. Molti moduli aggiuntivi aggiunti: ds18b20, duplicate_pin_override, filament_motion_sensor, palette2, motion_report, pca9533, pulse_counter, save_variables, sdcard_loop, temperature_host, temperature_mcu Correzione di diversi bug e pulizia del codice.","title":"Klipper 0.10.0"},{"location":"Releases.html#klipper-090","text":"Disponibile su 20201020. Modifiche principali in questa versione: Supporto per \"Input Shaping\" - un meccanismo per contrastare la risonanza della stampante. Pu\u00f2 ridurre o eliminare il \"ringing\" nelle stampe. Nuovo sistema \"Smooth Pressure Advance\". Questo implementa \"Pressure Advance\" senza introdurre variazioni di velocit\u00e0 istantanee. Ora \u00e8 anche possibile regolare l'anticipo della pressione utilizzando un metodo \"Tuning Tower\". Nuovo server API \"webhook\". Ci\u00f2 fornisce un'interfaccia JSON programmabile a Klipper. Il display LCD e il menu sono ora configurabili utilizzando la lingua del modello Jinja2. I driver per motori passo-passo TMC2208 possono ora essere utilizzati in modalit\u00e0 \"standalone\" con Klipper. Supporto BL-Touch v3 migliorato. Identificazione USB migliorata. Klipper ora ha il proprio codice di identificazione USB e i microcontrollori possono ora riportare i loro numeri di serie univoci durante l'identificazione USB. Nuovo supporto cinematico per stampanti \"Rotary Delta\" e \"CoreXZ\". Miglioramenti del microcontrollore: supporto per stm32f070, supporto per stm32f207, supporto per pin GPIO su \"Linux MCU\", supporto per \"bootloader HID\" stm32, supporto per bootloader Chitu, supporto per bootloader MKS Robin. Gestione migliorata degli eventi di \"garbage collection\" di Python. Molti moduli aggiuntivi aggiunti: adc_scaled, adxl345, bme280, display_status, extruder_stepper, fan_generic, hall_filament_width_sensor, htu21d, homing_heaters, input_shaper, lm75, print_stats, resonance_tester, shaper_calibrate, query_adc, graph_accelerometer, graph_extruder, graph_motion, graph_shaper, graph_temp_sensor, whconsole Correzione di diversi bug e pulizia del codice.","title":"Klipper 0.9.0"},{"location":"Releases.html#klipper-091","text":"Disponibile su 20201028. Versione contenente solo correzioni di bug.","title":"Klipper 0.9.1"},{"location":"Releases.html#klipper-080","text":"Disponibile su 20191021. Modifiche principali in questa versione: Nuovo supporto per il modello dei comandi G-Code. Il G-Code nel file di configurazione viene ora valutato con il linguaggio dei template Jinja2. Miglioramenti ai driver per stepper Trinamic: Nuovo supporto per i driver TMC2209 e TMC5160. Migliorati i comandi G-Code DUMP_TMC, SET_TMC_CURRENT e INIT_TMC. Supporto migliorato per la gestione di TMC UART con un mux analogico. Supporto migliorato per homing, sonda e livellamento del piatto: Aggiunti nuovi moduli manual_probe, bed_screws, Screws_tilt_adjust, skew_correction, safe_z_home. Sondaggio multi-campione migliorato con logica mediana, media e tentativi. Documentazione migliorata per BL-Touch, calibrazione della sonda, calibrazione endstop, calibrazione delta, homing sensorless e calibrazione della fase finecorsa. Supporto della corsa di riferimento migliorato su un asse Z grande. Molti miglioramenti del microcontrollore Klipper: Klipper portato su: SAM3X8C, SAM4S8C, SAMD51, STM32F042, STM32F4 Nuove implementazioni del driver CDC USB su SAM3X, SAM4, STM32F4. Supporto avanzato per il flashing di Klipper su USB. Supporto SPI software. Filtraggio della temperatura notevolmente migliorato sull'LPC176x. Le impostazioni dei pin di uscita possono essere configurate nel microcontrollore. Nuovo sito web con la documentazione di Klipper: http://klipper3d.org/ Klipper ora ha un logo. Supporto sperimentale alla cinematica polare e \"cable winch\". Il file di configurazione ora pu\u00f2 includere altri file di configurazione. Molti moduli aggiuntivi aggiunti: board_pins, controller_fan, delay_gcode, dotstar, filament_switch_sensor, firmware_retraction, gcode_arcs, gcode_button, heater_generic, manual_stepper, mcp4018, mcp4728, neopixel, pause_resume, respond, temperature_sensor tsl1401cl_filament_width_sensor, tuning_tower Molti comandi aggiuntivi aggiunti: RESTORE_GCODE_STATE, SAVE_GCODE_STATE, SET_GCODE_VARIABLE, SET_HEATER_TEMPERATURE, SET_IDLE_TIMEOUT, SET_TEMPERATURE_FAN_TARGET Correzione di diversi bug e pulizia del codice.","title":"Klipper 0.8.0"},{"location":"Releases.html#klipper-070","text":"Disponibile su 20181220. Modifiche principali in questa versione: Klipper ora supporta il livellamento del piatto \"mesh\" Nuovo supporto per la calibrazione delta \"potenziata\" (calibra le dimensioni x/y di stampa su stampanti delta) Supporto per la configurazione a runtime dei driver per motori passo-passo Trinamic (tmc2130, tmc2208, tmc2660) Migliorato il supporto del sensore di temperatura: MAX6675, MAX31855, MAX31856, MAX31865, termistori personalizzati, sensori stile pt100 comuni Diversi nuovi moduli: temperature_fan, sx1509, force_move, mcp4451, z_tilt, quad_gantry_level, endstop_phase, bltouch Aggiunti diversi nuovi comandi: SAVE_CONFIG, SET_PRESSURE_ADVANCE, SET_GCODE_OFFSET, SET_VELOCITY_LIMIT, STEPPER_BUZZ, TURN_OFF_HEATERS, M204, macro g-code personalizzate Supporto display LCD esteso: Supporto per i menu a runtime Nuove icone di visualizzazione Supporto per i display \"uc1701\" e \"ssd1306\" Supporto per microcontrollore aggiuntivo: Klipper portato su: LPC176x (Smoothieboards), SAM4E8E (Duet2), SAMD21 (Arduino Zero), STM32F103 (dispositivi \"blue pill\"), atmega32u4 Nuovo driver USB CDC generico implementato su AVR, LPC176x, SAMD21 e STM32F103 Miglioramenti delle prestazioni sui processori ARM Il codice della cinematica \u00e8 stato riscritto per utilizzare un \"risolutore iterativo\" Nuovi test case automatici per il software host Klipper Molti nuovi file di configurazione di esempio per le stampanti standard comuni Aggiornamenti della documentazione per bootloader, benchmarking, porting del microcontroller, controlli di configurazione, mappatura dei pin, impostazioni dello slicer, packaging e altro ancora Diverse correzioni di bug e pulizia del codice","title":"Klipper 0.7.0"},{"location":"Releases.html#klipper-060","text":"Disponibile su 20180331. Modifiche principali in questa versione: Controlli avanzati dei guasti hardware del riscaldatore e del termistore Supporto per sonde Z Supporto iniziale per la calibrazione automatica dei parametri sulle delta (tramite un nuovo comando delta_calibrate) Supporto iniziale per la compensazione dell'inclinazione del piatto (tramite il comando bed_tilt_calibrate) Supporto iniziale per \"homing sicuro\" e di homing overrides Supporto iniziale per la visualizzazione dello stato sui display RepRapDiscount stile 2004 e 12864 Nuovi miglioramenti multi-estrusore: Supporto per riscaldatori condivisi Supporto iniziale per carrelli doppi Supporto per la configurazione di pi\u00f9 stepper per asse (ad es. doppia Z) Supporto per pin di output digitali e pwm personalizzati (con un nuovo comando SET_PIN) Supporto iniziale per una \"sdcard virtuale\" che consente di stampare direttamente da Klipper (aiuta su macchine troppo lente per eseguire bene OctoPrint) Supporto per impostare diverse lunghezze del braccio su ciascuna torre di una delta Supporto per i comandi G-Code M220/M221 (override del fattore di velocit\u00e0/override del fattore di estrusione) Diversi aggiornamenti della documentazione: Molti nuovi file di configurazione di esempio per le stampanti standard comuni Nuovo esempio di configurazione di MCU multipli Nuovo esempio di configurazione del sensore bltouch Nuove FAQ, controllo della configurazione e documenti G-Code Supporto iniziale per test di integrazione continui su tutti i commit di github Diverse correzioni di bug e pulizia del codice","title":"Klipper 0.6.0"},{"location":"Releases.html#klipper-050","text":"Disponibile su 20171025. Modifiche principali in questa versione: Supporto per stampanti con pi\u00f9 estrusori. Supporto iniziale per l'esecuzione su Beaglebone PRU. Supporto iniziale per la scheda Replicape. Supporto iniziale per l'esecuzione del codice del microcontrollore in un processo Linux in tempo reale. Supporto per microcontrollori multipli. (Ad esempio, si potrebbe controllare un estrusore con un microcontrollore e il resto della stampante con un altro.) La sincronizzazione dell'orologio del software \u00e8 implementata per coordinare le azioni tra i microcontrollori. Miglioramenti delle prestazioni stepper (AVR da 20 Mhz fino a 189.000 passi al secondo). Supporto per il controllo dei servocomandi e supporto per la definizione delle ventole di raffreddamento degli ugelli. Diverse correzioni di bug e pulizia del codice","title":"Klipper 0.5.0"},{"location":"Releases.html#klipper-040","text":"Disponibile su 20170503. Modifiche principali in questa versione: Installazione migliorata su macchine Raspberry Pi. La maggior parte dell'installazione \u00e8 ora basata su script. Supporto per la cinematica corexy Aggiornamenti della documentazione: nuovo documento Cinematica, nuova guida all'ottimizzazione di Pressure Advance, nuovi file di configurazione di esempio e altro ancora Miglioramenti delle prestazioni dello stepper (AVR da 20 Mhz su 175.000 passi al secondo, Arduino Due oltre 460.000) Supporto per il ripristino automatico del microcontrollore. Supporto per il ripristino tramite l'attivazione dell'alimentazione USB su Raspberry Pi. L'algoritmo di avanzamento della pressione ora funziona con il look-ahead per ridurre le variazioni di pressione in curva. Supporto per limitare la velocit\u00e0 massima di brevi movimenti a zigzag Supporto per sensori AD595 Diverse correzioni di bug e pulizia del codice","title":"Klipper 0.4.0"},{"location":"Releases.html#klipper-030","text":"Disponibile su 20161223. Modifiche principali in questa versione: Documentazione migliorata Supporto per robot con cinematica delta Supporto per microcontrollore Arduino Due (ARM cortex-M3) Supporto USB per microcontrollori basati su AVR Supporto per l'algoritmo di \"pressure advance\": riduce la trasudazione durante le stampe. Nuova funzione \"stopper phased based\" - consente una maggiore precisione sull'homing. Supporto per comandi \"extended g-code\" come \"help\", \"restart\" e \"status\". Supporto per ricaricare la configurazione di Klipper e riavviare il software host emettendo un comando di \"restart\" dal terminale. Miglioramenti delle prestazioni stepper (AVR da 20 Mhz fino a 158.000 passi al secondo). Segnalazione errori migliorata. La maggior parte degli errori ora viene mostrata tramite il terminale insieme all'aiuto su come risolverli. Diverse correzioni di bug e pulizia del codice","title":"Klipper 0.3.0"},{"location":"Releases.html#klipper-020","text":"Rilascio iniziale di Klipper. Disponibile su 20160525. Le principali funzionalit\u00e0 disponibili nella versione iniziale includono: Supporto di base per stampanti cartesiane (stepper, estrusore, piatto riscaldato, ventola di raffreddamento). Supporto per i comandi g-code comuni. Supporto per interfacciarsi con OctoPrint. Accelerazione e gestione lookahead Supporto per microcontrollori AVR tramite porte seriali standard","title":"Klipper 0.2.0"},{"location":"Resonance_Compensation.html","text":"Compensazione della risonanza \u00b6 Klipper supporta Input Shaping, una tecnica che pu\u00f2 essere utilizzata per ridurre il ringing (noti anche come echoing, ghosting o increspature) nelle stampe. Il ringing \u00e8 un difetto di stampa della superficie quando, in genere, elementi come i bordi si ripetono su una superficie stampata come un sottile \"eco\": | | | I ringing sono causati da vibrazioni meccaniche nella stampante dovute a rapidi cambiamenti della direzione di stampa. Si noti che il ringing di solito ha origini meccaniche: telaio della stampante non sufficientemente rigido, cinghie non tese o troppo elastiche, problemi di allineamento delle parti meccaniche, massa in movimento pesante, ecc. Questi dovrebbero essere prima controllati e riparati, se possibile. Input shaping \u00e8 una tecnica di controllo ad anello aperto che crea un segnale di comando che annulla le proprie vibrazioni. La modellatura dell'ingresso richiede alcune regolazioni e misurazioni prima di poter essere abilitata. Oltre al ringing, Input Shaping riduce in genere le vibrazioni e le vibrazioni della stampante in generale e pu\u00f2 anche migliorare l'affidabilit\u00e0 della modalit\u00e0 StealthChop dei driver stepper Trinamic. Messa a punto \u00b6 La regolazione di base richiede la misurazione delle frequenze di ringing della stampante stampando un modello di prova. Carica il modello di prova per il ringing, che pu\u00f2 essere trovato in docs/prints/ringing_tower.stl , nello slicer: L'altezza dello strato (layer) consigliata \u00e8 0,2 o 0,25 mm. I livelli di riempimento e superiori possono essere impostati su 0. Usa 1-2 perimetri, o meglio ancora la modalit\u00e0 vaso liscio con base da 1-2 mm. Utilizzare velocit\u00e0 sufficientemente elevate, circa 80-100 mm/sec, per i perimetri esterni . Assicurati che il tempo minimo per lo strato sia al massimo 3 secondi. Assicurati che qualsiasi \"controllo dinamico dell'accelerazione\" sia disabilitato nello slicer. Non girare il modello. Il modello ha segni X e Y sul retro del modello. Nota la posizione insolita dei segni rispetto agli assi della stampante: non \u00e8 un errore. I contrassegni possono essere utilizzati successivamente nel processo di ottimizzazione come riferimento, poich\u00e9 mostrano a quale asse corrispondono le misurazioni. Frequenza di ringing \u00b6 Innanzitutto, misura la frequenza di ringing . Se il parametro square_corner_velocity \u00e8 stato modificato, ripristinalo a 5.0 . Non \u00e8 consigliabile aumentarlo quando si utilizza l'input shaper perch\u00e9 pu\u00f2 causare un maggiore smussamento smoothing delle parti: \u00e8 invece meglio utilizzare un valore di accelerazione pi\u00f9 elevato. Disable the minimum_cruise_ratio feature by issuing the following command: SET_VELOCITY_LIMIT MINIMUM_CRUISE_RATIO=0 Disabilita la Pressure Advance: SET_PRESSURE_ADVANCE ADVANCE=0 Se hai gi\u00e0 aggiunto la sezione [input_shaper] a printer.cfg, esegui il comando SET_INPUT_SHAPER SHAPER_FREQ_X=0 SHAPER_FREQ_Y=0 . Se ricevi l'errore \"Comando sconosciuto- Unknown command\", puoi tranquillamente ignorarlo a questo punto e continuare con le misurazioni. Eseguire il comando: TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 Fondamentalmente, cerchiamo di rendere pi\u00f9 pronunciato il ringing impostando diversi valori elevati per l'accelerazione. Questo comando aumenter\u00e0 l'accelerazione ogni 5 mm a partire da 1500 mm/sec^2: 1500 mm/sec^2, 2000 mm/sec^2, 2500 mm/sec^2 e cos\u00ec via fino a 7000 mm/sec^2 per l'ultima fascia. Stampa il modello di test sliced con i parametri suggeriti. Puoi interrompere la stampa prima se il ringing \u00e8 chiaramente visibile e vedi che l'accelerazione diventa troppo alta per la tua stampante (ad es. la stampante trema troppo o inizia a saltare i passaggi). Utilizzare i segni X e Y sul retro del modello come riferimento. Le misurazioni dal lato con il contrassegno X devono essere utilizzate per la configurazione dell'asse X e il contrassegno Y - per la configurazione dell'asse Y. Misurare la distanza D (in mm) tra pi\u00f9 oscillazioni sulla parte con il segno X, in prossimit\u00e0 delle tacche, preferibilmente saltando la prima o due oscillazioni. Per misurare pi\u00f9 facilmente la distanza tra le oscillazioni, contrassegnare prima le oscillazioni, quindi misurare la distanza tra i segni con un righello o un calibro: | | | Contare a quante oscillazioni N corrisponde la distanza misurata D . Se non sei sicuro di come contare le oscillazioni, fai riferimento all'immagine sopra, che mostra N = 6 oscillazioni. Calcola la frequenza di squillo dell'asse X come V \u00b7 N / D (Hz), dove V \u00e8 la velocit\u00e0 per i perimetri esterni (mm/sec). Per l'esempio sopra, abbiamo contrassegnato 6 oscillazioni e il test \u00e8 stato stampato a una velocit\u00e0 di 100 mm/sec, quindi la frequenza \u00e8 100 * 6 / 12,14 \u2248 49,4 Hz. Esegui (8) - (10) anche per il segno Y. Si noti che il ringing sulla stampa di prova dovrebbe seguire lo schema delle tacche curve, come nell'immagine sopra. In caso contrario, questo difetto non \u00e8 in realt\u00e0 un ringing e ha un'origine diversa: un problema meccanico o dell'estrusore. Dovrebbe essere risolto prima di abilitare e regolare gli shaper di input. Se le misurazioni non sono affidabili perch\u00e9, ad esempio, la distanza tra le oscillazioni non \u00e8 stabile, potrebbe significare che la stampante ha pi\u00f9 frequenze di risonanza sullo stesso asse. Si pu\u00f2 invece provare a seguire il processo di sintonizzazione descritto nella sezione Misurazioni inaffidabili delle frequenze di ringing e ottenere comunque qualcosa dalla tecnica di input shaping . La frequenza dei ringing pu\u00f2 dipendere dalla posizione del modello all'interno della piastra di stampa e dall'altezza Z, soprattutto sulle stampanti delta ; puoi controllare se vedi le differenze di frequenza in diverse posizioni lungo i lati del modello di prova e ad altezze diverse. \u00c8 possibile calcolare le frequenze di squillo medie sugli assi X e Y, se questo \u00e8 il caso. Se la frequenza di ringing misurata \u00e8 molto bassa (inferiore a circa 20-25 Hz), potrebbe essere una buona idea investire nell'irrigidire la stampante o nel diminuire la massa mobile, a seconda di ci\u00f2 che \u00e8 applicabile nel tuo caso, prima di procedere con l'ulteriore input shaping e rimisurare le frequenze in seguito. Per molti modelli di stampanti popolari spesso sono gi\u00e0 disponibili alcune soluzioni. Si noti che le frequenze di ringing possono cambiare se alla stampante vengono apportate modifiche che influiscono sulla massa in movimento o modificano la rigidit\u00e0 del sistema, ad esempio: Alcuni strumenti vengono installati, rimossi o sostituiti sulla testa di stampa che ne modificano la massa, ad es. viene installato un nuovo motore passo-passo (pi\u00f9 pesante o pi\u00f9 leggero) per estrusore diretto o viene installato un nuovo hotend, viene aggiunta una ventola pesante con un condotto, ecc. Le cinghie sono tese. Sono installati alcuni componenti aggiuntivi per aumentare la rigidit\u00e0 del telaio. Un piatto diverso \u00e8 installato su una stampante a piatto mobile o aggiunto un vetro, ecc. Se vengono apportate tali modifiche, \u00e8 una buona idea misurare almeno le frequenze di ringing per vedere se sono cambiate. Configurazione del Input shaper \u00b6 Dopo aver misurato le frequenze di ringing per gli assi X e Y, puoi aggiungere la seguente sezione al tuo printer.cfg : [input_shaper] shaper_freq_x: ... # frequenza per il segno X del modello di prova shaper_freq_y: ... # frequenza per il segno Y del modello di prova Per l'esempio sopra, otteniamo shaper_freq_x/y = 49.4. Scelta del input shaper \u00b6 Klipper supporta diversi input shaper. Si differenziano per la loro sensibilit\u00e0 agli errori che determinano la frequenza di risonanza e quanto smussamento provocano nelle parti stampate. Inoltre, alcuni degli shaper come 2HUMP_EI e 3HUMP_EI di solito non dovrebbero essere usati con shaper_freq = frequenza di risonanza: sono configurati in base a diverse considerazioni per ridurre diverse risonanze contemporaneamente. Per la maggior parte delle stampanti, possono essere consigliati shaper MZV o EI. Questa sezione descrive un processo di test per scegliere tra di loro e capire alcuni altri parametri correlati. Stampare il modello di prova di ringing come segue: Riavviare il firmware: RESTART Prepare for test: SET_VELOCITY_LIMIT MINIMUM_CRUISE_RATIO=0 Disabilita la Pressure Advance: SET_PRESSURE_ADVANCE ADVANCE=0 Eseguire: SET_INPUT_SHAPER SHAPER_TYPE=MZV Eseguire il comando: TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 Stampa il modello di test sliced con i parametri suggeriti. Se a questo punto non si vede alcun ringing, \u00e8 possibile consigliare l'uso dello shaper MZV. Se vedi dei ringing, rimisura le frequenze usando i passaggi (8)-(10) descritti nella sezione Frequenza ringing . Se le frequenze differiscono in modo significativo dai valori ottenuti in precedenza, \u00e8 necessaria una configurazione dello shaper di input pi\u00f9 complessa. Puoi fare riferimento ai dettagli tecnici della sezione Input shapers . In caso contrario, procedere al passaggio successivo. Ora prova l'input shaper EI. Per provarlo, ripeti i passaggi (1)-(6) da sopra, ma eseguendo invece al passaggio 4 il seguente comando : SET_INPUT_SHAPER SHAPER_TYPE=EI . Confronta due stampe con input shaper MZV e EI. Se EI mostra risultati notevolmente migliori rispetto a MZV, utilizzare EI shaper, altrimenti preferire MZV. Si noti che lo shaper EI causer\u00e0 una maggiore levigatura 'smoothing' nelle parti stampate (vedere la sezione successiva per ulteriori dettagli). Aggiungi il parametro shaper_type: mzv (o ei) alla sezione [input_shaper], ad esempio: [input_shaper] shaper_freq_x: ... shaper_freq_y: ... shaper_type: mzv Alcune note sulla scelta dello shaper: Lo shaper EI pu\u00f2 essere pi\u00f9 adatto per le stampanti a piatto mobile (se la frequenza di risonanza e il conseguente livellamento lo consentono): man mano che si deposita pi\u00f9 filamento sul piatto mobile, la massa del piatto aumenta e la frequenza di risonanza diminuisce. Poich\u00e9 lo shaper EI \u00e8 pi\u00f9 robusto alle variazioni della frequenza di risonanza, potrebbe funzionare meglio quando si stampano parti di grandi dimensioni. A causa della natura della cinematica delta, le frequenze di risonanza possono differire molto in diverse parti del volume di costruzione. Pertanto, lo shaper EI pu\u00f2 adattarsi meglio alle stampanti delta piuttosto che a MZV o ZV e dovrebbe essere considerato per l'uso. Se la frequenza di risonanza \u00e8 sufficientemente grande (pi\u00f9 di 50-60 Hz), si pu\u00f2 anche provare a testare lo shaper 2HUMP_EI (eseguendo il test suggerito sopra con SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI ), ma controllare le considerazioni nella sezione sotto prima di abilitarlo. Seleziona max_accel \u00b6 Dovresti avere un test stampato per lo shaper che hai scelto dal passaggio precedente (se non lo fai, stampa il modello di test affettato con i parametri suggeriti con l'anticipo di pressione disabilitato SET_PRESSURE_ADVANCE ADVANCE=0 e con la torre di regolazione abilitata come TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 ). Si noti che ad accelerazioni molto elevate, a seconda della frequenza di risonanza e dell'input shaper scelto (ad es. EI shaper crea pi\u00f9 smussamento di MZV), l'input shaping pu\u00f2 causare un'eccessiva levigatura -smoothing- e arrotondamento delle parti. Quindi, max_accel dovrebbe essere scelto in modo tale da impedirlo. Un altro parametro che pu\u00f2 influire sul livellamento \u00e8 square_corner_velocity , quindi non \u00e8 consigliabile aumentarlo al di sopra del valore predefinito di 5 mm/sec per evitare un aumento del livellamento smooting. Per selezionare un valore max_accel adatto, ispezionare il modello per lo shaper di input scelto. Per prima cosa, prendi nota a quale accelerazione il ringing \u00e8 ancora piccolo - che ti vada bene. Quindi, controlla la levigatura - smoothing. Per aiutare in questo, il modello di prova ha un piccolo spazio nel muro (0,15 mm): All'aumentare dell'accelerazione, aumenta anche la levigatura-smoothing e lo spazio effettivo nella stampa si allarga: In questa immagine, l'accelerazione aumenta da sinistra a destra e il gap inizia a crescere a partire da 3500 mm/sec^2 (quinta banda da sinistra). Quindi il buon valore per max_accel = 3000 (mm/sec^2) in questo caso per evitare l'eccessivo smoothing. Nota l'accelerazione quando lo spazio \u00e8 ancora molto piccolo nella stampa di prova. Se vedi rigonfiamenti, ma nessun vuoto nel muro, anche ad alte accelerazioni, potrebbe essere dovuto all'avanzamento della pressione disabilitato, specialmente sugli estrusori Bowden. In tal caso, potrebbe essere necessario ripetere la stampa con il PA abilitato. Potrebbe anche essere il risultato di un flusso di filamento non calibrato (troppo alto), quindi \u00e8 una buona idea controllare anche quello. Scegli il minimo tra i due valori di accelerazione (da ringing e smoothing) e inseriscilo come max_accel in printer.cfg. Come nota, pu\u00f2 succedere, specialmente a basse frequenze di ringing, che lo shaper EI provochi un'eccessiva attenuazione anche a basse accelerazioni. In questo caso, MZV potrebbe essere una scelta migliore, perch\u00e9 potrebbe consentire valori di accelerazione pi\u00f9 elevati. A frequenze di ringing molto basse (~25 Hz e inferiori) anche lo shaper MZV pu\u00f2 creare un effetto smussato eccessivo. In tal caso, puoi anche provare a ripetere i passaggi nella sezione Scegliere input shaper con shaper ZV, usando invece il comando SET_INPUT_SHAPER SHAPER_TYPE=ZV . Lo shaper ZV dovrebbe mostrare un livellamento ancora inferiore rispetto a MZV, ma \u00e8 pi\u00f9 sensibile agli errori nella misurazione delle frequenze di ringing. Un'altra considerazione \u00e8 che se una frequenza di risonanza \u00e8 troppo bassa (inferiore a 20-25 Hz), potrebbe essere una buona idea aumentare la rigidit\u00e0 della stampante o ridurre la massa in movimento. In caso contrario, l'accelerazione e la velocit\u00e0 di stampa potrebbero essere limitate a causa di un'eccessivo smoothing invece del ringing. Regolazione fine delle frequenze di risonanza \u00b6 Si noti che la precisione delle misurazioni delle frequenze di risonanza utilizzando il modello di test di ringing \u00e8 sufficiente per la maggior parte degli scopi, quindi si sconsiglia un'ulteriore messa a punto. Se vuoi ancora provare a ricontrollare i tuoi risultati (ad esempio se vedi ancora del ringing dopo aver stampato un modello di prova con un input shaper a tua scelta con le stesse frequenze che hai misurato in precedenza), puoi seguire i passaggi in questo sezione. Nota che se vedi ringing a frequenze diverse dopo aver abilitato [input_shaper], questa sezione non ti aiuter\u00e0. Supponendo di aver suddiviso il modello di ringing con i parametri suggeriti, completare i seguenti passaggi per ciascuno degli assi X e Y: Prepare for test: SET_VELOCITY_LIMIT MINIMUM_CRUISE_RATIO=0 Assicurati che Pressure Advance sia disabilitato: SET_PRESSURE_ADVANCE ADVANCE=0 Eseguire: SET_INPUT_SHAPER SHAPER_TYPE=ZV Dal modello di prova di ringing esistente con lo shaper di input scelto, seleziona l'accelerazione che mostra sufficientemente bene il ringing e impostala con: SET_VELOCITY_LIMIT ACCEL=... Calcola i parametri necessari per il comando TUNING_TOWER per ottimizzare il parametro shaper_freq_x come segue: start = shaper_freq_x * 83 / 132 e factor = shaper_freq_x / 66, dove qui shaper_freq_x \u00e8 il valore corrente in printer.cfg . Eseguire il comando: TUNING_TOWER COMMAND=SET_INPUT_SHAPER PARAMETER=SHAPER_FREQ_X START=start FACTOR=factor BAND=5 usando i valori start e factor calcolati al punto (5). Stampa il modello di prova. Reimposta il valore della frequenza originale: SET_INPUT_SHAPER SHAPER_FREQ_X=... . Trova la fascia che mostra meno ringing e conta il suo numero dal basso partendo da 1. Calcola il nuovo valore shaper_freq_x tramite il vecchio shaper_freq_x * (39 + 5 * #band-number) / 66. Ripetere questi passaggi per l'asse Y allo stesso modo, sostituendo i riferimenti all'asse X con l'asse Y (ad es. sostituire shaper_freq_x con shaper_freq_y nelle formule e nel comando TUNING_TOWER ). Ad esempio, supponiamo di aver misurato la frequenza di ringing per uno degli assi pari a 45 Hz. Questo d\u00e0 start = 45 * 83 / 132 = 28,30 e factor = 45 / 66 = 0,6818 valori per il comando TUNING_TOWER . Supponiamo ora che dopo aver stampato il modello di prova, la quarta fascia dal basso dia il minimo squillo. Questo d\u00e0 lo shaper_freq_^ aggiornato al valore pari a 45 * (39 + 5 * 4) / 66 \u2248 40,23. Dopo aver calcolato entrambi i nuovi parametri shaper_freq_x e shaper_freq_y , puoi aggiornare la sezione [input_shaper] in printer.cfg con i nuovi valori shaper_freq_x e shaper_freq_y . Pressure Advance \u00b6 Se si utilizza Pressure Advance, potrebbe essere necessario risintonizzarlo. Seguire le istruzioni per trovare il nuovo valore, se diverso dal precedente. Assicurati di riavviare Klipper prima di regolare Pressure Advance. Misurazioni inaffidabili delle frequenze di ringing \u00b6 Se non \u00e8 possibile misurare le frequenze di ringing, ad es. se la distanza tra le oscillazioni non \u00e8 stabile, potresti comunque essere in grado di sfruttare le tecniche di input shaping, ma i risultati potrebbero non essere buoni come con misurazioni corrette delle frequenze e richieder\u00e0 un po' pi\u00f9 di messa a punto e stampa del test modello. Si noti che un'altra possibilit\u00e0 \u00e8 acquistare e installare un accelerometro e misurare le risonanze con esso (fare riferimento a docs che descrive l'hardware richiesto e il processo di installazione), ma questa opzione richiede un po' di crimpatura e saldatura. Per l'ottimizzazione, aggiungi la sezione [input_shaper] vuota al tuo printer.cfg . Quindi, supponendo di aver fattolo slicing il modello di ringing con i parametri suggeriti, stampare il modello di prova 3 volte come segue. La prima volta, prima della stampa, eseguire RESTART SET_VELOCITY_LIMIT MINIMUM_CRUISE_RATIO=0 SET_PRESSURE_ADVANCE ADVANCE=0 SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=60 SHAPER_FREQ_Y=60 TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 e stampa il modello. Quindi stampare di nuovo il modello, ma prima di eseguire la stampa invece SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=50 SHAPER_FREQ_Y=50 TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 Quindi stampa il modello per la terza volta, ma ora esegui SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=40 SHAPER_FREQ_Y=40 TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 In sostanza, stiamo stampando il modello di prova di ringing con TUNING_TOWER utilizzando lo shaper 2HUMP_EI con shaper_freq = 60 Hz, 50 Hz e 40 Hz. Se nessuno dei modelli mostra miglioramenti nel ringing, allora, sfortunatamente non sembra che le tecniche di modellazione dell'input possano aiutare con il tuo caso. Altrimenti, \u00e8 possibile che tutti i modelli non mostrino ringing, o alcuni mostrino ringing e altri non cos\u00ec tanto. Scegli il modello di test con la frequenza pi\u00f9 alta che mostra comunque buoni miglioramenti nel ringing. Ad esempio, se i modelli a 40 Hz e 50 Hz non mostrano quasi nessuno ringing e il modello a 60 Hz mostra gi\u00e0 un po' pi\u00f9 di ringing, attenersi a 50 Hz. Ora controlla se lo shaper EI sarebbe abbastanza buono nel tuo caso. Scegli la frequenza dello shaper EI in base alla frequenza dello shaper 2HUMP_EI che hai scelto: Per lo shaper 2HUMP_EI 60 Hz, utilizzare lo shaper EI con shaper_freq = 50 Hz. Per lo shaper 2HUMP_EI 50 Hz, utilizzare lo shaper EI con shaper_freq = 40 Hz. Per lo shaper 2HUMP_EI 40 Hz, utilizzare lo shaper EI con shaper_freq = 33 Hz. Ora stampa il modello di prova ancora una volta, eseguendola SET_INPUT_SHAPER SHAPER_TYPE=EI SHAPER_FREQ_X=... SHAPER_FREQ_Y=... TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 fornendo shaper_freq_x=... e shaper_freq_y=... come determinato in precedenza. Se lo shaper EI mostra buoni risultati comparabili con lo shaper 2HUMP_EI, attenersi con lo shaper EI e la frequenza determinata in precedenza, altrimenti utilizzare lo shaper 2HUMP_EI con la frequenza corrispondente. Aggiungi i risultati a printer.cfg come, ad es. [input_shaper] shaper_freq_x: 50 shaper_freq_y: 50 shaper_type: 2hump_ei Continua l'ottimizzazione con la sezione Selecting max_accel . Risoluzione dei problemi e domande frequenti \u00b6 Non riesco a ottenere misurazioni affidabili delle frequenze di risonanza \u00b6 Innanzitutto, assicurati che non ci siano altri problemi con la stampante invece del ringing. Se le misurazioni non sono affidabili perch\u00e9, ad esempio, la distanza tra le oscillazioni non \u00e8 stabile, potrebbe significare che la stampante ha pi\u00f9 frequenze di risonanza sullo stesso asse. Si pu\u00f2 provare a seguire il processo di sintonizzazione descritto nella sezione Misurazioni inaffidabili delle frequenze di ringing e ottenere comunque qualcosa dalla tecnica di modellatura dell'input. Un'altra possibilit\u00e0 \u00e8 installare un accelerometro, misurare le risonanze con esso e regolare automaticamente lo shaper di input utilizzando i risultati di tali misurazioni. Dopo aver abilitato [input_shaper], ottengo parti stampate troppo levigate e i dettagli fini vengono persi \u00b6 Controllare le considerazioni nella sezione Selecting max_accel . Se la frequenza di risonanza \u00e8 bassa, non si dovrebbero impostare max_accel troppo alti o aumentare i parametri square_corner_velocity. Potrebbe anche essere meglio scegliere gli shaper di input MZV o anche ZV su EI (o gli shaper 2HUMP_EI e 3HUMP_EI). Dopo aver stampato correttamente per un po' di tempo senza ringing, sembra tornare \u00b6 \u00c8 possibile che dopo qualche tempo le frequenze di risonanza siano cambiate. Per esempio. forse la tensione delle cinghie \u00e8 cambiata (le cinghie si sono allentate di pi\u00f9), ecc. \u00c8 una buona idea controllare e rimisurare le frequenze di ringing come descritto nella sezione Frequenza di ringing e aggiornare il file di configurazione se necessario . La configurazione a doppio carrello \u00e8 supportata con gli input shaper? \u00b6 Yes. In this case, one should measure the resonances twice for each carriage. For example, if the second (dual) carriage is installed on X axis, it is possible to set different input shapers for X axis for the primary and dual carriages. However, the input shaper for Y axis should be the same for both carriages (as ultimately this axis is driven by one or more stepper motors each commanded to perform exactly the same steps). One possibility to configure the input shaper for such setups is to keep [input_shaper] section empty and additionally define a [delayed_gcode] section in the printer.cfg as follows: [input_shaper] # Intentionally empty [delayed_gcode init_shaper] initial_duration: 0.1 gcode: SET_DUAL_CARRIAGE CARRIAGE=1 SET_INPUT_SHAPER SHAPER_TYPE_X=<dual_carriage_shaper> SHAPER_FREQ_X=<dual_carriage_freq> SHAPER_TYPE_Y=<y_shaper> SHAPER_FREQ_Y=<y_freq> SET_DUAL_CARRIAGE CARRIAGE=0 SET_INPUT_SHAPER SHAPER_TYPE_X=<primary_carriage_shaper> SHAPER_FREQ_X=<primary_carriage_freq> SHAPER_TYPE_Y=<y_shaper> SHAPER_FREQ_Y=<y_freq> Note that SHAPER_TYPE_Y and SHAPER_FREQ_Y should be the same in both commands. It is also possible to put a similar snippet into the start g-code in the slicer, however then the shaper will not be enabled until any print is started. Note that the input shaper only needs to be configured once. Subsequent changes of the carriages or their modes via SET_DUAL_CARRIAGE command will preserve the configured input shaper parameters. L'input_shaper influisce sul tempo di stampa? \u00b6 No, la funzione input_shaper non ha praticamente alcun impatto sui tempi di stampa da sola. Tuttavia, il valore di max_accel lo fa certamente (regolazione di questo parametro descritta in questa sezione ). Dettagli tecnici \u00b6 Input shaper \u00b6 Gli shaper di input utilizzati in Klipper sono piuttosto standard e si pu\u00f2 trovare una panoramica pi\u00f9 approfondita negli articoli che descrivono gli shaper corrispondenti. Questa sezione contiene una breve panoramica di alcuni aspetti tecnici degli input shaper supportati. La tabella seguente mostra alcuni parametri (solitamente approssimativi) di ciascun shaper. Input shaper Shaper duration Riduzione delle vibrazioni 20x (5% di tolleranza alle vibrazioni) Riduzione delle vibrazioni 10 volte (tolleranza alle vibrazioni del 10%) ZV 0.5 / shaper_freq N/A \u00b1 5% shaper_freq MZV 0.75 / shaper_freq \u00b1 4% shaper_freq -10%...+15% shaper_freq ZVD 1 / shaper_freq \u00b1 15% shaper_freq \u00b1 22% shaper_freq EI 1 / shaper_freq \u00b1 20% shaper_freq \u00b1 25% shaper_freq 2HUMP_EI 1.5 / shaper_freq \u00b1 35% shaper_freq \u00b1 40 shaper_freq 3HUMP_EI 2 / shaper_freq -45...+50% shaper_freq -50%...+55% shaper_freq Una nota sulla riduzione delle vibrazioni: i valori nella tabella sopra sono approssimativi. Se il rapporto di smorzamento della stampante \u00e8 noto per ciascun asse, lo shaper pu\u00f2 essere configurato in modo pi\u00f9 preciso e ridurr\u00e0 quindi le risonanze in una gamma di frequenze leggermente pi\u00f9 ampia. Tuttavia, il rapporto di smorzamento \u00e8 solitamente sconosciuto ed \u00e8 difficile da stimare senza un'attrezzatura speciale, quindi Klipper utilizza il valore 0,1 per impostazione predefinita, che \u00e8 un buon valore a tutto tondo. Le gamme di frequenza nella tabella coprono un numero di diversi possibili rapporti di smorzamento attorno a quel valore (da 0,05 a 0,2 circa). Si noti inoltre che EI, 2HUMP_EI e 3HUMP_EI sono sintonizzati per ridurre le vibrazioni al 5%, quindi i valori per la tolleranza alle vibrazioni del 10% sono forniti solo per riferimento. Come utilizzare questa tabella: La durata dello shaper influisce sull0 smoothing delle parti: pi\u00f9 \u00e8 grande, pi\u00f9 le parti sono lisce. Questa dipendenza non \u00e8 lineare, ma pu\u00f2 dare un'idea di quali shaper \"levigano\" di pi\u00f9 per la stessa frequenza. L'ordinamento per smoothing \u00e8 il seguente: ZV < MZV < ZVD \u2248 EI < 2HUMP_EI < 3HUMP_EI. Inoltre, raramente \u00e8 pratico impostare shaper_freq = resonance freq per gli shaper 2HUMP_EI e 3HUMP_EI (dovrebbero essere usati per ridurre le vibrazioni per diverse frequenze). Si pu\u00f2 stimare una gamma di frequenze in cui lo shaper riduce le vibrazioni. Ad esempio, MZV con shaper_freq = 35 Hz riduce le vibrazioni al 5% per le frequenze [33,6, 36,4] Hz. 3HUMP_EI con shaper_freq = 50 Hz riduce le vibrazioni al 5% nell'intervallo [27,5, 75] Hz. Si pu\u00f2 usare questa tabella per verificare quale shaper dovrebbero usare se hanno bisogno di ridurre le vibrazioni a diverse frequenze. Ad esempio, se si hanno risonanze a 35 Hz e 60 Hz sullo stesso asse: a) EI shaper deve avere shaper_freq = 35 / (1 - 0,2) = 43,75 Hz, e ridurr\u00e0 le risonanze fino a 43,75 * (1 + 0,2 ) = 52,5 Hz, quindi non \u00e8 sufficiente; b) 2HUMP_EI shaper deve avere shaper_freq = 35 / (1 - 0,35) = 53,85 Hz e ridurr\u00e0 le vibrazioni fino a 53,85 * (1 + 0,35) = 72,7 Hz - quindi questa \u00e8 una configurazione accettabile. Cerca sempre di usare shaper_freq il pi\u00f9 alto possibile per un dato shaper (magari con un certo margine di sicurezza, quindi in questo esempio shaper_freq \u2248 50-52 Hz funzionerebbe meglio), e prova a usare uno shaper con la minor durata possibile dello shaper. Se \u00e8 necessario ridurre le vibrazioni a diverse frequenze molto diverse (ad esempio, 30 Hz e 100 Hz), \u00e8 possibile che la tabella sopra non fornisca informazioni sufficienti. In questo caso si pu\u00f2 avere pi\u00f9 fortuna con lo script scripts/graph_shaper.py , che \u00e8 pi\u00f9 flessibile.","title":"Compensazione della risonanza"},{"location":"Resonance_Compensation.html#compensazione-della-risonanza","text":"Klipper supporta Input Shaping, una tecnica che pu\u00f2 essere utilizzata per ridurre il ringing (noti anche come echoing, ghosting o increspature) nelle stampe. Il ringing \u00e8 un difetto di stampa della superficie quando, in genere, elementi come i bordi si ripetono su una superficie stampata come un sottile \"eco\": | | | I ringing sono causati da vibrazioni meccaniche nella stampante dovute a rapidi cambiamenti della direzione di stampa. Si noti che il ringing di solito ha origini meccaniche: telaio della stampante non sufficientemente rigido, cinghie non tese o troppo elastiche, problemi di allineamento delle parti meccaniche, massa in movimento pesante, ecc. Questi dovrebbero essere prima controllati e riparati, se possibile. Input shaping \u00e8 una tecnica di controllo ad anello aperto che crea un segnale di comando che annulla le proprie vibrazioni. La modellatura dell'ingresso richiede alcune regolazioni e misurazioni prima di poter essere abilitata. Oltre al ringing, Input Shaping riduce in genere le vibrazioni e le vibrazioni della stampante in generale e pu\u00f2 anche migliorare l'affidabilit\u00e0 della modalit\u00e0 StealthChop dei driver stepper Trinamic.","title":"Compensazione della risonanza"},{"location":"Resonance_Compensation.html#messa-a-punto","text":"La regolazione di base richiede la misurazione delle frequenze di ringing della stampante stampando un modello di prova. Carica il modello di prova per il ringing, che pu\u00f2 essere trovato in docs/prints/ringing_tower.stl , nello slicer: L'altezza dello strato (layer) consigliata \u00e8 0,2 o 0,25 mm. I livelli di riempimento e superiori possono essere impostati su 0. Usa 1-2 perimetri, o meglio ancora la modalit\u00e0 vaso liscio con base da 1-2 mm. Utilizzare velocit\u00e0 sufficientemente elevate, circa 80-100 mm/sec, per i perimetri esterni . Assicurati che il tempo minimo per lo strato sia al massimo 3 secondi. Assicurati che qualsiasi \"controllo dinamico dell'accelerazione\" sia disabilitato nello slicer. Non girare il modello. Il modello ha segni X e Y sul retro del modello. Nota la posizione insolita dei segni rispetto agli assi della stampante: non \u00e8 un errore. I contrassegni possono essere utilizzati successivamente nel processo di ottimizzazione come riferimento, poich\u00e9 mostrano a quale asse corrispondono le misurazioni.","title":"Messa a punto"},{"location":"Resonance_Compensation.html#frequenza-di-ringing","text":"Innanzitutto, misura la frequenza di ringing . Se il parametro square_corner_velocity \u00e8 stato modificato, ripristinalo a 5.0 . Non \u00e8 consigliabile aumentarlo quando si utilizza l'input shaper perch\u00e9 pu\u00f2 causare un maggiore smussamento smoothing delle parti: \u00e8 invece meglio utilizzare un valore di accelerazione pi\u00f9 elevato. Disable the minimum_cruise_ratio feature by issuing the following command: SET_VELOCITY_LIMIT MINIMUM_CRUISE_RATIO=0 Disabilita la Pressure Advance: SET_PRESSURE_ADVANCE ADVANCE=0 Se hai gi\u00e0 aggiunto la sezione [input_shaper] a printer.cfg, esegui il comando SET_INPUT_SHAPER SHAPER_FREQ_X=0 SHAPER_FREQ_Y=0 . Se ricevi l'errore \"Comando sconosciuto- Unknown command\", puoi tranquillamente ignorarlo a questo punto e continuare con le misurazioni. Eseguire il comando: TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 Fondamentalmente, cerchiamo di rendere pi\u00f9 pronunciato il ringing impostando diversi valori elevati per l'accelerazione. Questo comando aumenter\u00e0 l'accelerazione ogni 5 mm a partire da 1500 mm/sec^2: 1500 mm/sec^2, 2000 mm/sec^2, 2500 mm/sec^2 e cos\u00ec via fino a 7000 mm/sec^2 per l'ultima fascia. Stampa il modello di test sliced con i parametri suggeriti. Puoi interrompere la stampa prima se il ringing \u00e8 chiaramente visibile e vedi che l'accelerazione diventa troppo alta per la tua stampante (ad es. la stampante trema troppo o inizia a saltare i passaggi). Utilizzare i segni X e Y sul retro del modello come riferimento. Le misurazioni dal lato con il contrassegno X devono essere utilizzate per la configurazione dell'asse X e il contrassegno Y - per la configurazione dell'asse Y. Misurare la distanza D (in mm) tra pi\u00f9 oscillazioni sulla parte con il segno X, in prossimit\u00e0 delle tacche, preferibilmente saltando la prima o due oscillazioni. Per misurare pi\u00f9 facilmente la distanza tra le oscillazioni, contrassegnare prima le oscillazioni, quindi misurare la distanza tra i segni con un righello o un calibro: | | | Contare a quante oscillazioni N corrisponde la distanza misurata D . Se non sei sicuro di come contare le oscillazioni, fai riferimento all'immagine sopra, che mostra N = 6 oscillazioni. Calcola la frequenza di squillo dell'asse X come V \u00b7 N / D (Hz), dove V \u00e8 la velocit\u00e0 per i perimetri esterni (mm/sec). Per l'esempio sopra, abbiamo contrassegnato 6 oscillazioni e il test \u00e8 stato stampato a una velocit\u00e0 di 100 mm/sec, quindi la frequenza \u00e8 100 * 6 / 12,14 \u2248 49,4 Hz. Esegui (8) - (10) anche per il segno Y. Si noti che il ringing sulla stampa di prova dovrebbe seguire lo schema delle tacche curve, come nell'immagine sopra. In caso contrario, questo difetto non \u00e8 in realt\u00e0 un ringing e ha un'origine diversa: un problema meccanico o dell'estrusore. Dovrebbe essere risolto prima di abilitare e regolare gli shaper di input. Se le misurazioni non sono affidabili perch\u00e9, ad esempio, la distanza tra le oscillazioni non \u00e8 stabile, potrebbe significare che la stampante ha pi\u00f9 frequenze di risonanza sullo stesso asse. Si pu\u00f2 invece provare a seguire il processo di sintonizzazione descritto nella sezione Misurazioni inaffidabili delle frequenze di ringing e ottenere comunque qualcosa dalla tecnica di input shaping . La frequenza dei ringing pu\u00f2 dipendere dalla posizione del modello all'interno della piastra di stampa e dall'altezza Z, soprattutto sulle stampanti delta ; puoi controllare se vedi le differenze di frequenza in diverse posizioni lungo i lati del modello di prova e ad altezze diverse. \u00c8 possibile calcolare le frequenze di squillo medie sugli assi X e Y, se questo \u00e8 il caso. Se la frequenza di ringing misurata \u00e8 molto bassa (inferiore a circa 20-25 Hz), potrebbe essere una buona idea investire nell'irrigidire la stampante o nel diminuire la massa mobile, a seconda di ci\u00f2 che \u00e8 applicabile nel tuo caso, prima di procedere con l'ulteriore input shaping e rimisurare le frequenze in seguito. Per molti modelli di stampanti popolari spesso sono gi\u00e0 disponibili alcune soluzioni. Si noti che le frequenze di ringing possono cambiare se alla stampante vengono apportate modifiche che influiscono sulla massa in movimento o modificano la rigidit\u00e0 del sistema, ad esempio: Alcuni strumenti vengono installati, rimossi o sostituiti sulla testa di stampa che ne modificano la massa, ad es. viene installato un nuovo motore passo-passo (pi\u00f9 pesante o pi\u00f9 leggero) per estrusore diretto o viene installato un nuovo hotend, viene aggiunta una ventola pesante con un condotto, ecc. Le cinghie sono tese. Sono installati alcuni componenti aggiuntivi per aumentare la rigidit\u00e0 del telaio. Un piatto diverso \u00e8 installato su una stampante a piatto mobile o aggiunto un vetro, ecc. Se vengono apportate tali modifiche, \u00e8 una buona idea misurare almeno le frequenze di ringing per vedere se sono cambiate.","title":"Frequenza di ringing"},{"location":"Resonance_Compensation.html#configurazione-del-input-shaper","text":"Dopo aver misurato le frequenze di ringing per gli assi X e Y, puoi aggiungere la seguente sezione al tuo printer.cfg : [input_shaper] shaper_freq_x: ... # frequenza per il segno X del modello di prova shaper_freq_y: ... # frequenza per il segno Y del modello di prova Per l'esempio sopra, otteniamo shaper_freq_x/y = 49.4.","title":"Configurazione del Input shaper"},{"location":"Resonance_Compensation.html#scelta-del-input-shaper","text":"Klipper supporta diversi input shaper. Si differenziano per la loro sensibilit\u00e0 agli errori che determinano la frequenza di risonanza e quanto smussamento provocano nelle parti stampate. Inoltre, alcuni degli shaper come 2HUMP_EI e 3HUMP_EI di solito non dovrebbero essere usati con shaper_freq = frequenza di risonanza: sono configurati in base a diverse considerazioni per ridurre diverse risonanze contemporaneamente. Per la maggior parte delle stampanti, possono essere consigliati shaper MZV o EI. Questa sezione descrive un processo di test per scegliere tra di loro e capire alcuni altri parametri correlati. Stampare il modello di prova di ringing come segue: Riavviare il firmware: RESTART Prepare for test: SET_VELOCITY_LIMIT MINIMUM_CRUISE_RATIO=0 Disabilita la Pressure Advance: SET_PRESSURE_ADVANCE ADVANCE=0 Eseguire: SET_INPUT_SHAPER SHAPER_TYPE=MZV Eseguire il comando: TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 Stampa il modello di test sliced con i parametri suggeriti. Se a questo punto non si vede alcun ringing, \u00e8 possibile consigliare l'uso dello shaper MZV. Se vedi dei ringing, rimisura le frequenze usando i passaggi (8)-(10) descritti nella sezione Frequenza ringing . Se le frequenze differiscono in modo significativo dai valori ottenuti in precedenza, \u00e8 necessaria una configurazione dello shaper di input pi\u00f9 complessa. Puoi fare riferimento ai dettagli tecnici della sezione Input shapers . In caso contrario, procedere al passaggio successivo. Ora prova l'input shaper EI. Per provarlo, ripeti i passaggi (1)-(6) da sopra, ma eseguendo invece al passaggio 4 il seguente comando : SET_INPUT_SHAPER SHAPER_TYPE=EI . Confronta due stampe con input shaper MZV e EI. Se EI mostra risultati notevolmente migliori rispetto a MZV, utilizzare EI shaper, altrimenti preferire MZV. Si noti che lo shaper EI causer\u00e0 una maggiore levigatura 'smoothing' nelle parti stampate (vedere la sezione successiva per ulteriori dettagli). Aggiungi il parametro shaper_type: mzv (o ei) alla sezione [input_shaper], ad esempio: [input_shaper] shaper_freq_x: ... shaper_freq_y: ... shaper_type: mzv Alcune note sulla scelta dello shaper: Lo shaper EI pu\u00f2 essere pi\u00f9 adatto per le stampanti a piatto mobile (se la frequenza di risonanza e il conseguente livellamento lo consentono): man mano che si deposita pi\u00f9 filamento sul piatto mobile, la massa del piatto aumenta e la frequenza di risonanza diminuisce. Poich\u00e9 lo shaper EI \u00e8 pi\u00f9 robusto alle variazioni della frequenza di risonanza, potrebbe funzionare meglio quando si stampano parti di grandi dimensioni. A causa della natura della cinematica delta, le frequenze di risonanza possono differire molto in diverse parti del volume di costruzione. Pertanto, lo shaper EI pu\u00f2 adattarsi meglio alle stampanti delta piuttosto che a MZV o ZV e dovrebbe essere considerato per l'uso. Se la frequenza di risonanza \u00e8 sufficientemente grande (pi\u00f9 di 50-60 Hz), si pu\u00f2 anche provare a testare lo shaper 2HUMP_EI (eseguendo il test suggerito sopra con SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI ), ma controllare le considerazioni nella sezione sotto prima di abilitarlo.","title":"Scelta del input shaper"},{"location":"Resonance_Compensation.html#seleziona-max_accel","text":"Dovresti avere un test stampato per lo shaper che hai scelto dal passaggio precedente (se non lo fai, stampa il modello di test affettato con i parametri suggeriti con l'anticipo di pressione disabilitato SET_PRESSURE_ADVANCE ADVANCE=0 e con la torre di regolazione abilitata come TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 ). Si noti che ad accelerazioni molto elevate, a seconda della frequenza di risonanza e dell'input shaper scelto (ad es. EI shaper crea pi\u00f9 smussamento di MZV), l'input shaping pu\u00f2 causare un'eccessiva levigatura -smoothing- e arrotondamento delle parti. Quindi, max_accel dovrebbe essere scelto in modo tale da impedirlo. Un altro parametro che pu\u00f2 influire sul livellamento \u00e8 square_corner_velocity , quindi non \u00e8 consigliabile aumentarlo al di sopra del valore predefinito di 5 mm/sec per evitare un aumento del livellamento smooting. Per selezionare un valore max_accel adatto, ispezionare il modello per lo shaper di input scelto. Per prima cosa, prendi nota a quale accelerazione il ringing \u00e8 ancora piccolo - che ti vada bene. Quindi, controlla la levigatura - smoothing. Per aiutare in questo, il modello di prova ha un piccolo spazio nel muro (0,15 mm): All'aumentare dell'accelerazione, aumenta anche la levigatura-smoothing e lo spazio effettivo nella stampa si allarga: In questa immagine, l'accelerazione aumenta da sinistra a destra e il gap inizia a crescere a partire da 3500 mm/sec^2 (quinta banda da sinistra). Quindi il buon valore per max_accel = 3000 (mm/sec^2) in questo caso per evitare l'eccessivo smoothing. Nota l'accelerazione quando lo spazio \u00e8 ancora molto piccolo nella stampa di prova. Se vedi rigonfiamenti, ma nessun vuoto nel muro, anche ad alte accelerazioni, potrebbe essere dovuto all'avanzamento della pressione disabilitato, specialmente sugli estrusori Bowden. In tal caso, potrebbe essere necessario ripetere la stampa con il PA abilitato. Potrebbe anche essere il risultato di un flusso di filamento non calibrato (troppo alto), quindi \u00e8 una buona idea controllare anche quello. Scegli il minimo tra i due valori di accelerazione (da ringing e smoothing) e inseriscilo come max_accel in printer.cfg. Come nota, pu\u00f2 succedere, specialmente a basse frequenze di ringing, che lo shaper EI provochi un'eccessiva attenuazione anche a basse accelerazioni. In questo caso, MZV potrebbe essere una scelta migliore, perch\u00e9 potrebbe consentire valori di accelerazione pi\u00f9 elevati. A frequenze di ringing molto basse (~25 Hz e inferiori) anche lo shaper MZV pu\u00f2 creare un effetto smussato eccessivo. In tal caso, puoi anche provare a ripetere i passaggi nella sezione Scegliere input shaper con shaper ZV, usando invece il comando SET_INPUT_SHAPER SHAPER_TYPE=ZV . Lo shaper ZV dovrebbe mostrare un livellamento ancora inferiore rispetto a MZV, ma \u00e8 pi\u00f9 sensibile agli errori nella misurazione delle frequenze di ringing. Un'altra considerazione \u00e8 che se una frequenza di risonanza \u00e8 troppo bassa (inferiore a 20-25 Hz), potrebbe essere una buona idea aumentare la rigidit\u00e0 della stampante o ridurre la massa in movimento. In caso contrario, l'accelerazione e la velocit\u00e0 di stampa potrebbero essere limitate a causa di un'eccessivo smoothing invece del ringing.","title":"Seleziona max_accel"},{"location":"Resonance_Compensation.html#regolazione-fine-delle-frequenze-di-risonanza","text":"Si noti che la precisione delle misurazioni delle frequenze di risonanza utilizzando il modello di test di ringing \u00e8 sufficiente per la maggior parte degli scopi, quindi si sconsiglia un'ulteriore messa a punto. Se vuoi ancora provare a ricontrollare i tuoi risultati (ad esempio se vedi ancora del ringing dopo aver stampato un modello di prova con un input shaper a tua scelta con le stesse frequenze che hai misurato in precedenza), puoi seguire i passaggi in questo sezione. Nota che se vedi ringing a frequenze diverse dopo aver abilitato [input_shaper], questa sezione non ti aiuter\u00e0. Supponendo di aver suddiviso il modello di ringing con i parametri suggeriti, completare i seguenti passaggi per ciascuno degli assi X e Y: Prepare for test: SET_VELOCITY_LIMIT MINIMUM_CRUISE_RATIO=0 Assicurati che Pressure Advance sia disabilitato: SET_PRESSURE_ADVANCE ADVANCE=0 Eseguire: SET_INPUT_SHAPER SHAPER_TYPE=ZV Dal modello di prova di ringing esistente con lo shaper di input scelto, seleziona l'accelerazione che mostra sufficientemente bene il ringing e impostala con: SET_VELOCITY_LIMIT ACCEL=... Calcola i parametri necessari per il comando TUNING_TOWER per ottimizzare il parametro shaper_freq_x come segue: start = shaper_freq_x * 83 / 132 e factor = shaper_freq_x / 66, dove qui shaper_freq_x \u00e8 il valore corrente in printer.cfg . Eseguire il comando: TUNING_TOWER COMMAND=SET_INPUT_SHAPER PARAMETER=SHAPER_FREQ_X START=start FACTOR=factor BAND=5 usando i valori start e factor calcolati al punto (5). Stampa il modello di prova. Reimposta il valore della frequenza originale: SET_INPUT_SHAPER SHAPER_FREQ_X=... . Trova la fascia che mostra meno ringing e conta il suo numero dal basso partendo da 1. Calcola il nuovo valore shaper_freq_x tramite il vecchio shaper_freq_x * (39 + 5 * #band-number) / 66. Ripetere questi passaggi per l'asse Y allo stesso modo, sostituendo i riferimenti all'asse X con l'asse Y (ad es. sostituire shaper_freq_x con shaper_freq_y nelle formule e nel comando TUNING_TOWER ). Ad esempio, supponiamo di aver misurato la frequenza di ringing per uno degli assi pari a 45 Hz. Questo d\u00e0 start = 45 * 83 / 132 = 28,30 e factor = 45 / 66 = 0,6818 valori per il comando TUNING_TOWER . Supponiamo ora che dopo aver stampato il modello di prova, la quarta fascia dal basso dia il minimo squillo. Questo d\u00e0 lo shaper_freq_^ aggiornato al valore pari a 45 * (39 + 5 * 4) / 66 \u2248 40,23. Dopo aver calcolato entrambi i nuovi parametri shaper_freq_x e shaper_freq_y , puoi aggiornare la sezione [input_shaper] in printer.cfg con i nuovi valori shaper_freq_x e shaper_freq_y .","title":"Regolazione fine delle frequenze di risonanza"},{"location":"Resonance_Compensation.html#pressure-advance","text":"Se si utilizza Pressure Advance, potrebbe essere necessario risintonizzarlo. Seguire le istruzioni per trovare il nuovo valore, se diverso dal precedente. Assicurati di riavviare Klipper prima di regolare Pressure Advance.","title":"Pressure Advance"},{"location":"Resonance_Compensation.html#misurazioni-inaffidabili-delle-frequenze-di-ringing","text":"Se non \u00e8 possibile misurare le frequenze di ringing, ad es. se la distanza tra le oscillazioni non \u00e8 stabile, potresti comunque essere in grado di sfruttare le tecniche di input shaping, ma i risultati potrebbero non essere buoni come con misurazioni corrette delle frequenze e richieder\u00e0 un po' pi\u00f9 di messa a punto e stampa del test modello. Si noti che un'altra possibilit\u00e0 \u00e8 acquistare e installare un accelerometro e misurare le risonanze con esso (fare riferimento a docs che descrive l'hardware richiesto e il processo di installazione), ma questa opzione richiede un po' di crimpatura e saldatura. Per l'ottimizzazione, aggiungi la sezione [input_shaper] vuota al tuo printer.cfg . Quindi, supponendo di aver fattolo slicing il modello di ringing con i parametri suggeriti, stampare il modello di prova 3 volte come segue. La prima volta, prima della stampa, eseguire RESTART SET_VELOCITY_LIMIT MINIMUM_CRUISE_RATIO=0 SET_PRESSURE_ADVANCE ADVANCE=0 SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=60 SHAPER_FREQ_Y=60 TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 e stampa il modello. Quindi stampare di nuovo il modello, ma prima di eseguire la stampa invece SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=50 SHAPER_FREQ_Y=50 TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 Quindi stampa il modello per la terza volta, ma ora esegui SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=40 SHAPER_FREQ_Y=40 TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 In sostanza, stiamo stampando il modello di prova di ringing con TUNING_TOWER utilizzando lo shaper 2HUMP_EI con shaper_freq = 60 Hz, 50 Hz e 40 Hz. Se nessuno dei modelli mostra miglioramenti nel ringing, allora, sfortunatamente non sembra che le tecniche di modellazione dell'input possano aiutare con il tuo caso. Altrimenti, \u00e8 possibile che tutti i modelli non mostrino ringing, o alcuni mostrino ringing e altri non cos\u00ec tanto. Scegli il modello di test con la frequenza pi\u00f9 alta che mostra comunque buoni miglioramenti nel ringing. Ad esempio, se i modelli a 40 Hz e 50 Hz non mostrano quasi nessuno ringing e il modello a 60 Hz mostra gi\u00e0 un po' pi\u00f9 di ringing, attenersi a 50 Hz. Ora controlla se lo shaper EI sarebbe abbastanza buono nel tuo caso. Scegli la frequenza dello shaper EI in base alla frequenza dello shaper 2HUMP_EI che hai scelto: Per lo shaper 2HUMP_EI 60 Hz, utilizzare lo shaper EI con shaper_freq = 50 Hz. Per lo shaper 2HUMP_EI 50 Hz, utilizzare lo shaper EI con shaper_freq = 40 Hz. Per lo shaper 2HUMP_EI 40 Hz, utilizzare lo shaper EI con shaper_freq = 33 Hz. Ora stampa il modello di prova ancora una volta, eseguendola SET_INPUT_SHAPER SHAPER_TYPE=EI SHAPER_FREQ_X=... SHAPER_FREQ_Y=... TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 fornendo shaper_freq_x=... e shaper_freq_y=... come determinato in precedenza. Se lo shaper EI mostra buoni risultati comparabili con lo shaper 2HUMP_EI, attenersi con lo shaper EI e la frequenza determinata in precedenza, altrimenti utilizzare lo shaper 2HUMP_EI con la frequenza corrispondente. Aggiungi i risultati a printer.cfg come, ad es. [input_shaper] shaper_freq_x: 50 shaper_freq_y: 50 shaper_type: 2hump_ei Continua l'ottimizzazione con la sezione Selecting max_accel .","title":"Misurazioni inaffidabili delle frequenze di ringing"},{"location":"Resonance_Compensation.html#risoluzione-dei-problemi-e-domande-frequenti","text":"","title":"Risoluzione dei problemi e domande frequenti"},{"location":"Resonance_Compensation.html#non-riesco-a-ottenere-misurazioni-affidabili-delle-frequenze-di-risonanza","text":"Innanzitutto, assicurati che non ci siano altri problemi con la stampante invece del ringing. Se le misurazioni non sono affidabili perch\u00e9, ad esempio, la distanza tra le oscillazioni non \u00e8 stabile, potrebbe significare che la stampante ha pi\u00f9 frequenze di risonanza sullo stesso asse. Si pu\u00f2 provare a seguire il processo di sintonizzazione descritto nella sezione Misurazioni inaffidabili delle frequenze di ringing e ottenere comunque qualcosa dalla tecnica di modellatura dell'input. Un'altra possibilit\u00e0 \u00e8 installare un accelerometro, misurare le risonanze con esso e regolare automaticamente lo shaper di input utilizzando i risultati di tali misurazioni.","title":"Non riesco a ottenere misurazioni affidabili delle frequenze di risonanza"},{"location":"Resonance_Compensation.html#dopo-aver-abilitato-input_shaper-ottengo-parti-stampate-troppo-levigate-e-i-dettagli-fini-vengono-persi","text":"Controllare le considerazioni nella sezione Selecting max_accel . Se la frequenza di risonanza \u00e8 bassa, non si dovrebbero impostare max_accel troppo alti o aumentare i parametri square_corner_velocity. Potrebbe anche essere meglio scegliere gli shaper di input MZV o anche ZV su EI (o gli shaper 2HUMP_EI e 3HUMP_EI).","title":"Dopo aver abilitato [input_shaper], ottengo parti stampate troppo levigate e i dettagli fini vengono persi"},{"location":"Resonance_Compensation.html#dopo-aver-stampato-correttamente-per-un-po-di-tempo-senza-ringing-sembra-tornare","text":"\u00c8 possibile che dopo qualche tempo le frequenze di risonanza siano cambiate. Per esempio. forse la tensione delle cinghie \u00e8 cambiata (le cinghie si sono allentate di pi\u00f9), ecc. \u00c8 una buona idea controllare e rimisurare le frequenze di ringing come descritto nella sezione Frequenza di ringing e aggiornare il file di configurazione se necessario .","title":"Dopo aver stampato correttamente per un po' di tempo senza ringing, sembra tornare"},{"location":"Resonance_Compensation.html#la-configurazione-a-doppio-carrello-e-supportata-con-gli-input-shaper","text":"Yes. In this case, one should measure the resonances twice for each carriage. For example, if the second (dual) carriage is installed on X axis, it is possible to set different input shapers for X axis for the primary and dual carriages. However, the input shaper for Y axis should be the same for both carriages (as ultimately this axis is driven by one or more stepper motors each commanded to perform exactly the same steps). One possibility to configure the input shaper for such setups is to keep [input_shaper] section empty and additionally define a [delayed_gcode] section in the printer.cfg as follows: [input_shaper] # Intentionally empty [delayed_gcode init_shaper] initial_duration: 0.1 gcode: SET_DUAL_CARRIAGE CARRIAGE=1 SET_INPUT_SHAPER SHAPER_TYPE_X=<dual_carriage_shaper> SHAPER_FREQ_X=<dual_carriage_freq> SHAPER_TYPE_Y=<y_shaper> SHAPER_FREQ_Y=<y_freq> SET_DUAL_CARRIAGE CARRIAGE=0 SET_INPUT_SHAPER SHAPER_TYPE_X=<primary_carriage_shaper> SHAPER_FREQ_X=<primary_carriage_freq> SHAPER_TYPE_Y=<y_shaper> SHAPER_FREQ_Y=<y_freq> Note that SHAPER_TYPE_Y and SHAPER_FREQ_Y should be the same in both commands. It is also possible to put a similar snippet into the start g-code in the slicer, however then the shaper will not be enabled until any print is started. Note that the input shaper only needs to be configured once. Subsequent changes of the carriages or their modes via SET_DUAL_CARRIAGE command will preserve the configured input shaper parameters.","title":"La configurazione a doppio carrello \u00e8 supportata con gli input shaper?"},{"location":"Resonance_Compensation.html#linput_shaper-influisce-sul-tempo-di-stampa","text":"No, la funzione input_shaper non ha praticamente alcun impatto sui tempi di stampa da sola. Tuttavia, il valore di max_accel lo fa certamente (regolazione di questo parametro descritta in questa sezione ).","title":"L'input_shaper influisce sul tempo di stampa?"},{"location":"Resonance_Compensation.html#dettagli-tecnici","text":"","title":"Dettagli tecnici"},{"location":"Resonance_Compensation.html#input-shaper","text":"Gli shaper di input utilizzati in Klipper sono piuttosto standard e si pu\u00f2 trovare una panoramica pi\u00f9 approfondita negli articoli che descrivono gli shaper corrispondenti. Questa sezione contiene una breve panoramica di alcuni aspetti tecnici degli input shaper supportati. La tabella seguente mostra alcuni parametri (solitamente approssimativi) di ciascun shaper. Input shaper Shaper duration Riduzione delle vibrazioni 20x (5% di tolleranza alle vibrazioni) Riduzione delle vibrazioni 10 volte (tolleranza alle vibrazioni del 10%) ZV 0.5 / shaper_freq N/A \u00b1 5% shaper_freq MZV 0.75 / shaper_freq \u00b1 4% shaper_freq -10%...+15% shaper_freq ZVD 1 / shaper_freq \u00b1 15% shaper_freq \u00b1 22% shaper_freq EI 1 / shaper_freq \u00b1 20% shaper_freq \u00b1 25% shaper_freq 2HUMP_EI 1.5 / shaper_freq \u00b1 35% shaper_freq \u00b1 40 shaper_freq 3HUMP_EI 2 / shaper_freq -45...+50% shaper_freq -50%...+55% shaper_freq Una nota sulla riduzione delle vibrazioni: i valori nella tabella sopra sono approssimativi. Se il rapporto di smorzamento della stampante \u00e8 noto per ciascun asse, lo shaper pu\u00f2 essere configurato in modo pi\u00f9 preciso e ridurr\u00e0 quindi le risonanze in una gamma di frequenze leggermente pi\u00f9 ampia. Tuttavia, il rapporto di smorzamento \u00e8 solitamente sconosciuto ed \u00e8 difficile da stimare senza un'attrezzatura speciale, quindi Klipper utilizza il valore 0,1 per impostazione predefinita, che \u00e8 un buon valore a tutto tondo. Le gamme di frequenza nella tabella coprono un numero di diversi possibili rapporti di smorzamento attorno a quel valore (da 0,05 a 0,2 circa). Si noti inoltre che EI, 2HUMP_EI e 3HUMP_EI sono sintonizzati per ridurre le vibrazioni al 5%, quindi i valori per la tolleranza alle vibrazioni del 10% sono forniti solo per riferimento. Come utilizzare questa tabella: La durata dello shaper influisce sull0 smoothing delle parti: pi\u00f9 \u00e8 grande, pi\u00f9 le parti sono lisce. Questa dipendenza non \u00e8 lineare, ma pu\u00f2 dare un'idea di quali shaper \"levigano\" di pi\u00f9 per la stessa frequenza. L'ordinamento per smoothing \u00e8 il seguente: ZV < MZV < ZVD \u2248 EI < 2HUMP_EI < 3HUMP_EI. Inoltre, raramente \u00e8 pratico impostare shaper_freq = resonance freq per gli shaper 2HUMP_EI e 3HUMP_EI (dovrebbero essere usati per ridurre le vibrazioni per diverse frequenze). Si pu\u00f2 stimare una gamma di frequenze in cui lo shaper riduce le vibrazioni. Ad esempio, MZV con shaper_freq = 35 Hz riduce le vibrazioni al 5% per le frequenze [33,6, 36,4] Hz. 3HUMP_EI con shaper_freq = 50 Hz riduce le vibrazioni al 5% nell'intervallo [27,5, 75] Hz. Si pu\u00f2 usare questa tabella per verificare quale shaper dovrebbero usare se hanno bisogno di ridurre le vibrazioni a diverse frequenze. Ad esempio, se si hanno risonanze a 35 Hz e 60 Hz sullo stesso asse: a) EI shaper deve avere shaper_freq = 35 / (1 - 0,2) = 43,75 Hz, e ridurr\u00e0 le risonanze fino a 43,75 * (1 + 0,2 ) = 52,5 Hz, quindi non \u00e8 sufficiente; b) 2HUMP_EI shaper deve avere shaper_freq = 35 / (1 - 0,35) = 53,85 Hz e ridurr\u00e0 le vibrazioni fino a 53,85 * (1 + 0,35) = 72,7 Hz - quindi questa \u00e8 una configurazione accettabile. Cerca sempre di usare shaper_freq il pi\u00f9 alto possibile per un dato shaper (magari con un certo margine di sicurezza, quindi in questo esempio shaper_freq \u2248 50-52 Hz funzionerebbe meglio), e prova a usare uno shaper con la minor durata possibile dello shaper. Se \u00e8 necessario ridurre le vibrazioni a diverse frequenze molto diverse (ad esempio, 30 Hz e 100 Hz), \u00e8 possibile che la tabella sopra non fornisca informazioni sufficienti. In questo caso si pu\u00f2 avere pi\u00f9 fortuna con lo script scripts/graph_shaper.py , che \u00e8 pi\u00f9 flessibile.","title":"Input shaper"},{"location":"Rotation_Distance.html","text":"Rotation distance \u00b6 I driver per motori passo-passo su Klipper richiedono un parametro rotation_distance in ciascuna stepper config section . La distanza_rotazione \u00e8 la distanza percorsa dall'asse con un giro completo del motore passo-passo relativo. Questo documento descrive come configurare questo valore. Ottenere rotation_distance da steps_per_mm (o step_distance) \u00b6 I progettisti della tua stampante 3d hanno originariamente calcolato steps_per_mm da una distanza di rotazione. Se conosci i passi_per_mm, \u00e8 possibile utilizzare questa formula generale per ottenere la distanza di rotazione originale: rotation_distance = <passi_completi_per_rotazione> * <micropassi> / <passi_per_mm> Oppure, se hai una configurazione di Klipper precedente e conosci il parametro step_distance puoi usare questa formula: rotation_distance = <passi_completi_per_rotazione> * <micropassi> * <distanza_passo> L'impostazione <full_steps_per_rotation> \u00e8 determinata dal tipo di motore passo-passo. La maggior parte dei motori passo-passo sono \"passi passo a 1,8 gradi\" e quindi hanno 200 passi completi per rotazione (360 diviso 1,8 fa 200). Alcuni motori passo passo sono \"passo passo a 0,9 gradi\" e quindi hanno 400 passi completi per rotazione. Altri motori passo-passo sono rari. In caso di dubbi, non impostare full_steps_per_rotation nel file di configurazione e utilizzare 200 nella formula sopra. L'impostazione <microsteps> \u00e8 determinata dal driver del motore passo-passo. La maggior parte dei driver utilizza 16 micropassi. Se non sei sicuro, imposta microsteps: 16 nella configurazione e usa 16 nella formula sopra. Quasi tutte le stampanti dovrebbero avere un numero intero per rotation_distance sugli assi di tipo X, Y e Z. Se la formula precedente risulta in una distanza_rotazione che \u00e8 entro .01 da un numero intero, arrotonda il valore finale a quel numero_intero. Calibrazione rotation_distance sugli estrusori \u00b6 Su un estrusore, la rotation_distance \u00e8 la distanza percorsa dal filamento per una rotazione completa del motore passo-passo. Il modo migliore per ottenere un valore accurato per questa impostazione \u00e8 utilizzare una procedura di \"misura e ritaglio\". Innanzitutto inizia con un'ipotesi iniziale per la distanza di rotazione. Questo pu\u00f2 essere ottenuto da steps_per_mm o ispezionando l'hardware . Quindi utilizzare la seguente procedura per \"misurare e tagliare\": Assicurati che l'estrusore contenga del filamento, che l'hotend sia riscaldato a una temperatura appropriata e che la stampante sia pronta per l'estrusione. Utilizzare un pennarello per posizionare un segno sul filamento a circa 70 mm dall'ingresso del corpo dell'estrusore. Quindi usa un calibro digitale per misurare la distanza effettiva di quel segno nel modo pi\u00f9 preciso possibile. Nota questo come <initial_mark_distance> . Estrudere 50 mm di filamento con la seguente sequenza di comandi: G91 seguito da G1 E50 F60 . Nota 50 mm come <distanza_estrusione_richiesta> . Attendi che l'estrusore finisca il movimento (ci vorranno circa 50 secondi). \u00c8 importante utilizzare la velocit\u00e0 di estrusione lenta per questo test poich\u00e9 una velocit\u00e0 pi\u00f9 elevata pu\u00f2 causare una pressione elevata nell'estrusore che distorce i risultati. (Non utilizzare il \"pulsante estrudi\" sui front-end grafici per questo test poich\u00e9 si estrudono a una velocit\u00e0 elevata.) Utilizzare un calibro digitale per misurare la nuova distanza tra il corpo dell'estrusore e il segno sul filamento. Annota questa come <subsequent_mark_distance> . Quindi calcola: actual_extrude_distance = <initial_mark_distance> - <subsequent_mark_distance> Calcola rotation_distance come: rotation_distance = <rotation_distance_precedente> * <actual_extrude_distance> / <requested_extrude_distance> Arrotonda la nuova rotation_distance a tre cifre decimali. Se la distanza_di_estrusione effettiva differisce dalla distanza_di_estrusione richiesta di oltre 2 mm circa, \u00e8 una buona idea eseguire i passaggi precedenti una seconda volta. Nota: non utilizzare un metodo di tipo \"misura e ritaglia\" per calibrare gli assi di tipo x, y o z. Il metodo \"misura e taglia\" non \u00e8 sufficientemente accurato per quegli assi e probabilmente porter\u00e0 a una configurazione peggiore. Invece, se necessario, quegli assi possono essere determinati measuring the belts, pulleys, and lead screw hardware . Ottenere la rotation_distance ispezionando l'hardware \u00b6 E' possibile calcolare rotation_distance conoscendo i motori passo-passo e la cinematica della stampante. Questo pu\u00f2 essere utile se i passi_per_mm non sono noti o se si sta progettando una nuova stampante. Assi con trasmissione a cinghia \u00b6 \u00c8 facile calcolare rotation_distance per un asse lineare che utilizza una cinghia e una puleggia. Per prima cosa determinare il tipo di cinghia. La maggior parte delle stampanti utilizza un passo della cinghia di 2 mm (ovvero, ogni dente sulla cinghia \u00e8 a 2 mm di distanza). Quindi contare il numero di denti sulla puleggia del motore passo-passo. La distanza_rotazione viene quindi calcolata come: rotation_distance = <passo_cinghia> * <numero_di_denti_sulla_puleggia> Ad esempio, se una stampante ha una cinghia da 2 mm e utilizza una puleggia con 20 denti, la distanza di rotazione \u00e8 40. Assi con vite di comando \u00b6 \u00c8 facile calcolare la rotation_distance per le comuni viti di trasmissione utilizzando la seguente formula: rotation_distance = <passo_vite> * <numero_di_filetti_separati> Ad esempio, la comune \"madrevite T8\" ha una rotation distance di 8 (ha un passo di 2 mm e ha 4 filetti separati). Le stampanti pi\u00f9 vecchie con \"barre filettate\" hanno un solo \"filo\" sulla vite di comando e quindi la rotation distance \u00e8 il passo della vite. (Il passo della vite \u00e8 la distanza tra ciascuna scanalatura sulla vite.) Quindi, ad esempio, un'asta metrica M6 ha una rotation distance di 1 e un'asta M8 ha una rotation distance di 1,25. Estrusore \u00b6 \u00c8 possibile ottenere una distanza di rotazione iniziale per gli estrusori misurando il diametro del \"bullone dentato\" che spinge il filamento e utilizzando la seguente formula: rotation_distance = <diametro> * 3.14 Se l'estrusore utilizza ingranaggi, sar\u00e0 anche necessario determinare e impostare gear_ratio per l'estrusore. La rotation distance effettiva su un estrusore varier\u00e0 da stampante a stampante, perch\u00e9 la presa del \"bullone dentato\" che impegna il filamento pu\u00f2 variare. Pu\u00f2 anche variare tra le bobine di filamento. Dopo aver ottenuto una rotation distance iniziale, utilizzare la procedura di misurazione e ritaglio per ottenere un'impostazione pi\u00f9 accurata. Usando un gear_ratio \u00b6 L'impostazione di un gear_ratio pu\u00f2 semplificare la configurazione di rotation_distance su stepper a cui \u00e8 collegato un gear box (o simile). La maggior parte degli stepper non ha un gear box - se non sei sicuro, non impostare gear_ratio nella configurazione. Quando gear_ratio \u00e8 impostato, rotation_distance rappresenta la distanza percorsa dall'asse con una rotazione completa dell'ingranaggio finale sulla scatola ingranaggi. Se, ad esempio, si utilizza un riduttore con un rapporto \"5:1\", \u00e8 possibile calcolare la distanza_rotazione con conoscenza dell'hardware e quindi aggiungere gear_ratio: 5:1 alla configurazione. Per gli ingranaggi realizzati con cinghie e pulegge, \u00e8 possibile determinare il gear_ratio contando i denti sulle pulegge. Ad esempio, se uno stepper con una puleggia a 16 denti guida la puleggia successiva con 80 denti, si utilizzer\u00e0 gear_ratio: 80:16 . In effetti, si potrebbe aprire una comune \"scatola del cambio\" pronta all'uso e contare i denti al suo interno per confermare il suo rapporto di trasmissione. Si noti che a volte un gear-box avr\u00e0 un rapporto di trasmissione leggermente diverso da quello in cui \u00e8 pubblicizzato. I comuni ingranaggi del motore dell'estrusore BMG ne sono un esempio: sono pubblicizzati come \"3:1\" ma in realt\u00e0 utilizzano ingranaggi \"50:17\". (L'uso di numeri di denti senza un denominatore comune pu\u00f2 migliorare l'usura complessiva degli ingranaggi poich\u00e9 i denti non sempre ingranano allo stesso modo ad ogni giro.) Il comune \"riduttore epicicloidale 5.18:1\" \u00e8 configurato in modo pi\u00f9 accurato con gear_ratio: 57:11 . Se su un asse vengono utilizzati pi\u00f9 ingranaggi, \u00e8 possibile fornire un elenco separato da virgole nel gear_ratio. Ad esempio, un cambio \"5:1\" che guida una puleggia da 16 a 80 denti potrebbe utilizzare gear_ratio: 5:1, 80:16 . Nella maggior parte dei casi, gear_ratio dovrebbe essere definito con numeri interi poich\u00e9 ingranaggi e pulegge comuni hanno un numero intero di denti su di essi. Tuttavia, nei casi in cui una cinghia aziona una puleggia usando l'attrito invece dei denti, pu\u00f2 avere senso utilizzare un numero in virgola mobile nel rapporto di trasmissione (ad esempio, gear_ratio: 107.237:16 ).","title":"Rotation distance"},{"location":"Rotation_Distance.html#rotation-distance","text":"I driver per motori passo-passo su Klipper richiedono un parametro rotation_distance in ciascuna stepper config section . La distanza_rotazione \u00e8 la distanza percorsa dall'asse con un giro completo del motore passo-passo relativo. Questo documento descrive come configurare questo valore.","title":"Rotation distance"},{"location":"Rotation_Distance.html#ottenere-rotation_distance-da-steps_per_mm-o-step_distance","text":"I progettisti della tua stampante 3d hanno originariamente calcolato steps_per_mm da una distanza di rotazione. Se conosci i passi_per_mm, \u00e8 possibile utilizzare questa formula generale per ottenere la distanza di rotazione originale: rotation_distance = <passi_completi_per_rotazione> * <micropassi> / <passi_per_mm> Oppure, se hai una configurazione di Klipper precedente e conosci il parametro step_distance puoi usare questa formula: rotation_distance = <passi_completi_per_rotazione> * <micropassi> * <distanza_passo> L'impostazione <full_steps_per_rotation> \u00e8 determinata dal tipo di motore passo-passo. La maggior parte dei motori passo-passo sono \"passi passo a 1,8 gradi\" e quindi hanno 200 passi completi per rotazione (360 diviso 1,8 fa 200). Alcuni motori passo passo sono \"passo passo a 0,9 gradi\" e quindi hanno 400 passi completi per rotazione. Altri motori passo-passo sono rari. In caso di dubbi, non impostare full_steps_per_rotation nel file di configurazione e utilizzare 200 nella formula sopra. L'impostazione <microsteps> \u00e8 determinata dal driver del motore passo-passo. La maggior parte dei driver utilizza 16 micropassi. Se non sei sicuro, imposta microsteps: 16 nella configurazione e usa 16 nella formula sopra. Quasi tutte le stampanti dovrebbero avere un numero intero per rotation_distance sugli assi di tipo X, Y e Z. Se la formula precedente risulta in una distanza_rotazione che \u00e8 entro .01 da un numero intero, arrotonda il valore finale a quel numero_intero.","title":"Ottenere rotation_distance da steps_per_mm (o step_distance)"},{"location":"Rotation_Distance.html#calibrazione-rotation_distance-sugli-estrusori","text":"Su un estrusore, la rotation_distance \u00e8 la distanza percorsa dal filamento per una rotazione completa del motore passo-passo. Il modo migliore per ottenere un valore accurato per questa impostazione \u00e8 utilizzare una procedura di \"misura e ritaglio\". Innanzitutto inizia con un'ipotesi iniziale per la distanza di rotazione. Questo pu\u00f2 essere ottenuto da steps_per_mm o ispezionando l'hardware . Quindi utilizzare la seguente procedura per \"misurare e tagliare\": Assicurati che l'estrusore contenga del filamento, che l'hotend sia riscaldato a una temperatura appropriata e che la stampante sia pronta per l'estrusione. Utilizzare un pennarello per posizionare un segno sul filamento a circa 70 mm dall'ingresso del corpo dell'estrusore. Quindi usa un calibro digitale per misurare la distanza effettiva di quel segno nel modo pi\u00f9 preciso possibile. Nota questo come <initial_mark_distance> . Estrudere 50 mm di filamento con la seguente sequenza di comandi: G91 seguito da G1 E50 F60 . Nota 50 mm come <distanza_estrusione_richiesta> . Attendi che l'estrusore finisca il movimento (ci vorranno circa 50 secondi). \u00c8 importante utilizzare la velocit\u00e0 di estrusione lenta per questo test poich\u00e9 una velocit\u00e0 pi\u00f9 elevata pu\u00f2 causare una pressione elevata nell'estrusore che distorce i risultati. (Non utilizzare il \"pulsante estrudi\" sui front-end grafici per questo test poich\u00e9 si estrudono a una velocit\u00e0 elevata.) Utilizzare un calibro digitale per misurare la nuova distanza tra il corpo dell'estrusore e il segno sul filamento. Annota questa come <subsequent_mark_distance> . Quindi calcola: actual_extrude_distance = <initial_mark_distance> - <subsequent_mark_distance> Calcola rotation_distance come: rotation_distance = <rotation_distance_precedente> * <actual_extrude_distance> / <requested_extrude_distance> Arrotonda la nuova rotation_distance a tre cifre decimali. Se la distanza_di_estrusione effettiva differisce dalla distanza_di_estrusione richiesta di oltre 2 mm circa, \u00e8 una buona idea eseguire i passaggi precedenti una seconda volta. Nota: non utilizzare un metodo di tipo \"misura e ritaglia\" per calibrare gli assi di tipo x, y o z. Il metodo \"misura e taglia\" non \u00e8 sufficientemente accurato per quegli assi e probabilmente porter\u00e0 a una configurazione peggiore. Invece, se necessario, quegli assi possono essere determinati measuring the belts, pulleys, and lead screw hardware .","title":"Calibrazione rotation_distance sugli estrusori"},{"location":"Rotation_Distance.html#ottenere-la-rotation_distance-ispezionando-lhardware","text":"E' possibile calcolare rotation_distance conoscendo i motori passo-passo e la cinematica della stampante. Questo pu\u00f2 essere utile se i passi_per_mm non sono noti o se si sta progettando una nuova stampante.","title":"Ottenere la rotation_distance ispezionando l'hardware"},{"location":"Rotation_Distance.html#assi-con-trasmissione-a-cinghia","text":"\u00c8 facile calcolare rotation_distance per un asse lineare che utilizza una cinghia e una puleggia. Per prima cosa determinare il tipo di cinghia. La maggior parte delle stampanti utilizza un passo della cinghia di 2 mm (ovvero, ogni dente sulla cinghia \u00e8 a 2 mm di distanza). Quindi contare il numero di denti sulla puleggia del motore passo-passo. La distanza_rotazione viene quindi calcolata come: rotation_distance = <passo_cinghia> * <numero_di_denti_sulla_puleggia> Ad esempio, se una stampante ha una cinghia da 2 mm e utilizza una puleggia con 20 denti, la distanza di rotazione \u00e8 40.","title":"Assi con trasmissione a cinghia"},{"location":"Rotation_Distance.html#assi-con-vite-di-comando","text":"\u00c8 facile calcolare la rotation_distance per le comuni viti di trasmissione utilizzando la seguente formula: rotation_distance = <passo_vite> * <numero_di_filetti_separati> Ad esempio, la comune \"madrevite T8\" ha una rotation distance di 8 (ha un passo di 2 mm e ha 4 filetti separati). Le stampanti pi\u00f9 vecchie con \"barre filettate\" hanno un solo \"filo\" sulla vite di comando e quindi la rotation distance \u00e8 il passo della vite. (Il passo della vite \u00e8 la distanza tra ciascuna scanalatura sulla vite.) Quindi, ad esempio, un'asta metrica M6 ha una rotation distance di 1 e un'asta M8 ha una rotation distance di 1,25.","title":"Assi con vite di comando"},{"location":"Rotation_Distance.html#estrusore","text":"\u00c8 possibile ottenere una distanza di rotazione iniziale per gli estrusori misurando il diametro del \"bullone dentato\" che spinge il filamento e utilizzando la seguente formula: rotation_distance = <diametro> * 3.14 Se l'estrusore utilizza ingranaggi, sar\u00e0 anche necessario determinare e impostare gear_ratio per l'estrusore. La rotation distance effettiva su un estrusore varier\u00e0 da stampante a stampante, perch\u00e9 la presa del \"bullone dentato\" che impegna il filamento pu\u00f2 variare. Pu\u00f2 anche variare tra le bobine di filamento. Dopo aver ottenuto una rotation distance iniziale, utilizzare la procedura di misurazione e ritaglio per ottenere un'impostazione pi\u00f9 accurata.","title":"Estrusore"},{"location":"Rotation_Distance.html#usando-un-gear_ratio","text":"L'impostazione di un gear_ratio pu\u00f2 semplificare la configurazione di rotation_distance su stepper a cui \u00e8 collegato un gear box (o simile). La maggior parte degli stepper non ha un gear box - se non sei sicuro, non impostare gear_ratio nella configurazione. Quando gear_ratio \u00e8 impostato, rotation_distance rappresenta la distanza percorsa dall'asse con una rotazione completa dell'ingranaggio finale sulla scatola ingranaggi. Se, ad esempio, si utilizza un riduttore con un rapporto \"5:1\", \u00e8 possibile calcolare la distanza_rotazione con conoscenza dell'hardware e quindi aggiungere gear_ratio: 5:1 alla configurazione. Per gli ingranaggi realizzati con cinghie e pulegge, \u00e8 possibile determinare il gear_ratio contando i denti sulle pulegge. Ad esempio, se uno stepper con una puleggia a 16 denti guida la puleggia successiva con 80 denti, si utilizzer\u00e0 gear_ratio: 80:16 . In effetti, si potrebbe aprire una comune \"scatola del cambio\" pronta all'uso e contare i denti al suo interno per confermare il suo rapporto di trasmissione. Si noti che a volte un gear-box avr\u00e0 un rapporto di trasmissione leggermente diverso da quello in cui \u00e8 pubblicizzato. I comuni ingranaggi del motore dell'estrusore BMG ne sono un esempio: sono pubblicizzati come \"3:1\" ma in realt\u00e0 utilizzano ingranaggi \"50:17\". (L'uso di numeri di denti senza un denominatore comune pu\u00f2 migliorare l'usura complessiva degli ingranaggi poich\u00e9 i denti non sempre ingranano allo stesso modo ad ogni giro.) Il comune \"riduttore epicicloidale 5.18:1\" \u00e8 configurato in modo pi\u00f9 accurato con gear_ratio: 57:11 . Se su un asse vengono utilizzati pi\u00f9 ingranaggi, \u00e8 possibile fornire un elenco separato da virgole nel gear_ratio. Ad esempio, un cambio \"5:1\" che guida una puleggia da 16 a 80 denti potrebbe utilizzare gear_ratio: 5:1, 80:16 . Nella maggior parte dei casi, gear_ratio dovrebbe essere definito con numeri interi poich\u00e9 ingranaggi e pulegge comuni hanno un numero intero di denti su di essi. Tuttavia, nei casi in cui una cinghia aziona una puleggia usando l'attrito invece dei denti, pu\u00f2 avere senso utilizzare un numero in virgola mobile nel rapporto di trasmissione (ad esempio, gear_ratio: 107.237:16 ).","title":"Usando un gear_ratio"},{"location":"SDCard_Updates.html","text":"Aggiornamenti scheda SD \u00b6 Molte delle schede controller oggi popolari vengono fornite con un bootloader in grado di aggiornare il firmware tramite scheda SD. Sebbene ci\u00f2 sia conveniente in molte circostanze, questi bootloader in genere non forniscono altro modo per aggiornare il firmware. Questo pu\u00f2 essere un fastidio se la tua scheda \u00e8 montata in una posizione di difficile accesso o se devi aggiornare spesso il firmware. Dopo che Klipper \u00e8 stato inizialmente flashato su un controller, \u00e8 possibile trasferire il nuovo firmware sulla scheda SD e avviare la procedura di flashing tramite ssh. Procedura di aggiornamento tipica \u00b6 La procedura per aggiornare il firmware dell'MCU utilizzando la scheda SD \u00e8 simile a quella di altri metodi. Invece di usare make flash \u00e8 necessario eseguire uno script di supporto, flash-sdcard.sh . L'aggiornamento di un BigTreeTech SKR 1.3 potrebbe essere simile al seguente: sudo service klipper stop cd ~/klipper git pull make clean make menuconfig make ./scripts/flash-sdcard.sh /dev/ttyACM0 btt-skr-v1.3 sudo service klipper start Spetta all'utente determinare la posizione del dispositivo e il nome della scheda. Se un utente ha bisogno di eseguire il flashing di pi\u00f9 schede, flash-sdcard.sh (o make flash se appropriato) dovrebbe essere eseguito per ciascuna scheda prima di riavviare il servizio Klipper. Le schede supportate possono essere elencate con il seguente comando: ./scripts/flash-sdcard.sh -l Se non vedi la tua scheda elencata, potrebbe essere necessario aggiungere una nuova definizione di scheda come descritto di seguito . Utilizzo avanzato \u00b6 I comandi precedenti presuppongono che l'MCU si connetta alla velocit\u00e0 di trasmissione predefinita di 250000 e che il firmware si trovi in ~/klipper/out/klipper.bin . Lo script flash-sdcard.sh fornisce opzioni per modificare queste impostazioni predefinite. Tutte le opzioni possono essere visualizzate dalla schermata della guida: ./scripts/flash-sdcard.sh -h SD Card upload utility for Klipper usage: flash_sdcard.sh [-h] [-l] [-c] [-b <baud>] [-f <firmware>] <device> <board> positional arguments: <device> device serial port <board> board type optional arguments: -h show this message -l list available boards -c run flash check/verify only (skip upload) -b <baud> serial baud rate (default is 250000) -f <firmware> path to klipper.bin Se la tua scheda \u00e8 stata flashata con un firmware che si connette a un baud rate personalizzato, \u00e8 possibile eseguire l'aggiornamento specificando l'opzione -b : ./scripts/flash-sdcard.sh -b 115200 /dev/ttyAMA0 btt-skr-v1.3 Se desideri eseguire il flashing di una build di Klipper situata in un luogo diverso da quello predefinito, puoi farlo specificando l'opzione -f : ./scripts/flash-sdcard.sh -f ~/downloads/klipper.bin /dev/ttyAMA0 btt-skr-v1.3 Nota che quando si aggiorna un MKS Robin E3 non \u00e8 necessario eseguire manualmente update_mks_robin.py e fornire il binario risultante a flash-sdcard.sh . Questa procedura \u00e8 automatizzata durante il processo di caricamento. L'opzione -c viene utilizzata per eseguire un controllo o un'operazione di sola verifica per testare se la scheda esegue correttamente il firmware specificato. Questa opzione \u00e8 destinata principalmente ai casi in cui \u00e8 necessario un ciclo di alimentazione manuale per completare la procedura di flashing, ad esempio con i bootloader che utilizzano la modalit\u00e0 SDIO anzich\u00e9 SPI per accedere alle proprie schede SD. (Vedi avvertenze di seguito) Ma pu\u00f2 anche essere utilizzato in qualsiasi momento per verificare se il codice visualizzato nella scheda corrisponde alla versione nella cartella build su qualsiasi scheda supportata. Avvertenze \u00b6 Come accennato nell'introduzione, questo metodo funziona solo per l'aggiornamento del firmware. La procedura di flashing iniziale deve essere eseguita manualmente secondo le istruzioni che si applicano alla scheda del controller. Sebbene sia possibile eseguire il flashing di una build che modifica il baud seriale o l'interfaccia di connessione (ad esempio: da USB a UART), la verifica avr\u00e0 sempre esito negativo poich\u00e9 lo script non sar\u00e0 in grado di riconnettersi all'MCU per verificare la versione corrente. Sono supportate solo le schede che utilizzano SPI per la comunicazione con scheda SD. Le schede che utilizzano SDIO, come Flymaker Flyboard e MKS Robin Nano V1/V2, non funzioneranno in modalit\u00e0 SDIO. Tuttavia, di solito \u00e8 possibile eseguire il flashing di tali schede utilizzando invece la modalit\u00e0 Software SPI. Ma se il bootloader della scheda utilizza solo la modalit\u00e0 SDIO per accedere alla scheda SD, sar\u00e0 necessario un ciclo di alimentazione della scheda e della scheda SD in modo che la modalit\u00e0 possa tornare da SPI a SDIO per completare il reflashing. Tali schede dovrebbero essere definite con skip_verify abilitato per saltare il passaggio di verifica immediatamente dopo il flashing. Quindi, dopo il ciclo di spegnimento manuale, \u00e8 possibile eseguire nuovamente lo stesso identico comando ./scripts/flash-sdcard.sh , ma aggiungere l'opzione -c per completare l'operazione di controllo/verifica. Vedere Flashing Boards that use SDIO per esempi. Definizioni della scheda \u00b6 Dovrebbero essere disponibili le schede pi\u00f9 comuni, tuttavia \u00e8 possibile aggiungere una nuova definizione di scheda, se necessario. Le definizioni delle schede si trovano in ~/klipper/scripts/spi_flash/board_defs.py . Le definizioni sono memorizzate nel dizionario, ad esempio: BOARD_DEFS = { 'generic-lpc1768' : { 'mcu' : \"lpc1768\" , 'spi_bus' : \"ssp1\" , \"cs_pin\" : \"P0.6\" }, ...< further definitions > } Possono essere specificati i seguenti campi: mcu : il tipo di Mcu. Questo pu\u00f2 essere recuperato dopo aver configurato la build tramite make menuconfig eseguendo cat .config | grep CONFIG_MCU . Questo campo \u00e8 obbligatorio. spi_bus : il bus SPI collegato alla scheda SD. Questo dovrebbe essere recuperato dallo schema della scheda. Questo campo \u00e8 obbligatorio. cs_pin : il pin di selezione del chip collegato alla scheda SD. Questo dovrebbe essere recuperato dallo schema della scheda. Questo campo \u00e8 obbligatorio. firmware_path : il percorso sulla scheda SD in cui trasferire il firmware. L'impostazione predefinita \u00e8 firmware.bin . current_firmware_path : il percorso sulla scheda SD in cui si trova il file del firmware rinominato dopo un flash riuscito. L'impostazione predefinita \u00e8 'firmware.cur'. skip_verify : Definisce un valore booleano che dice agli script di saltare il passaggio di verifica del firmware durante il processo di flashing. L'impostazione predefinita \u00e8 False . Pu\u00f2 essere impostato su True per le schede che richiedono un ciclo di alimentazione manuale per completare il flashing. Per verificare il firmware in seguito, eseguire nuovamente lo script con l'opzione -c per eseguire lo step di verifica. Vedi le avvertenze con le schede SDIO Se \u00e8 richiesto il software SPI, il campo spi_bus deve essere impostato su swspi e deve essere specificato il seguente campo aggiuntivo: spi_pins : Dovrebbero essere 3 pin separati da virgola che sono collegati alla scheda SD nel formato miso,mosi,sclk`. Dovrebbe essere estremamente raro che sia necessario Software SPI, in genere solo le schede con errori di progettazione o le schede che normalmente supportano solo la modalit\u00e0 SDIO per la loro scheda SD lo richiederanno. La definizione della scheda btt-skr-pro fornisce un esempio della prima, e la definizione della scheda btt-octopus-f446-v1 fornisce un esempio della seconda. Prima di creare una nuova definizione di scheda, \u00e8 necessario verificare se una definizione di scheda esistente soddisfa i criteri necessari per la nuova scheda. Se questo \u00e8 il caso, pu\u00f2 essere specificato un BOARD_ALIAS . Ad esempio, \u00e8 possibile aggiungere il seguente alias per specificare my-new-board come alias per generic-lpc1768 : BOARD_ALIASES = { ...< previous aliases > , 'my-new-board' : BOARD_DEFS [ 'generic-lpc1768' ], } Se hai bisogno di una nuova definizione di scheda e ti senti a disagio con la procedura descritta sopra, ti consigliamo di rivolgerti a Klipper Community Discord . Flashing di schede che utilizzano SDIO \u00b6 Come menzionato nelle avvertenze , le schede il cui bootloader utilizza la modalit\u00e0 SDIO per accedere alla scheda SD richiedono un ciclo di alimentazione della scheda, e in particolare della scheda SD stessa, per passare dalla modalit\u00e0 SPI utilizzata durante la scrittura il file sulla scheda SD di nuovo in modalit\u00e0 SDIO affinch\u00e9 il bootloader lo inserisca nella scheda. Queste definizioni della scheda utilizzeranno il flag skip_verify , che indica allo strumento di flashing di interrompersi dopo aver scritto il firmware sulla scheda SD in modo che la scheda possa essere spenta e riaccesa manualmente e il passaggio di verifica posticipato fino al completamento. Esistono due scenari -- uno con l'host RPi in esecuzione su un alimentatore separato e l'altro quando l'host RPi \u00e8 in esecuzione con lo stesso alimentatore della scheda principale sottoposta a flashing. La differenza \u00e8 se \u00e8 necessario o meno spegnere anche l'RPi e quindi ssh di nuovo dopo che il flashing \u00e8 completo per eseguire il passaggio di verifica, o se la verifica pu\u00f2 essere eseguita immediatamente. Ecco alcuni esempi dei due scenari: Programmazione SDIO con RPi su alimentazione separata \u00b6 Una sessione tipica con l'RPi su un alimentatore separato \u00e8 simile alla seguente. Ovviamente, dovrai utilizzare il percorso del dispositivo e il nome della scheda corretti: sudo service klipper stop cd ~/klipper git pull make clean make menuconfig make ./scripts/flash-sdcard.sh /dev/ttyACM0 btt-octopus-f446-v1 [[[manually power-cycle the printer board here when instructed]]] ./scripts/flash-sdcard.sh -c /dev/ttyACM0 btt-octopus-f446-v1 sudo service klipper start Programmazione SDIO con RPi sullo stesso alimentatore \u00b6 Una sessione tipica con l'RPi sullo stesso alimentatore \u00e8 simile alla seguente. Ovviamente, dovrai utilizzare il percorso del dispositivo e il nome della scheda corretti: sudo service klipper stop cd ~/klipper git pull make clean make menuconfig make ./scripts/flash-sdcard.sh /dev/ttyACM0 btt-octopus-f446-v1 sudo shutdown -h now [[[wait for the RPi to shutdown, then power-cycle and ssh again to the RPi when it restarts]]] sudo service klipper stop cd ~/klipper ./scripts/flash-sdcard.sh -c /dev/ttyACM0 btt-octopus-f446-v1 sudo service klipper start In questo caso, poich\u00e9 \u00e8 in corso il riavvio dell'RPi Host, che riavvier\u00e0 il servizio klipper , \u00e8 necessario arrestare nuovamente klipper prima di eseguire il passaggio di verifica e riavviarlo al termine della verifica. Mappatura pin da SDIO a SPI \u00b6 Se lo schema della tua scheda utilizza SDIO per la sua scheda SD, puoi mappare i pin come descritto nella tabella seguente per determinare i pin SPI del software compatibili da assegnare nel file board_defs.py : Pin della scheda SD Pin della scheda micro SD Nome PIN SDIO Nome Pin SPI 9 1 DATA2 None (PU)* 1 2 CD/DATA3 CS 2 3 CMD MOSI 4 4 +3.3V (VDD) +3.3V (VDD) 5 5 CLK SCLK 3 6 GND (VSS) GND (VSS) 7 7 DATA0 MISO 8 8 DATA1 None (PU)* N/A 9 Card Detect (CD) Card Detect (CD) 6 10 GND GND * None (PU) indica un pin inutilizzato con una resistenza di pull-up","title":"Aggiornamenti scheda SD"},{"location":"SDCard_Updates.html#aggiornamenti-scheda-sd","text":"Molte delle schede controller oggi popolari vengono fornite con un bootloader in grado di aggiornare il firmware tramite scheda SD. Sebbene ci\u00f2 sia conveniente in molte circostanze, questi bootloader in genere non forniscono altro modo per aggiornare il firmware. Questo pu\u00f2 essere un fastidio se la tua scheda \u00e8 montata in una posizione di difficile accesso o se devi aggiornare spesso il firmware. Dopo che Klipper \u00e8 stato inizialmente flashato su un controller, \u00e8 possibile trasferire il nuovo firmware sulla scheda SD e avviare la procedura di flashing tramite ssh.","title":"Aggiornamenti scheda SD"},{"location":"SDCard_Updates.html#procedura-di-aggiornamento-tipica","text":"La procedura per aggiornare il firmware dell'MCU utilizzando la scheda SD \u00e8 simile a quella di altri metodi. Invece di usare make flash \u00e8 necessario eseguire uno script di supporto, flash-sdcard.sh . L'aggiornamento di un BigTreeTech SKR 1.3 potrebbe essere simile al seguente: sudo service klipper stop cd ~/klipper git pull make clean make menuconfig make ./scripts/flash-sdcard.sh /dev/ttyACM0 btt-skr-v1.3 sudo service klipper start Spetta all'utente determinare la posizione del dispositivo e il nome della scheda. Se un utente ha bisogno di eseguire il flashing di pi\u00f9 schede, flash-sdcard.sh (o make flash se appropriato) dovrebbe essere eseguito per ciascuna scheda prima di riavviare il servizio Klipper. Le schede supportate possono essere elencate con il seguente comando: ./scripts/flash-sdcard.sh -l Se non vedi la tua scheda elencata, potrebbe essere necessario aggiungere una nuova definizione di scheda come descritto di seguito .","title":"Procedura di aggiornamento tipica"},{"location":"SDCard_Updates.html#utilizzo-avanzato","text":"I comandi precedenti presuppongono che l'MCU si connetta alla velocit\u00e0 di trasmissione predefinita di 250000 e che il firmware si trovi in ~/klipper/out/klipper.bin . Lo script flash-sdcard.sh fornisce opzioni per modificare queste impostazioni predefinite. Tutte le opzioni possono essere visualizzate dalla schermata della guida: ./scripts/flash-sdcard.sh -h SD Card upload utility for Klipper usage: flash_sdcard.sh [-h] [-l] [-c] [-b <baud>] [-f <firmware>] <device> <board> positional arguments: <device> device serial port <board> board type optional arguments: -h show this message -l list available boards -c run flash check/verify only (skip upload) -b <baud> serial baud rate (default is 250000) -f <firmware> path to klipper.bin Se la tua scheda \u00e8 stata flashata con un firmware che si connette a un baud rate personalizzato, \u00e8 possibile eseguire l'aggiornamento specificando l'opzione -b : ./scripts/flash-sdcard.sh -b 115200 /dev/ttyAMA0 btt-skr-v1.3 Se desideri eseguire il flashing di una build di Klipper situata in un luogo diverso da quello predefinito, puoi farlo specificando l'opzione -f : ./scripts/flash-sdcard.sh -f ~/downloads/klipper.bin /dev/ttyAMA0 btt-skr-v1.3 Nota che quando si aggiorna un MKS Robin E3 non \u00e8 necessario eseguire manualmente update_mks_robin.py e fornire il binario risultante a flash-sdcard.sh . Questa procedura \u00e8 automatizzata durante il processo di caricamento. L'opzione -c viene utilizzata per eseguire un controllo o un'operazione di sola verifica per testare se la scheda esegue correttamente il firmware specificato. Questa opzione \u00e8 destinata principalmente ai casi in cui \u00e8 necessario un ciclo di alimentazione manuale per completare la procedura di flashing, ad esempio con i bootloader che utilizzano la modalit\u00e0 SDIO anzich\u00e9 SPI per accedere alle proprie schede SD. (Vedi avvertenze di seguito) Ma pu\u00f2 anche essere utilizzato in qualsiasi momento per verificare se il codice visualizzato nella scheda corrisponde alla versione nella cartella build su qualsiasi scheda supportata.","title":"Utilizzo avanzato"},{"location":"SDCard_Updates.html#avvertenze","text":"Come accennato nell'introduzione, questo metodo funziona solo per l'aggiornamento del firmware. La procedura di flashing iniziale deve essere eseguita manualmente secondo le istruzioni che si applicano alla scheda del controller. Sebbene sia possibile eseguire il flashing di una build che modifica il baud seriale o l'interfaccia di connessione (ad esempio: da USB a UART), la verifica avr\u00e0 sempre esito negativo poich\u00e9 lo script non sar\u00e0 in grado di riconnettersi all'MCU per verificare la versione corrente. Sono supportate solo le schede che utilizzano SPI per la comunicazione con scheda SD. Le schede che utilizzano SDIO, come Flymaker Flyboard e MKS Robin Nano V1/V2, non funzioneranno in modalit\u00e0 SDIO. Tuttavia, di solito \u00e8 possibile eseguire il flashing di tali schede utilizzando invece la modalit\u00e0 Software SPI. Ma se il bootloader della scheda utilizza solo la modalit\u00e0 SDIO per accedere alla scheda SD, sar\u00e0 necessario un ciclo di alimentazione della scheda e della scheda SD in modo che la modalit\u00e0 possa tornare da SPI a SDIO per completare il reflashing. Tali schede dovrebbero essere definite con skip_verify abilitato per saltare il passaggio di verifica immediatamente dopo il flashing. Quindi, dopo il ciclo di spegnimento manuale, \u00e8 possibile eseguire nuovamente lo stesso identico comando ./scripts/flash-sdcard.sh , ma aggiungere l'opzione -c per completare l'operazione di controllo/verifica. Vedere Flashing Boards that use SDIO per esempi.","title":"Avvertenze"},{"location":"SDCard_Updates.html#definizioni-della-scheda","text":"Dovrebbero essere disponibili le schede pi\u00f9 comuni, tuttavia \u00e8 possibile aggiungere una nuova definizione di scheda, se necessario. Le definizioni delle schede si trovano in ~/klipper/scripts/spi_flash/board_defs.py . Le definizioni sono memorizzate nel dizionario, ad esempio: BOARD_DEFS = { 'generic-lpc1768' : { 'mcu' : \"lpc1768\" , 'spi_bus' : \"ssp1\" , \"cs_pin\" : \"P0.6\" }, ...< further definitions > } Possono essere specificati i seguenti campi: mcu : il tipo di Mcu. Questo pu\u00f2 essere recuperato dopo aver configurato la build tramite make menuconfig eseguendo cat .config | grep CONFIG_MCU . Questo campo \u00e8 obbligatorio. spi_bus : il bus SPI collegato alla scheda SD. Questo dovrebbe essere recuperato dallo schema della scheda. Questo campo \u00e8 obbligatorio. cs_pin : il pin di selezione del chip collegato alla scheda SD. Questo dovrebbe essere recuperato dallo schema della scheda. Questo campo \u00e8 obbligatorio. firmware_path : il percorso sulla scheda SD in cui trasferire il firmware. L'impostazione predefinita \u00e8 firmware.bin . current_firmware_path : il percorso sulla scheda SD in cui si trova il file del firmware rinominato dopo un flash riuscito. L'impostazione predefinita \u00e8 'firmware.cur'. skip_verify : Definisce un valore booleano che dice agli script di saltare il passaggio di verifica del firmware durante il processo di flashing. L'impostazione predefinita \u00e8 False . Pu\u00f2 essere impostato su True per le schede che richiedono un ciclo di alimentazione manuale per completare il flashing. Per verificare il firmware in seguito, eseguire nuovamente lo script con l'opzione -c per eseguire lo step di verifica. Vedi le avvertenze con le schede SDIO Se \u00e8 richiesto il software SPI, il campo spi_bus deve essere impostato su swspi e deve essere specificato il seguente campo aggiuntivo: spi_pins : Dovrebbero essere 3 pin separati da virgola che sono collegati alla scheda SD nel formato miso,mosi,sclk`. Dovrebbe essere estremamente raro che sia necessario Software SPI, in genere solo le schede con errori di progettazione o le schede che normalmente supportano solo la modalit\u00e0 SDIO per la loro scheda SD lo richiederanno. La definizione della scheda btt-skr-pro fornisce un esempio della prima, e la definizione della scheda btt-octopus-f446-v1 fornisce un esempio della seconda. Prima di creare una nuova definizione di scheda, \u00e8 necessario verificare se una definizione di scheda esistente soddisfa i criteri necessari per la nuova scheda. Se questo \u00e8 il caso, pu\u00f2 essere specificato un BOARD_ALIAS . Ad esempio, \u00e8 possibile aggiungere il seguente alias per specificare my-new-board come alias per generic-lpc1768 : BOARD_ALIASES = { ...< previous aliases > , 'my-new-board' : BOARD_DEFS [ 'generic-lpc1768' ], } Se hai bisogno di una nuova definizione di scheda e ti senti a disagio con la procedura descritta sopra, ti consigliamo di rivolgerti a Klipper Community Discord .","title":"Definizioni della scheda"},{"location":"SDCard_Updates.html#flashing-di-schede-che-utilizzano-sdio","text":"Come menzionato nelle avvertenze , le schede il cui bootloader utilizza la modalit\u00e0 SDIO per accedere alla scheda SD richiedono un ciclo di alimentazione della scheda, e in particolare della scheda SD stessa, per passare dalla modalit\u00e0 SPI utilizzata durante la scrittura il file sulla scheda SD di nuovo in modalit\u00e0 SDIO affinch\u00e9 il bootloader lo inserisca nella scheda. Queste definizioni della scheda utilizzeranno il flag skip_verify , che indica allo strumento di flashing di interrompersi dopo aver scritto il firmware sulla scheda SD in modo che la scheda possa essere spenta e riaccesa manualmente e il passaggio di verifica posticipato fino al completamento. Esistono due scenari -- uno con l'host RPi in esecuzione su un alimentatore separato e l'altro quando l'host RPi \u00e8 in esecuzione con lo stesso alimentatore della scheda principale sottoposta a flashing. La differenza \u00e8 se \u00e8 necessario o meno spegnere anche l'RPi e quindi ssh di nuovo dopo che il flashing \u00e8 completo per eseguire il passaggio di verifica, o se la verifica pu\u00f2 essere eseguita immediatamente. Ecco alcuni esempi dei due scenari:","title":"Flashing di schede che utilizzano SDIO"},{"location":"SDCard_Updates.html#programmazione-sdio-con-rpi-su-alimentazione-separata","text":"Una sessione tipica con l'RPi su un alimentatore separato \u00e8 simile alla seguente. Ovviamente, dovrai utilizzare il percorso del dispositivo e il nome della scheda corretti: sudo service klipper stop cd ~/klipper git pull make clean make menuconfig make ./scripts/flash-sdcard.sh /dev/ttyACM0 btt-octopus-f446-v1 [[[manually power-cycle the printer board here when instructed]]] ./scripts/flash-sdcard.sh -c /dev/ttyACM0 btt-octopus-f446-v1 sudo service klipper start","title":"Programmazione SDIO con RPi su alimentazione separata"},{"location":"SDCard_Updates.html#programmazione-sdio-con-rpi-sullo-stesso-alimentatore","text":"Una sessione tipica con l'RPi sullo stesso alimentatore \u00e8 simile alla seguente. Ovviamente, dovrai utilizzare il percorso del dispositivo e il nome della scheda corretti: sudo service klipper stop cd ~/klipper git pull make clean make menuconfig make ./scripts/flash-sdcard.sh /dev/ttyACM0 btt-octopus-f446-v1 sudo shutdown -h now [[[wait for the RPi to shutdown, then power-cycle and ssh again to the RPi when it restarts]]] sudo service klipper stop cd ~/klipper ./scripts/flash-sdcard.sh -c /dev/ttyACM0 btt-octopus-f446-v1 sudo service klipper start In questo caso, poich\u00e9 \u00e8 in corso il riavvio dell'RPi Host, che riavvier\u00e0 il servizio klipper , \u00e8 necessario arrestare nuovamente klipper prima di eseguire il passaggio di verifica e riavviarlo al termine della verifica.","title":"Programmazione SDIO con RPi sullo stesso alimentatore"},{"location":"SDCard_Updates.html#mappatura-pin-da-sdio-a-spi","text":"Se lo schema della tua scheda utilizza SDIO per la sua scheda SD, puoi mappare i pin come descritto nella tabella seguente per determinare i pin SPI del software compatibili da assegnare nel file board_defs.py : Pin della scheda SD Pin della scheda micro SD Nome PIN SDIO Nome Pin SPI 9 1 DATA2 None (PU)* 1 2 CD/DATA3 CS 2 3 CMD MOSI 4 4 +3.3V (VDD) +3.3V (VDD) 5 5 CLK SCLK 3 6 GND (VSS) GND (VSS) 7 7 DATA0 MISO 8 8 DATA1 None (PU)* N/A 9 Card Detect (CD) Card Detect (CD) 6 10 GND GND * None (PU) indica un pin inutilizzato con una resistenza di pull-up","title":"Mappatura pin da SDIO a SPI"},{"location":"Skew_Correction.html","text":"Correzione dell'inclinazione \u00b6 La correzione dell'inclinazione basata su software pu\u00f2 aiutare a risolvere le imprecisioni dimensionali risultanti da un gruppo stampante non perfettamente in squadrato. Si noti che se la stampante \u00e8 notevolmente inclinata, si consiglia vivamente di utilizzare prima mezzi meccanici per ottenere la stampante il pi\u00f9 squadrata possibile prima di applicare la correzione basata sul software. Stampa un oggetto di calibrazione \u00b6 Il primo passaggio per correggere l'inclinazione \u00e8 stampare un calibration object lungo il piano che si desidera correggere. C'\u00e8 anche un calibration object che include tutti i piani in un modello. Vuoi che l'oggetto sia orientato in modo che l'angolo A sia verso l'origine del piano. Assicurarsi che durante questa stampa non venga applicata alcuna correzione dell'inclinazione. Puoi farlo rimuovendo il modulo [skew_correction] da printer.cfg o inserendo un gcode SET_SKEW CLEAR=1 . Prendi le tue misure \u00b6 The [skew_correction] module requires 3 measurements for each plane you want to correct; the length from Corner A to Corner C, the length from Corner B to Corner D, and the length from Corner A to Corner D. When measuring length AD do not include the flats on the corners that some test objects provide. Configura la tua inclinazione \u00b6 Assicurati che la sezione [skew_correction] sia in printer.cfg. Ora puoi usare il gcode SET_SKEW per configurare skew_correcton. Ad esempio, se le lunghezze misurate lungo XY sono le seguenti: Length AC = 140.4 Length BD = 142.8 Length AD = 99.8 SET_SKEW pu\u00f2 essere utilizzato per configurare la correzione dell'inclinazione per il piano XY. SET_SKEW XY=140.4,142.8,99.8 Puoi anche aggiungere misure per XZ e YZ al gcode: SET_SKEW XY=140.4,142.8,99.8 XZ=141.6,141.4,99.8 YZ=142.4,140.5,99.5 Il modulo [skew_correction] supporta anche la gestione del profilo in un modo simile a [bed_mesh] . Dopo aver impostato l'inclinazione usando il gcode SET_SKEW , puoi usare il gcode SKEW_PROFILE per salvarlo: SKEW_PROFILE SAVE=my_skew_profile Dopo questo comando ti verr\u00e0 chiesto di emettere un gcode SAVE_CONFIG per salvare il profilo nella memoria permanente. Se nessun profilo \u00e8 denominato my_skew_profile , verr\u00e0 creato un nuovo profilo. Se il profilo indicato esiste, verr\u00e0 sovrascritto. Una volta che hai un profilo salvato, puoi caricarlo: SKEW_PROFILE LOAD=my_skew_profile \u00c8 anche possibile rimuovere un profilo vecchio o superato: SKEW_PROFILE REMOVE=my_skew_profile Dopo aver rimosso un profilo, ti verr\u00e0 chiesto di emettere un SAVE_CONFIG per far s\u00ec che questa modifica persista. Verifica della tua correzione \u00b6 Dopo aver configurato skew_correction \u00e8 possibile ristampare la parte di calibrazione con la correzione abilitata. Usa il seguente gcode per controllare la tua inclinazione su ciascun piano. I risultati dovrebbero essere inferiori a quelli riportati tramite GET_CURRENT_SKEW . CALC_MEASURED_SKEW AC=<ac_length> BD=<bd_length> AD=<ad_length> Avvertenze \u00b6 A causa della natura della correzione dell'inclinazione, si consiglia di configurare l'inclinazione nel codice g iniziale, dopo l'homing e qualsiasi tipo di movimento che si sposta vicino al bordo dell'area di stampa, come uno spurgo o una pulizia degli ugelli. \u00c8 possibile utilizzare i codici g \"SET_SKEW\" o \"SKEW_PROFILE\" per ottenere ci\u00f2. Si consiglia inoltre di emettere un SET_SKEW CLEAR=1 alla fine del gcode. Tenere presente che \u00e8 possibile che [skew_correction] generi una correzione che sposti la testa oltre i limiti della stampante sugli assi X e/o Y. Si consiglia di disporre le parti lontano dai bordi quando si utilizza [skew_correction] .","title":"Correzione dell'inclinazione"},{"location":"Skew_Correction.html#correzione-dellinclinazione","text":"La correzione dell'inclinazione basata su software pu\u00f2 aiutare a risolvere le imprecisioni dimensionali risultanti da un gruppo stampante non perfettamente in squadrato. Si noti che se la stampante \u00e8 notevolmente inclinata, si consiglia vivamente di utilizzare prima mezzi meccanici per ottenere la stampante il pi\u00f9 squadrata possibile prima di applicare la correzione basata sul software.","title":"Correzione dell'inclinazione"},{"location":"Skew_Correction.html#stampa-un-oggetto-di-calibrazione","text":"Il primo passaggio per correggere l'inclinazione \u00e8 stampare un calibration object lungo il piano che si desidera correggere. C'\u00e8 anche un calibration object che include tutti i piani in un modello. Vuoi che l'oggetto sia orientato in modo che l'angolo A sia verso l'origine del piano. Assicurarsi che durante questa stampa non venga applicata alcuna correzione dell'inclinazione. Puoi farlo rimuovendo il modulo [skew_correction] da printer.cfg o inserendo un gcode SET_SKEW CLEAR=1 .","title":"Stampa un oggetto di calibrazione"},{"location":"Skew_Correction.html#prendi-le-tue-misure","text":"The [skew_correction] module requires 3 measurements for each plane you want to correct; the length from Corner A to Corner C, the length from Corner B to Corner D, and the length from Corner A to Corner D. When measuring length AD do not include the flats on the corners that some test objects provide.","title":"Prendi le tue misure"},{"location":"Skew_Correction.html#configura-la-tua-inclinazione","text":"Assicurati che la sezione [skew_correction] sia in printer.cfg. Ora puoi usare il gcode SET_SKEW per configurare skew_correcton. Ad esempio, se le lunghezze misurate lungo XY sono le seguenti: Length AC = 140.4 Length BD = 142.8 Length AD = 99.8 SET_SKEW pu\u00f2 essere utilizzato per configurare la correzione dell'inclinazione per il piano XY. SET_SKEW XY=140.4,142.8,99.8 Puoi anche aggiungere misure per XZ e YZ al gcode: SET_SKEW XY=140.4,142.8,99.8 XZ=141.6,141.4,99.8 YZ=142.4,140.5,99.5 Il modulo [skew_correction] supporta anche la gestione del profilo in un modo simile a [bed_mesh] . Dopo aver impostato l'inclinazione usando il gcode SET_SKEW , puoi usare il gcode SKEW_PROFILE per salvarlo: SKEW_PROFILE SAVE=my_skew_profile Dopo questo comando ti verr\u00e0 chiesto di emettere un gcode SAVE_CONFIG per salvare il profilo nella memoria permanente. Se nessun profilo \u00e8 denominato my_skew_profile , verr\u00e0 creato un nuovo profilo. Se il profilo indicato esiste, verr\u00e0 sovrascritto. Una volta che hai un profilo salvato, puoi caricarlo: SKEW_PROFILE LOAD=my_skew_profile \u00c8 anche possibile rimuovere un profilo vecchio o superato: SKEW_PROFILE REMOVE=my_skew_profile Dopo aver rimosso un profilo, ti verr\u00e0 chiesto di emettere un SAVE_CONFIG per far s\u00ec che questa modifica persista.","title":"Configura la tua inclinazione"},{"location":"Skew_Correction.html#verifica-della-tua-correzione","text":"Dopo aver configurato skew_correction \u00e8 possibile ristampare la parte di calibrazione con la correzione abilitata. Usa il seguente gcode per controllare la tua inclinazione su ciascun piano. I risultati dovrebbero essere inferiori a quelli riportati tramite GET_CURRENT_SKEW . CALC_MEASURED_SKEW AC=<ac_length> BD=<bd_length> AD=<ad_length>","title":"Verifica della tua correzione"},{"location":"Skew_Correction.html#avvertenze","text":"A causa della natura della correzione dell'inclinazione, si consiglia di configurare l'inclinazione nel codice g iniziale, dopo l'homing e qualsiasi tipo di movimento che si sposta vicino al bordo dell'area di stampa, come uno spurgo o una pulizia degli ugelli. \u00c8 possibile utilizzare i codici g \"SET_SKEW\" o \"SKEW_PROFILE\" per ottenere ci\u00f2. Si consiglia inoltre di emettere un SET_SKEW CLEAR=1 alla fine del gcode. Tenere presente che \u00e8 possibile che [skew_correction] generi una correzione che sposti la testa oltre i limiti della stampante sugli assi X e/o Y. Si consiglia di disporre le parti lontano dai bordi quando si utilizza [skew_correction] .","title":"Avvertenze"},{"location":"Slicers.html","text":"slicer \u00b6 Questo documento fornisce alcuni suggerimenti per configurare un'applicazione \"slicer\" da usare con Klipper. Gli slicer comuni usati con Klipper sono Slic3r, Cura, Simplify3D, ecc. Imposta il Gcode su variante Marlin \u00b6 Molti slicer hanno un'opzione per configurare il \"gusto G-Code\" o G-Code flavor. L'impostazione predefinita \u00e8 spesso \"Marlin\" e funziona bene con Klipper. L'impostazione \"Smoothieware\" funziona bene anche con Klipper. Klipper gcode_macro \u00b6 Gli slicer spesso consentono di configurare le sequenze \"Start G-Code\" e \"End G-Code\". Spesso \u00e8 invece conveniente definire macro personalizzate nel file di configurazione di Klipper, come ad esempio: [gcode_macro START_PRINT] e [gcode_macro END_PRINT] . Quindi puoi semplicemente eseguire START_PRINT e END_PRINT nella configurazione dello slicer. La definizione di queste azioni nella configurazione di Klipper pu\u00f2 rendere pi\u00f9 semplice modificare i passaggi iniziali e finali della stampante poich\u00e9 le modifiche non richiedono il re-slicing. Vedere sample-macros.cfg ad esempio le macro START_PRINT e END_PRINT. Vedere il config reference per i dettagli sulla definizione di una macro gcode. Impostazioni di retrazione di grandi dimensioni potrebbero richiedere la messa a punto di Klipper \u00b6 La velocit\u00e0 massima e l'accelerazione dei movimenti di ritrazione sono controllate in Klipper dalle impostazioni di configurazione max_extrude_only_velocity e max_extrude_only_accel . Queste impostazioni hanno un valore predefinito che dovrebbe funzionare bene su molte stampanti. Tuttavia, se si \u00e8 configurata una grande retrazione nello slicer (ad es. 5 mm o superiore), \u00e8 possibile che limitino la velocit\u00e0 di retrazione desiderata. Se si utilizza una grande retrazione, prendere in considerazione l'ottimizzazione di pressure advance di Klipper. Altrimenti, se si scopre che la testa di stampa sembra \"mettersi in pausa\" durante la retrazione e il priming, allora considerare di definire esplicitamente max_extrude_only_velocity e max_extrude_only_accel nel file di configurazione di Klipper. Non abilitare \"coasting\" -costeggiando- \u00b6 \u00c8 probabile che la funzione \"coasting\" si traduca in stampe di scarsa qualit\u00e0 con Klipper. Prendi in considerazione l'utilizzo di pressure advance di Klipper. In particolare, se lo slicer cambia drasticamente la velocit\u00e0 di estrusione tra i movimenti, Klipper eseguir\u00e0 la decelerazione e l'accelerazione tra i movimenti. \u00c8 probabile che questo renda il blobbing peggiore, non migliore. Al contrario, va bene (e spesso utile) utilizzare l'impostazione ritiro \"retract\" , l'impostazione pulire \"wipe\" e/o l'impostazione pulire alla retrazione \"wipe on retract\". Non utilizzare la \"distanza di riavvio extra\"- \"extra restart distance\"su Simplify3d \u00b6 Questa impostazione pu\u00f2 causare cambiamenti radicali alle velocit\u00e0 di estrusione che possono attivare il controllo della sezione trasversale di estrusione massima di Klipper. Prendi in considerazione l'utilizzo dell' pressure advance di Klipper o della normale impostazione di retrazione Simplify3d. Disabilita \"PreloadVE\" su KISSlicer \u00b6 Se si utilizza il software di slicing KISSlicer, impostare \"PreloadVE\" su zero. Prendi in considerazione l'utilizzo di pressure advance di Klipper. Disattiva le impostazioni di \"pressione dell'estrusore avanzata\"-\"advanced extruder pressure\" \u00b6 Alcune affettatrici pubblicizzano una capacit\u00e0 di \"pressione dell'estrusore avanzata\" - \"advanced extruder pressure\". Si consiglia di mantenere queste opzioni disabilitate quando si utilizza Klipper poich\u00e9 \u00e8 probabile che si traducano in stampe di scarsa qualit\u00e0. Prendi in considerazione l'utilizzo di pressure advance di Klipper. In particolare, queste impostazioni dello slicer possono indicare al firmware di apportare modifiche alla velocit\u00e0 di estrusione nella speranza che il firmware si avvicini a tali richieste e che la stampante ottenga approssimativamente una pressione dell'estrusore desiderabile. Klipper, tuttavia, utilizza calcoli cinematici e tempi precisi. Quando a Klipper viene comandato di apportare modifiche significative alla velocit\u00e0 di estrusione, pianificher\u00e0 le modifiche corrispondenti a velocit\u00e0, accelerazione e movimento dell'estrusore, il che non \u00e8 l'intento dello slicer. Lo slicer pu\u00f2 anche comandare velocit\u00e0 di estrusione eccessive al punto da attivare il controllo della sezione trasversale di estrusione massima di Klipper. Al contrario, va bene (e spesso utile) utilizzare l'impostazione ritiro \"retract\" , l'impostazione pulire \"wipe\" e/o l'impostazione pulire alla retrazione \"wipe on retract\". Macro START_PRINT \u00b6 Quando si utilizza una macro START_PRINT o simile, a volte \u00e8 utile passare i parametri dalle variabili dello slicer alla macro. In Cura, per passare le temperature, verrebbe utilizzato il seguente gcode iniziale: START_PRINT BED_TEMP={material_bed_temperature_layer_0} EXTRUDER_TEMP={material_print_temperature_layer_0} Nei derivati di slic3r come PrusaSlicer e SuperSlicer, verrebbe utilizzato quanto segue: START_PRINT EXTRUDER_TEMP=[first_layer_temperature] BED_TEMP=[first_layer_bed_temperature] Si noti inoltre che questeislicer inseriranno i propri codici di riscaldamento quando determinate condizioni non vengono soddisfatte. In Cura, l'esistenza delle variabili {material_bed_temperature_layer_0} e {material_print_temperature_layer_0} \u00e8 sufficiente per mitigare questo problema. Nei derivati slic3r, dovresti usare: M140 S0 M104 S0 prima della chiamata della macro. Tieni inoltre presente che SuperSlicer ha un'opzione del pulsante \"solo gcode personalizzato\", che ottiene lo stesso risultato. Un esempio di una macro START_PRINT che utilizza questi parametri pu\u00f2 essere trovato in config/sample-macros.cfg","title":"slicer"},{"location":"Slicers.html#slicer","text":"Questo documento fornisce alcuni suggerimenti per configurare un'applicazione \"slicer\" da usare con Klipper. Gli slicer comuni usati con Klipper sono Slic3r, Cura, Simplify3D, ecc.","title":"slicer"},{"location":"Slicers.html#imposta-il-gcode-su-variante-marlin","text":"Molti slicer hanno un'opzione per configurare il \"gusto G-Code\" o G-Code flavor. L'impostazione predefinita \u00e8 spesso \"Marlin\" e funziona bene con Klipper. L'impostazione \"Smoothieware\" funziona bene anche con Klipper.","title":"Imposta il Gcode su variante Marlin"},{"location":"Slicers.html#klipper-gcode_macro","text":"Gli slicer spesso consentono di configurare le sequenze \"Start G-Code\" e \"End G-Code\". Spesso \u00e8 invece conveniente definire macro personalizzate nel file di configurazione di Klipper, come ad esempio: [gcode_macro START_PRINT] e [gcode_macro END_PRINT] . Quindi puoi semplicemente eseguire START_PRINT e END_PRINT nella configurazione dello slicer. La definizione di queste azioni nella configurazione di Klipper pu\u00f2 rendere pi\u00f9 semplice modificare i passaggi iniziali e finali della stampante poich\u00e9 le modifiche non richiedono il re-slicing. Vedere sample-macros.cfg ad esempio le macro START_PRINT e END_PRINT. Vedere il config reference per i dettagli sulla definizione di una macro gcode.","title":"Klipper gcode_macro"},{"location":"Slicers.html#impostazioni-di-retrazione-di-grandi-dimensioni-potrebbero-richiedere-la-messa-a-punto-di-klipper","text":"La velocit\u00e0 massima e l'accelerazione dei movimenti di ritrazione sono controllate in Klipper dalle impostazioni di configurazione max_extrude_only_velocity e max_extrude_only_accel . Queste impostazioni hanno un valore predefinito che dovrebbe funzionare bene su molte stampanti. Tuttavia, se si \u00e8 configurata una grande retrazione nello slicer (ad es. 5 mm o superiore), \u00e8 possibile che limitino la velocit\u00e0 di retrazione desiderata. Se si utilizza una grande retrazione, prendere in considerazione l'ottimizzazione di pressure advance di Klipper. Altrimenti, se si scopre che la testa di stampa sembra \"mettersi in pausa\" durante la retrazione e il priming, allora considerare di definire esplicitamente max_extrude_only_velocity e max_extrude_only_accel nel file di configurazione di Klipper.","title":"Impostazioni di retrazione di grandi dimensioni potrebbero richiedere la messa a punto di Klipper"},{"location":"Slicers.html#non-abilitare-coasting-costeggiando-","text":"\u00c8 probabile che la funzione \"coasting\" si traduca in stampe di scarsa qualit\u00e0 con Klipper. Prendi in considerazione l'utilizzo di pressure advance di Klipper. In particolare, se lo slicer cambia drasticamente la velocit\u00e0 di estrusione tra i movimenti, Klipper eseguir\u00e0 la decelerazione e l'accelerazione tra i movimenti. \u00c8 probabile che questo renda il blobbing peggiore, non migliore. Al contrario, va bene (e spesso utile) utilizzare l'impostazione ritiro \"retract\" , l'impostazione pulire \"wipe\" e/o l'impostazione pulire alla retrazione \"wipe on retract\".","title":"Non abilitare \"coasting\" -costeggiando-"},{"location":"Slicers.html#non-utilizzare-la-distanza-di-riavvio-extra-extra-restart-distancesu-simplify3d","text":"Questa impostazione pu\u00f2 causare cambiamenti radicali alle velocit\u00e0 di estrusione che possono attivare il controllo della sezione trasversale di estrusione massima di Klipper. Prendi in considerazione l'utilizzo dell' pressure advance di Klipper o della normale impostazione di retrazione Simplify3d.","title":"Non utilizzare la \"distanza di riavvio extra\"- \"extra restart distance\"su Simplify3d"},{"location":"Slicers.html#disabilita-preloadve-su-kisslicer","text":"Se si utilizza il software di slicing KISSlicer, impostare \"PreloadVE\" su zero. Prendi in considerazione l'utilizzo di pressure advance di Klipper.","title":"Disabilita \"PreloadVE\" su KISSlicer"},{"location":"Slicers.html#disattiva-le-impostazioni-di-pressione-dellestrusore-avanzata-advanced-extruder-pressure","text":"Alcune affettatrici pubblicizzano una capacit\u00e0 di \"pressione dell'estrusore avanzata\" - \"advanced extruder pressure\". Si consiglia di mantenere queste opzioni disabilitate quando si utilizza Klipper poich\u00e9 \u00e8 probabile che si traducano in stampe di scarsa qualit\u00e0. Prendi in considerazione l'utilizzo di pressure advance di Klipper. In particolare, queste impostazioni dello slicer possono indicare al firmware di apportare modifiche alla velocit\u00e0 di estrusione nella speranza che il firmware si avvicini a tali richieste e che la stampante ottenga approssimativamente una pressione dell'estrusore desiderabile. Klipper, tuttavia, utilizza calcoli cinematici e tempi precisi. Quando a Klipper viene comandato di apportare modifiche significative alla velocit\u00e0 di estrusione, pianificher\u00e0 le modifiche corrispondenti a velocit\u00e0, accelerazione e movimento dell'estrusore, il che non \u00e8 l'intento dello slicer. Lo slicer pu\u00f2 anche comandare velocit\u00e0 di estrusione eccessive al punto da attivare il controllo della sezione trasversale di estrusione massima di Klipper. Al contrario, va bene (e spesso utile) utilizzare l'impostazione ritiro \"retract\" , l'impostazione pulire \"wipe\" e/o l'impostazione pulire alla retrazione \"wipe on retract\".","title":"Disattiva le impostazioni di \"pressione dell'estrusore avanzata\"-\"advanced extruder pressure\""},{"location":"Slicers.html#macro-start_print","text":"Quando si utilizza una macro START_PRINT o simile, a volte \u00e8 utile passare i parametri dalle variabili dello slicer alla macro. In Cura, per passare le temperature, verrebbe utilizzato il seguente gcode iniziale: START_PRINT BED_TEMP={material_bed_temperature_layer_0} EXTRUDER_TEMP={material_print_temperature_layer_0} Nei derivati di slic3r come PrusaSlicer e SuperSlicer, verrebbe utilizzato quanto segue: START_PRINT EXTRUDER_TEMP=[first_layer_temperature] BED_TEMP=[first_layer_bed_temperature] Si noti inoltre che questeislicer inseriranno i propri codici di riscaldamento quando determinate condizioni non vengono soddisfatte. In Cura, l'esistenza delle variabili {material_bed_temperature_layer_0} e {material_print_temperature_layer_0} \u00e8 sufficiente per mitigare questo problema. Nei derivati slic3r, dovresti usare: M140 S0 M104 S0 prima della chiamata della macro. Tieni inoltre presente che SuperSlicer ha un'opzione del pulsante \"solo gcode personalizzato\", che ottiene lo stesso risultato. Un esempio di una macro START_PRINT che utilizza questi parametri pu\u00f2 essere trovato in config/sample-macros.cfg","title":"Macro START_PRINT"},{"location":"Sponsors.html","text":"Sponsors \u00b6 Klipper \u00e8 un software libero. Dipendiamo dal generoso supporto degli sponsor. Considera la possibilit\u00e0 di sponsorizzare Klipper o di supportare i nostri sponsor. BIGTREETECH \u00b6 BIGTREETECH \u00e8 lo sponsor ufficiale della scheda madre di Klipper. BIGTREETECH si impegna a sviluppare prodotti innovativi e competitivi per servire meglio la comunit\u00e0 della stampa 3D. Seguili su Facebook o Twitter . Sponsors \u00b6 Sviluppatori Klipper \u00b6 Kevin O'Connor \u00b6 Kevin \u00e8 l'autore originale e l'attuale manutentore di Klipper. Fai una donazione su: https://ko-fi.com/koconnor o https://www.patreon.com/koconnor Eric Callahan \u00b6 Eric \u00e8 l'autore di bed_mesh, spi_flash e molti altri moduli Klipper. Eric ha una pagina per le donazioni : https://ko-fi.com/arksine Progetti correlati a Klipper \u00b6 Klipper \u00e8 spesso utilizzato con altri software gratuiti. Prendi in considerazione l'utilizzo o il supporto di questi progetti. Moonraker Mainsail Fluidd OctoPrint KlipperScreen","title":"Sponsors"},{"location":"Sponsors.html#sponsors","text":"Klipper \u00e8 un software libero. Dipendiamo dal generoso supporto degli sponsor. Considera la possibilit\u00e0 di sponsorizzare Klipper o di supportare i nostri sponsor.","title":"Sponsors"},{"location":"Sponsors.html#bigtreetech","text":"BIGTREETECH \u00e8 lo sponsor ufficiale della scheda madre di Klipper. BIGTREETECH si impegna a sviluppare prodotti innovativi e competitivi per servire meglio la comunit\u00e0 della stampa 3D. Seguili su Facebook o Twitter .","title":"BIGTREETECH"},{"location":"Sponsors.html#sponsors_1","text":"","title":"Sponsors"},{"location":"Sponsors.html#sviluppatori-klipper","text":"","title":"Sviluppatori Klipper"},{"location":"Sponsors.html#kevin-oconnor","text":"Kevin \u00e8 l'autore originale e l'attuale manutentore di Klipper. Fai una donazione su: https://ko-fi.com/koconnor o https://www.patreon.com/koconnor","title":"Kevin O'Connor"},{"location":"Sponsors.html#eric-callahan","text":"Eric \u00e8 l'autore di bed_mesh, spi_flash e molti altri moduli Klipper. Eric ha una pagina per le donazioni : https://ko-fi.com/arksine","title":"Eric Callahan"},{"location":"Sponsors.html#progetti-correlati-a-klipper","text":"Klipper \u00e8 spesso utilizzato con altri software gratuiti. Prendi in considerazione l'utilizzo o il supporto di questi progetti. Moonraker Mainsail Fluidd OctoPrint KlipperScreen","title":"Progetti correlati a Klipper"},{"location":"Status_Reference.html","text":"Status reference \u00b6 Questo documento \u00e8 un riferimento alle informazioni sullo stato della stampante disponibili in Klipper macro , display fields e tramite API Server . I campi in questo documento sono soggetti a modifiche: se si utilizza un attributo, assicurarsi di rivedere il documento Modifiche alla configurazione durante l'aggiornamento del software Klipper. angle \u00b6 Le seguenti informazioni sono disponibili negli oggetti angle some_name : temperature : l'ultima lettura della temperatura (in gradi Celsius) da un sensore magnetico Hall tle5012b. Questo valore \u00e8 disponibile solo se il sensore angolare \u00e8 un chip tle5012b e se le misurazioni sono in corso (altrimenti segnala None ). bed_mesh \u00b6 Le seguenti informazioni sono disponibili in bed_mesh : profile_name , mesh_min , mesh_max , probed_matrix , mesh_matrix : informazioni sulla bed_mesh attualmente attiva. profiles : l'insieme dei profili attualmente definiti come setup usando BED_MESH_PROFILE. bed_screws \u00b6 Le seguenti informazioni sono disponibili nell'oggetto Config_Reference.md#bed_screws : is_active : Restituisce True se lo strumento di regolazione delle viti del letto \u00e8 attualmente attivo. state : lo stato dello strumento di regolazione delle viti del piatto. \u00c8 una delle seguenti stringhe: \"adjust\", \"fine\". current_screw : l'indice per la vite corrente in corso di regolazione. accepted_screws : il numero di viti accettate. configfile \u00b6 Le seguenti informazioni sono disponibili nell'oggetto configfile (questo oggetto \u00e8 sempre disponibile): settings.<section>.<option> : Restituisce l'impostazione del file di configurazione data (o il valore predefinito) durante l'ultimo avvio o riavvio del software. (Qualsiasi impostazione modificata in fase di esecuzione non si rifletter\u00e0 qui.) config.<section>.<option> : Restituisce l'impostazione del file di configurazione non elaborato come letta da Klipper durante l'ultimo avvio o riavvio del software. (Qualsiasi impostazione modificata in fase di esecuzione non si rifletter\u00e0 qui.) Tutti i valori vengono restituiti come stringhe. save_config_pending : Restituisce vero se ci sono aggiornamenti che un comando SAVE_CONFIG potrebbe rendere persistenti sul disco. save_config_pending_items : contiene le sezioni e le opzioni che sono state modificate e sarebbero mantenute da un SAVE_CONFIG . warnings : un elenco di avvisi sulle opzioni di configurazione. Ogni voce nell'elenco sar\u00e0 un dizionario contenente un campo type e message (entrambe le stringhe). Ulteriori campi potrebbero essere disponibili a seconda del tipo di avviso. display_status \u00b6 Le seguenti informazioni sono disponibili nell'oggetto display_status (questo oggetto \u00e8 automaticamente disponibile se \u00e8 definita una sezione di configurazione display ): progress : il valore di avanzamento dell'ultimo comando G-Code M73 (o virtual_sdcard.progress se non \u00e8 stato ricevuto alcun M73 recente). message : il messaggio contenuto nell'ultimo comando G-Code M117 . endstop_phase \u00b6 Le seguenti informazioni sono disponibili nell'oggetto endstop_phase : last_home.<nome stepper>.phase : La fase del motore passo-passo al termine dell'ultimo tentativo di home. last_home.<stepper name>.phases : il numero totale di fasi disponibili sul motore passo-passo. last_home.<stepper name>.mcu_position : la posizione (tracciata dal microcontrollore) del motore passo-passo alla fine dell'ultimo tentativo di home. La posizione \u00e8 il numero totale di passi effettuati in avanti meno il numero totale di passi effettuati in senso inverso dall'ultimo riavvio del microcontrollore. exclude_object \u00b6 Le seguenti informazioni sono disponibili nell'oggetto exclude_object : objects : un array di oggetti conosciuti come fornito dal comando EXCLUDE_OBJECT_DEFINE . Queste sono le stesse informazioni fornite dal comando EXCLUDE_OBJECT VERBOSE=1 . I campi center e polygon saranno presenti solo se forniti nell'originale EXCLUDE_OBJECT_DEFINE Ecco un esempio JSON: [ { \"polygon\": [ [ 156.25, 146.2511675 ], [ 156.25, 153.7488325 ], [ 163.75, 153.7488325 ], [ 163.75, 146.2511675 ] ], \"name\": \"CYLINDER_2_STL_ID_2_COPY_0\", \"center\": [ 160, 150 ] }, { \"polygon\": [ [ 146.25, 146.2511675 ], [ 146.25, 153.7488325 ], [ 153.75, 153.7488325 ], [ 153.75, 146.2511675 ] ], \"name\": \"CYLINDER_2_STL_ID_1_COPY_0\", \"center\": [ 150, 150 ] } ] excluded_objects : un array di stringhe che elenca i nomi degli oggetti esclusi. current_object : il nome dell'oggetto attualmente in fase di stampa. extruder_stepper \u00b6 Le seguenti informazioni sono disponibili per gli oggetti extruder_stepper (cos\u00ec come per gli oggetti extruder ): pressure_advance : il valore corrente di pressure advance . smooth_time : il tempo di avanzamento graduale della pressure advance corrente. motion_queue : il nome dell'estrusore con cui \u00e8 attualmente sincronizzato questo stepper estrusore. Questo viene segnalato come None se lo stepper dell'estrusore non \u00e8 attualmente associato a un estrusore. fan \u00b6 Le seguenti informazioni sono disponibili negli oggetti fan , heater_fan some_name e controller_fan some_name : speed : La velocit\u00e0 della ventola come float tra 0.0 e 1.0. rpm : la velocit\u00e0 della ventola misurata in rotazioni al minuto se la ventola ha un pin tachimetro definito. filament_switch_sensor \u00b6 Le seguenti informazioni sono disponibili negli oggetti filament_switch_sensor some_name : enabled : Restituisce True se il sensore interruttore \u00e8 attualmente abilitato. filament_detected : restituisce True se il sensore \u00e8 in uno stato attivato. filament_motion_sensor \u00b6 Le seguenti informazioni sono disponibili negli oggetti filament_motion_sensor some_name : abilitato : Restituisce True se il sensore di movimento \u00e8 attualmente abilitato. filament_detected : restituisce True se il sensore \u00e8 in uno stato attivato. firmware_retraction \u00b6 Le seguenti informazioni sono disponibili nell'oggetto firmware_retraction : retract_length , retract_speed , unretract_extra_length , unretract_speed : le impostazioni correnti per il modulo firmware_retraction. Queste impostazioni possono differire dal file di configurazione se un comando SET_RETRACTION le altera. gcode_button \u00b6 The following information is available in gcode_button some_name objects: state : The current button state returned as \"PRESSED\" or \"RELEASED\" gcode_macro \u00b6 Le seguenti informazioni sono disponibili negli oggetti gcode_macro some_name : <variabile> : il valore corrente di una variabile gcode_macro . gcode_move \u00b6 Le seguenti informazioni sono disponibili nell'oggetto gcode_move (questo oggetto \u00e8 sempre disponibile): gcode_position : la posizione corrente della testa di stampa rispetto all'origine del Gcode corrente. Cio\u00e8, posizioni che si potrebbero inviare direttamente a un comando G1 . \u00c8 possibile accedere ai componenti x, y, z ed e di questa posizione (ad esempio, gcode_position.x ). position : l'ultima posizione comandata della testina utilizzando il sistema di coordinate specificato nel file di configurazione. \u00c8 possibile accedere alle componenti x, y, z ed e di questa posizione (ad esempio, position.x ). homing_origin : l'origine del sistema di coordinate gcode (relativo al sistema di coordinate specificato nel file di configurazione) da utilizzare dopo un comando G28 . Il comando SET_GCODE_OFFSET pu\u00f2 alterare questa posizione. \u00c8 possibile accedere ai componenti x, y e z di questa posizione (ad esempio, homing_origin.x ). speed : l'ultima velocit\u00e0 impostata in un comando G1 (in mm/s). speed_factor : La\"speed factor override\" come impostato da un comando M220 . Questo \u00e8 un valore in virgola mobile tale che 1,0 significa nessun override e, ad esempio, 2,0 raddoppierebbe la velocit\u00e0 richiesta. extrude_factor : L'\"extrude factor override\" come impostato da un comando M221 . Questo \u00e8 un valore in virgola mobile tale che 1,0 significa nessun override ad esempio 2,0 raddoppierebbe le estrusioni richieste. absolute_coordinates : restituisce True se in modalit\u00e0 coordinate assolute G90 o False se in modalit\u00e0 relativa G91 . absolute_extrude : restituisce True se in modalit\u00e0 di estrusione assoluta M82 o False se in modalit\u00e0 relativa M83 . hall_filament_width_sensor \u00b6 Le seguenti informazioni sono disponibili nell'oggetto hall_filament_width_sensor : is_active : Restituisce True se il sensore \u00e8 attualmente attivo. Diameter : l'ultima lettura dal sensore in mm. Raw : l'ultima lettura grezza dell'ADC dal sensore. Riscaldatore \u00b6 Le seguenti informazioni sono disponibili per oggetti riscaldatore come extruder , heater_bed e heater_generic : temperature : l'ultima temperatura riportata (in gradi Celsius come float) per il dato riscaldatore. target : la temperatura target attuale (in gradi Celsius come float) per il riscaldatore dato. power : l'ultima impostazione del pin PWM (un valore compreso tra 0.0 e 1.0) associato al riscaldatore. can_extrude : Se l'estrusore pu\u00f2 estrudere (definito da min_extrude_temp ), disponibile solo per extruder Riscaldatori \u00b6 Le seguenti informazioni sono disponibili nell'oggetto heaters (questo oggetto \u00e8 disponibile se \u00e8 definito un riscaldatore): disponibili_riscaldatori : restituisce un elenco di tutti i riscaldatori attualmente disponibili in base ai nomi completi delle sezioni di configurazione, ad es. [\"extruder\", \"heater_bed\", \"heater_generic my_custom_heater\"] . available_sensors : restituisce un elenco di tutti i riscaldatori attualmente disponibili in base ai nomi completi delle sezioni di configurazione, ad es. [\"extruder\", \"heater_bed\", \"heater_generic my_custom_heater\"] . available_monitors : Returns a list of all currently available temperature monitors by their full config section names, e.g. [\"tmc2240 stepper_x\"] . While a temperature sensor is always available to read, a temperature monitor may not be available and will return null in such case. idle_timeout \u00b6 Le seguenti informazioni sono disponibili nell'oggetto idle_timeout (questo oggetto \u00e8 sempre disponibile): state : lo stato corrente della stampante monitorato dal modulo idle_timeout. \u00c8 una delle seguenti stringhe: \"Idle\", \"Printing\", \"Ready\". printing_time : la quantit\u00e0 di tempo (in secondi) in cui la stampante \u00e8 rimasta nello stato \"Printing\" (come tracciato dal modulo idle_timeout). led \u00b6 Le seguenti informazioni sono disponibili per ogni sezione di configurazione [led led_name] , [neopixel led_name] , [dotstar led_name] , [pca9533 led_name] e [pca9632 led_name] definita in printer.cfg: color_data : un elenco di lista di colori contenenti i valori RGBW per ogni led nella catena. Ogni valore \u00e8 rappresentato come un float da 0,0 a 1,0. Ciascuna lista di colori contiene 4 voci (rosso, verde, blu, bianco) anche se il LED sottostante supporta meno canali di colore. Ad esempio, \u00e8 possibile accedere al valore blu (3\u00b0 elemento nell'elenco dei colori) del secondo neopixel in una catena in printer[\"neopixel <config_name>\"].color_data[1][2] . manual_probe \u00b6 Le seguenti informazioni sono disponibili nell'oggetto manual_probe : is_active : Restituisce True se \u00e8 attualmente attivo uno script di supporto per il rilevamento manuale. z_position : l'altezza corrente dell'ugello (come la sta attualmente interpretando la stampante). z_position_lower : ultimo tentativo di sonda appena inferiore all'altezza corrente. z_position_upper : ultimo tentativo di sonda appena maggiore dell'altezza corrente. mcu \u00b6 Le seguenti informazioni sono disponibili negli oggetti mcu e mcu some_name : mcu_version : la versione del codice Klipper riportata dal microcontrollore. mcu_build_versions : informazioni sugli strumenti di compilazione utilizzati per generare il codice del microcontrollore (come riportato dal microcontrollore). mcu_constants.<constant_name> : Elenca le costanti di tempo riportate dal microcontrollore. Le costanti disponibili possono differire tra le architetture del microcontrollore e con ogni revisione del codice. last_stats.<statistics_name> : informazioni statistiche sulla connessione del microcontrollore. motion_report \u00b6 Le seguenti informazioni sono disponibili nell'oggetto motion_report (questo oggetto \u00e8 automaticamente disponibile se \u00e8 definita una sezione di configurazione stepper): live_position : la posizione richiesta della testa di stampa interpolata all'ora corrente. live_velocity : la velocit\u00e0 della testa di stampa richiesta (in mm/s) al momento attuale. live_extruder_velocity : la velocit\u00e0 dell'estrusore richiesta (in mm/s) al momento attuale. output_pin \u00b6 Le seguenti informazioni sono disponibili negli oggetti output_pin some_name : value : Il \"valore\" del pin, come impostato da un comando SET_PIN . palette2 \u00b6 Le seguenti informazioni sono disponibili nell'oggetto palette2 : ping : Valore dell'ultimo ping di Palette 2 riportato in percentuale. remaining_load_length : Quando si avvia una stampa della Palette 2, questa sar\u00e0 la quantit\u00e0 di filamento da caricare nell'estrusore. is_splicing : Vero quando la Palette 2 sta giuntando il filamento. pause_resume \u00b6 Le seguenti informazioni sono disponibili nell'oggetto pause_resume : is_paused : Restituisce vero se un comando PAUSE \u00e8 stato eseguito senza un corrispondente RESUME. print_stats \u00b6 Le seguenti informazioni sono disponibili nell'oggetto print_stats (questo oggetto \u00e8 automaticamente disponibile se \u00e8 definita una sezione di configurazione virtual_sdcard ): filename , total_duration , print_duration , filament_used , state , message : informazioni stimate sulla stampa corrente quando \u00e8 attiva una stampa da virtual_sdcard. info.total_layer : Il valore totale del layer dell'ultimo comando G-Code SET_PRINT_STATS_INFO TOTAL_LAYER=<valore> . info.current_layer : il valore del layer corrente dell'ultimo comando G-Code SET_PRINT_STATS_INFO CURRENT_LAYER=<valore> . probe \u00b6 Le seguenti informazioni sono disponibili nell'oggetto probe (questo oggetto \u00e8 disponibile anche se \u00e8 definita una sezione di configurazione bltouch ): name : restituisce il nome della sonda in uso. last_query : Restituisce True se il probe \u00e8 stato segnalato come \"attivato\" durante l'ultimo comando QUERY_PROBE. Nota, se questo viene utilizzato in una macro, a causa dell'ordine di espansione del modello, il comando QUERY_PROBE deve essere eseguito prima della macro contenente questo riferimento. last_z_result : Restituisce il valore del risultato Z dell'ultimo comando PROBE. Nota, se questo viene utilizzato in una macro, a causa dell'ordine di espansione del modello, il comando PROBE (o simile) deve essere eseguito prima della macro contenente questo riferimento. pwm_cycle_time \u00b6 The following information is available in pwm_cycle_time some_name objects: value : Il \"valore\" del pin, come impostato da un comando SET_PIN . quad_gantry_level \u00b6 Le seguenti informazioni sono disponibili nell'oggetto quad_gantry_level (questo oggetto \u00e8 disponibile se quad_gantry_level \u00e8 definito): applied : Vero se il processo di livellamento del gantry \u00e8 stato eseguito e completato con successo. query_endstops \u00b6 Le seguenti informazioni sono disponibili nell'oggetto query_endstops (questo oggetto \u00e8 disponibile se \u00e8 definito un finecorsa): last_query[\"<endstop>\"] : Restituisce True se l'endstop specificato \u00e8 stato segnalato come \"attivato-triggered\" durante l'ultimo comando QUERY_ENDSTOP. Nota, se questo viene utilizzato in una macro, a causa dell'ordine di espansione del modello, il comando QUERY_ENDSTOP deve essere eseguito prima della macro contenente questo riferimento. screws_tilt_adjust \u00b6 Le seguenti informazioni sono disponibili nell'oggetto screws_tilt_adjust : error : restituisce True se il comando SCREWS_TILT_CALCULATE pi\u00f9 recente includeva il parametro MAX_DEVIATION e uno qualsiasi dei punti della vite rilevati superava il MAX_DEVIATION specificato. max_deviation : Return the last MAX_DEVIATION value of the most recent SCREWS_TILT_CALCULATE command. results[\"<screw>\"] : un dizionario contenente le seguenti chiavi: z : L'altezza Z misurata della posizione della vite. sign : una stringa che specifica la direzione in cui ruotare la vite per la regolazione necessaria. O \"CW\" per senso orario o \"CCW\" per senso antiorario. adjust : il numero di giri di vite per regolare la vite, dato nel formato \"HH:MM\", dove \"HH\" \u00e8 il numero di giri di vite completi e \"MM\" \u00e8 il numero di \"minuti di un quadrante di orologio\" che rappresenta un giro di vite parziale. (Es. \"01:15\" significherebbe girare la vite di un giro e un quarto.) is_base : Restituisce True se questa \u00e8 la vite di base. servo \u00b6 Le seguenti informazioni sono disponibili negli oggetti servo some_name : printer[\"servo <config_name>\"].value : l'ultima impostazione del pin PWM (un valore compreso tra 0.0 e 1.0) associata al servo. stepper_enable \u00b6 Le seguenti informazioni sono disponibili nell'oggetto stepper_enable (questo oggetto \u00e8 disponibile se \u00e8 definito uno stepper): steppers[\"<stepper>\"] : Restituisce True se lo stepper specificato \u00e8 abilitato. system_stats \u00b6 Le seguenti informazioni sono disponibili nell'oggetto system_stats (questo oggetto \u00e8 sempre disponibile): sysload , cputime , memavail : informazioni sul sistema operativo del host e sul carico del processo. sensori di temperatura \u00b6 Le seguenti informazioni sono disponibili in bme280 config_section_name , htu21d config_section_name , sht3x config_section_name , lm75 config_section_name , temperature_host config_section_name and temperature_combined config_section_name objects: temperature : l'ultima temperatura letta dal sensore. humidity , pressure , gas : The last read values from the sensor (only on bme280, htu21d, sht3x and lm75 sensors). temperature_fan \u00b6 Le seguenti informazioni sono disponibili negli oggetti temperature_fan some_name : temperature : l'ultima temperatura letta dal sensore. target : La temperatura target per la ventola. temperature_sensor \u00b6 Le seguenti informazioni sono disponibili negli oggetti temperature_sensor some_nome : temperature : l'ultima temperatura letta dal sensore. measured_min_temp , measured_max_temp : la temperatura pi\u00f9 bassa e pi\u00f9 alta vista dal sensore dall'ultimo riavvio del software host Klipper. driver tmc \u00b6 Le seguenti informazioni sono disponibili negli oggetti TMC stepper driver (ad esempio, [tmc2208 stepper_x] ): mcu_phase_offset : La posizione dello stepper del microcontrollore corrispondente alla fase \"zero\" del driver. Questo campo pu\u00f2 essere nullo se l'offset di fase non \u00e8 noto. phase_offset_position : La \"posizione comandata\" corrispondente alla fase \"zero\" del driver. Questo campo pu\u00f2 essere nullo se l'offset di fase non \u00e8 noto. drv_status : i risultati dell'ultima query sullo stato del driver. (Sono riportati solo i campi diversi da zero.) Questo campo sar\u00e0 nullo se il driver non \u00e8 abilitato (e quindi non viene interrogato periodicamente). temperature : The internal temperature reported by the driver. This field will be null if the driver is not enabled or if the driver does not support temperature reporting. run_current : La corrente di esecuzione attualmente impostata. hold_current : La corrente di mantenimento attualmente impostata. toolhead \u00b6 Le seguenti informazioni sono disponibili nell'oggetto toolhead (questo oggetto \u00e8 sempre disponibile): position : l'ultima posizione comandata della testa di stampa relativa al sistema di coordinate specificato nel file di configurazione. \u00c8 possibile accedere alle componenti x, y, z di questa posizione (ad esempio, position.x ). extruder : il nome dell'estrusore attualmente attivo. Ad esempio, in una macro si potrebbe usare printer[printer.toolhead.extruder].target per ottenere la temperatura target dell'estrusore corrente. homed_axes : Gli assi cartesiani correnti considerati in uno stato \"homed\". Questa \u00e8 una stringa contenente uno o pi\u00f9 di \"x\", \"y\", \"z\". axis_minimum , axis_maximum : i limiti di corsa dell'asse (mm) dopo la corsa di homing. \u00c8 possibile accedere alle componenti x, y, z di questo valore limite (ad es. axis_minimum.x , axis_minimum.z ). Per le stampanti Delta, cone_start_z \u00e8 l'altezza z massima al raggio massimo ( printer.toolhead.cone_start_z ). max_velocity , max_accel , minimum_cruise_ratio , square_corner_velocity : The current printing limits that are in effect. This may differ from the config file settings if a SET_VELOCITY_LIMIT (or M204 ) command alters them at run-time. stalls : il numero totale di volte (dall'ultimo riavvio) che la stampante ha dovuto essere messa in pausa perch\u00e9 la testina si muoveva pi\u00f9 velocemente di quanto fosse possibile leggere i movimenti dall'input del G-code. dual_carriage \u00b6 The following information is available in dual_carriage on a cartesian, hybrid_corexy or hybrid_corexz robot carriage_0 : The mode of the carriage 0. Possible values are: \"INACTIVE\" and \"PRIMARY\". carriage_1 : The mode of the carriage 1. Possible values are: \"INACTIVE\", \"PRIMARY\", \"COPY\", and \"MIRROR\". virtual_sdcard \u00b6 Le seguenti informazioni sono disponibili nell'oggetto virtual_sdcard : is_active : Restituisce True se una stampa da file \u00e8 attualmente attiva. progress : una stima dello stato di avanzamento della stampa corrente (in base alla dimensione del file e alla posizione del file). file_path : un percorso completo del file per il file attualmente caricato. file_position : la posizione corrente (in byte) di una stampa attiva. file_size : la dimensione (in byte) del file attualmente caricato. webhooks \u00b6 Le seguenti informazioni sono disponibili nell'oggetto webhooks (questo oggetto \u00e8 sempre disponibile): state : restituisce una stringa che indica lo stato corrente di Klipper. I valori possibili sono: \"ready\", \"startup\", \"shutdown\", \"error\". state_message : una stringa leggibile dall'uomo che fornisce un contesto aggiuntivo sullo stato corrente di Klipper. z_thermal_adjust \u00b6 Le seguenti informazioni sono disponibili nell'oggetto z_thermal_adjust (questo oggetto \u00e8 disponibile se z_thermal_adjust \u00e8 definito). enabled : Restituisce True se la regolazione \u00e8 abilitata. temperature : temperatura attuale (livellata) del sensore definito. [grado C] measured_min_temp : temperatura minima misurata. [degC] measured_max_temp : Temperatura massima misurata. [degC] current_z_adjust : Ultima regolazione Z calcolata [mm]. z_adjust_ref_temperature :Temperatura di riferimento corrente utilizzata per il calcolo di Z current_z_adjust [degC]. z_tilt \u00b6 Le seguenti informazioni sono disponibili nell'oggetto z_tilt (questo oggetto \u00e8 disponibile se z_tilt \u00e8 definito): applied : Vero se il processo di livellamento z-tilt \u00e8 stato eseguito e completato con successo.","title":"Status reference"},{"location":"Status_Reference.html#status-reference","text":"Questo documento \u00e8 un riferimento alle informazioni sullo stato della stampante disponibili in Klipper macro , display fields e tramite API Server . I campi in questo documento sono soggetti a modifiche: se si utilizza un attributo, assicurarsi di rivedere il documento Modifiche alla configurazione durante l'aggiornamento del software Klipper.","title":"Status reference"},{"location":"Status_Reference.html#angle","text":"Le seguenti informazioni sono disponibili negli oggetti angle some_name : temperature : l'ultima lettura della temperatura (in gradi Celsius) da un sensore magnetico Hall tle5012b. Questo valore \u00e8 disponibile solo se il sensore angolare \u00e8 un chip tle5012b e se le misurazioni sono in corso (altrimenti segnala None ).","title":"angle"},{"location":"Status_Reference.html#bed_mesh","text":"Le seguenti informazioni sono disponibili in bed_mesh : profile_name , mesh_min , mesh_max , probed_matrix , mesh_matrix : informazioni sulla bed_mesh attualmente attiva. profiles : l'insieme dei profili attualmente definiti come setup usando BED_MESH_PROFILE.","title":"bed_mesh"},{"location":"Status_Reference.html#bed_screws","text":"Le seguenti informazioni sono disponibili nell'oggetto Config_Reference.md#bed_screws : is_active : Restituisce True se lo strumento di regolazione delle viti del letto \u00e8 attualmente attivo. state : lo stato dello strumento di regolazione delle viti del piatto. \u00c8 una delle seguenti stringhe: \"adjust\", \"fine\". current_screw : l'indice per la vite corrente in corso di regolazione. accepted_screws : il numero di viti accettate.","title":"bed_screws"},{"location":"Status_Reference.html#configfile","text":"Le seguenti informazioni sono disponibili nell'oggetto configfile (questo oggetto \u00e8 sempre disponibile): settings.<section>.<option> : Restituisce l'impostazione del file di configurazione data (o il valore predefinito) durante l'ultimo avvio o riavvio del software. (Qualsiasi impostazione modificata in fase di esecuzione non si rifletter\u00e0 qui.) config.<section>.<option> : Restituisce l'impostazione del file di configurazione non elaborato come letta da Klipper durante l'ultimo avvio o riavvio del software. (Qualsiasi impostazione modificata in fase di esecuzione non si rifletter\u00e0 qui.) Tutti i valori vengono restituiti come stringhe. save_config_pending : Restituisce vero se ci sono aggiornamenti che un comando SAVE_CONFIG potrebbe rendere persistenti sul disco. save_config_pending_items : contiene le sezioni e le opzioni che sono state modificate e sarebbero mantenute da un SAVE_CONFIG . warnings : un elenco di avvisi sulle opzioni di configurazione. Ogni voce nell'elenco sar\u00e0 un dizionario contenente un campo type e message (entrambe le stringhe). Ulteriori campi potrebbero essere disponibili a seconda del tipo di avviso.","title":"configfile"},{"location":"Status_Reference.html#display_status","text":"Le seguenti informazioni sono disponibili nell'oggetto display_status (questo oggetto \u00e8 automaticamente disponibile se \u00e8 definita una sezione di configurazione display ): progress : il valore di avanzamento dell'ultimo comando G-Code M73 (o virtual_sdcard.progress se non \u00e8 stato ricevuto alcun M73 recente). message : il messaggio contenuto nell'ultimo comando G-Code M117 .","title":"display_status"},{"location":"Status_Reference.html#endstop_phase","text":"Le seguenti informazioni sono disponibili nell'oggetto endstop_phase : last_home.<nome stepper>.phase : La fase del motore passo-passo al termine dell'ultimo tentativo di home. last_home.<stepper name>.phases : il numero totale di fasi disponibili sul motore passo-passo. last_home.<stepper name>.mcu_position : la posizione (tracciata dal microcontrollore) del motore passo-passo alla fine dell'ultimo tentativo di home. La posizione \u00e8 il numero totale di passi effettuati in avanti meno il numero totale di passi effettuati in senso inverso dall'ultimo riavvio del microcontrollore.","title":"endstop_phase"},{"location":"Status_Reference.html#exclude_object","text":"Le seguenti informazioni sono disponibili nell'oggetto exclude_object : objects : un array di oggetti conosciuti come fornito dal comando EXCLUDE_OBJECT_DEFINE . Queste sono le stesse informazioni fornite dal comando EXCLUDE_OBJECT VERBOSE=1 . I campi center e polygon saranno presenti solo se forniti nell'originale EXCLUDE_OBJECT_DEFINE Ecco un esempio JSON: [ { \"polygon\": [ [ 156.25, 146.2511675 ], [ 156.25, 153.7488325 ], [ 163.75, 153.7488325 ], [ 163.75, 146.2511675 ] ], \"name\": \"CYLINDER_2_STL_ID_2_COPY_0\", \"center\": [ 160, 150 ] }, { \"polygon\": [ [ 146.25, 146.2511675 ], [ 146.25, 153.7488325 ], [ 153.75, 153.7488325 ], [ 153.75, 146.2511675 ] ], \"name\": \"CYLINDER_2_STL_ID_1_COPY_0\", \"center\": [ 150, 150 ] } ] excluded_objects : un array di stringhe che elenca i nomi degli oggetti esclusi. current_object : il nome dell'oggetto attualmente in fase di stampa.","title":"exclude_object"},{"location":"Status_Reference.html#extruder_stepper","text":"Le seguenti informazioni sono disponibili per gli oggetti extruder_stepper (cos\u00ec come per gli oggetti extruder ): pressure_advance : il valore corrente di pressure advance . smooth_time : il tempo di avanzamento graduale della pressure advance corrente. motion_queue : il nome dell'estrusore con cui \u00e8 attualmente sincronizzato questo stepper estrusore. Questo viene segnalato come None se lo stepper dell'estrusore non \u00e8 attualmente associato a un estrusore.","title":"extruder_stepper"},{"location":"Status_Reference.html#fan","text":"Le seguenti informazioni sono disponibili negli oggetti fan , heater_fan some_name e controller_fan some_name : speed : La velocit\u00e0 della ventola come float tra 0.0 e 1.0. rpm : la velocit\u00e0 della ventola misurata in rotazioni al minuto se la ventola ha un pin tachimetro definito.","title":"fan"},{"location":"Status_Reference.html#filament_switch_sensor","text":"Le seguenti informazioni sono disponibili negli oggetti filament_switch_sensor some_name : enabled : Restituisce True se il sensore interruttore \u00e8 attualmente abilitato. filament_detected : restituisce True se il sensore \u00e8 in uno stato attivato.","title":"filament_switch_sensor"},{"location":"Status_Reference.html#filament_motion_sensor","text":"Le seguenti informazioni sono disponibili negli oggetti filament_motion_sensor some_name : abilitato : Restituisce True se il sensore di movimento \u00e8 attualmente abilitato. filament_detected : restituisce True se il sensore \u00e8 in uno stato attivato.","title":"filament_motion_sensor"},{"location":"Status_Reference.html#firmware_retraction","text":"Le seguenti informazioni sono disponibili nell'oggetto firmware_retraction : retract_length , retract_speed , unretract_extra_length , unretract_speed : le impostazioni correnti per il modulo firmware_retraction. Queste impostazioni possono differire dal file di configurazione se un comando SET_RETRACTION le altera.","title":"firmware_retraction"},{"location":"Status_Reference.html#gcode_button","text":"The following information is available in gcode_button some_name objects: state : The current button state returned as \"PRESSED\" or \"RELEASED\"","title":"gcode_button"},{"location":"Status_Reference.html#gcode_macro","text":"Le seguenti informazioni sono disponibili negli oggetti gcode_macro some_name : <variabile> : il valore corrente di una variabile gcode_macro .","title":"gcode_macro"},{"location":"Status_Reference.html#gcode_move","text":"Le seguenti informazioni sono disponibili nell'oggetto gcode_move (questo oggetto \u00e8 sempre disponibile): gcode_position : la posizione corrente della testa di stampa rispetto all'origine del Gcode corrente. Cio\u00e8, posizioni che si potrebbero inviare direttamente a un comando G1 . \u00c8 possibile accedere ai componenti x, y, z ed e di questa posizione (ad esempio, gcode_position.x ). position : l'ultima posizione comandata della testina utilizzando il sistema di coordinate specificato nel file di configurazione. \u00c8 possibile accedere alle componenti x, y, z ed e di questa posizione (ad esempio, position.x ). homing_origin : l'origine del sistema di coordinate gcode (relativo al sistema di coordinate specificato nel file di configurazione) da utilizzare dopo un comando G28 . Il comando SET_GCODE_OFFSET pu\u00f2 alterare questa posizione. \u00c8 possibile accedere ai componenti x, y e z di questa posizione (ad esempio, homing_origin.x ). speed : l'ultima velocit\u00e0 impostata in un comando G1 (in mm/s). speed_factor : La\"speed factor override\" come impostato da un comando M220 . Questo \u00e8 un valore in virgola mobile tale che 1,0 significa nessun override e, ad esempio, 2,0 raddoppierebbe la velocit\u00e0 richiesta. extrude_factor : L'\"extrude factor override\" come impostato da un comando M221 . Questo \u00e8 un valore in virgola mobile tale che 1,0 significa nessun override ad esempio 2,0 raddoppierebbe le estrusioni richieste. absolute_coordinates : restituisce True se in modalit\u00e0 coordinate assolute G90 o False se in modalit\u00e0 relativa G91 . absolute_extrude : restituisce True se in modalit\u00e0 di estrusione assoluta M82 o False se in modalit\u00e0 relativa M83 .","title":"gcode_move"},{"location":"Status_Reference.html#hall_filament_width_sensor","text":"Le seguenti informazioni sono disponibili nell'oggetto hall_filament_width_sensor : is_active : Restituisce True se il sensore \u00e8 attualmente attivo. Diameter : l'ultima lettura dal sensore in mm. Raw : l'ultima lettura grezza dell'ADC dal sensore.","title":"hall_filament_width_sensor"},{"location":"Status_Reference.html#riscaldatore","text":"Le seguenti informazioni sono disponibili per oggetti riscaldatore come extruder , heater_bed e heater_generic : temperature : l'ultima temperatura riportata (in gradi Celsius come float) per il dato riscaldatore. target : la temperatura target attuale (in gradi Celsius come float) per il riscaldatore dato. power : l'ultima impostazione del pin PWM (un valore compreso tra 0.0 e 1.0) associato al riscaldatore. can_extrude : Se l'estrusore pu\u00f2 estrudere (definito da min_extrude_temp ), disponibile solo per extruder","title":"Riscaldatore"},{"location":"Status_Reference.html#riscaldatori","text":"Le seguenti informazioni sono disponibili nell'oggetto heaters (questo oggetto \u00e8 disponibile se \u00e8 definito un riscaldatore): disponibili_riscaldatori : restituisce un elenco di tutti i riscaldatori attualmente disponibili in base ai nomi completi delle sezioni di configurazione, ad es. [\"extruder\", \"heater_bed\", \"heater_generic my_custom_heater\"] . available_sensors : restituisce un elenco di tutti i riscaldatori attualmente disponibili in base ai nomi completi delle sezioni di configurazione, ad es. [\"extruder\", \"heater_bed\", \"heater_generic my_custom_heater\"] . available_monitors : Returns a list of all currently available temperature monitors by their full config section names, e.g. [\"tmc2240 stepper_x\"] . While a temperature sensor is always available to read, a temperature monitor may not be available and will return null in such case.","title":"Riscaldatori"},{"location":"Status_Reference.html#idle_timeout","text":"Le seguenti informazioni sono disponibili nell'oggetto idle_timeout (questo oggetto \u00e8 sempre disponibile): state : lo stato corrente della stampante monitorato dal modulo idle_timeout. \u00c8 una delle seguenti stringhe: \"Idle\", \"Printing\", \"Ready\". printing_time : la quantit\u00e0 di tempo (in secondi) in cui la stampante \u00e8 rimasta nello stato \"Printing\" (come tracciato dal modulo idle_timeout).","title":"idle_timeout"},{"location":"Status_Reference.html#led","text":"Le seguenti informazioni sono disponibili per ogni sezione di configurazione [led led_name] , [neopixel led_name] , [dotstar led_name] , [pca9533 led_name] e [pca9632 led_name] definita in printer.cfg: color_data : un elenco di lista di colori contenenti i valori RGBW per ogni led nella catena. Ogni valore \u00e8 rappresentato come un float da 0,0 a 1,0. Ciascuna lista di colori contiene 4 voci (rosso, verde, blu, bianco) anche se il LED sottostante supporta meno canali di colore. Ad esempio, \u00e8 possibile accedere al valore blu (3\u00b0 elemento nell'elenco dei colori) del secondo neopixel in una catena in printer[\"neopixel <config_name>\"].color_data[1][2] .","title":"led"},{"location":"Status_Reference.html#manual_probe","text":"Le seguenti informazioni sono disponibili nell'oggetto manual_probe : is_active : Restituisce True se \u00e8 attualmente attivo uno script di supporto per il rilevamento manuale. z_position : l'altezza corrente dell'ugello (come la sta attualmente interpretando la stampante). z_position_lower : ultimo tentativo di sonda appena inferiore all'altezza corrente. z_position_upper : ultimo tentativo di sonda appena maggiore dell'altezza corrente.","title":"manual_probe"},{"location":"Status_Reference.html#mcu","text":"Le seguenti informazioni sono disponibili negli oggetti mcu e mcu some_name : mcu_version : la versione del codice Klipper riportata dal microcontrollore. mcu_build_versions : informazioni sugli strumenti di compilazione utilizzati per generare il codice del microcontrollore (come riportato dal microcontrollore). mcu_constants.<constant_name> : Elenca le costanti di tempo riportate dal microcontrollore. Le costanti disponibili possono differire tra le architetture del microcontrollore e con ogni revisione del codice. last_stats.<statistics_name> : informazioni statistiche sulla connessione del microcontrollore.","title":"mcu"},{"location":"Status_Reference.html#motion_report","text":"Le seguenti informazioni sono disponibili nell'oggetto motion_report (questo oggetto \u00e8 automaticamente disponibile se \u00e8 definita una sezione di configurazione stepper): live_position : la posizione richiesta della testa di stampa interpolata all'ora corrente. live_velocity : la velocit\u00e0 della testa di stampa richiesta (in mm/s) al momento attuale. live_extruder_velocity : la velocit\u00e0 dell'estrusore richiesta (in mm/s) al momento attuale.","title":"motion_report"},{"location":"Status_Reference.html#output_pin","text":"Le seguenti informazioni sono disponibili negli oggetti output_pin some_name : value : Il \"valore\" del pin, come impostato da un comando SET_PIN .","title":"output_pin"},{"location":"Status_Reference.html#palette2","text":"Le seguenti informazioni sono disponibili nell'oggetto palette2 : ping : Valore dell'ultimo ping di Palette 2 riportato in percentuale. remaining_load_length : Quando si avvia una stampa della Palette 2, questa sar\u00e0 la quantit\u00e0 di filamento da caricare nell'estrusore. is_splicing : Vero quando la Palette 2 sta giuntando il filamento.","title":"palette2"},{"location":"Status_Reference.html#pause_resume","text":"Le seguenti informazioni sono disponibili nell'oggetto pause_resume : is_paused : Restituisce vero se un comando PAUSE \u00e8 stato eseguito senza un corrispondente RESUME.","title":"pause_resume"},{"location":"Status_Reference.html#print_stats","text":"Le seguenti informazioni sono disponibili nell'oggetto print_stats (questo oggetto \u00e8 automaticamente disponibile se \u00e8 definita una sezione di configurazione virtual_sdcard ): filename , total_duration , print_duration , filament_used , state , message : informazioni stimate sulla stampa corrente quando \u00e8 attiva una stampa da virtual_sdcard. info.total_layer : Il valore totale del layer dell'ultimo comando G-Code SET_PRINT_STATS_INFO TOTAL_LAYER=<valore> . info.current_layer : il valore del layer corrente dell'ultimo comando G-Code SET_PRINT_STATS_INFO CURRENT_LAYER=<valore> .","title":"print_stats"},{"location":"Status_Reference.html#probe","text":"Le seguenti informazioni sono disponibili nell'oggetto probe (questo oggetto \u00e8 disponibile anche se \u00e8 definita una sezione di configurazione bltouch ): name : restituisce il nome della sonda in uso. last_query : Restituisce True se il probe \u00e8 stato segnalato come \"attivato\" durante l'ultimo comando QUERY_PROBE. Nota, se questo viene utilizzato in una macro, a causa dell'ordine di espansione del modello, il comando QUERY_PROBE deve essere eseguito prima della macro contenente questo riferimento. last_z_result : Restituisce il valore del risultato Z dell'ultimo comando PROBE. Nota, se questo viene utilizzato in una macro, a causa dell'ordine di espansione del modello, il comando PROBE (o simile) deve essere eseguito prima della macro contenente questo riferimento.","title":"probe"},{"location":"Status_Reference.html#pwm_cycle_time","text":"The following information is available in pwm_cycle_time some_name objects: value : Il \"valore\" del pin, come impostato da un comando SET_PIN .","title":"pwm_cycle_time"},{"location":"Status_Reference.html#quad_gantry_level","text":"Le seguenti informazioni sono disponibili nell'oggetto quad_gantry_level (questo oggetto \u00e8 disponibile se quad_gantry_level \u00e8 definito): applied : Vero se il processo di livellamento del gantry \u00e8 stato eseguito e completato con successo.","title":"quad_gantry_level"},{"location":"Status_Reference.html#query_endstops","text":"Le seguenti informazioni sono disponibili nell'oggetto query_endstops (questo oggetto \u00e8 disponibile se \u00e8 definito un finecorsa): last_query[\"<endstop>\"] : Restituisce True se l'endstop specificato \u00e8 stato segnalato come \"attivato-triggered\" durante l'ultimo comando QUERY_ENDSTOP. Nota, se questo viene utilizzato in una macro, a causa dell'ordine di espansione del modello, il comando QUERY_ENDSTOP deve essere eseguito prima della macro contenente questo riferimento.","title":"query_endstops"},{"location":"Status_Reference.html#screws_tilt_adjust","text":"Le seguenti informazioni sono disponibili nell'oggetto screws_tilt_adjust : error : restituisce True se il comando SCREWS_TILT_CALCULATE pi\u00f9 recente includeva il parametro MAX_DEVIATION e uno qualsiasi dei punti della vite rilevati superava il MAX_DEVIATION specificato. max_deviation : Return the last MAX_DEVIATION value of the most recent SCREWS_TILT_CALCULATE command. results[\"<screw>\"] : un dizionario contenente le seguenti chiavi: z : L'altezza Z misurata della posizione della vite. sign : una stringa che specifica la direzione in cui ruotare la vite per la regolazione necessaria. O \"CW\" per senso orario o \"CCW\" per senso antiorario. adjust : il numero di giri di vite per regolare la vite, dato nel formato \"HH:MM\", dove \"HH\" \u00e8 il numero di giri di vite completi e \"MM\" \u00e8 il numero di \"minuti di un quadrante di orologio\" che rappresenta un giro di vite parziale. (Es. \"01:15\" significherebbe girare la vite di un giro e un quarto.) is_base : Restituisce True se questa \u00e8 la vite di base.","title":"screws_tilt_adjust"},{"location":"Status_Reference.html#servo","text":"Le seguenti informazioni sono disponibili negli oggetti servo some_name : printer[\"servo <config_name>\"].value : l'ultima impostazione del pin PWM (un valore compreso tra 0.0 e 1.0) associata al servo.","title":"servo"},{"location":"Status_Reference.html#stepper_enable","text":"Le seguenti informazioni sono disponibili nell'oggetto stepper_enable (questo oggetto \u00e8 disponibile se \u00e8 definito uno stepper): steppers[\"<stepper>\"] : Restituisce True se lo stepper specificato \u00e8 abilitato.","title":"stepper_enable"},{"location":"Status_Reference.html#system_stats","text":"Le seguenti informazioni sono disponibili nell'oggetto system_stats (questo oggetto \u00e8 sempre disponibile): sysload , cputime , memavail : informazioni sul sistema operativo del host e sul carico del processo.","title":"system_stats"},{"location":"Status_Reference.html#sensori-di-temperatura","text":"Le seguenti informazioni sono disponibili in bme280 config_section_name , htu21d config_section_name , sht3x config_section_name , lm75 config_section_name , temperature_host config_section_name and temperature_combined config_section_name objects: temperature : l'ultima temperatura letta dal sensore. humidity , pressure , gas : The last read values from the sensor (only on bme280, htu21d, sht3x and lm75 sensors).","title":"sensori di temperatura"},{"location":"Status_Reference.html#temperature_fan","text":"Le seguenti informazioni sono disponibili negli oggetti temperature_fan some_name : temperature : l'ultima temperatura letta dal sensore. target : La temperatura target per la ventola.","title":"temperature_fan"},{"location":"Status_Reference.html#temperature_sensor","text":"Le seguenti informazioni sono disponibili negli oggetti temperature_sensor some_nome : temperature : l'ultima temperatura letta dal sensore. measured_min_temp , measured_max_temp : la temperatura pi\u00f9 bassa e pi\u00f9 alta vista dal sensore dall'ultimo riavvio del software host Klipper.","title":"temperature_sensor"},{"location":"Status_Reference.html#driver-tmc","text":"Le seguenti informazioni sono disponibili negli oggetti TMC stepper driver (ad esempio, [tmc2208 stepper_x] ): mcu_phase_offset : La posizione dello stepper del microcontrollore corrispondente alla fase \"zero\" del driver. Questo campo pu\u00f2 essere nullo se l'offset di fase non \u00e8 noto. phase_offset_position : La \"posizione comandata\" corrispondente alla fase \"zero\" del driver. Questo campo pu\u00f2 essere nullo se l'offset di fase non \u00e8 noto. drv_status : i risultati dell'ultima query sullo stato del driver. (Sono riportati solo i campi diversi da zero.) Questo campo sar\u00e0 nullo se il driver non \u00e8 abilitato (e quindi non viene interrogato periodicamente). temperature : The internal temperature reported by the driver. This field will be null if the driver is not enabled or if the driver does not support temperature reporting. run_current : La corrente di esecuzione attualmente impostata. hold_current : La corrente di mantenimento attualmente impostata.","title":"driver tmc"},{"location":"Status_Reference.html#toolhead","text":"Le seguenti informazioni sono disponibili nell'oggetto toolhead (questo oggetto \u00e8 sempre disponibile): position : l'ultima posizione comandata della testa di stampa relativa al sistema di coordinate specificato nel file di configurazione. \u00c8 possibile accedere alle componenti x, y, z di questa posizione (ad esempio, position.x ). extruder : il nome dell'estrusore attualmente attivo. Ad esempio, in una macro si potrebbe usare printer[printer.toolhead.extruder].target per ottenere la temperatura target dell'estrusore corrente. homed_axes : Gli assi cartesiani correnti considerati in uno stato \"homed\". Questa \u00e8 una stringa contenente uno o pi\u00f9 di \"x\", \"y\", \"z\". axis_minimum , axis_maximum : i limiti di corsa dell'asse (mm) dopo la corsa di homing. \u00c8 possibile accedere alle componenti x, y, z di questo valore limite (ad es. axis_minimum.x , axis_minimum.z ). Per le stampanti Delta, cone_start_z \u00e8 l'altezza z massima al raggio massimo ( printer.toolhead.cone_start_z ). max_velocity , max_accel , minimum_cruise_ratio , square_corner_velocity : The current printing limits that are in effect. This may differ from the config file settings if a SET_VELOCITY_LIMIT (or M204 ) command alters them at run-time. stalls : il numero totale di volte (dall'ultimo riavvio) che la stampante ha dovuto essere messa in pausa perch\u00e9 la testina si muoveva pi\u00f9 velocemente di quanto fosse possibile leggere i movimenti dall'input del G-code.","title":"toolhead"},{"location":"Status_Reference.html#dual_carriage","text":"The following information is available in dual_carriage on a cartesian, hybrid_corexy or hybrid_corexz robot carriage_0 : The mode of the carriage 0. Possible values are: \"INACTIVE\" and \"PRIMARY\". carriage_1 : The mode of the carriage 1. Possible values are: \"INACTIVE\", \"PRIMARY\", \"COPY\", and \"MIRROR\".","title":"dual_carriage"},{"location":"Status_Reference.html#virtual_sdcard","text":"Le seguenti informazioni sono disponibili nell'oggetto virtual_sdcard : is_active : Restituisce True se una stampa da file \u00e8 attualmente attiva. progress : una stima dello stato di avanzamento della stampa corrente (in base alla dimensione del file e alla posizione del file). file_path : un percorso completo del file per il file attualmente caricato. file_position : la posizione corrente (in byte) di una stampa attiva. file_size : la dimensione (in byte) del file attualmente caricato.","title":"virtual_sdcard"},{"location":"Status_Reference.html#webhooks","text":"Le seguenti informazioni sono disponibili nell'oggetto webhooks (questo oggetto \u00e8 sempre disponibile): state : restituisce una stringa che indica lo stato corrente di Klipper. I valori possibili sono: \"ready\", \"startup\", \"shutdown\", \"error\". state_message : una stringa leggibile dall'uomo che fornisce un contesto aggiuntivo sullo stato corrente di Klipper.","title":"webhooks"},{"location":"Status_Reference.html#z_thermal_adjust","text":"Le seguenti informazioni sono disponibili nell'oggetto z_thermal_adjust (questo oggetto \u00e8 disponibile se z_thermal_adjust \u00e8 definito). enabled : Restituisce True se la regolazione \u00e8 abilitata. temperature : temperatura attuale (livellata) del sensore definito. [grado C] measured_min_temp : temperatura minima misurata. [degC] measured_max_temp : Temperatura massima misurata. [degC] current_z_adjust : Ultima regolazione Z calcolata [mm]. z_adjust_ref_temperature :Temperatura di riferimento corrente utilizzata per il calcolo di Z current_z_adjust [degC].","title":"z_thermal_adjust"},{"location":"Status_Reference.html#z_tilt","text":"Le seguenti informazioni sono disponibili nell'oggetto z_tilt (questo oggetto \u00e8 disponibile se z_tilt \u00e8 definito): applied : Vero se il processo di livellamento z-tilt \u00e8 stato eseguito e completato con successo.","title":"z_tilt"},{"location":"TMC_Drivers.html","text":"Driver TMC \u00b6 Questo documento fornisce informazioni sull'utilizzo dei driver Trinamic per motori stepper in modalit\u00e0 SPI/UART su Klipper. Klipper pu\u00f2 anche utilizzare i driver Trinamic nella loro \"modalit\u00e0 standalone\". Tuttavia, quando i driver sono in questa modalit\u00e0, non \u00e8 necessaria alcuna configurazione speciale di Klipper e le funzionalit\u00e0 avanzate di Klipper discusse in questo documento non sono disponibili. Oltre a questo documento, assicurati di rivedere il riferimento alla configurazione del driver TMC . Regolazione della corrente del motore \u00b6 Una corrente pi\u00f9 alta del driver aumenta la precisione del posizionamento e la coppia. Tuttavia, una corrente pi\u00f9 elevata aumenta anche il calore prodotto dal motore passo-passo e dal driver del motore passo-passo. Se il driver del motore passo-passo si surriscalda, si disabiliter\u00e0 e Klipper segnaler\u00e0 un errore. Se il motore passo-passo si surriscalda, perde coppia e precisione di posizionamento. (Se diventa molto caldo, potrebbe anche fondere le parti di plastica attaccate o vicino ad esso.) Come consiglio generale per l'ottimizzazione, preferire valori di corrente pi\u00f9 elevati purch\u00e9 il motore passo-passo non si surriscaldi troppo e il driver del motore passo-passo non segnali avvisi o errori. In generale, va bene che il motore passo-passo sia caldo, ma non dovrebbe diventare cos\u00ec caldo da risultare doloroso al tatto. Preferibilmente non specificare un hold_current \u00b6 Se si configura un hold_current , il driver TMC pu\u00f2 ridurre la corrente al motore passo-passo quando rileva che il passo-passo non si sta muovendo. Tuttavia, la variazione della corrente del motore pu\u00f2 di per s\u00e9 introdurre il movimento del motore. Ci\u00f2 pu\u00f2 verificarsi a causa di \"forze di arresto\" all'interno del motore passo-passo (il magnete permanente nel rotore tira verso i denti di ferro nello statore) o a causa di forze esterne sul carrello dell'asse. La maggior parte dei motori passo-passo non otterr\u00e0 un beneficio significativo dalla riduzione della corrente durante le normali stampe, perch\u00e9 pochi movimenti di stampa lasceranno un motore passo-passo inattivo per un tempo sufficientemente lungo da attivare la funzione hold_current . Ed \u00e8 improbabile che si vogliano introdurre sottili artefatti di stampa nelle poche mosse di stampa che lasciano uno stepper inattivo sufficientemente a lungo. Se si desidera ridurre la corrente ai motori durante le routine di avvio della stampa, considerare l'emissione di comandi SET_TMC_CURRENT in una START_PRINT macro per regolare la corrente prima e dopo i normali spostamenti di stampa. Alcune stampanti con motori Z dedicati che sono inattivi durante i normali movimenti di stampa (nessuna bed_mesho, nessuna inclinazione_piatto, nessuna correzione_inclinazione Z, nessuna stampa in \"modalit\u00e0 vaso\", ecc.) potrebbero scoprire che i motori Z funzionano a temperature pi\u00f9 basse con un hold_current . Se si implementa questo, assicurarsi di prendere in considerazione questo tipo di movimento dell'asse Z non comandato durante il livellamento del piatto, il rilevamento del piatto, la calibrazione della sonda e simili. Anche driver_TPOWERDOWN e driver_IHOLDDELAY dovrebbero essere calibrati di conseguenza. Se non sei sicuro, preferisci non specificare un hold_current . Impostazione della modalit\u00e0 \"spreadCycle\" rispetto a \"stealthChop\" \u00b6 Per impostazione predefinita, Klipper mette i driver TMC in modalit\u00e0 \"spreadCycle\". Se il driver supporta \"stealthChop\", pu\u00f2 essere abilitato aggiungendo stealthchop_threshold: 999999 alla sezione di configurazione di TMC. In generale, la modalit\u00e0 SpreadCycle fornisce una coppia maggiore e una maggiore precisione di posizionamento rispetto alla modalit\u00e0 StealthChop. Tuttavia, la modalit\u00e0 StealthChop pu\u00f2 produrre un rumore udibile notevolmente inferiore su alcune stampanti. I test di confronto delle modalit\u00e0 hanno mostrato un \"ritardo posizionale\" aumentato di circa il 75% di un passo completo durante i movimenti a velocit\u00e0 costante quando si utilizza la modalit\u00e0 StealthChop (ad esempio, su una stampante con distanza_rotazione di 40 mm e 200 passi_per_rotazione, la deviazione di posizione dei movimenti a velocit\u00e0 costante \u00e8 aumentata di ~0,150 mm). Tuttavia, questo \"ritardo nell'ottenimento della posizione richiesta\" potrebbe non manifestarsi come un difetto di stampa significativo e si potrebbe preferire il comportamento pi\u00f9 silenzioso della modalit\u00e0 stealthChop. Si consiglia di utilizzare sempre la modalit\u00e0 \"spreadCycle\" (non specificando stealthchop_threshold ) o di utilizzare sempre la modalit\u00e0 \"stealthChop\" (impostando stealthchop_threshold su 999999). Sfortunatamente, i driver spesso producono risultati scadenti e confusi se la modalit\u00e0 cambia mentre il motore \u00e8 a una velocit\u00e0 diversa da zero. L'impostazione dell'interpolazione TMC introduce una piccola deviazione di posizione \u00b6 L'impostazione interpolate del driver TMC pu\u00f2 ridurre il rumore udibile del movimento della stampante a costo di introdurre un piccolo errore di posizione sistemico. Questo errore di posizione sistematico deriva dal ritardo del driver nell'esecuzione dei \"passi\" inviati da Klipper. Durante i movimenti a velocit\u00e0 costante, questo ritardo si traduce in un errore di posizione di quasi mezzo micropasso configurato (pi\u00f9 precisamente, l'errore \u00e8 di mezzo micropasso meno un 512esimo di un passo intero). Ad esempio, su un asse con una distanza_rotazione di 40 mm, 200 passi_per_rotazione e 16 micropassi, l'errore sistemico introdotto durante i movimenti a velocit\u00e0 costante \u00e8 ~0,006 mm. Per una migliore precisione di posizionamento, considerare l'utilizzo della modalit\u00e0 SpreadCycle e disabilitare l'interpolazione (impostare interpolate: False nella configurazione del driver TMC). Se configurato in questo modo, \u00e8 possibile aumentare l'impostazione microstep per ridurre il rumore udibile durante il movimento del passo-passo. Tipicamente, un'impostazione microstep di 64 o 128 avr\u00e0 un rumore udibile simile all'interpolazione e lo far\u00e0 senza introdurre un errore posizionale sistemico. Se si utilizza la modalit\u00e0 StealthChop, l'imprecisione posizionale dell'interpolazione \u00e8 piccola rispetto all'imprecisione posizionale introdotta dalla modalit\u00e0 StealthChop. Pertanto l'interpolazione dell'ottimizzazione non \u00e8 considerata utile in modalit\u00e0 StealthChop e si pu\u00f2 lasciare l'interpolazione nel suo stato predefinito. Homing Sensorless \u00b6 L'homing senza sensori consente di posizionare un asse senza la necessit\u00e0 di un finecorsa fisico. Invece, il carrello sull'asse viene spostato nel finecorsa meccanico facendo perdere passi al motore passo-passo. Il driver stepper rileva i passi persi e lo indica all'MCU di controllo (Klipper) attivando un pin. Queste informazioni possono essere utilizzate da Klipper come fine corsa per l'asse. Questa guida illustra l'impostazione dell'homing sensorless per l'asse X della stampante (cartesiana). Tuttavia, funziona allo stesso modo con tutti gli altri assi (che richiedono un fine corsa). Dovresti configurarlo e sintonizzarlo per un asse alla volta. Limitazioni \u00b6 Assicurati che i tuoi componenti meccanici siano in grado di sopportare il carico del carrello che urta ripetutamente il limite dell'asse. Soprattutto le viti di comando potrebbero generare molta forza. L'homing di un asse Z facendo urtare l'ugello sulla superficie di stampa potrebbe non essere una buona idea. Per ottenere i migliori risultati, verificare che il carrello dell'asse stabilisca un contatto stabile con il limite dell'asse. Inoltre, l'homing sensorless potrebbe non essere sufficientemente preciso per la tua stampante. Sebbene l'homing degli assi X e Y su una macchina cartesiana possa funzionare bene, l'homing dell'asse Z in genere non \u00e8 sufficientemente preciso e pu\u00f2 comportare un'altezza del primo strato incoerente. L'homing di una stampante delta sensorless non \u00e8 consigliabile a causa della mancanza di precisione. Inoltre, il rilevamento dello stallo del driver passo-passo dipende dal carico meccanico sul motore, dalla corrente del motore e dalla temperatura del motore (resistenza della bobina). L'homing sensorless funziona meglio a velocit\u00e0 medie del motore. Per velocit\u00e0 molto basse (inferiori a 10 giri/min) il motore non genera una significativa EMF di ritorno e il TMC non \u00e8 in grado di rilevare in modo affidabile gli stalli del motore. Inoltre, a velocit\u00e0 molto elevate, l'EMF di ritorno del motore si avvicina alla tensione di alimentazione del motore, quindi il TMC non \u00e8 pi\u00f9 in grado di rilevare gli stalli. Si consiglia di dare un'occhiata alla scheda tecnica del proprio TMC specifico. L\u00ec puoi anche trovare maggiori dettagli sulle limitazioni di questa configurazione. Prerequisiti \u00b6 Sono necessari alcuni prerequisiti per utilizzare l'homing sensorless: Driver passo-passo TMC compatibile con stallGuard (tmc2130, tmc2209, tmc2660 o tmc5160). Interfaccia SPI/UART del driver TMC cablata al microcontrollore (la modalit\u00e0 stand-alone non funziona). Il pin \"DIAG\" o \"SG_TST\" appropriato del driver TMC collegato al microcontrollore. I passaggi nel documento config checks devono essere eseguiti per confermare che i motori passo-passo siano configurati e funzionino correttamente. Messa a punto \u00b6 La procedura qui descritta prevede sei passaggi principali: Scegli una velocit\u00e0 di homing. Configura il file printer.cfg per abilitare l'homing sensorless. Trova l'impostazione stallguard con la massima sensibilit\u00e0 che funziona con successo. Trova l'impostazione stallguard con la sensibilit\u00e0 pi\u00f9 bassa che effettua homing con successo con un solo tocco. Aggiorna il printer.cfg con l'impostazione di stallguard desiderata. Crea o aggiorna le macro printer.cfg per homing in modo coerente. Scegli la velocit\u00e0 di homing \u00b6 La velocit\u00e0 di homing \u00e8 una scelta importante quando si esegue l'homing senza sensori. \u00c8 consigliabile utilizzare una velocit\u00e0 di riferimento bassa in modo che il carrello non eserciti una forza eccessiva sul telaio quando entra in contatto con l'estremit\u00e0 della rotaia. Tuttavia, i driver TMC non sono in grado di rilevare in modo affidabile uno stallo a velocit\u00e0 molto basse. Un buon punto di partenza per la velocit\u00e0 di homing \u00e8 che il motore passo-passo esegua una rotazione completa ogni due secondi. Per molti assi questa sar\u00e0 la rotation_distance divisa per due. Per esempio: [stepper_x] rotation_distance: 40 homing_speed: 20 ... Configura printer.cfg per l'homing sensorless \u00b6 L'impostazione homing_retract_dist deve essere impostata su zero nella sezione di configurazione stepper_x per disabilitare il secondo movimento di homing. Il secondo tentativo di homing non aggiunge valore quando si utilizza l'homing sensorless, non funzioner\u00e0 in modo affidabile e confonder\u00e0 il processo di ottimizzazione. Assicurati che un'impostazione hold_current non sia specificata nella sezione del driver TMC del file config. (Se viene impostata una hold_current, dopo che \u00e8 stato stabilito il contatto, il motore si arresta mentre il carrello viene premuto contro l'estremit\u00e0 del binario e la riduzione della corrente mentre si trova in quella posizione pu\u00f2 causare il movimento del carrello, il che si traduce in prestazioni scadenti e confonde il processo di regolazione.) \u00c8 necessario configurare i pin di homing sensorless e configurare le impostazioni iniziali di \"stallguard\". Una configurazione di esempio tmc2209 per un asse X potrebbe essere simile a: [tmc2209 stepper_x] diag_pin: ^PA1 # Impostare sul pin MCU collegato al pin TMC DIAG driver_SGTHRS: 255 #255 \u00e8 il valore pi\u00f9 sensibile, 0 \u00e8 il meno sensibile ... [stepper_x] endstop_pin: tmc2209_stepper_x:virtual_endstop homing_retract_dist: 0 ... Un esempio di configurazione tmc2130 o tmc5160 potrebbe essere simile a: [tmc2130 stepper_x] diag1_pin: ^!PA1 # Pin collegato al pin TMC DIAG1 (o utilizzare pin diag0_pin / DIAG0) driver_SGT: -64 # -64 \u00e8 il valore pi\u00f9 sensibile, 63 \u00e8 il meno sensibile ... [stepper_x] endstop_pin: tmc2130_stepper_x:virtual_endstop homing_retract_dist: 0 ... Un esempio di configurazione di tmc2660 potrebbe essere simile a: [tmc2660 stepper_x] driver_SGT: -64 # -64 \u00e8 il valore pi\u00f9 sensibile, 63 \u00e8 il meno sensibile ... [stepper_x] endstop_pin: ^PA1 # Pin collegato al pin TMC SG_TST homing_retract_dist: 0 ... Gli esempi sopra mostrano solo le impostazioni specifiche per l'homing sensorless. Vedere il riferimento alla configurazione per tutte le opzioni disponibili. Trova la massima sensibilit\u00e0 che porta a homing con successo \u00b6 Posizionare il carrello vicino al centro del binario. Utilizzare il comando SET_TMC_FIELD per impostare la sensibilit\u00e0 pi\u00f9 alta. Per tmc2209: SET_TMC_FIELD STEPPER=stepper_x FIELD=SGTHRS VALUE=255 Per tmc2130, tmc5160 e tmc2660: SET_TMC_FIELD STEPPER=stepper_x FIELD=sgt VALUE=-64 Quindi inviare un comando G28 X0 e verificare che l'asse non si muova affatto o smetta rapidamente di muoversi. Se l'asse non si ferma, inviare un M112 per fermare la stampante - qualcosa non \u00e8 corretto con il cablaggio o la configurazione dei pin diag/sg_tst e deve essere corretto prima di continuare. Quindi, diminuire progressivamente la sensibilit\u00e0 dell'impostazione VALUE ed eseguire nuovamente i comandi SET_TMC_FIELD G28 X0 per trovare la sensibilit\u00e0 pi\u00f9 alta che fa s\u00ec che il carrello si muova con successo fino all'arresto e si arresti. (Per i driver tmc2209 questo diminuir\u00e0 SGTHRS, per altri conducenti aumenter\u00e0 il sgt.) Assicurati di iniziare ogni tentativo con il carrello vicino al centro del binario (se necessario, emetti M84 e quindi sposta manualmente il carrello sul centro). Dovrebbe essere possibile trovare la sensibilit\u00e0 pi\u00f9 alta che si adatta in modo affidabile (le impostazioni con una sensibilit\u00e0 pi\u00f9 alta comportano movimenti piccoli o nulli). Nota il valore trovato come sensibilit\u00e0_massima . (Se si ottiene la sensibilit\u00e0 minima possibile (SGTHRS=0 o sgt=63) senza alcun movimento del carrello, allora qualcosa non \u00e8 corretto con il cablaggio o la configurazione dei pin diag/sg_tst e deve essere corretto prima di continuare.) Quando si cerca la sensibilit\u00e0_massima, pu\u00f2 essere conveniente passare a diverse impostazioni VALUE (in modo da dividere in due il parametro VALUE). In tal caso, prepararsi a emettere un comando M112 per arrestare la stampante, poich\u00e9 un'impostazione con una sensibilit\u00e0 molto bassa potrebbe far \"sbattere\" ripetutamente l'asse contro l'estremit\u00e0 del binario. Assicurati di attendere un paio di secondi tra ogni tentativo di homing. Dopo che il driver TMC ha rilevato uno stallo, potrebbe volerci un po' di tempo per cancellare il suo indicatore interno ed essere in grado di rilevare un altro stallo. Durante questi test di ottimizzazione, se un comando G28 X0 non si sposta fino al limite dell'asse, prestare attenzione nell'emettere qualsiasi comando di movimento regolare (ad es. G1 ). Klipper non avr\u00e0 una corretta comprensione della posizione del carrello e un comando di spostamento potrebbe causare risultati indesiderati e confusi. Trova la sensibilit\u00e0 pi\u00f9 bassa che porta a homing con un solo tocco \u00b6 Quando si effettua l'homing con il valore maximum_sensitivity trovato, l'asse dovrebbe spostarsi all'estremit\u00e0 del binario e fermarsi con un \"tocco singolo\", ovvero non dovrebbe esserci un \"clic\" o un \"sbattere\". (Se c'\u00e8 un suono che sbatte o scatta alla sensibilit\u00e0_massima, allora la velocit\u00e0 di riferimento potrebbe essere troppo bassa, la corrente del driver potrebbe essere troppo bassa o la corsa di riferimento senza sensore potrebbe non essere una buona scelta per l'asse.) Il passo successivo \u00e8 spostare di nuovo continuamente il carrello in una posizione vicino al centro della rotaia, diminuire la sensibilit\u00e0 ed eseguire i comandi SET_TMC_FIELD G28 X0 - l'obiettivo ora \u00e8 trovare la sensibilit\u00e0 pi\u00f9 bassa che risulti ancora nel la carrozza torna con successo al punto di riferimento con un \"tocco singolo\". Cio\u00e8, non \"sbatte\" o \"clic\" quando viene a contatto con l'estremit\u00e0 del binario. Nota il valore trovato come sensibilit\u00e0_minima . Aggiorna printer.cfg con il valore della sensibilit\u00e0 \u00b6 Dopo aver trovato sensibilit\u00e0_massima e sensibilit\u00e0_minima , utilizzare una calcolatrice per ottenere la sensibilit\u00e0 consigliata come sensibilit\u00e0_minima + (sensibilit\u00e0_massima - sensibilit\u00e0_minima)/3 . La sensibilit\u00e0 consigliata dovrebbe essere compresa tra il minimo e il massimo, ma leggermente pi\u00f9 vicino al minimo. Arrotonda il valore finale al valore intero pi\u00f9 vicino. Per tmc2209 impostalo nella configurazione come driver_SGTHRS , per altri driver TMC impostalo nella configurazione come driver_SGT . Se l'intervallo tra sensibilit\u00e0_massima e sensibilit\u00e0_minima \u00e8 piccolo (ad esempio, inferiore a 5), potrebbe risultare in un homing instabile. Una velocit\u00e0 di riferimento pi\u00f9 elevata pu\u00f2 aumentare il range e rendere l'operazione pi\u00f9 stabile. Si noti che se viene apportata una modifica alla corrente del driver, alla velocit\u00e0 di riferimento o viene apportata una modifica notevole all'hardware della stampante, sar\u00e0 necessario eseguire nuovamente il processo di ottimizzazione. Utilizzo delle macro durante l'homing \u00b6 Dopo aver completato l'homing senza sensori, il carrello verr\u00e0 premuto contro l'estremit\u00e0 del binario e lo stepper eserciter\u00e0 una forza sul telaio fino a quando il carrello non si allontana. \u00c8 una buona idea creare una macro per posizionare l'asse e allontanare immediatamente il carrello dall'estremit\u00e0 della rotaia. \u00c8 una buona idea che la macro si metta in pausa di almeno 2 secondi prima di iniziare l'homing sensorless (o altrimenti assicurarsi che non ci siano stati movimenti sullo stepper per 2 secondi). Senza ritardo \u00e8 possibile che il flag di stallo interno del driver sia ancora impostato da un movimento precedente. Pu\u00f2 anche essere utile fare in modo che quella macro imposti la corrente del driver prima della corsa di riferimento e imposti una nuova corrente dopo che il carrello si \u00e8 allontanato. Una macro di esempio potrebbe assomigliare a: [gcode_macro SENSORLESS_HOME_X] gcode: {% set HOME_CUR = 0.700 %} {% set driver_config = printer.configfile.settings['tmc2209 stepper_x'] %} {% set RUN_CUR = driver_config.run_current %} # Imposta la corrente per l'homing sensorless SET_TMC_CURRENT STEPPER=stepper_x CURRENT={HOME_CUR} # Fai una pausa per assicurarti che il flag di stallo del driver sia clear G4 P2000 # Home G28 X0 # Spostamento G90 G1 X5 F1200 # Imposta corrente durante la stampa SET_TMC_CURRENT STEPPER=stepper_x CURRENT={RUN_CUR} La macro risultante pu\u00f2 essere chiamata da una sezione di configurazione homing_override o da una START_PRINT macro . Si noti che se viene modificata la corrente del driver durante l'homing, il processo di ottimizzazione dovrebbe essere eseguito nuovamente. Suggerimenti per l'homing sensorless su CoreXY \u00b6 \u00c8 possibile utilizzare l'homing sensorless sui carrelli X e Y di una stampante CoreXY. Klipper usa lo stepper [stepper_x] per rilevare gli stalli durante l'homing del carrello X e usa lo stepper [stepper_y] per rilevare gli stalli durante l'homing del carrello Y. Utilizzare la guida alla messa a punto sopra descritta per trovare la \"sensibilit\u00e0 allo stallo\" appropriata per ciascun carrello, ma prestare attenzione alle seguenti restrizioni: Quando si utilizza l'homing sensorless su CoreXY, assicurarsi che non sia configurato hold_current per nessuno dei due stepper. Durante la messa a punto, assicurati che entrambi i carrelli X e Y siano vicini al centro dei loro binari prima di ogni tentativo di homing. Al termine dell'ottimizzazione, quando si esegue l'homing sia di X che Y, utilizzare le macro per assicurarsi che un asse sia homed per primo, quindi spostare il carrello lontano dal limite dell'asse, fare una pausa per almeno 2 secondi, quindi avviare l'orientamento dell'altro carrello. L'allontanamento dall'asse evita l'homing di un asse mentre l'altro viene premuto contro il limite dell'asse (cosa potrebbe distorcere il rilevamento dello stallo). La pausa \u00e8 necessaria per garantire che il flag di stallo del driver sia cancellata prima del homing. Un esempio di macro homing CoreXY potrebbe essere simile a: [gcode_macro HOME] gcode: G90 # Home Z G28 Z0 G1 Z10 F1200 # Home Y G28 Y0 G1 Y5 F1200 # Home X G4 P2000 G28 X0 G1 X5 F1200 Interrogazione e diagnosi delle impostazioni del driver \u00b6 Il comando DUMP_TMC \u00e8 uno strumento utile durante la configurazione e la diagnosi dei driver. Riporter\u00e0 tutti i campi configurati da Klipper cos\u00ec come tutti i campi che possono essere interrogati dal driver. Tutti i campi riportati sono definiti nella scheda tecnica Trinamic per ciascun driver. Queste schede tecniche possono essere trovate sul sito web Trinamic . Ottenere e rivedere i dati Trinamic affinch\u00e9 il conducente interpreti i risultati di DUMP_TMC. Configurazione delle impostazioni driver_XXX \u00b6 Klipper supporta la configurazione di molti campi driver di basso livello usando le impostazioni driver_XXX . Il Riferimento alla configurazione del driver TMC contiene l'elenco completo dei campi disponibili per ogni tipo di driver. Inoltre, quasi tutti i campi possono essere modificati in fase di esecuzione utilizzando il comando SET_TMC_FIELD . Ciascuno di questi campi \u00e8 definito nella scheda tecnica Trinamic per ciascun driver. Queste schede tecniche possono essere trovate sul sito web Trinamic . Si noti che i fogli dati Trinamic a volte utilizzano un'espressione che pu\u00f2 confondere un'impostazione di alto livello (come \"fine isteresi\") con un valore di campo di basso livello (ad esempio, \"HEND\"). In Klipper, driver_XXX e SET_TMC_FIELD impostano sempre il valore del campo di basso livello che viene effettivamente scritto nel driver. Quindi, ad esempio, se il foglio dati Trinamic afferma che \u00e8 necessario scrivere un valore di 3 nel campo HEND per ottenere una \"fine dell'isteresi\" di 0, impostare driver_HEND=3 per ottenere il valore di alto livello di 0. Domande comuni \u00b6 Posso usare la modalit\u00e0 StealthChop su un estrusore con anticipo della pressione? \u00b6 Molte persone usano con successo la modalit\u00e0 \"stealthChop\" con pressure advance di Klipper. Klipper implementa Smooth Pressure Advance che non introduce variazioni di velocit\u00e0 istantanee. Tuttavia, la modalit\u00e0 \"stealthChop\" pu\u00f2 produrre una coppia del motore inferiore e/o produrre un maggiore calore del motore. Potrebbe essere o meno una modalit\u00e0 adeguata per la tua particolare stampante. Continuo a ricevere gli errori \"Impossibile leggere tmc uart 'stepper_x' register IFCNT\"? \u00b6 Ci\u00f2 si verifica quando Klipper non \u00e8 in grado di comunicare con un driver tmc2208 o tmc2209. Assicurarsi che l'alimentazione del motore sia abilitata, poich\u00e9 il driver del motore passo-passo generalmente necessita dell'alimentazione del motore prima di poter comunicare con il microcontrollore. Se questo errore si verifica dopo aver eseguito il flashing di Klipper per la prima volta, \u00e8 possibile che il driver stepper sia stato precedentemente programmato in uno stato non compatibile con Klipper. Per ripristinare lo stato, rimuovere tutta l'alimentazione dalla stampante per alcuni secondi (scollegare fisicamente sia USB che le spine di alimentazione). In caso contrario, questo errore \u00e8 in genere il risultato di un cablaggio errato del pin UART o di una configurazione Klipper errata delle impostazioni del pin UART. Continuo a ricevere errori \"Unable to write tmc spi 'stepper_x' register ...\"? \u00b6 Ci\u00f2 si verifica quando Klipper non \u00e8 in grado di comunicare con un driver tmc2130 o tmc5160. Assicurarsi che l'alimentazione del motore sia abilitata, poich\u00e9 il driver del motore passo-passo generalmente necessita dell'alimentazione del motore prima di poter comunicare con il microcontrollore. In caso contrario, questo errore \u00e8 in genere il risultato di un cablaggio SPI errato, una configurazione Klipper errata delle impostazioni SPI o una configurazione incompleta dei dispositivi su un bus SPI. Nota che se il driver si trova su un bus SPI condiviso con pi\u00f9 dispositivi, assicurati di configurare completamente ogni dispositivo su quel bus SPI condiviso in Klipper. Se un dispositivo su un bus SPI condiviso non \u00e8 configurato, potrebbe rispondere in modo errato a comandi non previsti e danneggiare la comunicazione con il dispositivo previsto. Se \u00e8 presente un dispositivo su un bus SPI condiviso che non pu\u00f2 essere configurato in Klipper, utilizzare una sezione di configurazione static_digital_output per impostare il pin CS del dispositivo inutilizzato alto (in modo che non tenti utilizzare il bus SPI). Lo schema della scheda \u00e8 spesso un utile riferimento per trovare quali dispositivi si trovano su un bus SPI e i pin associati. Perch\u00e9 ho ricevuto un errore \"TMC reports error: ...\"? \u00b6 Questo tipo di errore indica che il driver TMC ha rilevato un problema e si \u00e8 disabilitato. Cio\u00e8, il conducente ha smesso di mantenere la sua posizione e ha ignorato i comandi di movimento. Se Klipper rileva che un driver attivo si \u00e8 disabilitato, la stampante passer\u00e0 allo stato di \"spegnimento\". \u00c8 anche possibile che si verifichi un arresto TMC segnala errore a causa di errori SPI che impediscono la comunicazione con il driver (su tmc2130, tmc5160 o tmc2660). Se ci\u00f2 si verifica, \u00e8 normale che lo stato del driver riportato mostri 00000000 o ffffffff , ad esempio: TMC reports error: DRV_STATUS: ffffffff ... O TMC reports error: READRSP@RDSEL2: 00000000 ... . Tale errore pu\u00f2 essere dovuto a un problema di cablaggio SPI o pu\u00f2 essere dovuto a un ripristino automatico o a un guasto del driver TMC. Alcuni errori comuni e suggerimenti per diagnosticarli: TMC segnala l'errore: ... ot=1(OvertempError!) \u00b6 Ci\u00f2 indica che il driver del motore si \u00e8 disabilitato perch\u00e9 \u00e8 diventato troppo caldo. Le soluzioni tipiche consistono nel ridurre la corrente del motore passo-passo, aumentare il raffreddamento sul driver del motore passo-passo e/o aumentare il raffreddamento sul motore passo-passo. TMC segnala l'errore: ... ShortToGND O ShortToSupply \u00b6 Ci\u00f2 indica che il driver si \u00e8 disabilitato perch\u00e9 ha rilevato una corrente molto elevata che passa attraverso il driver. Ci\u00f2 potrebbe indicare un filo allentato o in cortocircuito al motore passo-passo o all'interno del motore passo-passo stesso. Questo errore pu\u00f2 verificarsi anche se si utilizza la modalit\u00e0 StealthChop e il driver TMC non \u00e8 in grado di prevedere con precisione il carico meccanico del motore. (Se il driver fa una previsione scadente, potrebbe inviare troppa corrente attraverso il motore e attivare il proprio rilevamento di sovracorrente.) Per verificarlo, disabilitare la modalit\u00e0 StealthChop e verificare se gli errori continuano a verificarsi. TMC segnala un errore: ... reset=1(Reset) OR CS_ACTUAL=0(Reset?) OR SE=0(Reset?) \u00b6 Ci\u00f2 indica che il driver si \u00e8 ripristinato durante la stampa. Ci\u00f2 potrebbe essere dovuto a problemi di tensione o cablaggio. TMC segnala l'errore: ... uv_cp=1(Undervoltage!) \u00b6 Ci\u00f2 indica che il driver ha rilevato un evento di bassa tensione e si \u00e8 disabilitato. Ci\u00f2 potrebbe essere dovuto a problemi di cablaggio o alimentazione. Come si regola la modalit\u00e0 spreadCycle/coolStep/etc. sui miei driver? \u00b6 Il sito web Trinamic contiene guide sulla configurazione dei driver. Queste guide sono spesso tecniche, di basso livello e potrebbero richiedere hardware specializzato. In ogni caso, sono la migliore fonte di informazioni.","title":"Driver TMC"},{"location":"TMC_Drivers.html#driver-tmc","text":"Questo documento fornisce informazioni sull'utilizzo dei driver Trinamic per motori stepper in modalit\u00e0 SPI/UART su Klipper. Klipper pu\u00f2 anche utilizzare i driver Trinamic nella loro \"modalit\u00e0 standalone\". Tuttavia, quando i driver sono in questa modalit\u00e0, non \u00e8 necessaria alcuna configurazione speciale di Klipper e le funzionalit\u00e0 avanzate di Klipper discusse in questo documento non sono disponibili. Oltre a questo documento, assicurati di rivedere il riferimento alla configurazione del driver TMC .","title":"Driver TMC"},{"location":"TMC_Drivers.html#regolazione-della-corrente-del-motore","text":"Una corrente pi\u00f9 alta del driver aumenta la precisione del posizionamento e la coppia. Tuttavia, una corrente pi\u00f9 elevata aumenta anche il calore prodotto dal motore passo-passo e dal driver del motore passo-passo. Se il driver del motore passo-passo si surriscalda, si disabiliter\u00e0 e Klipper segnaler\u00e0 un errore. Se il motore passo-passo si surriscalda, perde coppia e precisione di posizionamento. (Se diventa molto caldo, potrebbe anche fondere le parti di plastica attaccate o vicino ad esso.) Come consiglio generale per l'ottimizzazione, preferire valori di corrente pi\u00f9 elevati purch\u00e9 il motore passo-passo non si surriscaldi troppo e il driver del motore passo-passo non segnali avvisi o errori. In generale, va bene che il motore passo-passo sia caldo, ma non dovrebbe diventare cos\u00ec caldo da risultare doloroso al tatto.","title":"Regolazione della corrente del motore"},{"location":"TMC_Drivers.html#preferibilmente-non-specificare-un-hold_current","text":"Se si configura un hold_current , il driver TMC pu\u00f2 ridurre la corrente al motore passo-passo quando rileva che il passo-passo non si sta muovendo. Tuttavia, la variazione della corrente del motore pu\u00f2 di per s\u00e9 introdurre il movimento del motore. Ci\u00f2 pu\u00f2 verificarsi a causa di \"forze di arresto\" all'interno del motore passo-passo (il magnete permanente nel rotore tira verso i denti di ferro nello statore) o a causa di forze esterne sul carrello dell'asse. La maggior parte dei motori passo-passo non otterr\u00e0 un beneficio significativo dalla riduzione della corrente durante le normali stampe, perch\u00e9 pochi movimenti di stampa lasceranno un motore passo-passo inattivo per un tempo sufficientemente lungo da attivare la funzione hold_current . Ed \u00e8 improbabile che si vogliano introdurre sottili artefatti di stampa nelle poche mosse di stampa che lasciano uno stepper inattivo sufficientemente a lungo. Se si desidera ridurre la corrente ai motori durante le routine di avvio della stampa, considerare l'emissione di comandi SET_TMC_CURRENT in una START_PRINT macro per regolare la corrente prima e dopo i normali spostamenti di stampa. Alcune stampanti con motori Z dedicati che sono inattivi durante i normali movimenti di stampa (nessuna bed_mesho, nessuna inclinazione_piatto, nessuna correzione_inclinazione Z, nessuna stampa in \"modalit\u00e0 vaso\", ecc.) potrebbero scoprire che i motori Z funzionano a temperature pi\u00f9 basse con un hold_current . Se si implementa questo, assicurarsi di prendere in considerazione questo tipo di movimento dell'asse Z non comandato durante il livellamento del piatto, il rilevamento del piatto, la calibrazione della sonda e simili. Anche driver_TPOWERDOWN e driver_IHOLDDELAY dovrebbero essere calibrati di conseguenza. Se non sei sicuro, preferisci non specificare un hold_current .","title":"Preferibilmente non specificare un hold_current"},{"location":"TMC_Drivers.html#impostazione-della-modalita-spreadcycle-rispetto-a-stealthchop","text":"Per impostazione predefinita, Klipper mette i driver TMC in modalit\u00e0 \"spreadCycle\". Se il driver supporta \"stealthChop\", pu\u00f2 essere abilitato aggiungendo stealthchop_threshold: 999999 alla sezione di configurazione di TMC. In generale, la modalit\u00e0 SpreadCycle fornisce una coppia maggiore e una maggiore precisione di posizionamento rispetto alla modalit\u00e0 StealthChop. Tuttavia, la modalit\u00e0 StealthChop pu\u00f2 produrre un rumore udibile notevolmente inferiore su alcune stampanti. I test di confronto delle modalit\u00e0 hanno mostrato un \"ritardo posizionale\" aumentato di circa il 75% di un passo completo durante i movimenti a velocit\u00e0 costante quando si utilizza la modalit\u00e0 StealthChop (ad esempio, su una stampante con distanza_rotazione di 40 mm e 200 passi_per_rotazione, la deviazione di posizione dei movimenti a velocit\u00e0 costante \u00e8 aumentata di ~0,150 mm). Tuttavia, questo \"ritardo nell'ottenimento della posizione richiesta\" potrebbe non manifestarsi come un difetto di stampa significativo e si potrebbe preferire il comportamento pi\u00f9 silenzioso della modalit\u00e0 stealthChop. Si consiglia di utilizzare sempre la modalit\u00e0 \"spreadCycle\" (non specificando stealthchop_threshold ) o di utilizzare sempre la modalit\u00e0 \"stealthChop\" (impostando stealthchop_threshold su 999999). Sfortunatamente, i driver spesso producono risultati scadenti e confusi se la modalit\u00e0 cambia mentre il motore \u00e8 a una velocit\u00e0 diversa da zero.","title":"Impostazione della modalit\u00e0 \"spreadCycle\" rispetto a \"stealthChop\""},{"location":"TMC_Drivers.html#limpostazione-dellinterpolazione-tmc-introduce-una-piccola-deviazione-di-posizione","text":"L'impostazione interpolate del driver TMC pu\u00f2 ridurre il rumore udibile del movimento della stampante a costo di introdurre un piccolo errore di posizione sistemico. Questo errore di posizione sistematico deriva dal ritardo del driver nell'esecuzione dei \"passi\" inviati da Klipper. Durante i movimenti a velocit\u00e0 costante, questo ritardo si traduce in un errore di posizione di quasi mezzo micropasso configurato (pi\u00f9 precisamente, l'errore \u00e8 di mezzo micropasso meno un 512esimo di un passo intero). Ad esempio, su un asse con una distanza_rotazione di 40 mm, 200 passi_per_rotazione e 16 micropassi, l'errore sistemico introdotto durante i movimenti a velocit\u00e0 costante \u00e8 ~0,006 mm. Per una migliore precisione di posizionamento, considerare l'utilizzo della modalit\u00e0 SpreadCycle e disabilitare l'interpolazione (impostare interpolate: False nella configurazione del driver TMC). Se configurato in questo modo, \u00e8 possibile aumentare l'impostazione microstep per ridurre il rumore udibile durante il movimento del passo-passo. Tipicamente, un'impostazione microstep di 64 o 128 avr\u00e0 un rumore udibile simile all'interpolazione e lo far\u00e0 senza introdurre un errore posizionale sistemico. Se si utilizza la modalit\u00e0 StealthChop, l'imprecisione posizionale dell'interpolazione \u00e8 piccola rispetto all'imprecisione posizionale introdotta dalla modalit\u00e0 StealthChop. Pertanto l'interpolazione dell'ottimizzazione non \u00e8 considerata utile in modalit\u00e0 StealthChop e si pu\u00f2 lasciare l'interpolazione nel suo stato predefinito.","title":"L'impostazione dell'interpolazione TMC introduce una piccola deviazione di posizione"},{"location":"TMC_Drivers.html#homing-sensorless","text":"L'homing senza sensori consente di posizionare un asse senza la necessit\u00e0 di un finecorsa fisico. Invece, il carrello sull'asse viene spostato nel finecorsa meccanico facendo perdere passi al motore passo-passo. Il driver stepper rileva i passi persi e lo indica all'MCU di controllo (Klipper) attivando un pin. Queste informazioni possono essere utilizzate da Klipper come fine corsa per l'asse. Questa guida illustra l'impostazione dell'homing sensorless per l'asse X della stampante (cartesiana). Tuttavia, funziona allo stesso modo con tutti gli altri assi (che richiedono un fine corsa). Dovresti configurarlo e sintonizzarlo per un asse alla volta.","title":"Homing Sensorless"},{"location":"TMC_Drivers.html#limitazioni","text":"Assicurati che i tuoi componenti meccanici siano in grado di sopportare il carico del carrello che urta ripetutamente il limite dell'asse. Soprattutto le viti di comando potrebbero generare molta forza. L'homing di un asse Z facendo urtare l'ugello sulla superficie di stampa potrebbe non essere una buona idea. Per ottenere i migliori risultati, verificare che il carrello dell'asse stabilisca un contatto stabile con il limite dell'asse. Inoltre, l'homing sensorless potrebbe non essere sufficientemente preciso per la tua stampante. Sebbene l'homing degli assi X e Y su una macchina cartesiana possa funzionare bene, l'homing dell'asse Z in genere non \u00e8 sufficientemente preciso e pu\u00f2 comportare un'altezza del primo strato incoerente. L'homing di una stampante delta sensorless non \u00e8 consigliabile a causa della mancanza di precisione. Inoltre, il rilevamento dello stallo del driver passo-passo dipende dal carico meccanico sul motore, dalla corrente del motore e dalla temperatura del motore (resistenza della bobina). L'homing sensorless funziona meglio a velocit\u00e0 medie del motore. Per velocit\u00e0 molto basse (inferiori a 10 giri/min) il motore non genera una significativa EMF di ritorno e il TMC non \u00e8 in grado di rilevare in modo affidabile gli stalli del motore. Inoltre, a velocit\u00e0 molto elevate, l'EMF di ritorno del motore si avvicina alla tensione di alimentazione del motore, quindi il TMC non \u00e8 pi\u00f9 in grado di rilevare gli stalli. Si consiglia di dare un'occhiata alla scheda tecnica del proprio TMC specifico. L\u00ec puoi anche trovare maggiori dettagli sulle limitazioni di questa configurazione.","title":"Limitazioni"},{"location":"TMC_Drivers.html#prerequisiti","text":"Sono necessari alcuni prerequisiti per utilizzare l'homing sensorless: Driver passo-passo TMC compatibile con stallGuard (tmc2130, tmc2209, tmc2660 o tmc5160). Interfaccia SPI/UART del driver TMC cablata al microcontrollore (la modalit\u00e0 stand-alone non funziona). Il pin \"DIAG\" o \"SG_TST\" appropriato del driver TMC collegato al microcontrollore. I passaggi nel documento config checks devono essere eseguiti per confermare che i motori passo-passo siano configurati e funzionino correttamente.","title":"Prerequisiti"},{"location":"TMC_Drivers.html#messa-a-punto","text":"La procedura qui descritta prevede sei passaggi principali: Scegli una velocit\u00e0 di homing. Configura il file printer.cfg per abilitare l'homing sensorless. Trova l'impostazione stallguard con la massima sensibilit\u00e0 che funziona con successo. Trova l'impostazione stallguard con la sensibilit\u00e0 pi\u00f9 bassa che effettua homing con successo con un solo tocco. Aggiorna il printer.cfg con l'impostazione di stallguard desiderata. Crea o aggiorna le macro printer.cfg per homing in modo coerente.","title":"Messa a punto"},{"location":"TMC_Drivers.html#scegli-la-velocita-di-homing","text":"La velocit\u00e0 di homing \u00e8 una scelta importante quando si esegue l'homing senza sensori. \u00c8 consigliabile utilizzare una velocit\u00e0 di riferimento bassa in modo che il carrello non eserciti una forza eccessiva sul telaio quando entra in contatto con l'estremit\u00e0 della rotaia. Tuttavia, i driver TMC non sono in grado di rilevare in modo affidabile uno stallo a velocit\u00e0 molto basse. Un buon punto di partenza per la velocit\u00e0 di homing \u00e8 che il motore passo-passo esegua una rotazione completa ogni due secondi. Per molti assi questa sar\u00e0 la rotation_distance divisa per due. Per esempio: [stepper_x] rotation_distance: 40 homing_speed: 20 ...","title":"Scegli la velocit\u00e0 di homing"},{"location":"TMC_Drivers.html#configura-printercfg-per-lhoming-sensorless","text":"L'impostazione homing_retract_dist deve essere impostata su zero nella sezione di configurazione stepper_x per disabilitare il secondo movimento di homing. Il secondo tentativo di homing non aggiunge valore quando si utilizza l'homing sensorless, non funzioner\u00e0 in modo affidabile e confonder\u00e0 il processo di ottimizzazione. Assicurati che un'impostazione hold_current non sia specificata nella sezione del driver TMC del file config. (Se viene impostata una hold_current, dopo che \u00e8 stato stabilito il contatto, il motore si arresta mentre il carrello viene premuto contro l'estremit\u00e0 del binario e la riduzione della corrente mentre si trova in quella posizione pu\u00f2 causare il movimento del carrello, il che si traduce in prestazioni scadenti e confonde il processo di regolazione.) \u00c8 necessario configurare i pin di homing sensorless e configurare le impostazioni iniziali di \"stallguard\". Una configurazione di esempio tmc2209 per un asse X potrebbe essere simile a: [tmc2209 stepper_x] diag_pin: ^PA1 # Impostare sul pin MCU collegato al pin TMC DIAG driver_SGTHRS: 255 #255 \u00e8 il valore pi\u00f9 sensibile, 0 \u00e8 il meno sensibile ... [stepper_x] endstop_pin: tmc2209_stepper_x:virtual_endstop homing_retract_dist: 0 ... Un esempio di configurazione tmc2130 o tmc5160 potrebbe essere simile a: [tmc2130 stepper_x] diag1_pin: ^!PA1 # Pin collegato al pin TMC DIAG1 (o utilizzare pin diag0_pin / DIAG0) driver_SGT: -64 # -64 \u00e8 il valore pi\u00f9 sensibile, 63 \u00e8 il meno sensibile ... [stepper_x] endstop_pin: tmc2130_stepper_x:virtual_endstop homing_retract_dist: 0 ... Un esempio di configurazione di tmc2660 potrebbe essere simile a: [tmc2660 stepper_x] driver_SGT: -64 # -64 \u00e8 il valore pi\u00f9 sensibile, 63 \u00e8 il meno sensibile ... [stepper_x] endstop_pin: ^PA1 # Pin collegato al pin TMC SG_TST homing_retract_dist: 0 ... Gli esempi sopra mostrano solo le impostazioni specifiche per l'homing sensorless. Vedere il riferimento alla configurazione per tutte le opzioni disponibili.","title":"Configura printer.cfg per l'homing sensorless"},{"location":"TMC_Drivers.html#trova-la-massima-sensibilita-che-porta-a-homing-con-successo","text":"Posizionare il carrello vicino al centro del binario. Utilizzare il comando SET_TMC_FIELD per impostare la sensibilit\u00e0 pi\u00f9 alta. Per tmc2209: SET_TMC_FIELD STEPPER=stepper_x FIELD=SGTHRS VALUE=255 Per tmc2130, tmc5160 e tmc2660: SET_TMC_FIELD STEPPER=stepper_x FIELD=sgt VALUE=-64 Quindi inviare un comando G28 X0 e verificare che l'asse non si muova affatto o smetta rapidamente di muoversi. Se l'asse non si ferma, inviare un M112 per fermare la stampante - qualcosa non \u00e8 corretto con il cablaggio o la configurazione dei pin diag/sg_tst e deve essere corretto prima di continuare. Quindi, diminuire progressivamente la sensibilit\u00e0 dell'impostazione VALUE ed eseguire nuovamente i comandi SET_TMC_FIELD G28 X0 per trovare la sensibilit\u00e0 pi\u00f9 alta che fa s\u00ec che il carrello si muova con successo fino all'arresto e si arresti. (Per i driver tmc2209 questo diminuir\u00e0 SGTHRS, per altri conducenti aumenter\u00e0 il sgt.) Assicurati di iniziare ogni tentativo con il carrello vicino al centro del binario (se necessario, emetti M84 e quindi sposta manualmente il carrello sul centro). Dovrebbe essere possibile trovare la sensibilit\u00e0 pi\u00f9 alta che si adatta in modo affidabile (le impostazioni con una sensibilit\u00e0 pi\u00f9 alta comportano movimenti piccoli o nulli). Nota il valore trovato come sensibilit\u00e0_massima . (Se si ottiene la sensibilit\u00e0 minima possibile (SGTHRS=0 o sgt=63) senza alcun movimento del carrello, allora qualcosa non \u00e8 corretto con il cablaggio o la configurazione dei pin diag/sg_tst e deve essere corretto prima di continuare.) Quando si cerca la sensibilit\u00e0_massima, pu\u00f2 essere conveniente passare a diverse impostazioni VALUE (in modo da dividere in due il parametro VALUE). In tal caso, prepararsi a emettere un comando M112 per arrestare la stampante, poich\u00e9 un'impostazione con una sensibilit\u00e0 molto bassa potrebbe far \"sbattere\" ripetutamente l'asse contro l'estremit\u00e0 del binario. Assicurati di attendere un paio di secondi tra ogni tentativo di homing. Dopo che il driver TMC ha rilevato uno stallo, potrebbe volerci un po' di tempo per cancellare il suo indicatore interno ed essere in grado di rilevare un altro stallo. Durante questi test di ottimizzazione, se un comando G28 X0 non si sposta fino al limite dell'asse, prestare attenzione nell'emettere qualsiasi comando di movimento regolare (ad es. G1 ). Klipper non avr\u00e0 una corretta comprensione della posizione del carrello e un comando di spostamento potrebbe causare risultati indesiderati e confusi.","title":"Trova la massima sensibilit\u00e0 che porta a homing con successo"},{"location":"TMC_Drivers.html#trova-la-sensibilita-piu-bassa-che-porta-a-homing-con-un-solo-tocco","text":"Quando si effettua l'homing con il valore maximum_sensitivity trovato, l'asse dovrebbe spostarsi all'estremit\u00e0 del binario e fermarsi con un \"tocco singolo\", ovvero non dovrebbe esserci un \"clic\" o un \"sbattere\". (Se c'\u00e8 un suono che sbatte o scatta alla sensibilit\u00e0_massima, allora la velocit\u00e0 di riferimento potrebbe essere troppo bassa, la corrente del driver potrebbe essere troppo bassa o la corsa di riferimento senza sensore potrebbe non essere una buona scelta per l'asse.) Il passo successivo \u00e8 spostare di nuovo continuamente il carrello in una posizione vicino al centro della rotaia, diminuire la sensibilit\u00e0 ed eseguire i comandi SET_TMC_FIELD G28 X0 - l'obiettivo ora \u00e8 trovare la sensibilit\u00e0 pi\u00f9 bassa che risulti ancora nel la carrozza torna con successo al punto di riferimento con un \"tocco singolo\". Cio\u00e8, non \"sbatte\" o \"clic\" quando viene a contatto con l'estremit\u00e0 del binario. Nota il valore trovato come sensibilit\u00e0_minima .","title":"Trova la sensibilit\u00e0 pi\u00f9 bassa che porta a homing con un solo tocco"},{"location":"TMC_Drivers.html#aggiorna-printercfg-con-il-valore-della-sensibilita","text":"Dopo aver trovato sensibilit\u00e0_massima e sensibilit\u00e0_minima , utilizzare una calcolatrice per ottenere la sensibilit\u00e0 consigliata come sensibilit\u00e0_minima + (sensibilit\u00e0_massima - sensibilit\u00e0_minima)/3 . La sensibilit\u00e0 consigliata dovrebbe essere compresa tra il minimo e il massimo, ma leggermente pi\u00f9 vicino al minimo. Arrotonda il valore finale al valore intero pi\u00f9 vicino. Per tmc2209 impostalo nella configurazione come driver_SGTHRS , per altri driver TMC impostalo nella configurazione come driver_SGT . Se l'intervallo tra sensibilit\u00e0_massima e sensibilit\u00e0_minima \u00e8 piccolo (ad esempio, inferiore a 5), potrebbe risultare in un homing instabile. Una velocit\u00e0 di riferimento pi\u00f9 elevata pu\u00f2 aumentare il range e rendere l'operazione pi\u00f9 stabile. Si noti che se viene apportata una modifica alla corrente del driver, alla velocit\u00e0 di riferimento o viene apportata una modifica notevole all'hardware della stampante, sar\u00e0 necessario eseguire nuovamente il processo di ottimizzazione.","title":"Aggiorna printer.cfg con il valore della sensibilit\u00e0"},{"location":"TMC_Drivers.html#utilizzo-delle-macro-durante-lhoming","text":"Dopo aver completato l'homing senza sensori, il carrello verr\u00e0 premuto contro l'estremit\u00e0 del binario e lo stepper eserciter\u00e0 una forza sul telaio fino a quando il carrello non si allontana. \u00c8 una buona idea creare una macro per posizionare l'asse e allontanare immediatamente il carrello dall'estremit\u00e0 della rotaia. \u00c8 una buona idea che la macro si metta in pausa di almeno 2 secondi prima di iniziare l'homing sensorless (o altrimenti assicurarsi che non ci siano stati movimenti sullo stepper per 2 secondi). Senza ritardo \u00e8 possibile che il flag di stallo interno del driver sia ancora impostato da un movimento precedente. Pu\u00f2 anche essere utile fare in modo che quella macro imposti la corrente del driver prima della corsa di riferimento e imposti una nuova corrente dopo che il carrello si \u00e8 allontanato. Una macro di esempio potrebbe assomigliare a: [gcode_macro SENSORLESS_HOME_X] gcode: {% set HOME_CUR = 0.700 %} {% set driver_config = printer.configfile.settings['tmc2209 stepper_x'] %} {% set RUN_CUR = driver_config.run_current %} # Imposta la corrente per l'homing sensorless SET_TMC_CURRENT STEPPER=stepper_x CURRENT={HOME_CUR} # Fai una pausa per assicurarti che il flag di stallo del driver sia clear G4 P2000 # Home G28 X0 # Spostamento G90 G1 X5 F1200 # Imposta corrente durante la stampa SET_TMC_CURRENT STEPPER=stepper_x CURRENT={RUN_CUR} La macro risultante pu\u00f2 essere chiamata da una sezione di configurazione homing_override o da una START_PRINT macro . Si noti che se viene modificata la corrente del driver durante l'homing, il processo di ottimizzazione dovrebbe essere eseguito nuovamente.","title":"Utilizzo delle macro durante l'homing"},{"location":"TMC_Drivers.html#suggerimenti-per-lhoming-sensorless-su-corexy","text":"\u00c8 possibile utilizzare l'homing sensorless sui carrelli X e Y di una stampante CoreXY. Klipper usa lo stepper [stepper_x] per rilevare gli stalli durante l'homing del carrello X e usa lo stepper [stepper_y] per rilevare gli stalli durante l'homing del carrello Y. Utilizzare la guida alla messa a punto sopra descritta per trovare la \"sensibilit\u00e0 allo stallo\" appropriata per ciascun carrello, ma prestare attenzione alle seguenti restrizioni: Quando si utilizza l'homing sensorless su CoreXY, assicurarsi che non sia configurato hold_current per nessuno dei due stepper. Durante la messa a punto, assicurati che entrambi i carrelli X e Y siano vicini al centro dei loro binari prima di ogni tentativo di homing. Al termine dell'ottimizzazione, quando si esegue l'homing sia di X che Y, utilizzare le macro per assicurarsi che un asse sia homed per primo, quindi spostare il carrello lontano dal limite dell'asse, fare una pausa per almeno 2 secondi, quindi avviare l'orientamento dell'altro carrello. L'allontanamento dall'asse evita l'homing di un asse mentre l'altro viene premuto contro il limite dell'asse (cosa potrebbe distorcere il rilevamento dello stallo). La pausa \u00e8 necessaria per garantire che il flag di stallo del driver sia cancellata prima del homing. Un esempio di macro homing CoreXY potrebbe essere simile a: [gcode_macro HOME] gcode: G90 # Home Z G28 Z0 G1 Z10 F1200 # Home Y G28 Y0 G1 Y5 F1200 # Home X G4 P2000 G28 X0 G1 X5 F1200","title":"Suggerimenti per l'homing sensorless su CoreXY"},{"location":"TMC_Drivers.html#interrogazione-e-diagnosi-delle-impostazioni-del-driver","text":"Il comando DUMP_TMC \u00e8 uno strumento utile durante la configurazione e la diagnosi dei driver. Riporter\u00e0 tutti i campi configurati da Klipper cos\u00ec come tutti i campi che possono essere interrogati dal driver. Tutti i campi riportati sono definiti nella scheda tecnica Trinamic per ciascun driver. Queste schede tecniche possono essere trovate sul sito web Trinamic . Ottenere e rivedere i dati Trinamic affinch\u00e9 il conducente interpreti i risultati di DUMP_TMC.","title":"Interrogazione e diagnosi delle impostazioni del driver"},{"location":"TMC_Drivers.html#configurazione-delle-impostazioni-driver_xxx","text":"Klipper supporta la configurazione di molti campi driver di basso livello usando le impostazioni driver_XXX . Il Riferimento alla configurazione del driver TMC contiene l'elenco completo dei campi disponibili per ogni tipo di driver. Inoltre, quasi tutti i campi possono essere modificati in fase di esecuzione utilizzando il comando SET_TMC_FIELD . Ciascuno di questi campi \u00e8 definito nella scheda tecnica Trinamic per ciascun driver. Queste schede tecniche possono essere trovate sul sito web Trinamic . Si noti che i fogli dati Trinamic a volte utilizzano un'espressione che pu\u00f2 confondere un'impostazione di alto livello (come \"fine isteresi\") con un valore di campo di basso livello (ad esempio, \"HEND\"). In Klipper, driver_XXX e SET_TMC_FIELD impostano sempre il valore del campo di basso livello che viene effettivamente scritto nel driver. Quindi, ad esempio, se il foglio dati Trinamic afferma che \u00e8 necessario scrivere un valore di 3 nel campo HEND per ottenere una \"fine dell'isteresi\" di 0, impostare driver_HEND=3 per ottenere il valore di alto livello di 0.","title":"Configurazione delle impostazioni driver_XXX"},{"location":"TMC_Drivers.html#domande-comuni","text":"","title":"Domande comuni"},{"location":"TMC_Drivers.html#posso-usare-la-modalita-stealthchop-su-un-estrusore-con-anticipo-della-pressione","text":"Molte persone usano con successo la modalit\u00e0 \"stealthChop\" con pressure advance di Klipper. Klipper implementa Smooth Pressure Advance che non introduce variazioni di velocit\u00e0 istantanee. Tuttavia, la modalit\u00e0 \"stealthChop\" pu\u00f2 produrre una coppia del motore inferiore e/o produrre un maggiore calore del motore. Potrebbe essere o meno una modalit\u00e0 adeguata per la tua particolare stampante.","title":"Posso usare la modalit\u00e0 StealthChop su un estrusore con anticipo della pressione?"},{"location":"TMC_Drivers.html#continuo-a-ricevere-gli-errori-impossibile-leggere-tmc-uart-stepper_x-register-ifcnt","text":"Ci\u00f2 si verifica quando Klipper non \u00e8 in grado di comunicare con un driver tmc2208 o tmc2209. Assicurarsi che l'alimentazione del motore sia abilitata, poich\u00e9 il driver del motore passo-passo generalmente necessita dell'alimentazione del motore prima di poter comunicare con il microcontrollore. Se questo errore si verifica dopo aver eseguito il flashing di Klipper per la prima volta, \u00e8 possibile che il driver stepper sia stato precedentemente programmato in uno stato non compatibile con Klipper. Per ripristinare lo stato, rimuovere tutta l'alimentazione dalla stampante per alcuni secondi (scollegare fisicamente sia USB che le spine di alimentazione). In caso contrario, questo errore \u00e8 in genere il risultato di un cablaggio errato del pin UART o di una configurazione Klipper errata delle impostazioni del pin UART.","title":"Continuo a ricevere gli errori \"Impossibile leggere tmc uart 'stepper_x' register IFCNT\"?"},{"location":"TMC_Drivers.html#continuo-a-ricevere-errori-unable-to-write-tmc-spi-stepper_x-register","text":"Ci\u00f2 si verifica quando Klipper non \u00e8 in grado di comunicare con un driver tmc2130 o tmc5160. Assicurarsi che l'alimentazione del motore sia abilitata, poich\u00e9 il driver del motore passo-passo generalmente necessita dell'alimentazione del motore prima di poter comunicare con il microcontrollore. In caso contrario, questo errore \u00e8 in genere il risultato di un cablaggio SPI errato, una configurazione Klipper errata delle impostazioni SPI o una configurazione incompleta dei dispositivi su un bus SPI. Nota che se il driver si trova su un bus SPI condiviso con pi\u00f9 dispositivi, assicurati di configurare completamente ogni dispositivo su quel bus SPI condiviso in Klipper. Se un dispositivo su un bus SPI condiviso non \u00e8 configurato, potrebbe rispondere in modo errato a comandi non previsti e danneggiare la comunicazione con il dispositivo previsto. Se \u00e8 presente un dispositivo su un bus SPI condiviso che non pu\u00f2 essere configurato in Klipper, utilizzare una sezione di configurazione static_digital_output per impostare il pin CS del dispositivo inutilizzato alto (in modo che non tenti utilizzare il bus SPI). Lo schema della scheda \u00e8 spesso un utile riferimento per trovare quali dispositivi si trovano su un bus SPI e i pin associati.","title":"Continuo a ricevere errori \"Unable to write tmc spi 'stepper_x' register ...\"?"},{"location":"TMC_Drivers.html#perche-ho-ricevuto-un-errore-tmc-reports-error","text":"Questo tipo di errore indica che il driver TMC ha rilevato un problema e si \u00e8 disabilitato. Cio\u00e8, il conducente ha smesso di mantenere la sua posizione e ha ignorato i comandi di movimento. Se Klipper rileva che un driver attivo si \u00e8 disabilitato, la stampante passer\u00e0 allo stato di \"spegnimento\". \u00c8 anche possibile che si verifichi un arresto TMC segnala errore a causa di errori SPI che impediscono la comunicazione con il driver (su tmc2130, tmc5160 o tmc2660). Se ci\u00f2 si verifica, \u00e8 normale che lo stato del driver riportato mostri 00000000 o ffffffff , ad esempio: TMC reports error: DRV_STATUS: ffffffff ... O TMC reports error: READRSP@RDSEL2: 00000000 ... . Tale errore pu\u00f2 essere dovuto a un problema di cablaggio SPI o pu\u00f2 essere dovuto a un ripristino automatico o a un guasto del driver TMC. Alcuni errori comuni e suggerimenti per diagnosticarli:","title":"Perch\u00e9 ho ricevuto un errore \"TMC reports error: ...\"?"},{"location":"TMC_Drivers.html#tmc-segnala-lerrore-ot1overtemperror","text":"Ci\u00f2 indica che il driver del motore si \u00e8 disabilitato perch\u00e9 \u00e8 diventato troppo caldo. Le soluzioni tipiche consistono nel ridurre la corrente del motore passo-passo, aumentare il raffreddamento sul driver del motore passo-passo e/o aumentare il raffreddamento sul motore passo-passo.","title":"TMC segnala l'errore: ... ot=1(OvertempError!)"},{"location":"TMC_Drivers.html#tmc-segnala-lerrore-shorttognd-o-shorttosupply","text":"Ci\u00f2 indica che il driver si \u00e8 disabilitato perch\u00e9 ha rilevato una corrente molto elevata che passa attraverso il driver. Ci\u00f2 potrebbe indicare un filo allentato o in cortocircuito al motore passo-passo o all'interno del motore passo-passo stesso. Questo errore pu\u00f2 verificarsi anche se si utilizza la modalit\u00e0 StealthChop e il driver TMC non \u00e8 in grado di prevedere con precisione il carico meccanico del motore. (Se il driver fa una previsione scadente, potrebbe inviare troppa corrente attraverso il motore e attivare il proprio rilevamento di sovracorrente.) Per verificarlo, disabilitare la modalit\u00e0 StealthChop e verificare se gli errori continuano a verificarsi.","title":"TMC segnala l'errore: ... ShortToGND O ShortToSupply"},{"location":"TMC_Drivers.html#tmc-segnala-un-errore-reset1reset-or-cs_actual0reset-or-se0reset","text":"Ci\u00f2 indica che il driver si \u00e8 ripristinato durante la stampa. Ci\u00f2 potrebbe essere dovuto a problemi di tensione o cablaggio.","title":"TMC segnala un errore: ... reset=1(Reset) OR CS_ACTUAL=0(Reset?) OR SE=0(Reset?)"},{"location":"TMC_Drivers.html#tmc-segnala-lerrore-uv_cp1undervoltage","text":"Ci\u00f2 indica che il driver ha rilevato un evento di bassa tensione e si \u00e8 disabilitato. Ci\u00f2 potrebbe essere dovuto a problemi di cablaggio o alimentazione.","title":"TMC segnala l'errore: ... uv_cp=1(Undervoltage!)"},{"location":"TMC_Drivers.html#come-si-regola-la-modalita-spreadcyclecoolstepetc-sui-miei-driver","text":"Il sito web Trinamic contiene guide sulla configurazione dei driver. Queste guide sono spesso tecniche, di basso livello e potrebbero richiedere hardware specializzato. In ogni caso, sono la migliore fonte di informazioni.","title":"Come si regola la modalit\u00e0 spreadCycle/coolStep/etc. sui miei driver?"},{"location":"TSL1401CL_Filament_Width_Sensor.html","text":"Sensore TSL1401CL di larghezza del filamento \u00b6 Questo documento descrive il modulo host del sensore di larghezza del filamento (Filament Width Sensor). L'hardware utilizzato per lo sviluppo di questo modulo host si basa sull'array di sensori lineari TSL1401CL, ma pu\u00f2 funzionare con qualsiasi array di sensori dotato di uscita analogica. Puoi trovare design su Thingiverse . Per utilizzare un array di sensori come sensore di larghezza del filamento, leggere Config Reference e G-Code documentation . Come funziona? \u00b6 Il sensore genera un'uscita analogica in base alla larghezza calcolata del filamento. La tensione di uscita \u00e8 sempre uguale alla larghezza del filamento rilevata (es. 1.65v, 1.70v, 3.0v). Il modulo host monitora le variazioni di tensione e regola il moltiplicatore di estrusione. Note: \u00b6 Letture del sensore eseguite con intervalli di 10 mm predefiniti Se necessario, sei libero di modificare questa impostazione modificando il parametro MEASUREMENT_INTERVAL_MM nel file filament_width_sensor.py .","title":"Sensore TSL1401CL di larghezza del filamento"},{"location":"TSL1401CL_Filament_Width_Sensor.html#sensore-tsl1401cl-di-larghezza-del-filamento","text":"Questo documento descrive il modulo host del sensore di larghezza del filamento (Filament Width Sensor). L'hardware utilizzato per lo sviluppo di questo modulo host si basa sull'array di sensori lineari TSL1401CL, ma pu\u00f2 funzionare con qualsiasi array di sensori dotato di uscita analogica. Puoi trovare design su Thingiverse . Per utilizzare un array di sensori come sensore di larghezza del filamento, leggere Config Reference e G-Code documentation .","title":"Sensore TSL1401CL di larghezza del filamento"},{"location":"TSL1401CL_Filament_Width_Sensor.html#come-funziona","text":"Il sensore genera un'uscita analogica in base alla larghezza calcolata del filamento. La tensione di uscita \u00e8 sempre uguale alla larghezza del filamento rilevata (es. 1.65v, 1.70v, 3.0v). Il modulo host monitora le variazioni di tensione e regola il moltiplicatore di estrusione.","title":"Come funziona?"},{"location":"TSL1401CL_Filament_Width_Sensor.html#note","text":"Letture del sensore eseguite con intervalli di 10 mm predefiniti Se necessario, sei libero di modificare questa impostazione modificando il parametro MEASUREMENT_INTERVAL_MM nel file filament_width_sensor.py .","title":"Note:"},{"location":"Using_PWM_Tools.html","text":"Utilizzo dei strumenti PWM \u00b6 Questo documento descrive come impostare un laser o un mandrino controllato da PWM usando output_pin e alcune macro. Come funziona? \u00b6 Riutilizzando l'output pwm della ventola della testina di stampa, \u00e8 possibile controllare laser o mandrini. Ci\u00f2 \u00e8 utile se si utilizzano testine di stampa intercambiabili, ad esempio il cambio utensile E3D o una soluzione fai-da-te. Di solito, gli strumenti cam come LaserWeb possono essere configurati per utilizzare i comandi M3-M5 , che stanno per velocit\u00e0 mandrino CW ( M3 S[0-255] ), velocit\u00e0 mandrino CCW ( M4 S[ 0-255] ) e arresto mandrino ( M5 ). Attenzione: Quando utilizzi un laser, mantieni tutte le precauzioni di sicurezza che ti vengono in mente! I laser a diodi sono generalmente invertiti. Ci\u00f2 significa che quando l'MCU si riavvia, il laser sar\u00e0 completamente acceso per il tempo necessario al riavvio dell'MCU. Per buona misura, si raccomanda di indossare sempre occhiali laser appropriati della giusta lunghezza d'onda se il laser \u00e8 alimentato e per disconnettere il laser quando non \u00e8 necessario. Inoltre, dovresti configurare un timeout di sicurezza, in modo che quando l'host o l'MCU riscontrano un errore, lo strumento si arresti. Per un esempio di configurazione, vedere config/sample-pwm-tool.cfg . Limitazioni attuali \u00b6 Esiste una limitazione della frequenza degli aggiornamenti PWM. Pur essendo molto preciso, un aggiornamento PWM pu\u00f2 verificarsi solo ogni 0,1 secondi, rendendolo quasi inutile per l'incisione raster. Tuttavia, esiste un ramo sperimentale con i propri compromessi. A lungo termine, si prevede di aggiungere questa funzionalit\u00e0 al klipper principale. Comandi \u00b6 M3/M4 S<value> : Imposta il duty-cycle PWM. Valori compresi tra 0 e 255. M5 : Arresta l'uscita PWM al valore di spegnimento. Configurazione Laserweb \u00b6 Se utilizzi Laserweb, una configurazione funzionante sarebbe: GCODE START: M5 ; Disabilita Laser G21 ; Set units to mm G90 ; Absolute positioning G0 Z0 F7000 ; Set Non-Cutting speed GCODE END: M5 ; Disabilita Laser G91 ; relative G0 Z+20 F4000 ; G90 ; absolute GCODE HOMING: M5 ; Disabilita Laser G28 ; Home all axis TOOL ON: M3 $INTENSITY TOOL OFF: M5 ; Disabilita Laser LASER INTENSITY: S","title":"Utilizzo dei strumenti PWM"},{"location":"Using_PWM_Tools.html#utilizzo-dei-strumenti-pwm","text":"Questo documento descrive come impostare un laser o un mandrino controllato da PWM usando output_pin e alcune macro.","title":"Utilizzo dei strumenti PWM"},{"location":"Using_PWM_Tools.html#come-funziona","text":"Riutilizzando l'output pwm della ventola della testina di stampa, \u00e8 possibile controllare laser o mandrini. Ci\u00f2 \u00e8 utile se si utilizzano testine di stampa intercambiabili, ad esempio il cambio utensile E3D o una soluzione fai-da-te. Di solito, gli strumenti cam come LaserWeb possono essere configurati per utilizzare i comandi M3-M5 , che stanno per velocit\u00e0 mandrino CW ( M3 S[0-255] ), velocit\u00e0 mandrino CCW ( M4 S[ 0-255] ) e arresto mandrino ( M5 ). Attenzione: Quando utilizzi un laser, mantieni tutte le precauzioni di sicurezza che ti vengono in mente! I laser a diodi sono generalmente invertiti. Ci\u00f2 significa che quando l'MCU si riavvia, il laser sar\u00e0 completamente acceso per il tempo necessario al riavvio dell'MCU. Per buona misura, si raccomanda di indossare sempre occhiali laser appropriati della giusta lunghezza d'onda se il laser \u00e8 alimentato e per disconnettere il laser quando non \u00e8 necessario. Inoltre, dovresti configurare un timeout di sicurezza, in modo che quando l'host o l'MCU riscontrano un errore, lo strumento si arresti. Per un esempio di configurazione, vedere config/sample-pwm-tool.cfg .","title":"Come funziona?"},{"location":"Using_PWM_Tools.html#limitazioni-attuali","text":"Esiste una limitazione della frequenza degli aggiornamenti PWM. Pur essendo molto preciso, un aggiornamento PWM pu\u00f2 verificarsi solo ogni 0,1 secondi, rendendolo quasi inutile per l'incisione raster. Tuttavia, esiste un ramo sperimentale con i propri compromessi. A lungo termine, si prevede di aggiungere questa funzionalit\u00e0 al klipper principale.","title":"Limitazioni attuali"},{"location":"Using_PWM_Tools.html#comandi","text":"M3/M4 S<value> : Imposta il duty-cycle PWM. Valori compresi tra 0 e 255. M5 : Arresta l'uscita PWM al valore di spegnimento.","title":"Comandi"},{"location":"Using_PWM_Tools.html#configurazione-laserweb","text":"Se utilizzi Laserweb, una configurazione funzionante sarebbe: GCODE START: M5 ; Disabilita Laser G21 ; Set units to mm G90 ; Absolute positioning G0 Z0 F7000 ; Set Non-Cutting speed GCODE END: M5 ; Disabilita Laser G91 ; relative G0 Z+20 F4000 ; G90 ; absolute GCODE HOMING: M5 ; Disabilita Laser G28 ; Home all axis TOOL ON: M3 $INTENSITY TOOL OFF: M5 ; Disabilita Laser LASER INTENSITY: S","title":"Configurazione Laserweb"}]}