{"config":{"indexing":"full","lang":["fr"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Klipper est un microprogramme pour imprimante 3D. Il combine la puissance d'un ordinateur classique avec un ou plusieurs microcontr\u00f4leurs. Consultez le document Fonctionnalit\u00e9s pour plus d'informations sur les raisons pour lesquelles vous devriez utiliser Klipper. Pour commencer \u00e0 utiliser Klipper, commencez par effectuer l' installation . Klipper est un logiciel libre. Lisez la documentation ou consultez le code de Klipper sur github . Nous d\u00e9pendons du soutien g\u00e9n\u00e9reux de nos sponsors .","title":"Bienvenue"},{"location":"API_Server.html","text":"Serveur API \u00b6 Ce document d\u00e9crit l'Interface de Programmation d'Applications (API) de Klipper. Cette interface permet \u00e0 des applications externes d'interroger et de contr\u00f4ler Klipper. Activer le socket API \u00b6 Pour pouvoir utiliser les Serveur API, le logiciel h\u00f4te klippy.py doit \u00eatre d\u00e9marr\u00e9 avec le param\u00e8tre -a . Par exemple : ~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer.cfg -a /tmp/klippy_uds -l /tmp/klippy.log Cela force le logiciel h\u00f4te \u00e0 cr\u00e9er un socket de domaine Unix. Un client peut alors ouvrir une connexion sur ce socket et envoyer des commandes \u00e0 Klipper. Voir le projet Moonraker pour un outil populaire qui peut transf\u00e9rer les requ\u00eates HTTP vers le socket du serveur d'API de Klipper. Format de la demande \u00b6 Les messages envoy\u00e9s et re\u00e7us sur le socket sont des cha\u00eenes au format JSON et termin\u00e9es par le caract\u00e8re ASCII 0x03 : <json_object_1><0x03><json_object_2><0x03>... Klipper contiens un outil scripts/whconsole.py qui peut effectuer la mise en forme du message ci-dessus. Par exemple : ~/klipper/scripts/whconsole.py /tmp/klippy_uds Cet outil peut lire une s\u00e9rie de commandes JSON \u00e0 partir de l'entr\u00e9e standard stdin, les envoyer \u00e0 Klipper et afficher les r\u00e9sultats. Cet outil s'attend \u00e0 avoir une commande JSON par ligne et il ajoute automatiquement le terminateur 0x03 avant d'envoyer les requ\u00eates. (Le serveur d'API de Klipper ne attend pas un saut de ligne.) Protocole de l'API \u00b6 Le protocole de commande utilis\u00e9 sur le socket de communications est inspir\u00e9 par json-rpc . Une requ\u00eate pourrait ressembler \u00e0 \u00e7a : {\"id\": 123, \"method\": \"info\", \"params\": {}} et une r\u00e9ponse pourrait ressembler \u00e0 \u00e7a : {\"id\": 123, \"result\": {\"state_message\": \"Printer is ready\", \"klipper_path\": \"/home/pi/klipper\", \"config_file\": \"/home/pi/printer.cfg\", \"software_version\": \"v0.8.0-823-g883b1cb6\", \"hostname\": \"octopi\", \"cpu_info\": \"4 core ARMv7 Processor rev 4 (v7l)\", \"state\": \"ready\", \"python_path\": \"/home/pi/klippy-env/bin/python\", \"log_file\": \"/tmp/klippy.log\"}} Toutes les requ\u00eates doivent \u00eatre un dictionnaire JSON. (Ce document utilise le terme Python 'dictionary' pour d\u00e9crire un objet JSON - une affectation de paires Cl\u00e9/Valeur comprises en deux parenth\u00e8ses {} .) le dictionnaire de requ\u00eate doit contenir un param\u00e8tre \"m\u00e9thode\" disponible dans les \"points de terminaison\" de Klipper. Le dictionnaire de requ\u00eate peut contenir un param\u00e8tre \"params\" qui doit \u00eatre de type dictionnaire. Les \"params\" fournissent des informations de param\u00e8tre suppl\u00e9mentaires au \"endpoint\" Klipper qui traite la demande. Son contenu est sp\u00e9cifique au \"endpoint\". Le dictionnaire de requ\u00eate peut contenir un param\u00e8tre \"id\" qui peut \u00eatre de n'importe quel type JSON. Si \"id\" est pr\u00e9sent, alors Klipper r\u00e9pondra \u00e0 la demande avec une r\u00e9ponse contenant cet \"id\". Si \"id\" est omis (ou d\u00e9fini sur une valeur JSON \"null\"), Klipper ne fournira aucune r\u00e9ponse \u00e0 la requ\u00eate. Un message de r\u00e9ponse est un dictionnaire JSON contenant \"id\" et \"result\". Le \"r\u00e9sultat\" est toujours un dictionnaire - son contenu est sp\u00e9cifique au \"endpoint\" traitant la demande. Si le traitement d'un requ\u00eate est en erreur, le message de r\u00e9ponse contiendra un champ \"error\" au lieu de \"result\". Par exemple, la requ\u00eate : {\"id\": 123, \"method\": \"gcode/script\", \"params\": {\"script\": \"G1 X200\"}} pourrait retourner une erreur telle que :: {\"id\": 123, \"error\": {\"message\": \"Must home axis first: 200.000 0.000 0.000 [0.000]\", \"error\": \"WebRequestError\"}} Klipper traite toujours les demandes dans l'ordre de leur r\u00e9ception. Cependant, certaines requ\u00eates peuvent ne pas se terminer imm\u00e9diatement, ce qui peut entra\u00eener l'envoi de la r\u00e9ponse associ\u00e9e dans le d\u00e9sordre par rapport aux r\u00e9ponses d'autres requ\u00eates. Une requ\u00eate JSON ne suspend jamais le traitement des requ\u00eates JSON suivantes. Abonnements \u00b6 Certains \"endpoint\" de Klipper autorisent un \"abonnement\" pour de futurs messages asynchrone de mise \u00e0 jour. Par exemple : {\"id\": 123, \"method\": \"gcode/subscribe_output\", \"params\": {\"response_template\":{\"key\": 345}}} Peut r\u00e9pondre dans un premier temps : {\"id\": 123, \"result\": {}} et faire en sorte que Klipper envoie de futurs messages similaires \u00e0 : {\"params\": {\"response\": \"ok B:22.8 /0.0 T0:22.4 /0.0\"}, \"key\": 345} Une demande d'abonnement accepte un dictionnaire \"response_template\" dans le champ \"params\" de la demande. Ce dictionnaire \"response_template\" est utilis\u00e9 comme mod\u00e8le pour les futurs messages asynchrones - il peut contenir des paires cl\u00e9/valeur arbitraires. Lors de l'envoi de ces futurs messages asynchrones, Klipper ajoutera un champ \"params\" contenant un dictionnaire avec un contenu sp\u00e9cifique \"endpoint\" au mod\u00e8le de r\u00e9ponse, puis enverra ce mod\u00e8le. Si un champ \"response_template\" n'est pas fourni, il s'agit par d\u00e9faut d'un dictionnaire vide ( {} ). \"endpoints\" disponibles \u00b6 Par convention, les \"endpoints\" de Klipper sont de la forme <module_name>/<some_name> . Lors d'une demande \u00e0 un \"endpoint\", le nom complet doit \u00eatre d\u00e9fini dans le param\u00e8tre \"method\" du dictionnaire de requ\u00eate (par exemple, {\"method\"=\"gcode/restart\"} ). Info \u00b6 Le point de terminaison \"info\" est utilis\u00e9 pour obtenir des informations sur le syst\u00e8me et la version de Klipper. Il est \u00e9galement utilis\u00e9 pour fournir les informations de version du client \u00e0 Klipper. Par exemple : {\"id\": 123, \"method\": \"info\", \"params\": { \"client_info\": { \"version\": \"v1\"}}} S'il est pr\u00e9sent, le param\u00e8tre \"client_info\" doit \u00eatre un dictionnaire, mais ce dictionnaire peut avoir un contenu arbitraire. Les clients sont encourag\u00e9s \u00e0 fournir le nom du client et sa version logicielle lors de la premi\u00e8re connexion au serveur API Klipper. arr\u00eat d'urgence \u00b6 Le point de terminaison \"emergency_stop\" est utilis\u00e9 pour demander \u00e0 Klipper de passer \u00e0 un \u00e9tat \"shutdown\". Il se comporte de la m\u00eame mani\u00e8re que la commande G-Code M112 . Par exemple : {\"id\": 123, \"method\": \"emergency_stop\"} register_remote_method \u00b6 Ce point de terminaison permet aux clients d'enregistrer des m\u00e9thodes pouvant \u00eatre appel\u00e9es depuis klipper. Il renverra un objet vide en cas de succ\u00e8s. Par exemple : {\"id\": 123, \"method\": \"register_remote_method\", \"params\": {\"response_template\": {\"action\": \"run_paneldue_beep\"}, \"remote_method\": \"paneldue_beep\"}} renverra : }` La m\u00e9thode distante paneldue_beep peut d\u00e9sormais \u00eatre appel\u00e9e depuis Klipper. Notez que si la m\u00e9thode prend des param\u00e8tres, ils doivent \u00eatre fournis en tant qu'arguments de mots cl\u00e9s. Voici un exemple de la fa\u00e7on dont il peut \u00eatre appel\u00e9 \u00e0 partir d'un gcode_macro : [gcode_macro PANELDUE_BEEP] gcode: {action_call_remote_method(\"paneldue_beep\", frequency=300, duration=1.0)} Lorsque la macro gcode PANELDUE_BEEP est ex\u00e9cut\u00e9e, Klipper enverra ce qui suit sur le socket : {\"action\": \"run_paneldue_beep\", \"params\": {\"frequency\": 300, \"duration\": 1.0}} objects/list \u00b6 Ce point de terminaison remonte la liste des \"objets\" disponibles de l'imprimante que l'on peut interroger (via le point de terminaison \"objects/query\"). Par exemple : {\"id\": 123, \"method\": \"objects/list\"} peut renvoyer : {\"id\": 123, \"result\": {\"objects\": [\" webhooks\", \"configfile\", \"heaters\", \"gcode_move\", \"query_endstops\", \"idle_timeout\", \"toolhead\", \"extruder\"]}} objects/query \u00b6 Ce point de terminaison permet de retrouver des informations \u00e0 partir d'objets de l'imprimante. Par exemple : {\"id\": 123, \"method\": \"objects/query\", \"params\": {\"objects\": {\"toolhead\": [\"position\"], \"webhooks\": null}} } peut renvoyer : {\"id\": 123, \"result\": {\"status\": {\"webhooks\": {\"state\": \"ready\", \"state_message\": \"L'imprimante est pr\u00eate\"} , \"toolhead\": {\"position\": [0.0, 0.0, 0.0, 0.0]}}, \"eventtime\": 3051555.377933684}} Le param\u00e8tre \"objects\" dans la requ\u00eate doit \u00eatre un dictionnaire contenant des objets de l'imprimante \u00e0 interroger - la cl\u00e9 contient le nom de l'objet imprimante et la valeur est soit \"null\" (pour interroger tous les champs) soit une liste de noms de champs. Le message de r\u00e9ponse contiendra un champ \"statut\" contenant un dictionnaire avec les informations demand\u00e9es - la cl\u00e9 contient le nom de l'objet imprimante et la valeur est un dictionnaire contenant ses champs. Le message de r\u00e9ponse contiendra \u00e9galement un champ \"eventtime\" contenant l'horodatage \u00e0 partir duquel la requ\u00eate a \u00e9t\u00e9 prise. Les champs disponibles sont document\u00e9s dans le document R\u00e9f\u00e9rence des \u00e9tats . objects/subscribe \u00b6 Ce point de terminaison permet d'interroger puis de s'abonner \u00e0 des informations provenant d'objets de l'imprimante. La demande et la r\u00e9ponse du point de terminaison sont identiques au point de terminaison \"objects/query\". Par exemple : {\"id\": 123, \"method\": \"objects/subscribe\", \"params\": {\"objects\":{\"toolhead\": [\"position\"], \"webhooks\": [\"state \"]}, \"response_template\":{}}} peut renvoyer : {\"id\": 123, \"result\": {\"status\": {\"webhooks\": {\"state\": \"pr\u00eat\" }, \"toolhead\": {\"position\": [0.0, 0.0, 0.0, 0.0]}}, \"eventtime\": 3052153.382083195}} et entra\u00eener des messages asynchrones ult\u00e9rieurs tels que : {\"params\": {\"status\": {\"webhooks\": {\"state\": \"shutdown\"}}, \"eventtime\": 3052165.418815847}} gcode/help \u00b6 Ce point de terminaison permet de retrouver les commandes G-Code disponibles qui ont une cha\u00eene d'aide d\u00e9finie. Par exemple : {\"id\": 123, \"method\": \"gcode/help\"} peut renvoyer : {\"id\": 123, \"result\": {\"RESTORE_GCODE_STATE\": \"Restaurer un \u00e9tat G-Code pr\u00e9c\u00e9demment enregistr\u00e9\", \"PID_CALIBRATE\": \"Ex\u00e9cuter le test d'\u00e9talonnage PID\", \"QUERY_ADC\": \"Rapport de la derni\u00e8re valeur d'une broche analogique\", ...}} gcode/script \u00b6 Ce point de terminaison permet d'ex\u00e9cuter une s\u00e9rie de commandes G-Code. Par exemple : {\"id\": 123, \"method\": \"gcode/script\", \"params\": {\"script\": \"G90\"}} Si le script G-Code fourni g\u00e9n\u00e8re une erreur, une r\u00e9ponse d'erreur est g\u00e9n\u00e9r\u00e9e. Cependant, si la commande G-Code produit une sortie vers le terminal, cette sortie n'est pas remont\u00e9e dans la r\u00e9ponse. (Utilisez le point de terminaison \"gcode/subscribe_output\" pour obtenir la remont\u00e9e des sortie du terminal G-Code.) Si une commande G-Code est en cours de traitement lorsque cette demande est re\u00e7ue, le script re\u00e7u sera mis en file d'attente. Ce d\u00e9lai peut \u00eatre important (par exemple, si une commande d'attente de temp\u00e9rature de code G est en cours). Le message de r\u00e9ponse JSON est envoy\u00e9 lorsque le traitement du script est enti\u00e8rement termin\u00e9. gcode/restart \u00b6 Ce point de terminaison permet de demander un red\u00e9marrage - il est similaire \u00e0 l'ex\u00e9cution de la commande G-Code \"RESTART\". Par exemple : {\"id\": 123, \"method\": \"gcode/restart\"} Comme pour le point de terminaison \"gcode/script\", ce point de terminaison ne se termine qu'apr\u00e8s la fin de toutes les commandes G-Code en attente. gcode/firmware_restart \u00b6 Ceci est similaire au point de terminaison \"gcode/restart\" - il impl\u00e9mente la commande G-Code \"FIRMWARE_RESTART\". Par exemple : {\"id\": 123, \"method\": \"gcode/firmware_restart\"} Comme pour le point de terminaison \"gcode/script\", ce point de terminaison ne se termine qu'apr\u00e8s la fin de toutes les commandes G-Code en attente. gcode/subscribe_output \u00b6 Ce point de terminaison est utilis\u00e9 pour s'abonner aux messages du terminal G-Code de Klipper. Par exemple : {\"id\": 123, \"method\": \"gcode/subscribe_output\", \"params\": {\"response_template\":{}}} peut ult\u00e9rieurement produire des messages asynchrones tels que : {\"params\": {\"response\": \"// \u00c9tat de Klipper : Arr\u00eat\"}} Ce point de terminaison est destin\u00e9 \u00e0 prendre en charge l'interaction humaine via une interface \"fen\u00eatre de terminal\". L'analyse du contenu de la sortie du terminal G-Code est d\u00e9conseill\u00e9e. Utilisez le point de terminaison \"objects/subscribe\" pour obtenir des mises \u00e0 jour sur l'\u00e9tat de Klipper. motion_report/dump_stepper \u00b6 Ce point de terminaison est utilis\u00e9 pour s'abonner au flux de commandes interne stepper queue_step de Klipper pour un stepper. L'obtention de ces mises \u00e0 jour de mouvement de bas niveau peut \u00eatre utile \u00e0 des fins de diagnostic et de d\u00e9bogage. L'utilisation de ce point de terminaison peut augmenter la charge syst\u00e8me de Klipper. Une requ\u00eate peut ressembler \u00e0 : {\"id\": 123, \"method\":\"motion_report/dump_stepper\", \"params\": {\"name\": \"stepper_x\", \"response_template\": {}}} et peut renvoyer : {\"id\": 123, \"result\": {\"header\": [\"interval\", \"count\", \"add\"]}} et peut produire ult\u00e9rieurement des messages asynchrones tels que : {\"params\": {\"first_clock\": 179601081, \"first_time\": 8.98, \"first_position\": 0, \"last_clock\": 219686097, \"last_time\": 10.984, \"data\": [[179601081, 1, 0 ], [29573, 2, -8685], [16230, 4, -1525], [10559, 6, -160], [10000, 976, 0], [10000, 1000, 0], [10000, 1000, 0], [10000, 1000, 0], [9855, 5, 187], [11632, 4, 1534], [20756, 2, 9442]]}} Le champ \"en-t\u00eate\" dans la r\u00e9ponse initiale \u00e0 la requ\u00eate est utilis\u00e9 pour d\u00e9crire les champs pr\u00e9sents dans les r\u00e9ponses \"donn\u00e9es\" ult\u00e9rieures. motion_report/dump_trapq \u00b6 Ce point de terminaison est utilis\u00e9 pour s'abonner \u00e0 la \"file d'attente de mouvements trap\u00e9zo\u00efdaux\" interne de Klipper. L'obtention de ces mises \u00e0 jour de mouvement de bas niveau peut \u00eatre utile \u00e0 des fins de diagnostic et de d\u00e9bogage. L'utilisation de ce point de terminaison peut augmenter la charge syst\u00e8me de Klipper. Une requ\u00eate peut ressembler \u00e0 : {\"id\": 123, \"method\": \"motion_report/dump_trapq\", \"params\": {\"name\": \"toolhead\", \"response_template\":{}}} et peut renvoyer : {\"id\": 1, \"result\": {\"header\": [\"time\", \"duration\", \"start_velocity\", \"acceleration\", \"start_position\", \"direction\"]}} et peut produire ult\u00e9rieurement des messages asynchrones tels que : {\"params\": {\"data\": [[4.05, 1.0, 0.0, 0.0, [300.0, 0.0, 0.0], [0.0, 0.0, 0.0] ], [5.054, 0.001, 0.0, 3000.0, [300.0, 0.0, 0.0], [-1.0, 0.0, 0.0]]]}} Le champ \"en-t\u00eate\" dans la r\u00e9ponse initiale \u00e0 la requ\u00eate est utilis\u00e9 pour d\u00e9crire les champs pr\u00e9sents dans les r\u00e9ponses \"donn\u00e9es\" ult\u00e9rieures. adxl345/dump_adxl345 \u00b6 Ce point de terminaison est utilis\u00e9 pour s'abonner aux donn\u00e9es de l'acc\u00e9l\u00e9rom\u00e8tre ADXL345. L'obtention de ces mises \u00e0 jour de mouvement de bas niveau peut \u00eatre utile \u00e0 des fins de diagnostic et de d\u00e9bogage. L'utilisation de ce point de terminaison peut augmenter la charge syst\u00e8me de Klipper. Une requ\u00eate peut ressembler \u00e0 : {\"id\": 123, \"method\":\"adxl345/dump_adxl345\", \"params\": {\"sensor\": \"adxl345\", \"response_template\": {}}} et pourrait renvoyer : {\"id\": 123,\"result\":{\"header\":[\"time\",\"x_acceleration\",\"y_acceleration\", \"z_acceleration\"]}} et pourrait plus tard produire des messages asynchrones messages tels que : {\"params\":{\"overflows\":0,\"data\":[[3292.432935,-535.44309,-1529.8374,9561.4], [3292.433256,-382.45935,-1606.32927,9561.48375]]}} Le champ \"en-t\u00eate\" dans la r\u00e9ponse initiale \u00e0 la requ\u00eate est utilis\u00e9 pour d\u00e9crire les champs pr\u00e9sents dans les r\u00e9ponses \"donn\u00e9es\" ult\u00e9rieures. angle/dump_angle \u00b6 Ce point de terminaison est utilis\u00e9 pour s'abonner aux donn\u00e9es du capteur d'angle . L'obtention de ces mises \u00e0 jour de mouvement de bas niveau peut \u00eatre utile \u00e0 des fins de diagnostic et de d\u00e9bogage. L'utilisation de ce point de terminaison peut augmenter la charge syst\u00e8me de Klipper. Une requ\u00eate peut ressembler \u00e0 : {\"id\": 123, \"method\":\"angle/dump_angle\", \"params\": {\"sensor\": \"my_angle_sensor\", \"response_template\": {}}} et peut renvoyer : {\"id\": 123,\"result\":{\"header\":[\"time\",\"angle\"]}} et peut produire ult\u00e9rieurement des messages asynchrones tels que : { \"params\":{\"position_offset\":3.151562,\"errors\":0, \"data\":[[1290.951905,-5063],[1290.952321,-5065]]}} Le champ \"en-t\u00eate\" dans la r\u00e9ponse initiale \u00e0 la requ\u00eate est utilis\u00e9 pour d\u00e9crire les champs pr\u00e9sents dans les r\u00e9ponses \"donn\u00e9es\" ult\u00e9rieures. pause_resume/cancel \u00b6 Ce point final est similaire \u00e0 l'ex\u00e9cution de la commande G-Code \"PRINT_CANCEL\". Par exemple : {\"id\": 123, \"method\": \"pause_resume/cancel\"} Comme pour le point de terminaison \"gcode/script\", ce point de terminaison ne se termine qu'apr\u00e8s la fin de toutes les commandes G-Code en attente. pause_resume/pause \u00b6 Ce point d'entr\u00e9e est similaire \u00e0 l'ex\u00e9cution de la commande G-Code \"PAUSE\". Par exemple : {\"id\": 123, \"method\": \"pause_resume/pause\"} Comme pour le point de terminaison \"gcode/script\", ce point de terminaison ne se termine qu'apr\u00e8s la fin de toutes les commandes G-Code en attente. pause_resume/resume \u00b6 Ce point de terminaison est similaire \u00e0 l'ex\u00e9cution de la commande G-Code \"RESUME\". Par exemple : {\"id\": 123, \"method\": \"pause_resume/resume\"} Comme pour le point de terminaison \"gcode/script\", ce point de terminaison ne se termine qu'apr\u00e8s la fin de toutes les commandes G-Code en attente. query_endstops/status \u00b6 Ce point de terminaison interrogera les fins de course actifs et renverra leur \u00e9tat. Par exemple : {\"id\": 123, \"method\": \"query_endstops/status\"} peut renvoyer : {\"id\": 123, \"result\": {\"y\": \"open \", \"x\": \"open\", \"z\": \"TRIGGERED\"}} Comme pour le point de terminaison \"gcode/script\", ce point de terminaison ne se termine qu'apr\u00e8s la fin de toutes les commandes G-Code en attente.","title":"Serveur API"},{"location":"API_Server.html#serveur-api","text":"Ce document d\u00e9crit l'Interface de Programmation d'Applications (API) de Klipper. Cette interface permet \u00e0 des applications externes d'interroger et de contr\u00f4ler Klipper.","title":"Serveur API"},{"location":"API_Server.html#activer-le-socket-api","text":"Pour pouvoir utiliser les Serveur API, le logiciel h\u00f4te klippy.py doit \u00eatre d\u00e9marr\u00e9 avec le param\u00e8tre -a . Par exemple : ~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer.cfg -a /tmp/klippy_uds -l /tmp/klippy.log Cela force le logiciel h\u00f4te \u00e0 cr\u00e9er un socket de domaine Unix. Un client peut alors ouvrir une connexion sur ce socket et envoyer des commandes \u00e0 Klipper. Voir le projet Moonraker pour un outil populaire qui peut transf\u00e9rer les requ\u00eates HTTP vers le socket du serveur d'API de Klipper.","title":"Activer le socket API"},{"location":"API_Server.html#format-de-la-demande","text":"Les messages envoy\u00e9s et re\u00e7us sur le socket sont des cha\u00eenes au format JSON et termin\u00e9es par le caract\u00e8re ASCII 0x03 : <json_object_1><0x03><json_object_2><0x03>... Klipper contiens un outil scripts/whconsole.py qui peut effectuer la mise en forme du message ci-dessus. Par exemple : ~/klipper/scripts/whconsole.py /tmp/klippy_uds Cet outil peut lire une s\u00e9rie de commandes JSON \u00e0 partir de l'entr\u00e9e standard stdin, les envoyer \u00e0 Klipper et afficher les r\u00e9sultats. Cet outil s'attend \u00e0 avoir une commande JSON par ligne et il ajoute automatiquement le terminateur 0x03 avant d'envoyer les requ\u00eates. (Le serveur d'API de Klipper ne attend pas un saut de ligne.)","title":"Format de la demande"},{"location":"API_Server.html#protocole-de-lapi","text":"Le protocole de commande utilis\u00e9 sur le socket de communications est inspir\u00e9 par json-rpc . Une requ\u00eate pourrait ressembler \u00e0 \u00e7a : {\"id\": 123, \"method\": \"info\", \"params\": {}} et une r\u00e9ponse pourrait ressembler \u00e0 \u00e7a : {\"id\": 123, \"result\": {\"state_message\": \"Printer is ready\", \"klipper_path\": \"/home/pi/klipper\", \"config_file\": \"/home/pi/printer.cfg\", \"software_version\": \"v0.8.0-823-g883b1cb6\", \"hostname\": \"octopi\", \"cpu_info\": \"4 core ARMv7 Processor rev 4 (v7l)\", \"state\": \"ready\", \"python_path\": \"/home/pi/klippy-env/bin/python\", \"log_file\": \"/tmp/klippy.log\"}} Toutes les requ\u00eates doivent \u00eatre un dictionnaire JSON. (Ce document utilise le terme Python 'dictionary' pour d\u00e9crire un objet JSON - une affectation de paires Cl\u00e9/Valeur comprises en deux parenth\u00e8ses {} .) le dictionnaire de requ\u00eate doit contenir un param\u00e8tre \"m\u00e9thode\" disponible dans les \"points de terminaison\" de Klipper. Le dictionnaire de requ\u00eate peut contenir un param\u00e8tre \"params\" qui doit \u00eatre de type dictionnaire. Les \"params\" fournissent des informations de param\u00e8tre suppl\u00e9mentaires au \"endpoint\" Klipper qui traite la demande. Son contenu est sp\u00e9cifique au \"endpoint\". Le dictionnaire de requ\u00eate peut contenir un param\u00e8tre \"id\" qui peut \u00eatre de n'importe quel type JSON. Si \"id\" est pr\u00e9sent, alors Klipper r\u00e9pondra \u00e0 la demande avec une r\u00e9ponse contenant cet \"id\". Si \"id\" est omis (ou d\u00e9fini sur une valeur JSON \"null\"), Klipper ne fournira aucune r\u00e9ponse \u00e0 la requ\u00eate. Un message de r\u00e9ponse est un dictionnaire JSON contenant \"id\" et \"result\". Le \"r\u00e9sultat\" est toujours un dictionnaire - son contenu est sp\u00e9cifique au \"endpoint\" traitant la demande. Si le traitement d'un requ\u00eate est en erreur, le message de r\u00e9ponse contiendra un champ \"error\" au lieu de \"result\". Par exemple, la requ\u00eate : {\"id\": 123, \"method\": \"gcode/script\", \"params\": {\"script\": \"G1 X200\"}} pourrait retourner une erreur telle que :: {\"id\": 123, \"error\": {\"message\": \"Must home axis first: 200.000 0.000 0.000 [0.000]\", \"error\": \"WebRequestError\"}} Klipper traite toujours les demandes dans l'ordre de leur r\u00e9ception. Cependant, certaines requ\u00eates peuvent ne pas se terminer imm\u00e9diatement, ce qui peut entra\u00eener l'envoi de la r\u00e9ponse associ\u00e9e dans le d\u00e9sordre par rapport aux r\u00e9ponses d'autres requ\u00eates. Une requ\u00eate JSON ne suspend jamais le traitement des requ\u00eates JSON suivantes.","title":"Protocole de l'API"},{"location":"API_Server.html#abonnements","text":"Certains \"endpoint\" de Klipper autorisent un \"abonnement\" pour de futurs messages asynchrone de mise \u00e0 jour. Par exemple : {\"id\": 123, \"method\": \"gcode/subscribe_output\", \"params\": {\"response_template\":{\"key\": 345}}} Peut r\u00e9pondre dans un premier temps : {\"id\": 123, \"result\": {}} et faire en sorte que Klipper envoie de futurs messages similaires \u00e0 : {\"params\": {\"response\": \"ok B:22.8 /0.0 T0:22.4 /0.0\"}, \"key\": 345} Une demande d'abonnement accepte un dictionnaire \"response_template\" dans le champ \"params\" de la demande. Ce dictionnaire \"response_template\" est utilis\u00e9 comme mod\u00e8le pour les futurs messages asynchrones - il peut contenir des paires cl\u00e9/valeur arbitraires. Lors de l'envoi de ces futurs messages asynchrones, Klipper ajoutera un champ \"params\" contenant un dictionnaire avec un contenu sp\u00e9cifique \"endpoint\" au mod\u00e8le de r\u00e9ponse, puis enverra ce mod\u00e8le. Si un champ \"response_template\" n'est pas fourni, il s'agit par d\u00e9faut d'un dictionnaire vide ( {} ).","title":"Abonnements"},{"location":"API_Server.html#endpoints-disponibles","text":"Par convention, les \"endpoints\" de Klipper sont de la forme <module_name>/<some_name> . Lors d'une demande \u00e0 un \"endpoint\", le nom complet doit \u00eatre d\u00e9fini dans le param\u00e8tre \"method\" du dictionnaire de requ\u00eate (par exemple, {\"method\"=\"gcode/restart\"} ).","title":"\"endpoints\" disponibles"},{"location":"API_Server.html#info","text":"Le point de terminaison \"info\" est utilis\u00e9 pour obtenir des informations sur le syst\u00e8me et la version de Klipper. Il est \u00e9galement utilis\u00e9 pour fournir les informations de version du client \u00e0 Klipper. Par exemple : {\"id\": 123, \"method\": \"info\", \"params\": { \"client_info\": { \"version\": \"v1\"}}} S'il est pr\u00e9sent, le param\u00e8tre \"client_info\" doit \u00eatre un dictionnaire, mais ce dictionnaire peut avoir un contenu arbitraire. Les clients sont encourag\u00e9s \u00e0 fournir le nom du client et sa version logicielle lors de la premi\u00e8re connexion au serveur API Klipper.","title":"Info"},{"location":"API_Server.html#arret-durgence","text":"Le point de terminaison \"emergency_stop\" est utilis\u00e9 pour demander \u00e0 Klipper de passer \u00e0 un \u00e9tat \"shutdown\". Il se comporte de la m\u00eame mani\u00e8re que la commande G-Code M112 . Par exemple : {\"id\": 123, \"method\": \"emergency_stop\"}","title":"arr\u00eat d'urgence"},{"location":"API_Server.html#register_remote_method","text":"Ce point de terminaison permet aux clients d'enregistrer des m\u00e9thodes pouvant \u00eatre appel\u00e9es depuis klipper. Il renverra un objet vide en cas de succ\u00e8s. Par exemple : {\"id\": 123, \"method\": \"register_remote_method\", \"params\": {\"response_template\": {\"action\": \"run_paneldue_beep\"}, \"remote_method\": \"paneldue_beep\"}} renverra : }` La m\u00e9thode distante paneldue_beep peut d\u00e9sormais \u00eatre appel\u00e9e depuis Klipper. Notez que si la m\u00e9thode prend des param\u00e8tres, ils doivent \u00eatre fournis en tant qu'arguments de mots cl\u00e9s. Voici un exemple de la fa\u00e7on dont il peut \u00eatre appel\u00e9 \u00e0 partir d'un gcode_macro : [gcode_macro PANELDUE_BEEP] gcode: {action_call_remote_method(\"paneldue_beep\", frequency=300, duration=1.0)} Lorsque la macro gcode PANELDUE_BEEP est ex\u00e9cut\u00e9e, Klipper enverra ce qui suit sur le socket : {\"action\": \"run_paneldue_beep\", \"params\": {\"frequency\": 300, \"duration\": 1.0}}","title":"register_remote_method"},{"location":"API_Server.html#objectslist","text":"Ce point de terminaison remonte la liste des \"objets\" disponibles de l'imprimante que l'on peut interroger (via le point de terminaison \"objects/query\"). Par exemple : {\"id\": 123, \"method\": \"objects/list\"} peut renvoyer : {\"id\": 123, \"result\": {\"objects\": [\" webhooks\", \"configfile\", \"heaters\", \"gcode_move\", \"query_endstops\", \"idle_timeout\", \"toolhead\", \"extruder\"]}}","title":"objects/list"},{"location":"API_Server.html#objectsquery","text":"Ce point de terminaison permet de retrouver des informations \u00e0 partir d'objets de l'imprimante. Par exemple : {\"id\": 123, \"method\": \"objects/query\", \"params\": {\"objects\": {\"toolhead\": [\"position\"], \"webhooks\": null}} } peut renvoyer : {\"id\": 123, \"result\": {\"status\": {\"webhooks\": {\"state\": \"ready\", \"state_message\": \"L'imprimante est pr\u00eate\"} , \"toolhead\": {\"position\": [0.0, 0.0, 0.0, 0.0]}}, \"eventtime\": 3051555.377933684}} Le param\u00e8tre \"objects\" dans la requ\u00eate doit \u00eatre un dictionnaire contenant des objets de l'imprimante \u00e0 interroger - la cl\u00e9 contient le nom de l'objet imprimante et la valeur est soit \"null\" (pour interroger tous les champs) soit une liste de noms de champs. Le message de r\u00e9ponse contiendra un champ \"statut\" contenant un dictionnaire avec les informations demand\u00e9es - la cl\u00e9 contient le nom de l'objet imprimante et la valeur est un dictionnaire contenant ses champs. Le message de r\u00e9ponse contiendra \u00e9galement un champ \"eventtime\" contenant l'horodatage \u00e0 partir duquel la requ\u00eate a \u00e9t\u00e9 prise. Les champs disponibles sont document\u00e9s dans le document R\u00e9f\u00e9rence des \u00e9tats .","title":"objects/query"},{"location":"API_Server.html#objectssubscribe","text":"Ce point de terminaison permet d'interroger puis de s'abonner \u00e0 des informations provenant d'objets de l'imprimante. La demande et la r\u00e9ponse du point de terminaison sont identiques au point de terminaison \"objects/query\". Par exemple : {\"id\": 123, \"method\": \"objects/subscribe\", \"params\": {\"objects\":{\"toolhead\": [\"position\"], \"webhooks\": [\"state \"]}, \"response_template\":{}}} peut renvoyer : {\"id\": 123, \"result\": {\"status\": {\"webhooks\": {\"state\": \"pr\u00eat\" }, \"toolhead\": {\"position\": [0.0, 0.0, 0.0, 0.0]}}, \"eventtime\": 3052153.382083195}} et entra\u00eener des messages asynchrones ult\u00e9rieurs tels que : {\"params\": {\"status\": {\"webhooks\": {\"state\": \"shutdown\"}}, \"eventtime\": 3052165.418815847}}","title":"objects/subscribe"},{"location":"API_Server.html#gcodehelp","text":"Ce point de terminaison permet de retrouver les commandes G-Code disponibles qui ont une cha\u00eene d'aide d\u00e9finie. Par exemple : {\"id\": 123, \"method\": \"gcode/help\"} peut renvoyer : {\"id\": 123, \"result\": {\"RESTORE_GCODE_STATE\": \"Restaurer un \u00e9tat G-Code pr\u00e9c\u00e9demment enregistr\u00e9\", \"PID_CALIBRATE\": \"Ex\u00e9cuter le test d'\u00e9talonnage PID\", \"QUERY_ADC\": \"Rapport de la derni\u00e8re valeur d'une broche analogique\", ...}}","title":"gcode/help"},{"location":"API_Server.html#gcodescript","text":"Ce point de terminaison permet d'ex\u00e9cuter une s\u00e9rie de commandes G-Code. Par exemple : {\"id\": 123, \"method\": \"gcode/script\", \"params\": {\"script\": \"G90\"}} Si le script G-Code fourni g\u00e9n\u00e8re une erreur, une r\u00e9ponse d'erreur est g\u00e9n\u00e9r\u00e9e. Cependant, si la commande G-Code produit une sortie vers le terminal, cette sortie n'est pas remont\u00e9e dans la r\u00e9ponse. (Utilisez le point de terminaison \"gcode/subscribe_output\" pour obtenir la remont\u00e9e des sortie du terminal G-Code.) Si une commande G-Code est en cours de traitement lorsque cette demande est re\u00e7ue, le script re\u00e7u sera mis en file d'attente. Ce d\u00e9lai peut \u00eatre important (par exemple, si une commande d'attente de temp\u00e9rature de code G est en cours). Le message de r\u00e9ponse JSON est envoy\u00e9 lorsque le traitement du script est enti\u00e8rement termin\u00e9.","title":"gcode/script"},{"location":"API_Server.html#gcoderestart","text":"Ce point de terminaison permet de demander un red\u00e9marrage - il est similaire \u00e0 l'ex\u00e9cution de la commande G-Code \"RESTART\". Par exemple : {\"id\": 123, \"method\": \"gcode/restart\"} Comme pour le point de terminaison \"gcode/script\", ce point de terminaison ne se termine qu'apr\u00e8s la fin de toutes les commandes G-Code en attente.","title":"gcode/restart"},{"location":"API_Server.html#gcodefirmware_restart","text":"Ceci est similaire au point de terminaison \"gcode/restart\" - il impl\u00e9mente la commande G-Code \"FIRMWARE_RESTART\". Par exemple : {\"id\": 123, \"method\": \"gcode/firmware_restart\"} Comme pour le point de terminaison \"gcode/script\", ce point de terminaison ne se termine qu'apr\u00e8s la fin de toutes les commandes G-Code en attente.","title":"gcode/firmware_restart"},{"location":"API_Server.html#gcodesubscribe_output","text":"Ce point de terminaison est utilis\u00e9 pour s'abonner aux messages du terminal G-Code de Klipper. Par exemple : {\"id\": 123, \"method\": \"gcode/subscribe_output\", \"params\": {\"response_template\":{}}} peut ult\u00e9rieurement produire des messages asynchrones tels que : {\"params\": {\"response\": \"// \u00c9tat de Klipper : Arr\u00eat\"}} Ce point de terminaison est destin\u00e9 \u00e0 prendre en charge l'interaction humaine via une interface \"fen\u00eatre de terminal\". L'analyse du contenu de la sortie du terminal G-Code est d\u00e9conseill\u00e9e. Utilisez le point de terminaison \"objects/subscribe\" pour obtenir des mises \u00e0 jour sur l'\u00e9tat de Klipper.","title":"gcode/subscribe_output"},{"location":"API_Server.html#motion_reportdump_stepper","text":"Ce point de terminaison est utilis\u00e9 pour s'abonner au flux de commandes interne stepper queue_step de Klipper pour un stepper. L'obtention de ces mises \u00e0 jour de mouvement de bas niveau peut \u00eatre utile \u00e0 des fins de diagnostic et de d\u00e9bogage. L'utilisation de ce point de terminaison peut augmenter la charge syst\u00e8me de Klipper. Une requ\u00eate peut ressembler \u00e0 : {\"id\": 123, \"method\":\"motion_report/dump_stepper\", \"params\": {\"name\": \"stepper_x\", \"response_template\": {}}} et peut renvoyer : {\"id\": 123, \"result\": {\"header\": [\"interval\", \"count\", \"add\"]}} et peut produire ult\u00e9rieurement des messages asynchrones tels que : {\"params\": {\"first_clock\": 179601081, \"first_time\": 8.98, \"first_position\": 0, \"last_clock\": 219686097, \"last_time\": 10.984, \"data\": [[179601081, 1, 0 ], [29573, 2, -8685], [16230, 4, -1525], [10559, 6, -160], [10000, 976, 0], [10000, 1000, 0], [10000, 1000, 0], [10000, 1000, 0], [9855, 5, 187], [11632, 4, 1534], [20756, 2, 9442]]}} Le champ \"en-t\u00eate\" dans la r\u00e9ponse initiale \u00e0 la requ\u00eate est utilis\u00e9 pour d\u00e9crire les champs pr\u00e9sents dans les r\u00e9ponses \"donn\u00e9es\" ult\u00e9rieures.","title":"motion_report/dump_stepper"},{"location":"API_Server.html#motion_reportdump_trapq","text":"Ce point de terminaison est utilis\u00e9 pour s'abonner \u00e0 la \"file d'attente de mouvements trap\u00e9zo\u00efdaux\" interne de Klipper. L'obtention de ces mises \u00e0 jour de mouvement de bas niveau peut \u00eatre utile \u00e0 des fins de diagnostic et de d\u00e9bogage. L'utilisation de ce point de terminaison peut augmenter la charge syst\u00e8me de Klipper. Une requ\u00eate peut ressembler \u00e0 : {\"id\": 123, \"method\": \"motion_report/dump_trapq\", \"params\": {\"name\": \"toolhead\", \"response_template\":{}}} et peut renvoyer : {\"id\": 1, \"result\": {\"header\": [\"time\", \"duration\", \"start_velocity\", \"acceleration\", \"start_position\", \"direction\"]}} et peut produire ult\u00e9rieurement des messages asynchrones tels que : {\"params\": {\"data\": [[4.05, 1.0, 0.0, 0.0, [300.0, 0.0, 0.0], [0.0, 0.0, 0.0] ], [5.054, 0.001, 0.0, 3000.0, [300.0, 0.0, 0.0], [-1.0, 0.0, 0.0]]]}} Le champ \"en-t\u00eate\" dans la r\u00e9ponse initiale \u00e0 la requ\u00eate est utilis\u00e9 pour d\u00e9crire les champs pr\u00e9sents dans les r\u00e9ponses \"donn\u00e9es\" ult\u00e9rieures.","title":"motion_report/dump_trapq"},{"location":"API_Server.html#adxl345dump_adxl345","text":"Ce point de terminaison est utilis\u00e9 pour s'abonner aux donn\u00e9es de l'acc\u00e9l\u00e9rom\u00e8tre ADXL345. L'obtention de ces mises \u00e0 jour de mouvement de bas niveau peut \u00eatre utile \u00e0 des fins de diagnostic et de d\u00e9bogage. L'utilisation de ce point de terminaison peut augmenter la charge syst\u00e8me de Klipper. Une requ\u00eate peut ressembler \u00e0 : {\"id\": 123, \"method\":\"adxl345/dump_adxl345\", \"params\": {\"sensor\": \"adxl345\", \"response_template\": {}}} et pourrait renvoyer : {\"id\": 123,\"result\":{\"header\":[\"time\",\"x_acceleration\",\"y_acceleration\", \"z_acceleration\"]}} et pourrait plus tard produire des messages asynchrones messages tels que : {\"params\":{\"overflows\":0,\"data\":[[3292.432935,-535.44309,-1529.8374,9561.4], [3292.433256,-382.45935,-1606.32927,9561.48375]]}} Le champ \"en-t\u00eate\" dans la r\u00e9ponse initiale \u00e0 la requ\u00eate est utilis\u00e9 pour d\u00e9crire les champs pr\u00e9sents dans les r\u00e9ponses \"donn\u00e9es\" ult\u00e9rieures.","title":"adxl345/dump_adxl345"},{"location":"API_Server.html#angledump_angle","text":"Ce point de terminaison est utilis\u00e9 pour s'abonner aux donn\u00e9es du capteur d'angle . L'obtention de ces mises \u00e0 jour de mouvement de bas niveau peut \u00eatre utile \u00e0 des fins de diagnostic et de d\u00e9bogage. L'utilisation de ce point de terminaison peut augmenter la charge syst\u00e8me de Klipper. Une requ\u00eate peut ressembler \u00e0 : {\"id\": 123, \"method\":\"angle/dump_angle\", \"params\": {\"sensor\": \"my_angle_sensor\", \"response_template\": {}}} et peut renvoyer : {\"id\": 123,\"result\":{\"header\":[\"time\",\"angle\"]}} et peut produire ult\u00e9rieurement des messages asynchrones tels que : { \"params\":{\"position_offset\":3.151562,\"errors\":0, \"data\":[[1290.951905,-5063],[1290.952321,-5065]]}} Le champ \"en-t\u00eate\" dans la r\u00e9ponse initiale \u00e0 la requ\u00eate est utilis\u00e9 pour d\u00e9crire les champs pr\u00e9sents dans les r\u00e9ponses \"donn\u00e9es\" ult\u00e9rieures.","title":"angle/dump_angle"},{"location":"API_Server.html#pause_resumecancel","text":"Ce point final est similaire \u00e0 l'ex\u00e9cution de la commande G-Code \"PRINT_CANCEL\". Par exemple : {\"id\": 123, \"method\": \"pause_resume/cancel\"} Comme pour le point de terminaison \"gcode/script\", ce point de terminaison ne se termine qu'apr\u00e8s la fin de toutes les commandes G-Code en attente.","title":"pause_resume/cancel"},{"location":"API_Server.html#pause_resumepause","text":"Ce point d'entr\u00e9e est similaire \u00e0 l'ex\u00e9cution de la commande G-Code \"PAUSE\". Par exemple : {\"id\": 123, \"method\": \"pause_resume/pause\"} Comme pour le point de terminaison \"gcode/script\", ce point de terminaison ne se termine qu'apr\u00e8s la fin de toutes les commandes G-Code en attente.","title":"pause_resume/pause"},{"location":"API_Server.html#pause_resumeresume","text":"Ce point de terminaison est similaire \u00e0 l'ex\u00e9cution de la commande G-Code \"RESUME\". Par exemple : {\"id\": 123, \"method\": \"pause_resume/resume\"} Comme pour le point de terminaison \"gcode/script\", ce point de terminaison ne se termine qu'apr\u00e8s la fin de toutes les commandes G-Code en attente.","title":"pause_resume/resume"},{"location":"API_Server.html#query_endstopsstatus","text":"Ce point de terminaison interrogera les fins de course actifs et renverra leur \u00e9tat. Par exemple : {\"id\": 123, \"method\": \"query_endstops/status\"} peut renvoyer : {\"id\": 123, \"result\": {\"y\": \"open \", \"x\": \"open\", \"z\": \"TRIGGERED\"}} Comme pour le point de terminaison \"gcode/script\", ce point de terminaison ne se termine qu'apr\u00e8s la fin de toutes les commandes G-Code en attente.","title":"query_endstops/status"},{"location":"Axis_Twist_Compensation.html","text":"Axis Twist Compensation \u00b6 This document describes the [axis_twist_compensation] module. Some printers may have a small twist in their X rail which can skew the results of a probe attached to the X carriage. This is common in printers with designs like the Prusa MK3, Sovol SV06 etc and is further described under probe location bias . It may result in probe operations such as Bed Mesh , Screws Tilt Adjust , Z Tilt Adjust etc returning inaccurate representations of the bed. This module uses manual measurements by the user to correct the probe's results. Note that if your axis is significantly twisted it is strongly recommended to first use mechanical means to fix it prior to applying software corrections. Warning : This module is not compatible with dockable probes yet and will try to probe the bed without attaching the probe if you use it. Overview of compensation usage \u00b6 Tip: Make sure the probe X and Y offsets are correctly set as they greatly influence calibration. After setting up the [axis_twist_compensation] module, perform AXIS_TWIST_COMPENSATION_CALIBRATE The calibration wizard will prompt you to measure the probe Z offset at a few points along the bed The calibration defaults to 3 points but you can use the option SAMPLE_COUNT= to use a different number. Adjust your Z offset Perform automatic/probe-based bed tramming operations, such as Screws Tilt Adjust , Z Tilt Adjust etc Home all axis, then perform a Bed Mesh if required Perform a test print, followed by any fine-tuning as desired Tip: Bed temperature and nozzle temperature and size do not seem to have an influence to the calibration process. [axis_twist_compensation] setup and commands \u00b6 Configuration options for [axis_twist_compensation] can be found in the Configuration Reference . Commands for [axis_twist_compensation] can be found in the G-Codes Reference","title":"Axis Twist Compensation"},{"location":"Axis_Twist_Compensation.html#axis-twist-compensation","text":"This document describes the [axis_twist_compensation] module. Some printers may have a small twist in their X rail which can skew the results of a probe attached to the X carriage. This is common in printers with designs like the Prusa MK3, Sovol SV06 etc and is further described under probe location bias . It may result in probe operations such as Bed Mesh , Screws Tilt Adjust , Z Tilt Adjust etc returning inaccurate representations of the bed. This module uses manual measurements by the user to correct the probe's results. Note that if your axis is significantly twisted it is strongly recommended to first use mechanical means to fix it prior to applying software corrections. Warning : This module is not compatible with dockable probes yet and will try to probe the bed without attaching the probe if you use it.","title":"Axis Twist Compensation"},{"location":"Axis_Twist_Compensation.html#overview-of-compensation-usage","text":"Tip: Make sure the probe X and Y offsets are correctly set as they greatly influence calibration. After setting up the [axis_twist_compensation] module, perform AXIS_TWIST_COMPENSATION_CALIBRATE The calibration wizard will prompt you to measure the probe Z offset at a few points along the bed The calibration defaults to 3 points but you can use the option SAMPLE_COUNT= to use a different number. Adjust your Z offset Perform automatic/probe-based bed tramming operations, such as Screws Tilt Adjust , Z Tilt Adjust etc Home all axis, then perform a Bed Mesh if required Perform a test print, followed by any fine-tuning as desired Tip: Bed temperature and nozzle temperature and size do not seem to have an influence to the calibration process.","title":"Overview of compensation usage"},{"location":"Axis_Twist_Compensation.html#axis_twist_compensation-setup-and-commands","text":"Configuration options for [axis_twist_compensation] can be found in the Configuration Reference . Commands for [axis_twist_compensation] can be found in the G-Codes Reference","title":"[axis_twist_compensation] setup and commands"},{"location":"BLTouch.html","text":"BL-Touch \u00b6 Connexion du BL-Touch \u00b6 Un avertissement avant de commencer : \u00c9vitez de toucher la broche BL-Touch avec vos doigts nus, car elle est tr\u00e8s sensible \u00e0 la graisse des doigts. Et si vous la touchez, soyez tr\u00e8s doux, afin de ne pas plier ou pousser quoi que ce soit. Connectez le connecteur \"servo\" de la BL-Touch \u00e0 une control_pin selon la documentation de la BL-Touch ou celle de votre MCU. En utilisant le c\u00e2blage originel, le fil jaune du c\u00e2blage triple est la control_pin et le fil blanc du c\u00e2blage double est la sensor_pin . Vous devez configurer ces broches en fonction de votre c\u00e2blage. La plupart des dispositifs BL-Touch n\u00e9cessitent un pullup sur la broche du capteur (pr\u00e9fixez le nom de la broche par \"^\"). Par exemple : [bltouch] sensor_pin: ^P1.24 control_pin: P1.26 Si le BL-Touch est utilis\u00e9 pour amener l'axe Z \u00e0 l'origine, r\u00e9glez endstop_pin : probe:z_virtual_endstop et supprimez position_endstop dans la section de configuration [stepper_z] , puis ajoutez une section de configuration [safe_z_home] pour lever l'axe z, ramener les axes xy \u00e0 la position d'origine, se d\u00e9placer au centre du lit et ramener l'axe z \u00e0 la position d'origine. Par exemple : [safe_z_home] home_xy_position: 100, 100 # Change coordinates to the center of your print bed speed: 50 z_hop: 10 # Move up 10mm z_hop_speed: 5 Il est important que le mouvement z_hop dans safe_z_home soit suffisamment \u00e9lev\u00e9 pour que la sonde ne heurte rien, m\u00eame si la broche de la sonde se trouve dans son \u00e9tat le plus bas. Tests initiaux \u00b6 Avant de poursuivre, v\u00e9rifiez que la BL-Touch est mont\u00e9e \u00e0 la bonne hauteur, la tige doit se trouver \u00e0 environ 2 mm au-dessus de la buse lorsqu'elle est r\u00e9tract\u00e9e Lorsque vous mettez l'imprimante sous tension, la sonde BL-Touch doit effectuer un auto-test en sortant et r\u00e9tractant le pointeau plusieurs Une fois l'auto-test termin\u00e9, le pointeau doit \u00eatre r\u00e9tract\u00e9 et le voyant rouge de la sonde doit \u00eatre allum\u00e9. En cas d'erreur, par exemple si la sonde clignote en rouge ou si le pointeau est en bas au lieu d'\u00eatre en haut, veuillez \u00e9teindre l'imprimante et v\u00e9rifier le c\u00e2blage et la configuration. Si tout ce qui pr\u00e9c\u00e8de semble bon, il est temps de tester que la broche de contr\u00f4le fonctionne correctement. Ex\u00e9cutez d'abord BLTOUCH_DEBUG COMMAND=pin_down dans votre terminal d'imprimante. V\u00e9rifiez que le pointeau se d\u00e9place vers le bas et que la LED rouge de la sonde s'\u00e9teint. Si ce n'est pas le cas, v\u00e9rifiez \u00e0 nouveau votre c\u00e2blage et votre configuration. Ensuite, lancez une commande BLTOUCH_DEBUG COMMAND=pin_up , v\u00e9rifiez que le pointeau se r\u00e9tracte et que la lumi\u00e8re rouge s'allume \u00e0 nouveau. Si elle clignote, il y a un probl\u00e8me. L'\u00e9tape suivante consiste \u00e0 confirmer que la tige du capteur fonctionne correctement. Ex\u00e9cutez BLTOUCH_DEBUG COMMAND=pin_down , v\u00e9rifiez que le pointeau se d\u00e9place vers le bas, ex\u00e9cutez BLTOUCH_DEBUG COMMAND=touch_mode , ex\u00e9cutez QUERY_PROBE , et v\u00e9rifiez que la commande rapporte \"probe : open\". Ensuite, tout en poussant l\u00e9g\u00e8rement le pointeau vers le haut avec l'ongle de votre doigt, ex\u00e9cutez \u00e0 nouveau QUERY_PROBE . V\u00e9rifiez que la commande rapporte \"probe : TRIGGERED\". Si l'une ou l'autre des requ\u00eates ne donne pas le bon message, cela indique g\u00e9n\u00e9ralement un c\u00e2blage ou une configuration incorrecte (certains clones peuvent n\u00e9cessiter une manipulation sp\u00e9ciale). A la fin de ce test, ex\u00e9cutez BLTOUCH_DEBUG COMMAND=pin_up et v\u00e9rifiez que le pointeau se d\u00e9place vers le haut. Apr\u00e8s avoir effectu\u00e9 les tests de la broche de contr\u00f4le et de la broche de d\u00e9tection du BL-Touch, il est maintenant temps de tester le palpage, mais avec une petite astuce. Au lieu de laisser le pointeau de la sonde toucher le lit d'impression, laissez-le toucher l'ongle de votre doigt. Positionnez la t\u00eate d'impression loin du lit, \u00e9mettez un G28 (ou PROBE si vous n'utilisez pas probe:z_virtual_endstop), attendez que la t\u00eate d'impression commence \u00e0 descendre, et arr\u00eatez le mouvement en touchant tr\u00e8s doucement le pointeau avec votre ongle. Il se peut que vous deviez le faire deux fois, car la configuration par d\u00e9faut de l'autoguidage sonde deux fois. Pr\u00e9parez-vous \u00e0 \u00e9teindre l'imprimante si elle ne s'arr\u00eate pas lorsque vous touchez le pointeau. Si ce test a r\u00e9ussi, faites un autre G28 (ou PROBE ) mais cette fois-ci laissez-le toucher le lit comme il se doit. BL-Touch d\u00e9faillant \u00b6 Une fois que le BL-Touch est dans un \u00e9tat incoh\u00e9rent, il se met \u00e0 clignoter en rouge. Vous pouvez le forcer \u00e0 quitter cet \u00e9tat en \u00e9mettant : BLTOUCH_DEBUG COMMAND=reset Cela peut se produire si son \u00e9talonnage est interrompu par un blocage de l'extraction du pointeau. Cependant, il se peut \u00e9galement que le BL-Touch ne soit plus capable de se calibrer lui-m\u00eame. Cela se produit si la vis situ\u00e9e sur le dessus est mal positionn\u00e9e ou si le noyau magn\u00e9tique \u00e0 l'int\u00e9rieur de la tige du pointeau a boug\u00e9. S'il s'est d\u00e9plac\u00e9 vers le haut au point de coller \u00e0 la vis, il se peut que le BL-Touch ne soit plus capable de lib\u00e9rer sa tige. Dans ce cas, vous devez ouvrir la vis et utiliser un stylo \u00e0 bille pour le remettre doucement en place. R\u00e9introduisez la tige dans le BL-Touch de fa\u00e7on \u00e0 ce qu'elle tombe dans la position extraite. R\u00e9ajustez d\u00e9licatement la vis sans t\u00eate du dessus. Vous devez trouver la juste position pour qu'elle soit capable d'abaisser et de relever la tige et que la lumi\u00e8re rouge s'allume et s'\u00e9teigne. Utilisez les commandes reset , pin_up et pin_down pour y parvenir. \"Clones\" du BL-Touch \u00b6 De nombreux \"clones\" BL-Touch fonctionnent correctement avec Klipper en utilisant la configuration par d\u00e9faut. Cependant, certains \"clones\" peuvent ne pas supporter la commande QUERY_PROBE et certains autres \"clones\" peuvent n\u00e9cessiter la configuration de pin_up_reports_not_triggered ou pin_up_touch_mode_reports_triggered . Important ! Ne configurez pas pin_up_reports_not_triggered ou pin_up_touch_mode_reports_triggered \u00e0 False sans suivre ces instructions. Ne configurez pas l'une ou l'autre de ces options sur False sur un v\u00e9ritable BL-Touch. Une configuration incorrecte de ces param\u00e8tres sur False peut augmenter le temps de palpage et peut augmenter le risque d'endommager l'imprimante. Certains \"clones\" ne supportent pas le touch_mode et par cons\u00e9quent la commande QUERY_PROBE ne fonctionne pas. Malgr\u00e9 cela, il est possible d'effectuer un palpage et une mise \u00e0 l'origine avec ces dispositifs. Sur ces dispositifs, la commande QUERY_PROBE pendant les tests initiaux n'aboutira pas, mais le test suivant G28 (ou PROBE ) aboutira. Il est possible d'utiliser ces \"clones\" avec Klipper tant que l'on n'utilise pas la commande QUERY_PROBE et que l'on n'active pas la fonction probe_with_touch_mode . Certains \"clones\" sont incapables d'effectuer le test de v\u00e9rification du capteur interne de Klipper. Sur ces appareils, les tentatives de mise \u00e0 l'origine ou de palpage peuvent entra\u00eener le signalement par Klipper de l'erreur \"BLTouch failed to verify sensor state\". Si cela se produit, ex\u00e9cutez manuellement les \u00e9tapes pour confirmer que la broche du capteur fonctionne comme d\u00e9crit dans la section tests initiaux . Si les commandes QUERY_PROBE de ce test produisent toujours les r\u00e9sultats attendus et que l'erreur \"BLTouch failed to verify sensor state\" se produit toujours, il peut \u00eatre n\u00e9cessaire de mettre pin_up_touch_mode_reports_triggered \u00e0 False dans le fichier de configuration de Klipper. Un nombre rare d'anciens \"clones\" sont incapables de signaler qu'ils ont r\u00e9ussi \u00e0 relever leur pointeau. Sur ces appareils, Klipper signalera une erreur \"BLTouch failed to raise probe\" apr\u00e8s chaque tentative de retour \u00e0 l'origine ou de palpage. On peut tester ces appareils - \u00e9loigner la t\u00eate du lit, ex\u00e9cuter BLTOUCH_DEBUG COMMAND=pin_down , v\u00e9rifier que le pointeau s'est d\u00e9plac\u00e9 vers le bas, ex\u00e9cuter QUERY_PROBE , v\u00e9rifier que la commande rapporte \"probe : open\", ex\u00e9cuter BLTOUCH_DEBUG COMMAND=pin_up , v\u00e9rifier que le pointeau s'est d\u00e9plac\u00e9 vers le haut, et ex\u00e9cuter QUERY_PROBE . Si la broche reste en haut, que le dispositif n'entre pas dans un \u00e9tat d'erreur, et que la premi\u00e8re requ\u00eate rapporte \"probe : open\" alors que la seconde rapporte \"probe : TRIGGERED\" alors cela indique que pin_up_reports_not_triggered doit \u00eatre mis \u00e0 False dans le fichier de configuration de Klipper. BL-Touch v3 \u00b6 Certains BL-Touch v3.0 et BL-Touch 3.1 peuvent n\u00e9cessiter la configuration de probe_with_touch_mode dans le fichier de configuration de l'imprimante. Si le fil de signal du BL-Touch v3.0 est connect\u00e9 \u00e0 une broche d'arr\u00eat (avec un condensateur de filtrage du bruit), il se peut que le BL-Touch v3.0 ne soit pas capable d'envoyer un signal de mani\u00e8re constante pendant la recherche de l'origine et le palpage. Si les commandes QUERY_PROBE dans la section des tests initiaux produisent toujours les r\u00e9sultats attendus, mais que la t\u00eate de l'outil ne s'arr\u00eate toujours pas pendant les commandes G28/PROBE, alors cela indique ce probl\u00e8me. Une solution de contournement est de d\u00e9finir probe_with_touch_mode : True dans le fichier de configuration. Le BL-Touch v3.1 peut entrer incorrectement dans un \u00e9tat d'erreur apr\u00e8s une tentative de sondage r\u00e9ussie. Les sympt\u00f4mes sont une lumi\u00e8re clignotante occasionnelle sur le BL-Touch v3.1 qui dure quelques secondes apr\u00e8s qu'il ait r\u00e9ussi \u00e0 entrer en contact avec le lit. Klipper devrait effacer cette erreur automatiquement et elle est g\u00e9n\u00e9ralement inoffensive. Cependant, on peut d\u00e9finir probe_with_touch_mode dans le fichier de configuration pour \u00e9viter ce probl\u00e8me. Important ! Certains \"clones\" ainsi que le BL-Touch v2.0 (et ant\u00e9rieur) peuvent avoir une pr\u00e9cision r\u00e9duite lorsque probe_with_touch_mode est r\u00e9gl\u00e9 sur True. Le r\u00e9glage de cette valeur sur True augmente \u00e9galement le temps n\u00e9cessaire au d\u00e9ploiement de la sonde. Si vous configurez cette valeur sur un dispositif BL-Touch \"clone\" ou plus ancien, assurez-vous de tester la pr\u00e9cision de la sonde avant et apr\u00e8s avoir d\u00e9fini cette valeur (utilisez la commande PROBE_ACCURACY pour tester). Multi-palpages sans r\u00e9traction du pointeau \u00b6 Par d\u00e9faut, Klipper d\u00e9ploie le pointeau au d\u00e9but de chaque tentative de mesure et le r\u00e9tracte ensuite. Ce d\u00e9ploiement et cette r\u00e9traction r\u00e9p\u00e9titifs du pointeau peuvent augmenter la dur\u00e9e totale des s\u00e9quences d'\u00e9talonnage impliquant de nombreuses mesures du plateau. Klipper permet de laisser le pointeau d\u00e9ploy\u00e9 entre deux mesures cons\u00e9cutives, ce qui peut r\u00e9duire la dur\u00e9e totale des mesures. Ce mode est activ\u00e9 en configurant stow_on_each_sample \u00e0 False dans le fichier de configuration. Important ! Si vous r\u00e9glez la valeur Stow_on_each_sample sur False, Klipper peut effectuer des mouvements horizontaux de la t\u00eate de l'outil durant le d\u00e9ploiement du palpeur. Assurez-vous que toutes les op\u00e9rations de palpage ont un d\u00e9gagement Z suffisant avant de r\u00e9gler cette valeur sur False. Si l'espace est insuffisant, un mouvement horizontal peut faire en sorte que le pointeau s'accroche \u00e0 une obstruction et endommager l'imprimante. Important ! Il est recommand\u00e9 d'utiliser probe_with_touch_mode configur\u00e9 \u00e0 True lorsque vous utilisez stow_on_each_sample configur\u00e9 \u00e0 False. Certains \"clones\" peuvent ne pas d\u00e9tecter un contact ult\u00e9rieur du lit si probe_with_touch_mode n'est pas configur\u00e9. Sur tous les dispositifs, l'utilisation de la combinaison de ces deux param\u00e8tres simplifie la signalisation de l'appareil, am\u00e9liorant la stabilit\u00e9 globale. Notez cependant que certains \"clones\" ainsi que le BL-Touch v2.0 (et ant\u00e9rieurs) peuvent avoir une pr\u00e9cision r\u00e9duite lorsque probe_with_touch_mode est r\u00e9gl\u00e9 sur True. Sur ces appareils, c'est une bonne id\u00e9e de tester la pr\u00e9cision de la sonde avant et apr\u00e8s avoir r\u00e9gl\u00e9 probe_with_touch_mode (utilisez la commande PROBE_ACCURACY pour tester). \u00c9talonnage des d\u00e9calages du BL-Touch \u00b6 Suivez les instructions du guide Calibration de la sonde pour d\u00e9finir les param\u00e8tres de configuration x_offset, y_offset et z_offset. C'est une bonne id\u00e9e de v\u00e9rifier que le d\u00e9calage Z est proche de 1mm. Si ce n'est pas le cas, vous devrez probablement d\u00e9placer le dispositif vers le haut ou vers le bas pour r\u00e9soudre ce probl\u00e8me. Vous voulez qu'il se d\u00e9clenche bien avant que la buse ne touche le lit, afin qu'un \u00e9ventuel filament coinc\u00e9 ou un lit d\u00e9form\u00e9 n'affecte pas l'action du BL-Touch. Mais en m\u00eame temps, vous voulez que la position r\u00e9tract\u00e9e soit aussi loin que possible au-dessus de la buse pour \u00e9viter qu'elle ne touche les pi\u00e8ces imprim\u00e9es. Si un ajustement est effectu\u00e9 sur la position du BL-Touch, recommencez les \u00e9tapes d'\u00e9talonnage de celui-ci. Mode de sortie du BL-Touch \u00b6 Un BL-Touch V3.0 accepte le r\u00e9glage d'un mode de sortie 5V ou OPEN-DRAIN, un BL-Touch V3.1 le supporte aussi et peut \u00e9galement le stocker dans son EEPROM interne. Si votre carte contr\u00f4leur a besoin du niveau logique haut de 5V du mode 5V, vous pouvez r\u00e9gler le param\u00e8tre 'set_output_mode' dans la section [bltouch] du fichier de configuration de l'imprimante sur \"5V\". N'utilisez le mode 5V que si la ligne d'entr\u00e9e de votre carte contr\u00f4leur est tol\u00e9rante \u00e0 cette tension (5V). C'est pourquoi la configuration par d\u00e9faut de ces versions de BL-Touch est le mode OPEN-DRAIN. Vous pourriez potentiellement endommager le CPU de votre carte contr\u00f4leur En r\u00e9sum\u00e9 : Si une carte contr\u00f4leur a besoin d'un mode 5V ET qu'elle est tol\u00e9rante \u00e0 5V sur sa ligne de signal d'entr\u00e9e ET si vous avez un BL-Touch Smart V3.0, vous devez utiliser le param\u00e8tre 'set_output_mode : 5V' pour assurer ce r\u00e9glage \u00e0 chaque d\u00e9marrage, puisque la sonde ne peut pas se souvenir du r\u00e9glage n\u00e9cessaire. vous avez un BL-Touch Smart V3.1, vous avez le choix d'utiliser 'set_output_mode : 5V' ou de m\u00e9moriser le mode une fois pour toutes en utilisant une commande 'BLTOUCH_STORE MODE=5V' manuellement et sans plus utiliser le param\u00e8tre 'set_output_mode:'. vous avez une autre sonde : Certaines sondes ont une trace sur la carte de circuit imprim\u00e9 \u00e0 couper ou un cavalier \u00e0 r\u00e9gler afin de d\u00e9finir (de fa\u00e7on permanente) le mode de sortie. Dans ce cas, omettez compl\u00e8tement le param\u00e8tre 'set_output_mode'. Si vous avez une version V3.1, n'automatisez pas ou ne r\u00e9p\u00e9tez pas la m\u00e9morisation du mode de sortie afin d'\u00e9viter d'user l'EEPROM de la sonde. L'EEPROM du BLTouch permet environ 100.000 mises \u00e0 jour. 100 mises \u00e0 jour par jour repr\u00e9sentent environ 3 ans de fonctionnement avant l'usure de la m\u00e9moire. Ainsi, le stockage du mode de sortie dans la V3.1 est con\u00e7u par le vendeur pour \u00eatre une op\u00e9ration compliqu\u00e9e (le d\u00e9faut d'usine \u00e9tant un mode s\u00fbr OPEN DRAIN) et n'est pas adapt\u00e9 pour \u00eatre \u00e9mis de mani\u00e8re r\u00e9p\u00e9t\u00e9e par un trancheur, une macro ou autre, il est pr\u00e9f\u00e9rable de ne l'utiliser que lors de la premi\u00e8re int\u00e9gration de la sonde dans l'\u00e9lectronique de l'imprimante.","title":"BL-Touch"},{"location":"BLTouch.html#bl-touch","text":"","title":"BL-Touch"},{"location":"BLTouch.html#connexion-du-bl-touch","text":"Un avertissement avant de commencer : \u00c9vitez de toucher la broche BL-Touch avec vos doigts nus, car elle est tr\u00e8s sensible \u00e0 la graisse des doigts. Et si vous la touchez, soyez tr\u00e8s doux, afin de ne pas plier ou pousser quoi que ce soit. Connectez le connecteur \"servo\" de la BL-Touch \u00e0 une control_pin selon la documentation de la BL-Touch ou celle de votre MCU. En utilisant le c\u00e2blage originel, le fil jaune du c\u00e2blage triple est la control_pin et le fil blanc du c\u00e2blage double est la sensor_pin . Vous devez configurer ces broches en fonction de votre c\u00e2blage. La plupart des dispositifs BL-Touch n\u00e9cessitent un pullup sur la broche du capteur (pr\u00e9fixez le nom de la broche par \"^\"). Par exemple : [bltouch] sensor_pin: ^P1.24 control_pin: P1.26 Si le BL-Touch est utilis\u00e9 pour amener l'axe Z \u00e0 l'origine, r\u00e9glez endstop_pin : probe:z_virtual_endstop et supprimez position_endstop dans la section de configuration [stepper_z] , puis ajoutez une section de configuration [safe_z_home] pour lever l'axe z, ramener les axes xy \u00e0 la position d'origine, se d\u00e9placer au centre du lit et ramener l'axe z \u00e0 la position d'origine. Par exemple : [safe_z_home] home_xy_position: 100, 100 # Change coordinates to the center of your print bed speed: 50 z_hop: 10 # Move up 10mm z_hop_speed: 5 Il est important que le mouvement z_hop dans safe_z_home soit suffisamment \u00e9lev\u00e9 pour que la sonde ne heurte rien, m\u00eame si la broche de la sonde se trouve dans son \u00e9tat le plus bas.","title":"Connexion du BL-Touch"},{"location":"BLTouch.html#tests-initiaux","text":"Avant de poursuivre, v\u00e9rifiez que la BL-Touch est mont\u00e9e \u00e0 la bonne hauteur, la tige doit se trouver \u00e0 environ 2 mm au-dessus de la buse lorsqu'elle est r\u00e9tract\u00e9e Lorsque vous mettez l'imprimante sous tension, la sonde BL-Touch doit effectuer un auto-test en sortant et r\u00e9tractant le pointeau plusieurs Une fois l'auto-test termin\u00e9, le pointeau doit \u00eatre r\u00e9tract\u00e9 et le voyant rouge de la sonde doit \u00eatre allum\u00e9. En cas d'erreur, par exemple si la sonde clignote en rouge ou si le pointeau est en bas au lieu d'\u00eatre en haut, veuillez \u00e9teindre l'imprimante et v\u00e9rifier le c\u00e2blage et la configuration. Si tout ce qui pr\u00e9c\u00e8de semble bon, il est temps de tester que la broche de contr\u00f4le fonctionne correctement. Ex\u00e9cutez d'abord BLTOUCH_DEBUG COMMAND=pin_down dans votre terminal d'imprimante. V\u00e9rifiez que le pointeau se d\u00e9place vers le bas et que la LED rouge de la sonde s'\u00e9teint. Si ce n'est pas le cas, v\u00e9rifiez \u00e0 nouveau votre c\u00e2blage et votre configuration. Ensuite, lancez une commande BLTOUCH_DEBUG COMMAND=pin_up , v\u00e9rifiez que le pointeau se r\u00e9tracte et que la lumi\u00e8re rouge s'allume \u00e0 nouveau. Si elle clignote, il y a un probl\u00e8me. L'\u00e9tape suivante consiste \u00e0 confirmer que la tige du capteur fonctionne correctement. Ex\u00e9cutez BLTOUCH_DEBUG COMMAND=pin_down , v\u00e9rifiez que le pointeau se d\u00e9place vers le bas, ex\u00e9cutez BLTOUCH_DEBUG COMMAND=touch_mode , ex\u00e9cutez QUERY_PROBE , et v\u00e9rifiez que la commande rapporte \"probe : open\". Ensuite, tout en poussant l\u00e9g\u00e8rement le pointeau vers le haut avec l'ongle de votre doigt, ex\u00e9cutez \u00e0 nouveau QUERY_PROBE . V\u00e9rifiez que la commande rapporte \"probe : TRIGGERED\". Si l'une ou l'autre des requ\u00eates ne donne pas le bon message, cela indique g\u00e9n\u00e9ralement un c\u00e2blage ou une configuration incorrecte (certains clones peuvent n\u00e9cessiter une manipulation sp\u00e9ciale). A la fin de ce test, ex\u00e9cutez BLTOUCH_DEBUG COMMAND=pin_up et v\u00e9rifiez que le pointeau se d\u00e9place vers le haut. Apr\u00e8s avoir effectu\u00e9 les tests de la broche de contr\u00f4le et de la broche de d\u00e9tection du BL-Touch, il est maintenant temps de tester le palpage, mais avec une petite astuce. Au lieu de laisser le pointeau de la sonde toucher le lit d'impression, laissez-le toucher l'ongle de votre doigt. Positionnez la t\u00eate d'impression loin du lit, \u00e9mettez un G28 (ou PROBE si vous n'utilisez pas probe:z_virtual_endstop), attendez que la t\u00eate d'impression commence \u00e0 descendre, et arr\u00eatez le mouvement en touchant tr\u00e8s doucement le pointeau avec votre ongle. Il se peut que vous deviez le faire deux fois, car la configuration par d\u00e9faut de l'autoguidage sonde deux fois. Pr\u00e9parez-vous \u00e0 \u00e9teindre l'imprimante si elle ne s'arr\u00eate pas lorsque vous touchez le pointeau. Si ce test a r\u00e9ussi, faites un autre G28 (ou PROBE ) mais cette fois-ci laissez-le toucher le lit comme il se doit.","title":"Tests initiaux"},{"location":"BLTouch.html#bl-touch-defaillant","text":"Une fois que le BL-Touch est dans un \u00e9tat incoh\u00e9rent, il se met \u00e0 clignoter en rouge. Vous pouvez le forcer \u00e0 quitter cet \u00e9tat en \u00e9mettant : BLTOUCH_DEBUG COMMAND=reset Cela peut se produire si son \u00e9talonnage est interrompu par un blocage de l'extraction du pointeau. Cependant, il se peut \u00e9galement que le BL-Touch ne soit plus capable de se calibrer lui-m\u00eame. Cela se produit si la vis situ\u00e9e sur le dessus est mal positionn\u00e9e ou si le noyau magn\u00e9tique \u00e0 l'int\u00e9rieur de la tige du pointeau a boug\u00e9. S'il s'est d\u00e9plac\u00e9 vers le haut au point de coller \u00e0 la vis, il se peut que le BL-Touch ne soit plus capable de lib\u00e9rer sa tige. Dans ce cas, vous devez ouvrir la vis et utiliser un stylo \u00e0 bille pour le remettre doucement en place. R\u00e9introduisez la tige dans le BL-Touch de fa\u00e7on \u00e0 ce qu'elle tombe dans la position extraite. R\u00e9ajustez d\u00e9licatement la vis sans t\u00eate du dessus. Vous devez trouver la juste position pour qu'elle soit capable d'abaisser et de relever la tige et que la lumi\u00e8re rouge s'allume et s'\u00e9teigne. Utilisez les commandes reset , pin_up et pin_down pour y parvenir.","title":"BL-Touch d\u00e9faillant"},{"location":"BLTouch.html#clones-du-bl-touch","text":"De nombreux \"clones\" BL-Touch fonctionnent correctement avec Klipper en utilisant la configuration par d\u00e9faut. Cependant, certains \"clones\" peuvent ne pas supporter la commande QUERY_PROBE et certains autres \"clones\" peuvent n\u00e9cessiter la configuration de pin_up_reports_not_triggered ou pin_up_touch_mode_reports_triggered . Important ! Ne configurez pas pin_up_reports_not_triggered ou pin_up_touch_mode_reports_triggered \u00e0 False sans suivre ces instructions. Ne configurez pas l'une ou l'autre de ces options sur False sur un v\u00e9ritable BL-Touch. Une configuration incorrecte de ces param\u00e8tres sur False peut augmenter le temps de palpage et peut augmenter le risque d'endommager l'imprimante. Certains \"clones\" ne supportent pas le touch_mode et par cons\u00e9quent la commande QUERY_PROBE ne fonctionne pas. Malgr\u00e9 cela, il est possible d'effectuer un palpage et une mise \u00e0 l'origine avec ces dispositifs. Sur ces dispositifs, la commande QUERY_PROBE pendant les tests initiaux n'aboutira pas, mais le test suivant G28 (ou PROBE ) aboutira. Il est possible d'utiliser ces \"clones\" avec Klipper tant que l'on n'utilise pas la commande QUERY_PROBE et que l'on n'active pas la fonction probe_with_touch_mode . Certains \"clones\" sont incapables d'effectuer le test de v\u00e9rification du capteur interne de Klipper. Sur ces appareils, les tentatives de mise \u00e0 l'origine ou de palpage peuvent entra\u00eener le signalement par Klipper de l'erreur \"BLTouch failed to verify sensor state\". Si cela se produit, ex\u00e9cutez manuellement les \u00e9tapes pour confirmer que la broche du capteur fonctionne comme d\u00e9crit dans la section tests initiaux . Si les commandes QUERY_PROBE de ce test produisent toujours les r\u00e9sultats attendus et que l'erreur \"BLTouch failed to verify sensor state\" se produit toujours, il peut \u00eatre n\u00e9cessaire de mettre pin_up_touch_mode_reports_triggered \u00e0 False dans le fichier de configuration de Klipper. Un nombre rare d'anciens \"clones\" sont incapables de signaler qu'ils ont r\u00e9ussi \u00e0 relever leur pointeau. Sur ces appareils, Klipper signalera une erreur \"BLTouch failed to raise probe\" apr\u00e8s chaque tentative de retour \u00e0 l'origine ou de palpage. On peut tester ces appareils - \u00e9loigner la t\u00eate du lit, ex\u00e9cuter BLTOUCH_DEBUG COMMAND=pin_down , v\u00e9rifier que le pointeau s'est d\u00e9plac\u00e9 vers le bas, ex\u00e9cuter QUERY_PROBE , v\u00e9rifier que la commande rapporte \"probe : open\", ex\u00e9cuter BLTOUCH_DEBUG COMMAND=pin_up , v\u00e9rifier que le pointeau s'est d\u00e9plac\u00e9 vers le haut, et ex\u00e9cuter QUERY_PROBE . Si la broche reste en haut, que le dispositif n'entre pas dans un \u00e9tat d'erreur, et que la premi\u00e8re requ\u00eate rapporte \"probe : open\" alors que la seconde rapporte \"probe : TRIGGERED\" alors cela indique que pin_up_reports_not_triggered doit \u00eatre mis \u00e0 False dans le fichier de configuration de Klipper.","title":"\"Clones\" du BL-Touch"},{"location":"BLTouch.html#bl-touch-v3","text":"Certains BL-Touch v3.0 et BL-Touch 3.1 peuvent n\u00e9cessiter la configuration de probe_with_touch_mode dans le fichier de configuration de l'imprimante. Si le fil de signal du BL-Touch v3.0 est connect\u00e9 \u00e0 une broche d'arr\u00eat (avec un condensateur de filtrage du bruit), il se peut que le BL-Touch v3.0 ne soit pas capable d'envoyer un signal de mani\u00e8re constante pendant la recherche de l'origine et le palpage. Si les commandes QUERY_PROBE dans la section des tests initiaux produisent toujours les r\u00e9sultats attendus, mais que la t\u00eate de l'outil ne s'arr\u00eate toujours pas pendant les commandes G28/PROBE, alors cela indique ce probl\u00e8me. Une solution de contournement est de d\u00e9finir probe_with_touch_mode : True dans le fichier de configuration. Le BL-Touch v3.1 peut entrer incorrectement dans un \u00e9tat d'erreur apr\u00e8s une tentative de sondage r\u00e9ussie. Les sympt\u00f4mes sont une lumi\u00e8re clignotante occasionnelle sur le BL-Touch v3.1 qui dure quelques secondes apr\u00e8s qu'il ait r\u00e9ussi \u00e0 entrer en contact avec le lit. Klipper devrait effacer cette erreur automatiquement et elle est g\u00e9n\u00e9ralement inoffensive. Cependant, on peut d\u00e9finir probe_with_touch_mode dans le fichier de configuration pour \u00e9viter ce probl\u00e8me. Important ! Certains \"clones\" ainsi que le BL-Touch v2.0 (et ant\u00e9rieur) peuvent avoir une pr\u00e9cision r\u00e9duite lorsque probe_with_touch_mode est r\u00e9gl\u00e9 sur True. Le r\u00e9glage de cette valeur sur True augmente \u00e9galement le temps n\u00e9cessaire au d\u00e9ploiement de la sonde. Si vous configurez cette valeur sur un dispositif BL-Touch \"clone\" ou plus ancien, assurez-vous de tester la pr\u00e9cision de la sonde avant et apr\u00e8s avoir d\u00e9fini cette valeur (utilisez la commande PROBE_ACCURACY pour tester).","title":"BL-Touch v3"},{"location":"BLTouch.html#multi-palpages-sans-retraction-du-pointeau","text":"Par d\u00e9faut, Klipper d\u00e9ploie le pointeau au d\u00e9but de chaque tentative de mesure et le r\u00e9tracte ensuite. Ce d\u00e9ploiement et cette r\u00e9traction r\u00e9p\u00e9titifs du pointeau peuvent augmenter la dur\u00e9e totale des s\u00e9quences d'\u00e9talonnage impliquant de nombreuses mesures du plateau. Klipper permet de laisser le pointeau d\u00e9ploy\u00e9 entre deux mesures cons\u00e9cutives, ce qui peut r\u00e9duire la dur\u00e9e totale des mesures. Ce mode est activ\u00e9 en configurant stow_on_each_sample \u00e0 False dans le fichier de configuration. Important ! Si vous r\u00e9glez la valeur Stow_on_each_sample sur False, Klipper peut effectuer des mouvements horizontaux de la t\u00eate de l'outil durant le d\u00e9ploiement du palpeur. Assurez-vous que toutes les op\u00e9rations de palpage ont un d\u00e9gagement Z suffisant avant de r\u00e9gler cette valeur sur False. Si l'espace est insuffisant, un mouvement horizontal peut faire en sorte que le pointeau s'accroche \u00e0 une obstruction et endommager l'imprimante. Important ! Il est recommand\u00e9 d'utiliser probe_with_touch_mode configur\u00e9 \u00e0 True lorsque vous utilisez stow_on_each_sample configur\u00e9 \u00e0 False. Certains \"clones\" peuvent ne pas d\u00e9tecter un contact ult\u00e9rieur du lit si probe_with_touch_mode n'est pas configur\u00e9. Sur tous les dispositifs, l'utilisation de la combinaison de ces deux param\u00e8tres simplifie la signalisation de l'appareil, am\u00e9liorant la stabilit\u00e9 globale. Notez cependant que certains \"clones\" ainsi que le BL-Touch v2.0 (et ant\u00e9rieurs) peuvent avoir une pr\u00e9cision r\u00e9duite lorsque probe_with_touch_mode est r\u00e9gl\u00e9 sur True. Sur ces appareils, c'est une bonne id\u00e9e de tester la pr\u00e9cision de la sonde avant et apr\u00e8s avoir r\u00e9gl\u00e9 probe_with_touch_mode (utilisez la commande PROBE_ACCURACY pour tester).","title":"Multi-palpages sans r\u00e9traction du pointeau"},{"location":"BLTouch.html#etalonnage-des-decalages-du-bl-touch","text":"Suivez les instructions du guide Calibration de la sonde pour d\u00e9finir les param\u00e8tres de configuration x_offset, y_offset et z_offset. C'est une bonne id\u00e9e de v\u00e9rifier que le d\u00e9calage Z est proche de 1mm. Si ce n'est pas le cas, vous devrez probablement d\u00e9placer le dispositif vers le haut ou vers le bas pour r\u00e9soudre ce probl\u00e8me. Vous voulez qu'il se d\u00e9clenche bien avant que la buse ne touche le lit, afin qu'un \u00e9ventuel filament coinc\u00e9 ou un lit d\u00e9form\u00e9 n'affecte pas l'action du BL-Touch. Mais en m\u00eame temps, vous voulez que la position r\u00e9tract\u00e9e soit aussi loin que possible au-dessus de la buse pour \u00e9viter qu'elle ne touche les pi\u00e8ces imprim\u00e9es. Si un ajustement est effectu\u00e9 sur la position du BL-Touch, recommencez les \u00e9tapes d'\u00e9talonnage de celui-ci.","title":"\u00c9talonnage des d\u00e9calages du BL-Touch"},{"location":"BLTouch.html#mode-de-sortie-du-bl-touch","text":"Un BL-Touch V3.0 accepte le r\u00e9glage d'un mode de sortie 5V ou OPEN-DRAIN, un BL-Touch V3.1 le supporte aussi et peut \u00e9galement le stocker dans son EEPROM interne. Si votre carte contr\u00f4leur a besoin du niveau logique haut de 5V du mode 5V, vous pouvez r\u00e9gler le param\u00e8tre 'set_output_mode' dans la section [bltouch] du fichier de configuration de l'imprimante sur \"5V\". N'utilisez le mode 5V que si la ligne d'entr\u00e9e de votre carte contr\u00f4leur est tol\u00e9rante \u00e0 cette tension (5V). C'est pourquoi la configuration par d\u00e9faut de ces versions de BL-Touch est le mode OPEN-DRAIN. Vous pourriez potentiellement endommager le CPU de votre carte contr\u00f4leur En r\u00e9sum\u00e9 : Si une carte contr\u00f4leur a besoin d'un mode 5V ET qu'elle est tol\u00e9rante \u00e0 5V sur sa ligne de signal d'entr\u00e9e ET si vous avez un BL-Touch Smart V3.0, vous devez utiliser le param\u00e8tre 'set_output_mode : 5V' pour assurer ce r\u00e9glage \u00e0 chaque d\u00e9marrage, puisque la sonde ne peut pas se souvenir du r\u00e9glage n\u00e9cessaire. vous avez un BL-Touch Smart V3.1, vous avez le choix d'utiliser 'set_output_mode : 5V' ou de m\u00e9moriser le mode une fois pour toutes en utilisant une commande 'BLTOUCH_STORE MODE=5V' manuellement et sans plus utiliser le param\u00e8tre 'set_output_mode:'. vous avez une autre sonde : Certaines sondes ont une trace sur la carte de circuit imprim\u00e9 \u00e0 couper ou un cavalier \u00e0 r\u00e9gler afin de d\u00e9finir (de fa\u00e7on permanente) le mode de sortie. Dans ce cas, omettez compl\u00e8tement le param\u00e8tre 'set_output_mode'. Si vous avez une version V3.1, n'automatisez pas ou ne r\u00e9p\u00e9tez pas la m\u00e9morisation du mode de sortie afin d'\u00e9viter d'user l'EEPROM de la sonde. L'EEPROM du BLTouch permet environ 100.000 mises \u00e0 jour. 100 mises \u00e0 jour par jour repr\u00e9sentent environ 3 ans de fonctionnement avant l'usure de la m\u00e9moire. Ainsi, le stockage du mode de sortie dans la V3.1 est con\u00e7u par le vendeur pour \u00eatre une op\u00e9ration compliqu\u00e9e (le d\u00e9faut d'usine \u00e9tant un mode s\u00fbr OPEN DRAIN) et n'est pas adapt\u00e9 pour \u00eatre \u00e9mis de mani\u00e8re r\u00e9p\u00e9t\u00e9e par un trancheur, une macro ou autre, il est pr\u00e9f\u00e9rable de ne l'utiliser que lors de la premi\u00e8re int\u00e9gration de la sonde dans l'\u00e9lectronique de l'imprimante.","title":"Mode de sortie du BL-Touch"},{"location":"Beaglebone.html","text":"Beaglebone \u00b6 Ce document d\u00e9crit le processus d'ex\u00e9cution de Klipper sur un Beaglebone PRU. Construire l'image du syst\u00e8me \u00b6 Commencez par installer l'image Debian 9.9 2019-08-03 4GB SD IoT . Vous pouvez ex\u00e9cuter l'image \u00e0 partir d'une carte micro-SD ou de la carte eMMC int\u00e9gr\u00e9e. Si vous utilisez l'eMMC, installez-la sur l'eMMC maintenant en suivant les instructions du lien ci-dessus. Ensuite, connectez-vous \u00e0 la machine Beaglebone ( ssh debian@beaglebone -- le mot de passe est temppwd ) et installez Klipper en ex\u00e9cutant les commandes suivantes : git clone https://github.com/Klipper3d/klipper ./klipper/scripts/install-beaglebone.sh Installer Octoprint \u00b6 On peut ensuite installer Octoprint : git clone https://github.com/foosel/OctoPrint.git cd OctoPrint/ virtualenv venv ./venv/bin/python setup.py install Et configurer OctoPrint pour qu'il d\u00e9marre au d\u00e9marrage : sudo cp ~/OctoPrint/scripts/octoprint.init /etc/init.d/octoprint sudo chmod +x /etc/init.d/octoprint sudo cp ~/OctoPrint/scripts/octoprint.default /etc/default/octoprint sudo update-rc.d octoprint defaults Il est n\u00e9cessaire de modifier le fichier de configuration d'OctoPrint /etc/default/octoprint . Il faut changer l'utilisateur OCTOPRINT_USER en debian , changer NICELEVEL en 0 , d\u00e9commenter les param\u00e8tres BASEDIR , CONFIGFILE , et DAEMON et changer les r\u00e9f\u00e9rences de /home/pi/ en /home/debian/ : sudo nano /etc/default/octoprint D\u00e9marrez ensuite le service Octoprint : sudo systemctl start octoprint Assurez-vous que le serveur web OctoPrint est accessible - il devrait se trouver \u00e0 l'adresse suivante : http://beaglebone:5000/ Construire le code du microcontr\u00f4leur \u00b6 Pour compiler le code du microcontr\u00f4leur Klipper, commencez par le configurer pour le \"Beaglebone PRU\" : cd ~/klipper/ make menuconfig Pour compiler et installer le nouveau code du microcontr\u00f4leur, ex\u00e9cutez : sudo service klipper stop make flash sudo service klipper start Il est \u00e9galement n\u00e9cessaire de compiler et d'installer le code du microcontr\u00f4leur pour un processus h\u00f4te Linux. Configurez-le une seconde fois pour un \"processus Linux\" : make menuconfig Puis installez \u00e9galement ce code de micro-contr\u00f4leur : sudo service klipper stop make flash sudo service klipper start Configuration restante \u00b6 Terminez l'installation en configurant Klipper et Octoprint en suivant les instructions du document principal Installation . Imprimer avec le Beaglebone \u00b6 Malheureusement, le processeur du Beaglebone peut parfois avoir du mal \u00e0 faire fonctionner OctoPrint correctement. Des blocages d'impression sont connus pour se produire sur des impressions complexes (l'imprimante peut se d\u00e9placer plus rapidement qu'OctoPrint ne peut envoyer de commandes de mouvement). Si cela se produit, envisagez d'utiliser la fonctionnalit\u00e9 \"virtual_sdcard\" (voir R\u00e9f\u00e9rence des configurations pour plus de d\u00e9tails) pour imprimer directement depuis Klipper.","title":"Beaglebone"},{"location":"Beaglebone.html#beaglebone","text":"Ce document d\u00e9crit le processus d'ex\u00e9cution de Klipper sur un Beaglebone PRU.","title":"Beaglebone"},{"location":"Beaglebone.html#construire-limage-du-systeme","text":"Commencez par installer l'image Debian 9.9 2019-08-03 4GB SD IoT . Vous pouvez ex\u00e9cuter l'image \u00e0 partir d'une carte micro-SD ou de la carte eMMC int\u00e9gr\u00e9e. Si vous utilisez l'eMMC, installez-la sur l'eMMC maintenant en suivant les instructions du lien ci-dessus. Ensuite, connectez-vous \u00e0 la machine Beaglebone ( ssh debian@beaglebone -- le mot de passe est temppwd ) et installez Klipper en ex\u00e9cutant les commandes suivantes : git clone https://github.com/Klipper3d/klipper ./klipper/scripts/install-beaglebone.sh","title":"Construire l'image du syst\u00e8me"},{"location":"Beaglebone.html#installer-octoprint","text":"On peut ensuite installer Octoprint : git clone https://github.com/foosel/OctoPrint.git cd OctoPrint/ virtualenv venv ./venv/bin/python setup.py install Et configurer OctoPrint pour qu'il d\u00e9marre au d\u00e9marrage : sudo cp ~/OctoPrint/scripts/octoprint.init /etc/init.d/octoprint sudo chmod +x /etc/init.d/octoprint sudo cp ~/OctoPrint/scripts/octoprint.default /etc/default/octoprint sudo update-rc.d octoprint defaults Il est n\u00e9cessaire de modifier le fichier de configuration d'OctoPrint /etc/default/octoprint . Il faut changer l'utilisateur OCTOPRINT_USER en debian , changer NICELEVEL en 0 , d\u00e9commenter les param\u00e8tres BASEDIR , CONFIGFILE , et DAEMON et changer les r\u00e9f\u00e9rences de /home/pi/ en /home/debian/ : sudo nano /etc/default/octoprint D\u00e9marrez ensuite le service Octoprint : sudo systemctl start octoprint Assurez-vous que le serveur web OctoPrint est accessible - il devrait se trouver \u00e0 l'adresse suivante : http://beaglebone:5000/","title":"Installer Octoprint"},{"location":"Beaglebone.html#construire-le-code-du-microcontroleur","text":"Pour compiler le code du microcontr\u00f4leur Klipper, commencez par le configurer pour le \"Beaglebone PRU\" : cd ~/klipper/ make menuconfig Pour compiler et installer le nouveau code du microcontr\u00f4leur, ex\u00e9cutez : sudo service klipper stop make flash sudo service klipper start Il est \u00e9galement n\u00e9cessaire de compiler et d'installer le code du microcontr\u00f4leur pour un processus h\u00f4te Linux. Configurez-le une seconde fois pour un \"processus Linux\" : make menuconfig Puis installez \u00e9galement ce code de micro-contr\u00f4leur : sudo service klipper stop make flash sudo service klipper start","title":"Construire le code du microcontr\u00f4leur"},{"location":"Beaglebone.html#configuration-restante","text":"Terminez l'installation en configurant Klipper et Octoprint en suivant les instructions du document principal Installation .","title":"Configuration restante"},{"location":"Beaglebone.html#imprimer-avec-le-beaglebone","text":"Malheureusement, le processeur du Beaglebone peut parfois avoir du mal \u00e0 faire fonctionner OctoPrint correctement. Des blocages d'impression sont connus pour se produire sur des impressions complexes (l'imprimante peut se d\u00e9placer plus rapidement qu'OctoPrint ne peut envoyer de commandes de mouvement). Si cela se produit, envisagez d'utiliser la fonctionnalit\u00e9 \"virtual_sdcard\" (voir R\u00e9f\u00e9rence des configurations pour plus de d\u00e9tails) pour imprimer directement depuis Klipper.","title":"Imprimer avec le Beaglebone"},{"location":"Bed_Level.html","text":"Nivellement du lit \u00b6 Le nivellement du lit (parfois aussi appel\u00e9 \u00ab tramage du lit \u00bb) est essentiel pour obtenir des impressions de haute qualit\u00e9. Si un lit n'est pas correctement \"nivel\u00e9\", cela peut entra\u00eener une mauvaise adh\u00e9rence du lit, un \"gauchissement\" et des probl\u00e8mes subtils tout au long de l'impression. Ce document sert de guide pour effectuer le nivellement du lit dans Klipper. Il est important de comprendre l'objectif du nivellement du lit. Si l'imprimante doit aller \u00e0 la position X0 Y0 Z10 pendant une impression, alors l'objectif est que la buse de l'imprimante soit exactement \u00e0 10 mm du lit de l'imprimante. De plus, si l'imprimante doit ensuite aller \u00e0 la position \"X50 Z10\", l'objectif est que la buse maintienne une distance exacte de 10 mm du lit pendant tout ce mouvement horizontal. Afin d'obtenir des impressions de bonne qualit\u00e9, l'imprimante doit \u00eatre calibr\u00e9e de sorte que les distances Z soient pr\u00e9cises \u00e0 environ 25 microns (0,025 mm). Il s'agit d'une petite distance - nettement inf\u00e9rieure \u00e0 la largeur d'un cheveu humain. Cette \u00e9chelle ne peut pas \u00eatre mesur\u00e9e \"\u00e0 l'\u0153il\". Des effets subtils (tels que la dilatation thermique) ont un impact sur les mesures \u00e0 cette \u00e9chelle. Le secret pour obtenir une grande pr\u00e9cision est d'utiliser un processus reproductible et d'utiliser une m\u00e9thode de mise \u00e0 niveau qui tire parti de la haute pr\u00e9cision du propre syst\u00e8me de mouvement de l'imprimante. Choisissez le m\u00e9canisme d'\u00e9talonnage appropri\u00e9 \u00b6 Diff\u00e9rents types d'imprimantes utilisent diff\u00e9rentes m\u00e9thodes pour effectuer le nivellement du lit. A la fin toutes les m\u00e9thodes d\u00e9pendent du \"test du papier\" (d\u00e9crit ci-dessous). Cependant, le processus pour un type particulier d'imprimante est d\u00e9crit dans les autres documents. Avant d'ex\u00e9cuter l'un de ces outils d'\u00e9talonnage, assurez-vous d'ex\u00e9cuter les v\u00e9rifications d\u00e9crites dans le document de v\u00e9rification de la configuration . Il est n\u00e9cessaire de v\u00e9rifier les mouvements de base de l'imprimante avant d'effectuer le nivellement du lit. Pour les imprimantes avec une sonde Z automatique, assurez-vous de calibrer la sonde en suivant les instructions du document R\u00e9glages de la sonde . Pour les imprimantes delta, consultez le document R\u00e9glage des deltas . Pour les imprimantes avec un lit r\u00e9glable par vis et des fin de course Z traditionnels, consultez le document Nivellement manuel . Pendant le calibrage, il peut \u00eatre n\u00e9cessaire de d\u00e9finir la position_min du Z de l'imprimante sur un nombre n\u00e9gatif (par exemple, position_min = -2 ). L'imprimante effectue des v\u00e9rifications des limites m\u00eame pendant les routines d'\u00e9talonnage. La d\u00e9finition d'un nombre n\u00e9gatif permet \u00e0 l'imprimante de se d\u00e9placer en dessous de la position nominale du lit, ce qui peut aider \u00e0 d\u00e9terminer la position r\u00e9elle du lit. Le \"Test du papier\" \u00b6 Le principal m\u00e9canisme d'\u00e9talonnage du lit est le \"test du papier\". Il s'agit de placer un morceau r\u00e9gulier de \"papier pour photocopieuse\" entre le lit et la buse de l'imprimante, puis de d\u00e9placer la buse \u00e0 diff\u00e9rentes hauteurs Z jusqu'\u00e0 ce que l'on ressente une petite friction lorsque l'on pousse le papier d'avant en arri\u00e8re. Il est important de bien comprendre le \"test papier\" m\u00eame si l'on dispose d'une \"sonde Z automatique\". La sonde elle-m\u00eame doit souvent \u00eatre calibr\u00e9e pour obtenir de bons r\u00e9sultats. Cet \u00e9talonnage de la sonde est effectu\u00e9 \u00e0 l'aide de ce \"test papier\". Afin d'effectuer le test du papier, coupez un petit morceau de papier rectangulaire \u00e0 l'aide d'une paire de ciseaux (par exemple, 5x3 cm). Le papier a g\u00e9n\u00e9ralement une \u00e9paisseur d'environ 100 microns (0,100 mm). (L'\u00e9paisseur exacte du papier n'est pas cruciale.) La premi\u00e8re \u00e9tape du test du papier consiste \u00e0 inspecter la buse et le lit de l'imprimante. Assurez-vous qu'il n'y a pas de plastique (ou d'autres d\u00e9bris) sur la buse ou le lit. Inspectez la buse et le lit pour vous assurer qu'il n'y a pas de plastique ! Si l'on imprime toujours sur une bande adh\u00e9sive ou une surface d'impression particuli\u00e8re, on peut alors effectuer le test papier avec cette bande/surface en place. Cependant, notez que le ruban lui-m\u00eame a une \u00e9paisseur et que diff\u00e9rents rubans (ou toute autre surface d'impression) auront un impact sur les mesures Z. Assurez-vous de relancer le test du papier pour mesurer chaque type de surface utilis\u00e9. S'il y a du plastique sur la buse, chauffez la buse et utilisez une pince \u00e0 \u00e9piler en m\u00e9tal pour retirer ce plastique. Attendez que la buse refroidisse compl\u00e8tement \u00e0 temp\u00e9rature ambiante avant de continuer avec le test papier. Pendant que la buse refroidit, utilisez la pince \u00e0 \u00e9piler en m\u00e9tal pour retirer tout plastique susceptible de suinter. Effectuez toujours le test du papier lorsque la buse et le lit sont \u00e0 temp\u00e9rature ambiante ! Lorsque la buse est chauff\u00e9e, sa position (par rapport au lit) change en raison de la dilatation thermique. Cette dilatation thermique est g\u00e9n\u00e9ralement d'environ 100 microns, ce qui correspond \u00e0 peu pr\u00e8s \u00e0 la m\u00eame \u00e9paisseur qu'un morceau de papier d'imprimante typique. La quantit\u00e9 exacte de dilatation thermique n'est pas cruciale, tout comme l'\u00e9paisseur exacte du papier n'est pas cruciale. Commencez par l'hypoth\u00e8se que les deux sont \u00e9gaux (voir ci-dessous pour une m\u00e9thode de d\u00e9termination de la diff\u00e9rence entre les deux distances). Il peut sembler \u00e9tonnant de calibrer la distance \u00e0 temp\u00e9rature ambiante alors que l'objectif est d'avoir une distance constante lorsqu'il est chauff\u00e9. Cependant, si l'on calibre lorsque la buse est chauff\u00e9e, elle a tendance \u00e0 laisser couler de petites quantit\u00e9s de plastique fondu sur le papier, ce qui modifie la quantit\u00e9 de frottement ressenti. Cela complique l'obtention d'un bon calibrage. Le calibrage alors que le lit/la buse est chaud augmente \u00e9galement consid\u00e9rablement le risque de se br\u00fbler. La dilatation thermique est stable, elle est donc facilement prise en compte plus tard dans le processus d'\u00e9talonnage. Utilisez un outil automatique pour d\u00e9terminer des hauteurs Z pr\u00e9cises ! Klipper a de nombreux scripts d'aide disponibles (par exemple, MANUAL_PROBE, Z_ENDSTOP_CALIBRATE, PROBE_CALIBRATE, DELTA_CALIBRATE). Lisez les documents d\u00e9crits ci-dessus pour en choisir un. Ex\u00e9cutez la commande choisie dans la fen\u00eatre du terminal OctoPrint. Le script demandera une action de l'utilisateur dans la sortie du terminal OctoPrint. Cela ressemblera \u00e0 quelque chose comme : Recv: // Starting manual Z probe. Use TESTZ to adjust position. Recv: // Finish with ACCEPT or ABORT command. Recv: // Z position: ?????? --> 5.000 <-- ?????? La hauteur actuelle de la buse (telle que l'imprimante la calcule) est indiqu\u00e9e entre \"--> <--\". Le nombre \u00e0 droite est la hauteur du dernier essai de sondage juste sup\u00e9rieure \u00e0 la hauteur actuelle, et \u00e0 gauche c'est la hauteur du dernier essai de sondage inf\u00e9rieur \u00e0 la hauteur actuelle (ou ?????? si aucune tentative n'a \u00e9t\u00e9 effectu\u00e9e). Placez le papier entre la buse et le lit. Il peut \u00eatre utile de plier un coin du papier pour qu'il soit plus facile \u00e0 saisir. (Essayez de ne pas appuyer sur le lit lorsque vous d\u00e9placez le papier d'avant en arri\u00e8re.) Utilisez la commande TESTZ pour demander \u00e0 la buse de se rapprocher du papier. Par exemple : TESTZ Z=-0.1 La commande TESTZ d\u00e9placera la buse \u00e0 une distance relative de la position actuelle de la buse. (Ainsi, Z = -0.1 demande \u00e0 la buse de se rapprocher du lit de 0,1 mm.) Une fois que la buse a cess\u00e9 de bouger, poussez le papier d'avant en arri\u00e8re pour v\u00e9rifier si la buse est en contact avec le papier et pour sentir la quantit\u00e9 de frottement. Continuez \u00e0 \u00e9mettre des commandes TESTZ jusqu'\u00e0 ce que vous ressentiez une l\u00e9g\u00e8re friction lors du test avec le papier. Si il y a trop de frottement, on peut utiliser une valeur Z positive pour d\u00e9placer la buse vers le haut. Il est \u00e9galement possible d'utiliser TESTZ Z=+ ou TESTZ Z=- pour \"dichotomiser\" la derni\u00e8re position - c'est-\u00e0-dire se d\u00e9placer vers une position \u00e0 mi-chemin entre deux positions. Par exemple, si l'on re\u00e7oit l'invite suivante d'une commande TESTZ : Recv: // Z position: 0.130 --> 0.230 <-- 0.280 Ensuite, un 'TESTZ Z=-' d\u00e9placerait la buse vers une position Z de 0,180 (\u00e0 mi-chemin entre 0,130 et 0,230). On peut utiliser cette fonctionnalit\u00e9 pour aider \u00e0 r\u00e9duire rapidement \u00e0 un frottement constant. Il est \u00e9galement possible d'utiliser Z=++ et Z=-- pour revenir directement \u00e0 une mesure pass\u00e9e - par exemple, apr\u00e8s l'invite ci-dessus, une commande TESTZ Z=-- d\u00e9placerait la buse vers un Z position de 0,130. Apr\u00e8s r\u00e9gl\u00e9 la l\u00e9g\u00e8re force de friction, ex\u00e9cutez la commande ACCEPT : ACCEPT Cela validera la hauteur Z donn\u00e9e et enregistrera la valeur d'\u00e9talonnage. La force de friction ressentie n'est pas cruciale, tout comme la quantit\u00e9 de dilatation thermique et la largeur exacte du papier ne sont pas cruciales. Essayez simplement d'obtenir la m\u00eame quantit\u00e9 de frottement \u00e0 chaque fois que vous ex\u00e9cutez le test. Si quelque chose ne va pas pendant le test, on peut utiliser la commande ABORT pour quitter l'outil d'\u00e9talonnage. D\u00e9termination de la dilatation thermique \u00b6 Apr\u00e8s avoir effectu\u00e9 le nivellement du lit, on peut continuer \u00e0 calculer une valeur plus pr\u00e9cise pour compenser \u00abl'expansion thermique\u00bb, \u00abl'\u00e9paisseur du papier\u00bb et la \u00abquantit\u00e9 de frottement ressentie pendant le test du papier\u00bb. Ce type de calcul n'est g\u00e9n\u00e9ralement pas n\u00e9cessaire car la plupart des utilisateurs trouvent que le simple \"test papier\" donne de bons r\u00e9sultats. La fa\u00e7on la plus simple de faire ce calcul est d'imprimer un objet de test qui a des parois droites de tous les c\u00f4t\u00e9s. Le grand carr\u00e9 creux trouv\u00e9 dans docs/prints/square.stl peut \u00eatre utilis\u00e9 pour cela. Lors du d\u00e9coupage de l'objet, assurez-vous que le segment utilise la m\u00eame hauteur de couche et la m\u00eame largeur d'extrusion pour le premier niveau et pour toutes les couches suivantes. Utilisez une hauteur de couche grossi\u00e8re (la hauteur de couche doit \u00eatre d'environ 75 % du diam\u00e8tre de la buse) et n'utilisez pas de bordure ou de radeau. Imprimez l'objet \u00e0 tester, attendez qu'il refroidisse et retirez-le du lit. Inspectez la couche la plus basse de l'objet. (Il peut \u00e9galement \u00eatre utile de passer un doigt ou un ongle le long du bord inf\u00e9rieur.) Si l'on constate que la couche inf\u00e9rieure est l\u00e9g\u00e8rement bomb\u00e9e le long de tous les c\u00f4t\u00e9s de l'objet, cela indique que la buse \u00e9tait l\u00e9g\u00e8rement plus proche du lit qu'elle ne l'aurait d\u00fb. On peut \u00e9mettre une commande SET_GCODE_OFFSET Z=+.010 pour augmenter la hauteur. Dans les impressions suivantes, on peut inspecter ce comportement et effectuer d'autres ajustements si n\u00e9cessaire. Les ajustements de ce type se font g\u00e9n\u00e9ralement en dizaines de microns (0,010 mm). Si la couche inf\u00e9rieure appara\u00eet syst\u00e9matiquement plus \u00e9troite que les couches suivantes, vous pouvez utiliser la commande SET_GCODE_OFFSET pour effectuer un ajustement Z n\u00e9gatif. En cas de doute, on peut diminuer le r\u00e9glage Z jusqu'\u00e0 ce que la couche inf\u00e9rieure des impressions pr\u00e9sente un petit renflement, puis reculer jusqu'\u00e0 ce qu'il disparaisse. Le moyen le plus simple d'appliquer l'ajustement Z souhait\u00e9 consiste \u00e0 cr\u00e9er une macro de g-code START_PRINT et \u00e0 faire en sorte que le slicer appelle cette macro au d\u00e9but de chaque impression et \u00e0 ajouter une commande SET_GCODE_OFFSET \u00e0 cette macro. Voir le document trancheurs pour plus de d\u00e9tails.","title":"Nivellement du lit"},{"location":"Bed_Level.html#nivellement-du-lit","text":"Le nivellement du lit (parfois aussi appel\u00e9 \u00ab tramage du lit \u00bb) est essentiel pour obtenir des impressions de haute qualit\u00e9. Si un lit n'est pas correctement \"nivel\u00e9\", cela peut entra\u00eener une mauvaise adh\u00e9rence du lit, un \"gauchissement\" et des probl\u00e8mes subtils tout au long de l'impression. Ce document sert de guide pour effectuer le nivellement du lit dans Klipper. Il est important de comprendre l'objectif du nivellement du lit. Si l'imprimante doit aller \u00e0 la position X0 Y0 Z10 pendant une impression, alors l'objectif est que la buse de l'imprimante soit exactement \u00e0 10 mm du lit de l'imprimante. De plus, si l'imprimante doit ensuite aller \u00e0 la position \"X50 Z10\", l'objectif est que la buse maintienne une distance exacte de 10 mm du lit pendant tout ce mouvement horizontal. Afin d'obtenir des impressions de bonne qualit\u00e9, l'imprimante doit \u00eatre calibr\u00e9e de sorte que les distances Z soient pr\u00e9cises \u00e0 environ 25 microns (0,025 mm). Il s'agit d'une petite distance - nettement inf\u00e9rieure \u00e0 la largeur d'un cheveu humain. Cette \u00e9chelle ne peut pas \u00eatre mesur\u00e9e \"\u00e0 l'\u0153il\". Des effets subtils (tels que la dilatation thermique) ont un impact sur les mesures \u00e0 cette \u00e9chelle. Le secret pour obtenir une grande pr\u00e9cision est d'utiliser un processus reproductible et d'utiliser une m\u00e9thode de mise \u00e0 niveau qui tire parti de la haute pr\u00e9cision du propre syst\u00e8me de mouvement de l'imprimante.","title":"Nivellement du lit"},{"location":"Bed_Level.html#choisissez-le-mecanisme-detalonnage-approprie","text":"Diff\u00e9rents types d'imprimantes utilisent diff\u00e9rentes m\u00e9thodes pour effectuer le nivellement du lit. A la fin toutes les m\u00e9thodes d\u00e9pendent du \"test du papier\" (d\u00e9crit ci-dessous). Cependant, le processus pour un type particulier d'imprimante est d\u00e9crit dans les autres documents. Avant d'ex\u00e9cuter l'un de ces outils d'\u00e9talonnage, assurez-vous d'ex\u00e9cuter les v\u00e9rifications d\u00e9crites dans le document de v\u00e9rification de la configuration . Il est n\u00e9cessaire de v\u00e9rifier les mouvements de base de l'imprimante avant d'effectuer le nivellement du lit. Pour les imprimantes avec une sonde Z automatique, assurez-vous de calibrer la sonde en suivant les instructions du document R\u00e9glages de la sonde . Pour les imprimantes delta, consultez le document R\u00e9glage des deltas . Pour les imprimantes avec un lit r\u00e9glable par vis et des fin de course Z traditionnels, consultez le document Nivellement manuel . Pendant le calibrage, il peut \u00eatre n\u00e9cessaire de d\u00e9finir la position_min du Z de l'imprimante sur un nombre n\u00e9gatif (par exemple, position_min = -2 ). L'imprimante effectue des v\u00e9rifications des limites m\u00eame pendant les routines d'\u00e9talonnage. La d\u00e9finition d'un nombre n\u00e9gatif permet \u00e0 l'imprimante de se d\u00e9placer en dessous de la position nominale du lit, ce qui peut aider \u00e0 d\u00e9terminer la position r\u00e9elle du lit.","title":"Choisissez le m\u00e9canisme d'\u00e9talonnage appropri\u00e9"},{"location":"Bed_Level.html#le-test-du-papier","text":"Le principal m\u00e9canisme d'\u00e9talonnage du lit est le \"test du papier\". Il s'agit de placer un morceau r\u00e9gulier de \"papier pour photocopieuse\" entre le lit et la buse de l'imprimante, puis de d\u00e9placer la buse \u00e0 diff\u00e9rentes hauteurs Z jusqu'\u00e0 ce que l'on ressente une petite friction lorsque l'on pousse le papier d'avant en arri\u00e8re. Il est important de bien comprendre le \"test papier\" m\u00eame si l'on dispose d'une \"sonde Z automatique\". La sonde elle-m\u00eame doit souvent \u00eatre calibr\u00e9e pour obtenir de bons r\u00e9sultats. Cet \u00e9talonnage de la sonde est effectu\u00e9 \u00e0 l'aide de ce \"test papier\". Afin d'effectuer le test du papier, coupez un petit morceau de papier rectangulaire \u00e0 l'aide d'une paire de ciseaux (par exemple, 5x3 cm). Le papier a g\u00e9n\u00e9ralement une \u00e9paisseur d'environ 100 microns (0,100 mm). (L'\u00e9paisseur exacte du papier n'est pas cruciale.) La premi\u00e8re \u00e9tape du test du papier consiste \u00e0 inspecter la buse et le lit de l'imprimante. Assurez-vous qu'il n'y a pas de plastique (ou d'autres d\u00e9bris) sur la buse ou le lit. Inspectez la buse et le lit pour vous assurer qu'il n'y a pas de plastique ! Si l'on imprime toujours sur une bande adh\u00e9sive ou une surface d'impression particuli\u00e8re, on peut alors effectuer le test papier avec cette bande/surface en place. Cependant, notez que le ruban lui-m\u00eame a une \u00e9paisseur et que diff\u00e9rents rubans (ou toute autre surface d'impression) auront un impact sur les mesures Z. Assurez-vous de relancer le test du papier pour mesurer chaque type de surface utilis\u00e9. S'il y a du plastique sur la buse, chauffez la buse et utilisez une pince \u00e0 \u00e9piler en m\u00e9tal pour retirer ce plastique. Attendez que la buse refroidisse compl\u00e8tement \u00e0 temp\u00e9rature ambiante avant de continuer avec le test papier. Pendant que la buse refroidit, utilisez la pince \u00e0 \u00e9piler en m\u00e9tal pour retirer tout plastique susceptible de suinter. Effectuez toujours le test du papier lorsque la buse et le lit sont \u00e0 temp\u00e9rature ambiante ! Lorsque la buse est chauff\u00e9e, sa position (par rapport au lit) change en raison de la dilatation thermique. Cette dilatation thermique est g\u00e9n\u00e9ralement d'environ 100 microns, ce qui correspond \u00e0 peu pr\u00e8s \u00e0 la m\u00eame \u00e9paisseur qu'un morceau de papier d'imprimante typique. La quantit\u00e9 exacte de dilatation thermique n'est pas cruciale, tout comme l'\u00e9paisseur exacte du papier n'est pas cruciale. Commencez par l'hypoth\u00e8se que les deux sont \u00e9gaux (voir ci-dessous pour une m\u00e9thode de d\u00e9termination de la diff\u00e9rence entre les deux distances). Il peut sembler \u00e9tonnant de calibrer la distance \u00e0 temp\u00e9rature ambiante alors que l'objectif est d'avoir une distance constante lorsqu'il est chauff\u00e9. Cependant, si l'on calibre lorsque la buse est chauff\u00e9e, elle a tendance \u00e0 laisser couler de petites quantit\u00e9s de plastique fondu sur le papier, ce qui modifie la quantit\u00e9 de frottement ressenti. Cela complique l'obtention d'un bon calibrage. Le calibrage alors que le lit/la buse est chaud augmente \u00e9galement consid\u00e9rablement le risque de se br\u00fbler. La dilatation thermique est stable, elle est donc facilement prise en compte plus tard dans le processus d'\u00e9talonnage. Utilisez un outil automatique pour d\u00e9terminer des hauteurs Z pr\u00e9cises ! Klipper a de nombreux scripts d'aide disponibles (par exemple, MANUAL_PROBE, Z_ENDSTOP_CALIBRATE, PROBE_CALIBRATE, DELTA_CALIBRATE). Lisez les documents d\u00e9crits ci-dessus pour en choisir un. Ex\u00e9cutez la commande choisie dans la fen\u00eatre du terminal OctoPrint. Le script demandera une action de l'utilisateur dans la sortie du terminal OctoPrint. Cela ressemblera \u00e0 quelque chose comme : Recv: // Starting manual Z probe. Use TESTZ to adjust position. Recv: // Finish with ACCEPT or ABORT command. Recv: // Z position: ?????? --> 5.000 <-- ?????? La hauteur actuelle de la buse (telle que l'imprimante la calcule) est indiqu\u00e9e entre \"--> <--\". Le nombre \u00e0 droite est la hauteur du dernier essai de sondage juste sup\u00e9rieure \u00e0 la hauteur actuelle, et \u00e0 gauche c'est la hauteur du dernier essai de sondage inf\u00e9rieur \u00e0 la hauteur actuelle (ou ?????? si aucune tentative n'a \u00e9t\u00e9 effectu\u00e9e). Placez le papier entre la buse et le lit. Il peut \u00eatre utile de plier un coin du papier pour qu'il soit plus facile \u00e0 saisir. (Essayez de ne pas appuyer sur le lit lorsque vous d\u00e9placez le papier d'avant en arri\u00e8re.) Utilisez la commande TESTZ pour demander \u00e0 la buse de se rapprocher du papier. Par exemple : TESTZ Z=-0.1 La commande TESTZ d\u00e9placera la buse \u00e0 une distance relative de la position actuelle de la buse. (Ainsi, Z = -0.1 demande \u00e0 la buse de se rapprocher du lit de 0,1 mm.) Une fois que la buse a cess\u00e9 de bouger, poussez le papier d'avant en arri\u00e8re pour v\u00e9rifier si la buse est en contact avec le papier et pour sentir la quantit\u00e9 de frottement. Continuez \u00e0 \u00e9mettre des commandes TESTZ jusqu'\u00e0 ce que vous ressentiez une l\u00e9g\u00e8re friction lors du test avec le papier. Si il y a trop de frottement, on peut utiliser une valeur Z positive pour d\u00e9placer la buse vers le haut. Il est \u00e9galement possible d'utiliser TESTZ Z=+ ou TESTZ Z=- pour \"dichotomiser\" la derni\u00e8re position - c'est-\u00e0-dire se d\u00e9placer vers une position \u00e0 mi-chemin entre deux positions. Par exemple, si l'on re\u00e7oit l'invite suivante d'une commande TESTZ : Recv: // Z position: 0.130 --> 0.230 <-- 0.280 Ensuite, un 'TESTZ Z=-' d\u00e9placerait la buse vers une position Z de 0,180 (\u00e0 mi-chemin entre 0,130 et 0,230). On peut utiliser cette fonctionnalit\u00e9 pour aider \u00e0 r\u00e9duire rapidement \u00e0 un frottement constant. Il est \u00e9galement possible d'utiliser Z=++ et Z=-- pour revenir directement \u00e0 une mesure pass\u00e9e - par exemple, apr\u00e8s l'invite ci-dessus, une commande TESTZ Z=-- d\u00e9placerait la buse vers un Z position de 0,130. Apr\u00e8s r\u00e9gl\u00e9 la l\u00e9g\u00e8re force de friction, ex\u00e9cutez la commande ACCEPT : ACCEPT Cela validera la hauteur Z donn\u00e9e et enregistrera la valeur d'\u00e9talonnage. La force de friction ressentie n'est pas cruciale, tout comme la quantit\u00e9 de dilatation thermique et la largeur exacte du papier ne sont pas cruciales. Essayez simplement d'obtenir la m\u00eame quantit\u00e9 de frottement \u00e0 chaque fois que vous ex\u00e9cutez le test. Si quelque chose ne va pas pendant le test, on peut utiliser la commande ABORT pour quitter l'outil d'\u00e9talonnage.","title":"Le \"Test du papier\""},{"location":"Bed_Level.html#determination-de-la-dilatation-thermique","text":"Apr\u00e8s avoir effectu\u00e9 le nivellement du lit, on peut continuer \u00e0 calculer une valeur plus pr\u00e9cise pour compenser \u00abl'expansion thermique\u00bb, \u00abl'\u00e9paisseur du papier\u00bb et la \u00abquantit\u00e9 de frottement ressentie pendant le test du papier\u00bb. Ce type de calcul n'est g\u00e9n\u00e9ralement pas n\u00e9cessaire car la plupart des utilisateurs trouvent que le simple \"test papier\" donne de bons r\u00e9sultats. La fa\u00e7on la plus simple de faire ce calcul est d'imprimer un objet de test qui a des parois droites de tous les c\u00f4t\u00e9s. Le grand carr\u00e9 creux trouv\u00e9 dans docs/prints/square.stl peut \u00eatre utilis\u00e9 pour cela. Lors du d\u00e9coupage de l'objet, assurez-vous que le segment utilise la m\u00eame hauteur de couche et la m\u00eame largeur d'extrusion pour le premier niveau et pour toutes les couches suivantes. Utilisez une hauteur de couche grossi\u00e8re (la hauteur de couche doit \u00eatre d'environ 75 % du diam\u00e8tre de la buse) et n'utilisez pas de bordure ou de radeau. Imprimez l'objet \u00e0 tester, attendez qu'il refroidisse et retirez-le du lit. Inspectez la couche la plus basse de l'objet. (Il peut \u00e9galement \u00eatre utile de passer un doigt ou un ongle le long du bord inf\u00e9rieur.) Si l'on constate que la couche inf\u00e9rieure est l\u00e9g\u00e8rement bomb\u00e9e le long de tous les c\u00f4t\u00e9s de l'objet, cela indique que la buse \u00e9tait l\u00e9g\u00e8rement plus proche du lit qu'elle ne l'aurait d\u00fb. On peut \u00e9mettre une commande SET_GCODE_OFFSET Z=+.010 pour augmenter la hauteur. Dans les impressions suivantes, on peut inspecter ce comportement et effectuer d'autres ajustements si n\u00e9cessaire. Les ajustements de ce type se font g\u00e9n\u00e9ralement en dizaines de microns (0,010 mm). Si la couche inf\u00e9rieure appara\u00eet syst\u00e9matiquement plus \u00e9troite que les couches suivantes, vous pouvez utiliser la commande SET_GCODE_OFFSET pour effectuer un ajustement Z n\u00e9gatif. En cas de doute, on peut diminuer le r\u00e9glage Z jusqu'\u00e0 ce que la couche inf\u00e9rieure des impressions pr\u00e9sente un petit renflement, puis reculer jusqu'\u00e0 ce qu'il disparaisse. Le moyen le plus simple d'appliquer l'ajustement Z souhait\u00e9 consiste \u00e0 cr\u00e9er une macro de g-code START_PRINT et \u00e0 faire en sorte que le slicer appelle cette macro au d\u00e9but de chaque impression et \u00e0 ajouter une commande SET_GCODE_OFFSET \u00e0 cette macro. Voir le document trancheurs pour plus de d\u00e9tails.","title":"D\u00e9termination de la dilatation thermique"},{"location":"Bed_Mesh.html","text":"Maillage du Bed \u00b6 Le module Bed Mesh peut \u00eatre utilis\u00e9 pour compenser les irr\u00e9gularit\u00e9s de la surface du lit afin d'obtenir une meilleure premi\u00e8re couche sur l'ensemble du lit. Il convient de noter que la correction bas\u00e9e sur un logiciel n'atteindra pas des r\u00e9sultats parfaits, elle ne peut qu'approximer la forme du lit. Bed Mesh ne peut pas non plus compenser les probl\u00e8mes m\u00e9caniques et \u00e9lectriques. Si un axe est fauss\u00e9 ou si une sonde n'est pas pr\u00e9cise, le module bed_mesh ne recevra pas de r\u00e9sultats pr\u00e9cis du processus de sonde. Avant de proc\u00e9der \u00e0 l'\u00e9talonnage du maillage, vous devez vous assurer que l'offset Z de votre sonde est r\u00e9gl\u00e9. Si vous utilisez une but\u00e9e de fin de course pour la mise \u00e0 l'origine en Z, elle doit \u00e9galement \u00eatre r\u00e9gl\u00e9e. Voir Calibration de la sonde et Z_ENDSTOP_CALIBRATE dans Nivelage manuel pour plus d'informations. Configuration de base \u00b6 Lits rectangulaires \u00b6 Cet exemple suppose une imprimante avec un lit rectangulaire de 250 mm x 220 mm et une sonde avec un d\u00e9calage x de 24 mm et un d\u00e9calage y de 5 mm. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 speed : 120 Valeur par d\u00e9faut : 50 La vitesse \u00e0 laquelle l'outil se d\u00e9place entre les points palp\u00e9s. horizontal_move_z : 5 Valeur par d\u00e9faut : 5 La coordonn\u00e9e Z \u00e0 laquelle la sonde s'\u00e9l\u00e8ve avant de se d\u00e9placer entre les points. mesh_min : 35, 6 Requis La premi\u00e8re coordonn\u00e9e palp\u00e9e, la plus proche de l'origine. Cette coordonn\u00e9e est relative \u00e0 l'emplacement de la sonde. mesh_max : 240, 198 Obligatoire La coordonn\u00e9e sond\u00e9e la plus \u00e9loign\u00e9e de l'origine. Ce n'est pas n\u00e9cessairement le dernier point sond\u00e9, car le processus de sondage se d\u00e9roule en zigzag. Comme avec mesh_min , cette coordonn\u00e9e est relative \u00e0 l'emplacement de la sonde. probe_count : 5, 3 Valeur par d\u00e9faut : 3, 3 Le nombre de points \u00e0 palper sur chaque axe, sp\u00e9cifi\u00e9 sous forme de valeurs enti\u00e8res X, Y. Dans cet exemple, 5 points seront palp\u00e9s le long de l'axe X, avec 3 points le long de l'axe Y, pour un total de 15 points palp\u00e9s. Notez que si vous voulez une grille carr\u00e9e, par exemple 3x3, il est possible de n'utiliser qu'une seule valeur enti\u00e8re pour les deux axes, par exemple probe_count : 3 . Notez qu'un maillage n\u00e9cessite un nombre minimum de 3 points de sondage sur chaque axe. L'illustration ci-dessous montre comment les options mesh_min , mesh_max , et probe_count sont utilis\u00e9es pour g\u00e9n\u00e9rer des points de palpage. Les fl\u00e8ches indiquent la direction de la proc\u00e9dure de palpage, commen\u00e7ant en mesh_min . Pour r\u00e9f\u00e9rence, lorsque la sonde est \u00e0 mesh_min , la buse sera \u00e0 (11, 1), et lorsque la sonde est \u00e0 mesh_max , la buse sera \u00e0 (206, 193). Lits circulaires \u00b6 Cet exemple suppose une imprimante \u00e9quip\u00e9e d'un lit circulaire de 100 mm de rayon. Nous utiliserons les m\u00eames d\u00e9calages de sonde que dans l'exemple rectangulaire, 24 mm sur X et 5 mm sur Y. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_radius: 75 mesh_origin: 0, 0 round_probe_count: 5 mesh_radius : 75 Requis Le rayon du maillage palp\u00e9 en mm, par rapport \u00e0 mesh_origin . Notez que les d\u00e9calages de la sonde limitent la taille du rayon du maillage. Dans cet exemple, un rayon sup\u00e9rieur \u00e0 76 d\u00e9placerait la t\u00eate de l'outil en dehors des limites physiques de l'imprimante. mesh_origin : 0, 0 Valeur par d\u00e9faut : 0, 0 Le point central du maillage. Cette coordonn\u00e9e est relative \u00e0 l'emplacement de la sonde. Bien que la valeur par d\u00e9faut soit 0, 0, il peut \u00eatre utile d'ajuster l'origine dans le but de sonder une plus grande partie du lit. Voir l'illustration ci-dessous. round_probe_count : 5 Valeur par d\u00e9faut : 5 C'est une valeur enti\u00e8re d\u00e9finissant le nombre maximum de points palp\u00e9s le long des axes X et Y. Par \"maximum\", nous entendons le nombre de points palp\u00e9s le long de l'origine du maillage. Cette valeur doit \u00eatre un nombre impair, car il est n\u00e9cessaire que le centre du maillage soit palp\u00e9. L'illustration ci-dessous montre comment les points palp\u00e9s sont g\u00e9n\u00e9r\u00e9s. Comme vous pouvez le voir, d\u00e9finir mesh_origin sur (-10, 0) nous permet de sp\u00e9cifier un rayon de maillage plus grand de 85. Configuration avanc\u00e9e \u00b6 Les options de configuration plus avanc\u00e9es sont expliqu\u00e9es en d\u00e9tail ci-dessous. Chaque exemple s'appuie sur la configuration de base du lit rectangulaire pr\u00e9sent\u00e9e ci-dessus. Chacune des options avanc\u00e9es s'applique de la m\u00eame mani\u00e8re aux lits circulaires. Interpolation du maillage \u00b6 Bien qu'il soit possible d'\u00e9chantillonner directement la matrice sond\u00e9e \u00e0 l'aide d'une simple interpolation bilin\u00e9aire pour d\u00e9terminer les valeurs Z entre les points sond\u00e9s, il est souvent utile d'interpoler des points suppl\u00e9mentaires \u00e0 l'aide d'algorithmes d'interpolation plus avanc\u00e9s pour augmenter la densit\u00e9 du maillage. Ces algorithmes ajoutent une courbure au maillage, tentant de simuler les propri\u00e9t\u00e9s mat\u00e9rielles du lit. Bed Mesh offre une interpolation lagrange et bicubique pour y parvenir. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 mesh_pps: 2, 3 algorithm: bicubic bicubic_tension: 0.2 mesh_pps : 2, 3 Valeur par d\u00e9faut : 2, 2 L'option mesh_pps est l'abr\u00e9viation de Mesh Points Per Segment. Cette option indique le nombre de points \u00e0 interpoler pour chaque segment le long des axes X et Y. Un 'segment' est l'espace entre chaque point palp\u00e9. Comme pour probe_count , mesh_pps est sp\u00e9cifi\u00e9 en tant que paire de nombres entiers X, Y mais peut aussi \u00eatre sp\u00e9cifi\u00e9 comme un seul nombre entier en ce cas appliqu\u00e9 aux deux axes. Dans cet exemple, il y a 4 segments le long de l'axe X et 2 segments le long de l'axe Y. Cela r\u00e9sulte en 8 points interpol\u00e9s le long de l'axe X et 6 points interpol\u00e9s le long de l'axe Y, ce qui donne un maillage de 13x8. Notez que si mesh_pps est d\u00e9fini \u00e0 0, l'interpolation de maillage est d\u00e9sactiv\u00e9e et la matrice sond\u00e9e sera \u00e9chantillonn\u00e9e directement. algorithm : lagrange Valeur par d\u00e9faut : lagrange L'algorithme utilis\u00e9 pour interpoler le maillage. Peut \u00eatre lagrange ou bicubique . L'interpolation de Lagrange est plafonn\u00e9e \u00e0 6 points palp\u00e9s car une oscillation tend \u00e0 se produire avec un plus grand nombre d'\u00e9chantillons. L'interpolation bicubique requiert un minimum de 4 points le long de chaque axe, si moins de 4 points sont sp\u00e9cifi\u00e9s, l'\u00e9chantillonnage de Lagrange est forc\u00e9. Si mesh_pps est d\u00e9fini \u00e0 0 alors cette valeur est ignor\u00e9e car aucune interpolation de maille n'est faite. bicubic_tension : 0.2 Valeur par d\u00e9faut : 0.2 Si l'option algorithm est d\u00e9finie sur bicubique, il est possible d'indiquer une valeur de tension. Plus la tension est \u00e9lev\u00e9e, plus la pente est interpol\u00e9e. Soyez prudent lorsque vous ajustez cette valeur, car des valeurs plus \u00e9lev\u00e9es cr\u00e9ent \u00e9galement plus de d\u00e9passement, ce qui entra\u00eenera des valeurs interpol\u00e9es plus \u00e9lev\u00e9es ou plus basses que vos points palp\u00e9s. L'illustration ci-dessous montre comment les options ci-dessus sont utilis\u00e9es pour g\u00e9n\u00e9rer un maillage interpol\u00e9. Fractionnement des d\u00e9placements \u00b6 Le maillage du lit fonctionne en interceptant les commandes de d\u00e9placement du gcode et en appliquant une transformation \u00e0 leur coordonn\u00e9e Z. Les longs d\u00e9placements doivent \u00eatre divis\u00e9s en d\u00e9placements plus petits pour suivre correctement la forme du lit. Les options ci-dessous contr\u00f4lent le comportement du fractionnement. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 move_check_distance: 5 split_delta_z: .025 move_check_distance : 5 Valeur par d\u00e9faut : 5 La distance minimale de v\u00e9rification de changement de Z souhait\u00e9 avant d'effectuer un fractionnemeny. Dans cet exemple, un mouvement de plus de 5mm sera travers\u00e9 par l'algorithme. Tous les 5 mm, une recherche de maille Z sera effectu\u00e9e, en la comparant \u00e0 la valeur Z du mouvement pr\u00e9c\u00e9dent. Si le delta atteint le seuil fix\u00e9 par split_delta_z , le mouvement sera divis\u00e9 et la travers\u00e9e continuera. Ce processus se r\u00e9p\u00e8te jusqu'\u00e0 ce que la fin du d\u00e9placement soit atteinte, o\u00f9 un ajustement final sera appliqu\u00e9. Les d\u00e9placements plus courts que la move_check_distance ont l'ajustement Z correct appliqu\u00e9 directement au d\u00e9placement sans travers\u00e9e ou division. split_delta_z : .025 Valeur par d\u00e9faut : .025 Comme mentionn\u00e9 ci-dessus, il s'agit de l'\u00e9cart minimum requis pour d\u00e9clencher un fractionnement du mouvement. Dans cet exemple, toute valeur Z avec un \u00e9cart de +/- 0,025 mm d\u00e9clenchera un fractionnement. G\u00e9n\u00e9ralement, les valeurs par d\u00e9faut de ces options sont suffisantes, en fait la valeur par d\u00e9faut de 5 mm pour la move_check_distance peut \u00eatre exag\u00e9r\u00e9e. Cependant, un utilisateur avanc\u00e9 peut souhaiter exp\u00e9rimenter ces options afin d'obtenir une premi\u00e8re couche optimale. Att\u00e9nuation du maillage \u00b6 Lorsque l'option \"fondu\" est activ\u00e9e, l'ajustement du Z est r\u00e9duit progressivement sur une distance d\u00e9finie par la configuration. Ceci est r\u00e9alis\u00e9 en appliquant de petits ajustements \u00e0 la hauteur de la couche, en augmentant ou en diminuant selon la forme du lit. Lorsque le fondu est termin\u00e9, l'ajustement Z n'est plus appliqu\u00e9, ce qui permet au sommet de l'impression d'\u00eatre plat plut\u00f4t que de refl\u00e9ter la forme du lit. Le fondu peut \u00e9galement pr\u00e9senter quelques caract\u00e9ristiques ind\u00e9sirables, si le fondu est effectu\u00e9 trop rapidement, il peut entra\u00eener des artefacts visibles sur l'impression. De plus, si votre lit est sensiblement d\u00e9form\u00e9, le fondu peut r\u00e9tr\u00e9cir ou \u00e9tirer la hauteur Z de l'impression. C'est pourquoi le fondu est d\u00e9sactiv\u00e9 par d\u00e9faut. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 fade_start: 1 fade_end: 10 fade_target: 0 fade_start: 1 Valeur par d\u00e9faut : 1 La hauteur Z \u00e0 laquelle il faut commencer l'att\u00e9nuation progressive de l'ajustement. C'est une bonne id\u00e9e d'avoir quelques couches d\u00e9j\u00e0 d\u00e9pos\u00e9es avant de commencer le processus de fondu. fade_end : 10 Valeur par d\u00e9faut : 0 La hauteur Z \u00e0 laquelle le fondu doit s'arr\u00eater. Si cette valeur est inf\u00e9rieure \u00e0 fade_start , le fondu est d\u00e9sactiv\u00e9. Cette valeur peut \u00eatre ajust\u00e9e en fonction de la d\u00e9formation de la surface d'impression. Une surface fortement d\u00e9form\u00e9e devrait s'estomper sur une plus grande distance. Une surface presque plate peut \u00eatre capable de r\u00e9duire cette valeur pour s'estomper plus rapidement. 10mm est une valeur raisonnable pour commencer si vous utilisez la valeur par d\u00e9faut de 1 pour fade_start . fade_target : 0 Valeur par d\u00e9faut : la valeur Z moyenne du maillage Le fade_target peut \u00eatre consid\u00e9r\u00e9 comme un d\u00e9calage Z suppl\u00e9mentaire appliqu\u00e9 \u00e0 l'ensemble du lit une fois l'interpolation termin\u00e9e . L'id\u00e9al serait d'avoir cette valeur \u00e0 0, mais il y a des circonstances o\u00f9 elle ne peut pas l'\u00eatre. Par exemple, supposons que votre position de r\u00e9f\u00e9rence sur le lit est une valeur aberrante, 0,2 mm inf\u00e9rieure \u00e0 la hauteur moyenne sond\u00e9e du lit. Si le fade_target est 0, le fondu r\u00e9duira l'impression de 0,2 mm en moyenne sur le lit. En r\u00e9glant fade_target sur 0,2, la zone r\u00e9f\u00e9renc\u00e9e s'agrandira de 0,2 mm, cependant, le reste du lit sera dimensionn\u00e9 avec pr\u00e9cision. G\u00e9n\u00e9ralement, c'est une bonne id\u00e9e de laisser fade_target hors de la configuration afin que la hauteur moyenne du maillage soit utilis\u00e9e, cependant il peut \u00eatre souhaitable d'ajuster manuellement cette valeur si l'on veut imprimer sur une partie sp\u00e9cifique du lit. Configuring the zero reference position \u00b6 Many probes are susceptible to \"drift\", ie: inaccuracies in probing introduced by heat or interference. This can make calculating the probe's z-offset challenging, particularly at different bed temperatures. As such, some printers use an endstop for homing the Z axis and a probe for calibrating the mesh. In this configuration it is possible offset the mesh so that the (X, Y) reference position applies zero adjustment. The reference postion should be the location on the bed where a Z_ENDSTOP_CALIBRATE paper test is performed. The bed_mesh module provides the zero_reference_position option for specifying this coordinate: [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 zero_reference_position: 125, 110 probe_count: 5, 3 zero_reference_position: Default Value: None (disabled) The zero_reference_position expects an (X, Y) coordinate matching that of the reference position described above. If the coordinate lies within the mesh then the mesh will be offset so the reference position applies zero adjustment. If the coordinate lies outside of the mesh then the coordinate will be probed after calibration, with the resulting z-value used as the z-offset. Note that this coordinate must NOT be in a location specified as a faulty_region if a probe is necessary. The deprecated relative_reference_index \u00b6 Existing configurations using the relative_reference_index option must be updated to use the zero_reference_position . The response to the BED_MESH_OUTPUT PGP=1 gcode command will include the (X, Y) coordinate associated with the index; this position may be used as the value for the zero_reference_position . The output will look similar to the following: // bed_mesh: generated points // Index | Tool Adjusted | Probe // 0 | (1.0, 1.0) | (24.0, 6.0) // 1 | (36.7, 1.0) | (59.7, 6.0) // 2 | (72.3, 1.0) | (95.3, 6.0) // 3 | (108.0, 1.0) | (131.0, 6.0) ... (additional generated points) // bed_mesh: relative_reference_index 24 is (131.5, 108.0) Note: The above output is also printed in klippy.log during initialization. Using the example above we see that the relative_reference_index is printed along with its coordinate. Thus the zero_reference_position is 131.5, 108 . R\u00e9gions d\u00e9fectueuses \u00b6 Il est possible que certaines zones d'un lit donnent des r\u00e9sultats inexacts lors du palpage en raison d'un \"d\u00e9faut\" \u00e0 des endroits particuliers. Le meilleur exemple de ce ph\u00e9nom\u00e8ne est celui des lits comportant une s\u00e9rie d'aimants int\u00e9gr\u00e9s utilis\u00e9s pour retenir les t\u00f4les d'acier amovibles. Le champ magn\u00e9tique au niveau et autour de ces aimants peut faire qu'une sonde inductive se d\u00e9clenche \u00e0 une distance plus \u00e9lev\u00e9e ou plus basse qu'elle ne le ferait autrement, ce qui donne un maillage ne repr\u00e9sentant pas pr\u00e9cis\u00e9ment la surface \u00e0 ces endroits. Remarque : Il ne faut pas confondre ce ph\u00e9nom\u00e8ne avec le biais de l'emplacement de la sonde, qui produit des r\u00e9sultats inexacts sur l'ensemble du lit. Les options faulty_region peuvent \u00eatre configur\u00e9es pour compenser cet effet. Si un point g\u00e9n\u00e9r\u00e9 se trouve dans une r\u00e9gion d\u00e9fectueuse, le maillage du lit tentera de palper jusqu'\u00e0 4 points aux limites de cette r\u00e9gion. Ces valeurs palp\u00e9es seront moyenn\u00e9es et ins\u00e9r\u00e9es dans le maillage comme valeur Z \u00e0 la coordonn\u00e9e (X, Y) g\u00e9n\u00e9r\u00e9e. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 faulty_region_1_min: 130.0, 0.0 faulty_region_1_max: 145.0, 40.0 faulty_region_2_min: 225.0, 0.0 faulty_region_2_max: 250.0, 25.0 faulty_region_3_min: 165.0, 95.0 faulty_region_3_max: 205.0, 110.0 faulty_region_4_min: 30.0, 170.0 faulty_region_4_max: 45.0, 210.0 faulty_region_{1...99}_min faulty_region_{1..99}_max Valeur par d\u00e9faut : None (d\u00e9sactiv\u00e9) Les r\u00e9gions d\u00e9fectueuses sont d\u00e9finies d'une mani\u00e8re similaire \u00e0 celle du maillage lui-m\u00eame, o\u00f9 les coordonn\u00e9es minimum et maximum (X, Y) doivent \u00eatre infiqu\u00e9es pour chaque r\u00e9gion. Une r\u00e9gion d\u00e9fectueuse peut s'\u00e9tendre \u00e0 l'ext\u00e9rieur d'un maillage, mais les points alternatifs g\u00e9n\u00e9r\u00e9s seront toujours \u00e0 l'int\u00e9rieur des limites du maillage. Deux r\u00e9gions ne peuvent pas se chevaucher. L'image ci-dessous illustre comment les points de remplacement sont g\u00e9n\u00e9r\u00e9s lorsqu'un point g\u00e9n\u00e9r\u00e9 se trouve dans une r\u00e9gion d\u00e9fectueuse. Les r\u00e9gions repr\u00e9sent\u00e9es correspondent \u00e0 celles de l'exemple de configuration ci-dessus. Les points de remplacement et leurs coordonn\u00e9es sont identifi\u00e9s en vert. Gcodes de maillage du lit \u00b6 Calibration \u00b6 BED_MESH_CALIBRATE PROFILE=<name> METHOD=[manual | automatic] [<probe_parameter>=<value>] [<mesh_parameter>=<value>] Profil par d\u00e9faut : default M\u00e9thode par d\u00e9faut : automatique si une sonde est d\u00e9tect\u00e9e, sinon manuelle Lance la proc\u00e9dure de palpage de l'\u00e9talonnage du maillage du lit. Le maillage sera sauvegard\u00e9 dans un profil indiqu\u00e9 par le param\u00e8tre PROFILE , ou default si non pr\u00e9cis\u00e9. Si METHOD=manual est s\u00e9lectionn\u00e9, un palpage manuel sera effectu\u00e9. Lorsque vous passez du mode automatique au mode manuel, les points de maillage g\u00e9n\u00e9r\u00e9s seront automatiquement ajust\u00e9s. Il est possible de sp\u00e9cifier des param\u00e8tres de maillage pour modifier la zone palp\u00e9e. Les param\u00e8tres suivants sont disponibles : Lits rectangulaires (cart\u00e9siens) : MESH_MIN MESH_MAX PROBE_COUNT Lits circulaires (delta) : MESH_RADIUS MESH_ORIGIN ROUND_PROBE_COUNT Tous les lits : ALGORITHM Consultez la documentation de configuration ci-dessus pour plus de d\u00e9tails sur la fa\u00e7on dont chaque param\u00e8tre s'applique au maillage. Profils \u00b6 BED_MESH_PROFILE SAVE=<name> LOAD=<name> REMOVE=<name> Apr\u00e8s avoir r\u00e9alis\u00e9 un BED_MESH_CALIBRATE, il est possible de sauvegarder l'\u00e9tat actuel du maillage dans un profil nomm\u00e9. Cela permet de charger un maillage sans re-palper le lit. Apr\u00e8s qu'un profil ait \u00e9t\u00e9 enregistr\u00e9 en utilisant BED_MESH_PROFILE SAVE=<name> , le gcode SAVE_CONFIG peut \u00eatre ex\u00e9cut\u00e9 pour \u00e9crire le profil dans printer.cfg. Les profils peuvent \u00eatre charg\u00e9s en ex\u00e9cutant BED_MESH_PROFILE LOAD=<name> . Il convient de noter qu'\u00e0 chaque fois qu'un BED_MESH_CALIBRATE se produit, l'\u00e9tat actuel est automatiquement enregistr\u00e9 dans le profil default . Le profil default peut \u00eatre supprim\u00e9 comme suit : BED_MESH_PROFILE REMOVE=default Tout autre profil enregistr\u00e9 peut \u00eatre supprim\u00e9 de la m\u00eame mani\u00e8re, en rempla\u00e7ant default par le nom du profil que vous souhaitez supprimer. Chargement du profil par d\u00e9faut \u00b6 Les versions pr\u00e9c\u00e9dentes de bed_mesh chargeaient toujours le profil nomm\u00e9 default au d\u00e9marrage s'il \u00e9tait pr\u00e9sent. Ce comportement a \u00e9t\u00e9 supprim\u00e9 afin de permettre \u00e0 l'utilisateur de d\u00e9terminer quand un profil est charg\u00e9. Si un utilisateur souhaite charger le profil par d\u00e9faut, il est recommand\u00e9 d'ajouter BED_MESH_PROFILE LOAD=default \u00e0 sa macro START_PRINT ou \u00e0 la configuration \"Start G-Code\" de son trancheur, selon ce qui est applicable. Alternativement, l'ancien comportement de chargement d'un profil au d\u00e9marrage peut \u00eatre restaur\u00e9 avec un [delayed_gcode] : [delayed_gcode bed_mesh_init] initial_duration : .01 gcode : BED_MESH_PROFILE LOAD = default Sortie \u00b6 BED_MESH_OUTPUT PGP=[0 | 1] Affiche l'\u00e9tat actuel du maillage dans le terminal. Notez que le maillage lui-m\u00eame est affich\u00e9 Le param\u00e8tre PGP est l'abr\u00e9viation de \"Print Generated Points\". Si PGP=1 est d\u00e9fini, les points palp\u00e9s g\u00e9n\u00e9r\u00e9s seront affich\u00e9s sur le terminal : // bed_mesh: generated points // Index | Tool Adjusted | Probe // 0 | (11.0, 1.0) | (35.0, 6.0) // 1 | (62.2, 1.0) | (86.2, 6.0) // 2 | (113.5, 1.0) | (137.5, 6.0) // 3 | (164.8, 1.0) | (188.8, 6.0) // 4 | (216.0, 1.0) | (240.0, 6.0) // 5 | (216.0, 97.0) | (240.0, 102.0) // 6 | (164.8, 97.0) | (188.8, 102.0) // 7 | (113.5, 97.0) | (137.5, 102.0) // 8 | (62.2, 97.0) | (86.2, 102.0) // 9 | (11.0, 97.0) | (35.0, 102.0) // 10 | (11.0, 193.0) | (35.0, 198.0) // 11 | (62.2, 193.0) | (86.2, 198.0) // 12 | (113.5, 193.0) | (137.5, 198.0) // 13 | (164.8, 193.0) | (188.8, 198.0) // 14 | (216.0, 193.0) | (240.0, 198.0) Les points de la colonne \"Tool Adjusted\" font r\u00e9f\u00e9rence \u00e0 l'emplacement de la buse, et les points de la colonne \"Probe\" font r\u00e9f\u00e9rence \u00e0 l'emplacement du palpeur. Notez que lors d'un palpage manuel, les points \"Probe\" se r\u00e9f\u00e8rent \u00e0 la fois \u00e0 l'emplacement de l'outil et de la buse. Effacer l'\u00e9tat du maillage \u00b6 BED_MESH_CLEAR Ce G-Code peut \u00eatre utilis\u00e9 pour effacer l'\u00e9tat interne du maillage. Appliquer les d\u00e9calages X/Y \u00b6 BED_MESH_OFFSET [X=<value>] [Y=<value>] Ceci est utile pour les imprimantes avec plusieurs extrudeuses ind\u00e9pendantes, car un d\u00e9calage est n\u00e9cessaire pour produire un ajustement Z correct apr\u00e8s un changement d'outil. Les d\u00e9calages doivent \u00eatre indiqu\u00e9s par rapport \u00e0 l'extrudeuse primaire. C'est-\u00e0-dire qu'un d\u00e9calage X positif doit \u00eatre indiqu\u00e9 si l'extrudeuse secondaire est mont\u00e9e \u00e0 droite de l'extrudeuse primaire, et un d\u00e9calage Y positif doit \u00eatre indiqu\u00e9 si l'extrudeuse secondaire est mont\u00e9e \"derri\u00e8re\" l'extrudeuse primaire.","title":"Maillage du Bed"},{"location":"Bed_Mesh.html#maillage-du-bed","text":"Le module Bed Mesh peut \u00eatre utilis\u00e9 pour compenser les irr\u00e9gularit\u00e9s de la surface du lit afin d'obtenir une meilleure premi\u00e8re couche sur l'ensemble du lit. Il convient de noter que la correction bas\u00e9e sur un logiciel n'atteindra pas des r\u00e9sultats parfaits, elle ne peut qu'approximer la forme du lit. Bed Mesh ne peut pas non plus compenser les probl\u00e8mes m\u00e9caniques et \u00e9lectriques. Si un axe est fauss\u00e9 ou si une sonde n'est pas pr\u00e9cise, le module bed_mesh ne recevra pas de r\u00e9sultats pr\u00e9cis du processus de sonde. Avant de proc\u00e9der \u00e0 l'\u00e9talonnage du maillage, vous devez vous assurer que l'offset Z de votre sonde est r\u00e9gl\u00e9. Si vous utilisez une but\u00e9e de fin de course pour la mise \u00e0 l'origine en Z, elle doit \u00e9galement \u00eatre r\u00e9gl\u00e9e. Voir Calibration de la sonde et Z_ENDSTOP_CALIBRATE dans Nivelage manuel pour plus d'informations.","title":"Maillage du Bed"},{"location":"Bed_Mesh.html#configuration-de-base","text":"","title":"Configuration de base"},{"location":"Bed_Mesh.html#lits-rectangulaires","text":"Cet exemple suppose une imprimante avec un lit rectangulaire de 250 mm x 220 mm et une sonde avec un d\u00e9calage x de 24 mm et un d\u00e9calage y de 5 mm. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 speed : 120 Valeur par d\u00e9faut : 50 La vitesse \u00e0 laquelle l'outil se d\u00e9place entre les points palp\u00e9s. horizontal_move_z : 5 Valeur par d\u00e9faut : 5 La coordonn\u00e9e Z \u00e0 laquelle la sonde s'\u00e9l\u00e8ve avant de se d\u00e9placer entre les points. mesh_min : 35, 6 Requis La premi\u00e8re coordonn\u00e9e palp\u00e9e, la plus proche de l'origine. Cette coordonn\u00e9e est relative \u00e0 l'emplacement de la sonde. mesh_max : 240, 198 Obligatoire La coordonn\u00e9e sond\u00e9e la plus \u00e9loign\u00e9e de l'origine. Ce n'est pas n\u00e9cessairement le dernier point sond\u00e9, car le processus de sondage se d\u00e9roule en zigzag. Comme avec mesh_min , cette coordonn\u00e9e est relative \u00e0 l'emplacement de la sonde. probe_count : 5, 3 Valeur par d\u00e9faut : 3, 3 Le nombre de points \u00e0 palper sur chaque axe, sp\u00e9cifi\u00e9 sous forme de valeurs enti\u00e8res X, Y. Dans cet exemple, 5 points seront palp\u00e9s le long de l'axe X, avec 3 points le long de l'axe Y, pour un total de 15 points palp\u00e9s. Notez que si vous voulez une grille carr\u00e9e, par exemple 3x3, il est possible de n'utiliser qu'une seule valeur enti\u00e8re pour les deux axes, par exemple probe_count : 3 . Notez qu'un maillage n\u00e9cessite un nombre minimum de 3 points de sondage sur chaque axe. L'illustration ci-dessous montre comment les options mesh_min , mesh_max , et probe_count sont utilis\u00e9es pour g\u00e9n\u00e9rer des points de palpage. Les fl\u00e8ches indiquent la direction de la proc\u00e9dure de palpage, commen\u00e7ant en mesh_min . Pour r\u00e9f\u00e9rence, lorsque la sonde est \u00e0 mesh_min , la buse sera \u00e0 (11, 1), et lorsque la sonde est \u00e0 mesh_max , la buse sera \u00e0 (206, 193).","title":"Lits rectangulaires"},{"location":"Bed_Mesh.html#lits-circulaires","text":"Cet exemple suppose une imprimante \u00e9quip\u00e9e d'un lit circulaire de 100 mm de rayon. Nous utiliserons les m\u00eames d\u00e9calages de sonde que dans l'exemple rectangulaire, 24 mm sur X et 5 mm sur Y. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_radius: 75 mesh_origin: 0, 0 round_probe_count: 5 mesh_radius : 75 Requis Le rayon du maillage palp\u00e9 en mm, par rapport \u00e0 mesh_origin . Notez que les d\u00e9calages de la sonde limitent la taille du rayon du maillage. Dans cet exemple, un rayon sup\u00e9rieur \u00e0 76 d\u00e9placerait la t\u00eate de l'outil en dehors des limites physiques de l'imprimante. mesh_origin : 0, 0 Valeur par d\u00e9faut : 0, 0 Le point central du maillage. Cette coordonn\u00e9e est relative \u00e0 l'emplacement de la sonde. Bien que la valeur par d\u00e9faut soit 0, 0, il peut \u00eatre utile d'ajuster l'origine dans le but de sonder une plus grande partie du lit. Voir l'illustration ci-dessous. round_probe_count : 5 Valeur par d\u00e9faut : 5 C'est une valeur enti\u00e8re d\u00e9finissant le nombre maximum de points palp\u00e9s le long des axes X et Y. Par \"maximum\", nous entendons le nombre de points palp\u00e9s le long de l'origine du maillage. Cette valeur doit \u00eatre un nombre impair, car il est n\u00e9cessaire que le centre du maillage soit palp\u00e9. L'illustration ci-dessous montre comment les points palp\u00e9s sont g\u00e9n\u00e9r\u00e9s. Comme vous pouvez le voir, d\u00e9finir mesh_origin sur (-10, 0) nous permet de sp\u00e9cifier un rayon de maillage plus grand de 85.","title":"Lits circulaires"},{"location":"Bed_Mesh.html#configuration-avancee","text":"Les options de configuration plus avanc\u00e9es sont expliqu\u00e9es en d\u00e9tail ci-dessous. Chaque exemple s'appuie sur la configuration de base du lit rectangulaire pr\u00e9sent\u00e9e ci-dessus. Chacune des options avanc\u00e9es s'applique de la m\u00eame mani\u00e8re aux lits circulaires.","title":"Configuration avanc\u00e9e"},{"location":"Bed_Mesh.html#interpolation-du-maillage","text":"Bien qu'il soit possible d'\u00e9chantillonner directement la matrice sond\u00e9e \u00e0 l'aide d'une simple interpolation bilin\u00e9aire pour d\u00e9terminer les valeurs Z entre les points sond\u00e9s, il est souvent utile d'interpoler des points suppl\u00e9mentaires \u00e0 l'aide d'algorithmes d'interpolation plus avanc\u00e9s pour augmenter la densit\u00e9 du maillage. Ces algorithmes ajoutent une courbure au maillage, tentant de simuler les propri\u00e9t\u00e9s mat\u00e9rielles du lit. Bed Mesh offre une interpolation lagrange et bicubique pour y parvenir. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 mesh_pps: 2, 3 algorithm: bicubic bicubic_tension: 0.2 mesh_pps : 2, 3 Valeur par d\u00e9faut : 2, 2 L'option mesh_pps est l'abr\u00e9viation de Mesh Points Per Segment. Cette option indique le nombre de points \u00e0 interpoler pour chaque segment le long des axes X et Y. Un 'segment' est l'espace entre chaque point palp\u00e9. Comme pour probe_count , mesh_pps est sp\u00e9cifi\u00e9 en tant que paire de nombres entiers X, Y mais peut aussi \u00eatre sp\u00e9cifi\u00e9 comme un seul nombre entier en ce cas appliqu\u00e9 aux deux axes. Dans cet exemple, il y a 4 segments le long de l'axe X et 2 segments le long de l'axe Y. Cela r\u00e9sulte en 8 points interpol\u00e9s le long de l'axe X et 6 points interpol\u00e9s le long de l'axe Y, ce qui donne un maillage de 13x8. Notez que si mesh_pps est d\u00e9fini \u00e0 0, l'interpolation de maillage est d\u00e9sactiv\u00e9e et la matrice sond\u00e9e sera \u00e9chantillonn\u00e9e directement. algorithm : lagrange Valeur par d\u00e9faut : lagrange L'algorithme utilis\u00e9 pour interpoler le maillage. Peut \u00eatre lagrange ou bicubique . L'interpolation de Lagrange est plafonn\u00e9e \u00e0 6 points palp\u00e9s car une oscillation tend \u00e0 se produire avec un plus grand nombre d'\u00e9chantillons. L'interpolation bicubique requiert un minimum de 4 points le long de chaque axe, si moins de 4 points sont sp\u00e9cifi\u00e9s, l'\u00e9chantillonnage de Lagrange est forc\u00e9. Si mesh_pps est d\u00e9fini \u00e0 0 alors cette valeur est ignor\u00e9e car aucune interpolation de maille n'est faite. bicubic_tension : 0.2 Valeur par d\u00e9faut : 0.2 Si l'option algorithm est d\u00e9finie sur bicubique, il est possible d'indiquer une valeur de tension. Plus la tension est \u00e9lev\u00e9e, plus la pente est interpol\u00e9e. Soyez prudent lorsque vous ajustez cette valeur, car des valeurs plus \u00e9lev\u00e9es cr\u00e9ent \u00e9galement plus de d\u00e9passement, ce qui entra\u00eenera des valeurs interpol\u00e9es plus \u00e9lev\u00e9es ou plus basses que vos points palp\u00e9s. L'illustration ci-dessous montre comment les options ci-dessus sont utilis\u00e9es pour g\u00e9n\u00e9rer un maillage interpol\u00e9.","title":"Interpolation du maillage"},{"location":"Bed_Mesh.html#fractionnement-des-deplacements","text":"Le maillage du lit fonctionne en interceptant les commandes de d\u00e9placement du gcode et en appliquant une transformation \u00e0 leur coordonn\u00e9e Z. Les longs d\u00e9placements doivent \u00eatre divis\u00e9s en d\u00e9placements plus petits pour suivre correctement la forme du lit. Les options ci-dessous contr\u00f4lent le comportement du fractionnement. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 move_check_distance: 5 split_delta_z: .025 move_check_distance : 5 Valeur par d\u00e9faut : 5 La distance minimale de v\u00e9rification de changement de Z souhait\u00e9 avant d'effectuer un fractionnemeny. Dans cet exemple, un mouvement de plus de 5mm sera travers\u00e9 par l'algorithme. Tous les 5 mm, une recherche de maille Z sera effectu\u00e9e, en la comparant \u00e0 la valeur Z du mouvement pr\u00e9c\u00e9dent. Si le delta atteint le seuil fix\u00e9 par split_delta_z , le mouvement sera divis\u00e9 et la travers\u00e9e continuera. Ce processus se r\u00e9p\u00e8te jusqu'\u00e0 ce que la fin du d\u00e9placement soit atteinte, o\u00f9 un ajustement final sera appliqu\u00e9. Les d\u00e9placements plus courts que la move_check_distance ont l'ajustement Z correct appliqu\u00e9 directement au d\u00e9placement sans travers\u00e9e ou division. split_delta_z : .025 Valeur par d\u00e9faut : .025 Comme mentionn\u00e9 ci-dessus, il s'agit de l'\u00e9cart minimum requis pour d\u00e9clencher un fractionnement du mouvement. Dans cet exemple, toute valeur Z avec un \u00e9cart de +/- 0,025 mm d\u00e9clenchera un fractionnement. G\u00e9n\u00e9ralement, les valeurs par d\u00e9faut de ces options sont suffisantes, en fait la valeur par d\u00e9faut de 5 mm pour la move_check_distance peut \u00eatre exag\u00e9r\u00e9e. Cependant, un utilisateur avanc\u00e9 peut souhaiter exp\u00e9rimenter ces options afin d'obtenir une premi\u00e8re couche optimale.","title":"Fractionnement des d\u00e9placements"},{"location":"Bed_Mesh.html#attenuation-du-maillage","text":"Lorsque l'option \"fondu\" est activ\u00e9e, l'ajustement du Z est r\u00e9duit progressivement sur une distance d\u00e9finie par la configuration. Ceci est r\u00e9alis\u00e9 en appliquant de petits ajustements \u00e0 la hauteur de la couche, en augmentant ou en diminuant selon la forme du lit. Lorsque le fondu est termin\u00e9, l'ajustement Z n'est plus appliqu\u00e9, ce qui permet au sommet de l'impression d'\u00eatre plat plut\u00f4t que de refl\u00e9ter la forme du lit. Le fondu peut \u00e9galement pr\u00e9senter quelques caract\u00e9ristiques ind\u00e9sirables, si le fondu est effectu\u00e9 trop rapidement, il peut entra\u00eener des artefacts visibles sur l'impression. De plus, si votre lit est sensiblement d\u00e9form\u00e9, le fondu peut r\u00e9tr\u00e9cir ou \u00e9tirer la hauteur Z de l'impression. C'est pourquoi le fondu est d\u00e9sactiv\u00e9 par d\u00e9faut. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 fade_start: 1 fade_end: 10 fade_target: 0 fade_start: 1 Valeur par d\u00e9faut : 1 La hauteur Z \u00e0 laquelle il faut commencer l'att\u00e9nuation progressive de l'ajustement. C'est une bonne id\u00e9e d'avoir quelques couches d\u00e9j\u00e0 d\u00e9pos\u00e9es avant de commencer le processus de fondu. fade_end : 10 Valeur par d\u00e9faut : 0 La hauteur Z \u00e0 laquelle le fondu doit s'arr\u00eater. Si cette valeur est inf\u00e9rieure \u00e0 fade_start , le fondu est d\u00e9sactiv\u00e9. Cette valeur peut \u00eatre ajust\u00e9e en fonction de la d\u00e9formation de la surface d'impression. Une surface fortement d\u00e9form\u00e9e devrait s'estomper sur une plus grande distance. Une surface presque plate peut \u00eatre capable de r\u00e9duire cette valeur pour s'estomper plus rapidement. 10mm est une valeur raisonnable pour commencer si vous utilisez la valeur par d\u00e9faut de 1 pour fade_start . fade_target : 0 Valeur par d\u00e9faut : la valeur Z moyenne du maillage Le fade_target peut \u00eatre consid\u00e9r\u00e9 comme un d\u00e9calage Z suppl\u00e9mentaire appliqu\u00e9 \u00e0 l'ensemble du lit une fois l'interpolation termin\u00e9e . L'id\u00e9al serait d'avoir cette valeur \u00e0 0, mais il y a des circonstances o\u00f9 elle ne peut pas l'\u00eatre. Par exemple, supposons que votre position de r\u00e9f\u00e9rence sur le lit est une valeur aberrante, 0,2 mm inf\u00e9rieure \u00e0 la hauteur moyenne sond\u00e9e du lit. Si le fade_target est 0, le fondu r\u00e9duira l'impression de 0,2 mm en moyenne sur le lit. En r\u00e9glant fade_target sur 0,2, la zone r\u00e9f\u00e9renc\u00e9e s'agrandira de 0,2 mm, cependant, le reste du lit sera dimensionn\u00e9 avec pr\u00e9cision. G\u00e9n\u00e9ralement, c'est une bonne id\u00e9e de laisser fade_target hors de la configuration afin que la hauteur moyenne du maillage soit utilis\u00e9e, cependant il peut \u00eatre souhaitable d'ajuster manuellement cette valeur si l'on veut imprimer sur une partie sp\u00e9cifique du lit.","title":"Att\u00e9nuation du maillage"},{"location":"Bed_Mesh.html#configuring-the-zero-reference-position","text":"Many probes are susceptible to \"drift\", ie: inaccuracies in probing introduced by heat or interference. This can make calculating the probe's z-offset challenging, particularly at different bed temperatures. As such, some printers use an endstop for homing the Z axis and a probe for calibrating the mesh. In this configuration it is possible offset the mesh so that the (X, Y) reference position applies zero adjustment. The reference postion should be the location on the bed where a Z_ENDSTOP_CALIBRATE paper test is performed. The bed_mesh module provides the zero_reference_position option for specifying this coordinate: [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 zero_reference_position: 125, 110 probe_count: 5, 3 zero_reference_position: Default Value: None (disabled) The zero_reference_position expects an (X, Y) coordinate matching that of the reference position described above. If the coordinate lies within the mesh then the mesh will be offset so the reference position applies zero adjustment. If the coordinate lies outside of the mesh then the coordinate will be probed after calibration, with the resulting z-value used as the z-offset. Note that this coordinate must NOT be in a location specified as a faulty_region if a probe is necessary.","title":"Configuring the zero reference position"},{"location":"Bed_Mesh.html#the-deprecated-relative_reference_index","text":"Existing configurations using the relative_reference_index option must be updated to use the zero_reference_position . The response to the BED_MESH_OUTPUT PGP=1 gcode command will include the (X, Y) coordinate associated with the index; this position may be used as the value for the zero_reference_position . The output will look similar to the following: // bed_mesh: generated points // Index | Tool Adjusted | Probe // 0 | (1.0, 1.0) | (24.0, 6.0) // 1 | (36.7, 1.0) | (59.7, 6.0) // 2 | (72.3, 1.0) | (95.3, 6.0) // 3 | (108.0, 1.0) | (131.0, 6.0) ... (additional generated points) // bed_mesh: relative_reference_index 24 is (131.5, 108.0) Note: The above output is also printed in klippy.log during initialization. Using the example above we see that the relative_reference_index is printed along with its coordinate. Thus the zero_reference_position is 131.5, 108 .","title":"The deprecated relative_reference_index"},{"location":"Bed_Mesh.html#regions-defectueuses","text":"Il est possible que certaines zones d'un lit donnent des r\u00e9sultats inexacts lors du palpage en raison d'un \"d\u00e9faut\" \u00e0 des endroits particuliers. Le meilleur exemple de ce ph\u00e9nom\u00e8ne est celui des lits comportant une s\u00e9rie d'aimants int\u00e9gr\u00e9s utilis\u00e9s pour retenir les t\u00f4les d'acier amovibles. Le champ magn\u00e9tique au niveau et autour de ces aimants peut faire qu'une sonde inductive se d\u00e9clenche \u00e0 une distance plus \u00e9lev\u00e9e ou plus basse qu'elle ne le ferait autrement, ce qui donne un maillage ne repr\u00e9sentant pas pr\u00e9cis\u00e9ment la surface \u00e0 ces endroits. Remarque : Il ne faut pas confondre ce ph\u00e9nom\u00e8ne avec le biais de l'emplacement de la sonde, qui produit des r\u00e9sultats inexacts sur l'ensemble du lit. Les options faulty_region peuvent \u00eatre configur\u00e9es pour compenser cet effet. Si un point g\u00e9n\u00e9r\u00e9 se trouve dans une r\u00e9gion d\u00e9fectueuse, le maillage du lit tentera de palper jusqu'\u00e0 4 points aux limites de cette r\u00e9gion. Ces valeurs palp\u00e9es seront moyenn\u00e9es et ins\u00e9r\u00e9es dans le maillage comme valeur Z \u00e0 la coordonn\u00e9e (X, Y) g\u00e9n\u00e9r\u00e9e. [bed_mesh] speed: 120 horizontal_move_z: 5 mesh_min: 35, 6 mesh_max: 240, 198 probe_count: 5, 3 faulty_region_1_min: 130.0, 0.0 faulty_region_1_max: 145.0, 40.0 faulty_region_2_min: 225.0, 0.0 faulty_region_2_max: 250.0, 25.0 faulty_region_3_min: 165.0, 95.0 faulty_region_3_max: 205.0, 110.0 faulty_region_4_min: 30.0, 170.0 faulty_region_4_max: 45.0, 210.0 faulty_region_{1...99}_min faulty_region_{1..99}_max Valeur par d\u00e9faut : None (d\u00e9sactiv\u00e9) Les r\u00e9gions d\u00e9fectueuses sont d\u00e9finies d'une mani\u00e8re similaire \u00e0 celle du maillage lui-m\u00eame, o\u00f9 les coordonn\u00e9es minimum et maximum (X, Y) doivent \u00eatre infiqu\u00e9es pour chaque r\u00e9gion. Une r\u00e9gion d\u00e9fectueuse peut s'\u00e9tendre \u00e0 l'ext\u00e9rieur d'un maillage, mais les points alternatifs g\u00e9n\u00e9r\u00e9s seront toujours \u00e0 l'int\u00e9rieur des limites du maillage. Deux r\u00e9gions ne peuvent pas se chevaucher. L'image ci-dessous illustre comment les points de remplacement sont g\u00e9n\u00e9r\u00e9s lorsqu'un point g\u00e9n\u00e9r\u00e9 se trouve dans une r\u00e9gion d\u00e9fectueuse. Les r\u00e9gions repr\u00e9sent\u00e9es correspondent \u00e0 celles de l'exemple de configuration ci-dessus. Les points de remplacement et leurs coordonn\u00e9es sont identifi\u00e9s en vert.","title":"R\u00e9gions d\u00e9fectueuses"},{"location":"Bed_Mesh.html#gcodes-de-maillage-du-lit","text":"","title":"Gcodes de maillage du lit"},{"location":"Bed_Mesh.html#calibration","text":"BED_MESH_CALIBRATE PROFILE=<name> METHOD=[manual | automatic] [<probe_parameter>=<value>] [<mesh_parameter>=<value>] Profil par d\u00e9faut : default M\u00e9thode par d\u00e9faut : automatique si une sonde est d\u00e9tect\u00e9e, sinon manuelle Lance la proc\u00e9dure de palpage de l'\u00e9talonnage du maillage du lit. Le maillage sera sauvegard\u00e9 dans un profil indiqu\u00e9 par le param\u00e8tre PROFILE , ou default si non pr\u00e9cis\u00e9. Si METHOD=manual est s\u00e9lectionn\u00e9, un palpage manuel sera effectu\u00e9. Lorsque vous passez du mode automatique au mode manuel, les points de maillage g\u00e9n\u00e9r\u00e9s seront automatiquement ajust\u00e9s. Il est possible de sp\u00e9cifier des param\u00e8tres de maillage pour modifier la zone palp\u00e9e. Les param\u00e8tres suivants sont disponibles : Lits rectangulaires (cart\u00e9siens) : MESH_MIN MESH_MAX PROBE_COUNT Lits circulaires (delta) : MESH_RADIUS MESH_ORIGIN ROUND_PROBE_COUNT Tous les lits : ALGORITHM Consultez la documentation de configuration ci-dessus pour plus de d\u00e9tails sur la fa\u00e7on dont chaque param\u00e8tre s'applique au maillage.","title":"Calibration"},{"location":"Bed_Mesh.html#profils","text":"BED_MESH_PROFILE SAVE=<name> LOAD=<name> REMOVE=<name> Apr\u00e8s avoir r\u00e9alis\u00e9 un BED_MESH_CALIBRATE, il est possible de sauvegarder l'\u00e9tat actuel du maillage dans un profil nomm\u00e9. Cela permet de charger un maillage sans re-palper le lit. Apr\u00e8s qu'un profil ait \u00e9t\u00e9 enregistr\u00e9 en utilisant BED_MESH_PROFILE SAVE=<name> , le gcode SAVE_CONFIG peut \u00eatre ex\u00e9cut\u00e9 pour \u00e9crire le profil dans printer.cfg. Les profils peuvent \u00eatre charg\u00e9s en ex\u00e9cutant BED_MESH_PROFILE LOAD=<name> . Il convient de noter qu'\u00e0 chaque fois qu'un BED_MESH_CALIBRATE se produit, l'\u00e9tat actuel est automatiquement enregistr\u00e9 dans le profil default . Le profil default peut \u00eatre supprim\u00e9 comme suit : BED_MESH_PROFILE REMOVE=default Tout autre profil enregistr\u00e9 peut \u00eatre supprim\u00e9 de la m\u00eame mani\u00e8re, en rempla\u00e7ant default par le nom du profil que vous souhaitez supprimer.","title":"Profils"},{"location":"Bed_Mesh.html#chargement-du-profil-par-defaut","text":"Les versions pr\u00e9c\u00e9dentes de bed_mesh chargeaient toujours le profil nomm\u00e9 default au d\u00e9marrage s'il \u00e9tait pr\u00e9sent. Ce comportement a \u00e9t\u00e9 supprim\u00e9 afin de permettre \u00e0 l'utilisateur de d\u00e9terminer quand un profil est charg\u00e9. Si un utilisateur souhaite charger le profil par d\u00e9faut, il est recommand\u00e9 d'ajouter BED_MESH_PROFILE LOAD=default \u00e0 sa macro START_PRINT ou \u00e0 la configuration \"Start G-Code\" de son trancheur, selon ce qui est applicable. Alternativement, l'ancien comportement de chargement d'un profil au d\u00e9marrage peut \u00eatre restaur\u00e9 avec un [delayed_gcode] : [delayed_gcode bed_mesh_init] initial_duration : .01 gcode : BED_MESH_PROFILE LOAD = default","title":"Chargement du profil par d\u00e9faut"},{"location":"Bed_Mesh.html#sortie","text":"BED_MESH_OUTPUT PGP=[0 | 1] Affiche l'\u00e9tat actuel du maillage dans le terminal. Notez que le maillage lui-m\u00eame est affich\u00e9 Le param\u00e8tre PGP est l'abr\u00e9viation de \"Print Generated Points\". Si PGP=1 est d\u00e9fini, les points palp\u00e9s g\u00e9n\u00e9r\u00e9s seront affich\u00e9s sur le terminal : // bed_mesh: generated points // Index | Tool Adjusted | Probe // 0 | (11.0, 1.0) | (35.0, 6.0) // 1 | (62.2, 1.0) | (86.2, 6.0) // 2 | (113.5, 1.0) | (137.5, 6.0) // 3 | (164.8, 1.0) | (188.8, 6.0) // 4 | (216.0, 1.0) | (240.0, 6.0) // 5 | (216.0, 97.0) | (240.0, 102.0) // 6 | (164.8, 97.0) | (188.8, 102.0) // 7 | (113.5, 97.0) | (137.5, 102.0) // 8 | (62.2, 97.0) | (86.2, 102.0) // 9 | (11.0, 97.0) | (35.0, 102.0) // 10 | (11.0, 193.0) | (35.0, 198.0) // 11 | (62.2, 193.0) | (86.2, 198.0) // 12 | (113.5, 193.0) | (137.5, 198.0) // 13 | (164.8, 193.0) | (188.8, 198.0) // 14 | (216.0, 193.0) | (240.0, 198.0) Les points de la colonne \"Tool Adjusted\" font r\u00e9f\u00e9rence \u00e0 l'emplacement de la buse, et les points de la colonne \"Probe\" font r\u00e9f\u00e9rence \u00e0 l'emplacement du palpeur. Notez que lors d'un palpage manuel, les points \"Probe\" se r\u00e9f\u00e8rent \u00e0 la fois \u00e0 l'emplacement de l'outil et de la buse.","title":"Sortie"},{"location":"Bed_Mesh.html#effacer-letat-du-maillage","text":"BED_MESH_CLEAR Ce G-Code peut \u00eatre utilis\u00e9 pour effacer l'\u00e9tat interne du maillage.","title":"Effacer l'\u00e9tat du maillage"},{"location":"Bed_Mesh.html#appliquer-les-decalages-xy","text":"BED_MESH_OFFSET [X=<value>] [Y=<value>] Ceci est utile pour les imprimantes avec plusieurs extrudeuses ind\u00e9pendantes, car un d\u00e9calage est n\u00e9cessaire pour produire un ajustement Z correct apr\u00e8s un changement d'outil. Les d\u00e9calages doivent \u00eatre indiqu\u00e9s par rapport \u00e0 l'extrudeuse primaire. C'est-\u00e0-dire qu'un d\u00e9calage X positif doit \u00eatre indiqu\u00e9 si l'extrudeuse secondaire est mont\u00e9e \u00e0 droite de l'extrudeuse primaire, et un d\u00e9calage Y positif doit \u00eatre indiqu\u00e9 si l'extrudeuse secondaire est mont\u00e9e \"derri\u00e8re\" l'extrudeuse primaire.","title":"Appliquer les d\u00e9calages X/Y"},{"location":"Benchmarks.html","text":"Tests \u00b6 Ce document d\u00e9crit les benchmarks Klipper. Bancs d'essai des microcontr\u00f4leurs \u00b6 Cette section d\u00e9crit le m\u00e9canisme utilis\u00e9 pour g\u00e9n\u00e9rer les bancs d'essais (benchmarks) de fr\u00e9quence de pas du microcontr\u00f4leur Klipper. L'objectif principal des bancs d'essais est de fournir un m\u00e9canisme coh\u00e9rent pour mesurer l'impact des changements de codage dans le logiciel. Un objectif secondaire est de fournir des mesures de haut niveau pour comparer les performances entre puces et entre plateformes logicielles. Le test de vitesse des moteurs pas \u00e0 pas est con\u00e7u pour trouver la fr\u00e9quence de pas maximale que le mat\u00e9riel et le logiciel peuvent atteindre. Ce taux de pas de r\u00e9f\u00e9rence n'est pas r\u00e9alisable dans une utilisation \"r\u00e9elle\" de Klipper car il doit effectuer d'autres t\u00e2ches (par exemple, la communication microcontr\u00f4leur(s)/h\u00f4te, la lecture de la temp\u00e9rature, la v\u00e9rification des fin de course). En g\u00e9n\u00e9ral, les broches pour les tests sont choisies pour faire clignoter des LED ou d'autres actions inoffensives. V\u00e9rifiez toujours qu'il est s\u00fbr de commander les broches configur\u00e9es avant d'ex\u00e9cuter un test. Il n'est pas recommand\u00e9 de piloter un moteur pas \u00e0 pas lors d'un test. Test du taux de pas \u00b6 Le test est effectu\u00e9 \u00e0 l'aide de l'outil console.py (d\u00e9crit dans ). Le microcontr\u00f4leur est configur\u00e9 pour la plate-forme mat\u00e9rielle (voir ci-dessous), puis ce qui suit est copi\u00e9-coll\u00e9 dans la fen\u00eatre du terminal console.py : SET start_clock {clock+freq} SET ticks 1000 reset_step_clock oid=0 clock={start_clock} set_next_step_dir oid=0 dir=0 queue_step oid=0 interval={ticks} count=60000 add=0 set_next_step_dir oid=0 dir=1 queue_step oid=0 interval=3000 count=1 add=0 reset_step_clock oid=1 clock={start_clock} set_next_step_dir oid=1 dir=0 queue_step oid=1 interval={ticks} count=60000 add=0 set_next_step_dir oid=1 dir=1 queue_step oid=1 interval=3000 count=1 add=0 reset_step_clock oid=2 clock={start_clock} set_next_step_dir oid=2 dir=0 queue_step oid=2 interval={ticks} count=60000 add=0 set_next_step_dir oid=2 dir=1 queue_step oid=2 interval=3000 count=1 add=0 Ces tests simulent le d\u00e9placement de trois moteurs pas \u00e0 pas simultan\u00e9ment. Si son ex\u00e9cution entra\u00eene une erreur \"Rescheduled timer in the past\" or \"Stepper too far in past\", cela indique que le param\u00e8tre ticks est trop faible (il en r\u00e9sulte une vitesse de pas trop rapide) . L'objectif est de trouver le r\u00e9glage le plus bas du param\u00e8tre ticks qui aboutit de mani\u00e8re fiable \u00e0 la r\u00e9ussite du test. Il devrait \u00eatre possible de rechercher par dichotomie le param\u00e8tre ticks jusqu'\u00e0 ce qu'une valeur stable soit trouv\u00e9e. En cas d'\u00e9chec, on peut copier-coller ce qui suit pour effacer l'erreur en vue du prochain test : clear_shutdown Pour obtenir les tests de moteurs pas \u00e0 pas, la m\u00eame s\u00e9quence de configuration est utilis\u00e9e, mais seul le premier bloc du test ci-dessus est copi\u00e9-coll\u00e9 dans la fen\u00eatre console.py. Pour produire les tests trouv\u00e9s dans le document Fonctionnalit\u00e9s , le nombre total de pas par seconde est calcul\u00e9 en multipliant le nombre de steppers actifs par la fr\u00e9quence mcu nominale et en divisant par le param\u00e8tre final ticks. Les r\u00e9sultats sont arrondis au K le plus proche. Par exemple, avec trois steppers actifs : ECHO Test result is: {\"%.0fK\" % (3. * freq / ticks / 1000.)} Les tests sont ex\u00e9cut\u00e9s avec des param\u00e8tres adapt\u00e9s aux pilotes TMC. Pour les microcontr\u00f4leurs prenant en charge STEPPER_BOTH_EDGE=1 (comme indiqu\u00e9 dans la ligne MCU config au premier d\u00e9marrage de console.py), utilisez step_pulse_duration=0 et invert_step=-1 pour permettre un pas optimis\u00e9 sur les deux fronts de l'impulsion de pas. Pour les autres microcontr\u00f4leurs utiliser un step_pulse_duration correspondant \u00e0 100ns. Test du taux de pas sur AVR \u00b6 La s\u00e9quence de configuration suivante est utilis\u00e9e sur les puces AVR : allocate_oids count=3 config_stepper oid=0 step_pin=PA5 dir_pin=PA4 invert_step=0 step_pulse_ticks=32 config_stepper oid=1 step_pin=PA3 dir_pin=PA2 invert_step=0 step_pulse_ticks=32 config_stepper oid=2 step_pin=PC7 dir_pin=PC6 invert_step=0 step_pulse_ticks=32 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version gcc avr-gcc (GCC) 5.4.0 . Les tests 16Mhz et 20Mhz ont \u00e9t\u00e9 ex\u00e9cut\u00e9s \u00e0 l'aide d'un simulavr configur\u00e9 pour un atmega644p (les tests pr\u00e9c\u00e9dents ont confirm\u00e9 que les r\u00e9sultats du simulavr correspondent aux tests sur un 16Mhz at90usb et un 16Mhz atmega2560). avr ticks 1 moteur pas \u00e0 pas 102 3 moteurs pas \u00e0 pas 486 Test du taux de pas sur Arduino Due \u00b6 La s\u00e9quence de configuration suivante est utilis\u00e9e sur le Due : allocate_oids count=3 config_stepper oid=0 step_pin=PB27 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PB26 dir_pin=PC30 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PA21 dir_pin=PC30 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version de gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . sam3x8e ticks 1 moteur pas \u00e0 pas 66 3 moteurs pas \u00e0 pas 257 Test du taux de pas sur Duet Maestro \u00b6 La s\u00e9quence de configuration suivante est utilis\u00e9e sur le Duet Maestro : allocate_oids count=3 config_stepper oid=0 step_pin=PC26 dir_pin=PC18 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PC26 dir_pin=PA8 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PC26 dir_pin=PB4 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version de gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . sam4s8c ticks 1 moteur pas \u00e0 pas 71 3 moteurs pas \u00e0 pas 260 Test du taux de pas sur Duet Wifi \u00b6 La s\u00e9quence de configuration suivante est utilis\u00e9e sur le Duet Wifi : allocate_oids count=3 config_stepper oid=0 step_pin=PD6 dir_pin=PD11 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PD7 dir_pin=PD12 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PD8 dir_pin=PD13 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur la validation 59314d99 avec la version gcc gcc version 10.3.1 20210621 (version) (GNU Arm Embedded Toolchain 10.3-2021.07) . sam4e8e ticks 1 moteur pas \u00e0 pas 48 3 moteurs pas \u00e0 pas 215 Test du taux de pas sur Beaglebone PRU \u00b6 La s\u00e9quence de configuration suivante est utilis\u00e9e sur le PRU : allocate_oids count=3 config_stepper oid=0 step_pin=gpio0_23 dir_pin=gpio1_12 invert_step=0 step_pulse_ticks=20 config_stepper oid=1 step_pin=gpio1_15 dir_pin=gpio0_26 invert_step=0 step_pulse_ticks=20 config_stepper oid=2 step_pin=gpio0_22 dir_pin=gpio2_1 invert_step=0 step_pulse_ticks=20 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version de gcc pru-gcc (GCC) 8.0.0 20170530 (exp\u00e9rimental) . pru ticks 1 moteur pas \u00e0 pas 231 3 moteurs pas \u00e0 pas 847 Test du taux de pas STM32F042 \u00b6 La s\u00e9quence de configuration suivante est utilis\u00e9e sur le STM32F042 : allocate_oids count=3 config_stepper oid=0 step_pin=PA1 dir_pin=PA2 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PA3 dir_pin=PA2 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PB8 dir_pin=PA2 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version de gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . stm32f042 ticks 1 moteur pas \u00e0 pas 59 3 moteurs pas \u00e0 pas 249 Test du taux de pas sur STM32F103 \u00b6 La s\u00e9quence de configuration suivante est utilis\u00e9e sur le STM32F103 : allocate_oids count=3 config_stepper oid=0 step_pin=PC13 dir_pin=PB5 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PB3 dir_pin=PB6 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PA4 dir_pin=PB7 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version de gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . stm32f103 ticks 1 moteur pas \u00e0 pas 61 3 moteurs pas \u00e0 pas 264 Test du taux de pas sur STM32F4 \u00b6 La s\u00e9quence de configuration suivante est utilis\u00e9e sur le STM32F4 : allocate_oids count=3 config_stepper oid=0 step_pin=PA5 dir_pin=PB5 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PB2 dir_pin=PB6 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PB3 dir_pin=PB7 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version de gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . Les r\u00e9sultats STM32F407 ont \u00e9t\u00e9 obtenus en ex\u00e9cutant un binaire STM32F407 sur un STM32F446 (et donc en utilisant une horloge de 168 MHz). stm32f446 ticks 1 moteur pas \u00e0 pas 46 3 moteurs pas \u00e0 pas 205 stm32f407 ticks 1 moteur pas \u00e0 pas 46 3 moteurs pas \u00e0 pas 205 Test du taux de pas sur STM32H7 \u00b6 La s\u00e9quence de configuration suivante est utilis\u00e9e sur un STM32H743VIT6 : allocate_oids count=3 config_stepper oid=0 step_pin=PD4 dir_pin=PD3 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PA15 dir_pin=PA8 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PE2 dir_pin=PE3 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 00191b5c avec la version de gcc arm-none-eabi-gcc (15:8-2019-q3-1+b1) 8.3.1 20190703 (release) [gcc- 8 branches r\u00e9vision 273027] . stm32h7 ticks 1 moteur pas \u00e0 pas 44 3 moteurs pas \u00e0 pas 198 Test du taux de pas sur STM32G0B1 \u00b6 La s\u00e9quence de configuration suivante est utilis\u00e9e sur le STM32G0B1 : allocate_oids count=3 config_stepper oid=0 step_pin=PB13 dir_pin=PB12 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PB10 dir_pin=PB2 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PB0 dir_pin=PC5 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 247cd753 avec la version gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . stm32g0b1 ticks 1 moteur pas \u00e0 pas 58 3 moteurs pas \u00e0 pas 243 Test du taux de pas sur LPC176x \u00b6 La s\u00e9quence de configuration suivante est utilis\u00e9e sur le LPC176x : allocate_oids count=3 config_stepper oid=0 step_pin=P1.20 dir_pin=P1.18 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=P1.21 dir_pin=P1.18 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=P1.23 dir_pin=P1.18 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version de gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . Les r\u00e9sultats du LPC1769 \u00e0 120Mhz ont \u00e9t\u00e9 obtenus en overclockant un LPC1768 \u00e0 120Mhz. lpc1768 ticks 1 moteur pas \u00e0 pas 52 3 moteurs pas \u00e0 pas 222 lpc1769 ticks 1 moteur pas \u00e0 pas 51 3 moteurs pas \u00e0 pas 222 Test du taux de pas sur SAMD21 \u00b6 La s\u00e9quence de configuration suivante est utilis\u00e9e sur le SAMD21 : allocate_oids count=3 config_stepper oid=0 step_pin=PA27 dir_pin=PA20 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PB3 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PA17 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version de gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 sur un microcontr\u00f4leur SAMD21G18. samd21 ticks 1 moteur pas \u00e0 pas 70 3 moteurs pas \u00e0 pas 306 Test du taux de pas sur SAMD51 \u00b6 La s\u00e9quence de configuration suivante est utilis\u00e9e sur le SAMD51 : allocate_oids count=3 config_stepper oid=0 step_pin=PA22 dir_pin=PA20 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PA22 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PA22 dir_pin=PA19 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 sur un microcontr\u00f4leur SAMD51J19A. samd51 ticks 1 moteur pas \u00e0 pas 39 3 moteurs pas \u00e0 pas 191 1 moteur pas \u00e0 pas (200Mhz) 39 3 moteurs pas \u00e0 pas (200Mhz) 181 Test du taux de pas de l'AR100 \u00b6 La s\u00e9quence de configuration suivante est utilis\u00e9e sur le processeur AR100 (Allwinner A64) : allocate_oids count=3 config_stepper oid=0 step_pin=PL10 dir_pin=PE14 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PL11 dir_pin=PE15 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PL12 dir_pin=PE16 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 08d037c6 avec la version de gcc or1k-linux-musl-gcc (GCC) 9.2.0 sur un microcontr\u00f4leur Allwinner A64-H. AR100 R_PIO ticks 1 moteur pas \u00e0 pas 85 3 moteurs pas \u00e0 pas 359 Test du taux de pas sur RP2040 \u00b6 La s\u00e9quence de configuration suivante est utilis\u00e9e sur le RP2040 : allocate_oids count=3 config_stepper oid=0 step_pin=gpio25 dir_pin=gpio3 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=gpio26 dir_pin=gpio4 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=gpio27 dir_pin=gpio5 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 sur une carte Raspberry Pi Pico. rp2040 ticks 1 moteur pas \u00e0 pas 5 3 moteurs pas \u00e0 pas 22 Test du taux de pas pour le MCU Linux \u00b6 La s\u00e9quence de configuration suivante est utilis\u00e9e sur un Raspberry Pi : allocate_oids count=3 config_stepper oid=0 step_pin=gpio2 dir_pin=gpio3 invert_step=0 step_pulse_ticks=5 config_stepper oid=1 step_pin=gpio4 dir_pin=gpio5 invert_step=0 step_pulse_ticks=5 config_stepper oid=2 step_pin=gpio6 dir_pin=gpio17 invert_step=0 step_pulse_ticks=5 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version gcc gcc (Raspbian 8.3.0-6+rpi1) 8.3.0 sur un Raspberry Pi 3 (r\u00e9vision a02082). Il \u00e9tait difficile d'obtenir des r\u00e9sultats stables dans ce benchmark. Linux (RPi3) ticks 1 moteur pas \u00e0 pas 160 3 moteurs pas \u00e0 pas 380 Test de r\u00e9partition des commandes \u00b6 Le test de r\u00e9partition des commandes teste le nombre de commandes \"factices\" que le microcontr\u00f4leur peut traiter. Il s'agit principalement d'un test du m\u00e9canisme de communication mat\u00e9riel. Le test est ex\u00e9cut\u00e9 \u00e0 l'aide de l'outil console.py (d\u00e9crit dans ). Ce qui suit est copi\u00e9-coll\u00e9 dans la fen\u00eatre du terminal console.py : DELAY {clock + 2*freq} get_uptime FLOOD 100000 0.0 debug_nop get_uptime Une fois le test termin\u00e9, d\u00e9terminez la diff\u00e9rence entre les horloges signal\u00e9es dans les deux messages de r\u00e9ponse \"uptime\". Le nombre total de commandes par seconde est alors 100000 * mcu_frequency / clock_diff . Notez que ce test peut saturer la capacit\u00e9 USB/CPU d'un Raspberry Pi. En cas d'ex\u00e9cution sur un Raspberry Pi, Beaglebone ou un ordinateur h\u00f4te similaire, augmentez le d\u00e9lai (par exemple, DELAY {clock + 20*freq} get_uptime ). Le cas \u00e9ch\u00e9ant, les tests de performances ci-dessous concernent console.py ex\u00e9cut\u00e9 sur une machine de bureau avec l'appareil connect\u00e9 via un concentrateur \u00e0 haut d\u00e9bit. MCU Fr\u00e9quence Version Compilateur stm32f042 (CAN) 18K c105adc8 arm-none-eabi-gcc (GNU Tools 7-2018-q3-update) 7.3.1 atmega2560 (serial) 23K b161a69e avr-gcc (GCC) 4.8.1 sam3x8e (serial) 23K b161a69e arm-none-eabi-gcc (Fedora 7.1.0-5.fc27) 7.1.0 at90usb1286 (USB) 75K 01d2183f avr-gcc (GCC) 5.4.0 ar100 (s\u00e9rie) 138K 08d037c6 or1k-linux-musl-gcc 9.3.0 samd21 (USB) 223K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 pru (m\u00e9moire partag\u00e9e) 260K c5968a08 pru-gcc (GCC) 8.0.0 20170530 (exp\u00e9rimental) stm32f103 (USB) 355K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 sam3x8e (USB) 418K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 lpc1768 (USB) 534K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 lpc1769 (USB) 628K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 sam4s8c (USB) 650K 8d4a5c16 arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 samd51 (USB) 864K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 stm32f446 (USB) 870K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 rp2040 (USB) 873K c5667193 arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 Tests de l'h\u00f4te \u00b6 Il est possible d'ex\u00e9cuter des tests de temporisation sur le logiciel h\u00f4te en utilisant le m\u00e9canisme de traitement \"mode batch\" (d\u00e9crit dans ). Cela se fait g\u00e9n\u00e9ralement en choisissant un fichier G-Code volumineux et complexe et en chronom\u00e9trant le temps n\u00e9cessaire au logiciel h\u00f4te pour le traiter. Par example\u202f: time ~/klippy-env/bin/python ./klippy/klippy.py config/example-cartesian.cfg -i something_complex.gcode -o /dev/null -d out/klipper.dict","title":"Tests"},{"location":"Benchmarks.html#tests","text":"Ce document d\u00e9crit les benchmarks Klipper.","title":"Tests"},{"location":"Benchmarks.html#bancs-dessai-des-microcontroleurs","text":"Cette section d\u00e9crit le m\u00e9canisme utilis\u00e9 pour g\u00e9n\u00e9rer les bancs d'essais (benchmarks) de fr\u00e9quence de pas du microcontr\u00f4leur Klipper. L'objectif principal des bancs d'essais est de fournir un m\u00e9canisme coh\u00e9rent pour mesurer l'impact des changements de codage dans le logiciel. Un objectif secondaire est de fournir des mesures de haut niveau pour comparer les performances entre puces et entre plateformes logicielles. Le test de vitesse des moteurs pas \u00e0 pas est con\u00e7u pour trouver la fr\u00e9quence de pas maximale que le mat\u00e9riel et le logiciel peuvent atteindre. Ce taux de pas de r\u00e9f\u00e9rence n'est pas r\u00e9alisable dans une utilisation \"r\u00e9elle\" de Klipper car il doit effectuer d'autres t\u00e2ches (par exemple, la communication microcontr\u00f4leur(s)/h\u00f4te, la lecture de la temp\u00e9rature, la v\u00e9rification des fin de course). En g\u00e9n\u00e9ral, les broches pour les tests sont choisies pour faire clignoter des LED ou d'autres actions inoffensives. V\u00e9rifiez toujours qu'il est s\u00fbr de commander les broches configur\u00e9es avant d'ex\u00e9cuter un test. Il n'est pas recommand\u00e9 de piloter un moteur pas \u00e0 pas lors d'un test.","title":"Bancs d'essai des microcontr\u00f4leurs"},{"location":"Benchmarks.html#test-du-taux-de-pas","text":"Le test est effectu\u00e9 \u00e0 l'aide de l'outil console.py (d\u00e9crit dans ). Le microcontr\u00f4leur est configur\u00e9 pour la plate-forme mat\u00e9rielle (voir ci-dessous), puis ce qui suit est copi\u00e9-coll\u00e9 dans la fen\u00eatre du terminal console.py : SET start_clock {clock+freq} SET ticks 1000 reset_step_clock oid=0 clock={start_clock} set_next_step_dir oid=0 dir=0 queue_step oid=0 interval={ticks} count=60000 add=0 set_next_step_dir oid=0 dir=1 queue_step oid=0 interval=3000 count=1 add=0 reset_step_clock oid=1 clock={start_clock} set_next_step_dir oid=1 dir=0 queue_step oid=1 interval={ticks} count=60000 add=0 set_next_step_dir oid=1 dir=1 queue_step oid=1 interval=3000 count=1 add=0 reset_step_clock oid=2 clock={start_clock} set_next_step_dir oid=2 dir=0 queue_step oid=2 interval={ticks} count=60000 add=0 set_next_step_dir oid=2 dir=1 queue_step oid=2 interval=3000 count=1 add=0 Ces tests simulent le d\u00e9placement de trois moteurs pas \u00e0 pas simultan\u00e9ment. Si son ex\u00e9cution entra\u00eene une erreur \"Rescheduled timer in the past\" or \"Stepper too far in past\", cela indique que le param\u00e8tre ticks est trop faible (il en r\u00e9sulte une vitesse de pas trop rapide) . L'objectif est de trouver le r\u00e9glage le plus bas du param\u00e8tre ticks qui aboutit de mani\u00e8re fiable \u00e0 la r\u00e9ussite du test. Il devrait \u00eatre possible de rechercher par dichotomie le param\u00e8tre ticks jusqu'\u00e0 ce qu'une valeur stable soit trouv\u00e9e. En cas d'\u00e9chec, on peut copier-coller ce qui suit pour effacer l'erreur en vue du prochain test : clear_shutdown Pour obtenir les tests de moteurs pas \u00e0 pas, la m\u00eame s\u00e9quence de configuration est utilis\u00e9e, mais seul le premier bloc du test ci-dessus est copi\u00e9-coll\u00e9 dans la fen\u00eatre console.py. Pour produire les tests trouv\u00e9s dans le document Fonctionnalit\u00e9s , le nombre total de pas par seconde est calcul\u00e9 en multipliant le nombre de steppers actifs par la fr\u00e9quence mcu nominale et en divisant par le param\u00e8tre final ticks. Les r\u00e9sultats sont arrondis au K le plus proche. Par exemple, avec trois steppers actifs : ECHO Test result is: {\"%.0fK\" % (3. * freq / ticks / 1000.)} Les tests sont ex\u00e9cut\u00e9s avec des param\u00e8tres adapt\u00e9s aux pilotes TMC. Pour les microcontr\u00f4leurs prenant en charge STEPPER_BOTH_EDGE=1 (comme indiqu\u00e9 dans la ligne MCU config au premier d\u00e9marrage de console.py), utilisez step_pulse_duration=0 et invert_step=-1 pour permettre un pas optimis\u00e9 sur les deux fronts de l'impulsion de pas. Pour les autres microcontr\u00f4leurs utiliser un step_pulse_duration correspondant \u00e0 100ns.","title":"Test du taux de pas"},{"location":"Benchmarks.html#test-du-taux-de-pas-sur-avr","text":"La s\u00e9quence de configuration suivante est utilis\u00e9e sur les puces AVR : allocate_oids count=3 config_stepper oid=0 step_pin=PA5 dir_pin=PA4 invert_step=0 step_pulse_ticks=32 config_stepper oid=1 step_pin=PA3 dir_pin=PA2 invert_step=0 step_pulse_ticks=32 config_stepper oid=2 step_pin=PC7 dir_pin=PC6 invert_step=0 step_pulse_ticks=32 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version gcc avr-gcc (GCC) 5.4.0 . Les tests 16Mhz et 20Mhz ont \u00e9t\u00e9 ex\u00e9cut\u00e9s \u00e0 l'aide d'un simulavr configur\u00e9 pour un atmega644p (les tests pr\u00e9c\u00e9dents ont confirm\u00e9 que les r\u00e9sultats du simulavr correspondent aux tests sur un 16Mhz at90usb et un 16Mhz atmega2560). avr ticks 1 moteur pas \u00e0 pas 102 3 moteurs pas \u00e0 pas 486","title":"Test du taux de pas sur AVR"},{"location":"Benchmarks.html#test-du-taux-de-pas-sur-arduino-due","text":"La s\u00e9quence de configuration suivante est utilis\u00e9e sur le Due : allocate_oids count=3 config_stepper oid=0 step_pin=PB27 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PB26 dir_pin=PC30 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PA21 dir_pin=PC30 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version de gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . sam3x8e ticks 1 moteur pas \u00e0 pas 66 3 moteurs pas \u00e0 pas 257","title":"Test du taux de pas sur Arduino Due"},{"location":"Benchmarks.html#test-du-taux-de-pas-sur-duet-maestro","text":"La s\u00e9quence de configuration suivante est utilis\u00e9e sur le Duet Maestro : allocate_oids count=3 config_stepper oid=0 step_pin=PC26 dir_pin=PC18 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PC26 dir_pin=PA8 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PC26 dir_pin=PB4 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version de gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . sam4s8c ticks 1 moteur pas \u00e0 pas 71 3 moteurs pas \u00e0 pas 260","title":"Test du taux de pas sur Duet Maestro"},{"location":"Benchmarks.html#test-du-taux-de-pas-sur-duet-wifi","text":"La s\u00e9quence de configuration suivante est utilis\u00e9e sur le Duet Wifi : allocate_oids count=3 config_stepper oid=0 step_pin=PD6 dir_pin=PD11 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PD7 dir_pin=PD12 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PD8 dir_pin=PD13 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur la validation 59314d99 avec la version gcc gcc version 10.3.1 20210621 (version) (GNU Arm Embedded Toolchain 10.3-2021.07) . sam4e8e ticks 1 moteur pas \u00e0 pas 48 3 moteurs pas \u00e0 pas 215","title":"Test du taux de pas sur Duet Wifi"},{"location":"Benchmarks.html#test-du-taux-de-pas-sur-beaglebone-pru","text":"La s\u00e9quence de configuration suivante est utilis\u00e9e sur le PRU : allocate_oids count=3 config_stepper oid=0 step_pin=gpio0_23 dir_pin=gpio1_12 invert_step=0 step_pulse_ticks=20 config_stepper oid=1 step_pin=gpio1_15 dir_pin=gpio0_26 invert_step=0 step_pulse_ticks=20 config_stepper oid=2 step_pin=gpio0_22 dir_pin=gpio2_1 invert_step=0 step_pulse_ticks=20 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version de gcc pru-gcc (GCC) 8.0.0 20170530 (exp\u00e9rimental) . pru ticks 1 moteur pas \u00e0 pas 231 3 moteurs pas \u00e0 pas 847","title":"Test du taux de pas sur Beaglebone PRU"},{"location":"Benchmarks.html#test-du-taux-de-pas-stm32f042","text":"La s\u00e9quence de configuration suivante est utilis\u00e9e sur le STM32F042 : allocate_oids count=3 config_stepper oid=0 step_pin=PA1 dir_pin=PA2 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PA3 dir_pin=PA2 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PB8 dir_pin=PA2 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version de gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . stm32f042 ticks 1 moteur pas \u00e0 pas 59 3 moteurs pas \u00e0 pas 249","title":"Test du taux de pas STM32F042"},{"location":"Benchmarks.html#test-du-taux-de-pas-sur-stm32f103","text":"La s\u00e9quence de configuration suivante est utilis\u00e9e sur le STM32F103 : allocate_oids count=3 config_stepper oid=0 step_pin=PC13 dir_pin=PB5 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PB3 dir_pin=PB6 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PA4 dir_pin=PB7 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version de gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . stm32f103 ticks 1 moteur pas \u00e0 pas 61 3 moteurs pas \u00e0 pas 264","title":"Test du taux de pas sur STM32F103"},{"location":"Benchmarks.html#test-du-taux-de-pas-sur-stm32f4","text":"La s\u00e9quence de configuration suivante est utilis\u00e9e sur le STM32F4 : allocate_oids count=3 config_stepper oid=0 step_pin=PA5 dir_pin=PB5 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PB2 dir_pin=PB6 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PB3 dir_pin=PB7 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version de gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . Les r\u00e9sultats STM32F407 ont \u00e9t\u00e9 obtenus en ex\u00e9cutant un binaire STM32F407 sur un STM32F446 (et donc en utilisant une horloge de 168 MHz). stm32f446 ticks 1 moteur pas \u00e0 pas 46 3 moteurs pas \u00e0 pas 205 stm32f407 ticks 1 moteur pas \u00e0 pas 46 3 moteurs pas \u00e0 pas 205","title":"Test du taux de pas sur STM32F4"},{"location":"Benchmarks.html#test-du-taux-de-pas-sur-stm32h7","text":"La s\u00e9quence de configuration suivante est utilis\u00e9e sur un STM32H743VIT6 : allocate_oids count=3 config_stepper oid=0 step_pin=PD4 dir_pin=PD3 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PA15 dir_pin=PA8 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PE2 dir_pin=PE3 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 00191b5c avec la version de gcc arm-none-eabi-gcc (15:8-2019-q3-1+b1) 8.3.1 20190703 (release) [gcc- 8 branches r\u00e9vision 273027] . stm32h7 ticks 1 moteur pas \u00e0 pas 44 3 moteurs pas \u00e0 pas 198","title":"Test du taux de pas sur STM32H7"},{"location":"Benchmarks.html#test-du-taux-de-pas-sur-stm32g0b1","text":"La s\u00e9quence de configuration suivante est utilis\u00e9e sur le STM32G0B1 : allocate_oids count=3 config_stepper oid=0 step_pin=PB13 dir_pin=PB12 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PB10 dir_pin=PB2 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PB0 dir_pin=PC5 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 247cd753 avec la version gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . stm32g0b1 ticks 1 moteur pas \u00e0 pas 58 3 moteurs pas \u00e0 pas 243","title":"Test du taux de pas sur STM32G0B1"},{"location":"Benchmarks.html#test-du-taux-de-pas-sur-lpc176x","text":"La s\u00e9quence de configuration suivante est utilis\u00e9e sur le LPC176x : allocate_oids count=3 config_stepper oid=0 step_pin=P1.20 dir_pin=P1.18 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=P1.21 dir_pin=P1.18 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=P1.23 dir_pin=P1.18 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version de gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 . Les r\u00e9sultats du LPC1769 \u00e0 120Mhz ont \u00e9t\u00e9 obtenus en overclockant un LPC1768 \u00e0 120Mhz. lpc1768 ticks 1 moteur pas \u00e0 pas 52 3 moteurs pas \u00e0 pas 222 lpc1769 ticks 1 moteur pas \u00e0 pas 51 3 moteurs pas \u00e0 pas 222","title":"Test du taux de pas sur LPC176x"},{"location":"Benchmarks.html#test-du-taux-de-pas-sur-samd21","text":"La s\u00e9quence de configuration suivante est utilis\u00e9e sur le SAMD21 : allocate_oids count=3 config_stepper oid=0 step_pin=PA27 dir_pin=PA20 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PB3 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PA17 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version de gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 sur un microcontr\u00f4leur SAMD21G18. samd21 ticks 1 moteur pas \u00e0 pas 70 3 moteurs pas \u00e0 pas 306","title":"Test du taux de pas sur SAMD21"},{"location":"Benchmarks.html#test-du-taux-de-pas-sur-samd51","text":"La s\u00e9quence de configuration suivante est utilis\u00e9e sur le SAMD51 : allocate_oids count=3 config_stepper oid=0 step_pin=PA22 dir_pin=PA20 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PA22 dir_pin=PA21 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PA22 dir_pin=PA19 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 sur un microcontr\u00f4leur SAMD51J19A. samd51 ticks 1 moteur pas \u00e0 pas 39 3 moteurs pas \u00e0 pas 191 1 moteur pas \u00e0 pas (200Mhz) 39 3 moteurs pas \u00e0 pas (200Mhz) 181","title":"Test du taux de pas sur SAMD51"},{"location":"Benchmarks.html#test-du-taux-de-pas-de-lar100","text":"La s\u00e9quence de configuration suivante est utilis\u00e9e sur le processeur AR100 (Allwinner A64) : allocate_oids count=3 config_stepper oid=0 step_pin=PL10 dir_pin=PE14 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=PL11 dir_pin=PE15 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=PL12 dir_pin=PE16 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 08d037c6 avec la version de gcc or1k-linux-musl-gcc (GCC) 9.2.0 sur un microcontr\u00f4leur Allwinner A64-H. AR100 R_PIO ticks 1 moteur pas \u00e0 pas 85 3 moteurs pas \u00e0 pas 359","title":"Test du taux de pas de l'AR100"},{"location":"Benchmarks.html#test-du-taux-de-pas-sur-rp2040","text":"La s\u00e9quence de configuration suivante est utilis\u00e9e sur le RP2040 : allocate_oids count=3 config_stepper oid=0 step_pin=gpio25 dir_pin=gpio3 invert_step=-1 step_pulse_ticks=0 config_stepper oid=1 step_pin=gpio26 dir_pin=gpio4 invert_step=-1 step_pulse_ticks=0 config_stepper oid=2 step_pin=gpio27 dir_pin=gpio5 invert_step=-1 step_pulse_ticks=0 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version gcc arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0 sur une carte Raspberry Pi Pico. rp2040 ticks 1 moteur pas \u00e0 pas 5 3 moteurs pas \u00e0 pas 22","title":"Test du taux de pas sur RP2040"},{"location":"Benchmarks.html#test-du-taux-de-pas-pour-le-mcu-linux","text":"La s\u00e9quence de configuration suivante est utilis\u00e9e sur un Raspberry Pi : allocate_oids count=3 config_stepper oid=0 step_pin=gpio2 dir_pin=gpio3 invert_step=0 step_pulse_ticks=5 config_stepper oid=1 step_pin=gpio4 dir_pin=gpio5 invert_step=0 step_pulse_ticks=5 config_stepper oid=2 step_pin=gpio6 dir_pin=gpio17 invert_step=0 step_pulse_ticks=5 finalize_config crc=0 Le test a \u00e9t\u00e9 ex\u00e9cut\u00e9 pour la derni\u00e8re fois sur le commit 59314d99 avec la version gcc gcc (Raspbian 8.3.0-6+rpi1) 8.3.0 sur un Raspberry Pi 3 (r\u00e9vision a02082). Il \u00e9tait difficile d'obtenir des r\u00e9sultats stables dans ce benchmark. Linux (RPi3) ticks 1 moteur pas \u00e0 pas 160 3 moteurs pas \u00e0 pas 380","title":"Test du taux de pas pour le MCU Linux"},{"location":"Benchmarks.html#test-de-repartition-des-commandes","text":"Le test de r\u00e9partition des commandes teste le nombre de commandes \"factices\" que le microcontr\u00f4leur peut traiter. Il s'agit principalement d'un test du m\u00e9canisme de communication mat\u00e9riel. Le test est ex\u00e9cut\u00e9 \u00e0 l'aide de l'outil console.py (d\u00e9crit dans ). Ce qui suit est copi\u00e9-coll\u00e9 dans la fen\u00eatre du terminal console.py : DELAY {clock + 2*freq} get_uptime FLOOD 100000 0.0 debug_nop get_uptime Une fois le test termin\u00e9, d\u00e9terminez la diff\u00e9rence entre les horloges signal\u00e9es dans les deux messages de r\u00e9ponse \"uptime\". Le nombre total de commandes par seconde est alors 100000 * mcu_frequency / clock_diff . Notez que ce test peut saturer la capacit\u00e9 USB/CPU d'un Raspberry Pi. En cas d'ex\u00e9cution sur un Raspberry Pi, Beaglebone ou un ordinateur h\u00f4te similaire, augmentez le d\u00e9lai (par exemple, DELAY {clock + 20*freq} get_uptime ). Le cas \u00e9ch\u00e9ant, les tests de performances ci-dessous concernent console.py ex\u00e9cut\u00e9 sur une machine de bureau avec l'appareil connect\u00e9 via un concentrateur \u00e0 haut d\u00e9bit. MCU Fr\u00e9quence Version Compilateur stm32f042 (CAN) 18K c105adc8 arm-none-eabi-gcc (GNU Tools 7-2018-q3-update) 7.3.1 atmega2560 (serial) 23K b161a69e avr-gcc (GCC) 4.8.1 sam3x8e (serial) 23K b161a69e arm-none-eabi-gcc (Fedora 7.1.0-5.fc27) 7.1.0 at90usb1286 (USB) 75K 01d2183f avr-gcc (GCC) 5.4.0 ar100 (s\u00e9rie) 138K 08d037c6 or1k-linux-musl-gcc 9.3.0 samd21 (USB) 223K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 pru (m\u00e9moire partag\u00e9e) 260K c5968a08 pru-gcc (GCC) 8.0.0 20170530 (exp\u00e9rimental) stm32f103 (USB) 355K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 sam3x8e (USB) 418K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 lpc1768 (USB) 534K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 lpc1769 (USB) 628K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 sam4s8c (USB) 650K 8d4a5c16 arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 samd51 (USB) 864K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 stm32f446 (USB) 870K 01d2183f arm-none-eabi-gcc (Fedora 7.4.0-1.fc30) 7.4.0 rp2040 (USB) 873K c5667193 arm-none-eabi-gcc (Fedora 10.2.0-4.fc34) 10.2.0","title":"Test de r\u00e9partition des commandes"},{"location":"Benchmarks.html#tests-de-lhote","text":"Il est possible d'ex\u00e9cuter des tests de temporisation sur le logiciel h\u00f4te en utilisant le m\u00e9canisme de traitement \"mode batch\" (d\u00e9crit dans ). Cela se fait g\u00e9n\u00e9ralement en choisissant un fichier G-Code volumineux et complexe et en chronom\u00e9trant le temps n\u00e9cessaire au logiciel h\u00f4te pour le traiter. Par example\u202f: time ~/klippy-env/bin/python ./klippy/klippy.py config/example-cartesian.cfg -i something_complex.gcode -o /dev/null -d out/klipper.dict","title":"Tests de l'h\u00f4te"},{"location":"Bootloader_Entry.html","text":"Bootloader Entry \u00b6 Klipper can be instructed to reboot into a Bootloader in one of the following ways: Requesting the bootloader \u00b6 Virtual Serial \u00b6 If a virtual (USB-ACM) serial port is in use, pulsing DTR while at 1200 baud will request the bootloader. Python (with flash_usb ) \u00b6 To enter the bootloader using python (using flash_usb ): > cd klipper/scripts > python3 -c 'import flash_usb as u; u.enter_bootloader(\"<DEVICE>\")' Entering bootloader on <DEVICE> Where <DEVICE> is your serial device, such as /dev/serial.by-id/usb-Klipper[...] or /dev/ttyACM0 Note that if this fails, no output will be printed, success is indicated by printing Entering bootloader on <DEVICE> . Picocom \u00b6 picocom -b 1200 <DEVICE> <Ctrl-A><Ctrl-P> Where <DEVICE> is your serial device, such as /dev/serial.by-id/usb-Klipper[...] or /dev/ttyACM0 <Ctrl-A><Ctrl-P> means holding Ctrl , pressing and releasing a , pressing and releasing p , then releasing Ctrl Physical serial \u00b6 If a physical serial port is being used on the MCU (even if a USB serial adapter is being used to connect to it), sending the string <SPACE><FS><SPACE>Request Serial Bootloader!!<SPACE>~ . <SPACE> is an ASCII literal space, 0x20. <FS> is the ASCII File Separator, 0x1c. Note that this is not a valid message as per the MCU Protocol , but sync characters( ~ ) are still respected. Because this message must be the only thing in the \"block\" it is received in, prefixing an extra sync character can increase reliability if other tools were previously accessing the serial port. Shell \u00b6 stty <BAUD> < /dev/<DEVICE> echo $'~ \\x1c Request Serial Bootloader!! ~' >> /dev/<DEVICE> Where <DEVICE> is your serial port, such as /dev/ttyS0 , or /dev/serial/by-id/gpio-serial2 , and <BAUD> is the baud rate of the serial port, such as 115200 . CANBUS \u00b6 If CANBUS is in use, a special admin message will request the bootloader. This message will be respected even if the device already has a nodeid, and will also be processed if the mcu is shutdown. This method also applies to devices operating in CANBridge mode. Katapult's flashtool.py \u00b6 python3 ./katapult/scripts/flashtool.py -i <CAN_IFACE> -u <UUID> -r Where <CAN_IFACE> is the can interface to use. If using can0 , both the -i and <CAN_IFACE> may be omitted. <UUID> is the UUID of your CAN device. See the CANBUS Documentation for information on finding the CAN UUID of your devices. Entering the bootloader \u00b6 When klipper receives one of the above bootloader requests: If Katapult (formerly known as CANBoot) is available, klipper will request that Katapult stay active on the next boot, then reset the MCU (therefore entering Katapult). If Katapult is not available, klipper will then try to enter a platform-specific bootloader, such as STM32's DFU mode( see note ). In short, Klipper will reboot to Katapult if installed, then a hardware specific bootloader if available. For details about the specific bootloaders on various platforms see Bootloaders Notes \u00b6 STM32 DFU Warning \u00b6 Note that on some boards, like the Octopus Pro v1, entering DFU mode can cause undesired actions (such as powering the heater while in DFU mode). It is recommended to disconnect heaters, and otherwise prevent undesired operations when using DFU mode. Consult the documentation for your board for more details.","title":"Bootloader Entry"},{"location":"Bootloader_Entry.html#bootloader-entry","text":"Klipper can be instructed to reboot into a Bootloader in one of the following ways:","title":"Bootloader Entry"},{"location":"Bootloader_Entry.html#requesting-the-bootloader","text":"","title":"Requesting the bootloader"},{"location":"Bootloader_Entry.html#virtual-serial","text":"If a virtual (USB-ACM) serial port is in use, pulsing DTR while at 1200 baud will request the bootloader.","title":"Virtual Serial"},{"location":"Bootloader_Entry.html#python-with-flash_usb","text":"To enter the bootloader using python (using flash_usb ): > cd klipper/scripts > python3 -c 'import flash_usb as u; u.enter_bootloader(\"<DEVICE>\")' Entering bootloader on <DEVICE> Where <DEVICE> is your serial device, such as /dev/serial.by-id/usb-Klipper[...] or /dev/ttyACM0 Note that if this fails, no output will be printed, success is indicated by printing Entering bootloader on <DEVICE> .","title":"Python (with flash_usb)"},{"location":"Bootloader_Entry.html#picocom","text":"picocom -b 1200 <DEVICE> <Ctrl-A><Ctrl-P> Where <DEVICE> is your serial device, such as /dev/serial.by-id/usb-Klipper[...] or /dev/ttyACM0 <Ctrl-A><Ctrl-P> means holding Ctrl , pressing and releasing a , pressing and releasing p , then releasing Ctrl","title":"Picocom"},{"location":"Bootloader_Entry.html#physical-serial","text":"If a physical serial port is being used on the MCU (even if a USB serial adapter is being used to connect to it), sending the string <SPACE><FS><SPACE>Request Serial Bootloader!!<SPACE>~ . <SPACE> is an ASCII literal space, 0x20. <FS> is the ASCII File Separator, 0x1c. Note that this is not a valid message as per the MCU Protocol , but sync characters( ~ ) are still respected. Because this message must be the only thing in the \"block\" it is received in, prefixing an extra sync character can increase reliability if other tools were previously accessing the serial port.","title":"Physical serial"},{"location":"Bootloader_Entry.html#shell","text":"stty <BAUD> < /dev/<DEVICE> echo $'~ \\x1c Request Serial Bootloader!! ~' >> /dev/<DEVICE> Where <DEVICE> is your serial port, such as /dev/ttyS0 , or /dev/serial/by-id/gpio-serial2 , and <BAUD> is the baud rate of the serial port, such as 115200 .","title":"Shell"},{"location":"Bootloader_Entry.html#canbus","text":"If CANBUS is in use, a special admin message will request the bootloader. This message will be respected even if the device already has a nodeid, and will also be processed if the mcu is shutdown. This method also applies to devices operating in CANBridge mode.","title":"CANBUS"},{"location":"Bootloader_Entry.html#katapults-flashtoolpy","text":"python3 ./katapult/scripts/flashtool.py -i <CAN_IFACE> -u <UUID> -r Where <CAN_IFACE> is the can interface to use. If using can0 , both the -i and <CAN_IFACE> may be omitted. <UUID> is the UUID of your CAN device. See the CANBUS Documentation for information on finding the CAN UUID of your devices.","title":"Katapult's flashtool.py"},{"location":"Bootloader_Entry.html#entering-the-bootloader","text":"When klipper receives one of the above bootloader requests: If Katapult (formerly known as CANBoot) is available, klipper will request that Katapult stay active on the next boot, then reset the MCU (therefore entering Katapult). If Katapult is not available, klipper will then try to enter a platform-specific bootloader, such as STM32's DFU mode( see note ). In short, Klipper will reboot to Katapult if installed, then a hardware specific bootloader if available. For details about the specific bootloaders on various platforms see Bootloaders","title":"Entering the bootloader"},{"location":"Bootloader_Entry.html#notes","text":"","title":"Notes"},{"location":"Bootloader_Entry.html#stm32-dfu-warning","text":"Note that on some boards, like the Octopus Pro v1, entering DFU mode can cause undesired actions (such as powering the heater while in DFU mode). It is recommended to disconnect heaters, and otherwise prevent undesired operations when using DFU mode. Consult the documentation for your board for more details.","title":"STM32 DFU Warning"},{"location":"Bootloaders.html","text":"Chargeurs de d\u00e9marrage \u00b6 Ce document fournit des informations sur les \"chargeurs de d\u00e9marrage\" ou \"Bootloaders\" courants trouv\u00e9s sur les microcontr\u00f4leurs pris en charge par Klipper. Le chargeur de d\u00e9marrage est un logiciel tiers qui s'ex\u00e9cute sur le microcontr\u00f4leur lors de sa premi\u00e8re mise sous tension. Il est g\u00e9n\u00e9ralement utilis\u00e9 pour flasher une nouvelle application (par exemple, Klipper) sur le microcontr\u00f4leur sans n\u00e9cessiter de mat\u00e9riel sp\u00e9cialis\u00e9. Malheureusement, il n'existe pas de norme \u00e0 l'\u00e9chelle de l'industrie pour flasher un microcontr\u00f4leur, ni de chargeur de d\u00e9marrage standard qui fonctionne sur tous les microcontr\u00f4leurs. Pire encore, il est courant que chaque chargeur de d\u00e9marrage n\u00e9cessite un ensemble d'\u00e9tapes diff\u00e9rent pour flasher une application. Si l'on peut flasher un chargeur de d\u00e9marrage sur un microcontr\u00f4leur, on peut g\u00e9n\u00e9ralement \u00e9galement utiliser ce m\u00e9canisme pour flasher une application, mais il faut faire attention en faisant cela car on peut supprimer le chargeur de d\u00e9marrage par inadvertance. En revanche, un chargeur de d\u00e9marrage permettra g\u00e9n\u00e9ralement \u00e0 un utilisateur de flasher une application. Il est donc recommand\u00e9 d'utiliser le chargeur de d\u00e9marrage pour flasher une application lorsque cela est possible. Ce document tente de d\u00e9crire les chargeurs de d\u00e9marrage courants, les \u00e9tapes n\u00e9cessaires pour flasher un chargeur de d\u00e9marrage et les \u00e9tapes n\u00e9cessaires pour flasher une application. Ce document n'est pas une r\u00e9f\u00e9rence faisant autorit\u00e9 ; il est con\u00e7u comme une collection d'informations utiles que les d\u00e9veloppeurs de Klipper ont accumul\u00e9es. Micro-contr\u00f4leurs AVR \u00b6 De mani\u00e8re g\u00e9n\u00e9rale, le projet Arduino est une bonne r\u00e9f\u00e9rence pour les chargeurs de d\u00e9marrage et les proc\u00e9dures de flashage sur les microcontr\u00f4leurs Atmel Atmega 8 bits. En particulier, le fichier \"boards.txt\" : https://github.com/arduino/Arduino/blob/1.8.5/hardware/arduino/avr/boards.txt est une r\u00e9f\u00e9rence utile. Pour flasher le chargeur de d\u00e9marrage, les puces AVR n\u00e9cessitent un outil de flashage mat\u00e9riel externe (qui communique avec la puce \u00e0 l'aide de SPI). Cet outil peut \u00eatre achet\u00e9 (par exemple, effectuez une recherche sur internet avec \"avr isp\", \"arduino isp\" ou \"usb tiny isp\"). Il est \u00e9galement possible d'utiliser un autre Arduino ou Raspberry Pi pour flasher un chargeur de d\u00e9marrage AVR (par exemple, faites une recherche sur le internet pour \"programmer un avr \u00e0 l'aide de raspberry pi\"). Les exemples ci-dessous sont \u00e9crits en supposant qu'un appareil de type \"AVR ISP Mk2\" est utilis\u00e9. Le logiciel \"avrdude\" est l'outil le plus utilis\u00e9 pour flasher les puces atmega (\u00e0 la fois pour flasher le chargeur de d\u00e9marrage et l'application). Atmega2560 \u00b6 Cette puce se trouve g\u00e9n\u00e9ralement dans les \"Arduino Mega\" qui sont tr\u00e8s courante parmi les cartes d'imprimante 3d. Pour flasher le chargeur de d\u00e9marrage lui-m\u00eame, utilisez quelque chose comme : wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/stk500v2/stk500boot_v2_mega2560.hex' avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xD8:m -U lfuse:w:0xFF:m avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U flash:w:stk500boot_v2_mega2560.hex avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m Pour flasher une application, utilisez quelque chose comme : avrdude -cwiring -patmega2560 -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/klipper.elf.hex:i Atmega1280 \u00b6 Cette puce se trouve g\u00e9n\u00e9ralement dans les anciennes versions de \"l'Arduino Mega\". Pour flasher le chargeur de d\u00e9marrage lui-m\u00eame, utilisez quelque chose comme : wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/atmega/ATmegaBOOT_168_atmega1280.hex' avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xF5:m -U hfuse:w:0xDA:m -U lfuse:w:0xFF:m avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U flash:w:ATmegaBOOT_168_atmega1280.hex avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m Pour flasher une application, utilisez quelque chose comme : avrdude -carduino -patmega1280 -P/dev/ttyACM0 -b57600 -D -Uflash:w:out/klipper.elf.hex:i Atmega1284p \u00b6 Cette puce se trouve couramment dans les cartes d'imprimante 3d de style \"Melzi\". Pour flasher le chargeur de d\u00e9marrage lui-m\u00eame, utilisez quelque chose comme : wget 'https://github.com/Lauszus/Sanguino/raw/1.0.2/bootloaders/optiboot/optiboot_atmega1284p.hex' avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xDE:m -U lfuse:w:0xFF:m avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega1284p.hex avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m Pour flasher une application, utilisez quelque chose comme : avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/klipper.elf.hex:i Notez qu'un certain nombre de cartes de style \"Melzi\" sont pr\u00e9install\u00e9es avec un chargeur de d\u00e9marrage qui utilise un d\u00e9bit de 57600 bauds. Dans ce cas, pour flasher une application, utilisez plut\u00f4t quelque chose comme ceci : avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b57600 -D -Uflash:w:out/klipper.elf.hex:i At90usb1286 \u00b6 Ce document ne couvre pas la m\u00e9thode pour flasher un chargeur de d\u00e9marrage sur l'At90usb1286 ni le flashage g\u00e9n\u00e9ral des applications sur cet appareil. L'appareil Teensy++ de pjrc.com est livr\u00e9 avec un chargeur de d\u00e9marrage propri\u00e9taire. Il n\u00e9cessite un outil de flash personnalis\u00e9 de https://github.com/PaulStoffregen/teensy_loader_cli . On peut flasher une application avec en utilisant quelque chose comme : teensy_loader_cli --mcu=at90usb1286 out/klipper.elf.hex -v Atmega168 \u00b6 L'atmega168 a un espace flash limit\u00e9. Si vous utilisez un chargeur de d\u00e9marrage, il est recommand\u00e9 d'utiliser le chargeur de d\u00e9marrage Optiboot. Pour flasher ce chargeur de d\u00e9marrage, utilisez quelque chose comme : wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/optiboot/optiboot_atmega168.hex' avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0x04:m -U hfuse:w:0xDD:m -U lfuse:w:0xFF:m avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega168.hex avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m Pour flasher une application via le chargeur de d\u00e9marrage Optiboot, utilisez quelque chose comme : avrdude -carduino -patmega168 -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/klipper.elf.hex:i Micro-contr\u00f4leurs SAM3 (Arduino Due) \u00b6 Il n'est pas courant d'utiliser un chargeur de d\u00e9marrage avec le mcu SAM3. La puce elle-m\u00eame poss\u00e8de une ROM qui permet de programmer le flash \u00e0 partir du port s\u00e9rie 3,3 V ou de l'USB. Pour activer la ROM, la broche \"effacement\" est maintenue haute pendant une r\u00e9initialisation, ce qui efface le contenu flash et provoque l'ex\u00e9cution de la ROM. Sur un Arduino Due, cette s\u00e9quence peut \u00eatre accomplie en d\u00e9finissant un d\u00e9bit en bauds de 1200 sur le \"port usb de programmation\" (le port USB le plus proche de l'alimentation). Le code sur https://github.com/shumatech/BOSSA peut \u00eatre utilis\u00e9 pour programmer le SAM3. Il est recommand\u00e9 d'utiliser la version 1.9 ou ult\u00e9rieure. Pour flasher une application, utilisez quelque chose comme : bossac -U -p /dev/ttyACM0 -a -e -w out/klipper.bin -v -b bossac -U -p /dev/ttyACM0 -R Micro-contr\u00f4leurs SAM4 (Duet Wifi) \u00b6 Il n'est pas courant d'utiliser un bootloader avec le mcu SAM4. La puce elle-m\u00eame poss\u00e8de une ROM qui permet de programmer le flash \u00e0 partir du port s\u00e9rie 3,3 V ou de l'USB. Pour activer la ROM, la broche \"effacement\" est maintenue haute pendant une r\u00e9initialisation, ce qui efface le contenu flash et provoque l'ex\u00e9cution de la ROM. Le code sur https://github.com/shumatech/BOSSA peut \u00eatre utilis\u00e9 pour programmer le SAM4. Il est n\u00e9cessaire d'utiliser la version 1.8.0 ou sup\u00e9rieure. Pour flasher une application, utilisez quelque chose comme : bossac --port=/dev/ttyACM0 -b -U -e -w -v -R out/klipper.bin SAMDC21 micro-controllers (Duet3D Toolboard 1LC) \u00b6 The SAMC21 is flashed via the ARM Serial Wire Debug (SWD) interface. This is commonly done with a dedicated SWD hardware dongle. Alternatively, one can use a Raspberry Pi with OpenOCD . When using OpenOCD with the SAMC21, extra steps must be taken to first put the chip into Cold Plugging mode if the board makes use of the SWD pins for other purposes. If using OpenOCD on a Rasberry Pi, this can be done by running the following commands before invoking OpenOCD. SWCLK=25 SWDIO=24 SRST=18 echo \"Exporting SWCLK and SRST pins.\" echo $SWCLK > /sys/class/gpio/export echo $SRST > /sys/class/gpio/export echo \"out\" > /sys/class/gpio/gpio$SWCLK/direction echo \"out\" > /sys/class/gpio/gpio$SRST/direction echo \"Setting SWCLK low and pulsing SRST.\" echo \"0\" > /sys/class/gpio/gpio$SWCLK/value echo \"0\" > /sys/class/gpio/gpio$SRST/value echo \"1\" > /sys/class/gpio/gpio$SRST/value echo \"Unexporting SWCLK and SRST pins.\" echo $SWCLK > /sys/class/gpio/unexport echo $SRST > /sys/class/gpio/unexport To flash a program with OpenOCD use the following chip config: source [find target/at91samdXX.cfg] Obtain a program; for instance, klipper can be built for this chip. Flash with OpenOCD commands similar to: at91samd chip-erase at91samd bootloader 0 program out/klipper.elf verify Micro-contr\u00f4leurs SAMD21 (Arduino Zero) \u00b6 Le chargeur de d\u00e9marrage SAMD21 est flash\u00e9 via l'interface ARM Serial Wire Debug (SWD). Cela se fait g\u00e9n\u00e9ralement avec un dongle mat\u00e9riel SWD d\u00e9di\u00e9. Alternativement, on peut utiliser un Raspberry Pi avec OpenOCD . Pour flasher un chargeur de d\u00e9marrage avec OpenOCD, utilisez la configuration de puce suivante : source [find target/at91samdXX.cfg] Procurez-vous un bootloader - par exemple : wget 'https://github.com/arduino/ArduinoCore-samd/raw/1.8.3/bootloaders/zero/samd21_sam_ba.bin' Flashez avec des commandes OpenOCD similaires \u00e0 : at91samd bootloader 0 program samd21_sam_ba.bin verify Le chargeur de d\u00e9marrage le plus courant sur le SAMD21 est celui que l'on trouve sur le \"Arduino Zero\". Il utilise un chargeur de d\u00e9marrage de 8 Ko (l'application doit \u00eatre compil\u00e9e avec une adresse de d\u00e9marrage de 8 Ko). On peut entrer dans ce chargeur de d\u00e9marrage en double-cliquant sur le bouton de r\u00e9initialisation. Pour flasher une application, utilisez quelque chose comme : bossac -U -p /dev/ttyACM0 --offset=0x2000 -w out/klipper.bin -v -b -R En revanche, \"l'Arduino M0\" utilise un bootloader de 16KiB (l'application doit \u00eatre compil\u00e9e avec une adresse de d\u00e9marrage de 16KiB). Pour flasher une application sur ce chargeur de d\u00e9marrage, r\u00e9initialisez le microcontr\u00f4leur et ex\u00e9cutez la commande flash dans les premi\u00e8res secondes du d\u00e9marrage - quelque chose comme : avrdude -c stk500v2 -p atmega2560 -P /dev/ttyACM0 -u -Uflash:w:out/klipper.elf.hex:i Micro-contr\u00f4leurs SAMD51 (Adafruit Metro-M4 et similaires) \u00b6 Comme le SAMD21, le chargeur de d\u00e9marrage SAMD51 est flash\u00e9 via l'interface ARM Serial Wire Debug (SWD). Pour flasher un chargeur de d\u00e9marrage avec OpenOCD sur un Raspberry Pi utilisez la configuration de puce suivante : source [find target/atsame5x.cfg] Obtenir un Chargeur de D\u00e9marrage - De nombreux Chargeurs de d\u00e9marrage sont disponibles sur https://github.com/adafruit/uf2-samdx1/releases/latest . Par exemple\u202f: wget 'https://github.com/adafruit/uf2-samdx1/releases/download/v3.7.0/bootloader-itsybitsy_m4-v3.7.0.bin' Flashez avec des commandes OpenOCD similaires \u00e0 : at91samd bootloader 0 program bootloader-itsybitsy_m4-v3.7.0.bin verify at91samd bootloader 16384 Le SAMD51 utilise un chargeur de d\u00e9marrage de 16 Ko (l'application doit \u00eatre compil\u00e9e avec une adresse de d\u00e9marrage de 16 Ko). Pour flasher une application, utilisez quelque chose comme : bossac -U -p /dev/ttyACM0 --offset=0x4000 -w out/klipper.bin -v -b -R Microcontr\u00f4leurs STM32F103 (dispositifs Blue Pill) \u00b6 Les appareils STM32F103 ont une ROM qui peut flasher un chargeur de d\u00e9marrage ou une application via un port s\u00e9rie 3,3 V. En r\u00e8gle g\u00e9n\u00e9rale, on c\u00e2blerait les broches PA10 (MCU Rx) et PA9 (MCU Tx) \u00e0 un adaptateur UART 3,3 V. Pour acc\u00e9der \u00e0 la ROM, il faut connecter la broche \"boot 0\" au niveau haut et la broche \"boot 1\" au niveau bas, puis r\u00e9initialiser l'appareil. Le package \"stm32flash\" peut ensuite \u00eatre utilis\u00e9 pour flasher l'appareil en utilisant quelque chose comme : stm32flash -w out/klipper.bin -v -g 0 /dev/ttyAMA0 Notez que si l'on utilise un Raspberry Pi pour le port s\u00e9rie 3.3V, le protocole stm32flash utilise un mode de parit\u00e9 s\u00e9rie que le \"mini UART\" du Raspberry Pi ne prend pas en charge. Voir https://www.raspberrypi.com/documentation/computers/configuration.html#configuring-uarts pour plus de d\u00e9tails sur l'activation de l'uart complet sur les broches GPIO du Raspberry Pi. Apr\u00e8s avoir flash\u00e9, r\u00e9glez \u00e0 la fois \"boot 0\" et \"boot 1\" sur bas afin que les futures r\u00e9initialisations d\u00e9marrent \u00e0 partir du flash. STM32F103 avec chargeur de d\u00e9marrage stm32duino \u00b6 Le projet \"stm32duino\" a un chargeur de d\u00e9marrage compatible USB - voir : https://github.com/rogerclarkmelbourne/STM32duino-bootloader Ce chargeur de d\u00e9marrage peut \u00eatre flash\u00e9 via un port s\u00e9rie 3,3 V avec quelque chose comme : wget 'https://github.com/rogerclarkmelbourne/STM32duino-bootloader/raw/master/binaries/generic_boot20_pc13.bin' stm32flash -w generic_boot20_pc13.bin -v -g 0 /dev/ttyAMA0 Ce chargeur de d\u00e9marrage utilise 8 Ko d'espace flash (l'application doit \u00eatre compil\u00e9e avec une adresse de d\u00e9marrage de 8 Ko). Flashez une application avec quelque chose comme : dfu-util -d 1eaf:0003 -a 2 -R -D out/klipper.bin Le chargeur de d\u00e9marrage ne s'ex\u00e9cute g\u00e9n\u00e9ralement que pendant une courte p\u00e9riode apr\u00e8s le d\u00e9marrage. Il peut \u00eatre n\u00e9cessaire de chronom\u00e9trer la commande ci-dessus pour qu'elle s'ex\u00e9cute pendant que le chargeur de d\u00e9marrage est toujours actif (le chargeur de d\u00e9marrage fait clignoter une LED de la carte pendant son ex\u00e9cution). Vous pouvez \u00e9galement d\u00e9finir la broche \"boot 0\" sur low et la broche \"boot 1\" sur high pour rester en mode chargeur de d\u00e9marrage apr\u00e8s une r\u00e9initialisation. STM32F103 avec chargeur de d\u00e9marrage HID \u00b6 Le chargeur de d\u00e9marrage HID est un chargeur de d\u00e9marrage compact et sans pilote capable de flasher via USB. Un fork avec des builds sp\u00e9cifiques au SKR Mini E3 1.2 est \u00e9galement disponible. Pour les cartes STM32F103 g\u00e9n\u00e9riques telles que la 'blue pill', il est possible de flasher le chargeur de d\u00e9marrage via une ligne s\u00e9rie 3,3 V en utilisant stm32flash comme indiqu\u00e9 dans la section stm32duino ci-dessus, en rempla\u00e7ant le nom de fichier par le binaire du chargeur de d\u00e9marrage hid souhait\u00e9 (c'est-\u00e0-dire : hid_generic_pc13.bin pour la 'blue pill'). Il n'est pas possible d'utiliser stm32flash pour le SKR Mini E3 car la broche boot0 est directement li\u00e9e \u00e0 la terre et non connect\u00e9e via des broches d'en-t\u00eate. Il est recommand\u00e9 d'utiliser un STLink V2 avec le programmeur STM32Cube pour flasher le bootloader. Si vous n'avez pas acc\u00e8s \u00e0 un STLink, il est \u00e9galement possible d'utiliser un Raspberry Pi et OpenOCD avec la configuration de puce suivante : source [find target/stm32f1x.cfg] Si vous le souhaitez, vous pouvez faire une sauvegarde du flash actuel avec la commande suivante. Notez que cela peut prendre un certain temps : flash read_bank 0 btt_skr_mini_e3_backup.bin vous pouvez flasher avec des commandes similaires \u00e0 : stm32f1x mass_erase 0 program hid_btt_skr_mini_e3.bin verify 0x08000000 NOTES\u202f: L'exemple ci-dessus efface la puce puis programme le bootloader. Quelle que soit la m\u00e9thode choisie pour flasher, il est recommand\u00e9 d'effacer la puce avant de flasher. Avant de flasher le SKR Mini E3 avec ce chargeur de d\u00e9marrage, vous devez savoir que vous ne pourrez plus mettre \u00e0 jour le firmware via la carte SD. You may need to hold down the reset button on the board while launching OpenOCD. It should display something like: Open On-Chip Debugger 0.10.0+dev-01204-gc60252ac-dirty (2020-04-27-16:00) Licensed under GNU GPL v2 For bug reports, read http://openocd.org/doc/doxygen/bugs.html DEPRECATED! use 'adapter speed' not 'adapter_khz' Info : BCM2835 GPIO JTAG/SWD bitbang driver Info : JTAG and SWD modes enabled Info : clock speed 40 kHz Info : SWD DPIDR 0x1ba01477 Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints Info : stm32f1x.cpu: external reset detected Info : starting gdb server for stm32f1x.cpu on 3333 Info : Listening on port 3333 for gdb connections Apr\u00e8s quoi, vous pouvez rel\u00e2cher le bouton de r\u00e9initialisation. Ce chargeur de d\u00e9marrage n\u00e9cessite 2 Ko d'espace flash (l'application doit \u00eatre compil\u00e9e avec une adresse de d\u00e9marrage de 2 Ko). Le programme hid-flash est utilis\u00e9 pour t\u00e9l\u00e9charger un binaire sur le bootloader. Vous pouvez installer ce logiciel avec les commandes suivantes : sudo apt install libusb-1.0 cd ~/klipper/lib/hidflash make Si le chargeur de d\u00e9marrage est en cours d'ex\u00e9cution, vous pouvez flasher avec quelque chose comme : ~/klipper/lib/hidflash/hid-flash ~/klipper/out/klipper.bin Vous pouvez aussi utiliser make flash pour flasher directement klipper : make flash FLASH_DEVICE=1209:BEBA OU si klipper a d\u00e9j\u00e0 \u00e9t\u00e9 flash\u00e9 : make flash FLASH_DEVICE=/dev/ttyACM0 Il peut \u00eatre n\u00e9cessaire d'entrer manuellement dans le chargeur de d\u00e9marrage, cela peut \u00eatre fait en d\u00e9finissant \"boot 0\" au niveau bas et \"boot 1\" au niveau haut. Sur la SKR Mini E3 \"Boot 1\" n'est pas disponible, vous pouvez donc le faire en mettant la broche PA2 au niveau bas si vous avez flash\u00e9 \"hid_btt_skr_mini_e3.bin\". Cette broche est \u00e9tiquet\u00e9e \"TX0\" sur le connecteur TFT dans le document \"PIN\" du SKR Mini E3. Il y a une broche de terre \u00e0 c\u00f4t\u00e9 de PA2 que vous pouvez utiliser pour mettre PA2 au niveau bas. STM32F103/STM32F072 avec chargeur de d\u00e9marrage MSC \u00b6 Le chargeur de d\u00e9marrage MSC est un chargeur de d\u00e9marrage sans pilote capable de flasher via USB. Il est possible de flasher le chargeur de d\u00e9marrage via une ligne s\u00e9rie 3,3 V en utilisant stm32flash comme indiqu\u00e9 dans la section stm32duino ci-dessus, en rempla\u00e7ant le nom de fichier par le binaire du chargeur de d\u00e9marrage MSC souhait\u00e9 (c'est-\u00e0-dire : MSCboot-Bluepill.bin pour la 'blue pill). Pour les cartes STM32F072, il est \u00e9galement possible de flasher le bootloader via USB (via DFU) avec quelque chose comme : dfu-util -d 0483:df11 -a 0 -R -D MSCboot-STM32F072.bin -s0x08000000:leave Ce chargeur de d\u00e9marrage utilise 8 Ko ou 16 Ko d'espace flash, voir la description du chargeur de d\u00e9marrage (l'application doit \u00eatre compil\u00e9e avec l'adresse de d\u00e9marrage correspondante). Le chargeur de d\u00e9marrage peut \u00eatre activ\u00e9 en appuyant deux fois sur le bouton de r\u00e9initialisation de la carte. D\u00e8s que le chargeur de d\u00e9marrage est activ\u00e9, la carte appara\u00eet comme une cl\u00e9 USB sur laquelle le fichier klipper.bin peut \u00eatre copi\u00e9. STM32F103/STM32F0x2 avec chargeur de d\u00e9marrage CanBoot \u00b6 Le chargeur de d\u00e9marrage CanBoot offre une option pour t\u00e9l\u00e9charger le micrologiciel Klipper via le CANBUS. Le chargeur de d\u00e9marrage lui-m\u00eame est d\u00e9riv\u00e9 du code source de Klipper. Actuellement, CanBoot prend en charge les mod\u00e8les STM32F103, STM32F042 et STM32F072. Il est pr\u00e9f\u00e9rable d'utiliser un programmeur ST-Link pour flasher CanBoot, mais il est possible de le flasher en utilisant stm32flash sur les appareils STM32F103 et dfu-util sur les appareils STM32F042/STM32F072. Consultez les sections pr\u00e9c\u00e9dentes de ce document pour obtenir des instructions sur ces m\u00e9thodes de flash, en rempla\u00e7ant canboot.bin par le nom de fichier, le cas \u00e9ch\u00e9ant. Le r\u00e9f\u00e9rentiel CanBoot li\u00e9 ci-dessus fournit des instructions pour cr\u00e9er le chargeur de d\u00e9marrage. La premi\u00e8re fois que CanBoot a \u00e9t\u00e9 flash\u00e9, il devrait d\u00e9tecter qu'aucune application n'est pr\u00e9sente et entrer dans le chargeur de d\u00e9marrage. Si cela ne se produit pas, il est possible d'entrer dans le chargeur de d\u00e9marrage en appuyant deux fois de suite sur le bouton de r\u00e9initialisation. L'utilitaire flash_can.py fourni dans le dossier lib/canboot peut \u00eatre utilis\u00e9 pour t\u00e9l\u00e9charger le firmware Klipper. L'UUID de l'appareil doit clignoter. Si vous n'avez pas d'UUID, il est possible d'interroger les n\u0153uds ex\u00e9cutant actuellement le chargeur de d\u00e9marrage : python3 flash_can.py -q Cela renverra les UUID pour tous les n\u0153uds connect\u00e9s et qui n'avaient pas d'UUID attribu\u00e9. Cela devrait inclure tous les n\u0153uds actuellement dans le chargeur de d\u00e9marrage. Une fois que vous avez un UUID, vous pouvez t\u00e9l\u00e9charger le firmware avec la commande suivante : python3 flash_can.py -i can0 -f ~/klipper/out/klipper.bin -u aabbccddeeff O\u00f9 aabbccddeeff est remplac\u00e9 par votre UUID. Notez que les options -i et -f peuvent \u00eatre omises, elles sont par d\u00e9faut sur can0 et ~/klipper/out/klipper.bin . Lors de la cr\u00e9ation de Klipper pour une utilisation avec CanBoot, s\u00e9lectionnez l'option 8 KiB Bootloader. Micro-contr\u00f4leurs STM32F4 (SKR Pro 1.1) \u00b6 Les microcontr\u00f4leurs STM32F4 sont \u00e9quip\u00e9s d'un chargeur de d\u00e9marrage syst\u00e8me int\u00e9gr\u00e9 capable de flasher via USB (via DFU), s\u00e9rie 3,3 V et diverses autres m\u00e9thodes (voir le document STM AN2606 pour plus d'informations). Certaines cartes STM32F4, telles que le SKR Pro 1.1, ne peuvent pas passer en mode DFU. Le chargeur de d\u00e9marrage HID est disponible pour les cartes bas\u00e9es sur STM32F405/407 si l'utilisateur pr\u00e9f\u00e8re flasher sur USB plut\u00f4t que d'utiliser la carte SD. Notez que vous devrez peut-\u00eatre configurer et construire une version sp\u00e9cifique \u00e0 votre carte, une version pour le SKR Pro 1.1 est disponible ici . \u00c0 moins que votre carte ne soit compatible DFU, la m\u00e9thode de flashla plus accessible est probablement via une ligne s\u00e9rie 3,3 V, qui suit la m\u00eame proc\u00e9dure que flasher le STM32F103 avec stm32flash . Par exemple\u202f: wget https://github.com/Arksine/STM32_HID_Bootloader/releases/download/v0.5-beta/hid_bootloader_SKR_PRO.bin stm32flash -w hid_bootloader_SKR_PRO.bin -v -g 0 /dev/ttyAMA0 Ce chargeur de d\u00e9marrage n\u00e9cessite 16 Ko d'espace flash sur le STM32F4 (l'application doit \u00eatre compil\u00e9e avec une adresse de d\u00e9marrage de 16 Ko). Comme avec le STM32F1, le STM32F4 utilise l'outil hid-flash pour t\u00e9l\u00e9charger des fichiers binaires sur le MCU. Voir les instructions ci-dessus pour plus de d\u00e9tails sur la fa\u00e7on de construire et d'utiliser hid-flash. Il peut \u00eatre n\u00e9cessaire d'entrer manuellement dans le chargeur de d\u00e9marrage, cela peut \u00eatre fait en d\u00e9finissant \"boot 0\" au niveau bas, \"boot 1\" au niveau haut et en branchant l'appareil. Une fois la programmation termin\u00e9e, d\u00e9branchez l'appareil et re-r\u00e9glez \"boot 1\" au niveau bas pour que l'application soit charg\u00e9e. Micro-contr\u00f4leurs LPC176x (Smoothieboards) \u00b6 Ce document ne d\u00e9crit pas la m\u00e9thode pour flasher le Chargeur de d\u00e9marrage lui-m\u00eame - voir : http://smoothieware.org/flashing-the-bootloader pour plus d'informations sur ce sujet. Il est courant que les Smoothieboards soient livr\u00e9s avec un chargeur de d\u00e9marrage de : https://github.com/triffid/LPC17xx-DFU-Bootloader . Lors de l'utilisation de ce chargeur de d\u00e9marrage, l'application doit \u00eatre compil\u00e9e avec une adresse de d\u00e9marrage de 16 Ko. Le moyen le plus simple de flasher une application avec ce chargeur de d\u00e9marrage est de copier le fichier d'application (par exemple, out/klipper.bin ) dans un fichier nomm\u00e9 firmware.bin sur une carte SD, et puis de red\u00e9marrer le microcontr\u00f4leur avec cette carte SD. Ex\u00e9cuter OpenOCD sur le Raspberry PI \u00b6 OpenOCD est un logiciel qui peut effectuer un flashage et un d\u00e9bogage de puce de bas niveau. Il peut utiliser les broches GPIO d'un Raspberry Pi pour communiquer avec une vari\u00e9t\u00e9 de puces ARM. Cette section d\u00e9crit comment installer et lancer OpenOCD. Elle d\u00e9rive des instructions disponibles sur : https://learn.adafruit.com/programming-microcontrollers-using-openocd-on-raspberry-pi Commencez par t\u00e9l\u00e9charger et compiler le logiciel (chaque \u00e9tape peut prendre plusieurs minutes et l'\u00e9tape \"make\" peut prendre plus de 30 minutes) : sudo apt-get update sudo apt-get install autoconf libtool telnet mkdir ~/openocd cd ~/openocd/ git clone http://openocd.zylin.com/openocd cd openocd ./bootstrap ./configure --enable-sysfsgpio --enable-bcm2835gpio --prefix=/home/pi/openocd/install make make install Configurer OpenOCD \u00b6 Cr\u00e9ez un fichier de configuration OpenOCD : nano ~/openocd/openocd.cfg Utilisez une configuration similaire \u00e0 la suivante : # Utilise les pins du RPI: GPIO25 pour SWDCLK, GPIO24 pour SWDIO, GPIO18 pour nRST source [find interface/raspberrypi2-native.cfg] bcm2835gpio_swd_nums 25 24 bcm2835gpio_srst_num 18 transport select swd # Utilise le reset c\u00e2bl\u00e9 pour la raz de la puce reset_config srst_only adapter_nsrst_delay 100 adapter_nsrst_assert_width 100 # Specification du type de puce source [find target/atsame5x.cfg] # D\u00e9finir la vitesse de l'adaptateur adapter_khz 40 # Connexion \u00e0 la puce init targets reset halt C\u00e2blez le Raspberry Pi sur la puce cible \u00b6 \u00c9teignez \u00e0 la fois le Raspberry Pi et la puce cible avant le c\u00e2blage ! V\u00e9rifiez que la puce cible utilise bien du 3,3 V avant de la connecter au Raspberry Pi ! Connectez GND, SWDCLK, SWDIO et RST sur la puce cible \u00e0 GND, GPIO25, GPIO24 et GPIO18 sur le Raspberry Pi. Mettez ensuite le Raspberry Pi sous tension et alimentez la puce cible. Ex\u00e9cutez OpenOCD \u00b6 Ex\u00e9cutez OpenOCD : cd ~/openocd/ sudo ~/openocd/install/bin/openocd -f ~/openocd/openocd.cfg Ce qui pr\u00e9c\u00e8de devrait amener OpenOCD \u00e0 \u00e9mettre des messages texte, puis \u00e0 attendre (il ne doit pas imm\u00e9diatement revenir \u00e0 l'invite du shell). Si OpenOCD se ferme tout seul ou s'il continue \u00e0 \u00e9mettre des messages texte, v\u00e9rifiez \u00e0 nouveau le c\u00e2blage. Une fois OpenOCD en cours d'ex\u00e9cution et stable, on peut lui envoyer des commandes via telnet. Ouvrez une autre session SSH et ex\u00e9cutez ce qui suit : telnet 127.0.0.1 4444 (Vous pouvez quitter telnet en appuyant sur ctrl+] puis en ex\u00e9cutant la commande \"quit\".) OpenOCD et gdb \u00b6 Il est possible d'utiliser OpenOCD avec gdb pour d\u00e9boguer Klipper. Les commandes suivantes supposent que l'on ex\u00e9cute gdb sur une machine de bureau. Ajoutez ce qui suit au fichier de configuration OpenOCD : bindto 0.0.0.0 gdb_port 44444 Red\u00e9marrez OpenOCD sur le Raspberry Pi, puis ex\u00e9cutez la commande Unix suivante sur la machine de bureau : cd /path/to/klipper/ gdb out/klipper.elf Dans gdb, ex\u00e9cutez : target remote octopi:44444 (Remplacez \"octopi\" par le nom d'h\u00f4te du Raspberry Pi.) Une fois que gdb est en cours d'ex\u00e9cution, il est possible de d\u00e9finir des points d'arr\u00eat et d'inspecter les registres.","title":"Chargeurs de d\u00e9marrage"},{"location":"Bootloaders.html#chargeurs-de-demarrage","text":"Ce document fournit des informations sur les \"chargeurs de d\u00e9marrage\" ou \"Bootloaders\" courants trouv\u00e9s sur les microcontr\u00f4leurs pris en charge par Klipper. Le chargeur de d\u00e9marrage est un logiciel tiers qui s'ex\u00e9cute sur le microcontr\u00f4leur lors de sa premi\u00e8re mise sous tension. Il est g\u00e9n\u00e9ralement utilis\u00e9 pour flasher une nouvelle application (par exemple, Klipper) sur le microcontr\u00f4leur sans n\u00e9cessiter de mat\u00e9riel sp\u00e9cialis\u00e9. Malheureusement, il n'existe pas de norme \u00e0 l'\u00e9chelle de l'industrie pour flasher un microcontr\u00f4leur, ni de chargeur de d\u00e9marrage standard qui fonctionne sur tous les microcontr\u00f4leurs. Pire encore, il est courant que chaque chargeur de d\u00e9marrage n\u00e9cessite un ensemble d'\u00e9tapes diff\u00e9rent pour flasher une application. Si l'on peut flasher un chargeur de d\u00e9marrage sur un microcontr\u00f4leur, on peut g\u00e9n\u00e9ralement \u00e9galement utiliser ce m\u00e9canisme pour flasher une application, mais il faut faire attention en faisant cela car on peut supprimer le chargeur de d\u00e9marrage par inadvertance. En revanche, un chargeur de d\u00e9marrage permettra g\u00e9n\u00e9ralement \u00e0 un utilisateur de flasher une application. Il est donc recommand\u00e9 d'utiliser le chargeur de d\u00e9marrage pour flasher une application lorsque cela est possible. Ce document tente de d\u00e9crire les chargeurs de d\u00e9marrage courants, les \u00e9tapes n\u00e9cessaires pour flasher un chargeur de d\u00e9marrage et les \u00e9tapes n\u00e9cessaires pour flasher une application. Ce document n'est pas une r\u00e9f\u00e9rence faisant autorit\u00e9 ; il est con\u00e7u comme une collection d'informations utiles que les d\u00e9veloppeurs de Klipper ont accumul\u00e9es.","title":"Chargeurs de d\u00e9marrage"},{"location":"Bootloaders.html#micro-controleurs-avr","text":"De mani\u00e8re g\u00e9n\u00e9rale, le projet Arduino est une bonne r\u00e9f\u00e9rence pour les chargeurs de d\u00e9marrage et les proc\u00e9dures de flashage sur les microcontr\u00f4leurs Atmel Atmega 8 bits. En particulier, le fichier \"boards.txt\" : https://github.com/arduino/Arduino/blob/1.8.5/hardware/arduino/avr/boards.txt est une r\u00e9f\u00e9rence utile. Pour flasher le chargeur de d\u00e9marrage, les puces AVR n\u00e9cessitent un outil de flashage mat\u00e9riel externe (qui communique avec la puce \u00e0 l'aide de SPI). Cet outil peut \u00eatre achet\u00e9 (par exemple, effectuez une recherche sur internet avec \"avr isp\", \"arduino isp\" ou \"usb tiny isp\"). Il est \u00e9galement possible d'utiliser un autre Arduino ou Raspberry Pi pour flasher un chargeur de d\u00e9marrage AVR (par exemple, faites une recherche sur le internet pour \"programmer un avr \u00e0 l'aide de raspberry pi\"). Les exemples ci-dessous sont \u00e9crits en supposant qu'un appareil de type \"AVR ISP Mk2\" est utilis\u00e9. Le logiciel \"avrdude\" est l'outil le plus utilis\u00e9 pour flasher les puces atmega (\u00e0 la fois pour flasher le chargeur de d\u00e9marrage et l'application).","title":"Micro-contr\u00f4leurs AVR"},{"location":"Bootloaders.html#atmega2560","text":"Cette puce se trouve g\u00e9n\u00e9ralement dans les \"Arduino Mega\" qui sont tr\u00e8s courante parmi les cartes d'imprimante 3d. Pour flasher le chargeur de d\u00e9marrage lui-m\u00eame, utilisez quelque chose comme : wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/stk500v2/stk500boot_v2_mega2560.hex' avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xD8:m -U lfuse:w:0xFF:m avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U flash:w:stk500boot_v2_mega2560.hex avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m Pour flasher une application, utilisez quelque chose comme : avrdude -cwiring -patmega2560 -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/klipper.elf.hex:i","title":"Atmega2560"},{"location":"Bootloaders.html#atmega1280","text":"Cette puce se trouve g\u00e9n\u00e9ralement dans les anciennes versions de \"l'Arduino Mega\". Pour flasher le chargeur de d\u00e9marrage lui-m\u00eame, utilisez quelque chose comme : wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/atmega/ATmegaBOOT_168_atmega1280.hex' avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xF5:m -U hfuse:w:0xDA:m -U lfuse:w:0xFF:m avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U flash:w:ATmegaBOOT_168_atmega1280.hex avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m Pour flasher une application, utilisez quelque chose comme : avrdude -carduino -patmega1280 -P/dev/ttyACM0 -b57600 -D -Uflash:w:out/klipper.elf.hex:i","title":"Atmega1280"},{"location":"Bootloaders.html#atmega1284p","text":"Cette puce se trouve couramment dans les cartes d'imprimante 3d de style \"Melzi\". Pour flasher le chargeur de d\u00e9marrage lui-m\u00eame, utilisez quelque chose comme : wget 'https://github.com/Lauszus/Sanguino/raw/1.0.2/bootloaders/optiboot/optiboot_atmega1284p.hex' avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xDE:m -U lfuse:w:0xFF:m avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega1284p.hex avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m Pour flasher une application, utilisez quelque chose comme : avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/klipper.elf.hex:i Notez qu'un certain nombre de cartes de style \"Melzi\" sont pr\u00e9install\u00e9es avec un chargeur de d\u00e9marrage qui utilise un d\u00e9bit de 57600 bauds. Dans ce cas, pour flasher une application, utilisez plut\u00f4t quelque chose comme ceci : avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b57600 -D -Uflash:w:out/klipper.elf.hex:i","title":"Atmega1284p"},{"location":"Bootloaders.html#at90usb1286","text":"Ce document ne couvre pas la m\u00e9thode pour flasher un chargeur de d\u00e9marrage sur l'At90usb1286 ni le flashage g\u00e9n\u00e9ral des applications sur cet appareil. L'appareil Teensy++ de pjrc.com est livr\u00e9 avec un chargeur de d\u00e9marrage propri\u00e9taire. Il n\u00e9cessite un outil de flash personnalis\u00e9 de https://github.com/PaulStoffregen/teensy_loader_cli . On peut flasher une application avec en utilisant quelque chose comme : teensy_loader_cli --mcu=at90usb1286 out/klipper.elf.hex -v","title":"At90usb1286"},{"location":"Bootloaders.html#atmega168","text":"L'atmega168 a un espace flash limit\u00e9. Si vous utilisez un chargeur de d\u00e9marrage, il est recommand\u00e9 d'utiliser le chargeur de d\u00e9marrage Optiboot. Pour flasher ce chargeur de d\u00e9marrage, utilisez quelque chose comme : wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/optiboot/optiboot_atmega168.hex' avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0x04:m -U hfuse:w:0xDD:m -U lfuse:w:0xFF:m avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega168.hex avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m Pour flasher une application via le chargeur de d\u00e9marrage Optiboot, utilisez quelque chose comme : avrdude -carduino -patmega168 -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/klipper.elf.hex:i","title":"Atmega168"},{"location":"Bootloaders.html#micro-controleurs-sam3-arduino-due","text":"Il n'est pas courant d'utiliser un chargeur de d\u00e9marrage avec le mcu SAM3. La puce elle-m\u00eame poss\u00e8de une ROM qui permet de programmer le flash \u00e0 partir du port s\u00e9rie 3,3 V ou de l'USB. Pour activer la ROM, la broche \"effacement\" est maintenue haute pendant une r\u00e9initialisation, ce qui efface le contenu flash et provoque l'ex\u00e9cution de la ROM. Sur un Arduino Due, cette s\u00e9quence peut \u00eatre accomplie en d\u00e9finissant un d\u00e9bit en bauds de 1200 sur le \"port usb de programmation\" (le port USB le plus proche de l'alimentation). Le code sur https://github.com/shumatech/BOSSA peut \u00eatre utilis\u00e9 pour programmer le SAM3. Il est recommand\u00e9 d'utiliser la version 1.9 ou ult\u00e9rieure. Pour flasher une application, utilisez quelque chose comme : bossac -U -p /dev/ttyACM0 -a -e -w out/klipper.bin -v -b bossac -U -p /dev/ttyACM0 -R","title":"Micro-contr\u00f4leurs SAM3 (Arduino Due)"},{"location":"Bootloaders.html#micro-controleurs-sam4-duet-wifi","text":"Il n'est pas courant d'utiliser un bootloader avec le mcu SAM4. La puce elle-m\u00eame poss\u00e8de une ROM qui permet de programmer le flash \u00e0 partir du port s\u00e9rie 3,3 V ou de l'USB. Pour activer la ROM, la broche \"effacement\" est maintenue haute pendant une r\u00e9initialisation, ce qui efface le contenu flash et provoque l'ex\u00e9cution de la ROM. Le code sur https://github.com/shumatech/BOSSA peut \u00eatre utilis\u00e9 pour programmer le SAM4. Il est n\u00e9cessaire d'utiliser la version 1.8.0 ou sup\u00e9rieure. Pour flasher une application, utilisez quelque chose comme : bossac --port=/dev/ttyACM0 -b -U -e -w -v -R out/klipper.bin","title":"Micro-contr\u00f4leurs SAM4 (Duet Wifi)"},{"location":"Bootloaders.html#samdc21-micro-controllers-duet3d-toolboard-1lc","text":"The SAMC21 is flashed via the ARM Serial Wire Debug (SWD) interface. This is commonly done with a dedicated SWD hardware dongle. Alternatively, one can use a Raspberry Pi with OpenOCD . When using OpenOCD with the SAMC21, extra steps must be taken to first put the chip into Cold Plugging mode if the board makes use of the SWD pins for other purposes. If using OpenOCD on a Rasberry Pi, this can be done by running the following commands before invoking OpenOCD. SWCLK=25 SWDIO=24 SRST=18 echo \"Exporting SWCLK and SRST pins.\" echo $SWCLK > /sys/class/gpio/export echo $SRST > /sys/class/gpio/export echo \"out\" > /sys/class/gpio/gpio$SWCLK/direction echo \"out\" > /sys/class/gpio/gpio$SRST/direction echo \"Setting SWCLK low and pulsing SRST.\" echo \"0\" > /sys/class/gpio/gpio$SWCLK/value echo \"0\" > /sys/class/gpio/gpio$SRST/value echo \"1\" > /sys/class/gpio/gpio$SRST/value echo \"Unexporting SWCLK and SRST pins.\" echo $SWCLK > /sys/class/gpio/unexport echo $SRST > /sys/class/gpio/unexport To flash a program with OpenOCD use the following chip config: source [find target/at91samdXX.cfg] Obtain a program; for instance, klipper can be built for this chip. Flash with OpenOCD commands similar to: at91samd chip-erase at91samd bootloader 0 program out/klipper.elf verify","title":"SAMDC21 micro-controllers (Duet3D Toolboard 1LC)"},{"location":"Bootloaders.html#micro-controleurs-samd21-arduino-zero","text":"Le chargeur de d\u00e9marrage SAMD21 est flash\u00e9 via l'interface ARM Serial Wire Debug (SWD). Cela se fait g\u00e9n\u00e9ralement avec un dongle mat\u00e9riel SWD d\u00e9di\u00e9. Alternativement, on peut utiliser un Raspberry Pi avec OpenOCD . Pour flasher un chargeur de d\u00e9marrage avec OpenOCD, utilisez la configuration de puce suivante : source [find target/at91samdXX.cfg] Procurez-vous un bootloader - par exemple : wget 'https://github.com/arduino/ArduinoCore-samd/raw/1.8.3/bootloaders/zero/samd21_sam_ba.bin' Flashez avec des commandes OpenOCD similaires \u00e0 : at91samd bootloader 0 program samd21_sam_ba.bin verify Le chargeur de d\u00e9marrage le plus courant sur le SAMD21 est celui que l'on trouve sur le \"Arduino Zero\". Il utilise un chargeur de d\u00e9marrage de 8 Ko (l'application doit \u00eatre compil\u00e9e avec une adresse de d\u00e9marrage de 8 Ko). On peut entrer dans ce chargeur de d\u00e9marrage en double-cliquant sur le bouton de r\u00e9initialisation. Pour flasher une application, utilisez quelque chose comme : bossac -U -p /dev/ttyACM0 --offset=0x2000 -w out/klipper.bin -v -b -R En revanche, \"l'Arduino M0\" utilise un bootloader de 16KiB (l'application doit \u00eatre compil\u00e9e avec une adresse de d\u00e9marrage de 16KiB). Pour flasher une application sur ce chargeur de d\u00e9marrage, r\u00e9initialisez le microcontr\u00f4leur et ex\u00e9cutez la commande flash dans les premi\u00e8res secondes du d\u00e9marrage - quelque chose comme : avrdude -c stk500v2 -p atmega2560 -P /dev/ttyACM0 -u -Uflash:w:out/klipper.elf.hex:i","title":"Micro-contr\u00f4leurs SAMD21 (Arduino Zero)"},{"location":"Bootloaders.html#micro-controleurs-samd51-adafruit-metro-m4-et-similaires","text":"Comme le SAMD21, le chargeur de d\u00e9marrage SAMD51 est flash\u00e9 via l'interface ARM Serial Wire Debug (SWD). Pour flasher un chargeur de d\u00e9marrage avec OpenOCD sur un Raspberry Pi utilisez la configuration de puce suivante : source [find target/atsame5x.cfg] Obtenir un Chargeur de D\u00e9marrage - De nombreux Chargeurs de d\u00e9marrage sont disponibles sur https://github.com/adafruit/uf2-samdx1/releases/latest . Par exemple\u202f: wget 'https://github.com/adafruit/uf2-samdx1/releases/download/v3.7.0/bootloader-itsybitsy_m4-v3.7.0.bin' Flashez avec des commandes OpenOCD similaires \u00e0 : at91samd bootloader 0 program bootloader-itsybitsy_m4-v3.7.0.bin verify at91samd bootloader 16384 Le SAMD51 utilise un chargeur de d\u00e9marrage de 16 Ko (l'application doit \u00eatre compil\u00e9e avec une adresse de d\u00e9marrage de 16 Ko). Pour flasher une application, utilisez quelque chose comme : bossac -U -p /dev/ttyACM0 --offset=0x4000 -w out/klipper.bin -v -b -R","title":"Micro-contr\u00f4leurs SAMD51 (Adafruit Metro-M4 et similaires)"},{"location":"Bootloaders.html#microcontroleurs-stm32f103-dispositifs-blue-pill","text":"Les appareils STM32F103 ont une ROM qui peut flasher un chargeur de d\u00e9marrage ou une application via un port s\u00e9rie 3,3 V. En r\u00e8gle g\u00e9n\u00e9rale, on c\u00e2blerait les broches PA10 (MCU Rx) et PA9 (MCU Tx) \u00e0 un adaptateur UART 3,3 V. Pour acc\u00e9der \u00e0 la ROM, il faut connecter la broche \"boot 0\" au niveau haut et la broche \"boot 1\" au niveau bas, puis r\u00e9initialiser l'appareil. Le package \"stm32flash\" peut ensuite \u00eatre utilis\u00e9 pour flasher l'appareil en utilisant quelque chose comme : stm32flash -w out/klipper.bin -v -g 0 /dev/ttyAMA0 Notez que si l'on utilise un Raspberry Pi pour le port s\u00e9rie 3.3V, le protocole stm32flash utilise un mode de parit\u00e9 s\u00e9rie que le \"mini UART\" du Raspberry Pi ne prend pas en charge. Voir https://www.raspberrypi.com/documentation/computers/configuration.html#configuring-uarts pour plus de d\u00e9tails sur l'activation de l'uart complet sur les broches GPIO du Raspberry Pi. Apr\u00e8s avoir flash\u00e9, r\u00e9glez \u00e0 la fois \"boot 0\" et \"boot 1\" sur bas afin que les futures r\u00e9initialisations d\u00e9marrent \u00e0 partir du flash.","title":"Microcontr\u00f4leurs STM32F103 (dispositifs Blue Pill)"},{"location":"Bootloaders.html#stm32f103-avec-chargeur-de-demarrage-stm32duino","text":"Le projet \"stm32duino\" a un chargeur de d\u00e9marrage compatible USB - voir : https://github.com/rogerclarkmelbourne/STM32duino-bootloader Ce chargeur de d\u00e9marrage peut \u00eatre flash\u00e9 via un port s\u00e9rie 3,3 V avec quelque chose comme : wget 'https://github.com/rogerclarkmelbourne/STM32duino-bootloader/raw/master/binaries/generic_boot20_pc13.bin' stm32flash -w generic_boot20_pc13.bin -v -g 0 /dev/ttyAMA0 Ce chargeur de d\u00e9marrage utilise 8 Ko d'espace flash (l'application doit \u00eatre compil\u00e9e avec une adresse de d\u00e9marrage de 8 Ko). Flashez une application avec quelque chose comme : dfu-util -d 1eaf:0003 -a 2 -R -D out/klipper.bin Le chargeur de d\u00e9marrage ne s'ex\u00e9cute g\u00e9n\u00e9ralement que pendant une courte p\u00e9riode apr\u00e8s le d\u00e9marrage. Il peut \u00eatre n\u00e9cessaire de chronom\u00e9trer la commande ci-dessus pour qu'elle s'ex\u00e9cute pendant que le chargeur de d\u00e9marrage est toujours actif (le chargeur de d\u00e9marrage fait clignoter une LED de la carte pendant son ex\u00e9cution). Vous pouvez \u00e9galement d\u00e9finir la broche \"boot 0\" sur low et la broche \"boot 1\" sur high pour rester en mode chargeur de d\u00e9marrage apr\u00e8s une r\u00e9initialisation.","title":"STM32F103 avec chargeur de d\u00e9marrage stm32duino"},{"location":"Bootloaders.html#stm32f103-avec-chargeur-de-demarrage-hid","text":"Le chargeur de d\u00e9marrage HID est un chargeur de d\u00e9marrage compact et sans pilote capable de flasher via USB. Un fork avec des builds sp\u00e9cifiques au SKR Mini E3 1.2 est \u00e9galement disponible. Pour les cartes STM32F103 g\u00e9n\u00e9riques telles que la 'blue pill', il est possible de flasher le chargeur de d\u00e9marrage via une ligne s\u00e9rie 3,3 V en utilisant stm32flash comme indiqu\u00e9 dans la section stm32duino ci-dessus, en rempla\u00e7ant le nom de fichier par le binaire du chargeur de d\u00e9marrage hid souhait\u00e9 (c'est-\u00e0-dire : hid_generic_pc13.bin pour la 'blue pill'). Il n'est pas possible d'utiliser stm32flash pour le SKR Mini E3 car la broche boot0 est directement li\u00e9e \u00e0 la terre et non connect\u00e9e via des broches d'en-t\u00eate. Il est recommand\u00e9 d'utiliser un STLink V2 avec le programmeur STM32Cube pour flasher le bootloader. Si vous n'avez pas acc\u00e8s \u00e0 un STLink, il est \u00e9galement possible d'utiliser un Raspberry Pi et OpenOCD avec la configuration de puce suivante : source [find target/stm32f1x.cfg] Si vous le souhaitez, vous pouvez faire une sauvegarde du flash actuel avec la commande suivante. Notez que cela peut prendre un certain temps : flash read_bank 0 btt_skr_mini_e3_backup.bin vous pouvez flasher avec des commandes similaires \u00e0 : stm32f1x mass_erase 0 program hid_btt_skr_mini_e3.bin verify 0x08000000 NOTES\u202f: L'exemple ci-dessus efface la puce puis programme le bootloader. Quelle que soit la m\u00e9thode choisie pour flasher, il est recommand\u00e9 d'effacer la puce avant de flasher. Avant de flasher le SKR Mini E3 avec ce chargeur de d\u00e9marrage, vous devez savoir que vous ne pourrez plus mettre \u00e0 jour le firmware via la carte SD. You may need to hold down the reset button on the board while launching OpenOCD. It should display something like: Open On-Chip Debugger 0.10.0+dev-01204-gc60252ac-dirty (2020-04-27-16:00) Licensed under GNU GPL v2 For bug reports, read http://openocd.org/doc/doxygen/bugs.html DEPRECATED! use 'adapter speed' not 'adapter_khz' Info : BCM2835 GPIO JTAG/SWD bitbang driver Info : JTAG and SWD modes enabled Info : clock speed 40 kHz Info : SWD DPIDR 0x1ba01477 Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints Info : stm32f1x.cpu: external reset detected Info : starting gdb server for stm32f1x.cpu on 3333 Info : Listening on port 3333 for gdb connections Apr\u00e8s quoi, vous pouvez rel\u00e2cher le bouton de r\u00e9initialisation. Ce chargeur de d\u00e9marrage n\u00e9cessite 2 Ko d'espace flash (l'application doit \u00eatre compil\u00e9e avec une adresse de d\u00e9marrage de 2 Ko). Le programme hid-flash est utilis\u00e9 pour t\u00e9l\u00e9charger un binaire sur le bootloader. Vous pouvez installer ce logiciel avec les commandes suivantes : sudo apt install libusb-1.0 cd ~/klipper/lib/hidflash make Si le chargeur de d\u00e9marrage est en cours d'ex\u00e9cution, vous pouvez flasher avec quelque chose comme : ~/klipper/lib/hidflash/hid-flash ~/klipper/out/klipper.bin Vous pouvez aussi utiliser make flash pour flasher directement klipper : make flash FLASH_DEVICE=1209:BEBA OU si klipper a d\u00e9j\u00e0 \u00e9t\u00e9 flash\u00e9 : make flash FLASH_DEVICE=/dev/ttyACM0 Il peut \u00eatre n\u00e9cessaire d'entrer manuellement dans le chargeur de d\u00e9marrage, cela peut \u00eatre fait en d\u00e9finissant \"boot 0\" au niveau bas et \"boot 1\" au niveau haut. Sur la SKR Mini E3 \"Boot 1\" n'est pas disponible, vous pouvez donc le faire en mettant la broche PA2 au niveau bas si vous avez flash\u00e9 \"hid_btt_skr_mini_e3.bin\". Cette broche est \u00e9tiquet\u00e9e \"TX0\" sur le connecteur TFT dans le document \"PIN\" du SKR Mini E3. Il y a une broche de terre \u00e0 c\u00f4t\u00e9 de PA2 que vous pouvez utiliser pour mettre PA2 au niveau bas.","title":"STM32F103 avec chargeur de d\u00e9marrage HID"},{"location":"Bootloaders.html#stm32f103stm32f072-avec-chargeur-de-demarrage-msc","text":"Le chargeur de d\u00e9marrage MSC est un chargeur de d\u00e9marrage sans pilote capable de flasher via USB. Il est possible de flasher le chargeur de d\u00e9marrage via une ligne s\u00e9rie 3,3 V en utilisant stm32flash comme indiqu\u00e9 dans la section stm32duino ci-dessus, en rempla\u00e7ant le nom de fichier par le binaire du chargeur de d\u00e9marrage MSC souhait\u00e9 (c'est-\u00e0-dire : MSCboot-Bluepill.bin pour la 'blue pill). Pour les cartes STM32F072, il est \u00e9galement possible de flasher le bootloader via USB (via DFU) avec quelque chose comme : dfu-util -d 0483:df11 -a 0 -R -D MSCboot-STM32F072.bin -s0x08000000:leave Ce chargeur de d\u00e9marrage utilise 8 Ko ou 16 Ko d'espace flash, voir la description du chargeur de d\u00e9marrage (l'application doit \u00eatre compil\u00e9e avec l'adresse de d\u00e9marrage correspondante). Le chargeur de d\u00e9marrage peut \u00eatre activ\u00e9 en appuyant deux fois sur le bouton de r\u00e9initialisation de la carte. D\u00e8s que le chargeur de d\u00e9marrage est activ\u00e9, la carte appara\u00eet comme une cl\u00e9 USB sur laquelle le fichier klipper.bin peut \u00eatre copi\u00e9.","title":"STM32F103/STM32F072 avec chargeur de d\u00e9marrage MSC"},{"location":"Bootloaders.html#stm32f103stm32f0x2-avec-chargeur-de-demarrage-canboot","text":"Le chargeur de d\u00e9marrage CanBoot offre une option pour t\u00e9l\u00e9charger le micrologiciel Klipper via le CANBUS. Le chargeur de d\u00e9marrage lui-m\u00eame est d\u00e9riv\u00e9 du code source de Klipper. Actuellement, CanBoot prend en charge les mod\u00e8les STM32F103, STM32F042 et STM32F072. Il est pr\u00e9f\u00e9rable d'utiliser un programmeur ST-Link pour flasher CanBoot, mais il est possible de le flasher en utilisant stm32flash sur les appareils STM32F103 et dfu-util sur les appareils STM32F042/STM32F072. Consultez les sections pr\u00e9c\u00e9dentes de ce document pour obtenir des instructions sur ces m\u00e9thodes de flash, en rempla\u00e7ant canboot.bin par le nom de fichier, le cas \u00e9ch\u00e9ant. Le r\u00e9f\u00e9rentiel CanBoot li\u00e9 ci-dessus fournit des instructions pour cr\u00e9er le chargeur de d\u00e9marrage. La premi\u00e8re fois que CanBoot a \u00e9t\u00e9 flash\u00e9, il devrait d\u00e9tecter qu'aucune application n'est pr\u00e9sente et entrer dans le chargeur de d\u00e9marrage. Si cela ne se produit pas, il est possible d'entrer dans le chargeur de d\u00e9marrage en appuyant deux fois de suite sur le bouton de r\u00e9initialisation. L'utilitaire flash_can.py fourni dans le dossier lib/canboot peut \u00eatre utilis\u00e9 pour t\u00e9l\u00e9charger le firmware Klipper. L'UUID de l'appareil doit clignoter. Si vous n'avez pas d'UUID, il est possible d'interroger les n\u0153uds ex\u00e9cutant actuellement le chargeur de d\u00e9marrage : python3 flash_can.py -q Cela renverra les UUID pour tous les n\u0153uds connect\u00e9s et qui n'avaient pas d'UUID attribu\u00e9. Cela devrait inclure tous les n\u0153uds actuellement dans le chargeur de d\u00e9marrage. Une fois que vous avez un UUID, vous pouvez t\u00e9l\u00e9charger le firmware avec la commande suivante : python3 flash_can.py -i can0 -f ~/klipper/out/klipper.bin -u aabbccddeeff O\u00f9 aabbccddeeff est remplac\u00e9 par votre UUID. Notez que les options -i et -f peuvent \u00eatre omises, elles sont par d\u00e9faut sur can0 et ~/klipper/out/klipper.bin . Lors de la cr\u00e9ation de Klipper pour une utilisation avec CanBoot, s\u00e9lectionnez l'option 8 KiB Bootloader.","title":"STM32F103/STM32F0x2 avec chargeur de d\u00e9marrage CanBoot"},{"location":"Bootloaders.html#micro-controleurs-stm32f4-skr-pro-11","text":"Les microcontr\u00f4leurs STM32F4 sont \u00e9quip\u00e9s d'un chargeur de d\u00e9marrage syst\u00e8me int\u00e9gr\u00e9 capable de flasher via USB (via DFU), s\u00e9rie 3,3 V et diverses autres m\u00e9thodes (voir le document STM AN2606 pour plus d'informations). Certaines cartes STM32F4, telles que le SKR Pro 1.1, ne peuvent pas passer en mode DFU. Le chargeur de d\u00e9marrage HID est disponible pour les cartes bas\u00e9es sur STM32F405/407 si l'utilisateur pr\u00e9f\u00e8re flasher sur USB plut\u00f4t que d'utiliser la carte SD. Notez que vous devrez peut-\u00eatre configurer et construire une version sp\u00e9cifique \u00e0 votre carte, une version pour le SKR Pro 1.1 est disponible ici . \u00c0 moins que votre carte ne soit compatible DFU, la m\u00e9thode de flashla plus accessible est probablement via une ligne s\u00e9rie 3,3 V, qui suit la m\u00eame proc\u00e9dure que flasher le STM32F103 avec stm32flash . Par exemple\u202f: wget https://github.com/Arksine/STM32_HID_Bootloader/releases/download/v0.5-beta/hid_bootloader_SKR_PRO.bin stm32flash -w hid_bootloader_SKR_PRO.bin -v -g 0 /dev/ttyAMA0 Ce chargeur de d\u00e9marrage n\u00e9cessite 16 Ko d'espace flash sur le STM32F4 (l'application doit \u00eatre compil\u00e9e avec une adresse de d\u00e9marrage de 16 Ko). Comme avec le STM32F1, le STM32F4 utilise l'outil hid-flash pour t\u00e9l\u00e9charger des fichiers binaires sur le MCU. Voir les instructions ci-dessus pour plus de d\u00e9tails sur la fa\u00e7on de construire et d'utiliser hid-flash. Il peut \u00eatre n\u00e9cessaire d'entrer manuellement dans le chargeur de d\u00e9marrage, cela peut \u00eatre fait en d\u00e9finissant \"boot 0\" au niveau bas, \"boot 1\" au niveau haut et en branchant l'appareil. Une fois la programmation termin\u00e9e, d\u00e9branchez l'appareil et re-r\u00e9glez \"boot 1\" au niveau bas pour que l'application soit charg\u00e9e.","title":"Micro-contr\u00f4leurs STM32F4 (SKR Pro 1.1)"},{"location":"Bootloaders.html#micro-controleurs-lpc176x-smoothieboards","text":"Ce document ne d\u00e9crit pas la m\u00e9thode pour flasher le Chargeur de d\u00e9marrage lui-m\u00eame - voir : http://smoothieware.org/flashing-the-bootloader pour plus d'informations sur ce sujet. Il est courant que les Smoothieboards soient livr\u00e9s avec un chargeur de d\u00e9marrage de : https://github.com/triffid/LPC17xx-DFU-Bootloader . Lors de l'utilisation de ce chargeur de d\u00e9marrage, l'application doit \u00eatre compil\u00e9e avec une adresse de d\u00e9marrage de 16 Ko. Le moyen le plus simple de flasher une application avec ce chargeur de d\u00e9marrage est de copier le fichier d'application (par exemple, out/klipper.bin ) dans un fichier nomm\u00e9 firmware.bin sur une carte SD, et puis de red\u00e9marrer le microcontr\u00f4leur avec cette carte SD.","title":"Micro-contr\u00f4leurs LPC176x (Smoothieboards)"},{"location":"Bootloaders.html#executer-openocd-sur-le-raspberry-pi","text":"OpenOCD est un logiciel qui peut effectuer un flashage et un d\u00e9bogage de puce de bas niveau. Il peut utiliser les broches GPIO d'un Raspberry Pi pour communiquer avec une vari\u00e9t\u00e9 de puces ARM. Cette section d\u00e9crit comment installer et lancer OpenOCD. Elle d\u00e9rive des instructions disponibles sur : https://learn.adafruit.com/programming-microcontrollers-using-openocd-on-raspberry-pi Commencez par t\u00e9l\u00e9charger et compiler le logiciel (chaque \u00e9tape peut prendre plusieurs minutes et l'\u00e9tape \"make\" peut prendre plus de 30 minutes) : sudo apt-get update sudo apt-get install autoconf libtool telnet mkdir ~/openocd cd ~/openocd/ git clone http://openocd.zylin.com/openocd cd openocd ./bootstrap ./configure --enable-sysfsgpio --enable-bcm2835gpio --prefix=/home/pi/openocd/install make make install","title":"Ex\u00e9cuter OpenOCD sur le Raspberry PI"},{"location":"Bootloaders.html#configurer-openocd","text":"Cr\u00e9ez un fichier de configuration OpenOCD : nano ~/openocd/openocd.cfg Utilisez une configuration similaire \u00e0 la suivante : # Utilise les pins du RPI: GPIO25 pour SWDCLK, GPIO24 pour SWDIO, GPIO18 pour nRST source [find interface/raspberrypi2-native.cfg] bcm2835gpio_swd_nums 25 24 bcm2835gpio_srst_num 18 transport select swd # Utilise le reset c\u00e2bl\u00e9 pour la raz de la puce reset_config srst_only adapter_nsrst_delay 100 adapter_nsrst_assert_width 100 # Specification du type de puce source [find target/atsame5x.cfg] # D\u00e9finir la vitesse de l'adaptateur adapter_khz 40 # Connexion \u00e0 la puce init targets reset halt","title":"Configurer OpenOCD"},{"location":"Bootloaders.html#cablez-le-raspberry-pi-sur-la-puce-cible","text":"\u00c9teignez \u00e0 la fois le Raspberry Pi et la puce cible avant le c\u00e2blage ! V\u00e9rifiez que la puce cible utilise bien du 3,3 V avant de la connecter au Raspberry Pi ! Connectez GND, SWDCLK, SWDIO et RST sur la puce cible \u00e0 GND, GPIO25, GPIO24 et GPIO18 sur le Raspberry Pi. Mettez ensuite le Raspberry Pi sous tension et alimentez la puce cible.","title":"C\u00e2blez le Raspberry Pi sur la puce cible"},{"location":"Bootloaders.html#executez-openocd","text":"Ex\u00e9cutez OpenOCD : cd ~/openocd/ sudo ~/openocd/install/bin/openocd -f ~/openocd/openocd.cfg Ce qui pr\u00e9c\u00e8de devrait amener OpenOCD \u00e0 \u00e9mettre des messages texte, puis \u00e0 attendre (il ne doit pas imm\u00e9diatement revenir \u00e0 l'invite du shell). Si OpenOCD se ferme tout seul ou s'il continue \u00e0 \u00e9mettre des messages texte, v\u00e9rifiez \u00e0 nouveau le c\u00e2blage. Une fois OpenOCD en cours d'ex\u00e9cution et stable, on peut lui envoyer des commandes via telnet. Ouvrez une autre session SSH et ex\u00e9cutez ce qui suit : telnet 127.0.0.1 4444 (Vous pouvez quitter telnet en appuyant sur ctrl+] puis en ex\u00e9cutant la commande \"quit\".)","title":"Ex\u00e9cutez OpenOCD"},{"location":"Bootloaders.html#openocd-et-gdb","text":"Il est possible d'utiliser OpenOCD avec gdb pour d\u00e9boguer Klipper. Les commandes suivantes supposent que l'on ex\u00e9cute gdb sur une machine de bureau. Ajoutez ce qui suit au fichier de configuration OpenOCD : bindto 0.0.0.0 gdb_port 44444 Red\u00e9marrez OpenOCD sur le Raspberry Pi, puis ex\u00e9cutez la commande Unix suivante sur la machine de bureau : cd /path/to/klipper/ gdb out/klipper.elf Dans gdb, ex\u00e9cutez : target remote octopi:44444 (Remplacez \"octopi\" par le nom d'h\u00f4te du Raspberry Pi.) Une fois que gdb est en cours d'ex\u00e9cution, il est possible de d\u00e9finir des points d'arr\u00eat et d'inspecter les registres.","title":"OpenOCD et gdb"},{"location":"CANBUS.html","text":"CANBUS \u00b6 Ce document d\u00e9crit la prise en charge du CAN bus de Klipper. Mat\u00e9riel de l'appareil \u00b6 Klipper currently supports CAN on stm32, SAME5x, and rp2040 chips. In addition, the micro-controller chip must be on a board that has a CAN transceiver. Pour compiler le firmware de votre mat\u00e9riel canbus, ex\u00e9cutez make menuconfig et s\u00e9lectionnez \u00ab CAN bus \u00bb comme interface de communication. Enfin, compilez le code du microcontr\u00f4leur et flashez-le sur la carte cible. Mat\u00e9riel de l'h\u00f4te \u00b6 In order to use a CAN bus, it is necessary to have a host adapter. It is recommended to use a \"USB to CAN adapter\". There are many different USB to CAN adapters available from different manufacturers. When choosing one, we recommend verifying that the firmware can be updated on it. (Unfortunately, we've found some USB adapters run defective firmware and are locked down, so verify before purchasing.) Look for adapters that can run Klipper directly (in its \"USB to CAN bridge mode\") or that run the candlelight firmware . Il faut aussi configurer le syst\u00e8me d'exploitation h\u00f4te pour utiliser l'adaptateur. Cela se fait g\u00e9n\u00e9ralement en cr\u00e9ant un nouveau fichier nomm\u00e9 /etc/network/interfaces.d/can0 avec le contenu suivant : allow-hotplug can0 iface can0 can static bitrate 1000000 up ifconfig $IFACE txqueuelen 128 R\u00e9sistances de terminaison \u00b6 Un bus CAN doit avoir deux r\u00e9sistances de 120 ohms entre les fils CANH et CANL. Id\u00e9alement, une r\u00e9sistance situ\u00e9e \u00e0 chaque extr\u00e9mit\u00e9 du bus. Note that some devices have a builtin 120 ohm resistor that can not be easily removed. Some devices do not include a resistor at all. Other devices have a mechanism to select the resistor (typically by connecting a \"pin jumper\"). Be sure to check the schematics of all devices on the CAN bus to verify that there are two and only two 120 Ohm resistors on the bus. Pour tester que les r\u00e9sistances sont correctes, on peut couper l'alimentation de l'imprimante et utiliser un multim\u00e8tre pour v\u00e9rifier la r\u00e9sistance entre les fils CANH et CANL - la r\u00e9sistance doit \u00eatre d'environ 60 ohms sur un bus CAN correctement c\u00e2bl\u00e9. Trouver le canbus_uuid pour les nouveaux microcontr\u00f4leurs \u00b6 Chaque microcontr\u00f4leur sur le bus CAN se voit attribuer un identifiant unique bas\u00e9 sur un identifiant de puce cod\u00e9 en usine dans chaque microcontr\u00f4leur. Pour trouver les identifiant canbus des microcontr\u00f4leurs, assurez-vous que le mat\u00e9riel est correctement aliment\u00e9 et c\u00e2bl\u00e9, puis ex\u00e9cutez : ~/klippy-env/bin/python ~/klipper/scripts/canbus_query.py can0 Si des p\u00e9riph\u00e9riques CAN non initialis\u00e9s sont d\u00e9tect\u00e9s, la commande ci-dessus remontera des lignes comme celles-ci : Found canbus_uuid=11aa22bb33cc, Application: Klipper Chaque appareil aura un identifiant unique. Dans l'exemple ci-dessus, 11aa22bb33cc est le \"canbus_uuid\" du microcontr\u00f4leur. Notez que l'outil canbus_query.py ne signalera que les appareils non initialis\u00e9s - si Klipper (ou un outil similaire) configure l'appareil, il n'appara\u00eetra plus dans la liste. Configuration de Klipper \u00b6 Mettez \u00e0 jour la configuration de Klipper configuration mcu afin d'utiliser le bus CAN pour communiquer avec l'appareil - par exemple : [mcu my_can_mcu] canbus_uuid: 11aa22bb33cc Mode pont USB vers bus CAN \u00b6 Some micro-controllers support selecting \"USB to CAN bus bridge\" mode during Klipper's \"make menuconfig\". This mode may allow one to use a micro-controller as both a \"USB to CAN bus adapter\" and as a Klipper node. When Klipper uses this mode the micro-controller appears as a \"USB CAN bus adapter\" under Linux. The \"Klipper bridge mcu\" itself will appear as if it was on this CAN bus - it can be identified via canbus_query.py and it must be configured like other CAN bus Klipper nodes. Quelques remarques importantes lors de l'utilisation de ce mode : Il est n\u00e9cessaire de configurer l'interface can0 (ou similaire) sous Linux afin de communiquer avec le bus. Cependant, la vitesse du bus CAN Linux et les options de synchronisation des bits du bus CAN sont ignor\u00e9es par Klipper. Actuellement, la fr\u00e9quence du bus CAN est sp\u00e9cifi\u00e9e lors de \"make menuconfig\" et la vitesse du bus sp\u00e9cifi\u00e9e dans Linux est ignor\u00e9e. Whenever the \"bridge mcu\" is reset, Linux will disable the corresponding can0 interface. To ensure proper handling of FIRMWARE_RESTART and RESTART commands, it is recommended to use allow-hotplug in the /etc/network/interfaces.d/can0 file. For example: allow-hotplug can0 iface can0 can static bitrate 1000000 up ifconfig $IFACE txqueuelen 128 The \"bridge mcu\" is not actually on the CAN bus. Messages to and from the bridge mcu will not be seen by other adapters that may be on the CAN bus. The available bandwidth to both the \"bridge mcu\" itself and all devices on the CAN bus is effectively limited by the CAN bus frequency. As a result, it is recommended to use a CAN bus frequency of 1000000 when using \"USB to CAN bus bridge mode\".Even at a CAN bus frequency of 1000000, there may not be sufficient bandwidth to run a SHAPER_CALIBRATE test if both the XY steppers and the accelerometer all communicate via a single \"USB to CAN bus\" interface. A USB to CAN bridge board will not appear as a USB serial device, it will not show up when running ls /dev/serial/by-id , and it can not be configured in Klipper's printer.cfg file with a serial: parameter. The bridge board appears as a \"USB CAN adapter\" and it is configured in the printer.cfg as a CAN node . Tips for troubleshooting \u00b6 See the CAN bus troubleshooting document.","title":"CANBUS"},{"location":"CANBUS.html#canbus","text":"Ce document d\u00e9crit la prise en charge du CAN bus de Klipper.","title":"CANBUS"},{"location":"CANBUS.html#materiel-de-lappareil","text":"Klipper currently supports CAN on stm32, SAME5x, and rp2040 chips. In addition, the micro-controller chip must be on a board that has a CAN transceiver. Pour compiler le firmware de votre mat\u00e9riel canbus, ex\u00e9cutez make menuconfig et s\u00e9lectionnez \u00ab CAN bus \u00bb comme interface de communication. Enfin, compilez le code du microcontr\u00f4leur et flashez-le sur la carte cible.","title":"Mat\u00e9riel de l'appareil"},{"location":"CANBUS.html#materiel-de-lhote","text":"In order to use a CAN bus, it is necessary to have a host adapter. It is recommended to use a \"USB to CAN adapter\". There are many different USB to CAN adapters available from different manufacturers. When choosing one, we recommend verifying that the firmware can be updated on it. (Unfortunately, we've found some USB adapters run defective firmware and are locked down, so verify before purchasing.) Look for adapters that can run Klipper directly (in its \"USB to CAN bridge mode\") or that run the candlelight firmware . Il faut aussi configurer le syst\u00e8me d'exploitation h\u00f4te pour utiliser l'adaptateur. Cela se fait g\u00e9n\u00e9ralement en cr\u00e9ant un nouveau fichier nomm\u00e9 /etc/network/interfaces.d/can0 avec le contenu suivant : allow-hotplug can0 iface can0 can static bitrate 1000000 up ifconfig $IFACE txqueuelen 128","title":"Mat\u00e9riel de l'h\u00f4te"},{"location":"CANBUS.html#resistances-de-terminaison","text":"Un bus CAN doit avoir deux r\u00e9sistances de 120 ohms entre les fils CANH et CANL. Id\u00e9alement, une r\u00e9sistance situ\u00e9e \u00e0 chaque extr\u00e9mit\u00e9 du bus. Note that some devices have a builtin 120 ohm resistor that can not be easily removed. Some devices do not include a resistor at all. Other devices have a mechanism to select the resistor (typically by connecting a \"pin jumper\"). Be sure to check the schematics of all devices on the CAN bus to verify that there are two and only two 120 Ohm resistors on the bus. Pour tester que les r\u00e9sistances sont correctes, on peut couper l'alimentation de l'imprimante et utiliser un multim\u00e8tre pour v\u00e9rifier la r\u00e9sistance entre les fils CANH et CANL - la r\u00e9sistance doit \u00eatre d'environ 60 ohms sur un bus CAN correctement c\u00e2bl\u00e9.","title":"R\u00e9sistances de terminaison"},{"location":"CANBUS.html#trouver-le-canbus_uuid-pour-les-nouveaux-microcontroleurs","text":"Chaque microcontr\u00f4leur sur le bus CAN se voit attribuer un identifiant unique bas\u00e9 sur un identifiant de puce cod\u00e9 en usine dans chaque microcontr\u00f4leur. Pour trouver les identifiant canbus des microcontr\u00f4leurs, assurez-vous que le mat\u00e9riel est correctement aliment\u00e9 et c\u00e2bl\u00e9, puis ex\u00e9cutez : ~/klippy-env/bin/python ~/klipper/scripts/canbus_query.py can0 Si des p\u00e9riph\u00e9riques CAN non initialis\u00e9s sont d\u00e9tect\u00e9s, la commande ci-dessus remontera des lignes comme celles-ci : Found canbus_uuid=11aa22bb33cc, Application: Klipper Chaque appareil aura un identifiant unique. Dans l'exemple ci-dessus, 11aa22bb33cc est le \"canbus_uuid\" du microcontr\u00f4leur. Notez que l'outil canbus_query.py ne signalera que les appareils non initialis\u00e9s - si Klipper (ou un outil similaire) configure l'appareil, il n'appara\u00eetra plus dans la liste.","title":"Trouver le canbus_uuid pour les nouveaux microcontr\u00f4leurs"},{"location":"CANBUS.html#configuration-de-klipper","text":"Mettez \u00e0 jour la configuration de Klipper configuration mcu afin d'utiliser le bus CAN pour communiquer avec l'appareil - par exemple : [mcu my_can_mcu] canbus_uuid: 11aa22bb33cc","title":"Configuration de Klipper"},{"location":"CANBUS.html#mode-pont-usb-vers-bus-can","text":"Some micro-controllers support selecting \"USB to CAN bus bridge\" mode during Klipper's \"make menuconfig\". This mode may allow one to use a micro-controller as both a \"USB to CAN bus adapter\" and as a Klipper node. When Klipper uses this mode the micro-controller appears as a \"USB CAN bus adapter\" under Linux. The \"Klipper bridge mcu\" itself will appear as if it was on this CAN bus - it can be identified via canbus_query.py and it must be configured like other CAN bus Klipper nodes. Quelques remarques importantes lors de l'utilisation de ce mode : Il est n\u00e9cessaire de configurer l'interface can0 (ou similaire) sous Linux afin de communiquer avec le bus. Cependant, la vitesse du bus CAN Linux et les options de synchronisation des bits du bus CAN sont ignor\u00e9es par Klipper. Actuellement, la fr\u00e9quence du bus CAN est sp\u00e9cifi\u00e9e lors de \"make menuconfig\" et la vitesse du bus sp\u00e9cifi\u00e9e dans Linux est ignor\u00e9e. Whenever the \"bridge mcu\" is reset, Linux will disable the corresponding can0 interface. To ensure proper handling of FIRMWARE_RESTART and RESTART commands, it is recommended to use allow-hotplug in the /etc/network/interfaces.d/can0 file. For example: allow-hotplug can0 iface can0 can static bitrate 1000000 up ifconfig $IFACE txqueuelen 128 The \"bridge mcu\" is not actually on the CAN bus. Messages to and from the bridge mcu will not be seen by other adapters that may be on the CAN bus. The available bandwidth to both the \"bridge mcu\" itself and all devices on the CAN bus is effectively limited by the CAN bus frequency. As a result, it is recommended to use a CAN bus frequency of 1000000 when using \"USB to CAN bus bridge mode\".Even at a CAN bus frequency of 1000000, there may not be sufficient bandwidth to run a SHAPER_CALIBRATE test if both the XY steppers and the accelerometer all communicate via a single \"USB to CAN bus\" interface. A USB to CAN bridge board will not appear as a USB serial device, it will not show up when running ls /dev/serial/by-id , and it can not be configured in Klipper's printer.cfg file with a serial: parameter. The bridge board appears as a \"USB CAN adapter\" and it is configured in the printer.cfg as a CAN node .","title":"Mode pont USB vers bus CAN"},{"location":"CANBUS.html#tips-for-troubleshooting","text":"See the CAN bus troubleshooting document.","title":"Tips for troubleshooting"},{"location":"CANBUS_Troubleshooting.html","text":"CANBUS Troubleshooting \u00b6 This document provides information on troubleshooting communication issues when using Klipper with CAN bus . Verify CAN bus wiring \u00b6 The first step in troubleshooting communication issues is to verify the CAN bus wiring. Be sure there are exactly two 120 Ohm terminating resistors on the CAN bus. If the resistors are not properly installed then messages may not be able to be sent at all or the connection may have sporadic instability. The CANH and CANL bus wiring should be twisted around each other. At a minimum, the wiring should have a twist every few centimeters. Avoid twisting the CANH and CANL wiring around power wires and ensure that power wires that travel parallel to the CANH and CANL wires do not have the same amount of twists. Verify that all plugs and wire crimps on the CAN bus wiring are fully secured. Movement of the printer toolhead may jostle the CAN bus wiring causing a bad wire crimp or unsecured plug to result in intermittent communication errors. Check for incrementing bytes_invalid counter \u00b6 The Klipper log file will report a Stats line once a second when the printer is active. These \"Stats\" lines will have a bytes_invalid counter for each micro-controller. This counter should not increment during normal printer operation (it is normal for the counter to be non-zero after a RESTART and it is not a concern if the counter increments once a month or so). If this counter increments on a CAN bus micro-controller during normal printing (it increments every few hours or more frequently) then it is an indication of a severe problem. Incrementing bytes_invalid on a CAN bus connection is a symptom of reordered messages on the CAN bus. There are two known causes of reordered messages: Old versions of the popular candlight_firmware for USB CAN adapters had a bug that could cause reordered messages. If using a USB CAN adapter running this firmware then make sure to update to the latest firmware if incrementing bytes_invalid is observed. Some Linux kernel builds for embedded devices have been known to reorder CAN bus messages. It may be necessary to use an alternative Linux kernel or to use alternative hardware that supports mainstream Linux kernels that do not exhibit this problem. Reordered messages is a severe problem that must be fixed. It will result in unstable behavior and can lead to confusing errors at any part of a print. Obtaining candump logs \u00b6 The CAN bus messages sent to and from the micro-controller are handled by the Linux kernel. It is possible to capture these messages from the kernel for debugging purposes. A log of these messages may be of use in diagnostics. The Linux can-utils tool provides the capture software. It is typically installed on a machine by running: sudo apt-get update && sudo apt-get install can-utils Once installed, one may obtain a capture of all CAN bus messages on an interface with the following command: candump -tz -Ddex can0,#FFFFFFFF > mycanlog One can view the resulting log file ( mycanlog in the example above) to see each raw CAN bus message that was sent and received by Klipper. Understanding the content of these messages will likely require low-level knowledge of Klipper's CANBUS protocol and Klipper's MCU commands . Parsing Klipper messages in a candump log \u00b6 One may use the parsecandump.py tool to parse the low-level Klipper micro-controller messages contained in a candump log. Using this tool is an advanced topic that requires knowledge of Klipper MCU commands . For example: ./scripts/parsecandump.py mycanlog 108 ./out/klipper.dict This tool produces output similar to the parsedump tool . See the documentation for that tool for information on generating the Klipper micro-controller data dictionary. In the above example, 108 is the CAN bus id . It is a hexadecimal number. The id 108 is assigned by Klipper to the first micro-controller. If the CAN bus has multiple micro-controllers on it, then the second micro-controller would be 10a , the third would be 10c , and so on. The candump log must be produced using the -tz -Ddex command-line arguments (for example: candump -tz -Ddex can0,#FFFFFFFF ) in order to use the parsecandump.py tool. Using a logic analyzer on the canbus wiring \u00b6 The Sigrok Pulseview software along with a low-cost logic analyzer can be useful for diagnosing CAN bus signaling. This is an advanced topic likely only of interest to experts. One can often find \"USB logic analyzers\" for under $15 (US pricing as of 2023). These devices are often listed as \"Saleae logic clones\" or as \"24MHz 8 channel USB logic analyzers\". The above picture was taken while using Pulseview with a \"Saleae clone\" logic analyzer. The Sigrok and Pulseview software was installed on a desktop machine (also install the \"fx2lafw\" firmware if that is packaged separately). The CH0 pin on the logic analyzer was routed to the CAN Rx line, the CH1 pin was wired to the CAN Tx pin, and GND was wired to GND. Pulseview was configured to only display the D0 and D1 lines (red \"probe\" icon center top toolbar). The number of samples was set to 5 million (top toolbar) and the sample rate was set to 24Mhz (top toolbar). The CAN decoder was added (yellow and green \"bubble icon\" right top toolbar). The D0 channel was labeled as RX and set to trigger on a falling edge (click on black D0 label at left). The D1 channel was labeled as TX (click on brown D1 label at left). The CAN decoder was configured for 1Mbit rate (click on green CAN label at left). The CAN decoder was moved to the top of the display (click and drag green CAN label). Finally, the capture was started (click \"Run\" at top left) and a packet was transmitted on the CAN bus ( cansend can0 123#121212121212 ). The logic analyzer provides an independent tool for capturing packets and verifying bit timing.","title":"CANBUS Troubleshooting"},{"location":"CANBUS_Troubleshooting.html#canbus-troubleshooting","text":"This document provides information on troubleshooting communication issues when using Klipper with CAN bus .","title":"CANBUS Troubleshooting"},{"location":"CANBUS_Troubleshooting.html#verify-can-bus-wiring","text":"The first step in troubleshooting communication issues is to verify the CAN bus wiring. Be sure there are exactly two 120 Ohm terminating resistors on the CAN bus. If the resistors are not properly installed then messages may not be able to be sent at all or the connection may have sporadic instability. The CANH and CANL bus wiring should be twisted around each other. At a minimum, the wiring should have a twist every few centimeters. Avoid twisting the CANH and CANL wiring around power wires and ensure that power wires that travel parallel to the CANH and CANL wires do not have the same amount of twists. Verify that all plugs and wire crimps on the CAN bus wiring are fully secured. Movement of the printer toolhead may jostle the CAN bus wiring causing a bad wire crimp or unsecured plug to result in intermittent communication errors.","title":"Verify CAN bus wiring"},{"location":"CANBUS_Troubleshooting.html#check-for-incrementing-bytes_invalid-counter","text":"The Klipper log file will report a Stats line once a second when the printer is active. These \"Stats\" lines will have a bytes_invalid counter for each micro-controller. This counter should not increment during normal printer operation (it is normal for the counter to be non-zero after a RESTART and it is not a concern if the counter increments once a month or so). If this counter increments on a CAN bus micro-controller during normal printing (it increments every few hours or more frequently) then it is an indication of a severe problem. Incrementing bytes_invalid on a CAN bus connection is a symptom of reordered messages on the CAN bus. There are two known causes of reordered messages: Old versions of the popular candlight_firmware for USB CAN adapters had a bug that could cause reordered messages. If using a USB CAN adapter running this firmware then make sure to update to the latest firmware if incrementing bytes_invalid is observed. Some Linux kernel builds for embedded devices have been known to reorder CAN bus messages. It may be necessary to use an alternative Linux kernel or to use alternative hardware that supports mainstream Linux kernels that do not exhibit this problem. Reordered messages is a severe problem that must be fixed. It will result in unstable behavior and can lead to confusing errors at any part of a print.","title":"Check for incrementing bytes_invalid counter"},{"location":"CANBUS_Troubleshooting.html#obtaining-candump-logs","text":"The CAN bus messages sent to and from the micro-controller are handled by the Linux kernel. It is possible to capture these messages from the kernel for debugging purposes. A log of these messages may be of use in diagnostics. The Linux can-utils tool provides the capture software. It is typically installed on a machine by running: sudo apt-get update && sudo apt-get install can-utils Once installed, one may obtain a capture of all CAN bus messages on an interface with the following command: candump -tz -Ddex can0,#FFFFFFFF > mycanlog One can view the resulting log file ( mycanlog in the example above) to see each raw CAN bus message that was sent and received by Klipper. Understanding the content of these messages will likely require low-level knowledge of Klipper's CANBUS protocol and Klipper's MCU commands .","title":"Obtaining candump logs"},{"location":"CANBUS_Troubleshooting.html#parsing-klipper-messages-in-a-candump-log","text":"One may use the parsecandump.py tool to parse the low-level Klipper micro-controller messages contained in a candump log. Using this tool is an advanced topic that requires knowledge of Klipper MCU commands . For example: ./scripts/parsecandump.py mycanlog 108 ./out/klipper.dict This tool produces output similar to the parsedump tool . See the documentation for that tool for information on generating the Klipper micro-controller data dictionary. In the above example, 108 is the CAN bus id . It is a hexadecimal number. The id 108 is assigned by Klipper to the first micro-controller. If the CAN bus has multiple micro-controllers on it, then the second micro-controller would be 10a , the third would be 10c , and so on. The candump log must be produced using the -tz -Ddex command-line arguments (for example: candump -tz -Ddex can0,#FFFFFFFF ) in order to use the parsecandump.py tool.","title":"Parsing Klipper messages in a candump log"},{"location":"CANBUS_Troubleshooting.html#using-a-logic-analyzer-on-the-canbus-wiring","text":"The Sigrok Pulseview software along with a low-cost logic analyzer can be useful for diagnosing CAN bus signaling. This is an advanced topic likely only of interest to experts. One can often find \"USB logic analyzers\" for under $15 (US pricing as of 2023). These devices are often listed as \"Saleae logic clones\" or as \"24MHz 8 channel USB logic analyzers\". The above picture was taken while using Pulseview with a \"Saleae clone\" logic analyzer. The Sigrok and Pulseview software was installed on a desktop machine (also install the \"fx2lafw\" firmware if that is packaged separately). The CH0 pin on the logic analyzer was routed to the CAN Rx line, the CH1 pin was wired to the CAN Tx pin, and GND was wired to GND. Pulseview was configured to only display the D0 and D1 lines (red \"probe\" icon center top toolbar). The number of samples was set to 5 million (top toolbar) and the sample rate was set to 24Mhz (top toolbar). The CAN decoder was added (yellow and green \"bubble icon\" right top toolbar). The D0 channel was labeled as RX and set to trigger on a falling edge (click on black D0 label at left). The D1 channel was labeled as TX (click on brown D1 label at left). The CAN decoder was configured for 1Mbit rate (click on green CAN label at left). The CAN decoder was moved to the top of the display (click and drag green CAN label). Finally, the capture was started (click \"Run\" at top left) and a packet was transmitted on the CAN bus ( cansend can0 123#121212121212 ). The logic analyzer provides an independent tool for capturing packets and verifying bit timing.","title":"Using a logic analyzer on the canbus wiring"},{"location":"CANBUS_protocol.html","text":"Protocole CANBUS \u00b6 Ce document d\u00e9crit le protocole qu'utilise Klipper pour communiquer sur la couche CAN bus . Voir pour plus d'informations sur la configuration de canbus avec Klipper. Assignation de l'identifiant du micro-contr\u00f4leur \u00b6 Klipper utilise uniquement les paquets CAN bus 2.0A de taille standard, limit\u00e9s \u00e0 8 octets de donn\u00e9es et \u00e0 un identificateur de bus CAN de 11 bits. Afin de permettre des communications efficaces, un identifiant ( canbus_nodeid ) de 1 octet est affect\u00e9 \u00e0 chaque microcontr\u00f4leur pour g\u00e9rer les commandes et r\u00e9ponses Klipper. Les commandes Klipper \u00e9mises du microcontr\u00f4leur vers l'h\u00f4te utilisent l'id du bus CAN canbus_nodeid * 2 + 256 , tandis que les messages de retour du microcontr\u00f4leur vers l'h\u00f4te utilisent canbus_nodeid' *2 + 256 + 1 . Chaque microcontr\u00f4leur poss\u00e8de un identifiant unique attribu\u00e9 en usine qui est utilis\u00e9 lors de l'attribution de l'id. Cet identifiant pout d\u00e9passer la taille d'un paquet CAN, un fonction de hash est utilis\u00e9e pour g\u00e9nerer un id unique de 6 octets ( canbus_uuid ) \u00e0 partir de l'id 'usine'. Messages 'Admin' \u00b6 Les messages 'administratifs' sont utilis\u00e9s pour l'attribution des id. Ces messages envoy\u00e9s de l'h\u00f4te vers le microcontr\u00f4leur utilisent l'id 0x3f0\u0300 et les messages envoy\u00e9s du microcontr\u00f4leur vers l'h\u00f4te utilisent l'id 0x3f1 . Tous les microcontr\u00f4leurs \u00e9coutent les messages en provenance de 0x3f0 . Cet id peut \u00eatre consid\u00e9r\u00e9 comme une adresse de multidiffusion. Message CMD_QUERY_UNASSIGNED \u00b6 Cette commande interroge tous les microcontr\u00f4leurs pour lesquels aucun canbus_nodeid n'a \u00e9t\u00e9 assign\u00e9. Ces microcontr\u00f4leurs non assign\u00e9s, retournent un message RESP_NEED_NODEID. Le format du message CMD_QUERY_UNASSIGNED est : <1-octet pour le message_id = 0x00> Message CMD_SET_KLIPPER_NODEID \u00b6 Cette commande attribue un canbus_nodeid \u00e0 partir du canbus_uuid du microcontr\u00f4leur. Le format du message CMD_SET_KLIPPER_NODEID est : <1 octet pour le message_id = 0x01><6 octets pour le canbus_uuid><1 octet pour le canbus_nodeid> Message RESP_NEED_NODEID \u00b6 Le format du message RESP_NODE_NODEID est : <1 octet pour le message_id = 0x20><6 octets pour le canbus_uuid><1 octet pour le set_klipper_nodeid=0x01> Paquets de donn\u00e9es \u00b6 Un microcont\u00f4leur ayant re\u00e7u un nodeid par la commande CMD_SET_KLIPPER_NODEID peut envoyer et recevoir des paquets de donn\u00e9es. Les donn\u00e9es des paquets des messages utilisant l'identifiant de r\u00e9ception du bus CAN du n\u0153ud ( canbus_nodeid * 2 + 256 )' sont simplement ajout\u00e9s \u00e0 la fin du tampon et lorsque un mcu protocol message complet est trouv\u00e9 son contenu est analys\u00e9 et trait\u00e9. Les donn\u00e9es sont trait\u00e9es comme un flux d'octets - il n'est pas n\u00e9cessaire que le d\u00e9but d'un bloc de message Klipper soit align\u00e9 avec le d\u00e9but d'un paquet CAN bus. De la m\u00eame mani\u00e8re, les r\u00e9ponses sont renvoy\u00e9es du micrcontr\u00f4leur \u00e0 l'h\u00f4te en copiant les donn\u00e9es du message dans un ou plusieurs paquets avec l'identifiant canbus ( canbus_nodeid * 2 + 256 + 1 ).","title":"Protocole CANBUS"},{"location":"CANBUS_protocol.html#protocole-canbus","text":"Ce document d\u00e9crit le protocole qu'utilise Klipper pour communiquer sur la couche CAN bus . Voir pour plus d'informations sur la configuration de canbus avec Klipper.","title":"Protocole CANBUS"},{"location":"CANBUS_protocol.html#assignation-de-lidentifiant-du-micro-controleur","text":"Klipper utilise uniquement les paquets CAN bus 2.0A de taille standard, limit\u00e9s \u00e0 8 octets de donn\u00e9es et \u00e0 un identificateur de bus CAN de 11 bits. Afin de permettre des communications efficaces, un identifiant ( canbus_nodeid ) de 1 octet est affect\u00e9 \u00e0 chaque microcontr\u00f4leur pour g\u00e9rer les commandes et r\u00e9ponses Klipper. Les commandes Klipper \u00e9mises du microcontr\u00f4leur vers l'h\u00f4te utilisent l'id du bus CAN canbus_nodeid * 2 + 256 , tandis que les messages de retour du microcontr\u00f4leur vers l'h\u00f4te utilisent canbus_nodeid' *2 + 256 + 1 . Chaque microcontr\u00f4leur poss\u00e8de un identifiant unique attribu\u00e9 en usine qui est utilis\u00e9 lors de l'attribution de l'id. Cet identifiant pout d\u00e9passer la taille d'un paquet CAN, un fonction de hash est utilis\u00e9e pour g\u00e9nerer un id unique de 6 octets ( canbus_uuid ) \u00e0 partir de l'id 'usine'.","title":"Assignation de l'identifiant du micro-contr\u00f4leur"},{"location":"CANBUS_protocol.html#messages-admin","text":"Les messages 'administratifs' sont utilis\u00e9s pour l'attribution des id. Ces messages envoy\u00e9s de l'h\u00f4te vers le microcontr\u00f4leur utilisent l'id 0x3f0\u0300 et les messages envoy\u00e9s du microcontr\u00f4leur vers l'h\u00f4te utilisent l'id 0x3f1 . Tous les microcontr\u00f4leurs \u00e9coutent les messages en provenance de 0x3f0 . Cet id peut \u00eatre consid\u00e9r\u00e9 comme une adresse de multidiffusion.","title":"Messages 'Admin'"},{"location":"CANBUS_protocol.html#message-cmd_query_unassigned","text":"Cette commande interroge tous les microcontr\u00f4leurs pour lesquels aucun canbus_nodeid n'a \u00e9t\u00e9 assign\u00e9. Ces microcontr\u00f4leurs non assign\u00e9s, retournent un message RESP_NEED_NODEID. Le format du message CMD_QUERY_UNASSIGNED est : <1-octet pour le message_id = 0x00>","title":"Message CMD_QUERY_UNASSIGNED"},{"location":"CANBUS_protocol.html#message-cmd_set_klipper_nodeid","text":"Cette commande attribue un canbus_nodeid \u00e0 partir du canbus_uuid du microcontr\u00f4leur. Le format du message CMD_SET_KLIPPER_NODEID est : <1 octet pour le message_id = 0x01><6 octets pour le canbus_uuid><1 octet pour le canbus_nodeid>","title":"Message CMD_SET_KLIPPER_NODEID"},{"location":"CANBUS_protocol.html#message-resp_need_nodeid","text":"Le format du message RESP_NODE_NODEID est : <1 octet pour le message_id = 0x20><6 octets pour le canbus_uuid><1 octet pour le set_klipper_nodeid=0x01>","title":"Message RESP_NEED_NODEID"},{"location":"CANBUS_protocol.html#paquets-de-donnees","text":"Un microcont\u00f4leur ayant re\u00e7u un nodeid par la commande CMD_SET_KLIPPER_NODEID peut envoyer et recevoir des paquets de donn\u00e9es. Les donn\u00e9es des paquets des messages utilisant l'identifiant de r\u00e9ception du bus CAN du n\u0153ud ( canbus_nodeid * 2 + 256 )' sont simplement ajout\u00e9s \u00e0 la fin du tampon et lorsque un mcu protocol message complet est trouv\u00e9 son contenu est analys\u00e9 et trait\u00e9. Les donn\u00e9es sont trait\u00e9es comme un flux d'octets - il n'est pas n\u00e9cessaire que le d\u00e9but d'un bloc de message Klipper soit align\u00e9 avec le d\u00e9but d'un paquet CAN bus. De la m\u00eame mani\u00e8re, les r\u00e9ponses sont renvoy\u00e9es du micrcontr\u00f4leur \u00e0 l'h\u00f4te en copiant les donn\u00e9es du message dans un ou plusieurs paquets avec l'identifiant canbus ( canbus_nodeid * 2 + 256 + 1 ).","title":"Paquets de donn\u00e9es"},{"location":"CONTRIBUTING.html","text":"Contribuer \u00e0 Klipper \u00b6 Merci de contribuer \u00e0 Klipper ! Ce document d\u00e9crit la proc\u00e9dure \u00e0 suivre pour apporter des modifications \u00e0 Klipper. Veuillez consulter la page de contact pour obtenir des informations sur le signalement d'un probl\u00e8me ou pour obtenir des d\u00e9tails sur la mani\u00e8re de contacter les d\u00e9veloppeurs. Aper\u00e7u de la proc\u00e9dure de contribution \u00b6 Les contributions \u00e0 Klipper suivent g\u00e9n\u00e9ralement un processus de haut niveau : Un soumissionnaire commence par cr\u00e9er une GitHub Pull Request lorsqu'une soumission est pr\u00eate \u00e0 \u00eatre d\u00e9ploy\u00e9e \u00e0 grande \u00e9chelle. Lorsqu'un relecteur est disponible pour r\u00e9viser la soumission, il s'attribuera la Pull Request sur GitHub. L'objectif de la r\u00e9vision est de rechercher les d\u00e9fauts et de v\u00e9rifier que la soumission suit les directives document\u00e9es. Apr\u00e8s une r\u00e9vision r\u00e9ussie, le relecteur \"approuve la r\u00e9vision\" sur GitHub et un mainteneur commet la modification dans la branche principale de Klipper. Lorsque vous travaillez sur des am\u00e9liorations, pensez \u00e0 lancer (ou \u00e0 contribuer \u00e0) un sujet sur Klipper Discourse . Une discussion continue sur le forum peut am\u00e9liorer la visibilit\u00e9 du travail de d\u00e9veloppement et peut attirer d'autres personnes int\u00e9ress\u00e9es \u00e0 tester le nouveau travail. A quoi s'attendre lors d'une r\u00e9vision \u00b6 Les contributions \u00e0 Klipper sont examin\u00e9es avant d'\u00eatre fusionn\u00e9es. L'objectif principal du processus de r\u00e9vision est de v\u00e9rifier l'absence de d\u00e9fauts et de s'assurer que la soumission respecte les directives sp\u00e9cifi\u00e9es dans la documentation de Klipper. Il est entendu qu'il existe de nombreuses fa\u00e7ons d'accomplir une t\u00e2che ; l'objectif de la r\u00e9vision n'est pas de discuter de la \"meilleure\" mise en \u0153uvre. Dans la mesure du possible, il est pr\u00e9f\u00e9rable que les discussions de la r\u00e9vision soient ax\u00e9es sur les faits et les mesures. La majorit\u00e9 des soumissions donneront lieu \u00e0 un retour d'information. Soyez pr\u00eat \u00e0 obtenir un retour, \u00e0 fournir des d\u00e9tails suppl\u00e9mentaires et \u00e0 mettre \u00e0 jour la soumission si n\u00e9cessaire. Ce que le relecteur recherche le plus souvent : La soumission est-elle exempte de d\u00e9fauts et est-elle pr\u00eate \u00e0 \u00eatre d\u00e9ploy\u00e9e \u00e0 grande \u00e9chelle ?Les soumissionnaires sont cens\u00e9s tester leurs modifications avant de les soumettre. Les relecteurs recherchent les erreurs, mais ne testent pas, en g\u00e9n\u00e9ral, les soumissions. Une soumission accept\u00e9e est souvent d\u00e9ploy\u00e9e sur des milliers d'imprimantes dans les quelques semaines qui suivent son acceptation. La qualit\u00e9 des soumissions est donc consid\u00e9r\u00e9e comme une priorit\u00e9. Le d\u00e9p\u00f4t GitHub principal de Klipper3d/klipper n'accepte pas les travaux exp\u00e9rimentaux. Les auteurs doivent effectuer les exp\u00e9rimentations, le d\u00e9bogage et les tests dans leurs propres d\u00e9p\u00f4ts. Le serveur Klipper Discourse est un bon endroit pour faire conna\u00eetre les nouveaux travaux et trouver des utilisateurs d\u00e9sireux de fournir des commentaires concrets. Les soumissions doivent r\u00e9ussir tous les tests de r\u00e9gression . Lorsqu'ils corrigent un d\u00e9faut dans le code, les soumissionnaires doivent avoir une compr\u00e9hension g\u00e9n\u00e9rale de la cause fondamentale de ce d\u00e9faut, et la correction doit cibler cette seule cause fondamentale. Les soumissions de code ne doivent pas contenir de code de d\u00e9bogage excessif, d'options de d\u00e9bogage, ni d'enregistrement de d\u00e9bogage \u00e0 l'ex\u00e9cution. Les commentaires dans les soumissions de code doivent se concentrer sur l'am\u00e9lioration de la maintenance du code. Les soumissions ne doivent pas contenir de \"code comment\u00e9\" ni de commentaires excessifs d\u00e9crivant des impl\u00e9mentations pass\u00e9es. Il ne doit pas y avoir de commentaires excessifs de type \"todo\". Les mises \u00e0 jour de la documentation ne doivent pas indiquer qu'il s'agit d'un \"travail en cours\". La demande apporte-t-elle un avantage \"\u00e0 fort impact\" \u00e0 des utilisateurs du monde r\u00e9el effectuant des t\u00e2ches du monde r\u00e9el ?Les relecteurs doivent identifier, au moins dans leur propre esprit, \u00e0 peu pr\u00e8s \"qui est le public cible\", une \u00e9chelle approximative de \"la taille de ce public\", le \"b\u00e9n\u00e9fice\" qu'ils obtiendront, comment le \"b\u00e9n\u00e9fice est mesur\u00e9\", et les \"r\u00e9sultats de ces tests de mesure\". Dans la plupart des cas, ces \u00e9l\u00e9ments sont \u00e9vidents pour l'auteur et l'examinateur, et ne sont pas explicitement mentionn\u00e9s lors d'un examen. Les soumissions \u00e0 la branche principale de Klipper doivent avoir un public cible important. En r\u00e8gle g\u00e9n\u00e9rale, les soumissions doivent cibler une base d'au moins 100 utilisateurs du monde r\u00e9el. Si un relecteur demande des d\u00e9tails sur les \"avantages\" d'une proposition, ne consid\u00e9rez pas cela comme une critique. \u00catre capable de comprendre les avantages concrets d'un changement est une partie naturelle d'un examen. Lorsque l'on discute des avantages, il est pr\u00e9f\u00e9rable de parler de \"faits et de mesures\". En g\u00e9n\u00e9ral, les \u00e9valuateurs ne cherchent pas des r\u00e9ponses du type \"quelqu'un pourrait trouver l'option X utile\", ni des r\u00e9ponses du type \"cette soumission ajoute une fonctionnalit\u00e9 que le micrologiciel X met en \u0153uvre\". Au lieu de cela, il est g\u00e9n\u00e9ralement pr\u00e9f\u00e9rable de discuter des d\u00e9tails sur la fa\u00e7on dont l'am\u00e9lioration de la qualit\u00e9 a \u00e9t\u00e9 mesur\u00e9e et quels \u00e9taient les r\u00e9sultats de ces mesures - par exemple, \"les tests sur les imprimantes Acme X1000 montrent des coins am\u00e9lior\u00e9s comme on le voit sur l'image ...\", ou par exemple \"le temps d'impression de l'objet X du monde r\u00e9el sur une imprimante Foomatic X900 est pass\u00e9 de 4 heures \u00e0 3,5 heures\". Il est entendu que les tests de ce type peuvent prendre beaucoup de temps et d'efforts. Certaines des fonctionnalit\u00e9s les plus remarquables de Klipper ont n\u00e9cessit\u00e9 des mois de discussion, de re-travail, de tests et de documentation avant d'\u00eatre int\u00e9gr\u00e9es dans la branche principale. Tous les nouveaux modules, options de configuration, commandes, param\u00e8tres de commande et documents doivent avoir un \"impact \u00e9lev\u00e9\". Nous ne voulons pas imposer aux utilisateurs des options qu'ils ne peuvent raisonnablement pas configurer, ni des options qui n'apportent aucun avantage notable. Un relecteur peut demander des \u00e9claircissements sur la mani\u00e8re dont un utilisateur doit configurer une option - une r\u00e9ponse id\u00e9ale contiendra des d\u00e9tails sur le processus - par exemple, \"les utilisateurs du MegaX500 doivent r\u00e9gler l'option X sur 99,3 tandis que les utilisateurs du Elite100Y doivent calibrer l'option X en utilisant la proc\u00e9dure ...\". Si le but d'une option est de rendre le code plus modulaire, il est pr\u00e9f\u00e9rable d'utiliser des constantes de code plut\u00f4t que des options de configuration pour l'utilisateur. Les nouveaux modules, les nouvelles options et les nouveaux param\u00e8tres ne doivent pas offrir des fonctionnalit\u00e9s similaires \u00e0 celles des modules existants - si les diff\u00e9rences sont arbitraires, il est pr\u00e9f\u00e9rable d'utiliser le syst\u00e8me existant ou de remanier le code existant. Le droit d'auteur de la soumission est-il clair, non gracieux et compatible ?Les nouveaux fichiers C et Python doivent comporter une d\u00e9claration de copyright sans ambigu\u00eft\u00e9. Voir les fichiers existants pour le format pr\u00e9f\u00e9r\u00e9. Il est d\u00e9conseill\u00e9 de d\u00e9clarer un droit d'auteur sur un fichier existant lorsque l'on apporte des modifications mineures \u00e0 ce fichier. Le code provenant de sources tierces doit \u00eatre compatible avec la licence Klipper (GNU GPLv3). Les ajouts importants de code tiers doivent \u00eatre ajout\u00e9s au r\u00e9pertoire lib/ (et suivre le format d\u00e9crit dans lib/README ). Les soumissionnaires doivent fournir une ligne Signed-off-by en utilisant leur nom r\u00e9el complet. Elle indique que le soumissionnaire est d'accord avec le certificat d'origine du d\u00e9veloppeur . La soumission suit-elle les directives sp\u00e9cifi\u00e9es dans la documentation de Klipper ?En particulier, le code doit suivre les directives de et les fichiers de configuration doivent suivre les directives de . La documentation de Klipper est-elle mise \u00e0 jour pour refl\u00e9ter les nouveaux changements ?Au minimum, la documentation de r\u00e9f\u00e9rence doit \u00eatre mise \u00e0 jour avec les modifications correspondantes du code : Toutes les commandes et tous les param\u00e8tres de commande doivent \u00eatre document\u00e9s dans . Tous les modules destin\u00e9s aux utilisateurs et leurs param\u00e8tres de configuration doivent \u00eatre document\u00e9s dans . Toutes les \"variables d'\u00e9tat\" export\u00e9es doivent \u00eatre document\u00e9es dans . Tous les nouveaux \"webhooks\" et leurs param\u00e8tres doivent \u00eatre document\u00e9s dans . Toute modification qui apporte un changement non r\u00e9trocompatible \u00e0 une commande ou \u00e0 un param\u00e8tre du fichier de configuration doit \u00eatre document\u00e9e dans . Les nouveaux documents doivent \u00eatre ajout\u00e9s \u00e0 et \u00eatre ajout\u00e9s \u00e0 l'index du site web docs/_klipper3d/mkdocs.yml . Les commits sont-ils bien form\u00e9s, abordent-ils un seul sujet par commit, et sont-ils ind\u00e9pendants ?Les messages de validation doivent suivre le format pr\u00e9f\u00e9r\u00e9 . Les commits ne doivent pas avoir de conflit de fusion. Les nouveaux ajouts \u00e0 la branche ma\u00eetresse de Klipper sont toujours effectu\u00e9s via un \"rebase\" ou un \"squash and rebase\". Il n'est g\u00e9n\u00e9ralement pas n\u00e9cessaire pour les soumissionnaires de fusionner \u00e0 nouveau leur soumission \u00e0 chaque mise \u00e0 jour du d\u00e9p\u00f4t ma\u00eetre de Klipper. Cependant, s'il y a un conflit de fusion, il est recommand\u00e9 aux soumissionnaires d'utiliser git rebase pour r\u00e9soudre le conflit. Chaque validation doit porter sur un seul changement de haut niveau. Les changements importants doivent \u00eatre d\u00e9compos\u00e9s en plusieurs commits ind\u00e9pendants. Chaque livraison doit se suffire \u00e0 elle-m\u00eame pour que des outils comme git bisect et git revert fonctionnent de mani\u00e8re fiable. Les modifications des espaces blancs ne doivent pas \u00eatre m\u00e9lang\u00e9es avec les modifications fonctionnelles. En g\u00e9n\u00e9ral, les changements gratuits d'espace blanc ne sont pas accept\u00e9s, sauf s'ils proviennent du \"propri\u00e9taire\" \u00e9tabli du code en cours de modification. Klipper ne met pas en \u0153uvre un \"guide de style de codage\" strict, mais les modifications apport\u00e9es au code existant doivent respecter le flux de code de haut niveau, le style d'indentation du code et le format de ce code existant. Les soumissions de nouveaux modules et syst\u00e8mes b\u00e9n\u00e9ficient d'une plus grande souplesse en mati\u00e8re de style de codage, mais il est pr\u00e9f\u00e9rable que ce nouveau code suive un style coh\u00e9rent en interne et respecte g\u00e9n\u00e9ralement les normes de codage en vigueur dans le secteur. L'objectif d'une r\u00e9vision n'est pas de discuter de \"meilleures mises en \u0153uvre\". Cependant, si un relecteur a du mal \u00e0 comprendre l'impl\u00e9mentation d'une soumission, il peut demander des changements pour rendre l'impl\u00e9mentation plus transparente. En particulier, si les relecteurs ne peuvent pas se convaincre qu'une soumission est exempte de d\u00e9fauts, des changements peuvent \u00eatre n\u00e9cessaires. Dans le cadre d'une r\u00e9vision, un r\u00e9viseur peut cr\u00e9er une Pull Request alternative pour un sujet. Cela peut \u00eatre fait pour \u00e9viter un \"va-et-vient\" excessif sur des \u00e9l\u00e9ments de proc\u00e9dure mineurs et ainsi rationaliser le processus de soumission. Cela peut \u00e9galement \u00eatre fait parce que la discussion inspire un r\u00e9viseur \u00e0 construire une impl\u00e9mentation alternative. Ces deux situations sont le r\u00e9sultat normal d'une r\u00e9vision et ne doivent pas \u00eatre consid\u00e9r\u00e9es comme une critique de la soumission originale. Aider \u00e0 la r\u00e9vision \u00b6 Nous appr\u00e9cions l'aide pour les \u00e9valuations ! Il n'est pas n\u00e9cessaire d'\u00eatre un reviewer list\u00e9 pour effectuer une r\u00e9vision. Les auteurs de Pull Requests GitHub sont \u00e9galement encourag\u00e9s \u00e0 r\u00e9viser leurs propres soumissions. Pour faciliter la r\u00e9vision, suivez les \u00e9tapes d\u00e9crites dans \u00e0 quoi s'attendre lors d'une r\u00e9vision pour v\u00e9rifier la soumission. Une fois la r\u00e9vision termin\u00e9e, ajoutez un commentaire \u00e0 la Pull Request GitHub avec vos conclusions. Si la soumission passe la r\u00e9vision, veuillez l'indiquer explicitement dans le commentaire - par exemple quelque chose comme \"J'ai revu cette modification selon les \u00e9tapes du document CONTRIBUTING et tout me semble correct\". Si vous n'avez pas pu effectuer certaines \u00e9tapes de la r\u00e9vision, veuillez indiquer explicitement quelles \u00e9tapes ont \u00e9t\u00e9 r\u00e9vis\u00e9es et quelles \u00e9tapes ne l'ont pas \u00e9t\u00e9 - par exemple quelque chose comme \"Je n'ai pas v\u00e9rifi\u00e9 les d\u00e9fauts du code, mais j'ai revu tout le reste dans le document CONTRIBUTING et tout semble bon\". Nous appr\u00e9cions \u00e9galement les tests des soumissions. Si le code a \u00e9t\u00e9 test\u00e9, veuillez ajouter un commentaire \u00e0 la Pull Request GitHub avec les r\u00e9sultats de votre test - succ\u00e8s ou \u00e9chec. Veuillez indiquer explicitement que le code a \u00e9t\u00e9 test\u00e9 et les r\u00e9sultats - par exemple quelque chose comme \"J'ai test\u00e9 ce code sur mon imprimante Acme900Z avec une impression de vase et les r\u00e9sultats \u00e9taient bons\". R\u00e9viseurs \u00b6 Les \"r\u00e9viseurs\" de Klipper sont : Nom Id GitHub Domaines d'int\u00e9r\u00eat Dmitry Butyugin @dmbutyugin Input shaping, test de r\u00e9sonance, cin\u00e9matiques Eric Callahan @Arksine Nivellement du lit, flashage du MCU James Hartley @JamesH1978 Fichiers de configuration Kevin O'Connor @KevinOConnor Syst\u00e8me de mouvement de base, code du microcontr\u00f4leur Veuillez ne pas envoyer de \"ping\" \u00e0 l'un des \u00e9valuateurs et ne pas leur adresser de soumissions. Tous les \u00e9valuateurs surveillent les forums et les PR, et prennent en charge les \u00e9valuations quand ils en ont le temps. Les \"mainteneurs\" de Klipper sont : Nom Nom GitHub Kevin O'Connor @KevinOConnor Format des messages de commit \u00b6 Chaque livraison doit avoir un message de livraison format\u00e9 de la mani\u00e8re suivante : module : R\u00e9sum\u00e9 en majuscules, court (50 caract\u00e8res ou moins) Texte explicatif plus d\u00e9taill\u00e9, si n\u00e9cessaire. Limitez-le \u00e0 environ 75 caract\u00e8res ou plus. Dans certains contextes, la premi\u00e8re ligne est consid\u00e9r\u00e9e comme l'objet d'un courriel et le reste du texte comme le corps. sujet d'un message \u00e9lectronique et le reste du texte comme le corps du message. La ligne vierge s\u00e9parant le r\u00e9sum\u00e9 du corps est essentielle (\u00e0 moins que vous n'omettiez enti\u00e8rement le corps). le corps enti\u00e8rement) ; des outils comme rebase peuvent \u00eatre confondus si vous ex\u00e9cutez les les deux ensemble. Les autres paragraphes viennent apr\u00e8s les lignes vides.. Sign\u00e9 par : Mon nom <myemail@example.org> Dans l'exemple ci-dessus, module doit \u00eatre le nom d'un fichier ou d'un r\u00e9pertoire dans le r\u00e9f\u00e9rentiel (sans extension de fichier). Par exemple, clocksync : Corriger une faute de frappe dans l'appel pause() au moment de la connexion . Le but de sp\u00e9cifier un nom de module dans le message de livraison est d'aider \u00e0 fournir un contexte pour les commentaires de livraison. Il est important d'avoir une ligne \"Signed-off-by\" sur chaque commit - elle certifie que vous acceptez le certificat d'origine du d\u00e9veloppeur . Cette ligne doit contenir votre vrai nom (d\u00e9sol\u00e9, pas de pseudonymes ou de contributions anonymes) et une adresse \u00e9lectronique valide. Contribuer aux traductions de Klipper \u00b6 Projet de traduction de Klipper est le projet d\u00e9di\u00e9 \u00e0 la traduction de Klipper dans diff\u00e9rentes langues. Weblate h\u00e9berge toutes les cha\u00eenes Gettext pour la traduction et la r\u00e9vision. Les localisations peuvent \u00eatre affich\u00e9es sur klipper3d.org d\u00e8s lors qu'elles satisfont aux exigences suivantes : 75% Couverture totale Tous les titres (H1) sont traduits Une PR (Pull Request) hi\u00e9rarchis\u00e9e de navigation mise \u00e0 jour dans klipper-translations. Afin de r\u00e9duire la frustration li\u00e9e \u00e0 la traduction de termes sp\u00e9cifiques \u00e0 un domaine et de prendre connaissance des traductions en cours, vous pouvez soumettre une PR modifiant le Projet Klipper-translations readme.md . D\u00e8s qu'une traduction est pr\u00eate, la modification correspondante du projet Klipper peut \u00eatre effectu\u00e9e. Si une traduction existe d\u00e9j\u00e0 dans le r\u00e9f\u00e9rentiel Klipper et ne r\u00e9pond plus \u00e0 la liste de contr\u00f4le ci-dessus, elle sera marqu\u00e9e comme obsol\u00e8te apr\u00e8s un mois sans mise \u00e0 jour. Une fois que les conditions sont remplies, vous devez : mettre \u00e0 jour le fichier active_translations du d\u00e9p\u00f4t de klipper-tranlations Facultatif : ajouter un fichier manual-index.md dans le dossier docs\\locals\\<lang> du d\u00e9p\u00f4t klipper-translations pour remplacer l'index.md sp\u00e9cifique \u00e0 la langue (l'index.md g\u00e9n\u00e9r\u00e9 ne s'affiche pas correctement). Probl\u00e8mes connus : Actuellement, il n'existe pas de m\u00e9thode permettant de traduire correctement les images dans la documentation Il est impossible de traduire les titres dans mkdocs.yml.","title":"Contribuer \u00e0 Klipper"},{"location":"CONTRIBUTING.html#contribuer-a-klipper","text":"Merci de contribuer \u00e0 Klipper ! Ce document d\u00e9crit la proc\u00e9dure \u00e0 suivre pour apporter des modifications \u00e0 Klipper. Veuillez consulter la page de contact pour obtenir des informations sur le signalement d'un probl\u00e8me ou pour obtenir des d\u00e9tails sur la mani\u00e8re de contacter les d\u00e9veloppeurs.","title":"Contribuer \u00e0 Klipper"},{"location":"CONTRIBUTING.html#apercu-de-la-procedure-de-contribution","text":"Les contributions \u00e0 Klipper suivent g\u00e9n\u00e9ralement un processus de haut niveau : Un soumissionnaire commence par cr\u00e9er une GitHub Pull Request lorsqu'une soumission est pr\u00eate \u00e0 \u00eatre d\u00e9ploy\u00e9e \u00e0 grande \u00e9chelle. Lorsqu'un relecteur est disponible pour r\u00e9viser la soumission, il s'attribuera la Pull Request sur GitHub. L'objectif de la r\u00e9vision est de rechercher les d\u00e9fauts et de v\u00e9rifier que la soumission suit les directives document\u00e9es. Apr\u00e8s une r\u00e9vision r\u00e9ussie, le relecteur \"approuve la r\u00e9vision\" sur GitHub et un mainteneur commet la modification dans la branche principale de Klipper. Lorsque vous travaillez sur des am\u00e9liorations, pensez \u00e0 lancer (ou \u00e0 contribuer \u00e0) un sujet sur Klipper Discourse . Une discussion continue sur le forum peut am\u00e9liorer la visibilit\u00e9 du travail de d\u00e9veloppement et peut attirer d'autres personnes int\u00e9ress\u00e9es \u00e0 tester le nouveau travail.","title":"Aper\u00e7u de la proc\u00e9dure de contribution"},{"location":"CONTRIBUTING.html#a-quoi-sattendre-lors-dune-revision","text":"Les contributions \u00e0 Klipper sont examin\u00e9es avant d'\u00eatre fusionn\u00e9es. L'objectif principal du processus de r\u00e9vision est de v\u00e9rifier l'absence de d\u00e9fauts et de s'assurer que la soumission respecte les directives sp\u00e9cifi\u00e9es dans la documentation de Klipper. Il est entendu qu'il existe de nombreuses fa\u00e7ons d'accomplir une t\u00e2che ; l'objectif de la r\u00e9vision n'est pas de discuter de la \"meilleure\" mise en \u0153uvre. Dans la mesure du possible, il est pr\u00e9f\u00e9rable que les discussions de la r\u00e9vision soient ax\u00e9es sur les faits et les mesures. La majorit\u00e9 des soumissions donneront lieu \u00e0 un retour d'information. Soyez pr\u00eat \u00e0 obtenir un retour, \u00e0 fournir des d\u00e9tails suppl\u00e9mentaires et \u00e0 mettre \u00e0 jour la soumission si n\u00e9cessaire. Ce que le relecteur recherche le plus souvent : La soumission est-elle exempte de d\u00e9fauts et est-elle pr\u00eate \u00e0 \u00eatre d\u00e9ploy\u00e9e \u00e0 grande \u00e9chelle ?Les soumissionnaires sont cens\u00e9s tester leurs modifications avant de les soumettre. Les relecteurs recherchent les erreurs, mais ne testent pas, en g\u00e9n\u00e9ral, les soumissions. Une soumission accept\u00e9e est souvent d\u00e9ploy\u00e9e sur des milliers d'imprimantes dans les quelques semaines qui suivent son acceptation. La qualit\u00e9 des soumissions est donc consid\u00e9r\u00e9e comme une priorit\u00e9. Le d\u00e9p\u00f4t GitHub principal de Klipper3d/klipper n'accepte pas les travaux exp\u00e9rimentaux. Les auteurs doivent effectuer les exp\u00e9rimentations, le d\u00e9bogage et les tests dans leurs propres d\u00e9p\u00f4ts. Le serveur Klipper Discourse est un bon endroit pour faire conna\u00eetre les nouveaux travaux et trouver des utilisateurs d\u00e9sireux de fournir des commentaires concrets. Les soumissions doivent r\u00e9ussir tous les tests de r\u00e9gression . Lorsqu'ils corrigent un d\u00e9faut dans le code, les soumissionnaires doivent avoir une compr\u00e9hension g\u00e9n\u00e9rale de la cause fondamentale de ce d\u00e9faut, et la correction doit cibler cette seule cause fondamentale. Les soumissions de code ne doivent pas contenir de code de d\u00e9bogage excessif, d'options de d\u00e9bogage, ni d'enregistrement de d\u00e9bogage \u00e0 l'ex\u00e9cution. Les commentaires dans les soumissions de code doivent se concentrer sur l'am\u00e9lioration de la maintenance du code. Les soumissions ne doivent pas contenir de \"code comment\u00e9\" ni de commentaires excessifs d\u00e9crivant des impl\u00e9mentations pass\u00e9es. Il ne doit pas y avoir de commentaires excessifs de type \"todo\". Les mises \u00e0 jour de la documentation ne doivent pas indiquer qu'il s'agit d'un \"travail en cours\". La demande apporte-t-elle un avantage \"\u00e0 fort impact\" \u00e0 des utilisateurs du monde r\u00e9el effectuant des t\u00e2ches du monde r\u00e9el ?Les relecteurs doivent identifier, au moins dans leur propre esprit, \u00e0 peu pr\u00e8s \"qui est le public cible\", une \u00e9chelle approximative de \"la taille de ce public\", le \"b\u00e9n\u00e9fice\" qu'ils obtiendront, comment le \"b\u00e9n\u00e9fice est mesur\u00e9\", et les \"r\u00e9sultats de ces tests de mesure\". Dans la plupart des cas, ces \u00e9l\u00e9ments sont \u00e9vidents pour l'auteur et l'examinateur, et ne sont pas explicitement mentionn\u00e9s lors d'un examen. Les soumissions \u00e0 la branche principale de Klipper doivent avoir un public cible important. En r\u00e8gle g\u00e9n\u00e9rale, les soumissions doivent cibler une base d'au moins 100 utilisateurs du monde r\u00e9el. Si un relecteur demande des d\u00e9tails sur les \"avantages\" d'une proposition, ne consid\u00e9rez pas cela comme une critique. \u00catre capable de comprendre les avantages concrets d'un changement est une partie naturelle d'un examen. Lorsque l'on discute des avantages, il est pr\u00e9f\u00e9rable de parler de \"faits et de mesures\". En g\u00e9n\u00e9ral, les \u00e9valuateurs ne cherchent pas des r\u00e9ponses du type \"quelqu'un pourrait trouver l'option X utile\", ni des r\u00e9ponses du type \"cette soumission ajoute une fonctionnalit\u00e9 que le micrologiciel X met en \u0153uvre\". Au lieu de cela, il est g\u00e9n\u00e9ralement pr\u00e9f\u00e9rable de discuter des d\u00e9tails sur la fa\u00e7on dont l'am\u00e9lioration de la qualit\u00e9 a \u00e9t\u00e9 mesur\u00e9e et quels \u00e9taient les r\u00e9sultats de ces mesures - par exemple, \"les tests sur les imprimantes Acme X1000 montrent des coins am\u00e9lior\u00e9s comme on le voit sur l'image ...\", ou par exemple \"le temps d'impression de l'objet X du monde r\u00e9el sur une imprimante Foomatic X900 est pass\u00e9 de 4 heures \u00e0 3,5 heures\". Il est entendu que les tests de ce type peuvent prendre beaucoup de temps et d'efforts. Certaines des fonctionnalit\u00e9s les plus remarquables de Klipper ont n\u00e9cessit\u00e9 des mois de discussion, de re-travail, de tests et de documentation avant d'\u00eatre int\u00e9gr\u00e9es dans la branche principale. Tous les nouveaux modules, options de configuration, commandes, param\u00e8tres de commande et documents doivent avoir un \"impact \u00e9lev\u00e9\". Nous ne voulons pas imposer aux utilisateurs des options qu'ils ne peuvent raisonnablement pas configurer, ni des options qui n'apportent aucun avantage notable. Un relecteur peut demander des \u00e9claircissements sur la mani\u00e8re dont un utilisateur doit configurer une option - une r\u00e9ponse id\u00e9ale contiendra des d\u00e9tails sur le processus - par exemple, \"les utilisateurs du MegaX500 doivent r\u00e9gler l'option X sur 99,3 tandis que les utilisateurs du Elite100Y doivent calibrer l'option X en utilisant la proc\u00e9dure ...\". Si le but d'une option est de rendre le code plus modulaire, il est pr\u00e9f\u00e9rable d'utiliser des constantes de code plut\u00f4t que des options de configuration pour l'utilisateur. Les nouveaux modules, les nouvelles options et les nouveaux param\u00e8tres ne doivent pas offrir des fonctionnalit\u00e9s similaires \u00e0 celles des modules existants - si les diff\u00e9rences sont arbitraires, il est pr\u00e9f\u00e9rable d'utiliser le syst\u00e8me existant ou de remanier le code existant. Le droit d'auteur de la soumission est-il clair, non gracieux et compatible ?Les nouveaux fichiers C et Python doivent comporter une d\u00e9claration de copyright sans ambigu\u00eft\u00e9. Voir les fichiers existants pour le format pr\u00e9f\u00e9r\u00e9. Il est d\u00e9conseill\u00e9 de d\u00e9clarer un droit d'auteur sur un fichier existant lorsque l'on apporte des modifications mineures \u00e0 ce fichier. Le code provenant de sources tierces doit \u00eatre compatible avec la licence Klipper (GNU GPLv3). Les ajouts importants de code tiers doivent \u00eatre ajout\u00e9s au r\u00e9pertoire lib/ (et suivre le format d\u00e9crit dans lib/README ). Les soumissionnaires doivent fournir une ligne Signed-off-by en utilisant leur nom r\u00e9el complet. Elle indique que le soumissionnaire est d'accord avec le certificat d'origine du d\u00e9veloppeur . La soumission suit-elle les directives sp\u00e9cifi\u00e9es dans la documentation de Klipper ?En particulier, le code doit suivre les directives de et les fichiers de configuration doivent suivre les directives de . La documentation de Klipper est-elle mise \u00e0 jour pour refl\u00e9ter les nouveaux changements ?Au minimum, la documentation de r\u00e9f\u00e9rence doit \u00eatre mise \u00e0 jour avec les modifications correspondantes du code : Toutes les commandes et tous les param\u00e8tres de commande doivent \u00eatre document\u00e9s dans . Tous les modules destin\u00e9s aux utilisateurs et leurs param\u00e8tres de configuration doivent \u00eatre document\u00e9s dans . Toutes les \"variables d'\u00e9tat\" export\u00e9es doivent \u00eatre document\u00e9es dans . Tous les nouveaux \"webhooks\" et leurs param\u00e8tres doivent \u00eatre document\u00e9s dans . Toute modification qui apporte un changement non r\u00e9trocompatible \u00e0 une commande ou \u00e0 un param\u00e8tre du fichier de configuration doit \u00eatre document\u00e9e dans . Les nouveaux documents doivent \u00eatre ajout\u00e9s \u00e0 et \u00eatre ajout\u00e9s \u00e0 l'index du site web docs/_klipper3d/mkdocs.yml . Les commits sont-ils bien form\u00e9s, abordent-ils un seul sujet par commit, et sont-ils ind\u00e9pendants ?Les messages de validation doivent suivre le format pr\u00e9f\u00e9r\u00e9 . Les commits ne doivent pas avoir de conflit de fusion. Les nouveaux ajouts \u00e0 la branche ma\u00eetresse de Klipper sont toujours effectu\u00e9s via un \"rebase\" ou un \"squash and rebase\". Il n'est g\u00e9n\u00e9ralement pas n\u00e9cessaire pour les soumissionnaires de fusionner \u00e0 nouveau leur soumission \u00e0 chaque mise \u00e0 jour du d\u00e9p\u00f4t ma\u00eetre de Klipper. Cependant, s'il y a un conflit de fusion, il est recommand\u00e9 aux soumissionnaires d'utiliser git rebase pour r\u00e9soudre le conflit. Chaque validation doit porter sur un seul changement de haut niveau. Les changements importants doivent \u00eatre d\u00e9compos\u00e9s en plusieurs commits ind\u00e9pendants. Chaque livraison doit se suffire \u00e0 elle-m\u00eame pour que des outils comme git bisect et git revert fonctionnent de mani\u00e8re fiable. Les modifications des espaces blancs ne doivent pas \u00eatre m\u00e9lang\u00e9es avec les modifications fonctionnelles. En g\u00e9n\u00e9ral, les changements gratuits d'espace blanc ne sont pas accept\u00e9s, sauf s'ils proviennent du \"propri\u00e9taire\" \u00e9tabli du code en cours de modification. Klipper ne met pas en \u0153uvre un \"guide de style de codage\" strict, mais les modifications apport\u00e9es au code existant doivent respecter le flux de code de haut niveau, le style d'indentation du code et le format de ce code existant. Les soumissions de nouveaux modules et syst\u00e8mes b\u00e9n\u00e9ficient d'une plus grande souplesse en mati\u00e8re de style de codage, mais il est pr\u00e9f\u00e9rable que ce nouveau code suive un style coh\u00e9rent en interne et respecte g\u00e9n\u00e9ralement les normes de codage en vigueur dans le secteur. L'objectif d'une r\u00e9vision n'est pas de discuter de \"meilleures mises en \u0153uvre\". Cependant, si un relecteur a du mal \u00e0 comprendre l'impl\u00e9mentation d'une soumission, il peut demander des changements pour rendre l'impl\u00e9mentation plus transparente. En particulier, si les relecteurs ne peuvent pas se convaincre qu'une soumission est exempte de d\u00e9fauts, des changements peuvent \u00eatre n\u00e9cessaires. Dans le cadre d'une r\u00e9vision, un r\u00e9viseur peut cr\u00e9er une Pull Request alternative pour un sujet. Cela peut \u00eatre fait pour \u00e9viter un \"va-et-vient\" excessif sur des \u00e9l\u00e9ments de proc\u00e9dure mineurs et ainsi rationaliser le processus de soumission. Cela peut \u00e9galement \u00eatre fait parce que la discussion inspire un r\u00e9viseur \u00e0 construire une impl\u00e9mentation alternative. Ces deux situations sont le r\u00e9sultat normal d'une r\u00e9vision et ne doivent pas \u00eatre consid\u00e9r\u00e9es comme une critique de la soumission originale.","title":"A quoi s'attendre lors d'une r\u00e9vision"},{"location":"CONTRIBUTING.html#aider-a-la-revision","text":"Nous appr\u00e9cions l'aide pour les \u00e9valuations ! Il n'est pas n\u00e9cessaire d'\u00eatre un reviewer list\u00e9 pour effectuer une r\u00e9vision. Les auteurs de Pull Requests GitHub sont \u00e9galement encourag\u00e9s \u00e0 r\u00e9viser leurs propres soumissions. Pour faciliter la r\u00e9vision, suivez les \u00e9tapes d\u00e9crites dans \u00e0 quoi s'attendre lors d'une r\u00e9vision pour v\u00e9rifier la soumission. Une fois la r\u00e9vision termin\u00e9e, ajoutez un commentaire \u00e0 la Pull Request GitHub avec vos conclusions. Si la soumission passe la r\u00e9vision, veuillez l'indiquer explicitement dans le commentaire - par exemple quelque chose comme \"J'ai revu cette modification selon les \u00e9tapes du document CONTRIBUTING et tout me semble correct\". Si vous n'avez pas pu effectuer certaines \u00e9tapes de la r\u00e9vision, veuillez indiquer explicitement quelles \u00e9tapes ont \u00e9t\u00e9 r\u00e9vis\u00e9es et quelles \u00e9tapes ne l'ont pas \u00e9t\u00e9 - par exemple quelque chose comme \"Je n'ai pas v\u00e9rifi\u00e9 les d\u00e9fauts du code, mais j'ai revu tout le reste dans le document CONTRIBUTING et tout semble bon\". Nous appr\u00e9cions \u00e9galement les tests des soumissions. Si le code a \u00e9t\u00e9 test\u00e9, veuillez ajouter un commentaire \u00e0 la Pull Request GitHub avec les r\u00e9sultats de votre test - succ\u00e8s ou \u00e9chec. Veuillez indiquer explicitement que le code a \u00e9t\u00e9 test\u00e9 et les r\u00e9sultats - par exemple quelque chose comme \"J'ai test\u00e9 ce code sur mon imprimante Acme900Z avec une impression de vase et les r\u00e9sultats \u00e9taient bons\".","title":"Aider \u00e0 la r\u00e9vision"},{"location":"CONTRIBUTING.html#reviseurs","text":"Les \"r\u00e9viseurs\" de Klipper sont : Nom Id GitHub Domaines d'int\u00e9r\u00eat Dmitry Butyugin @dmbutyugin Input shaping, test de r\u00e9sonance, cin\u00e9matiques Eric Callahan @Arksine Nivellement du lit, flashage du MCU James Hartley @JamesH1978 Fichiers de configuration Kevin O'Connor @KevinOConnor Syst\u00e8me de mouvement de base, code du microcontr\u00f4leur Veuillez ne pas envoyer de \"ping\" \u00e0 l'un des \u00e9valuateurs et ne pas leur adresser de soumissions. Tous les \u00e9valuateurs surveillent les forums et les PR, et prennent en charge les \u00e9valuations quand ils en ont le temps. Les \"mainteneurs\" de Klipper sont : Nom Nom GitHub Kevin O'Connor @KevinOConnor","title":"R\u00e9viseurs"},{"location":"CONTRIBUTING.html#format-des-messages-de-commit","text":"Chaque livraison doit avoir un message de livraison format\u00e9 de la mani\u00e8re suivante : module : R\u00e9sum\u00e9 en majuscules, court (50 caract\u00e8res ou moins) Texte explicatif plus d\u00e9taill\u00e9, si n\u00e9cessaire. Limitez-le \u00e0 environ 75 caract\u00e8res ou plus. Dans certains contextes, la premi\u00e8re ligne est consid\u00e9r\u00e9e comme l'objet d'un courriel et le reste du texte comme le corps. sujet d'un message \u00e9lectronique et le reste du texte comme le corps du message. La ligne vierge s\u00e9parant le r\u00e9sum\u00e9 du corps est essentielle (\u00e0 moins que vous n'omettiez enti\u00e8rement le corps). le corps enti\u00e8rement) ; des outils comme rebase peuvent \u00eatre confondus si vous ex\u00e9cutez les les deux ensemble. Les autres paragraphes viennent apr\u00e8s les lignes vides.. Sign\u00e9 par : Mon nom <myemail@example.org> Dans l'exemple ci-dessus, module doit \u00eatre le nom d'un fichier ou d'un r\u00e9pertoire dans le r\u00e9f\u00e9rentiel (sans extension de fichier). Par exemple, clocksync : Corriger une faute de frappe dans l'appel pause() au moment de la connexion . Le but de sp\u00e9cifier un nom de module dans le message de livraison est d'aider \u00e0 fournir un contexte pour les commentaires de livraison. Il est important d'avoir une ligne \"Signed-off-by\" sur chaque commit - elle certifie que vous acceptez le certificat d'origine du d\u00e9veloppeur . Cette ligne doit contenir votre vrai nom (d\u00e9sol\u00e9, pas de pseudonymes ou de contributions anonymes) et une adresse \u00e9lectronique valide.","title":"Format des messages de commit"},{"location":"CONTRIBUTING.html#contribuer-aux-traductions-de-klipper","text":"Projet de traduction de Klipper est le projet d\u00e9di\u00e9 \u00e0 la traduction de Klipper dans diff\u00e9rentes langues. Weblate h\u00e9berge toutes les cha\u00eenes Gettext pour la traduction et la r\u00e9vision. Les localisations peuvent \u00eatre affich\u00e9es sur klipper3d.org d\u00e8s lors qu'elles satisfont aux exigences suivantes : 75% Couverture totale Tous les titres (H1) sont traduits Une PR (Pull Request) hi\u00e9rarchis\u00e9e de navigation mise \u00e0 jour dans klipper-translations. Afin de r\u00e9duire la frustration li\u00e9e \u00e0 la traduction de termes sp\u00e9cifiques \u00e0 un domaine et de prendre connaissance des traductions en cours, vous pouvez soumettre une PR modifiant le Projet Klipper-translations readme.md . D\u00e8s qu'une traduction est pr\u00eate, la modification correspondante du projet Klipper peut \u00eatre effectu\u00e9e. Si une traduction existe d\u00e9j\u00e0 dans le r\u00e9f\u00e9rentiel Klipper et ne r\u00e9pond plus \u00e0 la liste de contr\u00f4le ci-dessus, elle sera marqu\u00e9e comme obsol\u00e8te apr\u00e8s un mois sans mise \u00e0 jour. Une fois que les conditions sont remplies, vous devez : mettre \u00e0 jour le fichier active_translations du d\u00e9p\u00f4t de klipper-tranlations Facultatif : ajouter un fichier manual-index.md dans le dossier docs\\locals\\<lang> du d\u00e9p\u00f4t klipper-translations pour remplacer l'index.md sp\u00e9cifique \u00e0 la langue (l'index.md g\u00e9n\u00e9r\u00e9 ne s'affiche pas correctement). Probl\u00e8mes connus : Actuellement, il n'existe pas de m\u00e9thode permettant de traduire correctement les images dans la documentation Il est impossible de traduire les titres dans mkdocs.yml.","title":"Contribuer aux traductions de Klipper"},{"location":"Code_Overview.html","text":"Aper\u00e7u du code \u00b6 Ce document d\u00e9crit la disposition g\u00e9n\u00e9rale du code et le flux de code principal de Klipper. Disposition du r\u00e9pertoire \u00b6 Le r\u00e9pertoire src/ contient les sources C du code du micro-contr\u00f4leur. Les r\u00e9pertoires src/atsam/ , src/atsamd/ , src/avr/ , src/linux/ , src/lpc176x/ , src/pru/ , et src/stm32/ contiennent le code du micro-contr\u00f4leur sp\u00e9cifique \u00e0 chaque architecture. Le r\u00e9pertoire src/simulator/ contient des \u00e9l\u00e9ments de remplacement de code permettant de tester la compilation du micro-contr\u00f4leur sur d'autres architectures. Le r\u00e9pertoire src/generic/ contient du code d'assistance utile sur diff\u00e9rentes architectures. La compilation fait en sorte que les inclusions de \"board/somefile.h\" soient d'abord recherch\u00e9es dans le r\u00e9pertoire de l'architecture courante (par exemple, src/avr/somefile.h) et ensuite dans le r\u00e9pertoire g\u00e9n\u00e9rique (par exemple, src/generic/somefile.h). Le r\u00e9pertoire klippy/ contient le logiciel h\u00f4te. La majorit\u00e9 du logiciel h\u00f4te est \u00e9crit en Python, cependant le r\u00e9pertoire klippy/chelper/ contient quelques assistants en code C. Le r\u00e9pertoire klippy/kinematics/ contient le code li\u00e9 \u00e0 la cin\u00e9matique du robot. Le r\u00e9pertoire klippy/extras/ contient les \"modules\" extensibles du code h\u00f4te. Le r\u00e9pertoire lib/ contient du code de biblioth\u00e8que externe de tierce partie n\u00e9cessaire \u00e0 la construction de certaines cibles. Le r\u00e9pertoire config/ contient des exemples de fichiers de configuration d'imprimante. Le r\u00e9pertoire scripts/ contient des scripts de construction utiles \u00e0 la compilation du code du micro-contr\u00f4leur. Le r\u00e9pertoire test/ contient des cas de tests automatis\u00e9s. Pendant la compilation, le constructeur peut cr\u00e9er un r\u00e9pertoire out/ . Celui-ci contient des objets temporaires de compilation. L'objet micro-contr\u00f4leur final qui est construit est out/klipper.elf.hex sur AVR et out/klipper.bin sur ARM. Flux de code du micro-contr\u00f4leur \u00b6 L'ex\u00e9cution du code du microcontr\u00f4leur d\u00e9bute dans le code sp\u00e9cifique \u00e0 l'architecture (par exemple, src/avr/main.c ) qui appelle finalement sched_main() situ\u00e9 dans src/sched.c . Le code sched_main() commence par ex\u00e9cuter toutes les fonctions marqu\u00e9es avec la macro DECL_INIT(). Il ex\u00e9cute ensuite de mani\u00e8re r\u00e9p\u00e9t\u00e9e toutes les fonctions marqu\u00e9es par la macro DECL_TASK(). L'une des principales fonctions de la t\u00e2che est command_dispatch() situ\u00e9e dans src/command.c . Cette fonction est appel\u00e9e \u00e0 partir du code d'entr\u00e9e/sortie sp\u00e9cifique \u00e0 la carte (par exemple, src/avr/serial.c , src/generic/serial_irq.c ) et elle ex\u00e9cute les fonctions de commande associ\u00e9es aux commandes trouv\u00e9es dans le flux d'entr\u00e9e. Les fonctions de commande sont d\u00e9clar\u00e9es \u00e0 l'aide de la macro DECL_COMMAND() (voir le document protocole pour plus d'informations). Les fonctions de t\u00e2che, d'initialisation et de commande s'ex\u00e9cutent toujours avec les interruptions activ\u00e9es (toutefois, elles peuvent d\u00e9sactiver temporairement les interruptions si n\u00e9cessaire). Ces fonctions doivent \u00e9viter les longues pauses, les retards, ou effectuer un travail qui dure un temps significatif. (Les longs retards de ces fonctions \"t\u00e2ches\" entra\u00eenent une gigue de programmation pour d'autres \"t\u00e2ches\" - les retards de plus de 100us peuvent devenir perceptibles, les retards de plus de 500us peuvent entra\u00eener des retransmissions de commandes, les retards de plus de 100ms peuvent entra\u00eener des red\u00e9marrages du chien de garde). Ces fonctions planifient le travail \u00e0 des moments pr\u00e9cis en programmant des minuteries. Les fonctions de temporisation sont programm\u00e9es en appelant sched_add_timer() (situ\u00e9 dans src/sched.c ). Le code du planificateur s'arrangera pour que la fonction donn\u00e9e soit appel\u00e9e au moment demand\u00e9. Les interruptions de temporisation sont initialement trait\u00e9es dans un gestionnaire d'interruption sp\u00e9cifique \u00e0 l'architecture (par exemple, src/avr/timer.c ) qui appelle sched_timer_dispatch() situ\u00e9 dans src/sched.c . L'interruption de la temporisation entra\u00eene l'ex\u00e9cution des fonctions de temporisation planifi\u00e9es. Les fonctions de temporisation sont toujours ex\u00e9cut\u00e9es avec des interruptions d\u00e9sactiv\u00e9es. Les fonctions de temporisation devraient toujours se terminer en quelques microsecondes. \u00c0 la fin de l'\u00e9v\u00e9nement de temporisation, la fonction peut choisir de se reprogrammer. En cas de d\u00e9tection d'erreur, le code peut invoquer shutdown() (une macro qui appelle sched_shutdown() situ\u00e9e dans src/sched.c ). L'appel \u00e0 shutdown() entra\u00eene l'ex\u00e9cution de toutes les fonctions marqu\u00e9es par la macro DECL_SHUTDOWN(). Les fonctions d'arr\u00eat s'ex\u00e9cutent toujours avec des interruptions d\u00e9sactiv\u00e9es. Une grande partie des fonctionnalit\u00e9s du micro-contr\u00f4leur implique de travailler avec des broches d'entr\u00e9e/sortie \u00e0 usage g\u00e9n\u00e9ral (GPIO). Afin de s\u00e9parer le code de bas niveau sp\u00e9cifique \u00e0 l'architecture du code de haut niveau de la t\u00e2che, tous les \u00e9v\u00e9nements GPIO sont impl\u00e9ment\u00e9s dans des emballages sp\u00e9cifiques \u00e0 l'architecture (par exemple, src/avr/gpio.c ). Le code est compil\u00e9 avec l'optimisation \"-flto -fwhole-program\" de gcc qui fait un excellent travail d'int\u00e9gration des fonctions \u00e0 travers les unit\u00e9s de compilation, ainsi la plupart de ces minuscules fonctions gpio sont int\u00e9gr\u00e9es \u00e0 leurs appelants, et il n'y a aucun co\u00fbt d'ex\u00e9cution \u00e0 les utiliser. Aper\u00e7u du code Klippy \u00b6 Le code h\u00f4te (Klippy) est destin\u00e9 \u00e0 fonctionner sur un ordinateur \u00e0 petit prix (tel qu'un Raspberry Pi) associ\u00e9 au microcontr\u00f4leur. Le code est principalement \u00e9crit en Python, cependant il utilise CFFI pour impl\u00e9menter certaines fonctionnalit\u00e9s en code C. L'ex\u00e9cution initiale commence dans klippy/klippy.py . Ceci lit les arguments de la ligne de commande, ouvre le fichier de configuration de l'imprimante, instancie les principaux objets de l'imprimante et lance la connexion s\u00e9rie. L'ex\u00e9cution principale des commandes G-code se fait dans la m\u00e9thode process_commands() de klippy/gcode.py . Ce code traduit les commandes G-code en appels d'objets d'imprimante fr\u00e9quemment traduis en commandes d'actions \u00e0 ex\u00e9cuter sur le micro-contr\u00f4leur (tel que d\u00e9clar\u00e9 via la macro DECL_COMMAND dans le code du micro-contr\u00f4leur). Il y a quatre threads dans le code h\u00f4te de Klippy. Le thread principal g\u00e8re les commandes gcode entrantes. Un deuxi\u00e8me thread (r\u00e9sidant enti\u00e8rement dans le code C klippy/chelper/serialqueue.c ) g\u00e8re les entr\u00e9es/sorties de bas niveau avec le port s\u00e9rie. Le troisi\u00e8me thread est utilis\u00e9 pour traiter les messages de r\u00e9ponse du micro-contr\u00f4leur dans le code Python (voir klippy/serialhdl.py ). Le quatri\u00e8me thread \u00e9crit les messages de d\u00e9bogage dans le journal (voir klippy/queuelogger.py ) afin que les autres threads ne bloquent jamais les \u00e9critures dans le journal. Flux du code d'une commande de d\u00e9placement \u00b6 Un mouvement typique de l'imprimante commence lorsqu'une commande \"G1\" est envoy\u00e9e \u00e0 l'h\u00f4te Klippy et se termine lorsque les impulsions de pas correspondantes sont produites sur le micro-contr\u00f4leur. Cette section d\u00e9crit le flux du code d'une commande de d\u00e9placement typique. Le document cin\u00e9matiques fournit des informations suppl\u00e9mentaires sur la m\u00e9canique des mouvements. Le traitement d'une commande de d\u00e9placement commence dans gcode.py. Le but de gcode.py est de traduire le G-code en appels internes. Une commande G1 invoquera cmd_G1() dans klippy/extras/gcode_move.py. Le code gcode_move.py g\u00e8re les changements d'origine (par exemple, G92), les changements de positions relatives et absolues (par exemple, G90), et les changements d'unit\u00e9s (par exemple, F6000=100mm/s). Le chemin du code pour un d\u00e9placement est : _process_data() -> _process_commands() -> cmd_G1() . Finalement, la classe ToolHead est invoqu\u00e9e pour ex\u00e9cuter la demande r\u00e9elle : cmd_G1() -> ToolHead.move() La classe ToolHead (dans toolhead.py) g\u00e8re le \"look-ahead\" et suit la temporisation des actions d'impression. Le chemin du code principal pour un d\u00e9placement est : ToolHead.move() -> MoveQueue.add_move() -> MoveQueue.flush() -> Move.set_junction() -> ToolHead._process_moves() . ToolHead.move() cr\u00e9e un objet Move() avec les param\u00e8tres du d\u00e9placement (dans l'espace cart\u00e9sien et en unit\u00e9s de secondes et de millim\u00e8tres). La classe cin\u00e9matique a la possibilit\u00e9 de v\u00e9rifier chaque mouvement ( ToolHead.move() -> kin.check_move() ). Les classes cin\u00e9matiques sont situ\u00e9es dans le r\u00e9pertoire klippy/kinematics/. Le code check_move() peut lever une erreur si le d\u00e9placement n'est pas valide. Si check_move() se termine avec succ\u00e8s, alors la cin\u00e9matique sous-jacente doit \u00eatre capable de g\u00e9rer le d\u00e9placement. MoveQueue.add_move() place l'objet move dans la file d'attente \"look-ahead\". MoveQueue.flush() d\u00e9termine les vitesses de d\u00e9but et de fin de chaque mouvement. Move.set_junction() impl\u00e9mente le \"g\u00e9n\u00e9rateur de trap\u00e8ze\" sur un mouvement. Le \"g\u00e9n\u00e9rateur de trap\u00e8ze\" divise chaque mouvement en trois parties : une phase d'acc\u00e9l\u00e9ration constante, suivie d'une phase de vitesse constante, puis d'une phase de d\u00e9c\u00e9l\u00e9ration constante. Chaque d\u00e9placement contient ces trois phases dans cet ordre, certaines phases pouvant \u00eatre de dur\u00e9e nulle. Lorsque ToolHead._process_moves() est appel\u00e9, tout ce qui concerne le d\u00e9placement est connu : sa position de d\u00e9part, sa position d'arriv\u00e9e, son acc\u00e9l\u00e9ration, sa vitesse de d\u00e9part/de croisi\u00e8re/de fin, et la distance parcourue pendant l'acc\u00e9l\u00e9ration/la croisi\u00e8re/la d\u00e9c\u00e9l\u00e9ration. Toutes ces informations sont stock\u00e9es dans la classe Move() et sont dans l'espace cart\u00e9sien en unit\u00e9s de millim\u00e8tres et de secondes. Klipper utilise un solveur it\u00e9ratif afin de g\u00e9n\u00e9rer les d\u00e9lais des pas pour chaque moteur pas \u00e0 pas. Pour des raisons d'efficacit\u00e9, les d\u00e9lais d'impulsion des pas sont g\u00e9n\u00e9r\u00e9s en code C. Les mouvements sont d'abord plac\u00e9s dans une \"file d'attente de mouvements trap\u00e9zo\u00efdaux\" : ToolHead._process_moves() -> trapq_append() (dans klippy/chelper/trapq.c). Les d\u00e9lais de pas sont ensuite g\u00e9n\u00e9r\u00e9s : ToolHead._process_moves() -> ToolHead._update_move_time() -> MCU_Stepper.generate_steps() -> itersolve_generate_steps() -> itersolve_gen_steps_range() (dans klippy/chelper/itersolve.c). Le but du solveur it\u00e9ratif est de trouver les d\u00e9lais de pas \u00e0 partir d'une fonction calculant la position du moteur \u00e0 partir du temps. Ceci est fait en \"devinant\" de mani\u00e8re r\u00e9p\u00e9t\u00e9e plusieurs d\u00e9lais jusqu'\u00e0 ce que la formule de position du pas renvoie la position d\u00e9sir\u00e9e du pas suivant sur le moteur. Le retour d'information produit par chaque estimation est utilis\u00e9 afin d'am\u00e9liorer les estimations futures, de sorte que le processus converge rapidement vers le d\u00e9lai souhait\u00e9. Les formules de position cin\u00e9matique du moteur sont situ\u00e9es dans le r\u00e9pertoire klippy/chelper/ (par exemple, kin_cart.c, kin_corexy.c, kin_delta.c, kin_extruder.c). Notez que l'extrudeuse est g\u00e9r\u00e9e dans sa propre classe cin\u00e9matique : ToolHead._process_moves() -> PrinterExtruder.move() . Puisque la classe Move() sp\u00e9cifie le d\u00e9lai exact du mouvement et que les impulsions de pas sont envoy\u00e9es au micro-contr\u00f4leur avec un timing sp\u00e9cifique, les mouvements du moteur produits par la classe de l'extrudeuse seront synchronis\u00e9s avec le mouvement de la t\u00eate m\u00eame si le code est s\u00e9par\u00e9. Apr\u00e8s que le solveur it\u00e9ratif ait calcul\u00e9 les d\u00e9lais de pas, ils sont ajout\u00e9s \u00e0 un tableau : itersolve_gen_steps_range() -> stepcompress_append() (dans klippy/chelper/stepcompress.c). Le tableau (struct stepcompress.queue) stocke les dur\u00e9es correspondantes du compteur d'horloge du micro-contr\u00f4leur pour chaque \u00e9tape. Ici, la valeur du \"compteur d'horloge du micro-contr\u00f4leur\" correspond directement au compteur mat\u00e9riel du micro-contr\u00f4leur - elle est relative \u00e0 la derni\u00e8re mise sous tension du micro-contr\u00f4leur. La prochaine \u00e9tape majeure est de compresser les \u00e9tapes : stepcompress_flush() -> compress_bisect_add() (dans klippy/chelper/stepcompress.c). Ce code g\u00e9n\u00e8re et encode une s\u00e9rie de commandes \"queue_step\" du micro-contr\u00f4leur correspondant \u00e0 la liste des dur\u00e9es de pas du moteur construite \u00e0 l'\u00e9tape pr\u00e9c\u00e9dente. Ces commandes \"queue_step\" sont ensuite mises en file d'attente, hi\u00e9rarchis\u00e9es et envoy\u00e9es au micro-contr\u00f4leur (via stepcompress.c:steppersync et serialqueue.c:serialqueue). Le traitement des commandes queue_step sur le micro-contr\u00f4leur commence dans src/command.c qui analyse la commande et appelle command_queue_step() . Le code command_queue_step() (dans src/stepper.c) ajoute simplement les param\u00e8tres de chaque commande queue_step \u00e0 une file d'attente par moteur. En fonctionnement normal, la commande queue_step est analys\u00e9e et mise en file d'attente au moins 100ms avant le moment de son premier pas. Enfin, la g\u00e9n\u00e9ration des \u00e9v\u00e9nements de pas du moteur est faite dans stepper_event() . Elle est appel\u00e9e depuis l'interruption du compteur mat\u00e9riel \u00e0 l'heure pr\u00e9vue du premier pas. Le code stepper_event() g\u00e9n\u00e8re une impulsion de pas et se reprogramme ensuite pour s'ex\u00e9cuter au moment de l'impulsion de pas suivante pour les param\u00e8tres queue_step donn\u00e9s. Les param\u00e8tres pour chaque commande queue_step sont \"interval\", \"count\", et \"add\". A un haut niveau, stepper_event() ex\u00e9cute la commande suivante, 'count' fois : do_step() ; next_wake_time = last_wake_time + interval ; interval += add; Ce qui pr\u00e9c\u00e8de peut sembler beaucoup de complexit\u00e9 pour l'ex\u00e9cution d'un mouvement. Cependant, les seules parties vraiment int\u00e9ressantes se trouvent dans les classes ToolHead et kinematic. C'est cette partie du code qui pr\u00e9cise les mouvements et leurs dur\u00e9es. Les autres parties du traitement sont essentiellement de la communication et de la plomberie. Ajout d'un module h\u00f4te \u00b6 Le code h\u00f4te de Klippy a une capacit\u00e9 de chargement dynamique de modules. Si une section de configuration nomm\u00e9e \"[mon_module]\" est trouv\u00e9e dans le fichier de configuration de l'imprimante, le logiciel tentera automatiquement de charger le module python klippy/extras/mon_module.py . Ce syst\u00e8me de modules est la m\u00e9thode pr\u00e9f\u00e9r\u00e9e pour ajouter de nouvelles fonctionnalit\u00e9s \u00e0 Klipper. La fa\u00e7on la plus simple d'ajouter un nouveau module est d'utiliser un module existant comme r\u00e9f\u00e9rence - voir klippy/extras/servo.py comme exemple. Les \u00e9l\u00e9ments suivants peuvent \u00e9galement \u00eatre utiles : L'ex\u00e9cution du module commence dans la fonction load_config() au niveau du module (pour les sections de configuration de la forme [mon_module]) ou dans load_config_prefix() (pour les sections de configuration de la forme [mon_module mon_nom]). On passe \u00e0 cette fonction un objet \"config\" et elle doit retourner un nouvel \"objet imprimante\" associ\u00e9 \u00e0 la section de configuration donn\u00e9e. Durant le processus d'instanciation d'un nouvel objet imprimante, l'objet config peut \u00eatre utilis\u00e9 pour lire les param\u00e8tres de la section config donn\u00e9e. Ceci est fait en utilisant les m\u00e9thodes config.get() , config.getfloat() , config.getint() , etc. Assurez-vous de lire toutes les valeurs de la configuration pendant la construction de l'objet imprimante - si l'utilisateur sp\u00e9cifie un param\u00e8tre de configuration qui n'est pas lu pendant cette phase, il sera suppos\u00e9 qu'il s'agit d'une faute de frappe dans la configuration et une erreur sera lev\u00e9e. Utilisez la m\u00e9thode config.get_printer() pour obtenir une r\u00e9f\u00e9rence \u00e0 la classe principale \"printer\". Cette classe \"printer\" stocke les r\u00e9f\u00e9rences de tous les \"objets imprimante\" instanci\u00e9s. Utilisez la m\u00e9thode printer.lookup_object() pour trouver des r\u00e9f\u00e9rences \u00e0 d'autres objets imprimante. Presque toutes les fonctionnalit\u00e9s (m\u00eame les modules cin\u00e9matiques de base) sont encapsul\u00e9es dans un de ces objets imprimante. Notez, cependant, que lorsqu'un nouveau module est instanci\u00e9, tous les autres objets d'impression n'auront pas encore \u00e9t\u00e9 instanci\u00e9s. Les modules \"gcode\" et \"pins\" seront toujours disponibles, mais pour les autres modules, il est pr\u00e9f\u00e9rable de diff\u00e9rer la recherche. Enregistrez les gestionnaires d'\u00e9v\u00e9nements en utilisant la m\u00e9thode printer.register_event_handler() si le code doit \u00eatre appel\u00e9 lors d'\"\u00e9v\u00e9nements\" d\u00e9clench\u00e9s par d'autres objets imprimante. Chaque nom d'\u00e9v\u00e9nement est une cha\u00eene de caract\u00e8res, et par convention, c'est le nom du module source principal d\u00e9clenchant l'\u00e9v\u00e9nement avec un nom court pour l'action produite (par exemple, \"klippy:connect\"). Les param\u00e8tres pass\u00e9s \u00e0 chaque gestionnaire d'\u00e9v\u00e9nement sont sp\u00e9cifiques \u00e0 l'\u00e9v\u00e9nement en question (tout comme le traitement des exceptions et le contexte d'ex\u00e9cution). Deux \u00e9v\u00e9nements de d\u00e9marrage courants sont : klippy:connect - Cet \u00e9v\u00e9nement est g\u00e9n\u00e9r\u00e9 apr\u00e8s l'instanciation de tous les objets imprimante. Il est couramment utilis\u00e9 pour rechercher d'autres objets imprimante, pour v\u00e9rifier les param\u00e8tres de configuration et pour effectuer une premi\u00e8re \"prise de contact\" avec le mat\u00e9riel de l'imprimante. klippy:ready - Cet \u00e9v\u00e9nement est g\u00e9n\u00e9r\u00e9 apr\u00e8s que tous les gestionnaires de connexion se soient termin\u00e9s avec succ\u00e8s. Il indique que l'imprimante est en train de passer \u00e0 l'\u00e9tat pr\u00eat \u00e0 g\u00e9rer les op\u00e9rations normales. Ne d\u00e9clenchez pas d'erreur dans ce rappel. S'il y a une erreur dans la configuration de l'utilisateur, assurez-vous de la signaler pendant les phases load_config() ou \"connect event\". Utilisez soit raise config.error(\"mon erreur\") soit raise printer.config_error(\"mon erreur\") pour signaler l'erreur. Utilisez le module \"pins\" pour configurer une broche sur un micro-contr\u00f4leur. Ceci est typiquement fait avec quelque chose de similaire \u00e0 printer.lookup_object(\"pins\").setup_pin(\"pwm\", config.get(\"my_pin\")) . L'objet retourn\u00e9 peut alors \u00eatre command\u00e9 au moment de l'ex\u00e9cution. Si l'objet imprimante d\u00e9finit une m\u00e9thode get_status() , le module peut exporter des informations d'\u00e9tat via des macros et via le serveur API . La m\u00e9thode get_status() doit retourner un dictionnaire Python dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs des entiers, des flottants, des cha\u00eenes de caract\u00e8res, des listes, des dictionnaires, True, False ou None. Les tuples (et les tuples nomm\u00e9s) peuvent \u00e9galement \u00eatre utilis\u00e9s (ils apparaissent comme des listes lorsqu'on y acc\u00e8de via le serveur API). Les listes et les dictionnaires export\u00e9s doivent \u00eatre trait\u00e9s comme \"immuables\" - si leur contenu change, un nouvel objet doit \u00eatre renvoy\u00e9 par get_status() , sinon le serveur API ne d\u00e9tectera pas ces changements. Si le module doit acc\u00e9der \u00e0 la temporisation du syst\u00e8me ou \u00e0 des descripteurs de fichiers externes, utilisez printer.get_reactor() pour obtenir l'acc\u00e8s \u00e0 la classe globale \"event reactor\". Cette classe de r\u00e9acteur permet de programmer des temporisations, d'attendre des entr\u00e9es sur des descripteurs de fichiers, et d'\"endormir\" le code h\u00f4te. N'utilisez pas de variables globales. Tous les \u00e9tats doivent \u00eatre stock\u00e9s dans l'objet imprimante renvoy\u00e9 par la fonction load_config() . Ceci est important car sinon la commande RESTART pourrait ne pas fonctionner comme pr\u00e9vu. De m\u00eame, pour des raisons similaires, si des fichiers externes (ou des sockets) sont ouverts, assurez-vous d'enregistrer un gestionnaire d'\u00e9v\u00e9nement \"klippy:disconnect\" et de les fermer \u00e0 partir de ce rappel. \u00c9vitez d'acc\u00e9der aux variables membres internes (ou d'appeler les m\u00e9thodes commen\u00e7ant par un trait de soulignement) d'autres objets imprimante. Le respect de cette convention facilite la gestion des modifications futures. Il est recommand\u00e9 d'attribuer une valeur \u00e0 toutes les variables membres dans le constructeur Python des classes Python. (Et donc d'\u00e9viter d'utiliser la capacit\u00e9 de Python \u00e0 cr\u00e9er dynamiquement de nouvelles variables membres.) Si une variable Python doit stocker une valeur en virgule flottante, il est recommand\u00e9 de toujours affecter et manipuler cette variable avec des constantes en virgule flottante (et de ne jamais utiliser de constantes enti\u00e8res). Par exemple, pr\u00e9f\u00e9rez self.speed = 1. \u00e0 self.speed = 1 , et pr\u00e9f\u00e9rez self.speed = 2. * x plut\u00f4t que self.speed = 2 * x . L'utilisation coh\u00e9rente des valeurs \u00e0 virgule flottante peut \u00e9viter des bizarreries difficiles \u00e0 d\u00e9boguer dans les conversions de types Python. Si vous soumettez le module pour qu'il soit inclus dans le code principal de Klipper, veillez \u00e0 placer un avis de copyright en haut du module. Consultez les modules existants pour conna\u00eetre le format pr\u00e9f\u00e9r\u00e9. Ajout de nouvelles cin\u00e9matiques \u00b6 Cette section fournit quelques conseils pour ajouter le support \u00e0 Klipper de types suppl\u00e9mentaires de cin\u00e9matiques d'imprimante. Ce type d'activit\u00e9 n\u00e9cessite une excellente compr\u00e9hension des formules math\u00e9matiques de la cin\u00e9matique cible. Elle requiert \u00e9galement des comp\u00e9tences en mati\u00e8re de d\u00e9veloppement de logiciels, m\u00eame s'il suffit de mettre \u00e0 jour le logiciel h\u00f4te. Les \u00e9tapes utiles : Commencez par \u00e9tudier la section \" code de flux d'un mouvement \" et le document cin\u00e9matiques . Passez en revue les classes cin\u00e9matiques existantes dans le r\u00e9pertoire klippy/kinematics/. Les classes cin\u00e9matiques sont charg\u00e9es de convertir le mouvement en coordonn\u00e9es cart\u00e9siennes en un mouvement sur chaque moteur. On devrait \u00eatre capable de copier un de ces fichiers comme point de d\u00e9part. Impl\u00e9mentez les fonctions de position cin\u00e9matique du moteur en C pour chaque moteur si elles ne sont pas d\u00e9j\u00e0 disponibles (voir kin_cart.c, kin_corexy.c, et kin_delta.c dans klippy/chelper/). La fonction doit appeler move_get_coord() pour convertir une dur\u00e9e de d\u00e9placement donn\u00e9e (en secondes) en coordonn\u00e9es cart\u00e9siennes (en millim\u00e8tres), et ensuite calculer la position souhait\u00e9e du moteur (en millim\u00e8tres) \u00e0 partir de ces coordonn\u00e9es cart\u00e9siennes. Impl\u00e9mentez la m\u00e9thode calc_position() dans la nouvelle classe cin\u00e9matique. Cette m\u00e9thode calcule la position de la t\u00eate de l'outil en coordonn\u00e9es cart\u00e9siennes \u00e0 partir de la position de chaque moteur. Elle n'a pas besoin d'\u00eatre efficace car elle n'est typiquement appel\u00e9e que pendant les op\u00e9rations de mise \u00e0 l'origine et de palpage. Autres m\u00e9thodes. Impl\u00e9mentez les m\u00e9thodes check_move() , get_status() , get_steppers() , home() , et set_position() . Ces fonctions sont typiquement utilis\u00e9es pour fournir des v\u00e9rifications sp\u00e9cifiques \u00e0 la cin\u00e9matique. Cependant, au d\u00e9but du d\u00e9veloppement, on peut utiliser du code passe-partout ici. Impl\u00e9menter des cas de test. Cr\u00e9ez un fichier g-code avec une s\u00e9rie de mouvements pouvant tester des cas importants pour la cin\u00e9matique donn\u00e9e. Suivez la documentation de d\u00e9bogage pour convertir ce fichier g-code en commandes de micro-contr\u00f4leur. Ceci est utile pour tester les cas extr\u00eames et v\u00e9rifier les r\u00e9gressions. Portage sur un nouveau microcontr\u00f4leur \u00b6 Cette section fournit quelques conseils sur le portage du code du microcontr\u00f4leur de Klipper vers une nouvelle architecture. Ce type d'activit\u00e9 n\u00e9cessite une bonne connaissance du d\u00e9veloppement embarqu\u00e9 et un acc\u00e8s pratique au microcontr\u00f4leur cible. Les \u00e9tapes utiles : Commencez par identifier toutes les biblioth\u00e8ques tierces qui seront utilis\u00e9es pendant le portage. Les exemples courants incluent les wrappers \"CMSIS\" et les biblioth\u00e8ques \"HAL\" des fabricants. Tout code tiers doit \u00eatre compatible avec la licence GNU GPLv3. Le code tiers doit \u00eatre livr\u00e9 dans le r\u00e9pertoire Klipper lib/. Mettez \u00e0 jour le fichier lib/README en indiquant o\u00f9 et quand la biblioth\u00e8que a \u00e9t\u00e9 obtenue. Il est pr\u00e9f\u00e9rable de copier le code dans le d\u00e9p\u00f4t Klipper sans modification, mais si des modifications sont n\u00e9cessaires, elles doivent \u00eatre indiqu\u00e9es explicitement dans le fichier lib/README. Cr\u00e9er un nouveau sous-r\u00e9pertoire d'architecture dans le r\u00e9pertoire src/ et ajouter le support initial de Kconfig et Makefile. Utilisez les architectures existantes comme guide. Le simulateur src/simulator fournit un exemple de base pour un point de d\u00e9part minimal. La premi\u00e8re t\u00e2che principale de codage est d'apporter le support de communication \u00e0 la carte cible. C'est l'\u00e9tape la plus difficile dans un nouveau portage. Une fois que la communication de base fonctionne, les autres \u00e9tapes ont tendance \u00e0 \u00eatre beaucoup plus faciles. Il est typique d'utiliser un dispositif s\u00e9rie de type UART pendant le d\u00e9veloppement initial car ces types de dispositifs mat\u00e9riels sont g\u00e9n\u00e9ralement plus faciles \u00e0 activer et \u00e0 contr\u00f4ler. Pendant cette phase, faites un usage lib\u00e9ral du code d'aide du r\u00e9pertoire src/generic/ (v\u00e9rifiez comment src/simulator/Makefile inclut le code C g\u00e9n\u00e9rique dans la compilation). Il est \u00e9galement n\u00e9cessaire de d\u00e9finir timer_read_time() (qui renvoie l'horloge syst\u00e8me actuelle) dans cette phase, mais il n'est pas n\u00e9cessaire de supporter compl\u00e8tement la gestion des irq des timers. Familiarisez-vous avec l'outil console.py (comme d\u00e9crit dans le document de d\u00e9bogage ) et v\u00e9rifiez la connectivit\u00e9 au microcontr\u00f4leur avec cet outil. Cet outil traduit le protocole de communication de bas niveau du microcontr\u00f4leur en une forme lisible par l'homme. Ajouter le support pour la distribution des timers \u00e0 partir des interruptions mat\u00e9rielles. Voir Klipper commit 970831ee comme exemple des \u00e9tapes 1-5 r\u00e9alis\u00e9es pour l'architecture LPC176x. Apporter le support de base des entr\u00e9es et sorties GPIO. Voir Klipper commit c78b9076 comme exemple. Faire appara\u00eetre des p\u00e9riph\u00e9riques suppl\u00e9mentaires - par exemple, voir Klipper commit 65613aed , c812a40a , et c381d03a . Cr\u00e9ez un exemple de fichier de configuration Klipper dans le r\u00e9pertoire config/. Testez le micro-contr\u00f4leur avec le programme principal klippy.py. Pensez \u00e0 ajouter des cas de test de construction dans le r\u00e9pertoire test/. Conseils suppl\u00e9mentaires pour le codage : \u00c9vitez d'utiliser des \"champs de bits C\" pour acc\u00e9der aux registres d'E/S ; pr\u00e9f\u00e9rez les op\u00e9rations directes de lecture et d'\u00e9criture d'entiers de 32, 16 ou 8 bits. Les sp\u00e9cifications du langage C ne pr\u00e9cisent pas clairement comment le compilateur doit impl\u00e9menter les champs de bits C (par exemple, l'endianness et la disposition des bits), et il est difficile de d\u00e9terminer quelles op\u00e9rations d'E/S se produiront lors de la lecture ou de l'\u00e9criture d'un champ de bits C. Pr\u00e9f\u00e9rez l'\u00e9criture de valeurs explicites dans les registres d'E/S \u00e0 l'utilisation d'op\u00e9rations de lecture-modification-\u00e9criture. Autrement dit, si l'on met \u00e0 jour un champ dans un registre d'E/S dont les autres champs ont des valeurs connues, il est pr\u00e9f\u00e9rable d'\u00e9crire explicitement le contenu complet du registre. Les \u00e9critures explicites produisent un code plus petit, plus rapide et plus facile \u00e0 d\u00e9boguer. Les syst\u00e8mes de coordonn\u00e9es \u00b6 En interne, Klipper suit principalement la position de la t\u00eate de l'outil en coordonn\u00e9es cart\u00e9siennes relatives au syst\u00e8me de coordonn\u00e9es sp\u00e9cifi\u00e9 dans le fichier de configuration. C'est-\u00e0-dire que la plupart du code de Klipper ne conna\u00eetra jamais de changement de syst\u00e8me de coordonn\u00e9es. Si l'utilisateur fait une demande pour changer l'origine (par exemple, une commande G92 ) alors cet effet est obtenu en traduisant les commandes futures vers le syst\u00e8me de coordonn\u00e9es primaires. Cependant, dans certains cas, il est utile d'obtenir la position de la t\u00eate de l'outil dans un autre syst\u00e8me de coordonn\u00e9es et Klipper dispose de plusieurs outils pour faciliter cela. Vous pouvez le constater en ex\u00e9cutant la commande GET_POSITION. Par exemple : Send: GET_POSITION Recv: // mcu: stepper_a:-2060 stepper_b:-1169 stepper_c:-1613 Recv: // stepper: stepper_a:457.254159 stepper_b:466.085669 stepper_c:465.382132 Recv: // kinematic: X:8.339144 Y:-3.131558 Z:233.347121 Recv: // toolhead: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000 Recv: // gcode: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000 Recv: // gcode base: X:0.000000 Y:0.000000 Z:0.000000 E:0.000000 Recv: // gcode homing: X:0.000000 Y:0.000000 Z:0.000000 La position \"mcu\" ( stepper.get_mcu_position() dans le code) est le nombre total de pas que le micro-contr\u00f4leur a \u00e9mis dans un sens positif moins le nombre de pas \u00e9mis dans un sens n\u00e9gatif depuis la derni\u00e8re r\u00e9initialisation du micro-contr\u00f4leur. Si le robot est en mouvement lorsque la requ\u00eate est \u00e9mise, la valeur rapport\u00e9e inclut les mouvements mis en m\u00e9moire tampon dans le microcontr\u00f4leur, mais pas les mouvements de la file d'attente de surveillance. La position \"stepper\" ( stepper.get_commanded_position() ) est la position du moteur donn\u00e9 telle qu'elle est suivie par le code cin\u00e9matique. Cela correspond g\u00e9n\u00e9ralement \u00e0 la position (en mm) du chariot le long de son rail, par rapport \u00e0 la position_endstop indiqu\u00e9e dans le fichier de configuration. (Si le robot est en mouvement lorsque la requ\u00eate est \u00e9mise, la valeur rapport\u00e9e inclut les mouvements mis en m\u00e9moire tampon sur le micro-contr\u00f4leur, mais n'inclut pas les mouvements de la file d'attente look-ahead. On peut utiliser les appels toolhead.flush_step_generation() ou toolhead.wait_moves() pour vider compl\u00e8tement les codes de look-ahead et de g\u00e9n\u00e9ration de pas. La position \"kinematic\" ( kin.calc_position() ) est la position cart\u00e9sienne de la t\u00eate de l'outil telle que d\u00e9riv\u00e9e des positions \"pas \u00e0 pas\" et est relative au syst\u00e8me de coordonn\u00e9es sp\u00e9cifi\u00e9 dans le fichier de configuration. Cela peut diff\u00e9rer de la position cart\u00e9sienne demand\u00e9e en raison de la granularit\u00e9 des moteurs pas \u00e0 pas. Si le robot est en mouvement lorsque les positions \"stepper\" sont prises, la valeur rapport\u00e9e inclut les mouvements mis en m\u00e9moire tampon sur le micro-contr\u00f4leur, mais n'inclut pas les mouvements de la file d'attente look-ahead. On peut utiliser les appels toolhead.flush_step_generation() ou toolhead.wait_moves() pour vider compl\u00e8tement le code de look-ahead et de g\u00e9n\u00e9ration de pas. La position de la t\u00eate d'outil ( toolhead.get_position() ) est la derni\u00e8re position demand\u00e9e de la t\u00eate d'outil en coordonn\u00e9es cart\u00e9siennes par rapport au syst\u00e8me de coordonn\u00e9es sp\u00e9cifi\u00e9 dans le fichier de configuration. Si le robot est en mouvement lorsque la requ\u00eate est \u00e9mise, la valeur rapport\u00e9e inclut tous les d\u00e9placements demand\u00e9s (m\u00eame ceux dans les tampons en attente d'\u00eatre \u00e9mis vers les pilotes de moteurs pas \u00e0 pas). La position \"gcode\" est la derni\u00e8re position demand\u00e9e par une commande G1 (ou G0 ) en coordonn\u00e9es cart\u00e9siennes par rapport au syst\u00e8me de coordonn\u00e9es sp\u00e9cifi\u00e9 dans le fichier de configuration. Elle peut diff\u00e9rer de la position \"toolhead\" si une transformation g-code (par exemple, bed_mesh, bed_tilt, skew_correction) est en cours. Cela peut diff\u00e9rer des coordonn\u00e9es r\u00e9elles sp\u00e9cifi\u00e9es dans la derni\u00e8re commande G1 si l'origine du gcode a \u00e9t\u00e9 modifi\u00e9e (par exemple, G92 , SET_GCODE_OFFSET , M221 ). La commande M114 ( gcode_move.get_status()['gcode_position'] ) indiquera la derni\u00e8re position du g-code par rapport au syst\u00e8me de coordonn\u00e9es actuel du g-code. La \"base gcode\" est l'emplacement de l'origine du g-code en coordonn\u00e9es cart\u00e9siennes par rapport au syst\u00e8me de coordonn\u00e9es sp\u00e9cifi\u00e9 dans le fichier de configuration. Les commandes telles que G92 , SET_GCODE_OFFSET , et M221 modifient cette valeur. Le \"gcode homing\" est l'emplacement \u00e0 utiliser pour l'origine du g-code (en coordonn\u00e9es cart\u00e9siennes par rapport au syst\u00e8me de coordonn\u00e9es sp\u00e9cifi\u00e9 dans le fichier de configuration) apr\u00e8s une commande de mise \u00e0 l'origine G28 . La commande SET_GCODE_OFFSET peut modifier cette valeur. Temporisation \u00b6 La manipulation des horloges, des dur\u00e9es et des horodatages est fondamentale pour le fonctionnement de Klipper. Celui-ci ex\u00e9cute des actions sur l'imprimante en programmant des \u00e9v\u00e9nements qui se produiront dans un avenir proche. Par exemple, pour allumer un ventilateur, le code peut programmer un changement sur une broche GPIO dans 100 ms. Il est rare que le code tente d'effectuer une action instantan\u00e9e. Ainsi, la gestion du temps dans Klipper est essentielle pour un fonctionnement correct. Il existe trois types de temporisations suivis en interne dans le logiciel h\u00f4te Klipper : Heure du syst\u00e8me. L'heure syst\u00e8me utilise l'horloge du syst\u00e8me - c'est un nombre \u00e0 virgule flottante stock\u00e9 sous forme de secondes (g\u00e9n\u00e9ralement) relatif \u00e0 la date du dernier d\u00e9marrage de l'ordinateur h\u00f4te. Les temps syst\u00e8me ont un usage limit\u00e9 dans le logiciel - ils sont principalement utilis\u00e9s lors de l'interaction avec le syst\u00e8me d'exploitation. Dans le code h\u00f4te, les heures syst\u00e8me sont souvent stock\u00e9es dans des variables nomm\u00e9es eventtime ou curtime . Temps d'impression. Le temps d'impression est synchronis\u00e9 avec l'horloge du micro-contr\u00f4leur principal (le micro-contr\u00f4leur d\u00e9fini dans la section \"[mcu]\" de la configuration). C'est un nombre \u00e0 virgule flottante stock\u00e9 en secondes relatif \u00e0 la date du dernier red\u00e9marrage du micro-contr\u00f4leur principal. Il est possible de convertir un \"temps d'impression\" en horloge mat\u00e9rielle du micro-contr\u00f4leur principal en multipliant le temps d'impression par le taux de fr\u00e9quence du mcu configur\u00e9 statiquement. Le code h\u00f4te de haut niveau utilise les temps d'impression pour calculer presque toutes les actions physiques (par exemple, le mouvement de la t\u00eate, les changements de chauffage, etc.) Dans le code h\u00f4te, les temps d'impression sont g\u00e9n\u00e9ralement stock\u00e9s dans des variables nomm\u00e9es print_time ou move_time . Horloge MCU. Il s'agit du compteur d'horloge mat\u00e9riel de chaque micro-contr\u00f4leur. Il est stock\u00e9 sous forme d'un nombre entier et son taux de mise \u00e0 jour est relatif \u00e0 la fr\u00e9quence du micro-contr\u00f4leur donn\u00e9. Le logiciel h\u00f4te convertit ses temps internes en horloges avant de les transmettre \u00e0 l'unit\u00e9 centrale. Le code de l'unit\u00e9 centrale de traitement ne suit jamais le temps qu'en ticks d'horloge. Dans le code h\u00f4te, les valeurs d'horloge sont suivies sous forme d'entiers de 64 bits, alors que le code de l'unit\u00e9 centrale utilise des entiers de 32 bits. Dans le code h\u00f4te, les horloges sont g\u00e9n\u00e9ralement stock\u00e9es dans des variables dont les noms contiennent clock ou ticks . La conversion entre les diff\u00e9rents formats de temps est principalement impl\u00e9ment\u00e9e dans le code klippy/clocksync.py . Quelques \u00e9l\u00e9ments \u00e0 prendre en compte lors de la r\u00e9vision du code : Horloges 32bit et 64bit : Pour r\u00e9duire la bande passante et am\u00e9liorer l'efficacit\u00e9 du micro-contr\u00f4leur, les horloges sur le micro-contr\u00f4leur sont suivies comme des entiers 32bit. Lors de la comparaison de deux horloges dans le code mcu, la fonction timer_is_before() doit toujours \u00eatre utilis\u00e9e pour s'assurer que les renversements d'entiers sont trait\u00e9s correctement. Le logiciel h\u00f4te convertit les horloges 32bit en horloges 64bit en ajoutant les bits de poids fort du dernier timestamp mcu qu'il a re\u00e7u - aucun message du mcu n'est jamais plus de 2^31 ticks d'horloge dans le futur ou le pass\u00e9, donc cette conversion n'est jamais ambigu\u00eb. L'h\u00f4te convertit les horloges de 64 bits en horloges de 32 bits en tronquant simplement les bits de poids fort. Pour s'assurer qu'il n'y a pas d'ambigu\u00eft\u00e9 dans cette conversion, le code klippy/chelper/serialqueue.c mettra en m\u00e9moire tampon les messages jusqu'\u00e0 ce qu'ils soient dans les 2^31 ticks d'horloge de leur temps cible. Microcontr\u00f4leurs multiples : Le logiciel h\u00f4te permet d'utiliser plusieurs microcontr\u00f4leurs sur une seule imprimante. Dans ce cas, l'\"horloge MCU\" de chaque microcontr\u00f4leur est suivie s\u00e9par\u00e9ment. Le code clocksync.py g\u00e8re la d\u00e9rive de l'horloge entre les micro-contr\u00f4leurs en modifiant la fa\u00e7on dont il convertit le \"temps d'impression\" en \"horloge MCU\". Sur les mcus secondaires, la fr\u00e9quence du mcu utilis\u00e9e dans cette conversion est r\u00e9guli\u00e8rement mise \u00e0 jour pour tenir compte de la d\u00e9rive mesur\u00e9e.","title":"Aper\u00e7u du code"},{"location":"Code_Overview.html#apercu-du-code","text":"Ce document d\u00e9crit la disposition g\u00e9n\u00e9rale du code et le flux de code principal de Klipper.","title":"Aper\u00e7u du code"},{"location":"Code_Overview.html#disposition-du-repertoire","text":"Le r\u00e9pertoire src/ contient les sources C du code du micro-contr\u00f4leur. Les r\u00e9pertoires src/atsam/ , src/atsamd/ , src/avr/ , src/linux/ , src/lpc176x/ , src/pru/ , et src/stm32/ contiennent le code du micro-contr\u00f4leur sp\u00e9cifique \u00e0 chaque architecture. Le r\u00e9pertoire src/simulator/ contient des \u00e9l\u00e9ments de remplacement de code permettant de tester la compilation du micro-contr\u00f4leur sur d'autres architectures. Le r\u00e9pertoire src/generic/ contient du code d'assistance utile sur diff\u00e9rentes architectures. La compilation fait en sorte que les inclusions de \"board/somefile.h\" soient d'abord recherch\u00e9es dans le r\u00e9pertoire de l'architecture courante (par exemple, src/avr/somefile.h) et ensuite dans le r\u00e9pertoire g\u00e9n\u00e9rique (par exemple, src/generic/somefile.h). Le r\u00e9pertoire klippy/ contient le logiciel h\u00f4te. La majorit\u00e9 du logiciel h\u00f4te est \u00e9crit en Python, cependant le r\u00e9pertoire klippy/chelper/ contient quelques assistants en code C. Le r\u00e9pertoire klippy/kinematics/ contient le code li\u00e9 \u00e0 la cin\u00e9matique du robot. Le r\u00e9pertoire klippy/extras/ contient les \"modules\" extensibles du code h\u00f4te. Le r\u00e9pertoire lib/ contient du code de biblioth\u00e8que externe de tierce partie n\u00e9cessaire \u00e0 la construction de certaines cibles. Le r\u00e9pertoire config/ contient des exemples de fichiers de configuration d'imprimante. Le r\u00e9pertoire scripts/ contient des scripts de construction utiles \u00e0 la compilation du code du micro-contr\u00f4leur. Le r\u00e9pertoire test/ contient des cas de tests automatis\u00e9s. Pendant la compilation, le constructeur peut cr\u00e9er un r\u00e9pertoire out/ . Celui-ci contient des objets temporaires de compilation. L'objet micro-contr\u00f4leur final qui est construit est out/klipper.elf.hex sur AVR et out/klipper.bin sur ARM.","title":"Disposition du r\u00e9pertoire"},{"location":"Code_Overview.html#flux-de-code-du-micro-controleur","text":"L'ex\u00e9cution du code du microcontr\u00f4leur d\u00e9bute dans le code sp\u00e9cifique \u00e0 l'architecture (par exemple, src/avr/main.c ) qui appelle finalement sched_main() situ\u00e9 dans src/sched.c . Le code sched_main() commence par ex\u00e9cuter toutes les fonctions marqu\u00e9es avec la macro DECL_INIT(). Il ex\u00e9cute ensuite de mani\u00e8re r\u00e9p\u00e9t\u00e9e toutes les fonctions marqu\u00e9es par la macro DECL_TASK(). L'une des principales fonctions de la t\u00e2che est command_dispatch() situ\u00e9e dans src/command.c . Cette fonction est appel\u00e9e \u00e0 partir du code d'entr\u00e9e/sortie sp\u00e9cifique \u00e0 la carte (par exemple, src/avr/serial.c , src/generic/serial_irq.c ) et elle ex\u00e9cute les fonctions de commande associ\u00e9es aux commandes trouv\u00e9es dans le flux d'entr\u00e9e. Les fonctions de commande sont d\u00e9clar\u00e9es \u00e0 l'aide de la macro DECL_COMMAND() (voir le document protocole pour plus d'informations). Les fonctions de t\u00e2che, d'initialisation et de commande s'ex\u00e9cutent toujours avec les interruptions activ\u00e9es (toutefois, elles peuvent d\u00e9sactiver temporairement les interruptions si n\u00e9cessaire). Ces fonctions doivent \u00e9viter les longues pauses, les retards, ou effectuer un travail qui dure un temps significatif. (Les longs retards de ces fonctions \"t\u00e2ches\" entra\u00eenent une gigue de programmation pour d'autres \"t\u00e2ches\" - les retards de plus de 100us peuvent devenir perceptibles, les retards de plus de 500us peuvent entra\u00eener des retransmissions de commandes, les retards de plus de 100ms peuvent entra\u00eener des red\u00e9marrages du chien de garde). Ces fonctions planifient le travail \u00e0 des moments pr\u00e9cis en programmant des minuteries. Les fonctions de temporisation sont programm\u00e9es en appelant sched_add_timer() (situ\u00e9 dans src/sched.c ). Le code du planificateur s'arrangera pour que la fonction donn\u00e9e soit appel\u00e9e au moment demand\u00e9. Les interruptions de temporisation sont initialement trait\u00e9es dans un gestionnaire d'interruption sp\u00e9cifique \u00e0 l'architecture (par exemple, src/avr/timer.c ) qui appelle sched_timer_dispatch() situ\u00e9 dans src/sched.c . L'interruption de la temporisation entra\u00eene l'ex\u00e9cution des fonctions de temporisation planifi\u00e9es. Les fonctions de temporisation sont toujours ex\u00e9cut\u00e9es avec des interruptions d\u00e9sactiv\u00e9es. Les fonctions de temporisation devraient toujours se terminer en quelques microsecondes. \u00c0 la fin de l'\u00e9v\u00e9nement de temporisation, la fonction peut choisir de se reprogrammer. En cas de d\u00e9tection d'erreur, le code peut invoquer shutdown() (une macro qui appelle sched_shutdown() situ\u00e9e dans src/sched.c ). L'appel \u00e0 shutdown() entra\u00eene l'ex\u00e9cution de toutes les fonctions marqu\u00e9es par la macro DECL_SHUTDOWN(). Les fonctions d'arr\u00eat s'ex\u00e9cutent toujours avec des interruptions d\u00e9sactiv\u00e9es. Une grande partie des fonctionnalit\u00e9s du micro-contr\u00f4leur implique de travailler avec des broches d'entr\u00e9e/sortie \u00e0 usage g\u00e9n\u00e9ral (GPIO). Afin de s\u00e9parer le code de bas niveau sp\u00e9cifique \u00e0 l'architecture du code de haut niveau de la t\u00e2che, tous les \u00e9v\u00e9nements GPIO sont impl\u00e9ment\u00e9s dans des emballages sp\u00e9cifiques \u00e0 l'architecture (par exemple, src/avr/gpio.c ). Le code est compil\u00e9 avec l'optimisation \"-flto -fwhole-program\" de gcc qui fait un excellent travail d'int\u00e9gration des fonctions \u00e0 travers les unit\u00e9s de compilation, ainsi la plupart de ces minuscules fonctions gpio sont int\u00e9gr\u00e9es \u00e0 leurs appelants, et il n'y a aucun co\u00fbt d'ex\u00e9cution \u00e0 les utiliser.","title":"Flux de code du micro-contr\u00f4leur"},{"location":"Code_Overview.html#apercu-du-code-klippy","text":"Le code h\u00f4te (Klippy) est destin\u00e9 \u00e0 fonctionner sur un ordinateur \u00e0 petit prix (tel qu'un Raspberry Pi) associ\u00e9 au microcontr\u00f4leur. Le code est principalement \u00e9crit en Python, cependant il utilise CFFI pour impl\u00e9menter certaines fonctionnalit\u00e9s en code C. L'ex\u00e9cution initiale commence dans klippy/klippy.py . Ceci lit les arguments de la ligne de commande, ouvre le fichier de configuration de l'imprimante, instancie les principaux objets de l'imprimante et lance la connexion s\u00e9rie. L'ex\u00e9cution principale des commandes G-code se fait dans la m\u00e9thode process_commands() de klippy/gcode.py . Ce code traduit les commandes G-code en appels d'objets d'imprimante fr\u00e9quemment traduis en commandes d'actions \u00e0 ex\u00e9cuter sur le micro-contr\u00f4leur (tel que d\u00e9clar\u00e9 via la macro DECL_COMMAND dans le code du micro-contr\u00f4leur). Il y a quatre threads dans le code h\u00f4te de Klippy. Le thread principal g\u00e8re les commandes gcode entrantes. Un deuxi\u00e8me thread (r\u00e9sidant enti\u00e8rement dans le code C klippy/chelper/serialqueue.c ) g\u00e8re les entr\u00e9es/sorties de bas niveau avec le port s\u00e9rie. Le troisi\u00e8me thread est utilis\u00e9 pour traiter les messages de r\u00e9ponse du micro-contr\u00f4leur dans le code Python (voir klippy/serialhdl.py ). Le quatri\u00e8me thread \u00e9crit les messages de d\u00e9bogage dans le journal (voir klippy/queuelogger.py ) afin que les autres threads ne bloquent jamais les \u00e9critures dans le journal.","title":"Aper\u00e7u du code Klippy"},{"location":"Code_Overview.html#flux-du-code-dune-commande-de-deplacement","text":"Un mouvement typique de l'imprimante commence lorsqu'une commande \"G1\" est envoy\u00e9e \u00e0 l'h\u00f4te Klippy et se termine lorsque les impulsions de pas correspondantes sont produites sur le micro-contr\u00f4leur. Cette section d\u00e9crit le flux du code d'une commande de d\u00e9placement typique. Le document cin\u00e9matiques fournit des informations suppl\u00e9mentaires sur la m\u00e9canique des mouvements. Le traitement d'une commande de d\u00e9placement commence dans gcode.py. Le but de gcode.py est de traduire le G-code en appels internes. Une commande G1 invoquera cmd_G1() dans klippy/extras/gcode_move.py. Le code gcode_move.py g\u00e8re les changements d'origine (par exemple, G92), les changements de positions relatives et absolues (par exemple, G90), et les changements d'unit\u00e9s (par exemple, F6000=100mm/s). Le chemin du code pour un d\u00e9placement est : _process_data() -> _process_commands() -> cmd_G1() . Finalement, la classe ToolHead est invoqu\u00e9e pour ex\u00e9cuter la demande r\u00e9elle : cmd_G1() -> ToolHead.move() La classe ToolHead (dans toolhead.py) g\u00e8re le \"look-ahead\" et suit la temporisation des actions d'impression. Le chemin du code principal pour un d\u00e9placement est : ToolHead.move() -> MoveQueue.add_move() -> MoveQueue.flush() -> Move.set_junction() -> ToolHead._process_moves() . ToolHead.move() cr\u00e9e un objet Move() avec les param\u00e8tres du d\u00e9placement (dans l'espace cart\u00e9sien et en unit\u00e9s de secondes et de millim\u00e8tres). La classe cin\u00e9matique a la possibilit\u00e9 de v\u00e9rifier chaque mouvement ( ToolHead.move() -> kin.check_move() ). Les classes cin\u00e9matiques sont situ\u00e9es dans le r\u00e9pertoire klippy/kinematics/. Le code check_move() peut lever une erreur si le d\u00e9placement n'est pas valide. Si check_move() se termine avec succ\u00e8s, alors la cin\u00e9matique sous-jacente doit \u00eatre capable de g\u00e9rer le d\u00e9placement. MoveQueue.add_move() place l'objet move dans la file d'attente \"look-ahead\". MoveQueue.flush() d\u00e9termine les vitesses de d\u00e9but et de fin de chaque mouvement. Move.set_junction() impl\u00e9mente le \"g\u00e9n\u00e9rateur de trap\u00e8ze\" sur un mouvement. Le \"g\u00e9n\u00e9rateur de trap\u00e8ze\" divise chaque mouvement en trois parties : une phase d'acc\u00e9l\u00e9ration constante, suivie d'une phase de vitesse constante, puis d'une phase de d\u00e9c\u00e9l\u00e9ration constante. Chaque d\u00e9placement contient ces trois phases dans cet ordre, certaines phases pouvant \u00eatre de dur\u00e9e nulle. Lorsque ToolHead._process_moves() est appel\u00e9, tout ce qui concerne le d\u00e9placement est connu : sa position de d\u00e9part, sa position d'arriv\u00e9e, son acc\u00e9l\u00e9ration, sa vitesse de d\u00e9part/de croisi\u00e8re/de fin, et la distance parcourue pendant l'acc\u00e9l\u00e9ration/la croisi\u00e8re/la d\u00e9c\u00e9l\u00e9ration. Toutes ces informations sont stock\u00e9es dans la classe Move() et sont dans l'espace cart\u00e9sien en unit\u00e9s de millim\u00e8tres et de secondes. Klipper utilise un solveur it\u00e9ratif afin de g\u00e9n\u00e9rer les d\u00e9lais des pas pour chaque moteur pas \u00e0 pas. Pour des raisons d'efficacit\u00e9, les d\u00e9lais d'impulsion des pas sont g\u00e9n\u00e9r\u00e9s en code C. Les mouvements sont d'abord plac\u00e9s dans une \"file d'attente de mouvements trap\u00e9zo\u00efdaux\" : ToolHead._process_moves() -> trapq_append() (dans klippy/chelper/trapq.c). Les d\u00e9lais de pas sont ensuite g\u00e9n\u00e9r\u00e9s : ToolHead._process_moves() -> ToolHead._update_move_time() -> MCU_Stepper.generate_steps() -> itersolve_generate_steps() -> itersolve_gen_steps_range() (dans klippy/chelper/itersolve.c). Le but du solveur it\u00e9ratif est de trouver les d\u00e9lais de pas \u00e0 partir d'une fonction calculant la position du moteur \u00e0 partir du temps. Ceci est fait en \"devinant\" de mani\u00e8re r\u00e9p\u00e9t\u00e9e plusieurs d\u00e9lais jusqu'\u00e0 ce que la formule de position du pas renvoie la position d\u00e9sir\u00e9e du pas suivant sur le moteur. Le retour d'information produit par chaque estimation est utilis\u00e9 afin d'am\u00e9liorer les estimations futures, de sorte que le processus converge rapidement vers le d\u00e9lai souhait\u00e9. Les formules de position cin\u00e9matique du moteur sont situ\u00e9es dans le r\u00e9pertoire klippy/chelper/ (par exemple, kin_cart.c, kin_corexy.c, kin_delta.c, kin_extruder.c). Notez que l'extrudeuse est g\u00e9r\u00e9e dans sa propre classe cin\u00e9matique : ToolHead._process_moves() -> PrinterExtruder.move() . Puisque la classe Move() sp\u00e9cifie le d\u00e9lai exact du mouvement et que les impulsions de pas sont envoy\u00e9es au micro-contr\u00f4leur avec un timing sp\u00e9cifique, les mouvements du moteur produits par la classe de l'extrudeuse seront synchronis\u00e9s avec le mouvement de la t\u00eate m\u00eame si le code est s\u00e9par\u00e9. Apr\u00e8s que le solveur it\u00e9ratif ait calcul\u00e9 les d\u00e9lais de pas, ils sont ajout\u00e9s \u00e0 un tableau : itersolve_gen_steps_range() -> stepcompress_append() (dans klippy/chelper/stepcompress.c). Le tableau (struct stepcompress.queue) stocke les dur\u00e9es correspondantes du compteur d'horloge du micro-contr\u00f4leur pour chaque \u00e9tape. Ici, la valeur du \"compteur d'horloge du micro-contr\u00f4leur\" correspond directement au compteur mat\u00e9riel du micro-contr\u00f4leur - elle est relative \u00e0 la derni\u00e8re mise sous tension du micro-contr\u00f4leur. La prochaine \u00e9tape majeure est de compresser les \u00e9tapes : stepcompress_flush() -> compress_bisect_add() (dans klippy/chelper/stepcompress.c). Ce code g\u00e9n\u00e8re et encode une s\u00e9rie de commandes \"queue_step\" du micro-contr\u00f4leur correspondant \u00e0 la liste des dur\u00e9es de pas du moteur construite \u00e0 l'\u00e9tape pr\u00e9c\u00e9dente. Ces commandes \"queue_step\" sont ensuite mises en file d'attente, hi\u00e9rarchis\u00e9es et envoy\u00e9es au micro-contr\u00f4leur (via stepcompress.c:steppersync et serialqueue.c:serialqueue). Le traitement des commandes queue_step sur le micro-contr\u00f4leur commence dans src/command.c qui analyse la commande et appelle command_queue_step() . Le code command_queue_step() (dans src/stepper.c) ajoute simplement les param\u00e8tres de chaque commande queue_step \u00e0 une file d'attente par moteur. En fonctionnement normal, la commande queue_step est analys\u00e9e et mise en file d'attente au moins 100ms avant le moment de son premier pas. Enfin, la g\u00e9n\u00e9ration des \u00e9v\u00e9nements de pas du moteur est faite dans stepper_event() . Elle est appel\u00e9e depuis l'interruption du compteur mat\u00e9riel \u00e0 l'heure pr\u00e9vue du premier pas. Le code stepper_event() g\u00e9n\u00e8re une impulsion de pas et se reprogramme ensuite pour s'ex\u00e9cuter au moment de l'impulsion de pas suivante pour les param\u00e8tres queue_step donn\u00e9s. Les param\u00e8tres pour chaque commande queue_step sont \"interval\", \"count\", et \"add\". A un haut niveau, stepper_event() ex\u00e9cute la commande suivante, 'count' fois : do_step() ; next_wake_time = last_wake_time + interval ; interval += add; Ce qui pr\u00e9c\u00e8de peut sembler beaucoup de complexit\u00e9 pour l'ex\u00e9cution d'un mouvement. Cependant, les seules parties vraiment int\u00e9ressantes se trouvent dans les classes ToolHead et kinematic. C'est cette partie du code qui pr\u00e9cise les mouvements et leurs dur\u00e9es. Les autres parties du traitement sont essentiellement de la communication et de la plomberie.","title":"Flux du code d'une commande de d\u00e9placement"},{"location":"Code_Overview.html#ajout-dun-module-hote","text":"Le code h\u00f4te de Klippy a une capacit\u00e9 de chargement dynamique de modules. Si une section de configuration nomm\u00e9e \"[mon_module]\" est trouv\u00e9e dans le fichier de configuration de l'imprimante, le logiciel tentera automatiquement de charger le module python klippy/extras/mon_module.py . Ce syst\u00e8me de modules est la m\u00e9thode pr\u00e9f\u00e9r\u00e9e pour ajouter de nouvelles fonctionnalit\u00e9s \u00e0 Klipper. La fa\u00e7on la plus simple d'ajouter un nouveau module est d'utiliser un module existant comme r\u00e9f\u00e9rence - voir klippy/extras/servo.py comme exemple. Les \u00e9l\u00e9ments suivants peuvent \u00e9galement \u00eatre utiles : L'ex\u00e9cution du module commence dans la fonction load_config() au niveau du module (pour les sections de configuration de la forme [mon_module]) ou dans load_config_prefix() (pour les sections de configuration de la forme [mon_module mon_nom]). On passe \u00e0 cette fonction un objet \"config\" et elle doit retourner un nouvel \"objet imprimante\" associ\u00e9 \u00e0 la section de configuration donn\u00e9e. Durant le processus d'instanciation d'un nouvel objet imprimante, l'objet config peut \u00eatre utilis\u00e9 pour lire les param\u00e8tres de la section config donn\u00e9e. Ceci est fait en utilisant les m\u00e9thodes config.get() , config.getfloat() , config.getint() , etc. Assurez-vous de lire toutes les valeurs de la configuration pendant la construction de l'objet imprimante - si l'utilisateur sp\u00e9cifie un param\u00e8tre de configuration qui n'est pas lu pendant cette phase, il sera suppos\u00e9 qu'il s'agit d'une faute de frappe dans la configuration et une erreur sera lev\u00e9e. Utilisez la m\u00e9thode config.get_printer() pour obtenir une r\u00e9f\u00e9rence \u00e0 la classe principale \"printer\". Cette classe \"printer\" stocke les r\u00e9f\u00e9rences de tous les \"objets imprimante\" instanci\u00e9s. Utilisez la m\u00e9thode printer.lookup_object() pour trouver des r\u00e9f\u00e9rences \u00e0 d'autres objets imprimante. Presque toutes les fonctionnalit\u00e9s (m\u00eame les modules cin\u00e9matiques de base) sont encapsul\u00e9es dans un de ces objets imprimante. Notez, cependant, que lorsqu'un nouveau module est instanci\u00e9, tous les autres objets d'impression n'auront pas encore \u00e9t\u00e9 instanci\u00e9s. Les modules \"gcode\" et \"pins\" seront toujours disponibles, mais pour les autres modules, il est pr\u00e9f\u00e9rable de diff\u00e9rer la recherche. Enregistrez les gestionnaires d'\u00e9v\u00e9nements en utilisant la m\u00e9thode printer.register_event_handler() si le code doit \u00eatre appel\u00e9 lors d'\"\u00e9v\u00e9nements\" d\u00e9clench\u00e9s par d'autres objets imprimante. Chaque nom d'\u00e9v\u00e9nement est une cha\u00eene de caract\u00e8res, et par convention, c'est le nom du module source principal d\u00e9clenchant l'\u00e9v\u00e9nement avec un nom court pour l'action produite (par exemple, \"klippy:connect\"). Les param\u00e8tres pass\u00e9s \u00e0 chaque gestionnaire d'\u00e9v\u00e9nement sont sp\u00e9cifiques \u00e0 l'\u00e9v\u00e9nement en question (tout comme le traitement des exceptions et le contexte d'ex\u00e9cution). Deux \u00e9v\u00e9nements de d\u00e9marrage courants sont : klippy:connect - Cet \u00e9v\u00e9nement est g\u00e9n\u00e9r\u00e9 apr\u00e8s l'instanciation de tous les objets imprimante. Il est couramment utilis\u00e9 pour rechercher d'autres objets imprimante, pour v\u00e9rifier les param\u00e8tres de configuration et pour effectuer une premi\u00e8re \"prise de contact\" avec le mat\u00e9riel de l'imprimante. klippy:ready - Cet \u00e9v\u00e9nement est g\u00e9n\u00e9r\u00e9 apr\u00e8s que tous les gestionnaires de connexion se soient termin\u00e9s avec succ\u00e8s. Il indique que l'imprimante est en train de passer \u00e0 l'\u00e9tat pr\u00eat \u00e0 g\u00e9rer les op\u00e9rations normales. Ne d\u00e9clenchez pas d'erreur dans ce rappel. S'il y a une erreur dans la configuration de l'utilisateur, assurez-vous de la signaler pendant les phases load_config() ou \"connect event\". Utilisez soit raise config.error(\"mon erreur\") soit raise printer.config_error(\"mon erreur\") pour signaler l'erreur. Utilisez le module \"pins\" pour configurer une broche sur un micro-contr\u00f4leur. Ceci est typiquement fait avec quelque chose de similaire \u00e0 printer.lookup_object(\"pins\").setup_pin(\"pwm\", config.get(\"my_pin\")) . L'objet retourn\u00e9 peut alors \u00eatre command\u00e9 au moment de l'ex\u00e9cution. Si l'objet imprimante d\u00e9finit une m\u00e9thode get_status() , le module peut exporter des informations d'\u00e9tat via des macros et via le serveur API . La m\u00e9thode get_status() doit retourner un dictionnaire Python dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs des entiers, des flottants, des cha\u00eenes de caract\u00e8res, des listes, des dictionnaires, True, False ou None. Les tuples (et les tuples nomm\u00e9s) peuvent \u00e9galement \u00eatre utilis\u00e9s (ils apparaissent comme des listes lorsqu'on y acc\u00e8de via le serveur API). Les listes et les dictionnaires export\u00e9s doivent \u00eatre trait\u00e9s comme \"immuables\" - si leur contenu change, un nouvel objet doit \u00eatre renvoy\u00e9 par get_status() , sinon le serveur API ne d\u00e9tectera pas ces changements. Si le module doit acc\u00e9der \u00e0 la temporisation du syst\u00e8me ou \u00e0 des descripteurs de fichiers externes, utilisez printer.get_reactor() pour obtenir l'acc\u00e8s \u00e0 la classe globale \"event reactor\". Cette classe de r\u00e9acteur permet de programmer des temporisations, d'attendre des entr\u00e9es sur des descripteurs de fichiers, et d'\"endormir\" le code h\u00f4te. N'utilisez pas de variables globales. Tous les \u00e9tats doivent \u00eatre stock\u00e9s dans l'objet imprimante renvoy\u00e9 par la fonction load_config() . Ceci est important car sinon la commande RESTART pourrait ne pas fonctionner comme pr\u00e9vu. De m\u00eame, pour des raisons similaires, si des fichiers externes (ou des sockets) sont ouverts, assurez-vous d'enregistrer un gestionnaire d'\u00e9v\u00e9nement \"klippy:disconnect\" et de les fermer \u00e0 partir de ce rappel. \u00c9vitez d'acc\u00e9der aux variables membres internes (ou d'appeler les m\u00e9thodes commen\u00e7ant par un trait de soulignement) d'autres objets imprimante. Le respect de cette convention facilite la gestion des modifications futures. Il est recommand\u00e9 d'attribuer une valeur \u00e0 toutes les variables membres dans le constructeur Python des classes Python. (Et donc d'\u00e9viter d'utiliser la capacit\u00e9 de Python \u00e0 cr\u00e9er dynamiquement de nouvelles variables membres.) Si une variable Python doit stocker une valeur en virgule flottante, il est recommand\u00e9 de toujours affecter et manipuler cette variable avec des constantes en virgule flottante (et de ne jamais utiliser de constantes enti\u00e8res). Par exemple, pr\u00e9f\u00e9rez self.speed = 1. \u00e0 self.speed = 1 , et pr\u00e9f\u00e9rez self.speed = 2. * x plut\u00f4t que self.speed = 2 * x . L'utilisation coh\u00e9rente des valeurs \u00e0 virgule flottante peut \u00e9viter des bizarreries difficiles \u00e0 d\u00e9boguer dans les conversions de types Python. Si vous soumettez le module pour qu'il soit inclus dans le code principal de Klipper, veillez \u00e0 placer un avis de copyright en haut du module. Consultez les modules existants pour conna\u00eetre le format pr\u00e9f\u00e9r\u00e9.","title":"Ajout d'un module h\u00f4te"},{"location":"Code_Overview.html#ajout-de-nouvelles-cinematiques","text":"Cette section fournit quelques conseils pour ajouter le support \u00e0 Klipper de types suppl\u00e9mentaires de cin\u00e9matiques d'imprimante. Ce type d'activit\u00e9 n\u00e9cessite une excellente compr\u00e9hension des formules math\u00e9matiques de la cin\u00e9matique cible. Elle requiert \u00e9galement des comp\u00e9tences en mati\u00e8re de d\u00e9veloppement de logiciels, m\u00eame s'il suffit de mettre \u00e0 jour le logiciel h\u00f4te. Les \u00e9tapes utiles : Commencez par \u00e9tudier la section \" code de flux d'un mouvement \" et le document cin\u00e9matiques . Passez en revue les classes cin\u00e9matiques existantes dans le r\u00e9pertoire klippy/kinematics/. Les classes cin\u00e9matiques sont charg\u00e9es de convertir le mouvement en coordonn\u00e9es cart\u00e9siennes en un mouvement sur chaque moteur. On devrait \u00eatre capable de copier un de ces fichiers comme point de d\u00e9part. Impl\u00e9mentez les fonctions de position cin\u00e9matique du moteur en C pour chaque moteur si elles ne sont pas d\u00e9j\u00e0 disponibles (voir kin_cart.c, kin_corexy.c, et kin_delta.c dans klippy/chelper/). La fonction doit appeler move_get_coord() pour convertir une dur\u00e9e de d\u00e9placement donn\u00e9e (en secondes) en coordonn\u00e9es cart\u00e9siennes (en millim\u00e8tres), et ensuite calculer la position souhait\u00e9e du moteur (en millim\u00e8tres) \u00e0 partir de ces coordonn\u00e9es cart\u00e9siennes. Impl\u00e9mentez la m\u00e9thode calc_position() dans la nouvelle classe cin\u00e9matique. Cette m\u00e9thode calcule la position de la t\u00eate de l'outil en coordonn\u00e9es cart\u00e9siennes \u00e0 partir de la position de chaque moteur. Elle n'a pas besoin d'\u00eatre efficace car elle n'est typiquement appel\u00e9e que pendant les op\u00e9rations de mise \u00e0 l'origine et de palpage. Autres m\u00e9thodes. Impl\u00e9mentez les m\u00e9thodes check_move() , get_status() , get_steppers() , home() , et set_position() . Ces fonctions sont typiquement utilis\u00e9es pour fournir des v\u00e9rifications sp\u00e9cifiques \u00e0 la cin\u00e9matique. Cependant, au d\u00e9but du d\u00e9veloppement, on peut utiliser du code passe-partout ici. Impl\u00e9menter des cas de test. Cr\u00e9ez un fichier g-code avec une s\u00e9rie de mouvements pouvant tester des cas importants pour la cin\u00e9matique donn\u00e9e. Suivez la documentation de d\u00e9bogage pour convertir ce fichier g-code en commandes de micro-contr\u00f4leur. Ceci est utile pour tester les cas extr\u00eames et v\u00e9rifier les r\u00e9gressions.","title":"Ajout de nouvelles cin\u00e9matiques"},{"location":"Code_Overview.html#portage-sur-un-nouveau-microcontroleur","text":"Cette section fournit quelques conseils sur le portage du code du microcontr\u00f4leur de Klipper vers une nouvelle architecture. Ce type d'activit\u00e9 n\u00e9cessite une bonne connaissance du d\u00e9veloppement embarqu\u00e9 et un acc\u00e8s pratique au microcontr\u00f4leur cible. Les \u00e9tapes utiles : Commencez par identifier toutes les biblioth\u00e8ques tierces qui seront utilis\u00e9es pendant le portage. Les exemples courants incluent les wrappers \"CMSIS\" et les biblioth\u00e8ques \"HAL\" des fabricants. Tout code tiers doit \u00eatre compatible avec la licence GNU GPLv3. Le code tiers doit \u00eatre livr\u00e9 dans le r\u00e9pertoire Klipper lib/. Mettez \u00e0 jour le fichier lib/README en indiquant o\u00f9 et quand la biblioth\u00e8que a \u00e9t\u00e9 obtenue. Il est pr\u00e9f\u00e9rable de copier le code dans le d\u00e9p\u00f4t Klipper sans modification, mais si des modifications sont n\u00e9cessaires, elles doivent \u00eatre indiqu\u00e9es explicitement dans le fichier lib/README. Cr\u00e9er un nouveau sous-r\u00e9pertoire d'architecture dans le r\u00e9pertoire src/ et ajouter le support initial de Kconfig et Makefile. Utilisez les architectures existantes comme guide. Le simulateur src/simulator fournit un exemple de base pour un point de d\u00e9part minimal. La premi\u00e8re t\u00e2che principale de codage est d'apporter le support de communication \u00e0 la carte cible. C'est l'\u00e9tape la plus difficile dans un nouveau portage. Une fois que la communication de base fonctionne, les autres \u00e9tapes ont tendance \u00e0 \u00eatre beaucoup plus faciles. Il est typique d'utiliser un dispositif s\u00e9rie de type UART pendant le d\u00e9veloppement initial car ces types de dispositifs mat\u00e9riels sont g\u00e9n\u00e9ralement plus faciles \u00e0 activer et \u00e0 contr\u00f4ler. Pendant cette phase, faites un usage lib\u00e9ral du code d'aide du r\u00e9pertoire src/generic/ (v\u00e9rifiez comment src/simulator/Makefile inclut le code C g\u00e9n\u00e9rique dans la compilation). Il est \u00e9galement n\u00e9cessaire de d\u00e9finir timer_read_time() (qui renvoie l'horloge syst\u00e8me actuelle) dans cette phase, mais il n'est pas n\u00e9cessaire de supporter compl\u00e8tement la gestion des irq des timers. Familiarisez-vous avec l'outil console.py (comme d\u00e9crit dans le document de d\u00e9bogage ) et v\u00e9rifiez la connectivit\u00e9 au microcontr\u00f4leur avec cet outil. Cet outil traduit le protocole de communication de bas niveau du microcontr\u00f4leur en une forme lisible par l'homme. Ajouter le support pour la distribution des timers \u00e0 partir des interruptions mat\u00e9rielles. Voir Klipper commit 970831ee comme exemple des \u00e9tapes 1-5 r\u00e9alis\u00e9es pour l'architecture LPC176x. Apporter le support de base des entr\u00e9es et sorties GPIO. Voir Klipper commit c78b9076 comme exemple. Faire appara\u00eetre des p\u00e9riph\u00e9riques suppl\u00e9mentaires - par exemple, voir Klipper commit 65613aed , c812a40a , et c381d03a . Cr\u00e9ez un exemple de fichier de configuration Klipper dans le r\u00e9pertoire config/. Testez le micro-contr\u00f4leur avec le programme principal klippy.py. Pensez \u00e0 ajouter des cas de test de construction dans le r\u00e9pertoire test/. Conseils suppl\u00e9mentaires pour le codage : \u00c9vitez d'utiliser des \"champs de bits C\" pour acc\u00e9der aux registres d'E/S ; pr\u00e9f\u00e9rez les op\u00e9rations directes de lecture et d'\u00e9criture d'entiers de 32, 16 ou 8 bits. Les sp\u00e9cifications du langage C ne pr\u00e9cisent pas clairement comment le compilateur doit impl\u00e9menter les champs de bits C (par exemple, l'endianness et la disposition des bits), et il est difficile de d\u00e9terminer quelles op\u00e9rations d'E/S se produiront lors de la lecture ou de l'\u00e9criture d'un champ de bits C. Pr\u00e9f\u00e9rez l'\u00e9criture de valeurs explicites dans les registres d'E/S \u00e0 l'utilisation d'op\u00e9rations de lecture-modification-\u00e9criture. Autrement dit, si l'on met \u00e0 jour un champ dans un registre d'E/S dont les autres champs ont des valeurs connues, il est pr\u00e9f\u00e9rable d'\u00e9crire explicitement le contenu complet du registre. Les \u00e9critures explicites produisent un code plus petit, plus rapide et plus facile \u00e0 d\u00e9boguer.","title":"Portage sur un nouveau microcontr\u00f4leur"},{"location":"Code_Overview.html#les-systemes-de-coordonnees","text":"En interne, Klipper suit principalement la position de la t\u00eate de l'outil en coordonn\u00e9es cart\u00e9siennes relatives au syst\u00e8me de coordonn\u00e9es sp\u00e9cifi\u00e9 dans le fichier de configuration. C'est-\u00e0-dire que la plupart du code de Klipper ne conna\u00eetra jamais de changement de syst\u00e8me de coordonn\u00e9es. Si l'utilisateur fait une demande pour changer l'origine (par exemple, une commande G92 ) alors cet effet est obtenu en traduisant les commandes futures vers le syst\u00e8me de coordonn\u00e9es primaires. Cependant, dans certains cas, il est utile d'obtenir la position de la t\u00eate de l'outil dans un autre syst\u00e8me de coordonn\u00e9es et Klipper dispose de plusieurs outils pour faciliter cela. Vous pouvez le constater en ex\u00e9cutant la commande GET_POSITION. Par exemple : Send: GET_POSITION Recv: // mcu: stepper_a:-2060 stepper_b:-1169 stepper_c:-1613 Recv: // stepper: stepper_a:457.254159 stepper_b:466.085669 stepper_c:465.382132 Recv: // kinematic: X:8.339144 Y:-3.131558 Z:233.347121 Recv: // toolhead: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000 Recv: // gcode: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000 Recv: // gcode base: X:0.000000 Y:0.000000 Z:0.000000 E:0.000000 Recv: // gcode homing: X:0.000000 Y:0.000000 Z:0.000000 La position \"mcu\" ( stepper.get_mcu_position() dans le code) est le nombre total de pas que le micro-contr\u00f4leur a \u00e9mis dans un sens positif moins le nombre de pas \u00e9mis dans un sens n\u00e9gatif depuis la derni\u00e8re r\u00e9initialisation du micro-contr\u00f4leur. Si le robot est en mouvement lorsque la requ\u00eate est \u00e9mise, la valeur rapport\u00e9e inclut les mouvements mis en m\u00e9moire tampon dans le microcontr\u00f4leur, mais pas les mouvements de la file d'attente de surveillance. La position \"stepper\" ( stepper.get_commanded_position() ) est la position du moteur donn\u00e9 telle qu'elle est suivie par le code cin\u00e9matique. Cela correspond g\u00e9n\u00e9ralement \u00e0 la position (en mm) du chariot le long de son rail, par rapport \u00e0 la position_endstop indiqu\u00e9e dans le fichier de configuration. (Si le robot est en mouvement lorsque la requ\u00eate est \u00e9mise, la valeur rapport\u00e9e inclut les mouvements mis en m\u00e9moire tampon sur le micro-contr\u00f4leur, mais n'inclut pas les mouvements de la file d'attente look-ahead. On peut utiliser les appels toolhead.flush_step_generation() ou toolhead.wait_moves() pour vider compl\u00e8tement les codes de look-ahead et de g\u00e9n\u00e9ration de pas. La position \"kinematic\" ( kin.calc_position() ) est la position cart\u00e9sienne de la t\u00eate de l'outil telle que d\u00e9riv\u00e9e des positions \"pas \u00e0 pas\" et est relative au syst\u00e8me de coordonn\u00e9es sp\u00e9cifi\u00e9 dans le fichier de configuration. Cela peut diff\u00e9rer de la position cart\u00e9sienne demand\u00e9e en raison de la granularit\u00e9 des moteurs pas \u00e0 pas. Si le robot est en mouvement lorsque les positions \"stepper\" sont prises, la valeur rapport\u00e9e inclut les mouvements mis en m\u00e9moire tampon sur le micro-contr\u00f4leur, mais n'inclut pas les mouvements de la file d'attente look-ahead. On peut utiliser les appels toolhead.flush_step_generation() ou toolhead.wait_moves() pour vider compl\u00e8tement le code de look-ahead et de g\u00e9n\u00e9ration de pas. La position de la t\u00eate d'outil ( toolhead.get_position() ) est la derni\u00e8re position demand\u00e9e de la t\u00eate d'outil en coordonn\u00e9es cart\u00e9siennes par rapport au syst\u00e8me de coordonn\u00e9es sp\u00e9cifi\u00e9 dans le fichier de configuration. Si le robot est en mouvement lorsque la requ\u00eate est \u00e9mise, la valeur rapport\u00e9e inclut tous les d\u00e9placements demand\u00e9s (m\u00eame ceux dans les tampons en attente d'\u00eatre \u00e9mis vers les pilotes de moteurs pas \u00e0 pas). La position \"gcode\" est la derni\u00e8re position demand\u00e9e par une commande G1 (ou G0 ) en coordonn\u00e9es cart\u00e9siennes par rapport au syst\u00e8me de coordonn\u00e9es sp\u00e9cifi\u00e9 dans le fichier de configuration. Elle peut diff\u00e9rer de la position \"toolhead\" si une transformation g-code (par exemple, bed_mesh, bed_tilt, skew_correction) est en cours. Cela peut diff\u00e9rer des coordonn\u00e9es r\u00e9elles sp\u00e9cifi\u00e9es dans la derni\u00e8re commande G1 si l'origine du gcode a \u00e9t\u00e9 modifi\u00e9e (par exemple, G92 , SET_GCODE_OFFSET , M221 ). La commande M114 ( gcode_move.get_status()['gcode_position'] ) indiquera la derni\u00e8re position du g-code par rapport au syst\u00e8me de coordonn\u00e9es actuel du g-code. La \"base gcode\" est l'emplacement de l'origine du g-code en coordonn\u00e9es cart\u00e9siennes par rapport au syst\u00e8me de coordonn\u00e9es sp\u00e9cifi\u00e9 dans le fichier de configuration. Les commandes telles que G92 , SET_GCODE_OFFSET , et M221 modifient cette valeur. Le \"gcode homing\" est l'emplacement \u00e0 utiliser pour l'origine du g-code (en coordonn\u00e9es cart\u00e9siennes par rapport au syst\u00e8me de coordonn\u00e9es sp\u00e9cifi\u00e9 dans le fichier de configuration) apr\u00e8s une commande de mise \u00e0 l'origine G28 . La commande SET_GCODE_OFFSET peut modifier cette valeur.","title":"Les syst\u00e8mes de coordonn\u00e9es"},{"location":"Code_Overview.html#temporisation","text":"La manipulation des horloges, des dur\u00e9es et des horodatages est fondamentale pour le fonctionnement de Klipper. Celui-ci ex\u00e9cute des actions sur l'imprimante en programmant des \u00e9v\u00e9nements qui se produiront dans un avenir proche. Par exemple, pour allumer un ventilateur, le code peut programmer un changement sur une broche GPIO dans 100 ms. Il est rare que le code tente d'effectuer une action instantan\u00e9e. Ainsi, la gestion du temps dans Klipper est essentielle pour un fonctionnement correct. Il existe trois types de temporisations suivis en interne dans le logiciel h\u00f4te Klipper : Heure du syst\u00e8me. L'heure syst\u00e8me utilise l'horloge du syst\u00e8me - c'est un nombre \u00e0 virgule flottante stock\u00e9 sous forme de secondes (g\u00e9n\u00e9ralement) relatif \u00e0 la date du dernier d\u00e9marrage de l'ordinateur h\u00f4te. Les temps syst\u00e8me ont un usage limit\u00e9 dans le logiciel - ils sont principalement utilis\u00e9s lors de l'interaction avec le syst\u00e8me d'exploitation. Dans le code h\u00f4te, les heures syst\u00e8me sont souvent stock\u00e9es dans des variables nomm\u00e9es eventtime ou curtime . Temps d'impression. Le temps d'impression est synchronis\u00e9 avec l'horloge du micro-contr\u00f4leur principal (le micro-contr\u00f4leur d\u00e9fini dans la section \"[mcu]\" de la configuration). C'est un nombre \u00e0 virgule flottante stock\u00e9 en secondes relatif \u00e0 la date du dernier red\u00e9marrage du micro-contr\u00f4leur principal. Il est possible de convertir un \"temps d'impression\" en horloge mat\u00e9rielle du micro-contr\u00f4leur principal en multipliant le temps d'impression par le taux de fr\u00e9quence du mcu configur\u00e9 statiquement. Le code h\u00f4te de haut niveau utilise les temps d'impression pour calculer presque toutes les actions physiques (par exemple, le mouvement de la t\u00eate, les changements de chauffage, etc.) Dans le code h\u00f4te, les temps d'impression sont g\u00e9n\u00e9ralement stock\u00e9s dans des variables nomm\u00e9es print_time ou move_time . Horloge MCU. Il s'agit du compteur d'horloge mat\u00e9riel de chaque micro-contr\u00f4leur. Il est stock\u00e9 sous forme d'un nombre entier et son taux de mise \u00e0 jour est relatif \u00e0 la fr\u00e9quence du micro-contr\u00f4leur donn\u00e9. Le logiciel h\u00f4te convertit ses temps internes en horloges avant de les transmettre \u00e0 l'unit\u00e9 centrale. Le code de l'unit\u00e9 centrale de traitement ne suit jamais le temps qu'en ticks d'horloge. Dans le code h\u00f4te, les valeurs d'horloge sont suivies sous forme d'entiers de 64 bits, alors que le code de l'unit\u00e9 centrale utilise des entiers de 32 bits. Dans le code h\u00f4te, les horloges sont g\u00e9n\u00e9ralement stock\u00e9es dans des variables dont les noms contiennent clock ou ticks . La conversion entre les diff\u00e9rents formats de temps est principalement impl\u00e9ment\u00e9e dans le code klippy/clocksync.py . Quelques \u00e9l\u00e9ments \u00e0 prendre en compte lors de la r\u00e9vision du code : Horloges 32bit et 64bit : Pour r\u00e9duire la bande passante et am\u00e9liorer l'efficacit\u00e9 du micro-contr\u00f4leur, les horloges sur le micro-contr\u00f4leur sont suivies comme des entiers 32bit. Lors de la comparaison de deux horloges dans le code mcu, la fonction timer_is_before() doit toujours \u00eatre utilis\u00e9e pour s'assurer que les renversements d'entiers sont trait\u00e9s correctement. Le logiciel h\u00f4te convertit les horloges 32bit en horloges 64bit en ajoutant les bits de poids fort du dernier timestamp mcu qu'il a re\u00e7u - aucun message du mcu n'est jamais plus de 2^31 ticks d'horloge dans le futur ou le pass\u00e9, donc cette conversion n'est jamais ambigu\u00eb. L'h\u00f4te convertit les horloges de 64 bits en horloges de 32 bits en tronquant simplement les bits de poids fort. Pour s'assurer qu'il n'y a pas d'ambigu\u00eft\u00e9 dans cette conversion, le code klippy/chelper/serialqueue.c mettra en m\u00e9moire tampon les messages jusqu'\u00e0 ce qu'ils soient dans les 2^31 ticks d'horloge de leur temps cible. Microcontr\u00f4leurs multiples : Le logiciel h\u00f4te permet d'utiliser plusieurs microcontr\u00f4leurs sur une seule imprimante. Dans ce cas, l'\"horloge MCU\" de chaque microcontr\u00f4leur est suivie s\u00e9par\u00e9ment. Le code clocksync.py g\u00e8re la d\u00e9rive de l'horloge entre les micro-contr\u00f4leurs en modifiant la fa\u00e7on dont il convertit le \"temps d'impression\" en \"horloge MCU\". Sur les mcus secondaires, la fr\u00e9quence du mcu utilis\u00e9e dans cette conversion est r\u00e9guli\u00e8rement mise \u00e0 jour pour tenir compte de la d\u00e9rive mesur\u00e9e.","title":"Temporisation"},{"location":"Command_Templates.html","text":"Mod\u00e8les de commandes \u00b6 Ce document fournit des informations sur l'impl\u00e9mentation des s\u00e9quences de commandes G-Code dans les sections de configuration gcode_macro (et similaires). Nommage des macros de G-code \u00b6 La casse n'est pas importante pour le nom de la macro G-Code - MA_MACRO et ma_macro \u00e9valueront la m\u00eame chose et peuvent \u00eatre appel\u00e9es en majuscules ou en minuscules. Si des nombres sont utilis\u00e9s dans le nom de la macro, ils doivent tous se trouver \u00e0 la fin du nom (par exemple, TEST_MACRO25 est valide, mais MACRO25_TEST3 ne l'est pas). Formatage du G-Code dans la config \u00b6 L'indentation est importante lors de la d\u00e9finition d'une macro dans le fichier de configuration. Pour sp\u00e9cifier une s\u00e9quence G-Code multiligne, il est important que chaque ligne ait une indentation appropri\u00e9e. Par exemple\u202f: [gcode_macro blink_led] gcode: SET_PIN PIN=my_led VALUE=1 G4 P2000 SET_PIN PIN=my_led VALUE=0 L'option de configuration gcode: commence toujours au d\u00e9but de la ligne et les lignes suivantes de la macro G-Code ne commencent jamais au d\u00e9but. Ajouter une description \u00e0 votre macro \u00b6 Pour vous aider \u00e0 identifier la fonctionnalit\u00e9, une courte description peut \u00eatre ajout\u00e9e. Ajoutez description\u202f: avec un texte court pour d\u00e9crire la fonctionnalit\u00e9. La valeur par d\u00e9faut est \"Macro G-Code\". Par exemple\u202f: [gcode_macro blink_led] description: Blink my_led one time gcode: SET_PIN PIN=my_led VALUE=1 G4 P2000 SET_PIN PIN=my_led VALUE=0 Le terminal affichera la description lorsque vous utiliserez la commande HELP ou la fonction de saisie semi-automatique. Enregistrer/Restaurer l'\u00e9tat pour les d\u00e9placements G-Code \u00b6 Le langage de commande G-Code peut \u00eatre difficile \u00e0 utiliser. Le m\u00e9canisme standard pour d\u00e9placer la t\u00eate d'outil se fait via la commande G1 (la commande G0 est un alias pour G1 et elle peut \u00eatre utilis\u00e9e \u00e0 la place de G1 et inversement). Cependant, cette commande repose sur la configuration \"G-Code parsing state\" d\u00e9finie par M82 , M83 , G90 , G91 , G92 et les commandes pr\u00e9c\u00e9dentes G1 . Lors de la cr\u00e9ation d'une macro G-Code, il est conseill\u00e9 de toujours d\u00e9finir explicitement l'\u00e9tat d'analyse du G-Code avant d'\u00e9mettre une commande G1 . (Sinon, il y a un risque que la commande G1 fasse une demande ind\u00e9sirable.) Une fa\u00e7on courante d'y parvenir consiste \u00e0 encapsuler les mouvements G1 avec SAVE_GCODE_STATE , G91 et RESTORE_GCODE_STATE . Par exemple\u202f: [gcode_macro MOVE_UP] gcode: SAVE_GCODE_STATE NAME=my_move_up_state G91 G1 Z10 F300 RESTORE_GCODE_STATE NAME=my_move_up_state La commande G91 place l'\u00e9tat d'analyse du G-Code en \"mode de d\u00e9placement relatif\" et la commande RESTORE_GCODE_STATE restaure l'\u00e9tat tel qu'il \u00e9tait avant d'entrer dans la macro. Veillez \u00e0 sp\u00e9cifier une vitesse explicite (via le param\u00e8tre F ) sur la premi\u00e8re commande G1 . Extension du mod\u00e8le \u00b6 La section de configuration gcode_macro gcode: est \u00e9valu\u00e9e \u00e0 l'aide du langage Jinja2. On peut \u00e9valuer des expressions au moment de l'ex\u00e9cution en les entourant des caract\u00e8res { } ou utiliser des instructions conditionnelles avec des commande entour\u00e9es par {% %} . Voir la documentation Jinja2 pour plus d'informations sur la syntaxe. Un exemple de macro complexe : [gcode_macro clean_nozzle] gcode: {% set wipe_count = 8 %} SAVE_GCODE_STATE NAME=clean_nozzle_state G90 G0 Z15 F300 {% for wipe in range(wipe_count) %} {% for coordinate in [(275, 4),(235, 4)] %} G0 X{coordinate[0]} Y{coordinate[1] + 0.25 * wipe} Z9.7 F12000 {% endfor %} {% endfor %} RESTORE_GCODE_STATE NAME=clean_nozzle_state Param\u00e8tres de macro \u00b6 Il est souvent utile d'inspecter les param\u00e8tres pass\u00e9s \u00e0 la macro lorsqu'elle est appel\u00e9e. Ces param\u00e8tres sont disponibles via la pseudo-variable params . Par exemple, si la macro : [gcode_macro SET_PERCENT] gcode: M117 Now at { params.VALUE|float * 100 }% a \u00e9t\u00e9 appel\u00e9 avec SET_PERCENT VALUE=.2 , il sera \u00e9valu\u00e9 \u00e0 M117 Maintenant \u00e0 20 % . Les noms de param\u00e8tres sont toujours en majuscules lorsqu'ils sont \u00e9valu\u00e9s dans la macro et sont toujours transmis sous forme de cha\u00eenes. Si vous effectuez des calculs, ils doivent \u00eatre explicitement convertis en nombres entiers ou flottants. Il est courant d'utiliser la directive Jinja2 set pour affecter un param\u00e8tre \u00e0 une variable locale. Par exemple\u202f: [gcode_macro SET_BED_TEMPERATURE] gcode: {% set bed_temp = params.TEMPERATURE|default(40)|float %} M140 S{bed_temp} La variable \"rawparams\" \u00b6 Les param\u00e8tres complets non analys\u00e9s pour la macro en cours d'ex\u00e9cution sont accessibles via la pseudo-variable rawparams . Notez que cela inclura tous les commentaires qui faisaient partie de la commande d'origine. Voir le fichier sample-macros.cfg pour un exemple montrant comment remplacer la commande M117 \u00e0 l'aide de rawparams . La variable \"printer\" \u00b6 Il est possible d'inspecter (et de modifier) l'\u00e9tat actuel de l'imprimante via la pseudo-variable printer . Par exemple\u202f: [gcode_macro slow_fan] gcode: M106 S{ printer.fan.speed * 0.9 * 255} Les champs disponibles sont d\u00e9finis dans le document Status Reference . Important\u202f! Les macros sont d'abord \u00e9valu\u00e9es dans leur int\u00e9gralit\u00e9 et ce n'est qu'ensuite que les commandes r\u00e9sultantes sont ex\u00e9cut\u00e9es. Si une macro \u00e9met une commande qui modifie l'\u00e9tat de l'imprimante, les r\u00e9sultats de ce changement d'\u00e9tat ne seront pas visibles lors de l'\u00e9valuation de la macro. Cela peut \u00e9galement entra\u00eener un comportement subtil lorsqu'une macro g\u00e9n\u00e8re des commandes qui appellent d'autres macros, car la macro appel\u00e9e est \u00e9valu\u00e9e lorsqu'elle est invoqu\u00e9e (c'est-\u00e0-dire apr\u00e8s l'\u00e9valuation compl\u00e8te de la macro appelante). Par convention, le nom suivant imm\u00e9diatement printer est le nom d'une section de configuration. Ainsi, par exemple, printer.fan fait r\u00e9f\u00e9rence \u00e0 l'objet ventilateur cr\u00e9\u00e9 par la section de configuration [fan] . Il existe quelques exceptions \u00e0 cette r\u00e8gle, notamment les objets gcode_move et toolhead . Si la section de configuration contient des espaces, on peut y acc\u00e9der via l'accesseur [ ] - par exemple : printer[\"generic_heater my_chamber_heater\"].temperature . Notez que la directive Jinja2 set permet d'affecter un objet dans la hi\u00e9rarchie printer \u00e0 une variable locale. Cela peut rendre les macros plus lisibles et r\u00e9duire la saisie. Par exemple\u202f: [gcode_macro QUERY_HTU21D] gcode: {% set sensor = printer[\"htu21d my_sensor\"] %} M117 Temp:{sensor.temperature} Humidity:{sensor.humidity} Actions \u00b6 Certaines commandes disponibles peuvent modifier l'\u00e9tat de l'imprimante. Par exemple, { action_emergency_stop() } entra\u00eenera l'arr\u00eat de l'imprimante. Ces actions sont execut\u00e9es au moment o\u00f9 la macro est \u00e9valu\u00e9e, ce qui peut prendre beaucoup de temps avant que les commandes g-code g\u00e9n\u00e9r\u00e9es ne soient ex\u00e9cut\u00e9es. Commandes \"action\" disponibles : action_respond_info(msg) : affiche le msg donn\u00e9 dans le pseudo-terminal /tmp/printer. Chaque ligne de msg sera envoy\u00e9e avec un pr\u00e9fixe \"//\". action_raise_error(msg) : termine la macro actuelle (et toutes les macros appelantes) et \u00e9crit le msg donn\u00e9 sur le pseudo-terminal /tmp/printer. La premi\u00e8re ligne de msg sera envoy\u00e9e avec un pr\u00e9fixe \"!!\" et les lignes suivantes auront un pr\u00e9fixe \"//\". action_emergency_stop(msg) : Arr\u00eate l'imprimante. Le param\u00e8tre msg est facultatif, il peut \u00eatre utile de d\u00e9crire la raison de l'arr\u00eat. action_call_remote_method(method_name) : appelle une m\u00e9thode enregistr\u00e9e par un client distant. Si la m\u00e9thode prend des param\u00e8tres, ils doivent \u00eatre fournis via des arguments de mots-cl\u00e9s, c\u2019est-\u00e0-dire : action_call_remote_method(\u00ab print_stuff \u00bb, my_arg=\"hello_world \u00bb) Variables \u00b6 La commande SET_GCODE_VARIABLE peut \u00eatre utile pour enregistrer l'\u00e9tat entre les appels de macro. Les noms de variables ne doivent pas contenir de caract\u00e8res majuscules. Par exemple\u202f: [gcode_macro start_probe] variable_bed_temp: 0 gcode: # Save target temperature to bed_temp variable SET_GCODE_VARIABLE MACRO=start_probe VARIABLE=bed_temp VALUE={printer.heater_bed.target} # Disable bed heater M140 # Perform probe PROBE # Call finish_probe macro at completion of probe finish_probe [gcode_macro finish_probe] gcode: # Restore temperature M140 S{printer[\"gcode_macro start_probe\"].bed_temp} Assurez-vous de prendre en compte le moment de l'\u00e9valuation de la macro et de l'ex\u00e9cution de la commande lors de l'utilisation de SET_GCODE_VARIABLE. Gcodes retard\u00e9s \u00b6 L'option de configuration [delayed_gcode] peut \u00eatre utilis\u00e9e pour ex\u00e9cuter une s\u00e9quence gcode retard\u00e9e : [delayed_gcode clear_display] gcode: M117 [gcode_macro load_filament] gcode: G91 G1 E50 G90 M400 M117 Load Complete! UPDATE_DELAYED_GCODE ID=clear_display DURATION=10 Lorsque la macro load_filament ci-dessus s'ex\u00e9cute, elle affiche un message \"Load Complete!\" une fois l'extrusion termin\u00e9e. La derni\u00e8re ligne de gcode active le delay_gcode \"clear_display\", configur\u00e9 pour s'ex\u00e9cuter en 10 secondes. L'option de configuration initial_duration peut \u00eatre d\u00e9finie pour ex\u00e9cuter le delay_gcode au d\u00e9marrage de l'imprimante. Le compte \u00e0 rebours commence lorsque l'imprimante passe \u00e0 l'\u00e9tat \"pr\u00eat\". Par exemple, le delay_gcode ci-dessous s'ex\u00e9cutera 5 secondes apr\u00e8s que l'imprimante soit pr\u00eate, initialisant l'affichage avec \"Welcome!\" : [delayed_gcode welcome] initial_duration: 5. gcode: M117 Welcome! Il est possible qu'un gcode retard\u00e9 se r\u00e9p\u00e8te en le mettant \u00e0 jour dans l'option gcode : [delayed_gcode report_temp] initial_duration: 2. gcode: {action_respond_info(\"Extruder Temp: %.1f\" % (printer.extruder0.temperature))} UPDATE_DELAYED_GCODE ID=report_temp DURATION=2 Le delay_gcode ci-dessus enverra \"// Extruder Temp\u202f: [ex0_temp]\" \u00e0 Octoprint toutes les 2 secondes. Cela peut \u00eatre annul\u00e9 avec le gcode suivant\u202f: UPDATE_DELAYED_GCODE ID=report_temp DURATION=0 Mod\u00e8les de menus \u00b6 Si une section display_config est activ\u00e9e, il est alors possible de personnaliser le menu avec les sections de configuration menu . Les attributs en lecture seule suivants sont disponibles dans les mod\u00e8les de menu : menu.width - largeur de l\u2019\u00e9l\u00e9ment (nombre de colonnes d\u2019affichage) menu.ns - espace de noms de l'\u00e9l\u00e9ment menu.event - nom de l'\u00e9v\u00e9nement qui a d\u00e9clench\u00e9 le script menu.input - valeur d'entr\u00e9e, uniquement disponible dans le contexte du script d'entr\u00e9e Les actions suivantes sont disponibles dans les mod\u00e8les de menu : menu.back(force, update) : ex\u00e9cutera la commande de retour du menu, param\u00e8tres bool\u00e9ens facultatifs <force> et <update> . Lorsque <force> est d\u00e9fini sur True, l'\u00e9dition s'arr\u00eate \u00e9galement. La valeur par d\u00e9faut est False. Lorsque <update> est d\u00e9fini sur False, les \u00e9l\u00e9ments de conteneur parent ne sont pas mis \u00e0 jour. La valeur par d\u00e9faut est True. menu.exit(force) - ex\u00e9cutera la commande de sortie du menu, param\u00e8tre bool\u00e9en facultatif <force> valeur par d\u00e9faut False. Lorsque <force> est d\u00e9fini sur True, l'\u00e9dition s'arr\u00eate \u00e9galement. La valeur par d\u00e9faut est False. Enregistrer les variables sur le disque \u00b6 Si une section de configuration save_variables a \u00e9t\u00e9 activ\u00e9e, SAVE_VARIABLE VARIABLE=<name> VALUE=<value> peut \u00eatre utilis\u00e9 pour enregistrer la variable sur le disque afin qu'elle puisse \u00eatre utilis\u00e9e \u00e0 travers les red\u00e9marrages. Toutes les variables stock\u00e9es sont charg\u00e9es dans le dictionnaire printer.save_variables.variables au d\u00e9marrage et peuvent \u00eatre utilis\u00e9es dans les macros gcode. pour \u00e9viter les lignes trop longues, vous pouvez ajouter ce qui suit en haut de la macro : {% set svv = printer.save_variables.variables %} Par exemple, il pourrait \u00eatre utilis\u00e9 pour enregistrer l'\u00e9tat d'un extrudeur cyclope lors du d\u00e9marrage d'une impression, assurez-vous que l'extrudeuse active est utilis\u00e9e, au lieu de T0 : [gcode_macro T1] gcode: ACTIVATE_EXTRUDER extruder=extruder1 SAVE_VARIABLE VARIABLE=currentextruder VALUE='\"extruder1\"' [gcode_macro T0] gcode: ACTIVATE_EXTRUDER extruder=extruder SAVE_VARIABLE VARIABLE=currentextruder VALUE='\"extruder\"' [gcode_macro START_GCODE] gcode: {% set svv = printer.save_variables.variables %} ACTIVATE_EXTRUDER extruder={svv.currentextruder}","title":"Mod\u00e8les de commandes"},{"location":"Command_Templates.html#modeles-de-commandes","text":"Ce document fournit des informations sur l'impl\u00e9mentation des s\u00e9quences de commandes G-Code dans les sections de configuration gcode_macro (et similaires).","title":"Mod\u00e8les de commandes"},{"location":"Command_Templates.html#nommage-des-macros-de-g-code","text":"La casse n'est pas importante pour le nom de la macro G-Code - MA_MACRO et ma_macro \u00e9valueront la m\u00eame chose et peuvent \u00eatre appel\u00e9es en majuscules ou en minuscules. Si des nombres sont utilis\u00e9s dans le nom de la macro, ils doivent tous se trouver \u00e0 la fin du nom (par exemple, TEST_MACRO25 est valide, mais MACRO25_TEST3 ne l'est pas).","title":"Nommage des macros de G-code"},{"location":"Command_Templates.html#formatage-du-g-code-dans-la-config","text":"L'indentation est importante lors de la d\u00e9finition d'une macro dans le fichier de configuration. Pour sp\u00e9cifier une s\u00e9quence G-Code multiligne, il est important que chaque ligne ait une indentation appropri\u00e9e. Par exemple\u202f: [gcode_macro blink_led] gcode: SET_PIN PIN=my_led VALUE=1 G4 P2000 SET_PIN PIN=my_led VALUE=0 L'option de configuration gcode: commence toujours au d\u00e9but de la ligne et les lignes suivantes de la macro G-Code ne commencent jamais au d\u00e9but.","title":"Formatage du G-Code dans la config"},{"location":"Command_Templates.html#ajouter-une-description-a-votre-macro","text":"Pour vous aider \u00e0 identifier la fonctionnalit\u00e9, une courte description peut \u00eatre ajout\u00e9e. Ajoutez description\u202f: avec un texte court pour d\u00e9crire la fonctionnalit\u00e9. La valeur par d\u00e9faut est \"Macro G-Code\". Par exemple\u202f: [gcode_macro blink_led] description: Blink my_led one time gcode: SET_PIN PIN=my_led VALUE=1 G4 P2000 SET_PIN PIN=my_led VALUE=0 Le terminal affichera la description lorsque vous utiliserez la commande HELP ou la fonction de saisie semi-automatique.","title":"Ajouter une description \u00e0 votre macro"},{"location":"Command_Templates.html#enregistrerrestaurer-letat-pour-les-deplacements-g-code","text":"Le langage de commande G-Code peut \u00eatre difficile \u00e0 utiliser. Le m\u00e9canisme standard pour d\u00e9placer la t\u00eate d'outil se fait via la commande G1 (la commande G0 est un alias pour G1 et elle peut \u00eatre utilis\u00e9e \u00e0 la place de G1 et inversement). Cependant, cette commande repose sur la configuration \"G-Code parsing state\" d\u00e9finie par M82 , M83 , G90 , G91 , G92 et les commandes pr\u00e9c\u00e9dentes G1 . Lors de la cr\u00e9ation d'une macro G-Code, il est conseill\u00e9 de toujours d\u00e9finir explicitement l'\u00e9tat d'analyse du G-Code avant d'\u00e9mettre une commande G1 . (Sinon, il y a un risque que la commande G1 fasse une demande ind\u00e9sirable.) Une fa\u00e7on courante d'y parvenir consiste \u00e0 encapsuler les mouvements G1 avec SAVE_GCODE_STATE , G91 et RESTORE_GCODE_STATE . Par exemple\u202f: [gcode_macro MOVE_UP] gcode: SAVE_GCODE_STATE NAME=my_move_up_state G91 G1 Z10 F300 RESTORE_GCODE_STATE NAME=my_move_up_state La commande G91 place l'\u00e9tat d'analyse du G-Code en \"mode de d\u00e9placement relatif\" et la commande RESTORE_GCODE_STATE restaure l'\u00e9tat tel qu'il \u00e9tait avant d'entrer dans la macro. Veillez \u00e0 sp\u00e9cifier une vitesse explicite (via le param\u00e8tre F ) sur la premi\u00e8re commande G1 .","title":"Enregistrer/Restaurer l'\u00e9tat pour les d\u00e9placements G-Code"},{"location":"Command_Templates.html#extension-du-modele","text":"La section de configuration gcode_macro gcode: est \u00e9valu\u00e9e \u00e0 l'aide du langage Jinja2. On peut \u00e9valuer des expressions au moment de l'ex\u00e9cution en les entourant des caract\u00e8res { } ou utiliser des instructions conditionnelles avec des commande entour\u00e9es par {% %} . Voir la documentation Jinja2 pour plus d'informations sur la syntaxe. Un exemple de macro complexe : [gcode_macro clean_nozzle] gcode: {% set wipe_count = 8 %} SAVE_GCODE_STATE NAME=clean_nozzle_state G90 G0 Z15 F300 {% for wipe in range(wipe_count) %} {% for coordinate in [(275, 4),(235, 4)] %} G0 X{coordinate[0]} Y{coordinate[1] + 0.25 * wipe} Z9.7 F12000 {% endfor %} {% endfor %} RESTORE_GCODE_STATE NAME=clean_nozzle_state","title":"Extension du mod\u00e8le"},{"location":"Command_Templates.html#parametres-de-macro","text":"Il est souvent utile d'inspecter les param\u00e8tres pass\u00e9s \u00e0 la macro lorsqu'elle est appel\u00e9e. Ces param\u00e8tres sont disponibles via la pseudo-variable params . Par exemple, si la macro : [gcode_macro SET_PERCENT] gcode: M117 Now at { params.VALUE|float * 100 }% a \u00e9t\u00e9 appel\u00e9 avec SET_PERCENT VALUE=.2 , il sera \u00e9valu\u00e9 \u00e0 M117 Maintenant \u00e0 20 % . Les noms de param\u00e8tres sont toujours en majuscules lorsqu'ils sont \u00e9valu\u00e9s dans la macro et sont toujours transmis sous forme de cha\u00eenes. Si vous effectuez des calculs, ils doivent \u00eatre explicitement convertis en nombres entiers ou flottants. Il est courant d'utiliser la directive Jinja2 set pour affecter un param\u00e8tre \u00e0 une variable locale. Par exemple\u202f: [gcode_macro SET_BED_TEMPERATURE] gcode: {% set bed_temp = params.TEMPERATURE|default(40)|float %} M140 S{bed_temp}","title":"Param\u00e8tres de macro"},{"location":"Command_Templates.html#la-variable-rawparams","text":"Les param\u00e8tres complets non analys\u00e9s pour la macro en cours d'ex\u00e9cution sont accessibles via la pseudo-variable rawparams . Notez que cela inclura tous les commentaires qui faisaient partie de la commande d'origine. Voir le fichier sample-macros.cfg pour un exemple montrant comment remplacer la commande M117 \u00e0 l'aide de rawparams .","title":"La variable \"rawparams\""},{"location":"Command_Templates.html#la-variable-printer","text":"Il est possible d'inspecter (et de modifier) l'\u00e9tat actuel de l'imprimante via la pseudo-variable printer . Par exemple\u202f: [gcode_macro slow_fan] gcode: M106 S{ printer.fan.speed * 0.9 * 255} Les champs disponibles sont d\u00e9finis dans le document Status Reference . Important\u202f! Les macros sont d'abord \u00e9valu\u00e9es dans leur int\u00e9gralit\u00e9 et ce n'est qu'ensuite que les commandes r\u00e9sultantes sont ex\u00e9cut\u00e9es. Si une macro \u00e9met une commande qui modifie l'\u00e9tat de l'imprimante, les r\u00e9sultats de ce changement d'\u00e9tat ne seront pas visibles lors de l'\u00e9valuation de la macro. Cela peut \u00e9galement entra\u00eener un comportement subtil lorsqu'une macro g\u00e9n\u00e8re des commandes qui appellent d'autres macros, car la macro appel\u00e9e est \u00e9valu\u00e9e lorsqu'elle est invoqu\u00e9e (c'est-\u00e0-dire apr\u00e8s l'\u00e9valuation compl\u00e8te de la macro appelante). Par convention, le nom suivant imm\u00e9diatement printer est le nom d'une section de configuration. Ainsi, par exemple, printer.fan fait r\u00e9f\u00e9rence \u00e0 l'objet ventilateur cr\u00e9\u00e9 par la section de configuration [fan] . Il existe quelques exceptions \u00e0 cette r\u00e8gle, notamment les objets gcode_move et toolhead . Si la section de configuration contient des espaces, on peut y acc\u00e9der via l'accesseur [ ] - par exemple : printer[\"generic_heater my_chamber_heater\"].temperature . Notez que la directive Jinja2 set permet d'affecter un objet dans la hi\u00e9rarchie printer \u00e0 une variable locale. Cela peut rendre les macros plus lisibles et r\u00e9duire la saisie. Par exemple\u202f: [gcode_macro QUERY_HTU21D] gcode: {% set sensor = printer[\"htu21d my_sensor\"] %} M117 Temp:{sensor.temperature} Humidity:{sensor.humidity}","title":"La variable \"printer\""},{"location":"Command_Templates.html#actions","text":"Certaines commandes disponibles peuvent modifier l'\u00e9tat de l'imprimante. Par exemple, { action_emergency_stop() } entra\u00eenera l'arr\u00eat de l'imprimante. Ces actions sont execut\u00e9es au moment o\u00f9 la macro est \u00e9valu\u00e9e, ce qui peut prendre beaucoup de temps avant que les commandes g-code g\u00e9n\u00e9r\u00e9es ne soient ex\u00e9cut\u00e9es. Commandes \"action\" disponibles : action_respond_info(msg) : affiche le msg donn\u00e9 dans le pseudo-terminal /tmp/printer. Chaque ligne de msg sera envoy\u00e9e avec un pr\u00e9fixe \"//\". action_raise_error(msg) : termine la macro actuelle (et toutes les macros appelantes) et \u00e9crit le msg donn\u00e9 sur le pseudo-terminal /tmp/printer. La premi\u00e8re ligne de msg sera envoy\u00e9e avec un pr\u00e9fixe \"!!\" et les lignes suivantes auront un pr\u00e9fixe \"//\". action_emergency_stop(msg) : Arr\u00eate l'imprimante. Le param\u00e8tre msg est facultatif, il peut \u00eatre utile de d\u00e9crire la raison de l'arr\u00eat. action_call_remote_method(method_name) : appelle une m\u00e9thode enregistr\u00e9e par un client distant. Si la m\u00e9thode prend des param\u00e8tres, ils doivent \u00eatre fournis via des arguments de mots-cl\u00e9s, c\u2019est-\u00e0-dire : action_call_remote_method(\u00ab print_stuff \u00bb, my_arg=\"hello_world \u00bb)","title":"Actions"},{"location":"Command_Templates.html#variables","text":"La commande SET_GCODE_VARIABLE peut \u00eatre utile pour enregistrer l'\u00e9tat entre les appels de macro. Les noms de variables ne doivent pas contenir de caract\u00e8res majuscules. Par exemple\u202f: [gcode_macro start_probe] variable_bed_temp: 0 gcode: # Save target temperature to bed_temp variable SET_GCODE_VARIABLE MACRO=start_probe VARIABLE=bed_temp VALUE={printer.heater_bed.target} # Disable bed heater M140 # Perform probe PROBE # Call finish_probe macro at completion of probe finish_probe [gcode_macro finish_probe] gcode: # Restore temperature M140 S{printer[\"gcode_macro start_probe\"].bed_temp} Assurez-vous de prendre en compte le moment de l'\u00e9valuation de la macro et de l'ex\u00e9cution de la commande lors de l'utilisation de SET_GCODE_VARIABLE.","title":"Variables"},{"location":"Command_Templates.html#gcodes-retardes","text":"L'option de configuration [delayed_gcode] peut \u00eatre utilis\u00e9e pour ex\u00e9cuter une s\u00e9quence gcode retard\u00e9e : [delayed_gcode clear_display] gcode: M117 [gcode_macro load_filament] gcode: G91 G1 E50 G90 M400 M117 Load Complete! UPDATE_DELAYED_GCODE ID=clear_display DURATION=10 Lorsque la macro load_filament ci-dessus s'ex\u00e9cute, elle affiche un message \"Load Complete!\" une fois l'extrusion termin\u00e9e. La derni\u00e8re ligne de gcode active le delay_gcode \"clear_display\", configur\u00e9 pour s'ex\u00e9cuter en 10 secondes. L'option de configuration initial_duration peut \u00eatre d\u00e9finie pour ex\u00e9cuter le delay_gcode au d\u00e9marrage de l'imprimante. Le compte \u00e0 rebours commence lorsque l'imprimante passe \u00e0 l'\u00e9tat \"pr\u00eat\". Par exemple, le delay_gcode ci-dessous s'ex\u00e9cutera 5 secondes apr\u00e8s que l'imprimante soit pr\u00eate, initialisant l'affichage avec \"Welcome!\" : [delayed_gcode welcome] initial_duration: 5. gcode: M117 Welcome! Il est possible qu'un gcode retard\u00e9 se r\u00e9p\u00e8te en le mettant \u00e0 jour dans l'option gcode : [delayed_gcode report_temp] initial_duration: 2. gcode: {action_respond_info(\"Extruder Temp: %.1f\" % (printer.extruder0.temperature))} UPDATE_DELAYED_GCODE ID=report_temp DURATION=2 Le delay_gcode ci-dessus enverra \"// Extruder Temp\u202f: [ex0_temp]\" \u00e0 Octoprint toutes les 2 secondes. Cela peut \u00eatre annul\u00e9 avec le gcode suivant\u202f: UPDATE_DELAYED_GCODE ID=report_temp DURATION=0","title":"Gcodes retard\u00e9s"},{"location":"Command_Templates.html#modeles-de-menus","text":"Si une section display_config est activ\u00e9e, il est alors possible de personnaliser le menu avec les sections de configuration menu . Les attributs en lecture seule suivants sont disponibles dans les mod\u00e8les de menu : menu.width - largeur de l\u2019\u00e9l\u00e9ment (nombre de colonnes d\u2019affichage) menu.ns - espace de noms de l'\u00e9l\u00e9ment menu.event - nom de l'\u00e9v\u00e9nement qui a d\u00e9clench\u00e9 le script menu.input - valeur d'entr\u00e9e, uniquement disponible dans le contexte du script d'entr\u00e9e Les actions suivantes sont disponibles dans les mod\u00e8les de menu : menu.back(force, update) : ex\u00e9cutera la commande de retour du menu, param\u00e8tres bool\u00e9ens facultatifs <force> et <update> . Lorsque <force> est d\u00e9fini sur True, l'\u00e9dition s'arr\u00eate \u00e9galement. La valeur par d\u00e9faut est False. Lorsque <update> est d\u00e9fini sur False, les \u00e9l\u00e9ments de conteneur parent ne sont pas mis \u00e0 jour. La valeur par d\u00e9faut est True. menu.exit(force) - ex\u00e9cutera la commande de sortie du menu, param\u00e8tre bool\u00e9en facultatif <force> valeur par d\u00e9faut False. Lorsque <force> est d\u00e9fini sur True, l'\u00e9dition s'arr\u00eate \u00e9galement. La valeur par d\u00e9faut est False.","title":"Mod\u00e8les de menus"},{"location":"Command_Templates.html#enregistrer-les-variables-sur-le-disque","text":"Si une section de configuration save_variables a \u00e9t\u00e9 activ\u00e9e, SAVE_VARIABLE VARIABLE=<name> VALUE=<value> peut \u00eatre utilis\u00e9 pour enregistrer la variable sur le disque afin qu'elle puisse \u00eatre utilis\u00e9e \u00e0 travers les red\u00e9marrages. Toutes les variables stock\u00e9es sont charg\u00e9es dans le dictionnaire printer.save_variables.variables au d\u00e9marrage et peuvent \u00eatre utilis\u00e9es dans les macros gcode. pour \u00e9viter les lignes trop longues, vous pouvez ajouter ce qui suit en haut de la macro : {% set svv = printer.save_variables.variables %} Par exemple, il pourrait \u00eatre utilis\u00e9 pour enregistrer l'\u00e9tat d'un extrudeur cyclope lors du d\u00e9marrage d'une impression, assurez-vous que l'extrudeuse active est utilis\u00e9e, au lieu de T0 : [gcode_macro T1] gcode: ACTIVATE_EXTRUDER extruder=extruder1 SAVE_VARIABLE VARIABLE=currentextruder VALUE='\"extruder1\"' [gcode_macro T0] gcode: ACTIVATE_EXTRUDER extruder=extruder SAVE_VARIABLE VARIABLE=currentextruder VALUE='\"extruder\"' [gcode_macro START_GCODE] gcode: {% set svv = printer.save_variables.variables %} ACTIVATE_EXTRUDER extruder={svv.currentextruder}","title":"Enregistrer les variables sur le disque"},{"location":"Config_Changes.html","text":"Changements de configuration \u00b6 Ce document couvre les modifications logicielles apport\u00e9es au fichier de configuration qui ne sont pas r\u00e9tro compatibles. Il est conseill\u00e9 de consulter ce document lors de la mise \u00e0 jour du logiciel Klipper. Toutes les dates de ce document sont approximatives. Changements \u00b6 20230826: If safe_distance is set or calculated to be 0 in [dual_carriage] , the carriages proximity checks will be disabled as per documentation. A user may wish to configure safe_distance explicitly to prevent accidental crashes of the carriages with each other. Additionally, the homing order of the primary and the dual carriage is changed in some configurations (certain configurations when both carriages home in the same direction, see [dual_carriage] configuration reference for more details). 20230810: The flash-sdcard.sh script now supports both variants of the Bigtreetech SKR-3, STM32H743 and STM32H723. For this, the original tag of btt-skr-3 now has changed to be either btt-skr-3-h743 or btt-skr-3-h723. 20230729: The exported status for dual_carriage is changed. Instead of exporting mode and active_carriage , the individual modes for each carriage are exported as printer.dual_carriage.carriage_0 and printer.dual_carriage.carriage_1 . 20230619: The relative_reference_index option has been deprecated and superceded by the zero_reference_position option. Refer to the Bed Mesh Documentation for details on how to update the configuration. With this deprecation the RELATIVE_REFERENCE_INDEX is no longer available as a parameter for the BED_MESH_CALIBRATE gcode command. 20230530: The default canbus frequency in \"make menuconfig\" is now 1000000. If using canbus and using canbus with some other frequency is required, then be sure to select \"Enable extra low-level configuration options\" and specify the desired \"CAN bus speed\" in \"make menuconfig\" when compiling and flashing the micro-controller. 20230525: SHAPER_CALIBRATE command immediately applies input shaper parameters if [input_shaper] was enabled already. 20230407: The stalled_bytes counter in the log and in the printer.mcu.last_stats field has been renamed to upcoming_bytes . 20230323: On tmc5160 drivers multistep_filt is now enabled by default. Set driver_MULTISTEP_FILT: False in the tmc5160 config for the previous behavior. 20230304 : La commande SET_TMC_CURRENT ajuste d\u00e9sormais correctement le registre globalscaler pour les pilotes qui l'ont. Cela supprime une limitation o\u00f9 sur tmc5160, les courants ne pouvaient pas \u00eatre augment\u00e9s plus haut avec SET_TMC_CURRENT que la valeur run_current d\u00e9finie dans le fichier de configuration. Cependant, cela a un effet secondaire : apr\u00e8s avoir ex\u00e9cut\u00e9 SET_TMC_CURRENT , le moteur pas \u00e0 pas doit \u00eatre maintenu \u00e0 l'arr\u00eat pendant plus de 130 ms dans le cas o\u00f9 StealthChop2 est utilis\u00e9 afin que l'\u00e9talonnage AT#1 soit ex\u00e9cut\u00e9 par le pilote. 20230202 : Le format des informations d'\u00e9tat printer.screws_tilt_adjust a chang\u00e9. Les informations sont maintenant stock\u00e9es sous forme de dictionnaire de vis avec les mesures r\u00e9sultantes. Voir la r\u00e9f\u00e9rence d'\u00e9tat pour plus de d\u00e9tails. 20230201 : Le module [bed_mesh] ne charge plus le profil default au d\u00e9marrage. Il est recommand\u00e9 aux utilisateurs qui utilisent le profil default d'ajouter BED_MESH_PROFILE LOAD=default \u00e0 leur macro START_PRINT (ou \u00e0 la configuration \"Start G-Code\" de leur trancheur si applicable). 20230103 : Il est maintenant possible avec le script flash-sdcard.sh de flasher les deux variantes du Bigtreetech SKR-2, STM32F407 et STM32F429. Cela signifie que le tag originel de btt-skr2 a maintenant chang\u00e9 en btt-skr-2-f407 ou btt-skr-2-f429. 20221128 : Sortie de Klipper v0.11.0. 20221122 : Auparavant, avec safe_z_home, il \u00e9tait possible que le z_hop apr\u00e8s la mise \u00e0 l'origine g28 aille dans une direction z n\u00e9gative. Maintenant, un saut en z n'est effectu\u00e9 apr\u00e8s g28 que s'il r\u00e9sulte en un saut positif, refl\u00e9tant le comportement du saut en z se produisant avant la mise \u00e0 l'origine g28. 20220616 : Il \u00e9tait auparavant possible de flasher un rp2040 en mode bootloader en ex\u00e9cutant make flash FLASH_DEVICE=first . La commande \u00e9quivalente est maintenant make flash FLASH_DEVICE=2e8a:0003 . 20220612 : Le micro-contr\u00f4leur rp2040 a maintenant une solution de contournement pour l'errata USB \"rp2040-e5\". Cela devrait rendre les premi\u00e8res connexions USB plus fiables. Cependant, cela peut entra\u00eener un changement de comportement de la broche gpio15. Il est peu probable que le changement de comportement de la gpio15 soit perceptible. 20220407 : L'option de configuration pid_integral_max de temperature_fan a \u00e9t\u00e9 supprim\u00e9e (elle \u00e9tait obsol\u00e8te depuis 20210612). 20220407 : L'ordre des couleurs par d\u00e9faut pour les LEDs pca9632 est maintenant \"RGBW\". Ajoutez un param\u00e8tre explicite color_order : RBGW \u00e0 la section pca9632 config pour obtenir le comportement pr\u00e9c\u00e9dent. 20220330 : Le format des informations d'\u00e9tat printer.neopixel.color_data des modules neopixel et dotstar a chang\u00e9. L'information est maintenant stock\u00e9e comme une liste de listes de couleurs (au lieu d'une liste de dictionnaires). Voir la r\u00e9f\u00e9rence d'\u00e9tat pour plus de d\u00e9tails. 20220307 : M73 ne mettra plus la progression de l'impression \u00e0 0 si P est absent. 20220304 : Il n'y a plus de valeur par d\u00e9faut pour le param\u00e8tre extruder des sections de configuration extruder_stepper . Si vous le souhaitez, sp\u00e9cifiez explicitement extruder : extruder pour associer le moteur pas \u00e0 pas \u00e0 la file d'attente de mouvement \"extruder\" au d\u00e9marrage. 20220210 : La commande SYNC_STEPPER_TO_EXTRUDER est obsol\u00e8te ; la commande SET_EXTRUDER_STEP_DISTANCE est obsol\u00e8te ; l'option de configuration shared_heater de l' extrudeuse est obsol\u00e8te. Ces fonctionnalit\u00e9s seront supprim\u00e9es dans un futur proche. Remplacez SET_EXTRUDER_STEP_DISTANCE par SET_EXTRUDER_ROTATION_DISTANCE . Remplacez SYNC_STEPPER_TO_EXTRUDER par SYNC_EXTRUDER_MOTION . Remplacez les sections de configuration de l'extrudeuse utilisant shared_heater par les sections de configuration extruder_stepper et mettez \u00e0 jour toutes les macros d'activation pour utiliser SYNC_EXTRUDER_MOTION . 20220116 : Le code de calcul run_current des tmc2130, tmc2208, tmc2209, et tmc2660 a chang\u00e9. Pour certains param\u00e8tres run_current les pilotes peuvent maintenant \u00eatre configur\u00e9s diff\u00e9remment. Cette nouvelle configuration devrait \u00eatre plus pr\u00e9cise, mais elle peut invalider les r\u00e9glages pr\u00e9c\u00e9dents des pilotes tmc. 20211230 : Les scripts pour ajuster le fa\u00e7onneur d'entr\u00e9e ( scripts/calibrate_shaper.py et scripts/graph_accelerometer.py ) ont \u00e9t\u00e9 migr\u00e9s pour utiliser Python3 par d\u00e9faut. Par cons\u00e9quent, les utilisateurs doivent installer les versions Python3 de certains paquets (par exemple, sudo apt install python3-numpy python3-matplotlib ) pour continuer \u00e0 utiliser ces scripts. Pour plus de d\u00e9tails, reportez-vous \u00e0 Installation du logiciel . Alternativement, les utilisateurs peuvent temporairement forcer l'ex\u00e9cution de ces scripts sous Python 2 en appelant explicitement l'interpr\u00e9teur Python2 dans la console : python2 ~/klipper/scripts/calibrate_shaper.py ... 20211110 : Le capteur de temp\u00e9rature \"NTC 100K beta 3950\" est d\u00e9pr\u00e9ci\u00e9. Ce capteur sera supprim\u00e9 dans un avenir proche. La plupart des utilisateurs trouveront le capteur de temp\u00e9rature \"Generic 3950\" plus pr\u00e9cis. Pour continuer \u00e0 utiliser l'ancienne d\u00e9finition (g\u00e9n\u00e9ralement moins pr\u00e9cise), d\u00e9finissez une thermistance personnalis\u00e9e avec temp\u00e9rature1 : 25 , r\u00e9sistance1 : 100000 , et beta : 3950 . 20211104 : L'option \"step pulse duration\" dans \"make menuconfig\" a \u00e9t\u00e9 supprim\u00e9e. La dur\u00e9e d'impulsion par d\u00e9faut pour les pilotes TMC configur\u00e9s en mode UART ou SPI est maintenant de 100ns. Un nouveau param\u00e8tre step_pulse_duration dans la section configuration des moteurs doit \u00eatre d\u00e9fini pour tous les moteurs n\u00e9cessitant une dur\u00e9e d'impulsion personnalis\u00e9e. 20211102 : Plusieurs fonctionnalit\u00e9s obsol\u00e8tes ont \u00e9t\u00e9 supprim\u00e9es. L'option step_distance du stepper a \u00e9t\u00e9 supprim\u00e9e (obsol\u00e8te depuis 20201222). L'alias du capteur rpi_temperature a \u00e9t\u00e9 supprim\u00e9 (obsol\u00e8te depuis 20210219). L'option mcu pin_map a \u00e9t\u00e9 supprim\u00e9e (obsol\u00e8te depuis 20210325). L'option gcode_macro default_parameter_<name> et l'acc\u00e8s aux param\u00e8tres de commande par la macro autrement que par la pseudo-variable params ont \u00e9t\u00e9 supprim\u00e9s (obsol\u00e8te depuis 20210503). L'option heater pid_integral_max a \u00e9t\u00e9 supprim\u00e9e (obsol\u00e8te le 20210612). 20210929 : Sortie de Klipper v0.10.0. 20210903 : La valeur par d\u00e9faut de smooth_time pour les \u00e9l\u00e9ments chauffants est pass\u00e9e \u00e0 1 seconde (au lieu de 2 secondes). Pour la plupart des imprimantes, cela permettra un contr\u00f4le plus stable de la temp\u00e9rature. 20210830 : Le nom par d\u00e9faut de adxl345 est maintenant \"adxl345\". Le param\u00e8tre CHIP par d\u00e9faut pour les fonctions ACCELEROMETER_MEASURE et ACCELEROMETER_QUERY est maintenant aussi \"adxl345\". 20210830 : La commande adxl345 ACCELEROMETER_MEASURE ne prend plus en charge un param\u00e8tre RATE. Pour modifier le taux d'interrogation, mettez \u00e0 jour le fichier printer.cfg et lancez une commande RESTART. 20210821 : Plusieurs param\u00e8tres de configuration dans printer.configfile.settings seront maintenant rapport\u00e9s sous forme de listes au lieu de cha\u00eenes brutes. Si vous souhaitez obtenir une cha\u00eene de caract\u00e8res brute, utilisez printer.configfile.config \u00e0 la place. 20210819 : Dans certains cas, un mouvement de retour \u00e0 l'origine G28 peut se terminer dans une position qui est nominalement en dehors de la plage de mouvement valide. Dans de rares situations, cela peut entra\u00eener des erreurs d\u00e9routantes \"Move out of range\" apr\u00e8s le retour \u00e0 la position initiale. Si cela se produit, modifiez vos scripts de d\u00e9marrage pour d\u00e9placer la t\u00eate d'outil vers une position valide imm\u00e9diatement apr\u00e8s le retour \u00e0 la position initiale. 20210814 : Les pseudo-pins analogiques sur l'atmega168 et l'atmega328 ont \u00e9t\u00e9 renomm\u00e9s de PE0/PE1 \u00e0 PE2/PE3. 20210720 : Une section controller_fan surveille maintenant tous les moteurs pas \u00e0 pas par d\u00e9faut (pas seulement les moteurs pas \u00e0 pas cin\u00e9matiques). Si le comportement pr\u00e9c\u00e9dent est souhait\u00e9, voir l'option de configuration stepper dans la r\u00e9f\u00e9rence de configuration . 20210703 : Une section de configuration samd_sercom doit maintenant sp\u00e9cifier le bus sercom qu'elle configure via l'option sercom . 20210612 : l'option de configuration pid_integral_max dans les sections heater et temperature_fan est obsol\u00e8te. Cette option sera supprim\u00e9e dans les prochaines versions. 20210503: The gcode_macro default_parameter_<name> config option is deprecated. Use the params pseudo-variable to access macro parameters. Other methods for accessing macro parameters will be removed in the near future. Most users can replace a default_parameter_NAME: VALUE config option with a line like the following in the start of the macro: {% set NAME = params.NAME|default(VALUE)|float %} . See the Command Templates document for examples. 20210430 : la commande SET_VELOCITY_LIMIT (et M204) peuvent maintenant d\u00e9finir une \"velocity\", \"acceleration\", et \"square_corner_velocity\" sup\u00e9rieurs aux valeurs sp\u00e9cifi\u00e9es dans le fichier de configuration. 20210325 : La prise en charge de l'option de configuration pin_map est obsol\u00e8te. Utilisez le fichier sample-aliases.cfg pour traduire les noms des broches r\u00e9elles du microcontr\u00f4leur. L'option de configuration pin_map sera supprim\u00e9e dans les prochaines version. 20210313 : La prise en charge de Klipper pour les microcontr\u00f4leurs CAN bus a \u00e9t\u00e9 modifi\u00e9e. Si vous utilisez CANBus, tous les microcontr\u00f4leurs doivent \u00eatre reflash\u00e9s et le fichier de configuration de Klipper doit \u00eatre mise \u00e0 jour . 20210310 : la valeur par d\u00e9faut de driver_SFILT pour les TMC2660 a \u00e9t\u00e9 modifi\u00e9e : passage de 1 \u00e0 0 par d\u00e9faut. 20210227 : Les pilotes de moteur pas \u00e0 pas TMC en mode UART ou SPI sont d\u00e9sormais interrog\u00e9s une fois par seconde si ils sont activ\u00e9s - si le pilote ne peut pas \u00eatre contact\u00e9 ou si le pilote signale une erreur, alors Klipper passera \u00e0 un \u00e9tat d'arr\u00eat. 20210219 : Le module rpi_temperature a \u00e9t\u00e9 renomm\u00e9 en temperature_host . Remplacez toutes les occurrences de sensor_type : rpi_temperature par sensor_type : temperature_host . Le chemin vers le fichier de temp\u00e9rature peut \u00eatre sp\u00e9cifi\u00e9 dans la variable de configuration sensor_path . Le nom rpi_temperature est obsol\u00e8te et sera supprim\u00e9 dans les prochaines versions. 20210201: La commande TEST_RESONANCES va maintenant d\u00e9sactiver la mise en forme des entr\u00e9es si elle \u00e9tait pr\u00e9c\u00e9demment activ\u00e9e (et la r\u00e9activer apr\u00e8s le test). Afin d'outrepasser ce comportement et de garder la mise en forme de l'entr\u00e9e activ\u00e9e, on peut passer un param\u00e8tre suppl\u00e9mentaire INPUT_SHAPING=1 \u00e0 la commande. 20210201 : La commande ACCELEROMETER_MEASURE ajoutera d\u00e9sormais le nom de la puce acc\u00e9l\u00e9rom\u00e8tre au nom du fichier de sortie si un nom a \u00e9t\u00e9 donn\u00e9 \u00e0 la puce dans la section adxl345 correspondante du printer.cfg. 20201222 : Le param\u00e8tre step_distance dans les sections de configuration de moteur est obsol\u00e8te. Il est conseill\u00e9 de mettre \u00e0 jour la configuration pour utiliser le param\u00e8tre rotation_distance . Le support de step_distance sera supprim\u00e9 dans un futur proche. 20201218 : Le param\u00e8tre endstop_phase du module endstop_phase a \u00e9t\u00e9 remplac\u00e9 par trigger_phase . Si vous utilisez le module endstop phases, il sera n\u00e9cessaire de convertir en rotation_distance et de recalibrer les phases endstop en ex\u00e9cutant la commande ENDSTOP_PHASE_CALIBRATE. 20201218 : Les imprimantes rotatives delta et polaires doivent maintenant sp\u00e9cifier un gear_ratio pour leurs moteurs rotatifs, et elles ne peuvent plus sp\u00e9cifier un param\u00e8tre step_distance . Voir la r\u00e9f\u00e9rence de configuration pour le format du nouveau param\u00e8tre gear_ratio. 20201213 : Il n'est pas valide de sp\u00e9cifier un Z \"position_endstop\" lors de l'utilisation de \"probe:z_virtual_endstop\". Une erreur sera maintenant soulev\u00e9e si un Z \"position_endstop\" est sp\u00e9cifi\u00e9 avec \"probe:z_virtual_endstop\". Supprimez la d\u00e9finition de Z \"position_endstop\" pour corriger l'erreur. 20201120 : La section de configuration [board_pins] sp\u00e9cifie maintenant le nom du mcu dans un param\u00e8tre explicite mcu: . Si vous utilisez board_pins pour un mcu secondaire, alors la config doit \u00eatre mise \u00e0 jour pour sp\u00e9cifier ce nom. Voir la r\u00e9f\u00e9rence config pour plus de d\u00e9tails. 20201112 : La dur\u00e9e rapport\u00e9e par print_stats.print_duration a chang\u00e9. La dur\u00e9e pr\u00e9c\u00e9dant la premi\u00e8re extrusion d\u00e9tect\u00e9e est maintenant exclue. 20201029 : L'option de configuration neopixel color_order_GRB a \u00e9t\u00e9 supprim\u00e9e. Si n\u00e9cessaire, mettez \u00e0 jour la configuration pour d\u00e9finir la nouvelle option color_order sur RGB, GRB, RGBW, ou GRBW. 20201029 : L'option serial dans la section mcu config ne prend plus par d\u00e9faut /dev/ttyS0. Dans la rare situation o\u00f9 /dev/ttyS0 est le port s\u00e9rie d\u00e9sir\u00e9, il doit \u00eatre indiqu\u00e9 explicitement. 20201020 : Sortie de Klipper v0.9.0. 20200902 : Le calcul de la r\u00e9sistance \u00e0 la temp\u00e9rature des RTD des convertisseurs MAX31865 a \u00e9t\u00e9 corrig\u00e9 pour ne pas lire une valeur basse. Si vous utilisez un tel dispositif, vous devez recalibrer votre temp\u00e9rature d'impression et vos param\u00e8tres PID. 20200816 : L'objet macro gcode printer.gcode a \u00e9t\u00e9 renomm\u00e9 en printer.gcode_move . Plusieurs variables non document\u00e9es dans printer.toolhead et printer.gcode ont \u00e9t\u00e9 supprim\u00e9es. Voir docs/Command_Templates.md pour une liste des variables de mod\u00e8les disponibles. 20200816 : Le syst\u00e8me de macro gcode \"action_\" a chang\u00e9. Remplacez tout appel \u00e0 printer.gcode.action_emergency_stop() par action_emergency_stop() , printer.gcode.action_respond_info() par action_respond_info() , et printer.gcode.action_respond_error() par action_raise_error() . 20200809 : Le syst\u00e8me de menu a \u00e9t\u00e9 r\u00e9\u00e9crit. Si le menu a \u00e9t\u00e9 personnalis\u00e9, il sera n\u00e9cessaire de le mettre \u00e0 jour avec la nouvelle configuration. Voir config/example-menu.cfg pour les d\u00e9tails de la configuration et voir klippy/extras/display/menu.cfg pour les exemples. 20200731 : Le comportement de l'attribut progress rapport\u00e9 par l'objet imprimante virtual_sdcard a chang\u00e9. La progression n'est plus remise \u00e0 0 lorsqu'une impression est mise en pause. La progression est maintenant toujours bas\u00e9e sur la position interne du fichier, ou 0 si aucun fichier n'est charg\u00e9. 20200725 : Le param\u00e8tre de configuration enable du servo et le param\u00e8tre SET_SERVO ENABLE ont \u00e9t\u00e9 supprim\u00e9s. Mettez \u00e0 jour toutes les macros pour utiliser SET_SERVO SERVO=my_servo WIDTH=0 pour d\u00e9sactiver un servo. 20200608 : Le support de l'affichage LCD a chang\u00e9 le nom de certains \"glyphes\" internes. Si une disposition d'affichage personnalis\u00e9e a \u00e9t\u00e9 impl\u00e9ment\u00e9e, il peut \u00eatre n\u00e9cessaire d'actualiser avec les noms actuels de glyphes (voir klippy/extras/display/display.cfg pour une liste des glyphes disponibles). 20200606 : Les noms des broches sur linux mcu ont chang\u00e9. Les broches ont maintenant des noms de la forme gpiochip<chipid>/gpio<gpio> . Pour gpiochip0 vous pouvez aussi utiliser un court gpio<gpio> . Par exemple, ce qui \u00e9tait pr\u00e9c\u00e9demment appel\u00e9 P20 devient maintenant gpio20 ou `gpiochip0/gpio20``. 20200603 : La disposition par d\u00e9faut de l'\u00e9cran LCD 16x4 n'affiche plus le temps estim\u00e9 restant pour une impression. (Seul le temps \u00e9coul\u00e9 sera affich\u00e9.) Si l'on souhaite conserver l'ancien comportement, on peut personnaliser l'affichage du menu avec cette information (voir la description de display_data dans config/example-extras.cfg pour plus de d\u00e9tails). 20200531 : L'id par d\u00e9faut du vendeur/produit USB est maintenant 0x1d50/0x614e. Ces nouveaux identifiants sont r\u00e9serv\u00e9s \u00e0 Klipper (gr\u00e2ce au projet openmoko). Ce changement ne devrait pas n\u00e9cessiter de modification de la configuration, mais les nouveaux identifiants peuvent appara\u00eetre dans les journaux syst\u00e8me. 20200524 : La valeur par d\u00e9faut du champ pwm_freq du tmc5160 est maintenant z\u00e9ro (au lieu de un). 20200425 : La variable du mod\u00e8le de commande gcode_macro printer.heater a \u00e9t\u00e9 renomm\u00e9e en printer.heaters . 20200313 : La disposition par d\u00e9faut de l'\u00e9cran pour les imprimantes multi-extrudeurs avec un \u00e9cran 16x4 a chang\u00e9. La disposition de l'\u00e9cran pour un seul extrudeur est maintenant la disposition par d\u00e9faut et elle montrera l'extrudeur actuellement actif. Pour utiliser la disposition d'\u00e9cran pr\u00e9c\u00e9dente, d\u00e9finissez \"display_group : _multiextruder_16x4\" dans la section [display] du fichier printer.cfg. 20200308 : L'\u00e9l\u00e9ment de menu par d\u00e9faut __test a \u00e9t\u00e9 supprim\u00e9. Si le fichier de configuration a un menu personnalis\u00e9, assurez-vous de supprimer toutes les r\u00e9f\u00e9rences \u00e0 cet \u00e9l\u00e9ment de menu __test . 20200308 : Les options \"deck\" et \"card\" du menu ont \u00e9t\u00e9 supprim\u00e9es. Pour personnaliser la disposition d'un \u00e9cran lcd, utilisez les nouvelles sections de configuration display_data (voir config/example-extras.cfg pour les d\u00e9tails). 20200109 : Le module bed_mesh fait d\u00e9sormais r\u00e9f\u00e9rence \u00e0 l'emplacement de la sonde pour la configuration du maillage. Ainsi, certaines options de configuration ont \u00e9t\u00e9 renomm\u00e9es pour mieux refl\u00e9ter leur fonctionnalit\u00e9. Pour les lits rectangulaires, min_point et max_point ont \u00e9t\u00e9 renomm\u00e9s en mesh_min et mesh_max respectivement. Pour les lits ronds, bed_radius a \u00e9t\u00e9 renomm\u00e9 en mesh_radius . Une nouvelle option mesh_origin a \u00e9galement \u00e9t\u00e9 ajout\u00e9e pour les lits ronds. Notez que ces changements sont \u00e9galement incompatibles avec les profils de maillage pr\u00e9c\u00e9demment enregistr\u00e9s. Si un profil incompatible est d\u00e9tect\u00e9, il sera ignor\u00e9 et sa suppression sera programm\u00e9e. Le processus de suppression peut \u00eatre achev\u00e9 en lan\u00e7ant la commande SAVE_CONFIG. L'utilisateur devra recalibrer chaque profil. 20191218 : La section de configuration de l'affichage ne prend plus en charge \"lcd_type : st7567\". Utilisez le type d'affichage \"uc1701\" \u00e0 la place - d\u00e9finissez \"lcd_type : uc1701\" et changez \"rs_pin : some_pin\" en \"rst_pin : some_pin\". Il peut \u00e9galement \u00eatre n\u00e9cessaire d'ajouter un param\u00e8tre de configuration \"contrast : 60\". 20191210 : Les commandes int\u00e9gr\u00e9es T0, T1, T2, ... ont \u00e9t\u00e9 supprim\u00e9es. Les options de configuration activate_gcode et deactivate_gcode de l'extrudeuse ont \u00e9t\u00e9 supprim\u00e9es. Si ces commandes (et scripts) sont n\u00e9cessaires, d\u00e9finissez des macros individuelles de type [gcode_macro T0] qui appellent la commande ACTIVATE_EXTRUDER. Voir les fichiers config/sample-idex.cfg et sample-multi-extruder.cfg pour des exemples. 20191210 : La prise en charge de la commande M206 a \u00e9t\u00e9 supprim\u00e9e. Remplacer par des appels \u00e0 SET_GCODE_OFFSET. Si le support de M206 est n\u00e9cessaire, ajoutez une section de configuration [gcode_macro M206] qui appelle SET_GCODE_OFFSET. (Par exemple \"SET_GCODE_OFFSET Z=-{params.Z}\".) 20191202 : La prise en charge du param\u00e8tre non document\u00e9 \"S\" de la commande \"G4\" a \u00e9t\u00e9 supprim\u00e9e. Remplacez toutes les occurrences de S par le param\u00e8tre standard \"P\" (le d\u00e9lai sp\u00e9cifi\u00e9 en millisecondes). 20191126 : Les noms USB ont chang\u00e9 sur les micro-contr\u00f4leurs avec un support USB natif. Ils utilisent d\u00e9sormais un identifiant de puce unique par d\u00e9faut (lorsqu'il est disponible). Si une section de configuration \"mcu\" utilise un param\u00e8tre \"serial\" qui commence par \"/dev/serial/by-id/\", il peut \u00eatre n\u00e9cessaire de mettre \u00e0 jour la configuration. Ex\u00e9cutez \"ls /dev/serial/by-id/*\" dans un terminal ssh pour d\u00e9terminer le nouvel identifiant. 20191121 : Le param\u00e8tre pressure_advance_lookahead_time a \u00e9t\u00e9 supprim\u00e9. Voir example.cfg pour d'autres param\u00e8tres de configuration. 20191112 : La capacit\u00e9 d'activation virtuelle du pilote de pas \u00e0 pas tmc est d\u00e9sormais automatiquement activ\u00e9e si le moteur pas \u00e0 pas ne poss\u00e8de pas de broche d'activation d\u00e9di\u00e9e. Supprimez les r\u00e9f\u00e9rences \u00e0 tmcXXXX:virtual_enable de la configuration. La possibilit\u00e9 de contr\u00f4ler plusieurs broches dans la configuration enable_pin du moteur a \u00e9t\u00e9 supprim\u00e9e. Si plusieurs broches sont n\u00e9cessaires, utilisez une section de configuration multi_pin. 20191107 : La section de configuration de l'extrudeur primaire doit \u00eatre sp\u00e9cifi\u00e9e comme \"extruder\" et ne peut plus \u00eatre sp\u00e9cifi\u00e9e comme \"extruder0\". Les mod\u00e8les de commande Gcode qui interrogent le statut de l'extrudeur sont d\u00e9sormais accessibles via \"{printer.extruder}\". 20191021 : Sortie de Klipper v0.8.0 20191003 : L'option move_to_previous de [safe_z_homing] a d\u00e9sormais la valeur par d\u00e9faut False. (Elle \u00e9tait effectivement False avant 20190918.) 20190918 : L'option zhop de [safe_z_homing] est toujours r\u00e9appliqu\u00e9e apr\u00e8s la fin du homing sur l'axe Z. Cela peut obliger les utilisateurs \u00e0 mettre \u00e0 jour les scripts personnalis\u00e9s bas\u00e9s sur ce module. 20190806 : La commande SET_NEOPIXEL a \u00e9t\u00e9 renomm\u00e9e SET_LED. 20190726 : Le code num\u00e9rique-analogique du mcp4728 a \u00e9t\u00e9 modifi\u00e9. L'adresse i2c_address par d\u00e9faut est maintenant 0x60 et la r\u00e9f\u00e9rence de tension est maintenant relative \u00e0 la r\u00e9f\u00e9rence interne de 2,048 volts du mcp4728. 20190710 : L'option z_hop a \u00e9t\u00e9 supprim\u00e9e de la section de configuration [firmware_retract]. La prise en charge de z_hop \u00e9tait incompl\u00e8te et pouvait provoquer un comportement incorrect avec plusieurs trancheurs courants. 20190710 : Les param\u00e8tres optionnels de la commande PROBE_ACCURACY ont \u00e9t\u00e9 modifi\u00e9s. Il peut \u00eatre n\u00e9cessaire de mettre \u00e0 jour les macros ou les scripts qui utilisent cette commande. 20190628 : Toutes les options de configuration ont \u00e9t\u00e9 supprim\u00e9es de la section [skew_correction]. La configuration de la correction d'obliquit\u00e9 se fait d\u00e9sormais via le gcode SET_SKEW. Voir Correction de l'obliquit\u00e9 pour l'utilisation recommand\u00e9e. 20190607 : Les param\u00e8tres \"variable_X\" de gcode_macro (ainsi que le param\u00e8tre VALUE de SET_GCODE_VARIABLE) sont maintenant analys\u00e9s comme des litt\u00e9raux Python. Si une valeur doit \u00eatre assign\u00e9e \u00e0 une cha\u00eene de caract\u00e8res, mettez-la entre guillemets pour qu'elle soit \u00e9valu\u00e9e comme une cha\u00eene de caract\u00e8res. 20190606 : Les options de configuration \"samples\", \"samples_result\" et \"sample_retract_dist\" ont \u00e9t\u00e9 d\u00e9plac\u00e9es vers la section de configuration \"probe\". Ces options ne sont plus support\u00e9es dans les sections de configuration \"delta_calibrate\", \"bed_tilt\", \"bed_mesh\", \"screws_tilt_adjust\", \"z_tilt\", ou \"quad_gantry_level\". 20190528 : La variable magique \"status\" dans l'\u00e9valuation du mod\u00e8le gcode_macro a \u00e9t\u00e9 renomm\u00e9e en \"printer\". 20190520 : La commande SET_GCODE_OFFSET a \u00e9t\u00e9 modifi\u00e9e ; mettez \u00e0 jour vos macros de code G en cons\u00e9quence. La commande n'appliquera plus le d\u00e9calage demand\u00e9 \u00e0 la prochaine commande G1. L'ancien comportement peut \u00eatre approch\u00e9 en utilisant le nouveau param\u00e8tre \"MOVE=1\". 20190404 : Les paquets du logiciel h\u00f4te Python ont \u00e9t\u00e9 mis \u00e0 jour. Les utilisateurs devront r\u00e9ex\u00e9cuter le script ~/klipper/scripts/install-octopi.sh (ou mettre \u00e0 jour les d\u00e9pendances python s'ils n'utilisent pas une installation OctoPi standard). 20190404 : Les param\u00e8tres i2c_bus et spi_bus (dans diverses sections de configuration) prennent d\u00e9sormais un nom de bus au lieu d'un num\u00e9ro. 20190404 : Les param\u00e8tres de configuration du sx1509 ont chang\u00e9. Le param\u00e8tre 'adresse' est maintenant 'i2c_address' et doit \u00eatre sp\u00e9cifi\u00e9 comme un nombre d\u00e9cimal. L\u00e0 o\u00f9 0x3E \u00e9tait pr\u00e9c\u00e9demment utilis\u00e9, sp\u00e9cifiez 62. 20190328 : La valeur min_speed dans la configuration [temperature_fan] sera d\u00e9sormais respect\u00e9e et le ventilateur fonctionnera toujours \u00e0 cette vitesse ou plus en mode PID. 20190322 : La valeur par d\u00e9faut de \"driver_HEND\" dans les sections de configuration [tmc2660] a \u00e9t\u00e9 modifi\u00e9e de 6 \u00e0 3. Le champ \"driver_VSENSE\" a \u00e9t\u00e9 supprim\u00e9 (il est d\u00e9sormais calcul\u00e9 automatiquement \u00e0 partir de run_current). 20190310 : La section de configuration [controller_fan] prend d\u00e9sormais toujours un nom (tel que [controller_fan my_controller_fan]). 20190308 : Le champ \"driver_BLANK_TIME_SELECT\" dans les sections de configuration [tmc2130] et [tmc2208] a \u00e9t\u00e9 renomm\u00e9 \"driver_TBL\". 20190308 : La section config [tmc2660] a \u00e9t\u00e9 modifi\u00e9e. Un nouveau param\u00e8tre de configuration sense_resistor doit maintenant \u00eatre fourni. La signification de plusieurs des param\u00e8tres driver_XXX a \u00e9t\u00e9 modifi\u00e9e. 20190228 : Les utilisateurs de SPI ou I2C sur les cartes SAMD21 doivent maintenant sp\u00e9cifier les broches du bus via une section de configuration [samd_sercom]. 20190224 : L'option bed_shape a \u00e9t\u00e9 supprim\u00e9e de bed_mesh. L'option radius a \u00e9t\u00e9 renomm\u00e9e bed_radius. Les utilisateurs avec des lits ronds doivent fournir les options bed_radius et round_probe_count. 20190107 : Le param\u00e8tre i2c_address de la section config du mcp4451 a \u00e9t\u00e9 modifi\u00e9. Il s'agit d'un param\u00e8tre courant sur les Smoothieboards. La nouvelle valeur est la moiti\u00e9 de l'ancienne valeur (88 doit \u00eatre chang\u00e9 en 44, et 90 doit \u00eatre chang\u00e9 en 45). 20181220 : Sortie de Klipper v0.7.0","title":"Changements de configuration"},{"location":"Config_Changes.html#changements-de-configuration","text":"Ce document couvre les modifications logicielles apport\u00e9es au fichier de configuration qui ne sont pas r\u00e9tro compatibles. Il est conseill\u00e9 de consulter ce document lors de la mise \u00e0 jour du logiciel Klipper. Toutes les dates de ce document sont approximatives.","title":"Changements de configuration"},{"location":"Config_Changes.html#changements","text":"20230826: If safe_distance is set or calculated to be 0 in [dual_carriage] , the carriages proximity checks will be disabled as per documentation. A user may wish to configure safe_distance explicitly to prevent accidental crashes of the carriages with each other. Additionally, the homing order of the primary and the dual carriage is changed in some configurations (certain configurations when both carriages home in the same direction, see [dual_carriage] configuration reference for more details). 20230810: The flash-sdcard.sh script now supports both variants of the Bigtreetech SKR-3, STM32H743 and STM32H723. For this, the original tag of btt-skr-3 now has changed to be either btt-skr-3-h743 or btt-skr-3-h723. 20230729: The exported status for dual_carriage is changed. Instead of exporting mode and active_carriage , the individual modes for each carriage are exported as printer.dual_carriage.carriage_0 and printer.dual_carriage.carriage_1 . 20230619: The relative_reference_index option has been deprecated and superceded by the zero_reference_position option. Refer to the Bed Mesh Documentation for details on how to update the configuration. With this deprecation the RELATIVE_REFERENCE_INDEX is no longer available as a parameter for the BED_MESH_CALIBRATE gcode command. 20230530: The default canbus frequency in \"make menuconfig\" is now 1000000. If using canbus and using canbus with some other frequency is required, then be sure to select \"Enable extra low-level configuration options\" and specify the desired \"CAN bus speed\" in \"make menuconfig\" when compiling and flashing the micro-controller. 20230525: SHAPER_CALIBRATE command immediately applies input shaper parameters if [input_shaper] was enabled already. 20230407: The stalled_bytes counter in the log and in the printer.mcu.last_stats field has been renamed to upcoming_bytes . 20230323: On tmc5160 drivers multistep_filt is now enabled by default. Set driver_MULTISTEP_FILT: False in the tmc5160 config for the previous behavior. 20230304 : La commande SET_TMC_CURRENT ajuste d\u00e9sormais correctement le registre globalscaler pour les pilotes qui l'ont. Cela supprime une limitation o\u00f9 sur tmc5160, les courants ne pouvaient pas \u00eatre augment\u00e9s plus haut avec SET_TMC_CURRENT que la valeur run_current d\u00e9finie dans le fichier de configuration. Cependant, cela a un effet secondaire : apr\u00e8s avoir ex\u00e9cut\u00e9 SET_TMC_CURRENT , le moteur pas \u00e0 pas doit \u00eatre maintenu \u00e0 l'arr\u00eat pendant plus de 130 ms dans le cas o\u00f9 StealthChop2 est utilis\u00e9 afin que l'\u00e9talonnage AT#1 soit ex\u00e9cut\u00e9 par le pilote. 20230202 : Le format des informations d'\u00e9tat printer.screws_tilt_adjust a chang\u00e9. Les informations sont maintenant stock\u00e9es sous forme de dictionnaire de vis avec les mesures r\u00e9sultantes. Voir la r\u00e9f\u00e9rence d'\u00e9tat pour plus de d\u00e9tails. 20230201 : Le module [bed_mesh] ne charge plus le profil default au d\u00e9marrage. Il est recommand\u00e9 aux utilisateurs qui utilisent le profil default d'ajouter BED_MESH_PROFILE LOAD=default \u00e0 leur macro START_PRINT (ou \u00e0 la configuration \"Start G-Code\" de leur trancheur si applicable). 20230103 : Il est maintenant possible avec le script flash-sdcard.sh de flasher les deux variantes du Bigtreetech SKR-2, STM32F407 et STM32F429. Cela signifie que le tag originel de btt-skr2 a maintenant chang\u00e9 en btt-skr-2-f407 ou btt-skr-2-f429. 20221128 : Sortie de Klipper v0.11.0. 20221122 : Auparavant, avec safe_z_home, il \u00e9tait possible que le z_hop apr\u00e8s la mise \u00e0 l'origine g28 aille dans une direction z n\u00e9gative. Maintenant, un saut en z n'est effectu\u00e9 apr\u00e8s g28 que s'il r\u00e9sulte en un saut positif, refl\u00e9tant le comportement du saut en z se produisant avant la mise \u00e0 l'origine g28. 20220616 : Il \u00e9tait auparavant possible de flasher un rp2040 en mode bootloader en ex\u00e9cutant make flash FLASH_DEVICE=first . La commande \u00e9quivalente est maintenant make flash FLASH_DEVICE=2e8a:0003 . 20220612 : Le micro-contr\u00f4leur rp2040 a maintenant une solution de contournement pour l'errata USB \"rp2040-e5\". Cela devrait rendre les premi\u00e8res connexions USB plus fiables. Cependant, cela peut entra\u00eener un changement de comportement de la broche gpio15. Il est peu probable que le changement de comportement de la gpio15 soit perceptible. 20220407 : L'option de configuration pid_integral_max de temperature_fan a \u00e9t\u00e9 supprim\u00e9e (elle \u00e9tait obsol\u00e8te depuis 20210612). 20220407 : L'ordre des couleurs par d\u00e9faut pour les LEDs pca9632 est maintenant \"RGBW\". Ajoutez un param\u00e8tre explicite color_order : RBGW \u00e0 la section pca9632 config pour obtenir le comportement pr\u00e9c\u00e9dent. 20220330 : Le format des informations d'\u00e9tat printer.neopixel.color_data des modules neopixel et dotstar a chang\u00e9. L'information est maintenant stock\u00e9e comme une liste de listes de couleurs (au lieu d'une liste de dictionnaires). Voir la r\u00e9f\u00e9rence d'\u00e9tat pour plus de d\u00e9tails. 20220307 : M73 ne mettra plus la progression de l'impression \u00e0 0 si P est absent. 20220304 : Il n'y a plus de valeur par d\u00e9faut pour le param\u00e8tre extruder des sections de configuration extruder_stepper . Si vous le souhaitez, sp\u00e9cifiez explicitement extruder : extruder pour associer le moteur pas \u00e0 pas \u00e0 la file d'attente de mouvement \"extruder\" au d\u00e9marrage. 20220210 : La commande SYNC_STEPPER_TO_EXTRUDER est obsol\u00e8te ; la commande SET_EXTRUDER_STEP_DISTANCE est obsol\u00e8te ; l'option de configuration shared_heater de l' extrudeuse est obsol\u00e8te. Ces fonctionnalit\u00e9s seront supprim\u00e9es dans un futur proche. Remplacez SET_EXTRUDER_STEP_DISTANCE par SET_EXTRUDER_ROTATION_DISTANCE . Remplacez SYNC_STEPPER_TO_EXTRUDER par SYNC_EXTRUDER_MOTION . Remplacez les sections de configuration de l'extrudeuse utilisant shared_heater par les sections de configuration extruder_stepper et mettez \u00e0 jour toutes les macros d'activation pour utiliser SYNC_EXTRUDER_MOTION . 20220116 : Le code de calcul run_current des tmc2130, tmc2208, tmc2209, et tmc2660 a chang\u00e9. Pour certains param\u00e8tres run_current les pilotes peuvent maintenant \u00eatre configur\u00e9s diff\u00e9remment. Cette nouvelle configuration devrait \u00eatre plus pr\u00e9cise, mais elle peut invalider les r\u00e9glages pr\u00e9c\u00e9dents des pilotes tmc. 20211230 : Les scripts pour ajuster le fa\u00e7onneur d'entr\u00e9e ( scripts/calibrate_shaper.py et scripts/graph_accelerometer.py ) ont \u00e9t\u00e9 migr\u00e9s pour utiliser Python3 par d\u00e9faut. Par cons\u00e9quent, les utilisateurs doivent installer les versions Python3 de certains paquets (par exemple, sudo apt install python3-numpy python3-matplotlib ) pour continuer \u00e0 utiliser ces scripts. Pour plus de d\u00e9tails, reportez-vous \u00e0 Installation du logiciel . Alternativement, les utilisateurs peuvent temporairement forcer l'ex\u00e9cution de ces scripts sous Python 2 en appelant explicitement l'interpr\u00e9teur Python2 dans la console : python2 ~/klipper/scripts/calibrate_shaper.py ... 20211110 : Le capteur de temp\u00e9rature \"NTC 100K beta 3950\" est d\u00e9pr\u00e9ci\u00e9. Ce capteur sera supprim\u00e9 dans un avenir proche. La plupart des utilisateurs trouveront le capteur de temp\u00e9rature \"Generic 3950\" plus pr\u00e9cis. Pour continuer \u00e0 utiliser l'ancienne d\u00e9finition (g\u00e9n\u00e9ralement moins pr\u00e9cise), d\u00e9finissez une thermistance personnalis\u00e9e avec temp\u00e9rature1 : 25 , r\u00e9sistance1 : 100000 , et beta : 3950 . 20211104 : L'option \"step pulse duration\" dans \"make menuconfig\" a \u00e9t\u00e9 supprim\u00e9e. La dur\u00e9e d'impulsion par d\u00e9faut pour les pilotes TMC configur\u00e9s en mode UART ou SPI est maintenant de 100ns. Un nouveau param\u00e8tre step_pulse_duration dans la section configuration des moteurs doit \u00eatre d\u00e9fini pour tous les moteurs n\u00e9cessitant une dur\u00e9e d'impulsion personnalis\u00e9e. 20211102 : Plusieurs fonctionnalit\u00e9s obsol\u00e8tes ont \u00e9t\u00e9 supprim\u00e9es. L'option step_distance du stepper a \u00e9t\u00e9 supprim\u00e9e (obsol\u00e8te depuis 20201222). L'alias du capteur rpi_temperature a \u00e9t\u00e9 supprim\u00e9 (obsol\u00e8te depuis 20210219). L'option mcu pin_map a \u00e9t\u00e9 supprim\u00e9e (obsol\u00e8te depuis 20210325). L'option gcode_macro default_parameter_<name> et l'acc\u00e8s aux param\u00e8tres de commande par la macro autrement que par la pseudo-variable params ont \u00e9t\u00e9 supprim\u00e9s (obsol\u00e8te depuis 20210503). L'option heater pid_integral_max a \u00e9t\u00e9 supprim\u00e9e (obsol\u00e8te le 20210612). 20210929 : Sortie de Klipper v0.10.0. 20210903 : La valeur par d\u00e9faut de smooth_time pour les \u00e9l\u00e9ments chauffants est pass\u00e9e \u00e0 1 seconde (au lieu de 2 secondes). Pour la plupart des imprimantes, cela permettra un contr\u00f4le plus stable de la temp\u00e9rature. 20210830 : Le nom par d\u00e9faut de adxl345 est maintenant \"adxl345\". Le param\u00e8tre CHIP par d\u00e9faut pour les fonctions ACCELEROMETER_MEASURE et ACCELEROMETER_QUERY est maintenant aussi \"adxl345\". 20210830 : La commande adxl345 ACCELEROMETER_MEASURE ne prend plus en charge un param\u00e8tre RATE. Pour modifier le taux d'interrogation, mettez \u00e0 jour le fichier printer.cfg et lancez une commande RESTART. 20210821 : Plusieurs param\u00e8tres de configuration dans printer.configfile.settings seront maintenant rapport\u00e9s sous forme de listes au lieu de cha\u00eenes brutes. Si vous souhaitez obtenir une cha\u00eene de caract\u00e8res brute, utilisez printer.configfile.config \u00e0 la place. 20210819 : Dans certains cas, un mouvement de retour \u00e0 l'origine G28 peut se terminer dans une position qui est nominalement en dehors de la plage de mouvement valide. Dans de rares situations, cela peut entra\u00eener des erreurs d\u00e9routantes \"Move out of range\" apr\u00e8s le retour \u00e0 la position initiale. Si cela se produit, modifiez vos scripts de d\u00e9marrage pour d\u00e9placer la t\u00eate d'outil vers une position valide imm\u00e9diatement apr\u00e8s le retour \u00e0 la position initiale. 20210814 : Les pseudo-pins analogiques sur l'atmega168 et l'atmega328 ont \u00e9t\u00e9 renomm\u00e9s de PE0/PE1 \u00e0 PE2/PE3. 20210720 : Une section controller_fan surveille maintenant tous les moteurs pas \u00e0 pas par d\u00e9faut (pas seulement les moteurs pas \u00e0 pas cin\u00e9matiques). Si le comportement pr\u00e9c\u00e9dent est souhait\u00e9, voir l'option de configuration stepper dans la r\u00e9f\u00e9rence de configuration . 20210703 : Une section de configuration samd_sercom doit maintenant sp\u00e9cifier le bus sercom qu'elle configure via l'option sercom . 20210612 : l'option de configuration pid_integral_max dans les sections heater et temperature_fan est obsol\u00e8te. Cette option sera supprim\u00e9e dans les prochaines versions. 20210503: The gcode_macro default_parameter_<name> config option is deprecated. Use the params pseudo-variable to access macro parameters. Other methods for accessing macro parameters will be removed in the near future. Most users can replace a default_parameter_NAME: VALUE config option with a line like the following in the start of the macro: {% set NAME = params.NAME|default(VALUE)|float %} . See the Command Templates document for examples. 20210430 : la commande SET_VELOCITY_LIMIT (et M204) peuvent maintenant d\u00e9finir une \"velocity\", \"acceleration\", et \"square_corner_velocity\" sup\u00e9rieurs aux valeurs sp\u00e9cifi\u00e9es dans le fichier de configuration. 20210325 : La prise en charge de l'option de configuration pin_map est obsol\u00e8te. Utilisez le fichier sample-aliases.cfg pour traduire les noms des broches r\u00e9elles du microcontr\u00f4leur. L'option de configuration pin_map sera supprim\u00e9e dans les prochaines version. 20210313 : La prise en charge de Klipper pour les microcontr\u00f4leurs CAN bus a \u00e9t\u00e9 modifi\u00e9e. Si vous utilisez CANBus, tous les microcontr\u00f4leurs doivent \u00eatre reflash\u00e9s et le fichier de configuration de Klipper doit \u00eatre mise \u00e0 jour . 20210310 : la valeur par d\u00e9faut de driver_SFILT pour les TMC2660 a \u00e9t\u00e9 modifi\u00e9e : passage de 1 \u00e0 0 par d\u00e9faut. 20210227 : Les pilotes de moteur pas \u00e0 pas TMC en mode UART ou SPI sont d\u00e9sormais interrog\u00e9s une fois par seconde si ils sont activ\u00e9s - si le pilote ne peut pas \u00eatre contact\u00e9 ou si le pilote signale une erreur, alors Klipper passera \u00e0 un \u00e9tat d'arr\u00eat. 20210219 : Le module rpi_temperature a \u00e9t\u00e9 renomm\u00e9 en temperature_host . Remplacez toutes les occurrences de sensor_type : rpi_temperature par sensor_type : temperature_host . Le chemin vers le fichier de temp\u00e9rature peut \u00eatre sp\u00e9cifi\u00e9 dans la variable de configuration sensor_path . Le nom rpi_temperature est obsol\u00e8te et sera supprim\u00e9 dans les prochaines versions. 20210201: La commande TEST_RESONANCES va maintenant d\u00e9sactiver la mise en forme des entr\u00e9es si elle \u00e9tait pr\u00e9c\u00e9demment activ\u00e9e (et la r\u00e9activer apr\u00e8s le test). Afin d'outrepasser ce comportement et de garder la mise en forme de l'entr\u00e9e activ\u00e9e, on peut passer un param\u00e8tre suppl\u00e9mentaire INPUT_SHAPING=1 \u00e0 la commande. 20210201 : La commande ACCELEROMETER_MEASURE ajoutera d\u00e9sormais le nom de la puce acc\u00e9l\u00e9rom\u00e8tre au nom du fichier de sortie si un nom a \u00e9t\u00e9 donn\u00e9 \u00e0 la puce dans la section adxl345 correspondante du printer.cfg. 20201222 : Le param\u00e8tre step_distance dans les sections de configuration de moteur est obsol\u00e8te. Il est conseill\u00e9 de mettre \u00e0 jour la configuration pour utiliser le param\u00e8tre rotation_distance . Le support de step_distance sera supprim\u00e9 dans un futur proche. 20201218 : Le param\u00e8tre endstop_phase du module endstop_phase a \u00e9t\u00e9 remplac\u00e9 par trigger_phase . Si vous utilisez le module endstop phases, il sera n\u00e9cessaire de convertir en rotation_distance et de recalibrer les phases endstop en ex\u00e9cutant la commande ENDSTOP_PHASE_CALIBRATE. 20201218 : Les imprimantes rotatives delta et polaires doivent maintenant sp\u00e9cifier un gear_ratio pour leurs moteurs rotatifs, et elles ne peuvent plus sp\u00e9cifier un param\u00e8tre step_distance . Voir la r\u00e9f\u00e9rence de configuration pour le format du nouveau param\u00e8tre gear_ratio. 20201213 : Il n'est pas valide de sp\u00e9cifier un Z \"position_endstop\" lors de l'utilisation de \"probe:z_virtual_endstop\". Une erreur sera maintenant soulev\u00e9e si un Z \"position_endstop\" est sp\u00e9cifi\u00e9 avec \"probe:z_virtual_endstop\". Supprimez la d\u00e9finition de Z \"position_endstop\" pour corriger l'erreur. 20201120 : La section de configuration [board_pins] sp\u00e9cifie maintenant le nom du mcu dans un param\u00e8tre explicite mcu: . Si vous utilisez board_pins pour un mcu secondaire, alors la config doit \u00eatre mise \u00e0 jour pour sp\u00e9cifier ce nom. Voir la r\u00e9f\u00e9rence config pour plus de d\u00e9tails. 20201112 : La dur\u00e9e rapport\u00e9e par print_stats.print_duration a chang\u00e9. La dur\u00e9e pr\u00e9c\u00e9dant la premi\u00e8re extrusion d\u00e9tect\u00e9e est maintenant exclue. 20201029 : L'option de configuration neopixel color_order_GRB a \u00e9t\u00e9 supprim\u00e9e. Si n\u00e9cessaire, mettez \u00e0 jour la configuration pour d\u00e9finir la nouvelle option color_order sur RGB, GRB, RGBW, ou GRBW. 20201029 : L'option serial dans la section mcu config ne prend plus par d\u00e9faut /dev/ttyS0. Dans la rare situation o\u00f9 /dev/ttyS0 est le port s\u00e9rie d\u00e9sir\u00e9, il doit \u00eatre indiqu\u00e9 explicitement. 20201020 : Sortie de Klipper v0.9.0. 20200902 : Le calcul de la r\u00e9sistance \u00e0 la temp\u00e9rature des RTD des convertisseurs MAX31865 a \u00e9t\u00e9 corrig\u00e9 pour ne pas lire une valeur basse. Si vous utilisez un tel dispositif, vous devez recalibrer votre temp\u00e9rature d'impression et vos param\u00e8tres PID. 20200816 : L'objet macro gcode printer.gcode a \u00e9t\u00e9 renomm\u00e9 en printer.gcode_move . Plusieurs variables non document\u00e9es dans printer.toolhead et printer.gcode ont \u00e9t\u00e9 supprim\u00e9es. Voir docs/Command_Templates.md pour une liste des variables de mod\u00e8les disponibles. 20200816 : Le syst\u00e8me de macro gcode \"action_\" a chang\u00e9. Remplacez tout appel \u00e0 printer.gcode.action_emergency_stop() par action_emergency_stop() , printer.gcode.action_respond_info() par action_respond_info() , et printer.gcode.action_respond_error() par action_raise_error() . 20200809 : Le syst\u00e8me de menu a \u00e9t\u00e9 r\u00e9\u00e9crit. Si le menu a \u00e9t\u00e9 personnalis\u00e9, il sera n\u00e9cessaire de le mettre \u00e0 jour avec la nouvelle configuration. Voir config/example-menu.cfg pour les d\u00e9tails de la configuration et voir klippy/extras/display/menu.cfg pour les exemples. 20200731 : Le comportement de l'attribut progress rapport\u00e9 par l'objet imprimante virtual_sdcard a chang\u00e9. La progression n'est plus remise \u00e0 0 lorsqu'une impression est mise en pause. La progression est maintenant toujours bas\u00e9e sur la position interne du fichier, ou 0 si aucun fichier n'est charg\u00e9. 20200725 : Le param\u00e8tre de configuration enable du servo et le param\u00e8tre SET_SERVO ENABLE ont \u00e9t\u00e9 supprim\u00e9s. Mettez \u00e0 jour toutes les macros pour utiliser SET_SERVO SERVO=my_servo WIDTH=0 pour d\u00e9sactiver un servo. 20200608 : Le support de l'affichage LCD a chang\u00e9 le nom de certains \"glyphes\" internes. Si une disposition d'affichage personnalis\u00e9e a \u00e9t\u00e9 impl\u00e9ment\u00e9e, il peut \u00eatre n\u00e9cessaire d'actualiser avec les noms actuels de glyphes (voir klippy/extras/display/display.cfg pour une liste des glyphes disponibles). 20200606 : Les noms des broches sur linux mcu ont chang\u00e9. Les broches ont maintenant des noms de la forme gpiochip<chipid>/gpio<gpio> . Pour gpiochip0 vous pouvez aussi utiliser un court gpio<gpio> . Par exemple, ce qui \u00e9tait pr\u00e9c\u00e9demment appel\u00e9 P20 devient maintenant gpio20 ou `gpiochip0/gpio20``. 20200603 : La disposition par d\u00e9faut de l'\u00e9cran LCD 16x4 n'affiche plus le temps estim\u00e9 restant pour une impression. (Seul le temps \u00e9coul\u00e9 sera affich\u00e9.) Si l'on souhaite conserver l'ancien comportement, on peut personnaliser l'affichage du menu avec cette information (voir la description de display_data dans config/example-extras.cfg pour plus de d\u00e9tails). 20200531 : L'id par d\u00e9faut du vendeur/produit USB est maintenant 0x1d50/0x614e. Ces nouveaux identifiants sont r\u00e9serv\u00e9s \u00e0 Klipper (gr\u00e2ce au projet openmoko). Ce changement ne devrait pas n\u00e9cessiter de modification de la configuration, mais les nouveaux identifiants peuvent appara\u00eetre dans les journaux syst\u00e8me. 20200524 : La valeur par d\u00e9faut du champ pwm_freq du tmc5160 est maintenant z\u00e9ro (au lieu de un). 20200425 : La variable du mod\u00e8le de commande gcode_macro printer.heater a \u00e9t\u00e9 renomm\u00e9e en printer.heaters . 20200313 : La disposition par d\u00e9faut de l'\u00e9cran pour les imprimantes multi-extrudeurs avec un \u00e9cran 16x4 a chang\u00e9. La disposition de l'\u00e9cran pour un seul extrudeur est maintenant la disposition par d\u00e9faut et elle montrera l'extrudeur actuellement actif. Pour utiliser la disposition d'\u00e9cran pr\u00e9c\u00e9dente, d\u00e9finissez \"display_group : _multiextruder_16x4\" dans la section [display] du fichier printer.cfg. 20200308 : L'\u00e9l\u00e9ment de menu par d\u00e9faut __test a \u00e9t\u00e9 supprim\u00e9. Si le fichier de configuration a un menu personnalis\u00e9, assurez-vous de supprimer toutes les r\u00e9f\u00e9rences \u00e0 cet \u00e9l\u00e9ment de menu __test . 20200308 : Les options \"deck\" et \"card\" du menu ont \u00e9t\u00e9 supprim\u00e9es. Pour personnaliser la disposition d'un \u00e9cran lcd, utilisez les nouvelles sections de configuration display_data (voir config/example-extras.cfg pour les d\u00e9tails). 20200109 : Le module bed_mesh fait d\u00e9sormais r\u00e9f\u00e9rence \u00e0 l'emplacement de la sonde pour la configuration du maillage. Ainsi, certaines options de configuration ont \u00e9t\u00e9 renomm\u00e9es pour mieux refl\u00e9ter leur fonctionnalit\u00e9. Pour les lits rectangulaires, min_point et max_point ont \u00e9t\u00e9 renomm\u00e9s en mesh_min et mesh_max respectivement. Pour les lits ronds, bed_radius a \u00e9t\u00e9 renomm\u00e9 en mesh_radius . Une nouvelle option mesh_origin a \u00e9galement \u00e9t\u00e9 ajout\u00e9e pour les lits ronds. Notez que ces changements sont \u00e9galement incompatibles avec les profils de maillage pr\u00e9c\u00e9demment enregistr\u00e9s. Si un profil incompatible est d\u00e9tect\u00e9, il sera ignor\u00e9 et sa suppression sera programm\u00e9e. Le processus de suppression peut \u00eatre achev\u00e9 en lan\u00e7ant la commande SAVE_CONFIG. L'utilisateur devra recalibrer chaque profil. 20191218 : La section de configuration de l'affichage ne prend plus en charge \"lcd_type : st7567\". Utilisez le type d'affichage \"uc1701\" \u00e0 la place - d\u00e9finissez \"lcd_type : uc1701\" et changez \"rs_pin : some_pin\" en \"rst_pin : some_pin\". Il peut \u00e9galement \u00eatre n\u00e9cessaire d'ajouter un param\u00e8tre de configuration \"contrast : 60\". 20191210 : Les commandes int\u00e9gr\u00e9es T0, T1, T2, ... ont \u00e9t\u00e9 supprim\u00e9es. Les options de configuration activate_gcode et deactivate_gcode de l'extrudeuse ont \u00e9t\u00e9 supprim\u00e9es. Si ces commandes (et scripts) sont n\u00e9cessaires, d\u00e9finissez des macros individuelles de type [gcode_macro T0] qui appellent la commande ACTIVATE_EXTRUDER. Voir les fichiers config/sample-idex.cfg et sample-multi-extruder.cfg pour des exemples. 20191210 : La prise en charge de la commande M206 a \u00e9t\u00e9 supprim\u00e9e. Remplacer par des appels \u00e0 SET_GCODE_OFFSET. Si le support de M206 est n\u00e9cessaire, ajoutez une section de configuration [gcode_macro M206] qui appelle SET_GCODE_OFFSET. (Par exemple \"SET_GCODE_OFFSET Z=-{params.Z}\".) 20191202 : La prise en charge du param\u00e8tre non document\u00e9 \"S\" de la commande \"G4\" a \u00e9t\u00e9 supprim\u00e9e. Remplacez toutes les occurrences de S par le param\u00e8tre standard \"P\" (le d\u00e9lai sp\u00e9cifi\u00e9 en millisecondes). 20191126 : Les noms USB ont chang\u00e9 sur les micro-contr\u00f4leurs avec un support USB natif. Ils utilisent d\u00e9sormais un identifiant de puce unique par d\u00e9faut (lorsqu'il est disponible). Si une section de configuration \"mcu\" utilise un param\u00e8tre \"serial\" qui commence par \"/dev/serial/by-id/\", il peut \u00eatre n\u00e9cessaire de mettre \u00e0 jour la configuration. Ex\u00e9cutez \"ls /dev/serial/by-id/*\" dans un terminal ssh pour d\u00e9terminer le nouvel identifiant. 20191121 : Le param\u00e8tre pressure_advance_lookahead_time a \u00e9t\u00e9 supprim\u00e9. Voir example.cfg pour d'autres param\u00e8tres de configuration. 20191112 : La capacit\u00e9 d'activation virtuelle du pilote de pas \u00e0 pas tmc est d\u00e9sormais automatiquement activ\u00e9e si le moteur pas \u00e0 pas ne poss\u00e8de pas de broche d'activation d\u00e9di\u00e9e. Supprimez les r\u00e9f\u00e9rences \u00e0 tmcXXXX:virtual_enable de la configuration. La possibilit\u00e9 de contr\u00f4ler plusieurs broches dans la configuration enable_pin du moteur a \u00e9t\u00e9 supprim\u00e9e. Si plusieurs broches sont n\u00e9cessaires, utilisez une section de configuration multi_pin. 20191107 : La section de configuration de l'extrudeur primaire doit \u00eatre sp\u00e9cifi\u00e9e comme \"extruder\" et ne peut plus \u00eatre sp\u00e9cifi\u00e9e comme \"extruder0\". Les mod\u00e8les de commande Gcode qui interrogent le statut de l'extrudeur sont d\u00e9sormais accessibles via \"{printer.extruder}\". 20191021 : Sortie de Klipper v0.8.0 20191003 : L'option move_to_previous de [safe_z_homing] a d\u00e9sormais la valeur par d\u00e9faut False. (Elle \u00e9tait effectivement False avant 20190918.) 20190918 : L'option zhop de [safe_z_homing] est toujours r\u00e9appliqu\u00e9e apr\u00e8s la fin du homing sur l'axe Z. Cela peut obliger les utilisateurs \u00e0 mettre \u00e0 jour les scripts personnalis\u00e9s bas\u00e9s sur ce module. 20190806 : La commande SET_NEOPIXEL a \u00e9t\u00e9 renomm\u00e9e SET_LED. 20190726 : Le code num\u00e9rique-analogique du mcp4728 a \u00e9t\u00e9 modifi\u00e9. L'adresse i2c_address par d\u00e9faut est maintenant 0x60 et la r\u00e9f\u00e9rence de tension est maintenant relative \u00e0 la r\u00e9f\u00e9rence interne de 2,048 volts du mcp4728. 20190710 : L'option z_hop a \u00e9t\u00e9 supprim\u00e9e de la section de configuration [firmware_retract]. La prise en charge de z_hop \u00e9tait incompl\u00e8te et pouvait provoquer un comportement incorrect avec plusieurs trancheurs courants. 20190710 : Les param\u00e8tres optionnels de la commande PROBE_ACCURACY ont \u00e9t\u00e9 modifi\u00e9s. Il peut \u00eatre n\u00e9cessaire de mettre \u00e0 jour les macros ou les scripts qui utilisent cette commande. 20190628 : Toutes les options de configuration ont \u00e9t\u00e9 supprim\u00e9es de la section [skew_correction]. La configuration de la correction d'obliquit\u00e9 se fait d\u00e9sormais via le gcode SET_SKEW. Voir Correction de l'obliquit\u00e9 pour l'utilisation recommand\u00e9e. 20190607 : Les param\u00e8tres \"variable_X\" de gcode_macro (ainsi que le param\u00e8tre VALUE de SET_GCODE_VARIABLE) sont maintenant analys\u00e9s comme des litt\u00e9raux Python. Si une valeur doit \u00eatre assign\u00e9e \u00e0 une cha\u00eene de caract\u00e8res, mettez-la entre guillemets pour qu'elle soit \u00e9valu\u00e9e comme une cha\u00eene de caract\u00e8res. 20190606 : Les options de configuration \"samples\", \"samples_result\" et \"sample_retract_dist\" ont \u00e9t\u00e9 d\u00e9plac\u00e9es vers la section de configuration \"probe\". Ces options ne sont plus support\u00e9es dans les sections de configuration \"delta_calibrate\", \"bed_tilt\", \"bed_mesh\", \"screws_tilt_adjust\", \"z_tilt\", ou \"quad_gantry_level\". 20190528 : La variable magique \"status\" dans l'\u00e9valuation du mod\u00e8le gcode_macro a \u00e9t\u00e9 renomm\u00e9e en \"printer\". 20190520 : La commande SET_GCODE_OFFSET a \u00e9t\u00e9 modifi\u00e9e ; mettez \u00e0 jour vos macros de code G en cons\u00e9quence. La commande n'appliquera plus le d\u00e9calage demand\u00e9 \u00e0 la prochaine commande G1. L'ancien comportement peut \u00eatre approch\u00e9 en utilisant le nouveau param\u00e8tre \"MOVE=1\". 20190404 : Les paquets du logiciel h\u00f4te Python ont \u00e9t\u00e9 mis \u00e0 jour. Les utilisateurs devront r\u00e9ex\u00e9cuter le script ~/klipper/scripts/install-octopi.sh (ou mettre \u00e0 jour les d\u00e9pendances python s'ils n'utilisent pas une installation OctoPi standard). 20190404 : Les param\u00e8tres i2c_bus et spi_bus (dans diverses sections de configuration) prennent d\u00e9sormais un nom de bus au lieu d'un num\u00e9ro. 20190404 : Les param\u00e8tres de configuration du sx1509 ont chang\u00e9. Le param\u00e8tre 'adresse' est maintenant 'i2c_address' et doit \u00eatre sp\u00e9cifi\u00e9 comme un nombre d\u00e9cimal. L\u00e0 o\u00f9 0x3E \u00e9tait pr\u00e9c\u00e9demment utilis\u00e9, sp\u00e9cifiez 62. 20190328 : La valeur min_speed dans la configuration [temperature_fan] sera d\u00e9sormais respect\u00e9e et le ventilateur fonctionnera toujours \u00e0 cette vitesse ou plus en mode PID. 20190322 : La valeur par d\u00e9faut de \"driver_HEND\" dans les sections de configuration [tmc2660] a \u00e9t\u00e9 modifi\u00e9e de 6 \u00e0 3. Le champ \"driver_VSENSE\" a \u00e9t\u00e9 supprim\u00e9 (il est d\u00e9sormais calcul\u00e9 automatiquement \u00e0 partir de run_current). 20190310 : La section de configuration [controller_fan] prend d\u00e9sormais toujours un nom (tel que [controller_fan my_controller_fan]). 20190308 : Le champ \"driver_BLANK_TIME_SELECT\" dans les sections de configuration [tmc2130] et [tmc2208] a \u00e9t\u00e9 renomm\u00e9 \"driver_TBL\". 20190308 : La section config [tmc2660] a \u00e9t\u00e9 modifi\u00e9e. Un nouveau param\u00e8tre de configuration sense_resistor doit maintenant \u00eatre fourni. La signification de plusieurs des param\u00e8tres driver_XXX a \u00e9t\u00e9 modifi\u00e9e. 20190228 : Les utilisateurs de SPI ou I2C sur les cartes SAMD21 doivent maintenant sp\u00e9cifier les broches du bus via une section de configuration [samd_sercom]. 20190224 : L'option bed_shape a \u00e9t\u00e9 supprim\u00e9e de bed_mesh. L'option radius a \u00e9t\u00e9 renomm\u00e9e bed_radius. Les utilisateurs avec des lits ronds doivent fournir les options bed_radius et round_probe_count. 20190107 : Le param\u00e8tre i2c_address de la section config du mcp4451 a \u00e9t\u00e9 modifi\u00e9. Il s'agit d'un param\u00e8tre courant sur les Smoothieboards. La nouvelle valeur est la moiti\u00e9 de l'ancienne valeur (88 doit \u00eatre chang\u00e9 en 44, et 90 doit \u00eatre chang\u00e9 en 45). 20181220 : Sortie de Klipper v0.7.0","title":"Changements"},{"location":"Config_Reference.html","text":"R\u00e9f\u00e9rence de configuration \u00b6 Ce document est la r\u00e9f\u00e9rence des options disponibles dans le fichier de configuration de Klipper. Les descriptions de ce document sont format\u00e9es de mani\u00e8re \u00e0 ce qu'il soit possible de les copier-coller dans un fichier de configuration d'imprimante. Consultez le document d'installation pour obtenir des informations sur la configuration de Klipper et le choix d'un fichier de configuration initial. Configuration du microcontr\u00f4leur \u00b6 Format du nom des broches du microcontr\u00f4leur \u00b6 De nombreuses options de configuration n\u00e9cessitent le nom d'une broche du micro-contr\u00f4leur. Klipper utilise les noms mat\u00e9riel pour ces broches - par exemple PA4 . Les noms des broches peuvent \u00eatre pr\u00e9c\u00e9d\u00e9s de ! pour indiquer qu'une polarit\u00e9 inverse doit \u00eatre utilis\u00e9e (par exemple, d\u00e9clencher sur le niveau bas au lieu du niveau haut). Les broches d'entr\u00e9e peuvent \u00eatre pr\u00e9c\u00e9d\u00e9es de ^ pour indiquer qu'une r\u00e9sistance pull-up mat\u00e9rielle doit \u00eatre activ\u00e9e pour cette broche. Si le micro-contr\u00f4leur supporte les r\u00e9sistances pull-down, une broche d'entr\u00e9e peut \u00e9galement \u00eatre pr\u00e9c\u00e9d\u00e9e de ~ . Notez que certaines sections de configuration peuvent \"cr\u00e9er\" des broches suppl\u00e9mentaires. Lorsque cela se produit, la section de configuration d\u00e9finissant ces broches doit \u00eatre r\u00e9pertori\u00e9e dans le fichier de configuration avant toute section utilisant celles-ci. [mcu| \u00b6 Configuration du microcontr\u00f4leur primaire. [mcu] serial: # Le port s\u00e9rie \u00e0 connecter \u00e0 l'unit\u00e9 MCU. Si vous n'\u00eates pas s\u00fbr (ou s'il # change) consultez la section \"O\u00f9 est mon port s\u00e9rie ?\" de la FAQ. # Ce param\u00e8tre doit \u00eatre fourni lors de l'utilisation d'un port s\u00e9rie. #baud: 250000 # Le d\u00e9bit en bauds \u00e0 utiliser. La valeur par d\u00e9faut est 250000. #canbus_uuid: # Si vous utilisez un dispositif connect\u00e9 \u00e0 un bus CAN, ceci d\u00e9finit l'identifiant # unique de la puce \u00e0 laquelle se connecter. Cette valeur doit \u00eatre fournie lorsque l'on utilise # le bus CAN pour la communication. #canbus_interface: # Si vous utilisez un dispositif connect\u00e9 \u00e0 un bus CAN, ceci d\u00e9finit l'interface r\u00e9seau CAN # \u00e0 utiliser. La valeur par d\u00e9faut est 'can0'. #restart_method: # Ceci contr\u00f4le le m\u00e9canisme que l'h\u00f4te utilisera pour r\u00e9initialiser le microcontr\u00f4leur. # Les choix sont 'arduino', 'cheetah', 'rpi_usb', et 'command'. La m\u00e9thode 'arduino' # (basculer DTR) est courante sur les cartes et clones Arduino. # La m\u00e9thode 'cheetah' est une m\u00e9thode particuli\u00e8re n\u00e9cessaire pour certaines cartes # Fysetc Cheetah. La m\u00e9thode 'rpi_usb' est utile sur les cartes Raspberry Pi avec des # micro-contr\u00f4leurs aliment\u00e9s par USB - elle d\u00e9sactive bri\u00e8vement l'alimentation de tous # les ports USB pour effectuer une r\u00e9initialisation du microcontr\u00f4leur. # La m\u00e9thode 'command' implique l'envoi d'une commande Klipper au microcontr\u00f4leur # afin qu'il puisse # se r\u00e9initialiser. # La valeur par d\u00e9faut est 'arduino' si le micro-contr\u00f4leur communique via un port s\u00e9rie, # 'command' sinon. [mcu my_extra_mcu] \u00b6 Microcontr\u00f4leurs suppl\u00e9mentaires (on peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe \"mcu\"). Les microcontr\u00f4leurs suppl\u00e9mentaires introduisent des broches additionnelles pouvant \u00eatre configur\u00e9es comme des \u00e9l\u00e9ments de chauffage, des pilotes moteurs, des ventilateurs, etc. Par exemple, si une section \"[mcu extra_mcu]\" est ajout\u00e9e, des broches telles que \"extra_mcu:ar9\" pourront \u00eatre utilis\u00e9es ailleurs dans la configuration (o\u00f9 \"ar9\" est un nom de broche mat\u00e9rielle ou un nom d'alias sur le mcu donn\u00e9). [mcu my_extra_mcu] # Voir la section \"mcu\" pour les param\u00e8tres de configuration. Param\u00e8tres cin\u00e9matiques courants \u00b6 [printer] \u00b6 La section imprimante contr\u00f4le les param\u00e8tres de haut niveau de l'imprimante. [printer] kinematics: # Le type d'imprimante utilis\u00e9e. Cette option peut \u00eatre l'une des suivantes : cart\u00e9sienne, # corexy, corexz, hybrid_corexy, hybrid_corexz, rotary_delta, delta, deltesian, polar, winch, # ou none. Ce param\u00e8tre doit \u00eatre sp\u00e9cifi\u00e9. max_velocity: # Vitesse maximale (en mm/s) de la t\u00eate d'outil (par rapport \u00e0 l'impression). # Ce param\u00e8tre doit \u00eatre sp\u00e9cifi\u00e9. max_accel: # Acc\u00e9l\u00e9ration maximale (en mm/s^2) de la t\u00eate de l'outil (par rapport \u00e0 l'impression). # Ce param\u00e8tre doit \u00eatre sp\u00e9cifi\u00e9. #max_accel_to_decel: # Une pseudo-acc\u00e9l\u00e9ration (en mm/s^2) contr\u00f4lant la vitesse \u00e0 laquelle la t\u00eate de l'outil peut # passer de l'acc\u00e9l\u00e9ration \u00e0 la d\u00e9c\u00e9l\u00e9ration. Elle est utilis\u00e9e pour r\u00e9duire la vitesse maximale # des courts mouvements en zigzag (et donc r\u00e9duire les vibrations de l'imprimante dues \u00e0 ces # mouvements). La valeur par d\u00e9faut est la moiti\u00e9 de max_accel. #square_corner_velocity: 5.0 # La vitesse maximale (en mm/s) \u00e0 laquelle la t\u00eate d'outil peut parcourir un angle de 90 degr\u00e9s. # Une valeur non nulle peut r\u00e9duire les changements dans les d\u00e9bits de l'extrudeuse en # permettant des changements de vitesse instantan\u00e9s de la t\u00eate d'outil pendant les virages. # Cette valeur configure l'algorithme interne de prise de virage \u00e0 vitesse centrip\u00e8te ; les virages # dont l'angle est sup\u00e9rieur \u00e0 90 degr\u00e9s auront une vitesse de prise de virage plus \u00e9lev\u00e9e tandis # que ceux d'angles inf\u00e9rieurs \u00e0 90 degr\u00e9s auront une vitesse de virage plus faible. # Si ce param\u00e8tre est d\u00e9fini sur z\u00e9ro, la t\u00eate d'outil d\u00e9c\u00e9l\u00e9rera jusqu'\u00e0 z\u00e9ro \u00e0 chaque coin. # La valeur par d\u00e9faut est 5mm/s. [stepper] \u00b6 D\u00e9finitions des pilotes de moteurs pas \u00e0 pas. Diff\u00e9rents types d'imprimantes (comme sp\u00e9cifi\u00e9 par l'option \"kinematics\" dans la section [printer]) requi\u00e8rent diff\u00e9rents noms pour le moteur pas \u00e0 pas (par exemple, stepper_x vs stepper_a ). Ci-dessous, vous trouverez les d\u00e9finitions les plus courantes. Voir le document distance de rotation pour des informations sur le calcul du param\u00e8tre rotation_distance . Voir le document Multi-MCU homing pour des informations sur l'utilisation de plusieurs microcontr\u00f4leurs lors d'une mise \u00e0 l'origine. [stepper_x] step_pin: # Broche GPIO du moteur (d\u00e9clench\u00e9e \u00e0 l'\u00e9tat haut). Ce param\u00e8tre doit \u00eatre fourni. dir_pin: # Broche GPIO de direction (le niveau haut indique une direction positive). Ce param\u00e8tre # doit \u00eatre fourni. enable_pin: # Broche d'activation (par d\u00e9faut, enable est haut ; utilisez ! pour indiquer enable # bas). Si ce param\u00e8tre n'est pas fourni, le pilote du moteur pas \u00e0 pas doit toujours # \u00eatre activ\u00e9. rotation_distance: # Distance (en mm) parcourue par l'axe lors d'une rotation compl\u00e8te du moteur pas \u00e0 pas # (ou de l'engrenage final si le rapport de vitesse est sp\u00e9cifi\u00e9). # Ce param\u00e8tre doit \u00eatre fourni. microsteps: # Le nombre de micropas utilis\u00e9s par le pilote du moteur pas \u00e0 pas. Ce param\u00e8tre # doit \u00eatre fourni. #full_steps_per_rotation: 200 # Nombre de pas complets pour une rotation compl\u00e8te du moteur pas \u00e0 pas. # R\u00e9glez ce param\u00e8tre sur 200 pour un moteur pas \u00e0 pas de 1,8 degr\u00e9 ou sur 400 pour # un moteur de 0,9 degr\u00e9. La valeur par d\u00e9faut est 200. #gear_ratio: # Le rapport d'engrenage si le moteur pas \u00e0 pas est reli\u00e9 \u00e0 l'axe via une d\u00e9multiplication. # Par exemple, on peut sp\u00e9cifier \"5:1\" si un r\u00e9ducteur de 5 pour 1 est utilis\u00e9. # Si l'axe a plusieurs d\u00e9multiplications, on peut sp\u00e9cifier une liste de rapports s\u00e9par\u00e9s par # des virgules (par exemple, \"57:11, 2:1\"). Si un rapport de vitesse est sp\u00e9cifi\u00e9, alors # rotation_distance sp\u00e9cifie la distance parcourue par l'axe pour une rotation compl\u00e8te # de l'engrenage final. # La valeur par d\u00e9faut est de ne pas utiliser de rapport de vitesse. #step_pulse_duration: # Le temps minimum entre le front du signal d'impulsion de pas et le front du signal \"unstep\" suivant. # Ceci est \u00e9galement utilis\u00e9 pour d\u00e9finir le temps minimum entre une impulsion de pas et un signal # de changement de direction. # La valeur par d\u00e9faut est 0,000000100 (100ns) pour les pilotes TMC configur\u00e9s en mode UART ou SPI, # sinon la valeur par d\u00e9faut est de 0,000002 (2us) pour tous les autres pilotes. endstop_pin: # Broche de d\u00e9tection de l'interrupteur de fin de course. Si cette broche est sur un mcu diff\u00e9rent de # celui du moteur pas \u00e0 pas, cela active le \"multi-mcu\". Ce param\u00e8tre doit \u00eatre fourni pour les moteurs # pas \u00e0 pas X, Y, et Z sur les imprimantes de style cart\u00e9sien. #position_min: 0 # Distance minimale valide (en mm) vers laquelle l'utilisateur peut commander le moteur pas \u00e0 pas. # La valeur par d\u00e9faut est 0mm. position_endstop: # Emplacement de la but\u00e9e (en mm). Ce param\u00e8tre doit \u00eatre fourni pour les moteurs X, Y et Z # des imprimantes de style cart\u00e9sien. position_max: # Distance maximale valide (en mm) vers laquelle l'utilisateur peut ordonner au moteur de se d\u00e9placer. # Ce param\u00e8tre doit \u00eatre fourni pour les moteurs X, Y, et Z des imprimantes de type cart\u00e9sien. #homing_speed: 5.0 # Vitesse maximale (en mm/s) du moteur pas \u00e0 pas lors de la mise \u00e0 l'origine. La valeur par d\u00e9faut # est de 5mm/s. #homing_retract_dist: 5.0 # Distance de recul (en mm) avant le retour au point d'origine une seconde fois. # R\u00e9glez cette valeur \u00e0 z\u00e9ro pour d\u00e9sactiver le second retour \u00e0 l'origine. La valeur par d\u00e9faut # est de 5 mm. #homing_retract_speed: # Vitesse \u00e0 utiliser pour le mouvement de recul apr\u00e8s le retour \u00e0 l'origine au cas o\u00f9 elle soit # diff\u00e9rente de la vitesse de mise \u00e0 l'origine qui est la valeur par d\u00e9faut de ce param\u00e8tre. #second_homing_speed: # Vitesse (en mm/s) du moteur pas \u00e0 pas lors du second retour \u00e0 l'origine. # La valeur par d\u00e9faut est homing_speed/2. #homing_positive_dir: # Si la valeur est vraie (true), le retour au point d'origine entra\u00eenera le d\u00e9placement de la commande pas # \u00e0 pas dans une direction positive (en s'\u00e9loignant de z\u00e9ro) ; si elle est fausse (false), le retour \u00e0 l'origine # se fera vers z\u00e9ro. Il est pr\u00e9f\u00e9rable d'utiliser la valeur par d\u00e9faut que de sp\u00e9cifier ce param\u00e8tre. La valeur # par d\u00e9faut est true si position_endstop est proche de position_max et false si elle est proche de # la position_min. Cin\u00e9matique cart\u00e9sienne \u00b6 Voir example-cartesian.cfg pour un exemple de fichier de configuration de cin\u00e9matique cart\u00e9sienne. Seuls les param\u00e8tres sp\u00e9cifiques aux imprimantes cart\u00e9siennes sont d\u00e9crits ici - voir param\u00e8tres cin\u00e9matiques communs pour les param\u00e8tres disponibles. [printer] kinematics: cartesian max_z_velocity: # Ceci d\u00e9finit la vitesse maximale (en mm/s) du mouvement le long de l'axe z # Ce param\u00e8tre peut \u00eatre utilis\u00e9 pour limiter la vitesse maximale du moteur pas \u00e0 pas z. # La valeur par d\u00e9faut est l'utilisation de max_velocity pour # max_z_velocity. max_z_accel: # Ce param\u00e8tre d\u00e9finit l'acc\u00e9l\u00e9ration maximale (en mm/s^2) du mouvement sur l'axe z. # Cela limite l'acc\u00e9l\u00e9ration du moteur pas \u00e0 pas z. La valeur par d\u00e9faut est # d'utiliser max_accel pour max_z_accel. # La section stepper_x est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant # l'axe X dans un robot cart\u00e9sien. [stepper_x] # La section stepper_y est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant # l'axe Y d'un robot cart\u00e9sien. [stepper_y] # La section stepper_z est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant # l'axe Z d'un robot cart\u00e9sien. [stepper_z] Cin\u00e9matique Delta lin\u00e9aire \u00b6 Voir example-delta.cfg pour un exemple de fichier de configuration de cin\u00e9matique delta lin\u00e9aire. Voir le guide de calibration delta pour des informations sur la calibration. Seuls les param\u00e8tres sp\u00e9cifiques aux imprimantes delta lin\u00e9aires sont d\u00e9crits ici - voir param\u00e8tres cin\u00e9matiques communs pour les param\u00e8tres disponibles. [printer] kinematics: delta max_z_velocity: # Pour les imprimantes delta, cela limite la vitesse maximale (en mm/s) des # mouvements de l'axe z. Ce param\u00e8tre peut \u00eatre utilis\u00e9 pour r\u00e9duire la # vitesse maximale des d\u00e9placements vers le haut/bas (n\u00e9cessitent une vitesse # de pas plus \u00e9lev\u00e9e que les autres mouvements sur une imprimante delta). La # valeur par d\u00e9faut est d'utiliser max_velocity pour max_z_velocity. #max_z_accel: # Ceci d\u00e9finit l'acc\u00e9l\u00e9ration maximale (en mm/s^2) du mouvement le long de l'axe z. # Ce param\u00e8tre peut \u00eatre utile si l'imprimante peut atteindre une plus grande # acc\u00e9l\u00e9ration sur les mouvements XY que sur les mouvements Z (par exemple, lors # de l'utilisation de la compensation de r\u00e9sonance). # La valeur par d\u00e9faut est d'utiliser max_accel pour max_z_accel. #minimum_z_position: 0 # Position Z minimale \u00e0 laquelle l'utilisateur peut ordonner \u00e0 la t\u00eate de se d\u00e9placer. # La valeur par d\u00e9faut est 0. delta_radius: # Rayon (en mm) du cercle horizontal form\u00e9 par les trois colonnes d'axe lin\u00e9aire. # Ce param\u00e8tre peut \u00e9galement \u00eatre calcul\u00e9 comme suit : # delta_radius = smooth_rod_offset - effector_offset - carriage_offset. # Ce param\u00e8tre doit \u00eatre fourni. #print_radius: # Le rayon (en mm) des coordonn\u00e9es XY valides de la t\u00eate d'extrusion. On peut utiliser # ce param\u00e8tre pour personnaliser la v\u00e9rification de la plage de mouvements de la t\u00eate. # Si une grande valeur est sp\u00e9cifi\u00e9e ici, il peut \u00eatre possible de faire entrer la t\u00eate en collision # avec une colonne. La valeur par d\u00e9faut est d'utiliser delta_radius pour print_radius (ce qui # emp\u00eachera normalement une collision avec une colonne). # La section stepper_a d\u00e9crit le moteur pas \u00e0 pas contr\u00f4lant la colonne avant gauche (\u00e0 210 # degr\u00e9s). Cette section contr\u00f4le \u00e9galement les param\u00e8tres de la mise \u00e0 l'origine # (homing_speed, homing_retract_dist) pour toutes les colonnes. [stepper_a] position_endstop: # Distance (en mm) entre la buse et le lit lorsque la buse se trouve au centre de la zone de # construction et que la fin de course se d\u00e9clenche. Ce param\u00e8tre doit \u00eatre fourni pour le # stepper_a ; pour les stepper_b et stepper_c, ce param\u00e8tre prend par d\u00e9faut la valeur # sp\u00e9cifi\u00e9e pour stepper_a. arm_length: # Longueur (en mm) du bras reliant cette colonne \u00e0 la t\u00eate d'impression. # Ce param\u00e8tre doit \u00eatre fourni pour stepper_a ; pour stepper_b et stepper_c, ce param\u00e8tre # prend par d\u00e9faut la valeur sp\u00e9cifi\u00e9e pour stepper_a. #angle: # Cette option sp\u00e9cifie l'angle (en degr\u00e9s) o\u00f9 se trouve positionn\u00e9e la colonne. # La valeur par d\u00e9faut est 210 pour stepper_a, 330 pour stepper_b, et 90 # pour stepper_c. # La section stepper_b d\u00e9crit le moteur pas \u00e0 pas contr\u00f4lant la colonne avant droite (\u00e0 330 degr\u00e9s). [stepper_b] # La section stepper_c d\u00e9crit le moteur pas \u00e0 pas contr\u00f4lant la colonne arri\u00e8re droite (\u00e0 90 degr\u00e9s). [stepper_c] # La section delta_calibrate active une commande G-code \u00e9tendue DELTA_CALIBRATE permettant # de calibrer la position des interrupteurs de fin de course ainsi que les angles des colonnes. [delta_calibrate] radius: # Rayon (en mm) de la zone palpable. Il s'agit du rayon des coordonn\u00e9es de la buse \u00e0 sonder ; si # vous utilisez un palpeur automatique avec un d\u00e9calage XY, choisissez un rayon suffisamment # petit pour que la sonde reste toujours au-dessus du lit. # Ce param\u00e8tre doit \u00eatre fourni. #speed: 50 # La vitesse (en mm/s) des mouvements sans palpage pendant l'\u00e9talonnage. # La valeur par d\u00e9faut est 50. #horizontal_move_z: 5 # La hauteur (en mm) \u00e0 laquelle la t\u00eate doit \u00eatre relev\u00e9e pour se d\u00e9placer # juste avant de lancer une op\u00e9ration de palpage. La valeur par d\u00e9faut est 5. Cin\u00e9matique deltesienne \u00b6 Voir example-deltesian.cfg pour un exemple de fichier de configuration de cin\u00e9matique deltesienne. Seuls les param\u00e8tres sp\u00e9cifiques aux imprimantes deltesiennes sont d\u00e9crits ici - voir param\u00e8tres cin\u00e9matiques communs pour les param\u00e8tres disponibles. [printer] kinematics: deltesian max_z_velocity: # Pour les imprimantes delt\u00e9siennes, cela limite la vitesse maximale (en mm/s) de # d\u00e9placement avec le mouvement de l'axe z. Ce r\u00e9glage peut \u00eatre utilis\u00e9 pour r\u00e9duire la # vitesse maximale des mouvements vers le haut/vers le bas (qui n\u00e9cessitent un taux de pas plus \u00e9lev\u00e9 # que les autres mouvements sur une imprimante delt\u00e9sienne). La valeur par d\u00e9faut est d'utiliser # max_velocity pour max_z_velocity. #max_z_accel: # Ceci d\u00e9finit l'acc\u00e9l\u00e9ration maximale (en mm/s\u00b2) du mouvement le long # l'axe z. Ce param\u00e8tre peut \u00eatre utile si l'imprimante peut atteindre des # acc\u00e9l\u00e9ration sur les mouvements XY par rapport aux mouvements Z (par exemple, lors de l'utilisation du shaper d'entr\u00e9e). # La valeur par d\u00e9faut est d'utiliser max_accel pour max_z_accel. #minimum_z_position: 0 # La position Z minimale que l'utilisateur peut commander \u00e0 la t\u00eate de se d\u00e9placer # pour. La valeur par d\u00e9faut est 0. #min_angle: 5 # Ceci repr\u00e9sente l'angle minimum (en degr\u00e9s) par rapport \u00e0 l'horizontale # que les bras delt\u00e9siens sont autoris\u00e9s \u00e0 atteindre. Ce param\u00e8tre est # destin\u00e9 \u00e0 emp\u00eacher les bras de devenir compl\u00e8tement horizontaux, # qui risquerait d'inverser accidentellement l'axe XZ. La valeur par d\u00e9faut est 5. #print_width: # La distance (en mm) des coordonn\u00e9es X valides de la t\u00eate d'outil. On peut utiliser # ce param\u00e8tre pour personnaliser la v\u00e9rification de la plage des mouvements de la t\u00eate d'outil. Si # une grande valeur est sp\u00e9cifi\u00e9e ici alors il peut \u00eatre possible de commander # la t\u00eate d'outil en collision avec une tour. Ce param\u00e8tre g\u00e9n\u00e9ralement # correspond \u00e0 la largeur du lit (en mm). #slow_ratio: 3 # Le rapport utilis\u00e9 pour limiter la vitesse et l'acc\u00e9l\u00e9ration lors des mouvements pr\u00e8s de la # extr\u00eames de l'axe X. Si distance verticale divis\u00e9e par horizontale # la distance d\u00e9passe la valeur de slow_ratio, puis la vitesse et # les acc\u00e9l\u00e9rations sont limit\u00e9es \u00e0 la moiti\u00e9 de leurs valeurs nominales. Si vertical # la distance divis\u00e9e par la distance horizontale d\u00e9passe le double de la valeur de # le slow_ratio, puis la vitesse et l'acc\u00e9l\u00e9ration sont limit\u00e9es \u00e0 un # quart de leurs valeurs nominales. La valeur par d\u00e9faut est 3. # La section stepper_left est utilis\u00e9e pour d\u00e9crire le stepper contr\u00f4lant # la tour de gauche. Cette section contr\u00f4le \u00e9galement les param\u00e8tres de prise d'origine # (homing_speed, homing_retract_dist) pour toutes les tours. [stepper_left] position_endstop: # Distance (en mm) entre la buse et le lit lorsque la buse est # au centre de la zone de construction et les but\u00e9es sont d\u00e9clench\u00e9es. Ce # le param\u00e8tre doit \u00eatre fourni pour stepper_left; stepper_right prend la valeur de stepper_left par d\u00e9faut. arm_length: # Longueur (en mm) de la tige diagonale qui relie le chariot de la tour au # la t\u00eate d'impression. Ce param\u00e8tre doit \u00eatre fourni pour stepper_left; pour # stepper_right, ce param\u00e8tre prend par d\u00e9faut la valeur sp\u00e9cifi\u00e9e pour # stepper_left. arm_x_length: # Distance horizontale entre la t\u00eate d'impression et la tour lorsque l'imprimante est mise \u00e0 l'origine. Ce param\u00e8tre doit \u00eatre fourni pour stepper_left ; # pour stepper_right, ce param\u00e8tre prend par d\u00e9faut la valeur sp\u00e9cifi\u00e9e pour stepper_left. # La section stepper_right est utilis\u00e9e pour d\u00e9crire le stepper contr\u00f4lant le # tour de droite. [stepper_right] # La section stepper_y est utilis\u00e9e pour d\u00e9crire le stepper contr\u00f4lant # l'axe Y dans un robot delt\u00e9sien. [stepper_y] Cin\u00e9matique CoreXY \u00b6 Voir example-corexy.cfg pour un exemple de fichier cin\u00e9matique corexy (et h-bot). Seuls les param\u00e8tres sp\u00e9cifiques aux imprimantes corexy sont d\u00e9crits ici - voir param\u00e8tres cin\u00e9matiques communs pour les param\u00e8tres disponibles. [printer] kinematics: corexy max_z_velocity: # Ceci d\u00e9finit la vitesse maximale (en mm/s) du mouvement le long de l'axe z # Ce param\u00e8tre peut \u00eatre utilis\u00e9 pour limiter la vitesse maximale du moteur pas \u00e0 pas z. # La valeur par d\u00e9faut est l'utilisation de max_velocity pour max_z_velocity. max_z_accel: # Ce param\u00e8tre d\u00e9finit l'acc\u00e9l\u00e9ration maximale (en mm/s^2) du mouvement sur l'axe z. # Cela limite l'acc\u00e9l\u00e9ration du moteur pas \u00e0 pas z. La valeur par d\u00e9faut est # d'utiliser max_accel pour max_z_accel. # La section stepper_x est utilis\u00e9e pour d\u00e9crire l'axe X ainsi que le moteur pas \u00e0 pas # contr\u00f4lant le mouvement X+Y. [stepper_x] # La section stepper_y est utilis\u00e9e pour d\u00e9crire l'axe Y ainsi que le moteur pas \u00e0 pas # contr\u00f4lant le mouvement X-Y. [stepper_y] # La section stepper_z est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant l'axe Z. [stepper_z] Cin\u00e9matique CoreXZ \u00b6 Voir example-corexz.cfg pour un exemple de fichier de configuration de cin\u00e9matique corexz. Seuls les param\u00e8tres sp\u00e9cifiques aux imprimantes corexz sont d\u00e9crits ici - voir param\u00e8tres cin\u00e9matiques communs pour les param\u00e8tres disponibles. [printer] kinematics: corexz max_z_velocity: # Ceci d\u00e9finit la vitesse maximale (en mm/s) du mouvement le long de l'axe z. # La valeur par d\u00e9faut est d'utiliser max_velocity pour max_z_velocity. max_z_accel: # Ceci d\u00e9finit l'acc\u00e9l\u00e9ration maximale (en mm/s^2) du mouvement le long de l'axe z. # La valeur par d\u00e9faut est d'utiliser max_accel pour max_z_accel. # La section stepper_x est utilis\u00e9e pour d\u00e9crire l'axe X ainsi que le moteur pas \u00e0 pas # contr\u00f4lant le mouvement X+Z. [stepper_x] # La section stepper_y est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant l'axe Y. [stepper_y] # La section stepper_z est utilis\u00e9e pour d\u00e9crire l'axe Z ainsi que le moteur pas \u00e0 pas # contr\u00f4lant le mouvement X-Z. [stepper_z] Cin\u00e9matique Hybride-CoreXY \u00b6 Voir example-hybrid-corexy.cfg pour un exemple de fichier de configuration de cin\u00e9matique hybride corexy. Cette cin\u00e9matique est \u00e9galement connue sous le nom de cin\u00e9matique Markforged. Seuls les param\u00e8tres sp\u00e9cifiques aux imprimantes hybrides corexy sont d\u00e9crits ici ; voir param\u00e8tres cin\u00e9matiques communs pour les param\u00e8tres disponibles. [printer] kinematics: hybrid_corexy max_z_velocity: # Ceci d\u00e9finit la vitesse maximale (en mm/s) du mouvement le long de l'axe z # La valeur par d\u00e9faut est d'utiliser max_velocity pour max_z_velocity. max_z_acce : # Ceci d\u00e9finit l'acc\u00e9l\u00e9ration maximale (en mm/s^2) du mouvement le long de l'axe z. # La valeur par d\u00e9faut est d'utiliser max_accel pour max_z_accel. # La section stepper_x est utilis\u00e9e pour d\u00e9crire l'axe X ainsi que le moteur pas \u00e0 pas # contr\u00f4lant le mouvement X-Y. [stepper_x] # La section stepper_y est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant # l'axe Y. [stepper_y] # La section stepper_z est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant # l'axe Z. [stepper_z] Cin\u00e9matique Hybride-CoreXZ \u00b6 Voir example-hybrid-corexz.cfg pour un exemple de fichier de configuration de cin\u00e9matique hybride corexz. Cette cin\u00e9matique est \u00e9galement connue sous le nom de cin\u00e9matique Markforged. Seuls les param\u00e8tres sp\u00e9cifiques aux imprimantes hybrides corexy sont d\u00e9crits ici ; voir param\u00e8tres cin\u00e9matiques communs pour les param\u00e8tres disponibles. [printer] kinematics: hybrid_corexz max_z_velocity: # Ceci d\u00e9finit la vitesse maximale (en mm/s) du mouvement le long de l'axe z # La valeur par d\u00e9faut est d'utiliser max_velocity pour max_z_velocity. max_z_accel: # Ceci d\u00e9finit l'acc\u00e9l\u00e9ration maximale (en mm/s^2) du mouvement le long de # l'axe z. La valeur par d\u00e9faut est d'utiliser max_accel pour max_z_accel. # La section stepper_x est utilis\u00e9e pour d\u00e9crire l'axe X ainsi que le moteur pas \u00e0 pas # contr\u00f4lant le mouvement X-Z. [stepper_x] # La section stepper_y est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant # l'axe Y. [stepper_y] # La section stepper_z est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant # l'axe Z. [stepper_z] Cin\u00e9matique polaire \u00b6 Voir example-polar.cfg pour un exemple de fichier de configuration de cin\u00e9matique polaire. Seuls les param\u00e8tres sp\u00e9cifiques aux imprimantes polaires sont d\u00e9crits ici - voir param\u00e8tres cin\u00e9matiques communs pour les param\u00e8tres disponibles. LA CIN\u00c9MATIQUE POLAIRE EST UN TRAVAIL EN COURS. Les d\u00e9placements autour de la position 0, 0 sont connus pour ne pas fonctionner correctement. [printer] kinematics: polar max_z_velocity: # Ceci d\u00e9finit la vitesse maximale (en mm/s) du mouvement le long de l'axe z # Ce param\u00e8tre peut \u00eatre utilis\u00e9 pour limiter la vitesse maximale du moteur z. # La valeur par d\u00e9faut est d'utiliser max_velocity pour max_z_velocity. max_z_accel: # Ce param\u00e8tre d\u00e9finit l'acc\u00e9l\u00e9ration maximale (en mm/s^2) du mouvement sur l'axe z. # Cela limite l'acc\u00e9l\u00e9ration du moteur pas \u00e0 pas z. La valeur par d\u00e9faut est d'utiliser # max_accel pour max_z_accel. # La section stepper_bed est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant # le lit. [stepper_bed] gear_ratio: # Un rapport de vitesse doit \u00eatre sp\u00e9cifi\u00e9 et la distance de rotation ne peut pas \u00eatre # sp\u00e9cifi\u00e9e. Par exemple, si le lit est \u00e9quip\u00e9 d'une poulie \u00e0 80 dents entra\u00een\u00e9e par un # moteur dont l'axe est muni d'une poulie \u00e0 16 dents, il faut sp\u00e9cifier le rapport # d'engrenage de \"80:16\". Ce param\u00e8tre doit \u00eatre fourni. # La section stepper_arm est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant # le chariot sur le bras. [stepper_arm] # La section stepper_z permet de d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant l'axe Z. [stepper_z] Cin\u00e9matique rotative delta \u00b6 Voir example-rotary-delta.cfg pour un exemple de fichier de configuration de cin\u00e9matique rotative delta. Seuls les param\u00e8tres sp\u00e9cifiques aux imprimantes rotatives delta sont d\u00e9crits ici - voir param\u00e8tres cin\u00e9matiques communs pour les param\u00e8tres disponibles. LA CIN\u00c9MATIQUE ROTATIVE DELTA EST UN TRAVAIL EN COURS. Les mouvements d'orientation peuvent d\u00e9passer le temps imparti et certains contr\u00f4les de limites ne sont pas impl\u00e9ment\u00e9s. [printer] kinematics: rotary_delta max_z_velocity: # Pour les imprimantes delta, ceci limite la vitesse maximale (en mm/s) des d\u00e9placements avec # mouvement de l'axe z. Ce param\u00e8tre peut \u00eatre utilis\u00e9 pour r\u00e9duire la vitesse maximale des # mouvements de mont\u00e9e/descente (n\u00e9cessitant un taux de pas plus \u00e9lev\u00e9 que les autres mouvements # sur une imprimante delta). La valeur par d\u00e9faut est d'utiliser max_velocity pour max_z_velocity. #minimum_z_position: 0 # La position Z minimale \u00e0 laquelle l'utilisateur peut ordonner \u00e0 la t\u00eate de se d\u00e9placer. # La valeur par d\u00e9faut est 0. shoulder_radius: # Rayon (en mm) du cercle horizontal form\u00e9 par les trois articulations de l'effecteur, moins le rayon # du cercle form\u00e9 par l'articulation de l'effecteur. # Ce param\u00e8tre peut \u00e9galement \u00eatre calcul\u00e9 comme suit # shoulder_radius = (delta_f - delta_e) / sqrt(12) # Ce param\u00e8tre doit \u00eatre fourni. shoulder_height: # Distance (en mm) des joints de l'effecteur par rapport au lit, moins la hauteur de la t\u00eate de l'outil # sur l'effecteur. Ce param\u00e8tre doit \u00eatre fourni. # La section stepper_a d\u00e9crit le moteur pas \u00e0 pas contr\u00f4lant le bras arri\u00e8re droit (\u00e0 30 degr\u00e9s). # Cette section contr\u00f4le \u00e9galement les param\u00e8tres de la mise \u00e0 l'origine (homing_speed, # homing_retract_dist) pour tous les bras. [stepper_a] gear_ratio: # Un rapport de vitesse doit \u00eatre sp\u00e9cifi\u00e9 et la rotation_distance ne peut pas \u00eatre sp\u00e9cifi\u00e9e. # Par exemple, si le bras a une poulie de 80 dents entra\u00een\u00e9e par une poulie de 16 dents, \u00e0 son # tour reli\u00e9e \u00e0 une poulie de 60 dents entra\u00een\u00e9e par un moteur dont l'arbre est muni d'une poulie # \u00e0 16 dents, alors on sp\u00e9cifierait un rapport de vitesse de \"80:16, 60:16\". # Ce param\u00e8tre doit \u00eatre fourni. position_endstop: # Distance (en mm) entre la buse et le lit lorsque la buse se trouve au centre de la zone de construction # et que la but\u00e9e se d\u00e9clenche. Ce param\u00e8tre doit \u00eatre fourni pour le stepper_a ; pour le stepper_b et # le stepper_c, ce param\u00e8tre prend par d\u00e9faut la valeur sp\u00e9cifi\u00e9e pour stepper_a. upper_arm_length: # Longueur (en mm) du bras reliant l'\"articulation de l'effecteur\" \u00e0 l'\"articulation du coude\". # Ce param\u00e8tre doit \u00eatre fourni pour stepper_a ; pour stepper_b et stepper_c, ce param\u00e8tre prend par # d\u00e9faut la valeur sp\u00e9cifi\u00e9e pour stepper_a. lower_arm_length: # Longueur (en mm) du bras reliant l'\"articulation du coude\" \u00e0 l'\"articulation de l'effecteur\". # Ce param\u00e8tre doit \u00eatre fourni pour stepper_a ; pour stepper_b et stepper_c, ce param\u00e8tre prend # par d\u00e9faut la valeur sp\u00e9cifi\u00e9e pour stepper_a. #angle: # Cette option sp\u00e9cifie l'angle (en degr\u00e9s) auquel se trouve le bras. # La valeur par d\u00e9faut est 30 pour stepper_a, 150 pour stepper_b et 270 pour stepper_c. # La section stepper_b d\u00e9crit le moteur pas \u00e0 pas contr\u00f4lant le bras arri\u00e8re gauche (\u00e0 150 degr\u00e9s). [stepper_b] # La section stepper_c d\u00e9crit le moteur pas \u00e0 pas contr\u00f4lant le bras avant (\u00e0 270 degr\u00e9s). [stepper_c] # La section delta_calibrate active une commande G-code \u00e9tendue DELTA_CALIBRATE permettant # de calibrer les positions de la but\u00e9e de l'effecteur. [delta_calibrate] radius: # Rayon (en mm) de la zone pouvant \u00eatre palp\u00e9e. Il s'agit du rayon des coordonn\u00e9es de palpage # de la buse; si vous utilisez un palpeur automatique avec un d\u00e9calage XY, choisissez un rayon # suffisamment petit pour que la sonde s'adapte toujours au lit. Ce param\u00e8tre doit \u00eatre fourni. #speed: 50 # La vitesse (en mm/s) des mouvements sans palpage pendant l'\u00e9talonnage. # La valeur par d\u00e9faut est 50. #horizontal_move_z: 5 # La hauteur (en mm) \u00e0 laquelle la t\u00eate doit \u00eatre remont\u00e9e pour se d\u00e9placer juste avant de lancer # une op\u00e9ration de palpage. La valeur par d\u00e9faut est 5. Cin\u00e9matique du treuil \u00e0 c\u00e2ble \u00b6 Voir le fichier example-winch.cfg pour un exemple de fichier de configuration cin\u00e9matique d'un treuil \u00e0 c\u00e2ble. Seuls les param\u00e8tres sp\u00e9cifiques aux imprimantes \u00e0 treuil sont d\u00e9crits ici - voir param\u00e8tres cin\u00e9matiques communs pour les param\u00e8tres disponibles. LE SUPPORT DU TREUIL \u00c0 C\u00c2BLE EST EXP\u00c9RIMENTAL. La mise \u00e0 l'origine n'est pas impl\u00e9ment\u00e9e dans la cin\u00e9matique du treuil \u00e0 c\u00e2ble. Pour ramener l'imprimante \u00e0 l'origine, envoyez des commandes manuelles de mouvements jusqu'\u00e0 ce que la t\u00eate de l'outil soit \u00e0 0, 0, 0, puis envoyez la commande G28 . [printer] kinematics: winch # La section stepper_a d\u00e9crit le moteur pas \u00e0 pas connect\u00e9 au premier treuil \u00e0 c\u00e2ble. # Un minimum de 3 et un maximum de 26 treuils \u00e0 c\u00e2ble peuvent \u00eatre d\u00e9finis # (stepper_a \u00e0 stepper_z) bien qu'il soit courant d'en d\u00e9finir 4. [stepper_a] rotation_distance: # La rotation_distance est la distance nominale (en mm) \u00e0 laquelle la t\u00eate de l'outil # se d\u00e9place vers le treuil de c\u00e2ble pour chaque rotation compl\u00e8te du moteur pas # \u00e0 pas. Ce param\u00e8tre doit \u00eatre fourni. anchor_x: anchor_y: anchor_z: # Les positions X, Y et Z du treuil \u00e0 c\u00e2ble dans l'espace cart\u00e9sien. # Ces param\u00e8tres doivent \u00eatre fournis. Aucune cin\u00e9matique \u00b6 Il est possible de d\u00e9finir une cin\u00e9matique particuli\u00e8re \"aucune (none)\" pour d\u00e9sactiver le support cin\u00e9matique dans Klipper. Cela peut \u00eatre utile pour contr\u00f4ler des p\u00e9riph\u00e9riques qui ne sont pas des imprimantes 3D typiques ou encore \u00e0 des fins de d\u00e9bogage. [printer] kinematics: none max_velocity: 1 max_accel: 1 # Les param\u00e8tres max_velocity et max_accel doivent \u00eatre d\u00e9finis. Les # valeurs par d\u00e9faut ne sont pas utilis\u00e9es pour la cin\u00e9matique \"none\". Extrudeur commun et support du lit chauffant \u00b6 [extruder] \u00b6 La section de l'extrudeuse est utilis\u00e9e pour d\u00e9crire les param\u00e8tres de chauffe de la buse ainsi que pour les commandes pas \u00e0 pas de l'extrudeuse. Voir la r\u00e9f\u00e9rence de commande pour plus d'informations. Voir le guide d'avance de pression pour des informations sur le r\u00e9glage de l'avance de pression. [extruder] step_pin: dir_pin: enable_pin: microsteps: rotation_distance: #full_steps_per_rotation: #gear_ratio: # Voir la section \"stepper\" pour une description des param\u00e8tres ci-dessus. # Si aucun des param\u00e8tres ci-dessus n'est sp\u00e9cifi\u00e9, alors aucun pilote ne # sera associ\u00e9 \u00e0 la buse (bien qu'une commande SYNC_EXTRUDER_MOTION # puisse en associer un au moment de l'ex\u00e9cution). nozzle_diameter: # Diam\u00e8tre de l'orifice de la buse (en mm). Ce param\u00e8tre doit \u00eatre # fourni. filament_diameter: # Diam\u00e8tre moyen du filament (en mm) lorsqu'il entre dans l'extrudeuse. # Ce param\u00e8tre doit \u00eatre fourni. #max_extrude_cross_section: # Surface maximale (en mm^2) d'une section transversale d'extrusion (ex: # largeur de l'extrusion multipli\u00e9e par la hauteur de la couche). Ce param\u00e8tre # permet d'\u00e9viter d'extruder des quantit\u00e9s excessives durant de petits d\u00e9placements # XY. Si un d\u00e9placement demande une quantit\u00e9 d'extrusion sup\u00e9rieure \u00e0 cette valeur, # une erreur sera renvoy\u00e9e. La valeur par d\u00e9faut est 4.0 *diam\u00e8tre_buse^2 #instantaneous_corner_velocity: 1.000 # La variation instantan\u00e9e maximale de la vitesse (en mm/s) de l'extrudeuse # pendant la jonction de deux mouvements. La valeur par d\u00e9faut est 1mm/s. #max_extrude_only_distance: 50.0 # Longueur maximale (en mm de filament) qu'un mouvement de r\u00e9traction ou d'extrusion # peut fournir. Si un mouvement de r\u00e9traction ou d'extrusion unique demande une # distance sup\u00e9rieure \u00e0 cette valeur, une erreur sera renvoy\u00e9e. # La valeur par d\u00e9faut est 50mm. #max_extrude_only_velocity: #max_extrude_only_accel: # Vitesse maximale (en mm/s) et acc\u00e9l\u00e9ration (en mm/s^2) du moteur de l'extrudeuse # pour les r\u00e9tractions et les mouvements d'extrusion seuls. Ces param\u00e8tres n'ont aucun # impact sur les mouvements d'impression normaux. S'ils ne sont pas sp\u00e9cifi\u00e9s, ils sont # calcul\u00e9s pour correspondre \u00e0 la limite d'un mouvement qu'une impression de # section transversale de 4.0*diam\u00e8tre_buse^2 aurait. #pressure_advance: 0.0 # La quantit\u00e9 de filament \u00e0 pousser dans l'extrudeuse durant l'acc\u00e9l\u00e9ration de celle-ci. # Une quantit\u00e9 \u00e9gale de filament est r\u00e9tract\u00e9e durant la d\u00e9c\u00e9l\u00e9ration. Elle est mesur\u00e9e # en millim\u00e8tre/seconde. La valeur par d\u00e9faut est 0, ce qui d\u00e9sactive la fonctionnalit\u00e9 # d'avance de pression. #pressure_advance_smooth_time: 0.040 # Une dur\u00e9e (en secondes) \u00e0 utiliser lors du calcul de la vitesse moyenne de l'extrudeuse # pour l'avance de pression. Une valeur plus grande donne lieu \u00e0 des mouvements # d'extrusion plus lisses. Ce param\u00e8tre ne doit pas d\u00e9passer 200ms. # Ce param\u00e8tre ne s'applique que si pressure_advance est diff\u00e9rent de z\u00e9ro. La valeur # par d\u00e9faut est 0.040 (40 millisecondes). # # Les variables restantes d\u00e9crivent la chauffe de l'extrudeuse. heater_pin: # Broche de sortie PWM contr\u00f4lant le chauffage. Ce param\u00e8tre doit \u00eatre # fourni. #max_power: 1.0 # La puissance maximale (exprim\u00e9e sous la forme d'une valeur comprise entre 0,0 et 1,0) # de r\u00e9glage du heater_pin . La valeur 1.0 permet \u00e0 la broche d'\u00eatre r\u00e9gl\u00e9e comme toujours # activ\u00e9e durant des p\u00e9riodes prolong\u00e9es, tandis qu'une valeur de 0,5 permet \u00e0 la broche # de n'\u00eatre activ\u00e9e durant au plus la moiti\u00e9 du temps. # Ce r\u00e9glage peut \u00eatre utilis\u00e9 pour limiter la puissance totale de sortie (sur de longues # p\u00e9riodes) de l'\u00e9l\u00e9ment de chauffe. La valeur par d\u00e9faut est 1.0. sensor_type: # Type de capteur - les thermistances courantes sont \"EPCOS 100K B57560G104F\", # \"ATC Semitec 104GT-2\", \"ATC Semitec 104NT-4-R025H42G\", \"Generic # 3950\", \"Honeywell 100K 135-104LAG-J01\", \"NTC 100K MGB18-104F39050L32\", # \"SliceEngineering 450\", et \"TDK NTCG104LH104JT1\". Voir la section \"Capteurs de # temp\u00e9rature\" pour d'autres capteurs. # Ce param\u00e8tre doit \u00eatre fourni. sensor_pin: # Broche d'entr\u00e9e analogique connect\u00e9e au capteur. Ce param\u00e8tre doit \u00eatre # fourni. #pullup_resistor: 4700 # La r\u00e9sistance (en ohms) du pullup reli\u00e9 \u00e0 la thermistance. # Ce param\u00e8tre n'est valable que si le capteur est une thermistance. La valeur par # d\u00e9faut est 4700 ohms. #smooth_time: 1.0 # Une dur\u00e9e (en secondes) sur laquelle les mesures de temp\u00e9rature seront # liss\u00e9es pour r\u00e9duire l'impact du bruit de la mesure. La valeur par d\u00e9faut # est de 1 seconde. control: # Algorithme de contr\u00f4le (soit pid, soit watermark). Ce param\u00e8tre doit # \u00eatre fourni. pid_Kp: pid_Ki: pid_Kd: # Les param\u00e8tres proportionnels (pid_Kp), int\u00e9graux (pid_Ki) et d\u00e9riv\u00e9s (pid_Kd) # du syst\u00e8me de contr\u00f4le de r\u00e9troaction PID. Klipper \u00e9value les param\u00e8tres PID avec # la formule g\u00e9n\u00e9rale suivante : # heater_pwm = (Kp*erreur + Ki*int\u00e9grale(erreur) - Kd*d\u00e9riv\u00e9e(erreur)) / 255 # O\u00f9 \"erreur\" est le r\u00e9sultat de \"requested_temperature - measured_temperature\" et # \"heater_pwm\" est le taux de chauffage demand\u00e9, 0.0 \u00e9tant compl\u00e8tement \u00e9teint et # 1.0 \u00e9tant compl\u00e8tement allum\u00e9. Pensez \u00e0 utiliser la commande PID_CALIBRATE pour # obtenir ces param\u00e8tres. Les param\u00e8tres pid_Kp, pid_Ki, et pid_Kd doivent \u00eatre # fournis pour l'algorithme PID. #max_delta: 2.0 # Sur les \u00e9l\u00e9ments de chauffe contr\u00f4l\u00e9s par watermark, il s'agit du nombre de degr\u00e9s # en Celsius au-dessus de la temp\u00e9rature cible avant de d\u00e9sactiver le chauffage ainsi # que le nombre de degr\u00e9s en dessous de la temp\u00e9rature cible avant la r\u00e9activation du # chauffage. La valeur par d\u00e9faut est de 2 degr\u00e9s Celsius. #pwm_cycle_time: 0.100 # Dur\u00e9e en secondes de chaque cycle PWM logiciel du chauffage. Il n'est # pas recommand\u00e9 de d\u00e9finir cette valeur, sauf s'il existe une exigence # \u00e9lectrique pour commuter le chauffage plus rapidement que 10 fois par seconde. # La valeur par d\u00e9faut est 0,100 seconde. #min_extrude_temp: 170 # La temp\u00e9rature minimale (Celsius) au-dessus de laquelle les commandes de # d\u00e9placement de l'extrudeuse peuvent \u00eatre \u00e9mises. La valeur par d\u00e9faut est 170\u00b0 C. min_temp: max_temp: # La plage maximale de temp\u00e9ratures valides (Celsius) dans laquelle l'\u00e9l\u00e9ment de # chauffe doit rester. Ceci contr\u00f4le une fonction de s\u00e9curit\u00e9 impl\u00e9ment\u00e9e dans le code # du micro-contr\u00f4leur - si la temp\u00e9rature mesur\u00e9e sort de cette plage, le microcontr\u00f4leur # se met en \u00e9tat d'arr\u00eat. Ce contr\u00f4le peut aider \u00e0 d\u00e9tecter certaines d\u00e9faillances mat\u00e9rielles # de l'\u00e9l\u00e9ment chauffant et/ou du capteur. D\u00e9finissez cette plage suffisamment large pour # que des temp\u00e9ratures raisonnables n'entra\u00eenent pas d'erreur. # Ces param\u00e8tres doivent \u00eatre fournis. [heater_bed] \u00b6 La section heater_bed concerne le lit chauffant. Elle utilise les m\u00eames param\u00e8tres de mise en chauffe que ceux d\u00e9crits dans la section \"extrudeuse\". [heater_bed] heater_pin: sensor_type: sensor_pin: control: min_temp: max_temp: # Voir la section \"extruder\" pour une description des param\u00e8tres ci-dessus. Support du nivelage du lit \u00b6 [bed_mesh] \u00b6 Nivelage du maillage du lit. On peut d\u00e9finir une section de configuration bed_mesh pour activer les transformations de d\u00e9placement qui d\u00e9calent l'axe z en fonction d'un maillage g\u00e9n\u00e9r\u00e9 \u00e0 partir de points palp\u00e9s. Lorsqu'on utilise une sonde pour d\u00e9finir l'origine de l'axe z, il est recommand\u00e9 de d\u00e9finir une section safe_z_home dans printer.cfg pour r\u00e9aliser cette mise \u00e0 l'origine au centre de la zone d'impression. Consultez le guide du maillage du lit et la r\u00e9f\u00e9rence de la commande pour plus d'informations. Exemples visuels : lit rectangulaire, probe_count = 3, 3: x---x---x (max_point) | x---x---x | (min_point) x---x---x lit circulaire, round_probe_count = 5, bed_radius = r: x (0, r) fin / x---x---x \\ (-r, 0) x---x---x---x---x (r, 0) \\ x---x---x / x (0, -r) d\u00e9but [bed_mesh] #speed: 50 # The speed (in mm/s) of non-probing moves during the calibration. # The default is 50. #horizontal_move_z: 5 # The height (in mm) that the head should be commanded to move to # just prior to starting a probe operation. The default is 5. #mesh_radius: # Defines the radius of the mesh to probe for round beds. Note that # the radius is relative to the coordinate specified by the # mesh_origin option. This parameter must be provided for round beds # and omitted for rectangular beds. #mesh_origin: # Defines the center X, Y coordinate of the mesh for round beds. This # coordinate is relative to the probe's location. It may be useful # to adjust the mesh_origin in an effort to maximize the size of the # mesh radius. Default is 0, 0. This parameter must be omitted for # rectangular beds. #mesh_min: # Defines the minimum X, Y coordinate of the mesh for rectangular # beds. This coordinate is relative to the probe's location. This # will be the first point probed, nearest to the origin. This # parameter must be provided for rectangular beds. #mesh_max: # Defines the maximum X, Y coordinate of the mesh for rectangular # beds. Adheres to the same principle as mesh_min, however this will # be the furthest point probed from the bed's origin. This parameter # must be provided for rectangular beds. #probe_count: 3, 3 # For rectangular beds, this is a comma separate pair of integer # values X, Y defining the number of points to probe along each # axis. A single value is also valid, in which case that value will # be applied to both axes. Default is 3, 3. #round_probe_count: 5 # For round beds, this integer value defines the maximum number of # points to probe along each axis. This value must be an odd number. # Default is 5. #fade_start: 1.0 # The gcode z position in which to start phasing out z-adjustment # when fade is enabled. Default is 1.0. #fade_end: 0.0 # The gcode z position in which phasing out completes. When set to a # value below fade_start, fade is disabled. It should be noted that # fade may add unwanted scaling along the z-axis of a print. If a # user wishes to enable fade, a value of 10.0 is recommended. # Default is 0.0, which disables fade. #fade_target: # The z position in which fade should converge. When this value is # set to a non-zero value it must be within the range of z-values in # the mesh. Users that wish to converge to the z homing position # should set this to 0. Default is the average z value of the mesh. #split_delta_z: .025 # The amount of Z difference (in mm) along a move that will trigger # a split. Default is .025. #move_check_distance: 5.0 # The distance (in mm) along a move to check for split_delta_z. # This is also the minimum length that a move can be split. Default # is 5.0. #mesh_pps: 2, 2 # A comma separated pair of integers X, Y defining the number of # points per segment to interpolate in the mesh along each axis. A # \"segment\" can be defined as the space between each probed point. # The user may enter a single value which will be applied to both # axes. Default is 2, 2. #algorithm: lagrange # The interpolation algorithm to use. May be either \"lagrange\" or # \"bicubic\". This option will not affect 3x3 grids, which are forced # to use lagrange sampling. Default is lagrange. #bicubic_tension: .2 # When using the bicubic algorithm the tension parameter above may # be applied to change the amount of slope interpolated. Larger # numbers will increase the amount of slope, which results in more # curvature in the mesh. Default is .2. #zero_reference_position: # An optional X,Y coordinate that specifies the location on the bed # where Z = 0. When this option is specified the mesh will be offset # so that zero Z adjustment occurs at this location. The default is # no zero reference. #relative_reference_index: # **DEPRECATED, use the \"zero_reference_position\" option** # The legacy option superceded by the \"zero reference position\". # Rather than a coordinate this option takes an integer \"index\" that # refers to the location of one of the generated points. It is recommended # to use the \"zero_reference_position\" instead of this option for new # configurations. The default is no relative reference index. #faulty_region_1_min: #faulty_region_1_max: # Optional points that define a faulty region. See docs/Bed_Mesh.md # for details on faulty regions. Up to 99 faulty regions may be added. # By default no faulty regions are set. [bed_tilt] \u00b6 Compensation de l'inclinaison du lit. On peut d\u00e9finir une section de configuration bed_tilt pour activer les transformations de d\u00e9placement tenant compte d'un lit inclin\u00e9. Notez que bed_mesh et bed_tilt sont incompatibles ; les deux ne peuvent pas \u00eatre d\u00e9finis en m\u00eame temps. Voir la r\u00e9f\u00e9rence des commandes pour plus d'informations. [bed_tilt] #x_adjust: 0 # Quantit\u00e9 \u00e0 ajouter \u00e0 la hauteur Z de chaque mouvement pour chaque mm sur l'axe X. # La valeur par d\u00e9faut est 0. #y_adjust: 0 # Quantit\u00e9 \u00e0 ajouter \u00e0 la hauteur Z de chaque mouvement pour chaque mm sur l'axe Y. # La valeur par d\u00e9faut est 0. #z_adjust: 0 # Quantit\u00e9 \u00e0 ajouter \u00e0 la hauteur Z lorsque la buse est nominalement \u00e0 0, 0. # La valeur par d\u00e9faut est 0. # Les param\u00e8tres suivants contr\u00f4lent la commande g-code \u00e9tendue BED_TILT_CALIBRATE # utilis\u00e9e pour calibrer les param\u00e8tres de r\u00e9glage x et y appropri\u00e9s. #points: # Une liste de coordonn\u00e9es X, Y (une par ligne ; les lignes suivantes indent\u00e9es) devant # \u00eatre palp\u00e9es pendant une commande BED_TILT_CALIBRATE # Sp\u00e9cifiez les coordonn\u00e9es de la buse et assurez-vous que la sonde est au-dessus du lit # aux coordonn\u00e9es donn\u00e9es de la buse. # La valeur par d\u00e9faut est de ne pas activer la commande. #speed: 50 # Vitesse (en mm/s) des mouvements de d\u00e9placements hors palpage pendant l'\u00e9talonnage. # La valeur par d\u00e9faut est 50. #horizontal_move_z: 5 # Hauteur (en mm) \u00e0 laquelle la t\u00eate doit \u00eatre relev\u00e9e lors du d\u00e9placement juste avant # de lancer une op\u00e9ration de palpage. La valeur par d\u00e9faut est 5. [bed_screws] \u00b6 Outil d'aide au r\u00e9glage des vis de nivellement du lit. On peut d\u00e9finir une section de configuration [bed_screws] pour activer une commande g-code BED_SCREWS_ADJUST. Consultez le guide de nivelage et la r\u00e9f\u00e9rence des commandes pour plus d'informations. [bed_screws] #screw1: # Coordonn\u00e9es X, Y de la premi\u00e8re vis de r\u00e9glage du niveau du lit. Il s'agit # de la position vers laquelle d\u00e9placer la buse afin qu'elle soit plac\u00e9e au- # dessus de cette vis de r\u00e9glage (ou aussi proche que possible tout en \u00e9tant # au-dessus du lit). Ce param\u00e8tre doit \u00eatre fourni. #screw1_name: # Un nom arbitraire pour la vis donn\u00e9e. Ce nom est affich\u00e9 lors de # l'ex\u00e9cution du script d'aide. Par d\u00e9faut, le nom utilis\u00e9 est bas\u00e9 sur la # position XY de la vis. #screw1_fine_adjust : # Coordonn\u00e9es X, Y pour commander la buse afin de pouvoir affiner le # r\u00e9glage de la vis de mise \u00e0 niveau du lit. Par d\u00e9faut, il n'y a pas de # r\u00e9glage fin sur la vis de mise \u00e0 niveau du lit. #screw2: #screw2_name: #screw2_fine_adjust: #... # Vis suppl\u00e9mentaires de mise \u00e0 niveau du lit. Au moins trois vis doivent # \u00eatre d\u00e9finies. #horizontal_move_z: 5 # Hauteur (en mm) \u00e0 laquelle la t\u00eate doit \u00eatre relev\u00e9e pour se d\u00e9placer # lors du passage d'une vis \u00e0 la suivante. La valeur par d\u00e9faut est 5. #probe_height: 0 # Hauteur de la sonde (en mm) apr\u00e8s ajustement d\u00fb \u00e0 la dilatation # thermique du lit et de la buse. La valeur par d\u00e9faut est z\u00e9ro. #speed: 50 # Vitesse (en mm/s) des d\u00e9placements entre les palpages pendant # l'\u00e9talonnage. La valeur par d\u00e9faut est 50. #probe_speed: 5 # Vitesse (en mm/s) lors du d\u00e9placement d'une position # horizontal_move_z \u00e0 la position probe_height. La valeur par # d\u00e9faut est 5. [screws_tilt_adjust] \u00b6 Outil d'assistance au nivellement du lit avec les vis de r\u00e9glage et l'aide du palpeur Z. On peut d\u00e9finir une section de configuration screws_tilt_adjust pour activer une commande g-code SCREWS_TILT_CALCULATE. Voir le guide de nivelage et la r\u00e9f\u00e9rence des commandes pour des informations suppl\u00e9mentaires. [screws_tilt_adjust] #screw1: # La coordonn\u00e9e (X, Y) de la premi\u00e8re vis de nivellement du lit. pour que la sonde soit directement # au-dessus de la vis du lit (ou le plus pr\u00e8s possible tout en \u00e9tant # au-dessus du lit). C'est la vis de base utilis\u00e9e dans les calculs. Ce # param\u00e8tre doit \u00eatre fourni. #screw1_name: # Un nom arbitraire pour la vis donn\u00e9e. Ce nom s'affiche lorsque # le script d'assistance s'ex\u00e9cute. La valeur par d\u00e9faut est d'utiliser un nom bas\u00e9 sur # l'emplacement XY de la vis. #screw2: #nom_vis2: #... # Vis suppl\u00e9mentaires de mise \u00e0 niveau du lit. Au moins deux vis doivent \u00eatre # d\u00e9finies. #speed: 50 # La vitesse (en mm/s) des mouvements sans palpage pendant l'\u00e9talonnage. # La valeur par d\u00e9faut est 50. #horizontal_move_z: 5 # La hauteur (en mm) \u00e0 laquelle la t\u00eate doit se d\u00e9placer # juste avant de lancer une op\u00e9ration de d\u00e9tection. La valeur par d\u00e9faut est 5. #screw_thread: CW-M3 # Le type de vis utilis\u00e9 pour le nivellement du lit, M3, M4 ou M5, et la # sens de rotation du bouton qui sert \u00e0 niveler le lit. # Valeurs accept\u00e9es: CW-M3, CCW-M3, CW-M4, CCW-M4, CW-M5, CCW-M5. # La valeur par d\u00e9faut est CW-M3 que la plupart des imprimantes utilisent. A dans le sens des aiguilles d'une montre # la rotation du bouton diminue l'\u00e9cart entre la buse et le # lit. A l'inverse, une rotation dans le sens inverse des aiguilles d'une montre augmente l'\u00e9cart. [z_tilt] \u00b6 R\u00e9glage multiples de l'inclinaison de moteurs pas \u00e0 pas de l'axe Z. Cette fonction permet d'ajuster de mani\u00e8re ind\u00e9pendante l'inclinaison de plusieurs moteurs Z (voir la section \"stepper_z1\"). Si cette section est pr\u00e9sente, une commande G-Code \u00e9tendue Z_TILT_ADJUST devient disponible. [z_tilt] #z_positions: # Une liste de coordonn\u00e9es X, Y (une par ligne ; les lignes subs\u00e9quentes # indent\u00e9es) d\u00e9crivant l'emplacement de chaque \"point de pivot\" du lit. # Le \"point de pivot\" est le point o\u00f9 le lit s'attache \u00e0 l'\u00e9l\u00e9ment Z # donn\u00e9. Il est d\u00e9crit \u00e0 l'aide des coordonn\u00e9es de la buse (la position X, Y # de la buse si elle pouvait se d\u00e9placer directement au-dessus du point). La # premi\u00e8re entr\u00e9e correspond \u00e0 stepper_z, la deuxi\u00e8me \u00e0 stepper_z1, # la troisi\u00e8me \u00e0 stepper_z2, etc. Ce param\u00e8tre doit \u00eatre fourni. #points: # Une liste de coordonn\u00e9es X, Y (une par ligne ; les lignes ult\u00e9rieures # indent\u00e9es) qui doivent \u00eatre palp\u00e9es pendant une commande Z_TILT_ADJUST. # Sp\u00e9cifiez les coordonn\u00e9es de la buse et assurez-vous que le palpeur est # au-dessus du lit aux coordonn\u00e9es donn\u00e9es de la buse. # Ce param\u00e8tre doit \u00eatre fourni. #speed: 50 # La vitesse (en mm/s) des mouvements de d\u00e9placements hors palpage # pendant l'\u00e9talonnage. La valeur par d\u00e9faut est 50. #horizontal_move_z: 5 # Hauteur (en mm) \u00e0 laquelle la t\u00eate doit \u00eatre relev\u00e9e pour se d\u00e9placer juste # avant de lancer une op\u00e9ration de palpage. La valeur par d\u00e9faut est 5. #retries: 0 # Nombre de tentatives \u00e0 effectuer si les points palp\u00e9s ne sont pas dans la # tol\u00e9rance. #retry_tolerance: 0 # Si les r\u00e9-essais sont activ\u00e9s, r\u00e9essayer si les points sond\u00e9s les plus grands et # les plus petits diff\u00e8rent plus que la tol\u00e9rance retry_tolerance. Notez que la # plus petite unit\u00e9 de changement ici serait un seul pas. Cependant, si vous # sondez plus de points que de moteurs, il est probable que vous aurez une # valeur minimale fixe pour la plage de points sond\u00e9s. Vous pouvez en # apprendre plus en observant la sortie de la commande. [quad_gantry_level] \u00b6 Mise \u00e0 niveau du portique mobile \u00e0 l'aide de 4 moteurs Z contr\u00f4l\u00e9s ind\u00e9pendamment. Corrige les effets de paraboles hyperboliques (chips de pommes de terre) sur un portique mobile qui est plus flexible. AVERTISSEMENT : l'utilisation de cette section sur un lit mobile peut conduire \u00e0 des r\u00e9sultats ind\u00e9sirables. Si cette section est pr\u00e9sente, une commande G-Code \u00e9tendue QUAD_GANTRY_LEVEL devient disponible. Cette routine suppose la configuration suivante des moteurs Z : ---------------- |Z1 Z2| | --------- | | | | | | | | | | x-------- | |Z Z3| ---------------- O\u00f9 x est la position 0, 0 sur le lit [quad_gantry_level] #gantry_corners: # Une liste de coordonn\u00e9es X, Y, s\u00e9par\u00e9es par des retours \u00e0 la ligne, d\u00e9crivant les deux # coins oppos\u00e9s du portique. La premi\u00e8re entr\u00e9e correspond \u00e0 Z, la seconde \u00e0 Z2. # Ce param\u00e8tre doit \u00eatre fourni. #points: # Une liste, s\u00e9par\u00e9e par des retours \u00e0 la ligne, de quatre points X, Y devant \u00eatre palp\u00e9s # pendant une commande QUAD_GANTRY_LEVEL. L'ordre des emplacements est # important, il doit correspondre aux emplacements Z, Z1, Z2 et Z3 dans l'ordre. # Ce param\u00e8tre doit \u00eatre fourni. Pour une pr\u00e9cision maximale, assurez-vous que les # d\u00e9calages de votre sonde sont configur\u00e9s. #speed: 50 # La vitesse (en mm/s) des mouvements sans palpage pendant l'\u00e9talonnage. # La valeur par d\u00e9faut est 50. #horizontal_move_z: 5 # La hauteur (en mm) \u00e0 laquelle la t\u00eate doit \u00eatre relev\u00e9e pour se d\u00e9placer juste # avant de lancer une op\u00e9ration de palpage. La valeur par d\u00e9faut est 5. #max_adjust: 4 # Limite de s\u00e9curit\u00e9 quand un ajustement sup\u00e9rieur \u00e0 cette valeur est demand\u00e9. # quad_gantry_level abandonnera. #retries: 0 # Nombre de tentatives si les points palp\u00e9s ne sont pas dans la tol\u00e9rance. #retry_tolerance: 0 # Si les re-tentatives (retries) sont activ\u00e9es, r\u00e9essayer si les points palp\u00e9s les plus grands # et les plus petits diff\u00e8rent plus que la tol\u00e9rance de re-tentative (retry_tolerance). [skew_correction] \u00b6 Correction de l'inclinaison de l'imprimante. Il est possible de corriger l'inclinaison de l'imprimante logiciellement sur 3 plans, xy, xz, yz. Pour ce faire, on imprime un mod\u00e8le d'\u00e9talonnage le long d'un plan et on mesure trois longueurs. En raison de la nature de la correction d'inclinaison, ces longueurs sont d\u00e9finies via le gcode. Voir Correction d'inclinaison et R\u00e9f\u00e9rence des commandes pour plus de d\u00e9tails. [skew_correction] [z_thermal_adjust] \u00b6 Ajustement de la position Z de la t\u00eate d'impression en fonction de la temp\u00e9rature. Compenser le mouvement vertical de la t\u00eate d'impression caus\u00e9 par la dilatation thermique du ch\u00e2ssis de l'imprimante en temps r\u00e9el \u00e0 l'aide d'un capteur de temp\u00e9rature (g\u00e9n\u00e9ralement coupl\u00e9 \u00e0 une section verticale du ch\u00e2ssis). Voir aussi : commandes de code G \u00e9tendues . [z_thermal_adjust] #temp_coeff: # Le coefficient de dilatation thermique, en mm/\u00b0C. Par exemple, un # temp_coeff de 0,01 mm/\u00b0C d\u00e9placera l'axe Z vers le bas de 0,01 mm pour # chaque degr\u00e9 Celsius d'augmentation du capteur de temp\u00e9rature. La # valeur par d\u00e9faut, 0,0 mm/\u00b0C, n'applique aucun ajustement. #smooth_time: # Fen\u00eatre de lissage appliqu\u00e9e au capteur de temp\u00e9rature, en secondes. # Peut r\u00e9duire le bruit du moteur d\u00fb \u00e0 de petites corrections excessives en # r\u00e9ponse au bruit du capteur. La valeur par d\u00e9faut est de 2,0 secondes. #z_adjust_off_above: # D\u00e9sactive les ajustements au-dessus de cette hauteur Z [mm]. La derni\u00e8re # correction calcul\u00e9e restera appliqu\u00e9e jusqu'\u00e0 ce que la t\u00eate de l'outil passe # \u00e0 nouveau en dessous de la hauteur Z sp\u00e9cifi\u00e9e. La valeur par d\u00e9faut est # 99999999.0 mm (toujours actif). #max_z_adjustment: # Ajustement absolu maximal pouvant \u00eatre appliqu\u00e9 \u00e0 l'axe Z [mm]. # La valeur par d\u00e9faut est 99999999.0 mm (illimit\u00e9). #sensor_type: #sensor_pin: #min_temp: #max_temp: # Configuration du capteur de temp\u00e9rature. # Voir la section \"extrudeuse\" pour la d\u00e9finition des param\u00e8tres ci-dessus. #gcode_id: # Voir la section \"heater_generic\" pour la d\u00e9finition de ce # param\u00e8tre. Mise \u00e0 l'origine personnalis\u00e9e \u00b6 [safe_z_home] \u00b6 Mise \u00e0 l'origine s\u00fbre de l'axe Z. On peut utiliser ce m\u00e9canisme pour centrer l'axe Z sur des coordonn\u00e9es X, Y sp\u00e9cifiques. Ceci est utile si la t\u00eate de l'outil, par exemple, doit se d\u00e9placer vers le centre du lit avant que l'axe Z puisse \u00eatre mis \u00e0 l'origine. [safe_z_home] home_xy_position: # Une coordonn\u00e9e X, Y (par exemple 100, 100) o\u00f9 la mise \u00e0 l'origine Z # doit \u00eatre effectu\u00e9e. Ce param\u00e8tre doit \u00eatre fourni. #speed: 50.0 # Vitesse \u00e0 laquelle la t\u00eate de l'outil est d\u00e9plac\u00e9e vers la position de # r\u00e9f\u00e9rence Z s\u00fbre. La valeur par d\u00e9faut est 50 mm/s #z_hop: # Distance (en mm) pour lever l'axe Z avant le retour au point d'origine. # Cette valeur est appliqu\u00e9e \u00e0 toute commande d'initialisation, m\u00eame # si elle n'initialise pas l'axe Z. Si l'axe Z est d\u00e9j\u00e0 ramen\u00e9 \u00e0 la position # de base et que la position Z actuelle est inf\u00e9rieure \u00e0 z_hop, alors ceci # l\u00e8vera la t\u00eate \u00e0 une hauteur de z_hop. Si l'axe Z n'est pas d\u00e9j\u00e0 centr\u00e9, # la t\u00eate est relev\u00e9e de z_hop. # La valeur par d\u00e9faut est de ne pas impl\u00e9menter le relevage en Z. #z_hop_speed: 15.0 # Vitesse (en mm/s) \u00e0 laquelle l'axe Z est relev\u00e9 avant le retour \u00e0 la # position initiale. La valeur par d\u00e9faut est de 15 mm/s. #move_to_previous: False # Lorsqu'il a la valeur True, les axes X et Y sont r\u00e9initialis\u00e9s \u00e0 leurs # positions pr\u00e9c\u00e9dentes apr\u00e8s retour \u00e0 la position initiale de l'axe Z. # La valeur par d\u00e9faut est False. [homing_override] \u00b6 Homing override. On peut utiliser ce m\u00e9canisme pour ex\u00e9cuter une s\u00e9rie de commandes g-code \u00e0 la place d'un G28 trouv\u00e9 dans l'entr\u00e9e g-code normale. Cela peut \u00eatre utile sur les imprimantes qui n\u00e9cessitent une proc\u00e9dure sp\u00e9cifique du retour au point d'origine de la machine. [homing_override] gcode: # Une liste de commandes G-Code \u00e0 ex\u00e9cuter \u00e0 la place des commandes # G28 trouv\u00e9es dans l'entr\u00e9e g-code normale. Voir # docs/Command_Templates.md pour le format G-Code. Si un G28 est # contenu dans cette liste de commandes alors la proc\u00e9dure de mise \u00e0 # l'origine de l'imprimante sera invoqu\u00e9e. Les commandes \u00e9num\u00e9r\u00e9es # ici doivent ramener tous les axes \u00e0 la position initiale. # Ce param\u00e8tre doit \u00eatre fourni. #axes: xyz # Les axes \u00e0 remplacer. Par exemple, si ce param\u00e8tre est d\u00e9fini sur \"z\", # alors le script d'annulation ne sera ex\u00e9cut\u00e9 que lorsque l'axe z est mis # \u00e0 l'origine (par ex. une commande \"G28\" ou \"G28 Z\"). Remarque : # le script de neutralisation doit toujours g\u00e9rer tous les axes. La valeur # par d\u00e9faut est \"xyz\" ce qui fait que le script de remplacement sera # ex\u00e9cut\u00e9 \u00e0 la place de toutes les commandes G28. #set_position_x: #set_position_y: #set_position_z: # Si sp\u00e9cifi\u00e9, l'imprimante supposera que l'axe est \u00e0 la position indiqu\u00e9e # avant d'ex\u00e9cuter les commandes g-code ci-dessus. Le fait de d\u00e9finir # ceci d\u00e9sactive les contr\u00f4les d'orientation pour cet axe. Cela peut \u00eatre # utile si la t\u00eate doit se d\u00e9placer avant d'invoquer le m\u00e9canisme G28 # normal d'un axe. La valeur par d\u00e9faut est de ne pas forcer une # position pour un axe. [endstop_phase] \u00b6 Interrupteurs de fin de course ajust\u00e9s \u00e0 la phase du moteur pas \u00e0 pas. Pour utiliser cette fonction, d\u00e9finissez une section de configuration avec un pr\u00e9fixe \"endstop_phase\" suivi du nom de la section de configuration du moteur pas \u00e0 pas correspondante (par exemple, \"[endstop_phase stepper_z]\"). Cette fonctionnalit\u00e9 peut am\u00e9liorer la pr\u00e9cision des interrupteurs de fin de course. Ajoutez une d\u00e9claration nue \"[endstop_phase]\" pour activer la commande ENDSTOP_PHASE_CALIBRATE. Voir le guide de d\u00e9tecteurs de fin de course et la r\u00e9f\u00e9rence des commandes pour plus d'informations. [endstop_phase stepper_z] #endstop_accuracy: # D\u00e9finit la pr\u00e9cision attendue (en mm) de la but\u00e9e. Cela repr\u00e9sente la # distance d'erreur maximale que la but\u00e9e peut d\u00e9clencher (par # exemple, si une but\u00e9e peut occasionnellement se d\u00e9clencher 100um # en avance ou jusqu'\u00e0 100um en retard alors r\u00e9glez cette valeur sur # 0.200 pour 200um). La valeur par d\u00e9faut est # 4*rotation_distance/full_steps_per_rotation. #trigger_phase: # Sp\u00e9cifie la phase du pilote du moteur pas \u00e0 pas \u00e0 attendre lorsque # l'on atteint la but\u00e9e. Compos\u00e9 de deux nombres s\u00e9par\u00e9s par une barre # oblique - la phase et le nombre total de phases (par exemple, \"7/64\"). # Ne d\u00e9finissez cette valeur que si vous \u00eates s\u00fbr que le pilote du moteur # pas \u00e0 pas est r\u00e9initialis\u00e9 \u00e0 chaque fois que le mcu est r\u00e9initialis\u00e9. Si # cette valeur n'est pas d\u00e9finie, alors la phase du moteur pas \u00e0 pas sera # d\u00e9tect\u00e9e \u00e0 la premi\u00e8re mise \u00e0 l'origine et cette phase sera utilis\u00e9e sur # toutes les origines suivantes. #endstop_align_zero: False # Si vrai, la position_endstop de l'axe sera effectivement modifi\u00e9e de # mani\u00e8re \u00e0 ce que la position z\u00e9ro de l'axe se produise sur un pas # complet du moteur pas \u00e0 pas. (Si utilis\u00e9 sur l'axe Z et que la hauteur # de la couche d'impression est un multiple de la distance parcourue # par un pas complet, alors chaque couche se produira sur un pas # complet). La valeur par d\u00e9faut est False. Macros et \u00e9v\u00e9nements G-Code \u00b6 [gcode_macro] \u00b6 Macros G-Code (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"gcode_macro\"). Voir le guide des mod\u00e8les de commande pour plus d'informations. [gcode_macro my_cmd] #gcode: # Une liste de commandes G-Code \u00e0 ex\u00e9cuter \u00e0 la place de \"my_cmd\". # Voir docs/Command_Templates.md pour le format G-Code. Ce param\u00e8tre # doit \u00eatre fourni. #variable_<name>: # On peut sp\u00e9cifier un nombre quelconque d'options avec le pr\u00e9fixe # \"variable_\". Le nom de variable donn\u00e9 se verra attribu\u00e9 la valeur donn\u00e9e # (analys\u00e9e en tant que litt\u00e9ral par Python) et sera disponible pendant # l'expansion de la macro. Par exemple, une configuration avec # \"variable_fan_speed = 75\" pourrait avoir des commandes gcode # contenant \"M106 S{ fan_speed * 255 }\". Ces variables peuvent alors \u00eatre # modifi\u00e9es au moment de l'ex\u00e9cution en utilisant la commande # SET_GCODE_VARIABLE (voir docs/Command_Templates.md pour plus # de d\u00e9tails). Les noms de variables peuvent ne pas utiliser de # caract\u00e8res majuscules. #rename_existing: # Cette option permet \u00e0 la macro de remplacer une commande G-Code # existante et fournira la d\u00e9finition pr\u00e9c\u00e9dente de la commande via le # nom fourni ici. Ceci peut \u00eatre utilis\u00e9 pour remplacer les commandes # G-Code originelles. Il convient d'\u00eatre prudent lorsque l'on remplace # des commandes, cela pouvant provoquer des r\u00e9sultats complexes et # inattendus. La valeur par d\u00e9faut est de ne pas remplacer une # commande G-Code existante. #description: Macro G-Code # Ceci ajoutera une courte description utilis\u00e9e \u00e0 la commande HELP # ou lors de l'utilisation de la fonction de compl\u00e9tion automatique. # Par d\u00e9faut : \"G-Code macro\". [delayed_gcode] \u00b6 Ex\u00e9cute un gcode sur un d\u00e9lai d\u00e9fini. Voir le guide des mod\u00e8les de commande et la r\u00e9f\u00e9rence des commandes pour plus d'informations. [delayed_gcode my_delayed_gcode] gcode: # Une liste de commandes G-Code \u00e0 ex\u00e9cuter lorsque la dur\u00e9e du d\u00e9lai # est \u00e9coul\u00e9e. Les mod\u00e8les G-Code sont support\u00e9s. Ce param\u00e8tre # doit \u00eatre fourni. #initial_duration: 0.0 # Dur\u00e9e du d\u00e9lai initial (en secondes). Si elle est d\u00e9finie \u00e0 une valeur non # nulle, le gcode diff\u00e9r\u00e9 s'ex\u00e9cutera le nombre de secondes sp\u00e9cifi\u00e9 apr\u00e8s # que l'imprimante passe \u00e0 l'\u00e9tat \"pr\u00eat\". Ceci peut \u00eatre utile pour les # proc\u00e9dures d'initialisation ou lors d'une r\u00e9p\u00e9tition de delayed_gcode. # Si la valeur est 0, le delayed_gcode ne sera pas ex\u00e9cut\u00e9 au d\u00e9marrage. # La valeur par d\u00e9faut est 0. [save_variables] \u00b6 Prise en charge de l'enregistrement des variables sur le disque afin qu'elles soient conserv\u00e9es lors des red\u00e9marrages. Voir mod\u00e8les de commande et r\u00e9f\u00e9rence G-code pour plus d'informations. [save_variables] filename: # Obligatoire - fournir un nom de fichier utilis\u00e9 pour enregistrer les variables # sur le disque, par exemple ~/variables.cfg. [idle_timeout] \u00b6 D\u00e9lai d'inactivit\u00e9. Un d\u00e9lai d'inactivit\u00e9 est automatiquement activ\u00e9 - ajoutez une section de configuration idle_timeout explicite pour modifier les param\u00e8tres par d\u00e9faut. [idle_timeout] #gcode: # Une liste de commandes G-Code \u00e0 ex\u00e9cuter lors d'un d\u00e9lai d'inactivit\u00e9. Voir # docs/Command_Templates.md pour le format G-Code. La valeur par d\u00e9faut # est d'ex\u00e9cuter \"TURN_OFF_HEATERS\" et \"M84\". #timeout: 600 # Dur\u00e9e d'attente (en secondes) avant d'ex\u00e9cuter les commandes G-Code ci-dessus. # La valeur par d\u00e9faut est de 600 secondes. Fonctionnalit\u00e9s optionnelles du G-code \u00b6 [virtual_sdcard] \u00b6 Une carte SD virtuelle peut \u00eatre utile si la machine h\u00f4te n'est pas assez rapide pour faire fonctionner OctoPrint correctement. Elle permet au logiciel h\u00f4te Klipper d'imprimer directement les fichiers gcode stock\u00e9s dans un r\u00e9pertoire sur l'h\u00f4te en utilisant les commandes G-Code standard de la carte SD (par exemple, M24). [virtual_sdcard] path: # Le chemin d'acc\u00e8s au r\u00e9pertoire local sur la machine h\u00f4te de recherche # des fichiers g-code. Il s'agit d'un r\u00e9pertoire en lecture seule (les \u00e9critures # de fichiers sur une carte SD ne sont pas support\u00e9es). On peut le faire pointer # vers le r\u00e9pertoire de t\u00e9l\u00e9chargement d'OctoPrint (g\u00e9n\u00e9ralement # ~/.octoprint/uploads/ ). Ce param\u00e8tre doit \u00eatre fourni. #on_error_gcode: # Une liste de commandes G-Code \u00e0 ex\u00e9cuter lorsqu'une erreur est signal\u00e9e. [sdcard_loop] \u00b6 Certaines imprimantes dot\u00e9es de fonctions d'\u00e9jections des pi\u00e8ces imprim\u00e9es, comme un \u00e9jecteur de pi\u00e8ces ou une imprimante \u00e0 courroie, peuvent trouver une utilit\u00e9 dans la mise en boucle de sections du fichier de la carte SD (par exemple, pour imprimer la m\u00eame pi\u00e8ce encore et encore, ou r\u00e9p\u00e9ter une section d'une pi\u00e8ce pour une cha\u00eene ou un autre motif r\u00e9p\u00e9t\u00e9). Voir la r\u00e9f\u00e9rence des commandes pour les commandes prises en charge. Voir le fichier sample-macros.cfg pour une macro G-Code compatible avec le M808 de Marlin. [sdcard_loop] [force_move] \u00b6 Support des d\u00e9placements manuels des moteurs pas \u00e0 pas \u00e0 des fins de diagnostic. Remarque : l'utilisation de cette fonction peut placer l'imprimante dans un \u00e9tat invalide - consultez la r\u00e9f\u00e9rence de la commande pour obtenir des d\u00e9tails importants. [force_move] #enable_force_move: False # D\u00e9fini \u00e0 true pour activer les commandes G-Code \u00e9tendues FORCE_MOVE et # SET_KINEMATIC_POSITION # La valeur par d\u00e9faut est false. [pause_resume] \u00b6 Fonctionnalit\u00e9 Pause/Reprise avec prise en charge de la capture et de la restauration de position. Voir la r\u00e9f\u00e9rence de la commande pour plus d'informations. [pause_resume] #recover_velocity: 50. # Lorsque la capture/restauration est activ\u00e9e, la vitesse \u00e0 laquelle retourner \u00e0 # la position captur\u00e9e (en mm/s). La valeur par d\u00e9faut est 50,0 mm/s. [firmware_retraction] \u00b6 R\u00e9traction du filament par le firmware. Cela permet d'activer les commandes GCODE G10 (r\u00e9traction) et G11 (d\u00e9-r\u00e9traction) \u00e9mises par de nombreux trancheurs. Les param\u00e8tres ci-dessous fournissent des valeurs par d\u00e9faut au d\u00e9marrage, ces valeurs peuvent \u00eatre ajust\u00e9es via la commande SET_RETRACTION , ce qui permet des r\u00e9glages par filament et des ajustements en cours d'impression. [firmware_retraction] #retract_length: 0 # La longueur du filament (en mm) \u00e0 r\u00e9tracter lorsque G10 est activ\u00e9, et \u00e0 fournir # lorsque G11 est activ\u00e9 (voir unretract_extra_length ci-dessous). # La valeur par d\u00e9faut est 0 mm. #retract_speed: 20 # La vitesse de r\u00e9traction, en mm/s. La valeur par d\u00e9faut est 20 mm/s. #unretract_extra_length: 0 # Longueur (en mm) de filament *suppl\u00e9mentaire* \u00e0 ajouter lors de la d\u00e9-r\u00e9traction. #unretract_speed: 10 # La vitesse de d\u00e9-r\u00e9traction, en mm/s. La valeur par d\u00e9faut est 10 mm/s. [gcode_arcs] \u00b6 Support des commandes gcode de courbes (arc) (G2/G3). [gcode_arcs] #resolution: 1.0 # Un arc sera divis\u00e9 en segments. La longueur de chaque segment sera \u00e9gale \u00e0 # la r\u00e9solution en mm d\u00e9finie ci-dessus. Des valeurs plus faibles produiront un # arc plus fin, mais \u00e9galement plus de travail de votre machine. Les arcs plus # petits que la valeur configur\u00e9e deviendront des lignes droites. La valeur par # d\u00e9faut est 1 mm. [respond] \u00b6 Active les commandes \u00e9tendues \"M118\" et \"RESPOND\" . [respond] #default_type: echo # D\u00e9finit le pr\u00e9fixe par d\u00e9faut de la sortie \"M118\" et \"RESPOND\" \u00e0 l'un des # \u00e9l\u00e9ments suivants : # echo: \"echo : \" (C'est la valeur par d\u00e9faut) # command: \"// \" # error: \" !! \" #default_prefix: echo: # D\u00e9finit directement le pr\u00e9fixe par d\u00e9faut. Si elle est pr\u00e9sente, cette valeur # remplacera celle de \"default_type\". [exclude_object] \u00b6 Permet de prendre en charge l'exclusion ou l'annulation d'objets individuels pendant le processus d'impression. Voir le guide des objets exclus et la r\u00e9f\u00e9rence des commandes pour plus d'informations. Voir le fichier sample-macros.cfg pour une macro G-Code M486 compatible avec Marlin/RepRapFirmware. [exclude_object] Compensation de la r\u00e9sonance \u00b6 [input_shaper] \u00b6 Active la compensation de r\u00e9sonance . Voir \u00e9galement la r\u00e9f\u00e9rence des commandes . [input_shaper] #shaper_freq_x: 0 # Fr\u00e9quence (en Hz) de la mise en forme de l'entr\u00e9e pour l'axe X. Il s'agit g\u00e9n\u00e9ralement # d'une fr\u00e9quence de r\u00e9sonance de l'axe X que la mise en forme de l'entr\u00e9e doit supprimer. # Pour les mises en forme plus complexes, comme les mises en forme \u00e0 2 ou 3 bosses EI # (2hump/3hump), ce param\u00e8tre peut \u00eatre d\u00e9fini \u00e0 partir de diff\u00e9rentes consid\u00e9rations. # La valeur par d\u00e9faut est 0, ce qui d\u00e9sactive la mise en forme de l'entr\u00e9e pour l'axe X. #shaper_freq_y: 0 # Fr\u00e9quence (en Hz) de la mise en forme de l'entr\u00e9e pour l'axe Y. Il s'agit g\u00e9n\u00e9ralement # d'une fr\u00e9quence de r\u00e9sonance de l'axe Y que la mise en forme de l'entr\u00e9e doit supprimer. # Pour les mises en forme plus complexes, comme les mises en forme \u00e0 2 ou 3 bosses EI # (2hump/3hump), ce param\u00e8tre peut \u00eatre d\u00e9fini \u00e0 partir de diff\u00e9rentes consid\u00e9rations. # La valeur par d\u00e9faut est 0, ce qui d\u00e9sactive la mise en forme de l'entr\u00e9e pour l'axe Y. #shaper_type: mzv # Le type de mise en forme de l'entr\u00e9e \u00e0 utiliser pour les axes X et Y. Les types support\u00e9s # sont zv, mzv, zvd, ei, 2hump_ei, et 3hump_ei. # La valeur par d\u00e9faut est la compensation de r\u00e9sonance mzv. #shaper_type_x: #shaper_type_y: # Si shaper_type n'est pas d\u00e9fini, ces deux param\u00e8tres peuvent \u00eatre utilis\u00e9s pour configurer # des formes d'entr\u00e9e diff\u00e9rentes pour les axes X et Y. Les valeurs support\u00e9es sont les # m\u00eames que celles du param\u00e8tre shaper_type. #damping_ratio_x: 0.1 #damping_ratio_y: 0.1 # Taux d'amortissement des vibrations des axes X et Y utilis\u00e9s par les dispositifs de mise # en forme de l'entr\u00e9e afin d'am\u00e9liorer la suppression des vibrations. La valeur par d\u00e9faut est # 0.1 ce qui est une bonne valeur g\u00e9n\u00e9rale pour la plupart des imprimantes. Dans la plupart # des cas, ce param\u00e8tre ne n\u00e9cessite aucun r\u00e9glage et ne doit pas \u00eatre modifi\u00e9. [adxl345] \u00b6 Support des acc\u00e9l\u00e9rom\u00e8tres ADXL345. Ce support permet d'interroger les mesures de l'acc\u00e9l\u00e9rom\u00e8tre \u00e0 partir du capteur. Cela active une commande ACCELEROMETER_MEASURE (voir G-Codes pour plus d'informations). Le nom de la puce par d\u00e9faut est \"default\", mais on peut sp\u00e9cifier un nom explicite (par exemple, [adxl345 my_chip_name]). [adxl345] cs_pin: # La broche d'activation SPI du capteur. Ce param\u00e8tre doit \u00eatre fourni. #spi_speed: 5000000 # La vitesse SPI (en hz) \u00e0 utiliser lors de la communication avec la puce. # La valeur par d\u00e9faut est 5000000. #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # Voir la section \"param\u00e8tres SPI communs\" pour une description des # param\u00e8tres ci-dessus. #axes_map : x, y, z # L'axe de l'acc\u00e9l\u00e9rom\u00e8tre de chacun des axes X, Y et Z de l'imprimante. # Ceci peut \u00eatre utile si l'acc\u00e9l\u00e9rom\u00e8tre est mont\u00e9 dans une orientation # qui ne correspond pas \u00e0 celle de l'imprimante. Par exemple, on peut # r\u00e9gler cette option sur \"y, x, z\" pour permuter les axes X et Y. # Il est \u00e9galement possible d'inverser un axe si la direction de l'acc\u00e9l\u00e9rom\u00e8tre # est invers\u00e9e (par exemple, \"x, z, -y\"). La valeur par d\u00e9faut est \"x, y, z\". #Rate: 3200 # D\u00e9bit de donn\u00e9es de sortie pour ADXL345. ADXL345 prend en charge les d\u00e9bits # de donn\u00e9es suivants : 3200, 1600, 800, 400, 200, 100, 50, et 25. Notez qu'il n'est # pas recommand\u00e9 de changer ce d\u00e9bit par rapport au d\u00e9bit par d\u00e9faut de 3200, # les d\u00e9bits inf\u00e9rieurs \u00e0 800 affecteront consid\u00e9rablement la qualit\u00e9 des mesures # de r\u00e9sonance. [lis2dw] \u00b6 Support for LIS2DW accelerometers. [lis2dw] cs_pin: # The SPI enable pin for the sensor. This parameter must be provided. #spi_speed: 5000000 # The SPI speed (in hz) to use when communicating with the chip. # The default is 5000000. #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. #axes_map: x, y, z # See the \"adxl345\" section for information on this parameter. [mpu9250] \u00b6 Prise en charge des acc\u00e9l\u00e9rom\u00e8tres MPU-9250, MPU-9255, MPU-6515, MPU-6050 et MPU-6500 (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"mpu9250\"). [mpu9250 my_accelerometer] #i2c_address: # Default is 104 (0x68). If AD0 is high, it would be 0x69 instead. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: 400000 # See the \"common I2C settings\" section for a description of the # above parameters. The default \"i2c_speed\" is 400000. #axes_map: x, y, z # See the \"adxl345\" section for information on this parameter. [resonance_tester] \u00b6 Prise en charge du test de r\u00e9sonance et du calibrage automatique du fa\u00e7onneur d'entr\u00e9e (input shaper). Pour utiliser la plupart des fonctionnalit\u00e9s de ce module, des d\u00e9pendances logicielles suppl\u00e9mentaires doivent \u00eatre install\u00e9es ; reportez-vous \u00e0 Mesurer les r\u00e9sonances et \u00e0 la r\u00e9f\u00e9rence de commande pour plus d'informations. Voir la section Adoucissement Max du guide de mesure des r\u00e9sonances pour plus d'informations sur le param\u00e8tre max_smoothing et son utilisation. [resonance_tester] #probe_points: # Une liste de coordonn\u00e9es X, Y, Z de points (un point par ligne) \u00e0 tester. # Au moins un point est requis. Assurez-vous que tous les points avec une certaine marge # de s\u00e9curit\u00e9 dans le plan XY (~ quelques centim\u00e8tres) sont accessibles par la t\u00eate de l'outil. #accel_chip: # Nom de la puce d'acc\u00e9l\u00e9rom\u00e8tre \u00e0 utiliser pour les mesures. Si la puce adxl345 a \u00e9t\u00e9 d\u00e9finie # sans un nom explicite, ce param\u00e8tre peut simplement la r\u00e9f\u00e9rencer en tant que # \"accel_chip : adxl345\", sinon un nom explicite doit \u00eatre fourni, par exemple # \"accel_chip : adxl345 my_chip_name\". Soit ce param\u00e8tre seul, soit les deux param\u00e8tres # suivants doivent \u00eatre d\u00e9finis. #accel_chip_x: #accel_chip_y: # Noms des puces d'acc\u00e9l\u00e9rom\u00e8tre \u00e0 utiliser pour les mesures de chaque axe. # Peut \u00eatre utile, par exemple, sur une imprimante de type \"bed slinger\", si deux acc\u00e9l\u00e9rom\u00e8tres # s\u00e9par\u00e9s sont mont\u00e9s, un sur le lit (pour l'axe Y), l'autre sur la t\u00eate de l'outil (pour l'axe X). # Ces param\u00e8tres ont le m\u00eame format que le param\u00e8tre 'accel_chip'. Soit le param\u00e8tre # 'accel_chip' soit ces deux param\u00e8tres doivent \u00eatre fournis. #max_smoothing: # Lissage maximal du fa\u00e7onneur (shaper) d'entr\u00e9e \u00e0 autoriser pour chaque axe pendant # l'auto-calibration (avec la commande 'SHAPER_CALIBRATE'). Par d\u00e9faut, aucun lissage # maximal n'est sp\u00e9cifi\u00e9. Reportez-vous au guide Measuring_Resonances pour plus de d\u00e9tails # sur l'utilisation de cette fonction. #min_freq: 5 # Fr\u00e9quence minimale de test des r\u00e9sonances. La valeur par d\u00e9faut est 5 Hz. #max_freq: 133.33 # Fr\u00e9quence maximale de test des r\u00e9sonances. La valeur par d\u00e9faut est 133,33 Hz. #accel_per_hz: 75 # Ce param\u00e8tre permet de d\u00e9terminer l'acc\u00e9l\u00e9ration \u00e0 utiliser pour tester une fr\u00e9quence # sp\u00e9cifique: accel = accel_per_hz * freq. Plus haute est cette valeur, plus l'\u00e9nergie des # oscillations est \u00e9lev\u00e9e. Peut \u00eatre fix\u00e9 \u00e0 une valeur inf\u00e9rieure \u00e0 celle par d\u00e9faut si les # r\u00e9sonances deviennent trop fortes sur l'imprimante. Cependant, des valeurs plus faibles # rendent les mesures des r\u00e9sonances \u00e0 haute fr\u00e9quence moins pr\u00e9cises. La valeur par # d\u00e9faut est de 75 (mm/sec). #hz_per_sec: 1 # D\u00e9termine la vitesse de l'essai. Lors du test de toutes les fr\u00e9quences dans la plage [min_freq, # max_freq], chaque seconde, la fr\u00e9quence augmente de hz_per_sec. # De faibles valeurs rendent le test lent, de grandes valeurs diminueront la pr\u00e9cision du test. # La valeur par d\u00e9faut est 1.0 (Hz/sec == sec^-2). Assistants de fichiers de configuration \u00b6 [board_pins] \u00b6 Alias des broches de la carte (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"board_pins\"). Utilisez ceci pour d\u00e9finir des alias de broches d'un micro-contr\u00f4leur. [board_pins my_aliases] mcu: mcu # Une liste de micro-contr\u00f4leurs s\u00e9par\u00e9s par des virgules pouvant utiliser les # alias. La valeur par d\u00e9faut est d'appliquer les alias au \"mcu\" principal. alias: aliases_<nom>: # Une liste s\u00e9par\u00e9e par des virgules d'alias \"nom=valeur\" \u00e0 cr\u00e9er pour le micro- # contr\u00f4leur donn\u00e9. Par exemple, \"EXP1_1=PE6\" cr\u00e9era un alias \"EXP1_1\" pour la # broche \"PE6\". Cependant, si la \"valeur\" est incluse dans \"<>\", alors \"nom\" est cr\u00e9\u00e9 # comme une broche r\u00e9serv\u00e9e (par exemple, \"EXP1_9=<GND>\" r\u00e9serverait \"EXP1_9\"). # Un nombre quelconque d'options commen\u00e7ant par \"alias_\" peuvent \u00eatre sp\u00e9cifi\u00e9es. [include] \u00b6 Prise en charge de l'inclusion de fichiers. On peut inclure des fichiers de configuration suppl\u00e9mentaires \u00e0 partir du fichier de configuration principal de l'imprimante. Les caract\u00e8res g\u00e9n\u00e9riques peuvent \u00e9galement \u00eatre utilis\u00e9s (par exemple, \"configs/*.cfg\"). [include my_other_config.cfg] [duplicate_pin_override] \u00b6 Cet outil permet de d\u00e9finir plusieurs fois une m\u00eame broche de microcontr\u00f4leur dans un fichier de configuration sans v\u00e9rification normale des erreurs. Ceci est destin\u00e9 \u00e0 des fins de diagnostic et de d\u00e9bogage. Cette section n'est pas n\u00e9cessaire lorsque Klipper prend en charge l'utilisation de la m\u00eame broche plusieurs fois, et l'utilisation de cette d\u00e9rogation peut entra\u00eener des r\u00e9sultats confus et inattendus. [duplicate_pin_override] pins: # Une liste de broches s\u00e9par\u00e9es par des virgules pouvant \u00eatre utilis\u00e9es plusieurs fois dans # un fichier de configuration sans contr\u00f4les d'erreurs normaux. Ce param\u00e8tre doit \u00eatre # fourni. Mat\u00e9riel de nivelage du lit \u00b6 [probe] \u00b6 Sonde de hauteur Z. On peut d\u00e9finir cette section pour activer le mat\u00e9riel de nivellement de l'axe Z. Lorsque cette section est activ\u00e9e, les commandes g-code \u00e9tendus PROBE et QUERY_PROBE deviennent disponibles. Consultez \u00e9galement le guide d'\u00e9talonnage des sondes . La section probe cr\u00e9e \u00e9galement une broche virtuelle \"probe:z_virtual_endstop\". Il est possible de d\u00e9finir la broche du stepper_z, endstop_pin, sur cette broche virtuelle pour les imprimantes de style cart\u00e9sien qui utilisent la sonde \u00e0 la place d'un interrupteur de fin de course Z. Si vous utilisez \"probe:z_virtual_endstop\", ne d\u00e9finissez pas de position_endstop dans la configuration de la section stepper_z. [probe] pin: # Broche de d\u00e9tection de la sonde. Si la broche se trouve sur un microcontr\u00f4leur diff\u00e9rent # de celui des moteurs de l'axe Z alors elle active le \"multi-mcu homing\". Ce param\u00e8tre # doit \u00eatre fourni. #deactivate_on_each_sample: True # Ceci d\u00e9termine si Klipper doit ex\u00e9cuter le gcode de d\u00e9sactivation entre chaque tentative # de palpage lors d'une s\u00e9quence de palpages multiples. # La valeur par d\u00e9faut est True. #x_offset: 0.0 # La distance (en mm) entre la sonde et la buse le long de l'axe x. # La valeur par d\u00e9faut est 0. #y_offset: 0.0 # La distance (en mm) entre la sonde et la buse le long de l'axe y. # La valeur par d\u00e9faut est 0. z_offset: # La distance (en mm) entre le lit et la buse lorsque la sonde se d\u00e9clenche. # Ce param\u00e8tre doit \u00eatre fourni. #speed: 5.0 # Vitesse (en mm/s) de l'axe Z lors du palpage. La valeur par d\u00e9faut est 5mm/s. #samples: 1 # Le nombre de fois o\u00f9 il faut palper chaque point. Les valeurs z palp\u00e9es seront # moyenn\u00e9es. La valeur par d\u00e9faut est de palper 1 fois. #sample_retract_dist: 2.0 # Distance (en mm) \u00e0 parcourir pour relever la t\u00eate de l'outil entre chaque palpage # (en cas d'\u00e9chantillonnage multiple). La valeur par d\u00e9faut est 2mm. #lift_speed: # Vitesse (en mm/s) de l'axe Z lors du levage de la sonde entre les \u00e9chantillons. # La valeur par d\u00e9faut est la m\u00eame que celle du param\u00e8tre 'speed'. #samples_result: average # La m\u00e9thode de calcul lorsque l'on \u00e9chantillonne plusieurs fois - soit \"m\u00e9diane\" # (median) ou \"moyenne\" (average). La valeur par d\u00e9faut est \"moyenne\". #samples_tolerance: 0.100 # La distance Z maximale (en mm) \u00e0 laquelle un \u00e9chantillon peut diff\u00e9rer des autres # \u00e9chantillons. Si cette tol\u00e9rance est d\u00e9pass\u00e9e, soit une erreur est signal\u00e9e soit une # tentative de palpage est recommenc\u00e9e (cf. samples_tolerance_retries). # La valeur par d\u00e9faut est 0.100mm. #samples_tolerance_retries: 0 # Le nombre de fois qu'il faut r\u00e9essayer quand un palpage d\u00e9passe la tol\u00e9rance des # \u00e9chantillons. Lors d'une nouvelle tentative, tous les \u00e9chantillons en cours sont rejet\u00e9s # et une tentative de palpa est relanc\u00e9e. Si un ensemble valide d'\u00e9chantillons n'est pas # obtenu dans le nombre de tentatives donn\u00e9, une erreur est signal\u00e9e. La valeur par d\u00e9faut # est z\u00e9ro, ce qui entra\u00eene le signalement d'une erreur d\u00e8s le premier \u00e9chantillon d\u00e9passant # la tol\u00e9rance de samples_tolerance. #activate_gcode: # Une liste de commandes G-Code \u00e0 ex\u00e9cuter avant chaque tentative de palpage. # Voir docs/Command_Templates.md pour le format G-Code. Cela peut \u00eatre utile si la sonde # doit \u00eatre activ\u00e9e d'une mani\u00e8re particuli\u00e8re. Ne pas envoyer ici de commandes d\u00e9pla\u00e7ant # la t\u00eate de l'outil (par exemple, G1). La valeur par d\u00e9faut est de ne pas ex\u00e9cuter de commandes # G-code sp\u00e9ciales lors de l'activation. #deactivate_gcode: # Une liste de commandes G-Code \u00e0 ex\u00e9cuter apr\u00e8s la fin de chaque tentative de palpage # termin\u00e9e. Voir docs/Command_Templates.md pour le format G-Code. Ne pas envoyer ici # de commandes d\u00e9pla\u00e7ant la t\u00eate de l'outil. La valeur par d\u00e9faut est de ne pas ex\u00e9cuter de # commandes G-code sp\u00e9ciales lors de la d\u00e9sactivation. [bltouch] \u00b6 Sonde BLTouch. On peut d\u00e9finir cette section (au lieu d'une section probe) pour activer une sonde BLTouch. Voir Guide BL-Touch et R\u00e9f\u00e9rence des commandes pour plus d'informations. Une broche virtuelle \"probe:z_virtual_endstop\" est \u00e9galement cr\u00e9\u00e9e (voir la section \"probe\" pour les d\u00e9tails). [bltouch] sensor_pin: # Broche connect\u00e9e \u00e0 la broche du capteur (sensor) BLTouch. La plupart des BLTouch # exigent un pullup sur la broche du capteur (pr\u00e9fixez le nom de la broche par \"^\"). # Ce param\u00e8tre doit \u00eatre fourni. control_pin: # Broche connect\u00e9e \u00e0 la broche de commande du BLTouch. # Ce param\u00e8tre doit \u00eatre fourni. #pin_move_time: 0.680 # Dur\u00e9e d'attente (en secondes) pour que la broche BLTouch se d\u00e9place vers # le haut ou le bas. La valeur par d\u00e9faut est de 0,680 seconde. #stow_on_each_sample: True # D\u00e9termine si Klipper doit ordonner \u00e0 la broche de se d\u00e9placer vers le haut entre # chaque palpage lors d'une s\u00e9quence de palpages multiples. # Lisez les instructions dans docs/BLTouch.md avant de r\u00e9gler ce param\u00e8tre \u00e0 False. # La valeur par d\u00e9faut est True. #probe_with_touch_mode: False # Si ce param\u00e8tre est d\u00e9fini sur True, Klipper palpera avec le p\u00e9riph\u00e9rique en # \"touch_mode\". La valeur par d\u00e9faut est False (palpage en mode \"pin_down\"). #pin_up_reports_not_triggered: True # D\u00e9finit si le BLTouch rapporte syst\u00e9matiquement le palpeur dans un \u00e9tat \"non # d\u00e9clench\u00e9\" apr\u00e8s une commande \"pin_up\" r\u00e9ussie. Ceci devrait \u00eatre True pour # tous les BLTouch authentiques. Lisez les instructions de docs/BLTouch.md avant # de r\u00e9gler cette valeur \u00e0 False. La valeur par d\u00e9faut est True. #pin_up_touch_mode_reports_triggered: True # D\u00e9finit si le BLTouch rapporte syst\u00e9matiquement un \u00e9tat \"d\u00e9clench\u00e9\" apr\u00e8s la # commande \"pin_up_mode_reports_triggered\". Ceci devrait \u00eatre True pour tous les # BLTouch authentiques. Lisez les instructions de docs/BLTouch.md avant de r\u00e9gler # cette valeur \u00e0 False. La valeur par d\u00e9faut est True. #set_output_mode: # Demande un mode de sortie particulier de la broche du capteur sur un BLTouch V3.0 # (et ult\u00e9rieurs). Ce param\u00e8tre ne doit pas \u00eatre utilis\u00e9 sur d'autres types de sondes. # R\u00e9glez sur \"5V\" pour demander une sortie de 5 Volts de la broche du capteur (\u00e0 n'utiliser # que si la carte contr\u00f4leur n\u00e9cessite le mode 5V et est tol\u00e9rante \u00e0 5V sur sa ligne de signal # d'entr\u00e9e). R\u00e9glez sur \"OD\" pour demander l'utilisation de la sortie de la broche du capteur # en mode drain ouvert. La valeur par d\u00e9faut est de ne pas demander de mode de sortie. #x_offset: #y_offset: #z_offset: #speed: #lift_speed: #samples: #sample_retract_dist: #samples_result: #samples_tolerance: #samples_tolerance_retries: # Voir la section \"probe\" pour des informations sur ces param\u00e8tres. [smart_effector] \u00b6 Le \"Smart Effector\" de Duet3d impl\u00e9mente une sonde Z utilisant un capteur de force. On peut d\u00e9finir cette section \u00e0 la place de [probe] pour activer les fonctionnalit\u00e9s sp\u00e9cifiques du Smart Effector. Cela permet \u00e9galement d'activer les commandes d'ex\u00e9cution afin d'ajuster les param\u00e8tres du Smart Effector au moment de son ex\u00e9cution. [smart_effector] pin: # Broche connect\u00e9e \u00e0 la broche de sortie de la sonde Z de Smart Effector (broche 5). Notez qu' une # r\u00e9sistance de tirage (pullup) sur la carte n'est g\u00e9n\u00e9ralement pas n\u00e9cessaire. Cependant, si la broche # de sortie est connect\u00e9e \u00e0 la broche de la carte \u00e0 l'aide d'une r\u00e9sistance de tirage, cette r\u00e9sistance doit # \u00eatre de valeur \u00e9lev\u00e9e (par ex. 10K Ohm ou plus). Certaines cartes ont une r\u00e9sistance de tirage de faible # valeur sur l'entr\u00e9e de la sonde Z, ce qui entra\u00eenera probablement un \u00e9tat de sonde toujours d\u00e9clench\u00e9. # Dans ce cas, connectez le Smart Effector \u00e0 une autre broche sur la carte. Ce param\u00e8tre est n\u00e9cessaire. #control_pin: # Broche connect\u00e9e \u00e0 la broche d'entr\u00e9e de contr\u00f4le du Smart Effector (broche 7). Si elle est fournie, # les commandes de programmation de la sensibilit\u00e9 du Smart Effector deviennent disponibles. #probe_accel: # Si elle est d\u00e9finie, limite l'acc\u00e9l\u00e9ration des mouvements de palpage (en mm/sec^2). # Une grande acc\u00e9l\u00e9ration soudaine au d\u00e9but du mouvement de palpage peut provoquer des # d\u00e9clenchements intempestifs de la sonde, surtout si la t\u00eate de l'outil est lourde. # Pour \u00e9viter cela, il peut \u00eatre n\u00e9cessaire de r\u00e9duire l'acc\u00e9l\u00e9ration des mouvements de palpage # via ce param\u00e8tre. #recovery_time: 0.4 # D\u00e9lai entre les mouvements de d\u00e9placement et les mouvements de palpage en secondes. Un # d\u00e9placement rapide avant le palpage peut entra\u00eener un d\u00e9clenchement intempestif de celui-ci. # Cela peut provoquer des erreurs 'Probe triggered prior to movement' si aucun d\u00e9lai n'est d\u00e9fini. # La valeur 0 d\u00e9sactive le d\u00e9lai de r\u00e9cup\u00e9ration. # La valeur par d\u00e9faut est 0,4. #x_offset: #y_offset: # Doivent \u00eatre laiss\u00e9s non d\u00e9finis (ou d\u00e9finis \u00e0 0). z_offset: # Hauteur de d\u00e9clenchement de la sonde. Commencez avec -0,1 (mm), et ajustez plus tard en # utilisant la commande `PROBE_CALIBRATE`. Ce param\u00e8tre doit \u00eatre fourni. #speed: # Vitesse (en mm/s) de l'axe Z lors du palpage. Il est recommand\u00e9 de commencer avec une # vitesse de palpage de 20 mm/s et d'ajuster si n\u00e9cessaire pour am\u00e9liorer la pr\u00e9cision et la # r\u00e9p\u00e9tabilit\u00e9 du d\u00e9clenchement du palpeur. #samples: #sample_retract_dist: #samples_result: #samples_tolerance: #samples_tolerance_retries: #activate_gcode: #deactivate_gcode: #deactivate_on_each_sample: # Voir la section \"sonde\" (probe) pour plus d'informations sur les param\u00e8tres ci-dessus. [axis_twist_compensation] \u00b6 A tool to compensate for inaccurate probe readings due to twist in X gantry. See the Axis Twist Compensation Guide for more detailed information regarding symptoms, configuration and setup. [axis_twist_compensation] #speed: 50 # The speed (in mm/s) of non-probing moves during the calibration. # The default is 50. #horizontal_move_z: 5 # The height (in mm) that the head should be commanded to move to # just prior to starting a probe operation. The default is 5. calibrate_start_x: 20 # Defines the minimum X coordinate of the calibration # This should be the X coordinate that positions the nozzle at the starting # calibration position. This parameter must be provided. calibrate_end_x: 200 # Defines the maximum X coordinate of the calibration # This should be the X coordinate that positions the nozzle at the ending # calibration position. This parameter must be provided. calibrate_y: 112.5 # Defines the Y coordinate of the calibration # This should be the Y coordinate that positions the nozzle during the # calibration process. This parameter must be provided and is recommended to # be near the center of the bed Moteurs pas \u00e0 pas et extrudeurs additionnels \u00b6 [stepper_z1] \u00b6 Axes \u00e0 moteurs pas \u00e0 pas multiples. Sur une imprimante de style cart\u00e9sien, le pilote moteur contr\u00f4lant un axe donn\u00e9 peut avoir des blocs de configuration suppl\u00e9mentaires d\u00e9finissant les pilotes moteurs qui doivent \u00eatre mis en marche de concert avec le pilote principal. On peut d\u00e9finir un nombre quelconque de sections avec un suffixe num\u00e9rique commen\u00e7ant \u00e0 1 (par exemple, \"stepper_z1\", \"stepper_z2\", etc.). [stepper_z1] #step_pin: #dir_pin: #enable_pin: #microsteps: #rotation_distanc : # Voir la section \"stepper\" pour la d\u00e9finition des param\u00e8tres ci-dessus. #endstop_pin: # Si une endstop_pin est d\u00e9finie pour le moteur suppl\u00e9mentaire, alors le moteur # se d\u00e9placera \u00e0 l'origine jusqu'\u00e0 ce que la fin de course soit d\u00e9clench\u00e9e. Sinon, le # moteur se d\u00e9placera jusqu'\u00e0 ce que la fin de course du moteur principal de l'axe # soit d\u00e9clench\u00e9e. [extruder1] \u00b6 Dans une imprimante multi-extrudeurs, ajoutez une section d'extrudeur suppl\u00e9mentaire pour chaque extrudeur suppl\u00e9mentaire. Les sections d'extrudeur suppl\u00e9mentaires doivent \u00eatre nomm\u00e9es \"extruder1\", \"extruder2\", \"extruder3\", et ainsi de suite. Voir la section \"extruder\" pour une description des param\u00e8tres disponibles. Voir sample-multi-extruder.cfg pour un exemple de configuration. [extruder1] #step_pin: #dir_pin: #... # Voir la section \"extruder\" pour les param\u00e8tres disponibles pour le pilote de moteur # pas \u00e0 pas et l'\u00e9l\u00e9ment de chauffe. #shared_heater: # Cette option est obsol\u00e8te et ne doit plus \u00eatre utilis\u00e9e. [dual_carriage] \u00b6 Support for cartesian and hybrid_corexy/z printers with dual carriages on a single axis. The carriage mode can be set via the SET_DUAL_CARRIAGE extended g-code command. For example, \"SET_DUAL_CARRIAGE CARRIAGE=1\" command will activate the carriage defined in this section (CARRIAGE=0 will return activation to the primary carriage). Dual carriage support is typically combined with extra extruders - the SET_DUAL_CARRIAGE command is often called at the same time as the ACTIVATE_EXTRUDER command. Be sure to park the carriages during deactivation. Note that during G28 homing, typically the primary carriage is homed first followed by the carriage defined in the [dual_carriage] config section. However, the [dual_carriage] carriage will be homed first if both carriages home in a positive direction and the [dual_carriage] carriage has a position_endstop greater than the primary carriage, or if both carriages home in a negative direction and the [dual_carriage] carriage has a position_endstop less than the primary carriage. Additionally, one could use \"SET_DUAL_CARRIAGE CARRIAGE=1 MODE=COPY\" or \"SET_DUAL_CARRIAGE CARRIAGE=1 MODE=MIRROR\" commands to activate either copying or mirroring mode of the dual carriage, in which case it will follow the motion of the carriage 0 accordingly. These commands can be used to print two parts simultaneously - either two identical parts (in COPY mode) or mirrored parts (in MIRROR mode). Note that COPY and MIRROR modes also require appropriate configuration of the extruder on the dual carriage, which can typically be achieved with \"SYNC_EXTRUDER_MOTION MOTION_QUEUE=extruder EXTRUDER= \" or a similar command. Voir sample-idex.cfg pour un exemple de configuration. [dual_carriage] axis: # The axis this extra carriage is on (either x or y). This parameter # must be provided. #safe_distance: # The minimum distance (in mm) to enforce between the dual and the primary # carriages. If a G-Code command is executed that will bring the carriages # closer than the specified limit, such a command will be rejected with an # error. If safe_distance is not provided, it will be inferred from # position_min and position_max for the dual and primary carriages. If set # to 0 (or safe_distance is unset and position_min and position_max are # identical for the primary and dual carraiges), the carriages proximity # checks will be disabled. #step_pin: #dir_pin: #enable_pin: #microsteps: #rotation_distance: #endstop_pin: #position_endstop: #position_min: #position_max: # See the \"stepper\" section for the definition of the above parameters. [extruder_stepper] \u00b6 Support pour des moteurs suppl\u00e9mentaires synchronis\u00e9s avec le mouvement d'une extrudeuse (on peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe \"extruder_stepper\"). Voir la r\u00e9f\u00e9rence des commandes pour plus d'informations. [extrudeur_stepper my_extra_stepper] extruder: # L'extrudeur sur lequel ce pilote moteur est synchronis\u00e9. Si ce param\u00e8tre est # d\u00e9fini sur une cha\u00eene vide, le pilote ne sera pas synchronis\u00e9 avec un extrudeur. # Ce param\u00e8tre doit \u00eatre fourni. #step_pin: #dir_pin: #enable_pin: #microsteps: #rotation_distance: # Voir la section \"stepper\" pour la d\u00e9finition des param\u00e8tres # ci-dessus. [manual_stepper] \u00b6 Pilotes de moteur manuels (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"manual_stepper\"). Ce sont des pilotes de moteur contr\u00f4l\u00e9s par la commande g-code MANUAL_STEPPER. Par exemple \"MANUAL_STEPPER STEPPER=my_stepper MOVE=10 SPEED=5\". Voir le fichier G-Codes pour une description de la commande MANUAL_STEPPER. Les pilotes de moteur ne sont pas connect\u00e9s \u00e0 la cin\u00e9matique normale de l'imprimante. [manual_stepper my_stepper] #step_pin: #dir_pin: #enable_pin: #microsteps: #rotation_distance: # Voir la section \"stepper\" pour une description de ces param\u00e8tres. #velocity: # D\u00e9finit la vitesse par d\u00e9faut (en mm/s) pour le pilote moteur. Cette valeur # sera utilis\u00e9e si une commande MANUAL_STEPPER ne sp\u00e9cifie pas de param\u00e8tre SPEED # La valeur par d\u00e9faut est 5mm/s. #accel # D\u00e9finit l'acc\u00e9l\u00e9ration par d\u00e9faut (en mm/s^2) pour le pilote moteur Une # acc\u00e9l\u00e9ration de z\u00e9ro n'entra\u00eenera aucune acc\u00e9l\u00e9ration. Cette valeur # sera utilis\u00e9e si une commande MANUAL_STEPPER ne sp\u00e9cifie pas de # param\u00e8tre ACCEL. La valeur par d\u00e9faut est z\u00e9ro. #endstop_pin: # Broche de d\u00e9tection de l'interrupteur de fin de course. Si elle est sp\u00e9cifi\u00e9e, on peut effectuer # des \"mouvements de retour \u00e0 l'origine\" en ajoutant un param\u00e8tre STOP_ON_ENDSTOP aux # commandes de mouvement MANUAL_STEPPER. \u00c9l\u00e9ments chauffants et capteurs personnalis\u00e9s \u00b6 [verify_heater] \u00b6 V\u00e9rification de l'\u00e9l\u00e9ment chauffant et du capteur de temp\u00e9rature. La v\u00e9rification des \u00e9l\u00e9ments de chauffage est automatiquement activ\u00e9e pour chaque mat\u00e9riel de chauffage configur\u00e9 sur l'imprimante. Utilisez les sections verify_heater pour modifier les param\u00e8tres par d\u00e9faut. [verify_heater heater_config_name] #max_error: 120 # L'erreur de temp\u00e9rature cumul\u00e9e maximale avant de d\u00e9clencher une erreur. # Des valeurs plus petites entra\u00eenent une v\u00e9rification plus stricte et des valeurs # plus grandes permettent un d\u00e9lai plus long avant qu'une erreur ne soit signal\u00e9e. # Plus pr\u00e9cis\u00e9ment, la temp\u00e9rature est inspect\u00e9e une fois par seconde et si elle # est proche de la temp\u00e9rature cible, un \"compteur d'erreurs\" interne est remis # \u00e0 z\u00e9ro; sinon, si la temp\u00e9rature est inf\u00e9rieure \u00e0 la plage cible, le compteur est # augment\u00e9 de la quantit\u00e9 de temp\u00e9rature rapport\u00e9e diff\u00e9rant de cette plage. Si # le compteur d\u00e9passe ce \"max_error\", une erreur est signal\u00e9e. La valeur par # d\u00e9faut est 120. #check_gain_time: # Ceci contr\u00f4le la v\u00e9rification du chauffage durant la chauffe initiale. Des valeurs # plus petites entra\u00eenent une v\u00e9rification plus stricte et des valeurs plus grandes # autorisent un d\u00e9lai plus grand avant qu'une erreur ne soit signal\u00e9e. Sp\u00e9cifiquement, # pendant la chauffe initiale, tant que la temp\u00e9rature de l'\u00e9l\u00e9ment chauffant augmente # durant ce laps de temps (sp\u00e9cifi\u00e9 en secondes), le \"compteur d'erreurs\" interne est # remis \u00e0 z\u00e9ro. La valeur par d\u00e9faut est de 20 secondes pour les extrudeuses et 60 # secondes pour le lit chauffant. #hysteresis: 5 # La diff\u00e9rence de temp\u00e9rature maximale (en Celsius) par rapport \u00e0 une temp\u00e9rature # cible consid\u00e9r\u00e9e comme situ\u00e9e dans la plage de la cible. Ceci contr\u00f4le la v\u00e9rification # de la plage du param\u00e8tre max_error. Il est rare de personnaliser cette valeur. # La valeur par d\u00e9faut est 5. #heating_gain: 2 # La temp\u00e9rature minimale (en Celsius) pour laquelle le chauffage doit progresser # pendant la p\u00e9riode de check_gain_time. Il est rare de personnaliser cette valeur. # La valeur par d\u00e9faut est 2. [homing_heaters] \u00b6 Outil de d\u00e9sactivation des \u00e9l\u00e9ments chauffants lors de la prise d'origine ou du palpage d'un axe. [homing_heaters] #steppers: # Une liste de pilotes moteurs s\u00e9par\u00e9s par des virgules qui devraient d\u00e9sactiver les chauffages. # La valeur par d\u00e9faut est de d\u00e9sactiver les chauffages pour tout d\u00e9placement (mise \u00e0 # l'origine / palpage). # Exemple typique : stepper_z #heaters: # Une liste, s\u00e9par\u00e9e par des virgules, d'\u00e9l\u00e9ments chauffants \u00e0 d\u00e9sactiver pendant les d\u00e9placements # (mise \u00e0 l'origine / palpage). La valeur par d\u00e9faut est de d\u00e9sactiver tous les \u00e9l\u00e9ments chauffants. # Exemple typique : extruder, heater_bed [thermistor] \u00b6 Thermistances personnalis\u00e9es (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"thermistor\"). Une thermistance personnalis\u00e9e peut \u00eatre utilis\u00e9e dans le champ sensor_type d'une section de configuration de chauffage. (Par exemple, si l'on d\u00e9finit une section \"[thermistor my_thermistor]\", on peut utiliser un \"sensor_type: my_thermistor\" lors de la d\u00e9finition d'un \u00e9l\u00e9ment de chauffe). Veillez \u00e0 placer la section thermistor dans le fichier de configuration avant sa premi\u00e8re utilisation dans une section de chauffage. [thermistor ma_thermistance] #temperature1: #resistance1: #temperature2: #resistance2: #temperature3: #resistance3: # Trois mesures de r\u00e9sistance (en Ohms) aux temp\u00e9ratures donn\u00e9es # (en Celsius). Ces trois mesures seront utilis\u00e9es pour calculer les # coefficients de Steinhart-Hart pour la thermistance. Ces param\u00e8tres # doivent \u00eatre fournis lors de l'utilisation de Steinhart-Hart pour d\u00e9finir la # thermistance. #beta: # Alternativement, on peut d\u00e9finir temp\u00e9rature1, r\u00e9sistance1, et beta # pour d\u00e9finir les param\u00e8tres de la thermistance. Ce param\u00e8tre doit \u00eatre # fourni lorsque l'on utilise \"beta\" pour d\u00e9finir la thermistance. [adc_temperature] \u00b6 Capteurs de temp\u00e9rature ADC personnalis\u00e9s (on peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe \"adc_temperature\"). Cela permet de d\u00e9finir un capteur de temp\u00e9rature personnalis\u00e9 mesurant une tension sur une broche de convertisseur analogique-num\u00e9rique (ADC) et utilise une interpolation lin\u00e9aire entre un ensemble de mesures configur\u00e9es de temp\u00e9rature/tension (ou de temp\u00e9rature/r\u00e9sistance) pour d\u00e9terminer la temp\u00e9rature. Le capteur r\u00e9sultant peut \u00eatre utilis\u00e9 comme un type de capteur dans une section de chauffage. (Par exemple, si l'on d\u00e9finit une section \"[adc_temperature my_sensor]\", on peut utiliser un \"sensor_type : my_sensor\" lors de la d\u00e9finition d'un \u00e9l\u00e9ment chauffant). Veillez \u00e0 placer la section du capteur dans le fichier de configuration avant sa premi\u00e8re utilisation dans une section de chauffage. [adc_temperature mon_capteur] #temperature1: #voltage1: #temperature2: #voltage2: #... # Un ensemble de temp\u00e9ratures (en Celsius) et de tensions (en Volts) \u00e0 utiliser comme # r\u00e9f\u00e9rence lors de la conversion d'une temp\u00e9rature. Une section de chauffage utilisant # ce capteur peut \u00e9galement sp\u00e9cifier les param\u00e8tres adc_voltage et voltage_offset # pour d\u00e9finir la tension ADC (voir la section \"Amplificateurs communs de temp\u00e9rature\" # pour plus de d\u00e9tails). Au moins deux mesures doivent \u00eatre fournies. #temperature1: #resistance1: #temperature2: #resistance2: #... # Alternativement, on peut indiquer un ensemble de temp\u00e9ratures (en Celsius) # et de r\u00e9sistance (en Ohms) \u00e0 utiliser comme r\u00e9f\u00e9rence lors de la conversion d'une # temp\u00e9rature. Une section de chauffage utilisant ce capteur peut \u00e9galement sp\u00e9cifier un # param\u00e8tre pullup_resistor (voir la section \"extrudeuse\" pour plus de d\u00e9tails). Au # moins deux mesures doivent \u00eatre fournies. [heater_generic] \u00b6 \u00c9l\u00e9ments de chauffe g\u00e9n\u00e9riques (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"heater_generic\"). Ces \u00e9l\u00e9ments de chauffe se comportent de la m\u00eame mani\u00e8re que les \u00e9l\u00e9ments de chauffe standards (extrudeuses, lits chauffants). Utilisez la commande SET_HEATER_TEMPERATURE (voir G-Codes pour plus de d\u00e9tails) pour d\u00e9finir la temp\u00e9rature cible. [heater_generic my_generic_heater] #gcode_id: # L'identifiant \u00e0 utiliser pour signaler la temp\u00e9rature dans la commande M105. # Ce param\u00e8tre doit \u00eatre fourni. #heater_pin: #max_power: #sensor_type: #sensor_pin: #smooth_time: #control: #pid_Kp: #pid_Ki: #pid_Kd: #pwm_cycle_time: #min_temp: #max_temp: # Voir la section \"extruder\" pour la d\u00e9finition des param\u00e8tres # ci-dessus. [temperature_sensor] \u00b6 Capteurs de temp\u00e9rature g\u00e9n\u00e9riques. On peut d\u00e9finir un nombre quelconque de capteurs de temp\u00e9rature suppl\u00e9mentaires signal\u00e9s par la commande M105. [temperature_sensor my_sensor] #sensor_type: #sensor_pin: #min_temp: #max_temp: # Voir la section \"extrudeuse\" pour la d\u00e9finition des param\u00e8tres # ci-dessus. #gcode_id: # Voir la section \"heater_generic\" pour la d\u00e9finition de ce # param\u00e8tre. Capteurs de temp\u00e9rature \u00b6 Klipper inclut les d\u00e9finitions de nombreux types de capteurs de temp\u00e9rature. Ces capteurs peuvent \u00eatre utilis\u00e9s dans n'importe quelle section de la configuration n\u00e9cessitant un capteur de temp\u00e9rature (comme une section [extruder] ou [heater_bed] ). Thermistances communes \u00b6 Thermistances communes. Les param\u00e8tres suivants sont disponibles dans les sections de chauffage utilisant l'un de ces capteurs. sensor_type: # Un parmi \"EPCOS 100K B57560G104F\", \"ATC Semitec 104GT-2\", # \"ATC Semitec 104NT-4-R025H42G\", \"Generic 3950\", # \"Honeywell 100K 135-104LAG-J01\", \"NTC 100K MGB18-104F39050L32\", # \"SliceEngineering 450\", ou \"TDK NTCG104LH104JT1\". sensor_pin: # Broche d'entr\u00e9e analogique connect\u00e9e \u00e0 la thermistance. Ce param\u00e8tre doit # \u00eatre fourni. #pullup_resistor: 4700 # La r\u00e9sistance (en ohms) de tirage (pullup) reli\u00e9e \u00e0 la thermistance. # La valeur par d\u00e9faut est 4700 ohms. #inline_resistor: 0 # La r\u00e9sistance (en ohms) d'une r\u00e9sistance suppl\u00e9mentaire (ne variant pas en fonction de # la chaleur) plac\u00e9e en ligne avec la thermistance. Il est rare de la d\u00e9finir. # La valeur par d\u00e9faut est 0 ohms. Amplificateurs de temp\u00e9rature courants \u00b6 Amplificateurs de temp\u00e9rature courants. Les param\u00e8tres suivants sont disponibles dans les sections de chauffage utilisant l'un de ces capteurs. sensor_type: # Un parmi \"PT100 INA826\", \"AD595\", \"AD597\", \"AD8494\", \"AD8495\", # \"AD8496\", ou \"AD8497\". sensor_pin: # Broche d'entr\u00e9e analogique connect\u00e9e au capteur. Ce param\u00e8tre doit \u00eatre # fourni. #adc_voltage: 5.0 # La tension de comparaison ADC (en Volts). La valeur par d\u00e9faut est de 5 volts. #voltage_offset: 0 # D\u00e9calage de la tension de l'ADC (en Volts). La valeur par d\u00e9faut est 0. Capteur PT1000 directement connect\u00e9 \u00b6 Capteur PT1000 connect\u00e9 en direct. Les param\u00e8tres suivants sont disponibles dans les sections chauffage utilisant ces capteurs. sensor_type : PT1000 sensor_pin: # Broche d'entr\u00e9e analogique connect\u00e9e au capteur. Ce param\u00e8tre doit \u00eatre # fourni. #pullup_resistor: 4700 # La r\u00e9sistance (en ohms) de tirage (pullup) reli\u00e9e au capteur. La valeur par # d\u00e9faut est 4700 ohms. Capteurs de temp\u00e9rature MAXxxxxx \u00b6 Capteurs MAXxxxxx \u00e0 interface p\u00e9riph\u00e9rique s\u00e9rie (SPI) bas\u00e9s sur la temp\u00e9rature. Les param\u00e8tres suivants sont disponibles dans les sections de chauffage qui utilisent l'un de ces types de capteurs. sensor_type : # Un parmi les types suivants : \"MAX6675\", \"MAX31855\", \"MAX31856\" ou \"MAX31865\". sensor_pin: # La broche de s\u00e9lection de puce pour la puce du capteur. Ce param\u00e8tre doit \u00eatre # fourni. #spi_speed: 4000000 # La vitesse SPI (en hz) \u00e0 utiliser lors de la communication avec la puce. # La valeur par d\u00e9faut est 4000000. #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # Voir la section \"param\u00e8tres SPI communs\" pour une description des # param\u00e8tres ci-dessus. #tc_type: K #tc_use_50Hz_filter: False #tc_averaging_count: 1 # Les param\u00e8tres ci-dessus contr\u00f4lent les param\u00e8tres des capteurs des puces MAX31856 # Les valeurs par d\u00e9faut de chaque param\u00e8tre sont indiqu\u00e9es \u00e0 c\u00f4t\u00e9 du nom du param\u00e8tre # dans la liste ci-dessus. #rtd_nominal_r: 100 #rtd_reference_r: 430 #rtd_num_of_wires: 2 #rtd_use_50Hz_filter: False # Les param\u00e8tres ci-dessus contr\u00f4lent les param\u00e8tres des capteurs des puces MAX31865 # Les valeurs par d\u00e9faut de chaque param\u00e8tre sont indiqu\u00e9es \u00e0 c\u00f4t\u00e9 du nom du param\u00e8tre # dans la liste ci-dessus. Capteurs de temp\u00e9rature BMP280/BME280/BME680 \u00b6 Capteurs environnementaux BMP280/BME280/BME680 \u00e0 interface \u00e0 deux fils (I2C). Notez que ces capteurs ne sont pas destin\u00e9s \u00e0 \u00eatre utilis\u00e9s avec des extrudeurs et des lits chauffants, mais plut\u00f4t pour surveiller la temp\u00e9rature ambiante (C), la pression (hPa), l'humidit\u00e9 relative et, dans le cas du BME680, le niveau de gaz. Voir sample-macros.cfg pour un gcode_macro pouvant \u00eatre utilis\u00e9 pour signaler la pression et l'humidit\u00e9 en plus de la temp\u00e9rature. sensor_type: BME280 #i2c_address: # Default is 118 (0x76). Some BME280 sensors have an address of 119 # (0x77). #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. AHT10/AHT20/AHT21 temperature sensor \u00b6 AHT10/AHT20/AHT21 two wire interface (I2C) environmental sensors. Note that these sensors are not intended for use with extruders and heater beds, but rather for monitoring ambient temperature (C) and relative humidity. See sample-macros.cfg for a gcode_macro that may be used to report humidity in addition to temperature. sensor_type: AHT10 # Also use AHT10 for AHT20 and AHT21 sensors. #i2c_address: # Default is 56 (0x38). Some AHT10 sensors give the option to use # 57 (0x39) by moving a resistor. #i2c_mcu: #i2c_bus: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #aht10_report_time: # Interval in seconds between readings. Default is 30, minimum is 5 Capteur HTU21D \u00b6 Capteur d'environnement de la famille HTU21D \u00e0 interface \u00e0 deux fils (I2C). Notez que ce capteur n'est pas destin\u00e9 \u00e0 \u00eatre utilis\u00e9 avec les extrudeuses et les lits chauffants, mais plut\u00f4t \u00e0 surveiller la temp\u00e9rature ambiante (C) et l'humidit\u00e9 relative. Voir sample-macros.cfg pour un gcode_macro utilisable permettant d'indiquer l'humidit\u00e9 en plus de la temp\u00e9rature. sensor_type: # Must be \"HTU21D\" , \"SI7013\", \"SI7020\", \"SI7021\" or \"SHT21\" #i2c_address: # Default is 64 (0x40). #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #htu21d_hold_master: # If the sensor can hold the I2C buf while reading. If True no other # bus communication can be performed while reading is in progress. # Default is False. #htu21d_resolution: # The resolution of temperature and humidity reading. # Valid values are: # 'TEMP14_HUM12' -> 14bit for Temp and 12bit for humidity # 'TEMP13_HUM10' -> 13bit for Temp and 10bit for humidity # 'TEMP12_HUM08' -> 12bit for Temp and 08bit for humidity # 'TEMP11_HUM11' -> 11bit for Temp and 11bit for humidity # Default is: \"TEMP11_HUM11\" #htu21d_report_time: # Interval in seconds between readings. Default is 30 Capteur de temp\u00e9rature LM75 \u00b6 Capteurs de temp\u00e9rature LM75/LM75A connect\u00e9s en deux fils (I2C). Ces capteurs ont une gamme de -55~125 \u00b0C, et sont donc utilisables par exemple pour la surveillance de la temp\u00e9rature d'une chambre. Ils peuvent aussi fonctionner comme de simples contr\u00f4leurs de ventilateurs/\u00e9l\u00e9ments chauffants. sensor_type: LM75 #i2c_address: # Default is 72 (0x48). Normal range is 72-79 (0x48-0x4F) and the 3 # low bits of the address are configured via pins on the chip # (usually with jumpers or hard wired). #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #lm75_report_time: # Interval in seconds between readings. Default is 0.8, with minimum # 0.5. Capteur de temp\u00e9rature int\u00e9gr\u00e9 au microcontr\u00f4leur \u00b6 Les micro-contr\u00f4leurs atsam, atsamd, et stm32 poss\u00e8dent un capteur de temp\u00e9rature interne. On peut utiliser le capteur \"temperature_mcu\" pour surveiller ces temp\u00e9ratures. sensor_type: temperature_mcu #sensor_mcu: mcu # Le micro-contr\u00f4leur \u00e0 lire. La valeur par d\u00e9faut est \"mcu\". #sensor_temperature1: #sensor_adc1: # Sp\u00e9cifiez les deux param\u00e8tres ci-dessus (une temp\u00e9rature en Celsius et une valeur d' ADC sous # forme de flottant entre 0,0 et 1,0) pour calibrer la temp\u00e9rature du microcontr\u00f4leur. Cela peut # am\u00e9liorer la pr\u00e9cision de la temp\u00e9rature rapport\u00e9e sur certaines puces. Une fa\u00e7on typique d'obtenir # ces informations d'\u00e9talonnage est de couper compl\u00e8tement l'alimentation de l'imprimante pendant # quelques heures (afin de s'assurer qu'elle est \u00e0 la temp\u00e9rature ambiante), puis de la remettre sous # tension et d'utiliser la fonction QUERY_ADC pour obtenir une mesure ADC. # Utilisez un autre capteur de temp\u00e9rature sur l'imprimante pour trouver la temp\u00e9rature ambiante # correspondante. La valeur par d\u00e9faut est d'utiliser les donn\u00e9es d'\u00e9talonnage d'usine du microcontr\u00f4leur # (le cas \u00e9ch\u00e9ant) ou les valeurs nominales de la sp\u00e9cification du microcontr\u00f4leur. #sensor_temperature2: #sensor_adc2: # Si sensor_temperature1/sensor_adc1 est sp\u00e9cifi\u00e9, on peut \u00e9galement sp\u00e9cifier les donn\u00e9es # d'\u00e9talonnage de sensor_temperature2/sensor_adc2. En proc\u00e9dant ainsi on peut fournir des # informations calibr\u00e9es sur la \"pente de temp\u00e9rature\". La valeur par d\u00e9faut est d'utiliser les donn\u00e9es # d'\u00e9talonnage d'usine sur le microcontr\u00f4leur (le cas \u00e9ch\u00e9ant) ou les valeurs nominales de la # sp\u00e9cification du microcontr\u00f4leur. Capteur de temp\u00e9rature de l'h\u00f4te \u00b6 Temp\u00e9rature de la machine (par exemple Raspberry Pi) ex\u00e9cutant le logiciel h\u00f4te. sensor_type: temperature_host #sensor_path: # Le chemin d'acc\u00e8s au fichier syst\u00e8me de temp\u00e9rature. La valeur par d\u00e9faut est # \" /sys/class/thermal/thermal_zone0/temp \" qui est le fichier syst\u00e8me de # temp\u00e9rature sur un ordinateur Raspberry Pi. Capteur de temp\u00e9rature DS18B20 \u00b6 Le DS18B20 est un capteur de temp\u00e9rature num\u00e9rique \u00e0 1 fil (w1). Notez que ce capteur n'est pas destin\u00e9 \u00e0 \u00eatre utilis\u00e9 avec les extrudeurs et les lits chauffants, mais plut\u00f4t pour surveiller la temp\u00e9rature ambiante (C). Ces capteurs ont une port\u00e9e allant jusqu'\u00e0 125 \u00b0C et sont donc utilisables pour la surveillance de la temp\u00e9rature d'un caisson par exemple. Ils peuvent \u00e9galement fonctionner comme de simples contr\u00f4leurs de ventilateurs/\u00e9l\u00e9ments chauffants. Les capteurs DS18B20 ne sont support\u00e9s que par un \"mcu h\u00f4te\", par exemple le Raspberry Pi. Le module w1-gpio du noyau Linux doit \u00eatre install\u00e9. sensor_type: DS18B20 serial_no: # Chaque dispositif \u00e0 1-wire poss\u00e8de un num\u00e9ro de s\u00e9rie unique utilis\u00e9 pour l'identifier, # g\u00e9n\u00e9ralement au format 28-031674b175ff. Ce param\u00e8tre doit \u00eatre fourni. # Les p\u00e9riph\u00e9riques 1-wire connect\u00e9s peuvent \u00eatre list\u00e9s \u00e0 l'aide de la commande Linux suivante : # ls /sys/bus/w1/devices/ #ds18_report_time: # Intervalle en secondes entre les lectures. La valeur par d\u00e9faut est de 3,0, avec un minimum de 1,0. #sensor_mcu: # Le micro-contr\u00f4leur \u00e0 lire. Doit \u00eatre le host_mcu Combined temperature sensor \u00b6 Combined temperature sensor is a virtual temperature sensor based on several other sensors. This sensor can be used with extruders, heater_generic and heater beds. sensor_type: temperature_combined #sensor_list: # Must be provided. List of sensors to combine to new \"virtual\" # sensor. # E.g. 'temperature_sensor sensor1,extruder,heater_bed' #combination_method: # Must be provided. Combination method used for the sensor. # Available options are 'max', 'min', 'mean'. #maximum_deviation: # Must be provided. Maximum permissible deviation between the sensors # to combine (e.g. 5 degrees). To disable it, use a large value (e.g. 999.9) Ventilateurs \u00b6 [fan] \u00b6 Ventilateur de refroidissement de la pi\u00e8ce. [fan] pin: # Broche de sortie contr\u00f4lant le ventilateur. Ce param\u00e8tre doit \u00eatre fourni. #max_power: 1.0 # La puissance maximale (exprim\u00e9e en tant que valeur comprise entre 0,0 et 1,0) \u00e0 laquelle # r\u00e9gler la broche. La valeur 1.0 permet de r\u00e9gler la broche enti\u00e8rement activ\u00e9e pendant de # longues p\u00e9riodes, tandis qu'une valeur de 0,5 permet \u00e0 la broche de n'\u00eatre activ\u00e9e que # durant la moiti\u00e9 du temps au maximum. Ce param\u00e8tre peut \u00eatre utilis\u00e9 pour limiter la # puissance totale de sortie (sur des p\u00e9riodes prolong\u00e9es) du ventilateur. # Si cette valeur est inf\u00e9rieure \u00e0 1,0, les demandes de vitesse du ventilateur seront mises \u00e0 # l'\u00e9chelle entre z\u00e9ro et max_power (par exemple, si la puissance maximale est de 0,9 et # qu'une vitesse de 80 % est demand\u00e9e, la puissance du ventilateur sera r\u00e9gl\u00e9e \u00e0 72 %. # La valeur par d\u00e9faut est 1.0. #shutdown_speed: 0 # La vitesse souhait\u00e9e du ventilateur (exprim\u00e9e comme une valeur de 0,0 \u00e0 1,0) si # le logiciel du microcontr\u00f4leur passe dans un \u00e9tat d'erreur. La valeur par d\u00e9faut # est 0. #cycle_time: 0.010 # La dur\u00e9e (en secondes) de chaque cycle d'alimentation PWM du ventilateur. Il est # recommand\u00e9 que cette dur\u00e9e soit de 10 millisecondes ou plus si vous utilisez un PWM logiciel. # La valeur par d\u00e9faut est de 0,010 seconde. #hardware_pwm: False # Activez ceci pour utiliser le PWM mat\u00e9riel au lieu du PWM logiciel. La plupart des ventilateurs # ne fonctionnent pas correctement avec le PWM mat\u00e9riel, il n'est donc pas recommand\u00e9 # d'activer cette option \u00e0 moins qu'il n'y ait une exigence \u00e9lectrique pour obtenir une tr\u00e8s haute # vitesse. Lorsque vous utilisez le PWM mat\u00e9riel, le temps de cycle r\u00e9el est contraint par la mise # en \u0153uvre et peut \u00eatre significativement diff\u00e9rent du temps de cycle demand\u00e9. # La valeur par d\u00e9faut est False. #kick_start_time: 0.100 # Dur\u00e9e (en secondes) de fonctionnement du ventilateur \u00e0 pleine vitesse, soit lors de sa premi\u00e8re # activation soit lors d'une augmentation de plus de 50% (pour faire tourner le ventilateur). # La valeur par d\u00e9faut est de 0,100 seconde. #off_below: 0.0 # La vitesse d'entr\u00e9e minimale qui alimentera le ventilateur (exprim\u00e9e comme une valeur # comprise entre 0,0 et 1,0). Quand une vitesse inf\u00e9rieure \u00e0 off_below est demand\u00e9e le ventilateur # sera d\u00e9sactiv\u00e9. Ce r\u00e9glage peut \u00eatre utilis\u00e9 pour \u00e9viter que le ventilateur ne cale et pour # garantir que les d\u00e9marrages sont efficaces. # La valeur par d\u00e9faut est 0.0. # # Ce param\u00e8tre doit \u00eatre recalibr\u00e9 chaque fois que max_power est ajust\u00e9. # Pour calibrer ce param\u00e8tre, commencez avec off_below r\u00e9gl\u00e9 sur 0.0 et ventilateur tournant. Diminuez # progressivement la vitesse du ventilateur afin de d\u00e9terminer la vitesse d'entr\u00e9e la plus faible entra\u00eenant # le ventilateur de mani\u00e8re fiable sans d\u00e9crochage. R\u00e9glez off_below au rapport cyclique correspondant # \u00e0 cette valeur (par exemple, 12% -> 0,12) ou l\u00e9g\u00e8rement plus. #tachometer_pin: # Broche d'entr\u00e9e tachym\u00e9trique de surveillance de la vitesse du ventilateur. Un pullup est g\u00e9n\u00e9ralement # n\u00e9cessaire. Ce param\u00e8tre est facultatif. #tachometer_ppr: 2 # Lorsque tachometer_pin est sp\u00e9cifi\u00e9, il s'agit du nombre d'impulsions par r\u00e9volution du signal # tachym\u00e9trique. Pour un ventilateur BLDC, c'est normalement la moiti\u00e9 du nombre de p\u00f4les. # La valeur par d\u00e9faut est 2. #tachometer_poll_interval: 0.0015 # Lorsque tachometer_pin est sp\u00e9cifi\u00e9, il s'agit de la p\u00e9riode d'interrogation de la broche tachym\u00e9trique, # en secondes. La valeur par d\u00e9faut est 0.0015, ce qui est suffisamment rapide pour des ventilateurs de # moins de 10000 RPM \u00e0 2 PPR. Cette valeur doit \u00eatre inf\u00e9rieure \u00e0 30/(tachometer_ppr*rpm), avec une # certaine marge, o\u00f9 rpm est la vitesse maximale (en RPM) du ventilateur. #enable_pin: # Broche optionnelle pour d'activation de l'alimentation du ventilateur. Cela peut \u00eatre utile pour les # ventilateurs avec des entr\u00e9es PWM d\u00e9di\u00e9es. Certains de ces ventilateurs restent allum\u00e9s m\u00eame \u00e0 0 % # de PWM. Dans ce cas, la broche PWM peut \u00eatre utilis\u00e9e normalement et, par exemple, un FET commut\u00e9 # \u00e0 la masse (broche de ventilateur standard) peut \u00eatre utilis\u00e9 pour contr\u00f4ler l'alimentation du ventilateur. [heater_fan] \u00b6 Ventilateurs de chauffage (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"heater_fan\"). Un \"ventilateur de chauffage\" est un ventilateur activ\u00e9 lorsque le chauffage qui lui est associ\u00e9 est actif. Par d\u00e9faut, un heater_fan a une vitesse d'arr\u00eat \u00e9gale \u00e0 la puissance maximale. [heater_fan heatbreak_cooling_fan] #pin: #max_power: #shutdown_speed: #cycle_time: #hardware_pwm: #kick_start_time: #off_below: #tachometer_pin: #tachometer_ppr: #tachometer_poll_interval: #enable_pin: # See the \"fan\" section for a description of the above parameters. #heater: extruder # Name of the config section defining the heater that this fan is # associated with. If a comma separated list of heater names is # provided here, then the fan will be enabled when any of the given # heaters are enabled. The default is \"extruder\". #heater_temp: 50.0 # A temperature (in Celsius) that the heater must drop below before # the fan is disabled. The default is 50 Celsius. #fan_speed: 1.0 # The fan speed (expressed as a value from 0.0 to 1.0) that the fan # will be set to when its associated heater is enabled. The default # is 1.0 [controller_fan] \u00b6 Ventilateur de refroidissement du contr\u00f4leur (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"controller_fan\"). Un \"ventilateur de contr\u00f4leur\" est un ventilateur activ\u00e9 chaque fois que l'\u00e9l\u00e9ment chauffant ou le pilote pas \u00e0 pas qui lui est associ\u00e9 est actif. Le ventilateur s'arr\u00eatera chaque fois qu'un idle_timeout sera atteint afin de garantir qu'aucune surchauffe ne se produise apr\u00e8s la d\u00e9sactivation d'un composant surveill\u00e9. [controller_fan my_controller_fan] #pin: #max_power: #shutdown_speed: #cycle_time: #hardware_pwm: #kick_start_time: #off_below: #tachometer_pin: #tachometer_ppr: #tachometer_poll_interval: #enable_pin: # Voir la section \"fan\" pour une description des param\u00e8tres ci-dessus. #fan_speed: 1.0 # Vitesse du ventilateur (exprim\u00e9e comme une valeur de 0,0 \u00e0 1,0) \u00e0 laquelle celui-ci # sera r\u00e9gl\u00e9 lorsqu'un chauffage ou un pilote pas \u00e0 pas est actif. # La valeur par d\u00e9faut est 1.0 #idle_timeout: # Dur\u00e9e (en secondes) apr\u00e8s activit\u00e9 d'un pilote pas \u00e0 pas ou d'un \u00e9l\u00e9ment chauffant # pour laquelle le ventilateur doit continuer de fonctionner. La valeur par d\u00e9faut # est de 30 secondes. #idle_speed: # Vitesse du ventilateur (exprim\u00e9e comme une valeur de 0,0 et 1,0) \u00e0 laquelle le r\u00e9gler # lors de l'activit\u00e9 d'une chauffe ou d'un pilote pas \u00e0 pas avant que le d\u00e9lai d'attente # idle_timeout ne soit atteint. La valeur par d\u00e9faut est fan_speed. #heater: #stepper : # Nom de la section de configuration d\u00e9finissant l'\u00e9l\u00e9ment chauffant/pilote auquel ce ventilateur # est associ\u00e9. Si une liste s\u00e9par\u00e9e par des virgules de noms d'\u00e9l\u00e9ments chauffants/pilotes est # fournie ici, le ventilateur s'activera lorsque l'un des \u00e9l\u00e9ments chauffants/pilotes donn\u00e9s est activ\u00e9. # Le chauffage par d\u00e9faut est \"extruder\", le pilote par d\u00e9faut est tous. [temperature_fan] \u00b6 Ventilateurs de refroidissement d\u00e9clench\u00e9s en fonction de la temp\u00e9rature (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"temperature_fan\"). Un \"ventilateur de temp\u00e9rature\" est un ventilateur activ\u00e9 lorsque le capteur qui lui est associ\u00e9 est au-dessus d'une temp\u00e9rature d\u00e9finie. Par d\u00e9faut, un ventilateur de temp\u00e9rature a une vitesse d'arr\u00eat \u00e9gale \u00e0 la puissance maximale. Voir la r\u00e9f\u00e9rence des commandes pour plus d'informations. [temperature_fan my_temp_fan] #pin: #max_power: #shutdown_speed: #cycle_time: #hardware_pwm: #kick_start_time: #off_below: #tachometer_pin: #tachometer_ppr: #tachometer_poll_interval: #enable_pin: # Voir la section \"ventilateur\" pour une description des param\u00e8tres ci-dessus. #sensor_type: #sensor_pin: #control: #max_delta: #min_temp: #max_temp: # Voir la section \"extrudeuse\" pour une description des param\u00e8tres ci-dessus. #pid_Kp: #pid_Ki: #pid_Kd: # Les param\u00e8tres proportionnels (pid_Kp), int\u00e9graux (pid_Ki), et d\u00e9riv\u00e9s (pid_Ki) # du syst\u00e8me de contr\u00f4le par r\u00e9troaction PID. Klipper \u00e9value les param\u00e8tres PID # avec la formule g\u00e9n\u00e9rale suivante : # fan_pwm = max_power - (Kp*e + Ki*integral(e) - Kd*derivative(e)) / 255 # O\u00f9 \"e\" est \"temp\u00e9rature_cible - temp\u00e9rature_mesur\u00e9e\" et # \"fan_pwm\" est le d\u00e9bit du ventilateur demand\u00e9, 0,0 correspondant \u00e0 un arr\u00eat complet # et 1,0 correspond \u00e0 un fonctionnement \u00e0 plein r\u00e9gime. Les param\u00e8tres pid_Kp, pid_Ki, # et pid_Kd doivent \u00eatre fournis lorsque l'algorithme de contr\u00f4le PID est activ\u00e9. #pid_deriv_time: 2.0 # Une dur\u00e9e (en secondes) sur laquelle lisser les mesures de temp\u00e9rature lors de # l'utilisation de l'algorithme de contr\u00f4le PID. Cela peut r\u00e9duire l'impact du bruit de # mesure. La valeur par d\u00e9faut est de 2 secondes. #target_temp: 40.0 # Une temp\u00e9rature (en Celsius) qui sera la temp\u00e9rature cible. # La valeur par d\u00e9faut est 40 degr\u00e9s. #max_speed: 1.0 # La vitesse du ventilateur (exprim\u00e9e comme une valeur de 0,0 \u00e0 1,0) \u00e0 laquelle r\u00e9gler # le ventilateur lorsque la temp\u00e9rature du capteur d\u00e9passera la valeur d\u00e9finie. # La valeur par d\u00e9faut est 1.0. #min_speed: 0.3 # Vitesse minimale du ventilateur (exprim\u00e9e sous forme d'une valeur comprise entre 0,0 # et 1,0) \u00e0 laquelle r\u00e9gler le ventilateur pour les ventilateurs \u00e0 temp\u00e9rature PID. # La valeur par d\u00e9faut est 0,3. #gcode_id: # S'il est d\u00e9fini, la temp\u00e9rature sera signal\u00e9e dans les requ\u00eates M105 en utilisant l'identifiant # d'id donn\u00e9. La valeur par d\u00e9faut est de ne pas rapporter la temp\u00e9rature via M105. [fan_generic] \u00b6 Ventilateur command\u00e9 manuellement (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"fan_generic\"). La vitesse d'un ventilateur command\u00e9 manuellement est r\u00e9gl\u00e9e avec la commande SET_FAN_SPEED commandes G-Code . [fan_generic extruder_partfan] #pin: #max_power: #shutdown_speed: #cycle_time: #hardware_pwm: #kick_start_time: #off_below: #tachometer_pin: #tachometer_ppr: #tachometer_poll_interval: #enable_pin: # Voir la section \"ventilateur\" pour une description des param\u00e8tres ci-dessus. LEDs \u00b6 [led] \u00b6 Prise en charge des LEDs (et des bandes de LEDs) contr\u00f4l\u00e9es par les broches PWM du microcontr\u00f4leur (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"led\"). Voir la r\u00e9f\u00e9rence de la commande pour plus d'informations. [led my_led] #red_pin: #green_pin: #blue_pin: #white_pin: # La broche contr\u00f4lant la couleur de la LED donn\u00e9e. Au moins un des param\u00e8tres ci-dessus # doit \u00eatre fourni. #cycle_time: 0.010 # Dur\u00e9e (en secondes) par cycle PWM. Il est recommand\u00e9 # que ce soit 10 millisecondes ou plus lorsque l'on utilise un PWM logiciel. # La valeur par d\u00e9faut est de 0,010 seconde. #hardware_pwm: False # Activez ceci pour utiliser le PWM mat\u00e9riel au lieu du PWM logiciel. Lors de # l'utilisation du PWM mat\u00e9riel, le temps de cycle r\u00e9el est contraint par # l'impl\u00e9mentation et peut \u00eatre significativement diff\u00e9rent du # cycle_time demand\u00e9. La valeur par d\u00e9faut est False. #initial_RED: 0.0 #initial_GREEN: 0.0 #initial_BLUE: 0.0 #initial_WHITE: 0.0 # D\u00e9finit la couleur initiale de la LED. Chaque valeur doit \u00eatre comprise entre 0.0 et # 1.0. La valeur par d\u00e9faut pour chaque couleur est 0. [neopixel] \u00b6 Prise en charge des LED neopixel (alias WS2812) (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"neopixel\"). Voir la r\u00e9f\u00e9rence de commande pour plus d'informations. Notez que l'impl\u00e9mentation du mcu linux ne supporte pas actuellement les neopixels directement connect\u00e9s. La conception actuelle utilisant l'interface du noyau Linux ne permet pas ce sc\u00e9nario car l'interface GPIO du noyau n'est pas assez rapide pour fournir les taux d'impulsion requis. [neopixel my_neopixel] pin: # La broche connect\u00e9e au neopixel. Ce param\u00e8tre doit \u00eatre # fourni. #chain_count: # Le nombre de puces Neopixel connect\u00e9es en \"cha\u00eene\" \u00e0 la broche fournie. # La valeur par d\u00e9faut est 1 (ce qui indique qu'un seul Neopixel est connect\u00e9 \u00e0 la broche). #color_order: GRB # D\u00e9finit l'ordre des pixels requis par le mat\u00e9riel LED (en utilisant une cha\u00eene # contenant les lettres R, G, B, W avec W en option). Alternativement, il peut s'agir d'une liste # d'ordres de pixels s\u00e9par\u00e9s par des virgules - un pour chaque LED de la cha\u00eene. # La valeur par d\u00e9faut est GRB. #initial_RED: 0.0 #initial_GREEN: 0.0 #initial_BLUE: 0.0 #initial_WHITE: 0.0 # Voir la section \"led\" pour des informations sur ces param\u00e8tres. [dotstar] \u00b6 Prise en charge des LEDs Dotstar (alias APA102) (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"dotstar\"). Voir la r\u00e9f\u00e9rence de commande pour plus d'informations. [dotstar my_dotstar] data_pin: # La broche connect\u00e9e \u00e0 la ligne de donn\u00e9es du dotstar. Ce param\u00e8tre # doit \u00eatre fourni. clock_pin: # La broche connect\u00e9e \u00e0 la ligne d'horloge du dotstar. Ce param\u00e8tre # doit \u00eatre fourni. #chain_count: # Voir la section \"neopixel\" pour des informations sur ce param\u00e8tre. #initial_RED: 0.0 #initial_GREEN: 0.0 #initial_BLUE: 0.0 # Voir la section \"led\" pour des informations sur ces param\u00e8tres. [pca9533] \u00b6 Support de la LED PCA9533. Le PCA9533 est utilis\u00e9 sur la mightyboard. [pca9533 my_pca9533] #i2c_address: 98 # The i2c address that the chip is using on the i2c bus. Use 98 for # the PCA9533/1, 99 for the PCA9533/2. The default is 98. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #initial_RED: 0.0 #initial_GREEN: 0.0 #initial_BLUE: 0.0 #initial_WHITE: 0.0 # See the \"led\" section for information on these parameters. [pca9632] \u00b6 Support des LEDs du PCA9632. Le PCA9632 est utilis\u00e9 sur le FlashForge Dreamer. [pca9632 my_pca9632] #i2c_address: 98 # The i2c address that the chip is using on the i2c bus. This may be # 96, 97, 98, or 99. The default is 98. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #scl_pin: #sda_pin: # Alternatively, if the pca9632 is not connected to a hardware I2C # bus, then one may specify the \"clock\" (scl_pin) and \"data\" # (sda_pin) pins. The default is to use hardware I2C. #color_order: RGBW # Set the pixel order of the LED (using a string containing the # letters R, G, B, W). The default is RGBW. #initial_RED: 0.0 #initial_GREEN: 0.0 #initial_BLUE: 0.0 #initial_WHITE: 0.0 # See the \"led\" section for information on these parameters. Servos suppl\u00e9mentaires, boutons et autres broches \u00b6 [servo] \u00b6 Servos (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"servo\"). Les servos peuvent \u00eatre contr\u00f4l\u00e9s en utilisant la commande SET_SERVO g-code . Par exemple : SET_SERVO SERVO=my_servo ANGLE=180 [servo my_servo] pin: # Broche de sortie PWM contr\u00f4lant le servo. Ce param\u00e8tre doit \u00eatre # fourni. #maximum_servo_angle: 180 # L'angle maximum (en degr\u00e9s) auquel ce servo peut \u00eatre r\u00e9gl\u00e9. La valeur # par d\u00e9faut est de 180 degr\u00e9s. #minimum_pulse_width: 0.001 # La dur\u00e9e minimale de la largeur d'impulsion (en secondes). Cela devrait correspondre # avec un angle de 0 degr\u00e9. La valeur par d\u00e9faut est de 0,001 seconde. #maximum_pulse_width: 0.002 # La dur\u00e9e maximale de la largeur d'impulsion (en secondes). Cela devrait correspondre # avec l'angle de maximum_servo_angle. La valeur par d\u00e9faut est 0.002 secondes. #initial_angle: # Angle initial (en degr\u00e9s) sur lequel r\u00e9gler le servo. La valeur par d\u00e9faut est de # ne pas envoyer de signal au d\u00e9marrage. #initial_pulse_width: # Dur\u00e9e initiale de la largeur d'impulsion (en secondes) \u00e0 laquelle le servo doit \u00eatre r\u00e9gl\u00e9. (Ceci # n'est valable que si initial_angle n'est pas d\u00e9fini). La valeur par d\u00e9faut est de n'envoyer # aucun signal au d\u00e9marrage. [gcode_button] \u00b6 Ex\u00e9cute le gcode quand un bouton est press\u00e9 ou rel\u00e2ch\u00e9 (ou quand une broche change d'\u00e9tat). Vous pouvez v\u00e9rifier l'\u00e9tat du bouton en utilisant QUERY_BUTTON button=my_gcode_button . [gcode_button my_gcode_button] pin: # La broche sur laquelle le bouton est connect\u00e9. Ce param\u00e8tre doit \u00eatre # fourni. #analog_range: # Deux r\u00e9sistances s\u00e9par\u00e9es par des virgules (en Ohms) sp\u00e9cifiant la plage de # r\u00e9sistance minimale et maximale de la r\u00e9sistance du bouton. Si le param\u00e8tre # analog_range est fourni, la broche doit \u00eatre une broche \u00e0 capacit\u00e9 analogique. # La valeur par d\u00e9faut est d'utiliser un gpio num\u00e9rique pour le bouton. #analog_pullup_resistor: # La r\u00e9sistance d'excursion (en Ohms) lorsque la gamme analogique est sp\u00e9cifi\u00e9e. # La valeur par d\u00e9faut est 4700 ohms. #press_gcode: # Une liste de commandes G-Code \u00e0 ex\u00e9cuter lorsque le bouton est press\u00e9. # Les mod\u00e8les G-Code sont pris en charge. Ce param\u00e8tre doit \u00eatre fourni. #release_gcode: # Une liste de commandes G-code \u00e0 ex\u00e9cuter lorsque le bouton est rel\u00e2ch\u00e9. # Les mod\u00e8les G-Code sont support\u00e9s. La valeur par d\u00e9faut est de ne pas ex\u00e9cuter # de commandes lors du rel\u00e2chement d'un bouton. [output_pin] \u00b6 Broches de sortie configurables \u00e0 l'ex\u00e9cution (on peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe \"output_pin\"). Les broches configur\u00e9es ici seront param\u00e9tr\u00e9es comme des broches de sortie modifiables au moment de l'ex\u00e9cution en utilisant des commandes g-code \u00e9tendues de type \"SET_PIN PIN=my_pin VALUE=.1\" [output_pin my_pin] pin: # La broche \u00e0 configurer comme une sortie. Ce param\u00e8tre doit \u00eatre # fourni. #pwm: False # D\u00e9finit si la broche de sortie doit \u00eatre capable de modulation de largeur d'impulsion. # Si ce param\u00e8tre est vrai, les champs de valeur doivent \u00eatre compris entre 0 et 1. # La valeur par d\u00e9faut est False. #static_value: # Si cette valeur est d\u00e9finie, la broche est affect\u00e9e \u00e0 cette valeur au d\u00e9marrage et # la broche ne peut pas \u00eatre modifi\u00e9e pendant l'ex\u00e9cution. Une broche statique utilise # l\u00e9g\u00e8rement moins de RAM dans le micro-contr\u00f4leur. Le d\u00e9faut est d'utiliser # la configuration des broches param\u00e9tr\u00e9es lors du d\u00e9marrage. #value: # La valeur \u00e0 donner initialement \u00e0 la broche pendant la configuration du MCU. # La valeur par d\u00e9faut est 0 (pour une tension basse). #shutdown_value: # La valeur \u00e0 donner \u00e0 la broche lors d'un \u00e9v\u00e9nement d'arr\u00eat du MCU. La valeur par # d\u00e9faut est 0 (pour une tension basse). #maximum_mcu_duration: # La dur\u00e9e maximale pendant laquelle une valeur de non-arr\u00eat peut \u00eatre pilot\u00e9e par # le MCUsans un accus\u00e9 de r\u00e9ception de l'h\u00f4te. # Si l'h\u00f4te ne peut pas suivre une mise \u00e0 jour, le MCU s'\u00e9teindra et mettra # toutes les broches \u00e0 leurs valeurs d'arr\u00eat respectives. # D\u00e9faut : 0 (d\u00e9sactiv\u00e9) # Les valeurs habituelles sont d'environ 5 secondes. #cycle_time: 0.100 # La dur\u00e9e (en secondes) par cycle PWM. Il est recommand\u00e9 que ce soit # 10 millisecondes ou plus lorsque vous utilisez un PWM logiciel. # La valeur par d\u00e9faut est de 0.100 secondes pour les broches PWM. #hardware_pwm: False # Activez pour utiliser le PWM mat\u00e9riel au lieu du PWM logiciel. Lors de # l'utilisation d'un PWM mat\u00e9riel, le temps de cycle r\u00e9el est limit\u00e9 par # l'impl\u00e9mentation et peut \u00eatre significativement diff\u00e9rent du # cycle_time demand\u00e9. La valeur par d\u00e9faut est False. #scale : # Ce param\u00e8tre peut \u00eatre utilis\u00e9 pour modifier la fa\u00e7on dont les param\u00e8tres 'value' # et 'shutdown_value' sont interpr\u00e9t\u00e9s pour les broches pwm. Si fourni, alors # le param\u00e8tre 'value' doit \u00eatre compris entre 0.0 et 'scale'. Cela peut \u00eatre utile # lors de la configuration d'une broche PWM contr\u00f4lant une r\u00e9f\u00e9rence de tension # d'un moteur pas \u00e0 pas. L''\u00e9chelle' peut \u00eatre d\u00e9finie sur l'intensit\u00e9 du moteur pas # \u00e0 pas \u00e9quivalent si le PWM \u00e9tait enti\u00e8rement activ\u00e9, et puis le param\u00e8tre 'value' # peut \u00eatre sp\u00e9cifi\u00e9 en utilisant l'intensit\u00e9 souhait\u00e9e pour le moteur pas \u00e0 pas. La # valeur par d\u00e9faut est de ne pas mettre \u00e0 l'\u00e9chelle le param\u00e8tre 'value'. [static_digital_output] \u00b6 Broches de sortie num\u00e9rique configur\u00e9es statiquement (on peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe \"static_digital_output\"). Les broches configur\u00e9es ici seront configur\u00e9es comme une sortie GPIO pendant la configuration du MCU. Elles ne peuvent pas \u00eatre modifi\u00e9es en cours d'ex\u00e9cution. [static_digital_output my_output_pins] pins: # Une liste de broches s\u00e9par\u00e9es par des virgules \u00e0 d\u00e9finir comme broches de sortie GPIO. La broche # sera d\u00e9finie \u00e0 un niveau haut, sauf si le nom de la broche est pr\u00e9c\u00e9d\u00e9 de \"!\". # Ce param\u00e8tre doit \u00eatre fourni. [multi_pin] \u00b6 Sorties \u00e0 broches multiples (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"multi_pin\"). Une sortie multi_pin cr\u00e9e un alias de broche interne pouvant modifier plusieurs broches de sortie chaque fois que la broche alias est d\u00e9finie. Par exemple, on peut d\u00e9finir un objet \"[multi_pin my_fan]\" contenant deux broches et ensuite d\u00e9finir \"pin=multi_pin:my_fan\" dans la section \"[fan]\" - \u00e0 chaque changement du ventilateur, les deux broches de sortie seront mises \u00e0 jour. Ces alias ne peuvent pas \u00eatre utilis\u00e9s avec des broches de moteur pas \u00e0 pas. [multi_pin my_multi_pin] pins: # Une liste s\u00e9par\u00e9e par des virgules des broches associ\u00e9es \u00e0 cet alias. Ce param\u00e8tre # doit \u00eatre fourni. Configuration des pilotes pas \u00e0 pas TMC \u00b6 Configuration des pilotes de moteurs pas \u00e0 pas Trinamic en mode UART/SPI. Des informations suppl\u00e9mentaires sont disponibles dans le guide des pilotes TMC et dans la r\u00e9f\u00e9rence des commandes . [tmc2130] \u00b6 Configuration d' un pilote de moteur pas \u00e0 pas TMC2130 via le bus SPI. Pour utiliser cette fonctionnalit\u00e9, d\u00e9finissez une section de configuration avec un pr\u00e9fixe \"tmc2130\" suivi du nom de la section de configuration du moteur pas \u00e0 pas correspondant (par exemple, \"[tmc2130 stepper_x]\"). [tmc2130 stepper_x] cs_pin: # La broche correspondant \u00e0 la ligne de s\u00e9lection de puce de la TMC2130. Cette # broche sera mise \u00e0 l'\u00e9tat bas au d\u00e9but des messages SPI et remont\u00e9e \u00e0 l'\u00e9tat haut # apr\u00e8s la fin du message. Ce param\u00e8tre doit \u00eatre fourni. #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # Voir la section \"param\u00e8tres SPI communs\" pour une description des param\u00e8tres # ci-dessus. #chain_position: #chain_length: # Ces param\u00e8tres configurent une guirlande SPI. Les deux param\u00e8tres d\u00e9finissent la # position du pilote moteur dans la cha\u00eene et la longueur totale de la cha\u00eene. # La position 1 correspond au pilote moteur stepper qui se connecte au signal MOSI. # La valeur par d\u00e9faut est de ne pas utiliser de guirlande SPI. # Interpoler: True # Si true, active l'interpolation de pas (le pilote fera un pas interne \u00e0 un taux de 256 # micro-pas). Cette interpolation introduit une petite d\u00e9viation syst\u00e9mique de la # position - voir TMC_Drivers.md pour plus de d\u00e9tails. La valeur par d\u00e9faut est True. run_current: # Configuration de la quantit\u00e9 de courant (en amp\u00e8res RMS) que le pilote utilise # pendant le mouvement du moteur pas \u00e0 pas. Ce param\u00e8tre doit \u00eatre fourni. #hold_current: # Configuration de la quantit\u00e9 de courant (en amp\u00e8res RMS) que le pilote utilise # lorsque le moteur pas \u00e0 pas n'est pas en mouvement. La d\u00e9finition d'un hold_current # n'est pas recommand\u00e9e (voir TMC_Drivers.md pour plus de d\u00e9tails). La valeur par # d\u00e9faut est de ne pas r\u00e9duire le courant. #sense_resistor: 0.110 # La r\u00e9sistance (en ohms) de la r\u00e9sistance de d\u00e9tection du moteur. La valeur par d\u00e9faut # est de 0.110 ohms. #stealthchop_threshold: 0 # La vitesse (en mm/s) \u00e0 laquelle le seuil \"stealthChop\" doit \u00eatre fix\u00e9. Lorsque d\u00e9fini, le # mode \"stealthChop\" sera activ\u00e9 si la vitesse du moteur pas \u00e0 pas est inf\u00e9rieure \u00e0 cette # valeur. La valeur par d\u00e9faut est 0, ce qui d\u00e9sactive le mode \"stealthChop\". #driver_MSLUT0: 2863314260 #driver_MSLUT1: 1251300522 #driver_MSLUT2: 608774441 #driver_MSLUT3: 269500962 #driver_MSLUT4: 4227858431 #driver_MSLUT5: 3048961917 #driver_MSLUT6: 1227445590 #driver_MSLUT7: 4211234 #driver_W0: 2 #driver_W1: 1 #driver_W2: 1 #driver_W3: 1 #driver_X1: 128 #driver_X2: 255 #driver_X3: 255 #driver_START_SIN: 0 #driver_START_SIN90: 247 # Ces champs contr\u00f4lent directement les registres de la table des micro-pas. La table # d'ondes est sp\u00e9cifique \u00e0 chaque moteur et peut varier en fonction du courant. Une # configuration optimale aura un minimum d'artefacts d'impression caus\u00e9s par le # mouvement non lin\u00e9aire du moteur pas \u00e0 pas. Les valeurs sp\u00e9cifi\u00e9es ci-dessus sont # les valeurs par d\u00e9faut utilis\u00e9es par le pilote. La valeur doit \u00eatre sp\u00e9cifi\u00e9e sous la forme # d'un entier d\u00e9cimal (la forme hexad\u00e9cimale n'est pas prise en charge). Afin de calculer # les champs de la table d'onde, consultez la \"feuille de calcul\" tmc2130 sur le site # Web de Trinamic. #driver_IHOLDDELAY: 8 #driver_TPOWERDOWN: 0 #driver_TBL: 1 #driver_TOFF: 4 #driver_HEND: 7 #driver_HSTRT: 0 #driver_PWM_AUTOSCALE: True #driver_PWM_FREQ: 1 #driver_PWM_GRAD: 4 #driver_PWM_AMPL: 128 #driver_SGT: 0 # Permet de d\u00e9finir le registre donn\u00e9 pendant la configuration de la puce TMC2130. # Ceci peut \u00eatre utilis\u00e9 pour d\u00e9finir les param\u00e8tres personnalis\u00e9s du moteur. Les valeurs # par d\u00e9faut de chaque param\u00e8tre sont indiqu\u00e9es \u00e0 c\u00f4t\u00e9 du nom du param\u00e8tre dans la # liste ci-dessus. #diag0_pin: #diag1_pin: # La broche du microcontr\u00f4leur reli\u00e9e \u00e0 l'une des lignes DIAG de la puce TMC2130. # Une seule broche diag doit \u00eatre sp\u00e9cifi\u00e9e. La broche est \"active low\" et est donc # normalement pr\u00e9c\u00e9d\u00e9e de \"^ !\". Le r\u00e9glage de ceci cr\u00e9e une broche virtuelle # \"tmc2130_stepper_x:virtual_endstop\" pouvant \u00eatre utilis\u00e9e comme broche d'arr\u00eat # du moteur. Cela permet d'activer le \"sensorless homing\". (Assurez-vous de r\u00e9gler # \u00e9galement driver_SGT \u00e0 une valeur de sensibilit\u00e9 appropri\u00e9e). # La valeur par d\u00e9faut est de ne pas activer la recherche d'origine sans capteur. [tmc2208] \u00b6 Configuration d'un pilote de moteur pas \u00e0 pas TMC2208 (ou TMC2224) via un UART \u00e0 fil unique. Pour utiliser cette fonctionnalit\u00e9, d\u00e9finissez une section de configuration avec un pr\u00e9fixe \"tmc2208\" suivi du nom de la section de configuration du moteur pas \u00e0 pas correspondant (par exemple, \"[tmc2208 stepper_x]\"). [tmc2208 stepper_x] uart_pin: # The pin connected to the TMC2208 PDN_UART line. This parameter # must be provided. #tx_pin: # If using separate receive and transmit lines to communicate with # the driver then set uart_pin to the receive pin and tx_pin to the # transmit pin. The default is to use uart_pin for both reading and # writing. #select_pins: # A comma separated list of pins to set prior to accessing the # tmc2208 UART. This may be useful for configuring an analog mux for # UART communication. The default is to not configure any pins. #interpolate: True # If true, enable step interpolation (the driver will internally # step at a rate of 256 micro-steps). This interpolation does # introduce a small systemic positional deviation - see # TMC_Drivers.md for details. The default is True. run_current: # The amount of current (in amps RMS) to configure the driver to use # during stepper movement. This parameter must be provided. #hold_current: # The amount of current (in amps RMS) to configure the driver to use # when the stepper is not moving. Setting a hold_current is not # recommended (see TMC_Drivers.md for details). The default is to # not reduce the current. #sense_resistor: 0.110 # The resistance (in ohms) of the motor sense resistor. The default # is 0.110 ohms. #stealthchop_threshold: 0 # The velocity (in mm/s) to set the \"stealthChop\" threshold to. When # set, \"stealthChop\" mode will be enabled if the stepper motor # velocity is below this value. The default is 0, which disables # \"stealthChop\" mode. #driver_MULTISTEP_FILT: True #driver_IHOLDDELAY: 8 #driver_TPOWERDOWN: 20 #driver_TBL: 2 #driver_TOFF: 3 #driver_HEND: 0 #driver_HSTRT: 5 #driver_PWM_AUTOGRAD: True #driver_PWM_AUTOSCALE: True #driver_PWM_LIM: 12 #driver_PWM_REG: 8 #driver_PWM_FREQ: 1 #driver_PWM_GRAD: 14 #driver_PWM_OFS: 36 # Set the given register during the configuration of the TMC2208 # chip. This may be used to set custom motor parameters. The # defaults for each parameter are next to the parameter name in the # above list. [tmc2209] \u00b6 Configuration d'un pilote de moteur pas \u00e0 pas TMC2209 via un UART \u00e0 fil unique. Pour utiliser cette fonctionnalit\u00e9, d\u00e9finissez une section de configuration avec un pr\u00e9fixe \"tmc2209\" suivi du nom de la section de configuration du moteur pas \u00e0 pas correspondant (par exemple, \"[tmc2209 stepper_x]\"). [tmc2209 stepper_x] uart_pin: #tx_pin: #select_pins: #interpolate: True run_current: #hold_current: #sense_resistor: 0.110 #stealthchop_threshold: 0 # See the \"tmc2208\" section for the definition of these parameters. #uart_address: # The address of the TMC2209 chip for UART messages (an integer # between 0 and 3). This is typically used when multiple TMC2209 # chips are connected to the same UART pin. The default is zero. #driver_MULTISTEP_FILT: True #driver_IHOLDDELAY: 8 #driver_TPOWERDOWN: 20 #driver_TBL: 2 #driver_TOFF: 3 #driver_HEND: 0 #driver_HSTRT: 5 #driver_PWM_AUTOGRAD: True #driver_PWM_AUTOSCALE: True #driver_PWM_LIM: 12 #driver_PWM_REG: 8 #driver_PWM_FREQ: 1 #driver_PWM_GRAD: 14 #driver_PWM_OFS: 36 #driver_SGTHRS: 0 # Set the given register during the configuration of the TMC2209 # chip. This may be used to set custom motor parameters. The # defaults for each parameter are next to the parameter name in the # above list. #diag_pin: # The micro-controller pin attached to the DIAG line of the TMC2209 # chip. The pin is normally prefaced with \"^\" to enable a pullup. # Setting this creates a \"tmc2209_stepper_x:virtual_endstop\" virtual # pin which may be used as the stepper's endstop_pin. Doing this # enables \"sensorless homing\". (Be sure to also set driver_SGTHRS to # an appropriate sensitivity value.) The default is to not enable # sensorless homing. [tmc2660] \u00b6 Configuration d'un pilote de moteur pas \u00e0 pas TMC2660 via le bus SPI. Pour utiliser cette fonctionnalit\u00e9, d\u00e9finissez une section de configuration avec un pr\u00e9fixe \"tmc2660\" suivi du nom de la section de configuration du moteur pas \u00e0 pas correspondant (par exemple, \"[tmc2660 stepper_x]\"). [tmc2660 stepper_x] cs_pin: # La broche correspondant \u00e0 la ligne de s\u00e9lection de la puce TMC2660. Cette # broche sera mise \u00e0 l'\u00e9tat bas au d\u00e9but des messages SPI et passera \u00e0 l'\u00e9tat # haut apr\u00e8s la fin du transfert du message. Ce param\u00e8tre doit \u00eatre fourni. #spi_speed: 4000000 # Fr\u00e9quence du bus SPI utilis\u00e9e pour communiquer avec le pilote de pas \u00e0 pas # TMC2660. La valeur par d\u00e9faut est 4000000. #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # Voir la section \"param\u00e8tres SPI communs\" pour une description des # param\u00e8tres ci-dessus. #interpolate: True # Si vrai, active l'interpolation par pas (le pilote fera un pas interne \u00e0 un taux # de 256 micro-pas). Cela ne fonctionne que si les micro-pas sont fix\u00e9s \u00e0 16. # L'interpolation introduit une petite d\u00e9viation de position syst\u00e9mique - voir # TMC_Drivers.md pour plus de d\u00e9tails. La valeur par d\u00e9faut est True. run_current: # La quantit\u00e9 de courant (en amp\u00e8res RMS) utilis\u00e9e par le pilote pendant le # d\u00e9placement du moteur pas \u00e0 pas. Ce param\u00e8tre doit \u00eatre fourni. #sense_resistor: # La r\u00e9sistance (en ohms) de la r\u00e9sistance de d\u00e9tection du moteur (Vr\u00e9f). Ce # param\u00e8tre doit \u00eatre fourni. #idle_current_percent 100 # Le pourcentage du courant de fonctionnement auquel le pilote pas \u00e0 pas # sera abaiss\u00e9 quand le d\u00e9lai d'inactivit\u00e9 expirera (vous devez configurer le # d\u00e9lai \u00e0 l'aide d'une section de configuration [idle_timeout]). Le courant sera # remont\u00e9 d\u00e8s que le moteur devra \u00e0 nouveau se d\u00e9placer. Assurez-vous de # d\u00e9finir une valeur suffisamment \u00e9lev\u00e9e pour que les moteurs ne perdent pas # leur position. Il y a \u00e9galement un petit d\u00e9lai avant que le courant ne soit remis, # il faut donc en tenir compte lors de demandes de mouvements rapides alors # que le pilote est inactif. La valeur par d\u00e9faut est 100 (aucune r\u00e9duction). #driver_TBL: 2 #driver_RNDTF: 0 #driver_HDEC: 0 #driver_CHM: 0 #driver_HEND: 3 #driver_HSTRT: 3 #driver_TOFF: 4 #driver_SEIMIN: 0 #driver_SEDN: 0 #driver_SEMAX: 0 #driver_SEUP: 0 #driver_SEMIN: 0 #driver_SFILT: 0 #driver_SGT: 0 #driver_SLPH: 0 #driver_SLPL: 0 #driver_DISS2G: 0 #driver_TS2G: 3 # D\u00e9finit les param\u00e8tres \u00e0 utiliser pendant la configuration de la puce TMC2660. # Ceci peut \u00eatre utilis\u00e9 pour d\u00e9finir des param\u00e8tres de pilote personnalis\u00e9s. Les # valeurs par d\u00e9faut de chaque param\u00e8tre sont indiqu\u00e9es \u00e0 c\u00f4t\u00e9 du nom du param\u00e8tre # dans la liste ci-dessus. Consultez la fiche technique du TMC2660 pour conna\u00eetre la # fonction de chaque param\u00e8tre ainsi que les restrictions sur les combinaisons de # param\u00e8tres. Soyez particuli\u00e8rement attentif au registre CHOPCONF, o\u00f9 le fait de # r\u00e9gler CHM \u00e0 soit z\u00e9ro, soit un, entra\u00eene des modifications de la disposition (le # premier bit de HDEC est interpr\u00e9t\u00e9 comme le MSB de HSTRT dans ce cas). [tmc2240] \u00b6 Configure a TMC2240 stepper motor driver via SPI bus or UART. To use this feature, define a config section with a \"tmc2240\" prefix followed by the name of the corresponding stepper config section (for example, \"[tmc2240 stepper_x]\"). [tmc2240 stepper_x] cs_pin: # The pin corresponding to the TMC2240 chip select line. This pin # will be set to low at the start of SPI messages and raised to high # after the message completes. This parameter must be provided. #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. #uart_pin: # The pin connected to the TMC2240 DIAG1/SW line. If this parameter # is provided UART communication is used rather then SPI. #chain_position: #chain_length: # These parameters configure an SPI daisy chain. The two parameters # define the stepper position in the chain and the total chain length. # Position 1 corresponds to the stepper that connects to the MOSI signal. # The default is to not use an SPI daisy chain. #interpolate: True # If true, enable step interpolation (the driver will internally # step at a rate of 256 micro-steps). The default is True. run_current: # The amount of current (in amps RMS) to configure the driver to use # during stepper movement. This parameter must be provided. #hold_current: # The amount of current (in amps RMS) to configure the driver to use # when the stepper is not moving. Setting a hold_current is not # recommended (see TMC_Drivers.md for details). The default is to # not reduce the current. #rref: 12000 # The resistance (in ohms) of the resistor between IREF and GND. The # default is 12000. #stealthchop_threshold: 0 # The velocity (in mm/s) to set the \"stealthChop\" threshold to. When # set, \"stealthChop\" mode will be enabled if the stepper motor # velocity is below this value. The default is 0, which disables # \"stealthChop\" mode. #driver_MSLUT0: 2863314260 #driver_MSLUT1: 1251300522 #driver_MSLUT2: 608774441 #driver_MSLUT3: 269500962 #driver_MSLUT4: 4227858431 #driver_MSLUT5: 3048961917 #driver_MSLUT6: 1227445590 #driver_MSLUT7: 4211234 #driver_W0: 2 #driver_W1: 1 #driver_W2: 1 #driver_W3: 1 #driver_X1: 128 #driver_X2: 255 #driver_X3: 255 #driver_START_SIN: 0 #driver_START_SIN90: 247 #driver_OFFSET_SIN90: 0 # These fields control the Microstep Table registers directly. The optimal # wave table is specific to each motor and might vary with current. An # optimal configuration will have minimal print artifacts caused by # non-linear stepper movement. The values specified above are the default # values used by the driver. The value must be specified as a decimal integer # (hex form is not supported). In order to compute the wave table fields, # see the tmc2130 \"Calculation Sheet\" from the Trinamic website. # Additionally, this driver also has the OFFSET_SIN90 field which can be used # to tune a motor with unbalanced coils. See the `Sine Wave Lookup Table` # section in the datasheet for information about this field and how to tune # it. #driver_MULTISTEP_FILT: True #driver_IHOLDDELAY: 6 #driver_IRUNDELAY: 4 #driver_TPOWERDOWN: 10 #driver_TBL: 2 #driver_TOFF: 3 #driver_HEND: 2 #driver_HSTRT: 5 #driver_FD3: 0 #driver_TPFD: 4 #driver_CHM: 0 #driver_VHIGHFS: 0 #driver_VHIGHCHM: 0 #driver_DISS2G: 0 #driver_DISS2VS: 0 #driver_PWM_AUTOSCALE: True #driver_PWM_AUTOGRAD: True #driver_PWM_FREQ: 0 #driver_FREEWHEEL: 0 #driver_PWM_GRAD: 0 #driver_PWM_OFS: 29 #driver_PWM_REG: 4 #driver_PWM_LIM: 12 #driver_SGT: 0 #driver_SEMIN: 0 #driver_SEUP: 0 #driver_SEMAX: 0 #driver_SEDN: 0 #driver_SEIMIN: 0 #driver_SFILT: 0 #driver_SG4_ANGLE_OFFSET: 1 # Set the given register during the configuration of the TMC2240 # chip. This may be used to set custom motor parameters. The # defaults for each parameter are next to the parameter name in the # above list. #diag0_pin: #diag1_pin: # The micro-controller pin attached to one of the DIAG lines of the # TMC2240 chip. Only a single diag pin should be specified. The pin # is \"active low\" and is thus normally prefaced with \"^!\". Setting # this creates a \"tmc2240_stepper_x:virtual_endstop\" virtual pin # which may be used as the stepper's endstop_pin. Doing this enables # \"sensorless homing\". (Be sure to also set driver_SGT to an # appropriate sensitivity value.) The default is to not enable # sensorless homing. [tmc5160] \u00b6 Configuration d'un pilote de moteur pas \u00e0 pas TMC5160 via le bus SPI. Pour utiliser cette fonctionnalit\u00e9, d\u00e9finissez une section de configuration avec un pr\u00e9fixe \"tmc5160\" suivi du nom de la section de configuration du moteur pas \u00e0 pas correspondant (par exemple, \"[tmc5160 stepper_x]\"). [tmc5160 stepper_x] cs_pin: # The pin corresponding to the TMC5160 chip select line. This pin # will be set to low at the start of SPI messages and raised to high # after the message completes. This parameter must be provided. #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. #chain_position: #chain_length: # These parameters configure an SPI daisy chain. The two parameters # define the stepper position in the chain and the total chain length. # Position 1 corresponds to the stepper that connects to the MOSI signal. # The default is to not use an SPI daisy chain. #interpolate: True # If true, enable step interpolation (the driver will internally # step at a rate of 256 micro-steps). The default is True. run_current: # The amount of current (in amps RMS) to configure the driver to use # during stepper movement. This parameter must be provided. #hold_current: # The amount of current (in amps RMS) to configure the driver to use # when the stepper is not moving. Setting a hold_current is not # recommended (see TMC_Drivers.md for details). The default is to # not reduce the current. #sense_resistor: 0.075 # The resistance (in ohms) of the motor sense resistor. The default # is 0.075 ohms. #stealthchop_threshold: 0 # The velocity (in mm/s) to set the \"stealthChop\" threshold to. When # set, \"stealthChop\" mode will be enabled if the stepper motor # velocity is below this value. The default is 0, which disables # \"stealthChop\" mode. #driver_MSLUT0: 2863314260 #driver_MSLUT1: 1251300522 #driver_MSLUT2: 608774441 #driver_MSLUT3: 269500962 #driver_MSLUT4: 4227858431 #driver_MSLUT5: 3048961917 #driver_MSLUT6: 1227445590 #driver_MSLUT7: 4211234 #driver_W0: 2 #driver_W1: 1 #driver_W2: 1 #driver_W3: 1 #driver_X1: 128 #driver_X2: 255 #driver_X3: 255 #driver_START_SIN: 0 #driver_START_SIN90: 247 # These fields control the Microstep Table registers directly. The optimal # wave table is specific to each motor and might vary with current. An # optimal configuration will have minimal print artifacts caused by # non-linear stepper movement. The values specified above are the default # values used by the driver. The value must be specified as a decimal integer # (hex form is not supported). In order to compute the wave table fields, # see the tmc2130 \"Calculation Sheet\" from the Trinamic website. #driver_MULTISTEP_FILT: True #driver_IHOLDDELAY: 6 #driver_TPOWERDOWN: 10 #driver_TBL: 2 #driver_TOFF: 3 #driver_HEND: 2 #driver_HSTRT: 5 #driver_FD3: 0 #driver_TPFD: 4 #driver_CHM: 0 #driver_VHIGHFS: 0 #driver_VHIGHCHM: 0 #driver_DISS2G: 0 #driver_DISS2VS: 0 #driver_PWM_AUTOSCALE: True #driver_PWM_AUTOGRAD: True #driver_PWM_FREQ: 0 #driver_FREEWHEEL: 0 #driver_PWM_GRAD: 0 #driver_PWM_OFS: 30 #driver_PWM_REG: 4 #driver_PWM_LIM: 12 #driver_SGT: 0 #driver_SEMIN: 0 #driver_SEUP: 0 #driver_SEMAX: 0 #driver_SEDN: 0 #driver_SEIMIN: 0 #driver_SFILT: 0 #driver_DRVSTRENGTH: 0 #driver_BBMCLKS: 4 #driver_BBMTIME: 0 #driver_FILT_ISENSE: 0 # Set the given register during the configuration of the TMC5160 # chip. This may be used to set custom motor parameters. The # defaults for each parameter are next to the parameter name in the # above list. #diag0_pin: #diag1_pin: # The micro-controller pin attached to one of the DIAG lines of the # TMC5160 chip. Only a single diag pin should be specified. The pin # is \"active low\" and is thus normally prefaced with \"^!\". Setting # this creates a \"tmc5160_stepper_x:virtual_endstop\" virtual pin # which may be used as the stepper's endstop_pin. Doing this enables # \"sensorless homing\". (Be sure to also set driver_SGT to an # appropriate sensitivity value.) The default is to not enable # sensorless homing. Configuration du courant du moteur pas \u00e0 pas en temps r\u00e9el \u00b6 [ad5206] \u00b6 Digipots AD5206 configur\u00e9s statiquement et connect\u00e9s via un bus SPI (on peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe \"ad5206\"). [ad5206 my_digipot] enable_pin: # La broche correspondant \u00e0 la ligne de s\u00e9lection de la puce AD5206. Cette broche # sera r\u00e9gl\u00e9e \u00e0 un niveau bas au d\u00e9but des messages SPI et sera relev\u00e9e \u00e0 un niveau \u00e9lev\u00e9 # apr\u00e8s la fin du message. Ce param\u00e8tre doit \u00eatre fourni. #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # Voir la section \"param\u00e8tres communs SPI\" pour une description des param\u00e8tres ci-dessus. # #channel_1: #channel_2: #channel_3: #channel_4: #channel_5: #channel_6: # La valeur pour d\u00e9finir statiquement le canal AD5206 donn\u00e9. Cette valeur est # g\u00e9n\u00e9ralement d\u00e9finie sur un nombre compris entre 0,0 et 1,0. 1,0 \u00e9tant la r\u00e9sistance # la plus \u00e9lev\u00e9e et 0,0 la r\u00e9sistance la plus faible. Cependant, la plage peut \u00eatre # modifi\u00e9e \u00e0 l'aide du param\u00e8tre 'scale' (voir ci-dessous). # Si un canal n'est pas sp\u00e9cifi\u00e9, il n'est pas configur\u00e9. # scale: # Ce param\u00e8tre peut \u00eatre utilis\u00e9 pour modifier l'interpr\u00e9tation des param\u00e8tres 'channel_x'. # S'il est fourni, alors les param\u00e8tres 'channel_x' doivent \u00eatre compris entre 0.0 et 'scale'. # Cela peut \u00eatre utile lorsque le AD5206 est utilis\u00e9 pour d\u00e9finir des r\u00e9f\u00e9rences de tension # pas \u00e0 pas. L''\u00e9chelle' peut \u00eatre r\u00e9gl\u00e9e sur l'intensit\u00e9 \u00e9quivalente de la commande pas \u00e0 pas # si l'AD5206 \u00e9tait \u00e0 sa r\u00e9sistance la plus \u00e9lev\u00e9e, puis les param\u00e8tres 'channel_x' peuvent \u00eatre # sp\u00e9cifi\u00e9s en utilisant la valeur d'intensit\u00e9 d\u00e9sir\u00e9e pour le pilote pas \u00e0 pas. La configuration # par d\u00e9faut est de ne pas mettre \u00e0 l'\u00e9chelle les param\u00e8tres 'channel_x'. [mcp4451] \u00b6 Digipot MCP4451 configur\u00e9 statiquement et connect\u00e9 via le bus I2C (on peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe \"mcp4451\"). [mcp4451 my_digipot] i2c_address: # The i2c address that the chip is using on the i2c bus. This # parameter must be provided. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #wiper_0: #wiper_1: #wiper_2: #wiper_3: # The value to statically set the given MCP4451 \"wiper\" to. This is # typically set to a number between 0.0 and 1.0 with 1.0 being the # highest resistance and 0.0 being the lowest resistance. However, # the range may be changed with the 'scale' parameter (see below). # If a wiper is not specified then it is left unconfigured. #scale: # This parameter can be used to alter how the 'wiper_x' parameters # are interpreted. If provided, then the 'wiper_x' parameters should # be between 0.0 and 'scale'. This may be useful when the MCP4451 is # used to set stepper voltage references. The 'scale' can be set to # the equivalent stepper amperage if the MCP4451 were at its highest # resistance, and then the 'wiper_x' parameters can be specified # using the desired amperage value for the stepper. The default is # to not scale the 'wiper_x' parameters. [mcp4728] \u00b6 Convertisseur num\u00e9rique-analogique MCP4728 configur\u00e9 statiquement et connect\u00e9 via le bus I2C (on peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe \"mcp4728\"). [mcp4728 my_dac] #i2c_address: 96 # The i2c address that the chip is using on the i2c bus. The default # is 96. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #channel_a: #channel_b: #channel_c: #channel_d: # The value to statically set the given MCP4728 channel to. This is # typically set to a number between 0.0 and 1.0 with 1.0 being the # highest voltage (2.048V) and 0.0 being the lowest voltage. # However, the range may be changed with the 'scale' parameter (see # below). If a channel is not specified then it is left # unconfigured. #scale: # This parameter can be used to alter how the 'channel_x' parameters # are interpreted. If provided, then the 'channel_x' parameters # should be between 0.0 and 'scale'. This may be useful when the # MCP4728 is used to set stepper voltage references. The 'scale' can # be set to the equivalent stepper amperage if the MCP4728 were at # its highest voltage (2.048V), and then the 'channel_x' parameters # can be specified using the desired amperage value for the # stepper. The default is to not scale the 'channel_x' parameters. [mcp4018] \u00b6 Digipot MCP4018 configur\u00e9 statiquement et connect\u00e9 via deux broches gpio \"bit banging\" (on peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe \"mcp4018\"). [mcp4018 my_digipot] scl_pin: # La broche d'horloge SCL. Ce param\u00e8tre doit \u00eatre fourni. sda_pin: # La broche de \"donn\u00e9es\" SDA. Ce param\u00e8tre doit \u00eatre fourni. wiper: # La valeur \u00e0 laquelle d\u00e9finir statiquement le \"wiper\" MCP4018 donn\u00e9. Ce param\u00e8tre est # g\u00e9n\u00e9ralement r\u00e9gl\u00e9e sur un nombre compris entre 0,0 et 1,0, 1,0 \u00e9tant la r\u00e9sistance # la plus \u00e9lev\u00e9e et 0.0 la r\u00e9sistance la plus faible. Cependant, la plage peut \u00eatre modifi\u00e9e \u00e0 # l'aide du param\u00e8tre 'scale' (voir ci-dessous). Ce param\u00e8tre doit \u00eatre fourni. #scale: # Ce param\u00e8tre peut \u00eatre utilis\u00e9 pour modifier l'interpr\u00e9tation du param\u00e8tre 'wiper'. # S'il est fourni, le param\u00e8tre 'wiper' doit se situer entre 0,0 et 'scale'. Ceci peut \u00eatre utile # lorsque le MCP4018 est utilis\u00e9 pour d\u00e9finir des r\u00e9f\u00e9rences de tension pas \u00e0 pas. # L''\u00e9chelle' peut \u00eatre r\u00e9gl\u00e9e sur l'intensit\u00e9 du pilote pas \u00e0 pas \u00e9quivalent si le MCP4018 # est \u00e0 sa plus grande# r\u00e9sistance la plus \u00e9lev\u00e9e, puis le param\u00e8tre 'wiper' peut \u00eatre sp\u00e9cifi\u00e9 # en utilisant la valeur d'intensit\u00e9 d\u00e9sir\u00e9e pour le pilote pas \u00e0 pas. La valeur par d\u00e9faut est # de ne pas mettre \u00e0 l'\u00e9chelle le param\u00e8tre 'wiper'. Prise en charge de l'affichage \u00b6 [display] \u00b6 Prise en charge d'un \u00e9cran reli\u00e9 au microcontr\u00f4leur. [display] lcd_type: # Le type de puce LCD utilis\u00e9. Cela peut \u00eatre \"hd44780\", \"hd44780_spi\", \"st7920\", # \"emulated_st7920\", \"uc1701\", \"ssd1306\", ou \"sh1106\". # Voir les sections d'affichage ci-dessous pour plus d'informations sur chaque type # et les param\u00e8tres suppl\u00e9mentaires qu'ils fournissent. Ce param\u00e8tre doit \u00eatre # fourni. #display_group: # Le nom du groupe de donn\u00e9es \u00e0 afficher sur l'\u00e9cran. Cela contr\u00f4le le contenu de # l'\u00e9cran (voir la section \"display_data\" pour plus d'informations). La valeur par # d\u00e9faut est _default_20x4 pour les \u00e9crans hd44780 et _default_16x4 pour les # autres affichages. #menu_timeout: # D\u00e9lai d'attente pour le menu. Le fait d'\u00eatre inactif pendant ce nombre de secondes # d\u00e9clenchera la sortie du menu ou le retour au menu racine si l'autorun est activ\u00e9. # La valeur par d\u00e9faut est 0 seconde (d\u00e9sactiv\u00e9) #menu_root: # Nom de la section du menu principal \u00e0 afficher lorsque vous cliquez sur l'encodeur # de l'\u00e9cran d'accueil. La valeur par d\u00e9faut est __main, et cela affiche les menus par # d\u00e9faut tels que d\u00e9finis dans klippy/extras/display/menu.cfg #menu_reverse_navigation: # Lorsque activ\u00e9, inverse les directions vers le haut et vers le bas de la liste. # La valeur par d\u00e9faut est False. Ce param\u00e8tre est optionnel. #encoder_pins: # Les broches connect\u00e9es \u00e0 l'encodeur. 2 broches doivent \u00eatre fournies lorsque vous # utilisez l'encodeur. Ce param\u00e8tre doit \u00eatre fourni lors de l'utilisation du menu. #encoder_steps_per_detent: # Combien de pas l'encodeur \u00e9met par cran (\"clic\"). Si l'encodeur prend deux crans pour # se d\u00e9placer entre les entr\u00e9es ou d\u00e9place deux entr\u00e9es \u00e0 partir d'un seul cran, essayez de # modifier cette valeur. Les valeurs autoris\u00e9es sont 2 (demi-step) ou 4 (full-step). # La valeur par d\u00e9faut est 4. #click_pin: # La broche connect\u00e9e au bouton 'entr\u00e9e' ou au 'clic' de l'encodeur. Ce param\u00e8tre doit # \u00eatre fourni lors de l'utilisation du menu. La pr\u00e9sence d'un param\u00e8tre de configuration # 'analog_range_click_pin' fait passer ce param\u00e8tre de num\u00e9rique \u00e0 analogique. #back_pin: # La broche connect\u00e9e au bouton 'retour'. Ce param\u00e8tre est facultatif, le menu peut \u00eatre utilis\u00e9 # sans lui. La pr\u00e9sence d'un param\u00e8tre de configuration 'analog_range_back_pin' transforme # ce param\u00e8tre de num\u00e9rique \u00e0 analogique. #up_pin: # La broche connect\u00e9e au bouton 'haut'. Ce param\u00e8tre doit \u00eatre fourni lorsque vous utilisez un # menu sans encodeur. La pr\u00e9sence d'un param\u00e8tre de configuration 'analog_range_up_pin' # transforme ce param\u00e8tre de num\u00e9rique \u00e0 analogique. #down_pin: # La broche connect\u00e9e au bouton 'bas'. Ce param\u00e8tre doit \u00eatre fourni lorsque vous utilisez un # menu sans encodeur. La pr\u00e9sence d'un param\u00e8tre de configuration 'analog_range_down_pin' # transforme ce param\u00e8tre de num\u00e9rique \u00e0 analogique. #kill_pin: # La broche connect\u00e9e au bouton 'kill'. Ce bouton appellera l'arr\u00eat d'urgence. La pr\u00e9sence d'un # param\u00e8tre 'analog_range_kill_pin' fait passer ce param\u00e8tre de num\u00e9rique \u00e0 analogique. #analog_pullup_resistor: 4700 # La r\u00e9sistance (en ohms) du pullup attach\u00e9 au bouton analogique. # La valeur par d\u00e9faut est de 4700 ohms. #analog_range_click_pin: # La plage de r\u00e9sistances du bouton 'entr\u00e9e'. Les valeurs minimale et maximale de la plage # s\u00e9par\u00e9es par des virgules doivent \u00eatre fournies lors de l'utilisation du bouton analogique. #analog_range_back_pin: # La plage de r\u00e9sistances du bouton 'retour'. Les valeurs minimale et maximale de la plage # s\u00e9par\u00e9es par des virgules doivent \u00eatre fournies lors de l'utilisation du bouton analogique. #analog_range_up_pin: # La plage de r\u00e9sistances du bouton 'haut'. Les valeurs minimale et maximale de la plage # s\u00e9par\u00e9es par des virgules doivent \u00eatre fournies lors de l'utilisation du bouton analogique. #analog_range_down_pin: # La plage de r\u00e9sistances du bouton 'bas'. Les valeurs minimale et maximale de la plage # s\u00e9par\u00e9es par des virgules doivent \u00eatre fournies lors de l'utilisation du bouton analogique. #analog_range_kill_pin: # La plage de r\u00e9sistances du bouton 'kill'. Les valeurs minimale et maximale de la plage # s\u00e9par\u00e9es par des virgules doivent \u00eatre fournies lors de l'utilisation du bouton analogique. \u00e9cran hd44780 \u00b6 Informations de configuration des \u00e9crans hd44780 (utilis\u00e9s dans les \u00e9crans de type \"RepRapDiscount 2004 Smart Controller\"). [display] lcd_type: hd44780 # D\u00e9finir \u00e0 \"hd44780\" pour les \u00e9crans hd44780. rs_pin: e_pin: d4_pin: d5_pin: d6_pin: d7_pin: # Broches connect\u00e9es \u00e0 un lcd de type hd44780. Ces param\u00e8tres doivent # \u00eatre fournis. #hd44780_protocol_init: True # Effectuer l'initialisation du protocole 8-bit/4-bit sur un \u00e9cran hd44780. # Ceci est n\u00e9cessaire sur les vrais dispositifs hd44780. Cependant, on peut avoir besoin # de le d\u00e9sactiver avec certains p\u00e9riph\u00e9riques \"clones\". La valeur par d\u00e9faut est True. #line_length: # D\u00e9finit le nombre de caract\u00e8res par ligne pour un lcd de type hd44780. # Les valeurs possibles sont 20 (par d\u00e9faut) et 16. Le nombre de lignes est # fix\u00e9 \u00e0 4. ... \u00e9cran hd44780_spi \u00b6 Informations de configuration d'un \u00e9cran hd44780_spi - un \u00e9cran 20x04 contr\u00f4l\u00e9 par un \"registre \u00e0 d\u00e9calage (shift register)\" mat\u00e9riel (utilis\u00e9 dans les imprimantes bas\u00e9es sur mightyboard). [display] lcd_type: hd44780_spi # D\u00e9finir \u00e0 \"hd44780_spi\" pour les \u00e9crans hd44780_spi. latch_pin: spi_software_sclk_pin: spi_software_mosi_pin: spi_software_miso_pin: # Broches connect\u00e9es au registre \u00e0 d\u00e9calage contr\u00f4lant l'affichage. # La broche spi_software_miso_pin doit \u00eatre d\u00e9finie sur une broche inutilis\u00e9e # de la carte m\u00e8re de l'imprimante, car le registre \u00e0 d\u00e9calage contr\u00f4lant l'affichage # n'a pas de broche MISO, mais l'impl\u00e9mentation logicielle de spi n\u00e9cessite que # cette broche soit configur\u00e9e. #hd44780_protocol_init: True # Effectue l'initialisation du protocole 8-bit/4-bit sur un \u00e9cran hd44780. # Ceci est n\u00e9cessaire sur les vrais dispositifs hd44780. Cependant, on peut avoir besoin # de le d\u00e9sactiver avec certains p\u00e9riph\u00e9riques \"clones\". La valeur par d\u00e9faut est True. #line_length: # D\u00e9finit le nombre de caract\u00e8res par ligne pour un lcd de type hd44780. # Les valeurs possibles sont 20 (par d\u00e9faut) et 16. Le nombre de lignes est # fix\u00e9 \u00e0 4. ... \u00e9cran st7920 \u00b6 Informations de configuration des \u00e9crans st7920 (utilis\u00e9s dans les \u00e9crans de type \"RepRapDiscount 12864 Full Graphic Smart Controller\"). [display] lcd_type: st7920 # D\u00e9finir \u00e0 \"st7920\" pour les \u00e9crans st7920. cs_pin: sclk_pin: sid_pin: # Les broches connect\u00e9es \u00e0 un lcd de type st7920. Ces param\u00e8tres doivent \u00eatre # fournis. ... \u00e9cran emulated_st7920 \u00b6 Informations de configuration d'un \u00e9cran st7920 \u00e9mul\u00e9 - que l'on trouve dans certains \"\u00e9crans tactiles de 2,4 pouces\" et similaires. [display] lcd_type: emulated_st7920 # D\u00e9finir \u00e0 \"emulated_st7920\" pour les \u00e9crans emulated_st7920. en_pin: spi_software_sclk_pin: spi_software_mosi_pin: spi_software_miso_pin: # Les broches connect\u00e9es \u00e0 un lcd de type emulated_st7920. L'en_pin # correspond \u00e0 la cs_pin du lcd de type st7920, # spi_software_sclk_pin correspond \u00e0 sclk_pin et # spi_software_mosi_pin correspond \u00e0 sid_pin. La broche # spi_software_miso_pin doit \u00eatre r\u00e9gl\u00e9e sur une broche non utilis\u00e9e de la carte # m\u00e8re de l'imprimante car le st7920 n'a pas de broche MISO mais l'impl\u00e9mentation # logicielle spi n\u00e9cessite que cette broche soit configur\u00e9e. ... \u00e9cran uc1701 \u00b6 Informations de configuration des \u00e9crans uc1701 (utilis\u00e9s dans les \u00e9crans de type \"MKS Mini 12864\"). [display] lcd_type: uc1701 # D\u00e9finir \u00e0 \"uc1701\" pour les \u00e9crans uc1701. cs_pin: a0_pin: # Les broches connect\u00e9es \u00e0 un lcd de type uc1701. Ces param\u00e8tres doivent \u00eatre # fournis. #rst_pin: # La broche connect\u00e9e \u00e0 la broche \"rst\" du lcd. Si elle n'est pas sp\u00e9cifi\u00e9e, # le mat\u00e9riel doit avoir un pull-up sur la ligne lcd correspondante. #contrast: # Le contraste \u00e0 d\u00e9finir. La valeur peut aller de 0 \u00e0 63 , la valeur par # d\u00e9faut est 40. ... \u00e9crans ssd1306 et sh1106 \u00b6 Les informations de configuration des \u00e9crans ssd1306 et sh1106. [display] lcd_type: # Set to either \"ssd1306\" or \"sh1106\" for the given display type. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # Optional parameters available for displays connected via an i2c # bus. See the \"common I2C settings\" section for a description of # the above parameters. #cs_pin: #dc_pin: #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # The pins connected to the lcd when in \"4-wire\" spi mode. See the # \"common SPI settings\" section for a description of the parameters # that start with \"spi_\". The default is to use i2c mode for the # display. #reset_pin: # A reset pin may be specified on the display. If it is not # specified then the hardware must have a pull-up on the # corresponding lcd line. #contrast: # The contrast to set. The value may range from 0 to 256 and the # default is 239. #vcomh: 0 # Set the Vcomh value on the display. This value is associated with # a \"smearing\" effect on some OLED displays. The value may range # from 0 to 63. Default is 0. #invert: False # TRUE inverts the pixels on certain OLED displays. The default is # False. #x_offset: 0 # Set the horizontal offset value on SH1106 displays. The default is # 0. ... [display_data] \u00b6 Support pour l'affichage de donn\u00e9es personnalis\u00e9es sur un \u00e9cran lcd. On peut cr\u00e9er un nombre quelconque de groupes d'affichage et un nombre quelconque d'\u00e9l\u00e9ments de donn\u00e9es sous ces groupes. L'\u00e9cran affichera tous les \u00e9l\u00e9ments de donn\u00e9es d'un groupe donn\u00e9 si l'option display_group de la section [display] est d\u00e9finie sur le nom du groupe en question. Un ensemble par d\u00e9faut de groupes d'affichage est automatiquement cr\u00e9\u00e9. On peut remplacer ou \u00e9tendre ces \u00e9l\u00e9ments display_data en rempla\u00e7ant les valeurs par d\u00e9faut dans le fichier de configuration principal printer.cfg. [display_data my_group_name my_data_name] position: # Ligne et colonne s\u00e9par\u00e9es par des virgules de la position de l'affichage \u00e0 # utiliser pour afficher l'information. Ce param\u00e8tre doit \u00eatre fourni. text: # Le texte \u00e0 afficher \u00e0 la position donn\u00e9e. Ce champ est \u00e9valu\u00e9 en utilisant les # mod\u00e8les de commande (voir docs/Command_Templates.md). # Ce param\u00e8tre doit \u00eatre fourni. [display_template] \u00b6 Les \"macros\" de texte des donn\u00e9es d'affichage (on peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe display_template). Voir le document mod\u00e8les de commande pour des informations sur l'\u00e9valuation des mod\u00e8les. Cette fonctionnalit\u00e9 permet de r\u00e9duire les d\u00e9finitions r\u00e9p\u00e9titives dans les sections display_data. On peut utiliser la fonction int\u00e9gr\u00e9e render() dans les sections display_data pour \u00e9valuer un mod\u00e8le. Par exemple, si l'on d\u00e9finit \"[display_template my_template] \", on peut alors utiliser \"{ render('my_template') } dans une section display_data. Cette fonctionnalit\u00e9 peut \u00e9galement \u00eatre utilis\u00e9e pour des mises \u00e0 jour continues des LEDs \u00e0 l'aide de la commande SET_LED_TEMPLATE . [display_template my_template_name] #param_<name>: # On peut sp\u00e9cifier un nombre quelconque d'options avec le pr\u00e9fixe \"param_\". Le nom # donn\u00e9 se verra attribuer la valeur donn\u00e9e (analys\u00e9e comme un litt\u00e9ral Python) et # sera disponible pendant l'expansion de la macro. Si le param\u00e8tre est pass\u00e9 dans # l'appel \u00e0 render(), alors cette valeur sera utilis\u00e9e pendant l'expansion de la macro. # Par exemple, une configuration avec \"param_speed = 75\" pourrait avoir un appelant # avec \"render('my_template_name', param_speed=80)\". Les noms de param\u00e8tres # peuvent ne pas utiliser de caract\u00e8res majuscules. text: # Le texte \u00e0 renvoyer lors du rendu de ce mod\u00e8le. Ce champ est \u00e9valu\u00e9 \u00e0 l'aide de # mod\u00e8les de commande (voir docs/Command_Templates.md). # Ce param\u00e8tre doit \u00eatre fourni. [display_glyph] \u00b6 Affiche un glyphe personnalis\u00e9 sur les \u00e9crans le supportant. Le nom donn\u00e9 se verra attribu\u00e9 les donn\u00e9es d'affichage, donn\u00e9es qui pourront ensuite \u00eatre r\u00e9f\u00e9renc\u00e9es dans les mod\u00e8les d'affichage par leur nom entour\u00e9 de deux symboles \"tilde\", par exemple ~my_display_glyph~ Voir sample-glyphs.cfg pour quelques exemples. [display_glyph my_display_glyph] #data: # Les donn\u00e9es d'affichage, stock\u00e9es sous forme de 16 lignes compos\u00e9es de 16 bits (1 par # pixel) o\u00f9 '.' est un pixel vide et '*' est un pixel actif (par ex, \"****************\" pour afficher # une ligne horizontale pleine). # On peut \u00e9galement utiliser '0' pour un pixel vide et '1' pour un pixel actif. # Placez chaque ligne d'affichage sur une ligne de configuration distincte. Le glyphe doit \u00eatre # compos\u00e9 d'exactement 16 lignes de 16 bits chacune. Ce param\u00e8tre est facultatif. #hd44780_data: # Glyphe \u00e0 utiliser sur les \u00e9crans 20x4 hd44780. Le glyphe doit \u00eatre compos\u00e9 d'exactement # 8 lignes de 5 bits chacune. Ce param\u00e8tre est facultatif. #hd44780_slot: # L'index mat\u00e9riel hd44780 (0..7) pour stocker le glyphe. Si plusieurs images distinctes # utilisent le m\u00eame slot, assurez-vous de n'utiliser qu'une seule de ces images dans un # \u00e9cran donn\u00e9. Ce param\u00e8tre est requis si hd44780_data est sp\u00e9cifi\u00e9. [display my_extra_display] \u00b6 Si une section principale [display] a \u00e9t\u00e9 d\u00e9finie dans printer.cfg comme indiqu\u00e9 ci-dessus, il est possible de d\u00e9finir plusieurs affichages auxiliaires. Notez que les affichages auxiliaires ne supportent pas actuellement la fonctionnalit\u00e9 de menus, ils ne supportent donc pas les options \"menu\" ou la configuration de boutons. [display my_extra_display] # Voir la section \"affichage\" (display) pour les param\u00e8tres disponibles. [menu] \u00b6 Menus de l'\u00e9cran LCD personnalisables. Un ensemble de menus par d\u00e9faut est automatiquement cr\u00e9\u00e9. On peut remplacer ou \u00e9tendre le menu en rempla\u00e7ant les valeurs par d\u00e9faut dans le fichier de configuration principal printer.cfg. Consultez le document sur les mod\u00e8les de commande pour obtenir des informations sur les attributs de menu disponibles lors du rendu du mod\u00e8le. # Param\u00e8tres communs disponibles pour toutes les sections de configuration de menu. #[menu __some_list __some_name] #type: disabled # \u00c9l\u00e9ment de menu d\u00e9sactiv\u00e9 de fa\u00e7on permanente, le seul attribut requis est 'type'. # Vous permet de d\u00e9sactiver/masquer facilement des \u00e9l\u00e9ments de menu existants. #[menu some_name] #type: # Un \u00e9l\u00e9ment parmi command, input, list, text : # command - \u00e9l\u00e9ment de menu de base avec divers d\u00e9clencheurs de script. # input - m\u00eame chose que 'command' mais avec des capacit\u00e9s de changement de valeur. # Pressez pour d\u00e9marrer/arr\u00eater le mode d'\u00e9dition. # list - permet de regrouper les \u00e9l\u00e9ments du menu dans une liste d\u00e9roulante. # Ajoutez \u00e0 la liste en cr\u00e9ant des configurations de menu en utilisant # \"some_list\" comme pr\u00e9fixe - par exemple : # [menu some_list some_item_in_the_list]. # vsdlist - identique \u00e0 'list' mais ajoutera les fichiers de la carte SD virtuelle # (sera supprim\u00e9 dans le futur) #name: # Nom de l'\u00e9l\u00e9ment de menu - \u00e9valu\u00e9 comme un mod\u00e8le. #enable: # Mod\u00e8le \u00e9valu\u00e9 \u00e0 True ou False. #index: # Position o\u00f9 l'\u00e9l\u00e9ment doit \u00eatre ins\u00e9r\u00e9 dans la liste. Par d\u00e9faut # l'\u00e9l\u00e9ment est ajout\u00e9 \u00e0 la fin. #[menu some_list] #type: list #name: #enable: # Voir ci-dessus pour une description de ces param\u00e8tres. #[menu some_list some_command] #type: command #name: #enable: # Voir ci-dessus pour une description de ces param\u00e8tres. #gcode: # Script \u00e0 ex\u00e9cuter lors d'un clic sur un bouton ou un clic long. \u00c9valu\u00e9 comme un # mod\u00e8le. #[menu some_list some_input] #type: input #name: #enable: # Voir ci-dessus pour une description de ces param\u00e8tres. #input: # Valeur initiale \u00e0 utiliser lors de l'\u00e9dition - \u00e9valu\u00e9e comme un mod\u00e8le. # Le r\u00e9sultat doit \u00eatre de type flottant. #input_min: # Valeur minimale de l''intervalle - \u00e9valu\u00e9e comme un mod\u00e8le. Par d\u00e9faut -99999. #input_max: # Valeur maximale de l'intervalle - \u00e9valu\u00e9e comme un mod\u00e8le. Par d\u00e9faut 99999. #input_step: # Pas d'\u00e9dition - Doit \u00eatre un nombre entier positif ou une valeur flottante. Poss\u00e8de # un pas de vitesse rapide interne. Lorsque \"(input_max - input_min) / input_step > 100\" # alors le pas de vitesse rapide est 10 * input_step sinon le pas de vitesse rapide # est le m\u00eame que celui de l'input_step. #realtime: # Cet attribut accepte une valeur bool\u00e9enne statique. Lorsqu'il est activ\u00e9, alors le script # gcode est ex\u00e9cut\u00e9 apr\u00e8s chaque changement de valeur. La valeur par d\u00e9faut est False. #gcode: # Script \u00e0 ex\u00e9cuter lors d'un clic sur un bouton, d'un clic long ou d'un changement de valeur. # \u00c9valu\u00e9 comme un mod\u00e8le. Le clic sur le bouton d\u00e9clenchera le d\u00e9but ou fin du mode d'\u00e9dition. Capteurs de filaments \u00b6 [filament_switch_sensor] \u00b6 Capteur de commutation de filament. Prise en charge de la d\u00e9tection de l'insertion et du d\u00e9placement du filament \u00e0 l'aide d'un capteur de commutation, tel qu'un interrupteur de fin de course. Voir la r\u00e9f\u00e9rence des commandes pour plus d'informations. [filament_switch_sensor my_sensor] #pause_on_runout: True # Lorsque d\u00e9fini sur True, une PAUSE sera ex\u00e9cut\u00e9e imm\u00e9diatement apr\u00e8s qu'un runout # soit d\u00e9tect\u00e9. Notez que si pause_on_runout est False et que le runout_gcode est omis, # la d\u00e9tection du runout est d\u00e9sactiv\u00e9e. Par d\u00e9faut, est True. #runout_gcode: # Une liste de commandes G-Code \u00e0 ex\u00e9cuter apr\u00e8s la d\u00e9tection d'une fin de filament. # Voir docs/Command_Templates.md pour le format G-Code. Si pause_on_runout est # r\u00e9gl\u00e9 sur True, ce G-code sera ex\u00e9cut\u00e9 apr\u00e8s la fin de la PAUSE. Par d\u00e9faut, aucune # commande G-Code n'est ex\u00e9cut\u00e9e. #insert_gcode: # Une liste de commandes G-Code \u00e0 ex\u00e9cuter apr\u00e8s qu'une insertion de filament soit d\u00e9tect\u00e9e. # Voir docs/Command_Templates.md pour le format G-Code. La valeur par d\u00e9faut est de # n'ex\u00e9cuter aucune commande G-Code, ce qui d\u00e9sactive la d\u00e9tection de l'insertion. #event_delay 3.0 # La dur\u00e9e minimale en secondes \u00e0 attendre entre les \u00e9v\u00e9nements. # Des \u00e9v\u00e9nements d\u00e9clench\u00e9s durant cette p\u00e9riode seront silencieusement ignor\u00e9s. # La valeur par d\u00e9faut est de 3 secondes. #pause_delay: 0.5 # Le d\u00e9lai, en secondes, entre l'envoi de la commande de pause et l'ex\u00e9cution du runout_gcode. # Il peut \u00eatre utile d'augmenter ce d\u00e9lai si OctoPrint pr\u00e9sente un comportement \u00e9trange lors de # la pause. La valeur par d\u00e9faut est 0.5 secondes. #switch_pin: # La broche sur laquelle l'interrupteur est connect\u00e9. # Ce param\u00e8tre doit \u00eatre fourni. [filament_motion_sensor] \u00b6 Capteur de mouvement de filament. Prise en charge de la d\u00e9tection de pr\u00e9sence et d\u00e9placement du filament \u00e0 l'aide d'un encodeur basculant la broche de sortie pendant le mouvement du filament dans le capteur. Voir la r\u00e9f\u00e9rence des commandes pour plus d'informations. [filament_motion_sensor my_sensor] detection_length: 7.0 # La longueur minimale du filament tir\u00e9 \u00e0 travers le capteur d\u00e9clenchant # un changement d'\u00e9tat sur la broche de commutation. # La valeur par d\u00e9faut est 7 mm. extruder: # Le nom de la section de l'extrudeuse \u00e0 laquelle ce capteur est associ\u00e9. # Ce param\u00e8tre doit \u00eatre fourni. switch_pin: #pause_on_runout: #runout_gcode: #insert_gcode: #event_delay: #pause_delay: # Voir la section \"filament_switch_sensor\" pour une description des # param\u00e8tres ci-dessus. [tsl1401cl_filament_width_sensor] \u00b6 Capteur de largeur de filament bas\u00e9 sur le TSLl401CL. Voir ce guide pour plus d'informations. [tsl1401cl_filament_width_sensor] #pin: #default_nominal_filament_diameter: 1.75 # (mm) # Diff\u00e9rence maximale de diam\u00e8tre de filament autoris\u00e9e en mm. #max_diff\u00e9rence: 0.2 # La distance entre le capteur et la chambre de fusion en mm. #measurement_delay: 100 [hall_filament_width_sensor] \u00b6 Capteur Hall de largeur de filament (voir Capteur Hall de largeur de filament ). [hall_filament_width_sensor] adc1: adc2: # Broches d'entr\u00e9e analogiques connect\u00e9es au capteur. Ces param\u00e8tres doivent # \u00eatre fournis. #cal_dia1: 1.50 #cal_dia2: 2.00 # Les valeurs d'\u00e9talonnage (en mm) pour les capteurs. La valeur par d\u00e9faut est # 1,50 pour cal_dia1 et 2,00 pour cal_dia2. #raw_dia1: 9500 #raw_dia2: 10500 # Les valeurs brutes d'\u00e9talonnage des capteurs. La valeur par d\u00e9faut est 9500 # pour raw_dia1 et 10500 pour raw_dia2. #default_nominal_filament_diameter: 1.75 # Le diam\u00e8tre nominal du filament. Ce param\u00e8tre doit \u00eatre fourni. #max_difference: 0.200 # Diff\u00e9rence maximale autoris\u00e9e de diam\u00e8tre du filament en millim\u00e8tres (mm). # Si la diff\u00e9rence entre le diam\u00e8tre nominal du filament et la sortie du capteur # est sup\u00e9rieure \u00e0 +- max_difference, le multiplicateur d'extrusion est ramen\u00e9 \u00e0 # \u00e0 %100. La valeur par d\u00e9faut est de 0,200. #measurement_delay: 70 # La distance entre le capteur et la chambre de fusion/la buse en # millim\u00e8tres (mm). Le filament situ\u00e9 entre le capteur et la buse # sera trait\u00e9 comme le default_nominal_filament_diameter. # Ce module h\u00f4te fonctionne avec une logique FIFO. Il conserve chaque valeur # de capteur dans un tableau et les remet (POP) dans la bonne position. Ce # param\u00e8tre doit \u00eatre fourni. #enable: False # Capteur activ\u00e9 ou d\u00e9sactiv\u00e9 apr\u00e8s la mise sous tension. La valeur par d\u00e9faut est # d\u00e9sactiv\u00e9. #measurement_interval: 10 # La distance approximative (en mm) entre les lectures du capteur. La valeur # par d\u00e9faut est de 10mm. #logging: False # Le diam\u00e8tre de sortie vers le terminal et vers klipper.log peut \u00eatre activ\u00e9 par # ce param\u00e8tre. #min_diameter: 1.0 # Diam\u00e8tre minimal pour d\u00e9clencher le capteur virtuel filament_switch_sensor. #use_current_dia_while_delay: False # Utiliser le diam\u00e8tre actuel au lieu du diam\u00e8tre nominal pendant que le d\u00e9lai # de mesure n'est pas \u00e9coul\u00e9. #pause_on_runout: #runout_gcode: #insert_gcode: #event_delay: #pause_delay: # Voir la section \"filament_switch_sensor\" pour une description des # param\u00e8tres ci-dessus. Support mat\u00e9riel sp\u00e9cifique \u00e0 une carte \u00b6 [sx1509] \u00b6 Configuration d'un expandeur SX1509 I2C vers GPIO. En raison du d\u00e9lai encouru par la communication I2C, vous ne devez PAS utiliser les broches du SX1509 comme activation du moteur pas \u00e0 pas, pas ou direction ou toute autre broche n\u00e9cessitant un changement de bit rapide. Il est pr\u00e9f\u00e9rable de les utiliser comme sorties num\u00e9riques statiques ou contr\u00f4l\u00e9es par gcode ou comme broches hardware-pwm pour des ventilateurs par exemple. On peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe \"sx1509\". Chaque expandeur fournit un ensemble de 16 broches (sx1509_my_sx1509:PIN_0 \u00e0 sx1509_my_sx1509:PIN_15) pouvant \u00eatre utilis\u00e9es dans la configuration de l'imprimante. Voir le fichier generic-duet2-duex.cfg pour un exemple. [sx1509 my_sx1509] i2c_address: # I2C address used by this expander. Depending on the hardware # jumpers this is one out of the following addresses: 62 63 112 # 113. This parameter must be provided. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. [samd_sercom] \u00b6 Configuration de SAMD SERCOM pour indiquer les broches \u00e0 utiliser sur un mat\u00e9riel SERCOM. On peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"samd_sercom\". Chaque SERCOM doit \u00eatre configur\u00e9 avant de pouvoir \u00eatre utilis\u00e9 comme p\u00e9riph\u00e9rique SPI ou I2C. Placez cette section de configuration au-dessus de toute autre section qui utilise les bus SPI ou I2C. [samd_sercom my_sercom] sercom: # Le nom du bus sercom \u00e0 configurer dans le micro-contr\u00f4leur. # Les noms disponibles sont \"sercom0\", \"sercom1\", etc. # Ce param\u00e8tredoit \u00eatre fourni. tx_pin: # Broche MOSI pour la communication SPI, ou broche SDA (donn\u00e9es) pour la communication I2C. # La broche doit avoir une configuration pinmux valide pour le p\u00e9riph\u00e9rique SERCOM donn\u00e9. # Ce param\u00e8tre doit \u00eatre fourni. #rx_pin: # Broche MISO pour la communication SPI. Cette broche n'est pas utilis\u00e9e pour la communication I2C # (I2C utilise tx_pin pour l'envoi et la r\u00e9ception). # La broche doit avoir une configuration pinmux valide pour le p\u00e9riph\u00e9rique SERCOM donn\u00e9. # Ce param\u00e8tre est optionnel. clk_pin: # La broche CLK pour la communication SPI, ou la broche SCL (horloge) pour la communication I2C. # La broche doit avoir une configuration pinmux valide pour le p\u00e9riph\u00e9rique SERCOM donn\u00e9. # Ce param\u00e8tre doit \u00eatre fourni [adc_scaled] \u00b6 Mise \u00e0 l'\u00e9chelle analogique du Duet2 Maestro par lectures vref et vssa. D\u00e9finir une section adc_scaled permet d'activer des broches adc virtuelles (telles que \"my_name:PB0\") qui seront automatiquement ajust\u00e9es par les broches de surveillance vref et vssa de la carte. Assurez-vous de d\u00e9finir cette section de configuration au-dessus de toute section de configuration utilisant l'une de ces broches virtuelles. Voir le fichier generic-duet2-maestro.cfg pour un exemple. [adc_scaled my_name] vref_pin : # La broche ADC \u00e0 utiliser pour le contr\u00f4le de VREF. Ce param\u00e8tre doit \u00eatre # fourni. vssa_pin : # La broche ADC \u00e0 utiliser pour la surveillance VSSA. Ce param\u00e8tre doit \u00eatre # fourni. #smooth_time : 2.0 # Une dur\u00e9e (en secondes) durant laquelle les mesures de vref et vssa # seront liss\u00e9es pour r\u00e9duire l'impact du bruit des mesures. # La valeur par d\u00e9faut est de 2 secondes. [replicape] \u00b6 Support de Replicape - voir le guide beaglebone et le fichier generic-replicape.cfg pour un exemple. # La section de configuration \"replicape\" ajoute \"replicape:stepper_x_enable\" pour # l'activation de broches virtuelles de moteur (pour les moteurs X, Y, Z, E et H) et # \"replicape:power_x\" des broches de sortie PWM (pour les pilotes, e, h, fan0, fan1, # fan2, et fan3) utilisables ailleurs dans le fichier de configuration. [replicape] revision: # La r\u00e9vision du mat\u00e9riel replicape. Actuellement, seule la r\u00e9vision \"B3\" est # support\u00e9e. Ce param\u00e8tre doit \u00eatre fourni. #enable_pin: !gpio0_20 # La broche d'activation globale de la replicape. La valeur par d\u00e9faut est !gpio0_20 # (aka P9_41). host_mcu : # Le nom de la section de configuration mcu communiquant avec la section de # l'instance mcu du \"processus linux\" de Klipper. Ce param\u00e8tre doit \u00eatre # fourni. #standstill_power_down: False # Ce param\u00e8tre contr\u00f4le la ligne CFG6_ENN sur tous les moteurs pas \u00e0 pas. # True r\u00e8gle les lignes d'activation sur \"ouvert\". La valeur par d\u00e9faut est # False. #stepper_x_microstep_mode: #stepper_y_microstep_mode: #stepper_z_microstep_mode: #stepper_e_microstep_mode: #stepper_h_microstep_mode: # Ce param\u00e8tre contr\u00f4le les broches CFG1 et CFG2 du pilote de moteur donn\u00e9. # Les options disponibles sont : disable, 1, 2, spread2, 4, 16, spread4, spread16, # stealth4, et stealth16. La valeur par d\u00e9faut est disable. #stepper_x_current: #stepper_y_current: #stepper_z_current: #stepper_e_current: #stepper_h_current: # Le courant maximum configur\u00e9 (en Amp\u00e8res) du moteur pas \u00e0 pas. # Ce param\u00e8tre doit \u00eatre fourni si le moteur pas \u00e0 pas n'est pas dans un # mode d\u00e9sactiv\u00e9. #stepper_x_chopper_off_time_high: #stepper_y_chopper_off_time_high: #stepper_z_chopper_off_time_high: #stepper_e_chopper_off_time_high: #stepper_h_chopper_off_time_high: # Ce param\u00e8tre contr\u00f4le la broche CFG0 du pilote du moteur pas \u00e0 pas. # (True place CFG0 en haut, False le place en bas). La valeur par d\u00e9faut est False. #stepper_x_chopper_hysteresis_high: #stepper_y_chopper_hysteresis_high: #stepper_z_chopper_hysteresis_high: #stepper_e_chopper_hysteresis_high: #stepper_h_chopper_hysteresis_high: # Ce param\u00e8tre contr\u00f4le la broche CFG4 du pilote du moteur pas \u00e0 pas. # (True place CFG4 en haut, False le place en bas). La valeur par d\u00e9faut est False. #stepper_x_chopper_blank_time_high: #stepper_y_chopper_blank_time_high: #stepper_z_chopper_blank_time_high: #stepper_e_chopper_blank_time_high: #stepper_h_chopper_blank_time_high: # Ce param\u00e8tre contr\u00f4le la broche CFG5 du pilote du moteur pas \u00e0 pas. # (True place CFG5 en haut, False le place en bas). La valeur par d\u00e9faut est True. Autres modules sp\u00e9cifiques \u00b6 [palette2] \u00b6 Prise en charge des multimat\u00e9riaux de la Palette 2 - assure une int\u00e9gration plus \u00e9troite de la prise en charge des p\u00e9riph\u00e9riques de la Palette 2 en mode connect\u00e9. Ce module n\u00e9cessite \u00e9galement [virtual_sdcard] et [pause_resume] pour une fonctionnalit\u00e9 compl\u00e8te. Si vous utilisez ce module, n'utilisez pas le plugin Palette 2 pour Octoprint car ils entreront en conflit, et le module ne pourra pas s'initialiser correctement, ce qui fera \u00e9chouer votre impression. Si vous utilisez Octoprint et que vous diffusez du gcode sur le port s\u00e9rie au lieu d'imprimer \u00e0 partir de virtual_sd, alors supprimez M1 et M0 de Commandes de pause dans Param\u00e8tres > Connexion s\u00e9rie > Firmware & protocole \u00e9vitera d'avoir \u00e0 lancer l'impression sur la Palette 2 et de devoir lever la pause dans Octoprint pour que l'impression commence. [palette2] serial: # Le port s\u00e9rie \u00e0 connecter \u00e0 la Palette 2. #baud: 115200 # Le d\u00e9bit en bauds \u00e0 utiliser. La valeur par d\u00e9faut est 115200. #feedrate_splice: 0.8 # La vitesse d'avance \u00e0 utiliser lors de l'\u00e9pissage, la valeur par d\u00e9faut est 0,8 #feedrate_normal: 1.0 # La vitesse d'avance \u00e0 utiliser apr\u00e8s le raccordement, la valeur par d\u00e9faut est 1.0 #auto_load_speed: 2 # Vitesse d'avance d'extrusion lors du chargement automatique, la valeur par d\u00e9faut est 2 (mm/s) #auto_cancel_variation: 0.1 # Annulation automatique de l'impression lorsque la variation du ping est sup\u00e9rieure \u00e0 ce seuil [angle] \u00b6 Prise en charge du capteur d'angle Hall magn\u00e9tique pour la lecture des mesures de l'angle de l'arbre du moteur pas \u00e0 pas \u00e0 l'aide des puces SPI a1333, as5047d ou tle5012b. Les mesures sont disponibles via le serveur API et l' outil d'analyse de mouvement . Voir la r\u00e9f\u00e9rence G-Code pour les commandes disponibles. [angle my_angle_sensor] sensor_type: # Le type de la puce du capteur magn\u00e9tique \u00e0 effet Hall. Les choix disponibles # sont \"a1333\", \"as5047d\" et \"tle5012b\". Ce param\u00e8tre doit \u00eatre sp\u00e9cifi\u00e9. #sample_period: 0.000400 # La p\u00e9riode de requ\u00eate (en secondes) \u00e0 utiliser lors des mesures. La valeur par # d\u00e9faut est de 0.000400 (ce qui correspond \u00e0 2500 \u00e9chantillons par seconde). #stepper: # Le nom du pilote moteur pas \u00e0 pas auquel le capteur d'angle est attach\u00e9 (ex, # \"stepper_x\"). La d\u00e9finition de cette valeur active un \u00e9talonnage d'angle. # Pour utiliser cette fonction, le paquet Python \"numpy\" doit \u00eatre install\u00e9. # Par d\u00e9faut, l'\u00e9talonnage d'angle n'est pas activ\u00e9 pour un capteur d'angle. cs_pin: # La broche d'activation SPI du capteur. Ce param\u00e8tre doit \u00eatre fourni. #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # Voir la section \"param\u00e8tres SPI communs\" pour une description des # param\u00e8tres ci-dessus. Param\u00e8tres communs aux bus \u00b6 Param\u00e8tres SPI communs \u00b6 Les param\u00e8tres suivants sont g\u00e9n\u00e9ralement disponibles pour les dispositifs utilisant un bus SPI. #spi_speed: # La vitesse SPI (en hz) \u00e0 utiliser lors de la communication avec le p\u00e9riph\u00e9rique. # La valeur par d\u00e9faut d\u00e9pend du type de p\u00e9riph\u00e9rique. #spi_bus: # Si le micro-contr\u00f4leur supporte plusieurs bus SPI alors on peut sp\u00e9cifier le nom # du bus du micro-contr\u00f4leur ici. La valeur par d\u00e9faut d\u00e9pend du type de # micro-contr\u00f4leur. #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # Sp\u00e9cifiez les param\u00e8tres ci-dessus pour utiliser le \"SPI logiciel\". Ce mode ne # n\u00e9cessite pas le support mat\u00e9riel du micro-contr\u00f4leur (typiquement n'importe # quelle broche d'usage g\u00e9n\u00e9ral peut \u00eatre utilis\u00e9e). La valeur par d\u00e9faut est de # ne pas utiliser le \"spi logiciel\". Param\u00e8tres I2C communs \u00b6 Les param\u00e8tres suivants sont g\u00e9n\u00e9ralement disponibles pour les dispositifs utilisant un bus I2C. La prise en charge actuelle du microcontr\u00f4leur de Klipper pour I2C n'est g\u00e9n\u00e9ralement pas tol\u00e9rante au bruit de ligne. Des erreurs inattendues sur les fils I2C peuvent amener Klipper \u00e0 g\u00e9n\u00e9rer une erreur d'ex\u00e9cution. La prise en charge de Klipper pour la r\u00e9cup\u00e9ration d'erreur varie selon chaque type de microcontr\u00f4leur. Il est g\u00e9n\u00e9ralement recommand\u00e9 de n'utiliser que des appareils I2C qui se trouvent sur la m\u00eame carte de circuit imprim\u00e9 que le microcontr\u00f4leur. La plupart des impl\u00e9mentations de microcontr\u00f4leurs Klipper ne prennent en charge qu'une i2c_speed de 100000 ( mode standard , 100kbit/s). Le micro-contr\u00f4leur Klipper \"Linux\" supporte une vitesse de 400000 ( fast mode , 400kbit/s), mais il doit \u00eatre d\u00e9fini dans le syst\u00e8me d'exploitation sinon le param\u00e8tre i2c_speed sera ignor\u00e9. Le microcontr\u00f4leur Klipper \"RP2040\" et la famille ATmega AVR supportent un taux de 400000 via le param\u00e8tre i2c_speed . Tous les autres microcontr\u00f4leurs Klipper utilisent un taux de 100000 et ignorent le param\u00e8tre i2c_speed . #i2c_address: # The i2c address of the device. This must specified as a decimal # number (not in hex). The default depends on the type of device. #i2c_mcu: # The name of the micro-controller that the chip is connected to. # The default is \"mcu\". #i2c_bus: # If the micro-controller supports multiple I2C busses then one may # specify the micro-controller bus name here. The default depends on # the type of micro-controller. #i2c_software_scl_pin: #i2c_software_sda_pin: # Specify these parameters to use micro-controller software based # I2C \"bit-banging\" support. The two parameters should the two pins # on the micro-controller to use for the scl and sda wires. The # default is to use hardware based I2C support as specified by the # i2c_bus parameter. #i2c_speed: # The I2C speed (in Hz) to use when communicating with the device. # The Klipper implementation on most micro-controllers is hard-coded # to 100000 and changing this value has no effect. The default is # 100000. Linux, RP2040 and ATmega support 400000.","title":"R\u00e9f\u00e9rence de configuration"},{"location":"Config_Reference.html#reference-de-configuration","text":"Ce document est la r\u00e9f\u00e9rence des options disponibles dans le fichier de configuration de Klipper. Les descriptions de ce document sont format\u00e9es de mani\u00e8re \u00e0 ce qu'il soit possible de les copier-coller dans un fichier de configuration d'imprimante. Consultez le document d'installation pour obtenir des informations sur la configuration de Klipper et le choix d'un fichier de configuration initial.","title":"R\u00e9f\u00e9rence de configuration"},{"location":"Config_Reference.html#configuration-du-microcontroleur","text":"","title":"Configuration du microcontr\u00f4leur"},{"location":"Config_Reference.html#format-du-nom-des-broches-du-microcontroleur","text":"De nombreuses options de configuration n\u00e9cessitent le nom d'une broche du micro-contr\u00f4leur. Klipper utilise les noms mat\u00e9riel pour ces broches - par exemple PA4 . Les noms des broches peuvent \u00eatre pr\u00e9c\u00e9d\u00e9s de ! pour indiquer qu'une polarit\u00e9 inverse doit \u00eatre utilis\u00e9e (par exemple, d\u00e9clencher sur le niveau bas au lieu du niveau haut). Les broches d'entr\u00e9e peuvent \u00eatre pr\u00e9c\u00e9d\u00e9es de ^ pour indiquer qu'une r\u00e9sistance pull-up mat\u00e9rielle doit \u00eatre activ\u00e9e pour cette broche. Si le micro-contr\u00f4leur supporte les r\u00e9sistances pull-down, une broche d'entr\u00e9e peut \u00e9galement \u00eatre pr\u00e9c\u00e9d\u00e9e de ~ . Notez que certaines sections de configuration peuvent \"cr\u00e9er\" des broches suppl\u00e9mentaires. Lorsque cela se produit, la section de configuration d\u00e9finissant ces broches doit \u00eatre r\u00e9pertori\u00e9e dans le fichier de configuration avant toute section utilisant celles-ci.","title":"Format du nom des broches du microcontr\u00f4leur"},{"location":"Config_Reference.html#mcu","text":"Configuration du microcontr\u00f4leur primaire. [mcu] serial: # Le port s\u00e9rie \u00e0 connecter \u00e0 l'unit\u00e9 MCU. Si vous n'\u00eates pas s\u00fbr (ou s'il # change) consultez la section \"O\u00f9 est mon port s\u00e9rie ?\" de la FAQ. # Ce param\u00e8tre doit \u00eatre fourni lors de l'utilisation d'un port s\u00e9rie. #baud: 250000 # Le d\u00e9bit en bauds \u00e0 utiliser. La valeur par d\u00e9faut est 250000. #canbus_uuid: # Si vous utilisez un dispositif connect\u00e9 \u00e0 un bus CAN, ceci d\u00e9finit l'identifiant # unique de la puce \u00e0 laquelle se connecter. Cette valeur doit \u00eatre fournie lorsque l'on utilise # le bus CAN pour la communication. #canbus_interface: # Si vous utilisez un dispositif connect\u00e9 \u00e0 un bus CAN, ceci d\u00e9finit l'interface r\u00e9seau CAN # \u00e0 utiliser. La valeur par d\u00e9faut est 'can0'. #restart_method: # Ceci contr\u00f4le le m\u00e9canisme que l'h\u00f4te utilisera pour r\u00e9initialiser le microcontr\u00f4leur. # Les choix sont 'arduino', 'cheetah', 'rpi_usb', et 'command'. La m\u00e9thode 'arduino' # (basculer DTR) est courante sur les cartes et clones Arduino. # La m\u00e9thode 'cheetah' est une m\u00e9thode particuli\u00e8re n\u00e9cessaire pour certaines cartes # Fysetc Cheetah. La m\u00e9thode 'rpi_usb' est utile sur les cartes Raspberry Pi avec des # micro-contr\u00f4leurs aliment\u00e9s par USB - elle d\u00e9sactive bri\u00e8vement l'alimentation de tous # les ports USB pour effectuer une r\u00e9initialisation du microcontr\u00f4leur. # La m\u00e9thode 'command' implique l'envoi d'une commande Klipper au microcontr\u00f4leur # afin qu'il puisse # se r\u00e9initialiser. # La valeur par d\u00e9faut est 'arduino' si le micro-contr\u00f4leur communique via un port s\u00e9rie, # 'command' sinon.","title":"[mcu|"},{"location":"Config_Reference.html#mcu-my_extra_mcu","text":"Microcontr\u00f4leurs suppl\u00e9mentaires (on peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe \"mcu\"). Les microcontr\u00f4leurs suppl\u00e9mentaires introduisent des broches additionnelles pouvant \u00eatre configur\u00e9es comme des \u00e9l\u00e9ments de chauffage, des pilotes moteurs, des ventilateurs, etc. Par exemple, si une section \"[mcu extra_mcu]\" est ajout\u00e9e, des broches telles que \"extra_mcu:ar9\" pourront \u00eatre utilis\u00e9es ailleurs dans la configuration (o\u00f9 \"ar9\" est un nom de broche mat\u00e9rielle ou un nom d'alias sur le mcu donn\u00e9). [mcu my_extra_mcu] # Voir la section \"mcu\" pour les param\u00e8tres de configuration.","title":"[mcu my_extra_mcu]"},{"location":"Config_Reference.html#parametres-cinematiques-courants","text":"","title":"Param\u00e8tres cin\u00e9matiques courants"},{"location":"Config_Reference.html#printer","text":"La section imprimante contr\u00f4le les param\u00e8tres de haut niveau de l'imprimante. [printer] kinematics: # Le type d'imprimante utilis\u00e9e. Cette option peut \u00eatre l'une des suivantes : cart\u00e9sienne, # corexy, corexz, hybrid_corexy, hybrid_corexz, rotary_delta, delta, deltesian, polar, winch, # ou none. Ce param\u00e8tre doit \u00eatre sp\u00e9cifi\u00e9. max_velocity: # Vitesse maximale (en mm/s) de la t\u00eate d'outil (par rapport \u00e0 l'impression). # Ce param\u00e8tre doit \u00eatre sp\u00e9cifi\u00e9. max_accel: # Acc\u00e9l\u00e9ration maximale (en mm/s^2) de la t\u00eate de l'outil (par rapport \u00e0 l'impression). # Ce param\u00e8tre doit \u00eatre sp\u00e9cifi\u00e9. #max_accel_to_decel: # Une pseudo-acc\u00e9l\u00e9ration (en mm/s^2) contr\u00f4lant la vitesse \u00e0 laquelle la t\u00eate de l'outil peut # passer de l'acc\u00e9l\u00e9ration \u00e0 la d\u00e9c\u00e9l\u00e9ration. Elle est utilis\u00e9e pour r\u00e9duire la vitesse maximale # des courts mouvements en zigzag (et donc r\u00e9duire les vibrations de l'imprimante dues \u00e0 ces # mouvements). La valeur par d\u00e9faut est la moiti\u00e9 de max_accel. #square_corner_velocity: 5.0 # La vitesse maximale (en mm/s) \u00e0 laquelle la t\u00eate d'outil peut parcourir un angle de 90 degr\u00e9s. # Une valeur non nulle peut r\u00e9duire les changements dans les d\u00e9bits de l'extrudeuse en # permettant des changements de vitesse instantan\u00e9s de la t\u00eate d'outil pendant les virages. # Cette valeur configure l'algorithme interne de prise de virage \u00e0 vitesse centrip\u00e8te ; les virages # dont l'angle est sup\u00e9rieur \u00e0 90 degr\u00e9s auront une vitesse de prise de virage plus \u00e9lev\u00e9e tandis # que ceux d'angles inf\u00e9rieurs \u00e0 90 degr\u00e9s auront une vitesse de virage plus faible. # Si ce param\u00e8tre est d\u00e9fini sur z\u00e9ro, la t\u00eate d'outil d\u00e9c\u00e9l\u00e9rera jusqu'\u00e0 z\u00e9ro \u00e0 chaque coin. # La valeur par d\u00e9faut est 5mm/s.","title":"[printer]"},{"location":"Config_Reference.html#stepper","text":"D\u00e9finitions des pilotes de moteurs pas \u00e0 pas. Diff\u00e9rents types d'imprimantes (comme sp\u00e9cifi\u00e9 par l'option \"kinematics\" dans la section [printer]) requi\u00e8rent diff\u00e9rents noms pour le moteur pas \u00e0 pas (par exemple, stepper_x vs stepper_a ). Ci-dessous, vous trouverez les d\u00e9finitions les plus courantes. Voir le document distance de rotation pour des informations sur le calcul du param\u00e8tre rotation_distance . Voir le document Multi-MCU homing pour des informations sur l'utilisation de plusieurs microcontr\u00f4leurs lors d'une mise \u00e0 l'origine. [stepper_x] step_pin: # Broche GPIO du moteur (d\u00e9clench\u00e9e \u00e0 l'\u00e9tat haut). Ce param\u00e8tre doit \u00eatre fourni. dir_pin: # Broche GPIO de direction (le niveau haut indique une direction positive). Ce param\u00e8tre # doit \u00eatre fourni. enable_pin: # Broche d'activation (par d\u00e9faut, enable est haut ; utilisez ! pour indiquer enable # bas). Si ce param\u00e8tre n'est pas fourni, le pilote du moteur pas \u00e0 pas doit toujours # \u00eatre activ\u00e9. rotation_distance: # Distance (en mm) parcourue par l'axe lors d'une rotation compl\u00e8te du moteur pas \u00e0 pas # (ou de l'engrenage final si le rapport de vitesse est sp\u00e9cifi\u00e9). # Ce param\u00e8tre doit \u00eatre fourni. microsteps: # Le nombre de micropas utilis\u00e9s par le pilote du moteur pas \u00e0 pas. Ce param\u00e8tre # doit \u00eatre fourni. #full_steps_per_rotation: 200 # Nombre de pas complets pour une rotation compl\u00e8te du moteur pas \u00e0 pas. # R\u00e9glez ce param\u00e8tre sur 200 pour un moteur pas \u00e0 pas de 1,8 degr\u00e9 ou sur 400 pour # un moteur de 0,9 degr\u00e9. La valeur par d\u00e9faut est 200. #gear_ratio: # Le rapport d'engrenage si le moteur pas \u00e0 pas est reli\u00e9 \u00e0 l'axe via une d\u00e9multiplication. # Par exemple, on peut sp\u00e9cifier \"5:1\" si un r\u00e9ducteur de 5 pour 1 est utilis\u00e9. # Si l'axe a plusieurs d\u00e9multiplications, on peut sp\u00e9cifier une liste de rapports s\u00e9par\u00e9s par # des virgules (par exemple, \"57:11, 2:1\"). Si un rapport de vitesse est sp\u00e9cifi\u00e9, alors # rotation_distance sp\u00e9cifie la distance parcourue par l'axe pour une rotation compl\u00e8te # de l'engrenage final. # La valeur par d\u00e9faut est de ne pas utiliser de rapport de vitesse. #step_pulse_duration: # Le temps minimum entre le front du signal d'impulsion de pas et le front du signal \"unstep\" suivant. # Ceci est \u00e9galement utilis\u00e9 pour d\u00e9finir le temps minimum entre une impulsion de pas et un signal # de changement de direction. # La valeur par d\u00e9faut est 0,000000100 (100ns) pour les pilotes TMC configur\u00e9s en mode UART ou SPI, # sinon la valeur par d\u00e9faut est de 0,000002 (2us) pour tous les autres pilotes. endstop_pin: # Broche de d\u00e9tection de l'interrupteur de fin de course. Si cette broche est sur un mcu diff\u00e9rent de # celui du moteur pas \u00e0 pas, cela active le \"multi-mcu\". Ce param\u00e8tre doit \u00eatre fourni pour les moteurs # pas \u00e0 pas X, Y, et Z sur les imprimantes de style cart\u00e9sien. #position_min: 0 # Distance minimale valide (en mm) vers laquelle l'utilisateur peut commander le moteur pas \u00e0 pas. # La valeur par d\u00e9faut est 0mm. position_endstop: # Emplacement de la but\u00e9e (en mm). Ce param\u00e8tre doit \u00eatre fourni pour les moteurs X, Y et Z # des imprimantes de style cart\u00e9sien. position_max: # Distance maximale valide (en mm) vers laquelle l'utilisateur peut ordonner au moteur de se d\u00e9placer. # Ce param\u00e8tre doit \u00eatre fourni pour les moteurs X, Y, et Z des imprimantes de type cart\u00e9sien. #homing_speed: 5.0 # Vitesse maximale (en mm/s) du moteur pas \u00e0 pas lors de la mise \u00e0 l'origine. La valeur par d\u00e9faut # est de 5mm/s. #homing_retract_dist: 5.0 # Distance de recul (en mm) avant le retour au point d'origine une seconde fois. # R\u00e9glez cette valeur \u00e0 z\u00e9ro pour d\u00e9sactiver le second retour \u00e0 l'origine. La valeur par d\u00e9faut # est de 5 mm. #homing_retract_speed: # Vitesse \u00e0 utiliser pour le mouvement de recul apr\u00e8s le retour \u00e0 l'origine au cas o\u00f9 elle soit # diff\u00e9rente de la vitesse de mise \u00e0 l'origine qui est la valeur par d\u00e9faut de ce param\u00e8tre. #second_homing_speed: # Vitesse (en mm/s) du moteur pas \u00e0 pas lors du second retour \u00e0 l'origine. # La valeur par d\u00e9faut est homing_speed/2. #homing_positive_dir: # Si la valeur est vraie (true), le retour au point d'origine entra\u00eenera le d\u00e9placement de la commande pas # \u00e0 pas dans une direction positive (en s'\u00e9loignant de z\u00e9ro) ; si elle est fausse (false), le retour \u00e0 l'origine # se fera vers z\u00e9ro. Il est pr\u00e9f\u00e9rable d'utiliser la valeur par d\u00e9faut que de sp\u00e9cifier ce param\u00e8tre. La valeur # par d\u00e9faut est true si position_endstop est proche de position_max et false si elle est proche de # la position_min.","title":"[stepper]"},{"location":"Config_Reference.html#cinematique-cartesienne","text":"Voir example-cartesian.cfg pour un exemple de fichier de configuration de cin\u00e9matique cart\u00e9sienne. Seuls les param\u00e8tres sp\u00e9cifiques aux imprimantes cart\u00e9siennes sont d\u00e9crits ici - voir param\u00e8tres cin\u00e9matiques communs pour les param\u00e8tres disponibles. [printer] kinematics: cartesian max_z_velocity: # Ceci d\u00e9finit la vitesse maximale (en mm/s) du mouvement le long de l'axe z # Ce param\u00e8tre peut \u00eatre utilis\u00e9 pour limiter la vitesse maximale du moteur pas \u00e0 pas z. # La valeur par d\u00e9faut est l'utilisation de max_velocity pour # max_z_velocity. max_z_accel: # Ce param\u00e8tre d\u00e9finit l'acc\u00e9l\u00e9ration maximale (en mm/s^2) du mouvement sur l'axe z. # Cela limite l'acc\u00e9l\u00e9ration du moteur pas \u00e0 pas z. La valeur par d\u00e9faut est # d'utiliser max_accel pour max_z_accel. # La section stepper_x est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant # l'axe X dans un robot cart\u00e9sien. [stepper_x] # La section stepper_y est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant # l'axe Y d'un robot cart\u00e9sien. [stepper_y] # La section stepper_z est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant # l'axe Z d'un robot cart\u00e9sien. [stepper_z]","title":"Cin\u00e9matique cart\u00e9sienne"},{"location":"Config_Reference.html#cinematique-delta-lineaire","text":"Voir example-delta.cfg pour un exemple de fichier de configuration de cin\u00e9matique delta lin\u00e9aire. Voir le guide de calibration delta pour des informations sur la calibration. Seuls les param\u00e8tres sp\u00e9cifiques aux imprimantes delta lin\u00e9aires sont d\u00e9crits ici - voir param\u00e8tres cin\u00e9matiques communs pour les param\u00e8tres disponibles. [printer] kinematics: delta max_z_velocity: # Pour les imprimantes delta, cela limite la vitesse maximale (en mm/s) des # mouvements de l'axe z. Ce param\u00e8tre peut \u00eatre utilis\u00e9 pour r\u00e9duire la # vitesse maximale des d\u00e9placements vers le haut/bas (n\u00e9cessitent une vitesse # de pas plus \u00e9lev\u00e9e que les autres mouvements sur une imprimante delta). La # valeur par d\u00e9faut est d'utiliser max_velocity pour max_z_velocity. #max_z_accel: # Ceci d\u00e9finit l'acc\u00e9l\u00e9ration maximale (en mm/s^2) du mouvement le long de l'axe z. # Ce param\u00e8tre peut \u00eatre utile si l'imprimante peut atteindre une plus grande # acc\u00e9l\u00e9ration sur les mouvements XY que sur les mouvements Z (par exemple, lors # de l'utilisation de la compensation de r\u00e9sonance). # La valeur par d\u00e9faut est d'utiliser max_accel pour max_z_accel. #minimum_z_position: 0 # Position Z minimale \u00e0 laquelle l'utilisateur peut ordonner \u00e0 la t\u00eate de se d\u00e9placer. # La valeur par d\u00e9faut est 0. delta_radius: # Rayon (en mm) du cercle horizontal form\u00e9 par les trois colonnes d'axe lin\u00e9aire. # Ce param\u00e8tre peut \u00e9galement \u00eatre calcul\u00e9 comme suit : # delta_radius = smooth_rod_offset - effector_offset - carriage_offset. # Ce param\u00e8tre doit \u00eatre fourni. #print_radius: # Le rayon (en mm) des coordonn\u00e9es XY valides de la t\u00eate d'extrusion. On peut utiliser # ce param\u00e8tre pour personnaliser la v\u00e9rification de la plage de mouvements de la t\u00eate. # Si une grande valeur est sp\u00e9cifi\u00e9e ici, il peut \u00eatre possible de faire entrer la t\u00eate en collision # avec une colonne. La valeur par d\u00e9faut est d'utiliser delta_radius pour print_radius (ce qui # emp\u00eachera normalement une collision avec une colonne). # La section stepper_a d\u00e9crit le moteur pas \u00e0 pas contr\u00f4lant la colonne avant gauche (\u00e0 210 # degr\u00e9s). Cette section contr\u00f4le \u00e9galement les param\u00e8tres de la mise \u00e0 l'origine # (homing_speed, homing_retract_dist) pour toutes les colonnes. [stepper_a] position_endstop: # Distance (en mm) entre la buse et le lit lorsque la buse se trouve au centre de la zone de # construction et que la fin de course se d\u00e9clenche. Ce param\u00e8tre doit \u00eatre fourni pour le # stepper_a ; pour les stepper_b et stepper_c, ce param\u00e8tre prend par d\u00e9faut la valeur # sp\u00e9cifi\u00e9e pour stepper_a. arm_length: # Longueur (en mm) du bras reliant cette colonne \u00e0 la t\u00eate d'impression. # Ce param\u00e8tre doit \u00eatre fourni pour stepper_a ; pour stepper_b et stepper_c, ce param\u00e8tre # prend par d\u00e9faut la valeur sp\u00e9cifi\u00e9e pour stepper_a. #angle: # Cette option sp\u00e9cifie l'angle (en degr\u00e9s) o\u00f9 se trouve positionn\u00e9e la colonne. # La valeur par d\u00e9faut est 210 pour stepper_a, 330 pour stepper_b, et 90 # pour stepper_c. # La section stepper_b d\u00e9crit le moteur pas \u00e0 pas contr\u00f4lant la colonne avant droite (\u00e0 330 degr\u00e9s). [stepper_b] # La section stepper_c d\u00e9crit le moteur pas \u00e0 pas contr\u00f4lant la colonne arri\u00e8re droite (\u00e0 90 degr\u00e9s). [stepper_c] # La section delta_calibrate active une commande G-code \u00e9tendue DELTA_CALIBRATE permettant # de calibrer la position des interrupteurs de fin de course ainsi que les angles des colonnes. [delta_calibrate] radius: # Rayon (en mm) de la zone palpable. Il s'agit du rayon des coordonn\u00e9es de la buse \u00e0 sonder ; si # vous utilisez un palpeur automatique avec un d\u00e9calage XY, choisissez un rayon suffisamment # petit pour que la sonde reste toujours au-dessus du lit. # Ce param\u00e8tre doit \u00eatre fourni. #speed: 50 # La vitesse (en mm/s) des mouvements sans palpage pendant l'\u00e9talonnage. # La valeur par d\u00e9faut est 50. #horizontal_move_z: 5 # La hauteur (en mm) \u00e0 laquelle la t\u00eate doit \u00eatre relev\u00e9e pour se d\u00e9placer # juste avant de lancer une op\u00e9ration de palpage. La valeur par d\u00e9faut est 5.","title":"Cin\u00e9matique Delta lin\u00e9aire"},{"location":"Config_Reference.html#cinematique-deltesienne","text":"Voir example-deltesian.cfg pour un exemple de fichier de configuration de cin\u00e9matique deltesienne. Seuls les param\u00e8tres sp\u00e9cifiques aux imprimantes deltesiennes sont d\u00e9crits ici - voir param\u00e8tres cin\u00e9matiques communs pour les param\u00e8tres disponibles. [printer] kinematics: deltesian max_z_velocity: # Pour les imprimantes delt\u00e9siennes, cela limite la vitesse maximale (en mm/s) de # d\u00e9placement avec le mouvement de l'axe z. Ce r\u00e9glage peut \u00eatre utilis\u00e9 pour r\u00e9duire la # vitesse maximale des mouvements vers le haut/vers le bas (qui n\u00e9cessitent un taux de pas plus \u00e9lev\u00e9 # que les autres mouvements sur une imprimante delt\u00e9sienne). La valeur par d\u00e9faut est d'utiliser # max_velocity pour max_z_velocity. #max_z_accel: # Ceci d\u00e9finit l'acc\u00e9l\u00e9ration maximale (en mm/s\u00b2) du mouvement le long # l'axe z. Ce param\u00e8tre peut \u00eatre utile si l'imprimante peut atteindre des # acc\u00e9l\u00e9ration sur les mouvements XY par rapport aux mouvements Z (par exemple, lors de l'utilisation du shaper d'entr\u00e9e). # La valeur par d\u00e9faut est d'utiliser max_accel pour max_z_accel. #minimum_z_position: 0 # La position Z minimale que l'utilisateur peut commander \u00e0 la t\u00eate de se d\u00e9placer # pour. La valeur par d\u00e9faut est 0. #min_angle: 5 # Ceci repr\u00e9sente l'angle minimum (en degr\u00e9s) par rapport \u00e0 l'horizontale # que les bras delt\u00e9siens sont autoris\u00e9s \u00e0 atteindre. Ce param\u00e8tre est # destin\u00e9 \u00e0 emp\u00eacher les bras de devenir compl\u00e8tement horizontaux, # qui risquerait d'inverser accidentellement l'axe XZ. La valeur par d\u00e9faut est 5. #print_width: # La distance (en mm) des coordonn\u00e9es X valides de la t\u00eate d'outil. On peut utiliser # ce param\u00e8tre pour personnaliser la v\u00e9rification de la plage des mouvements de la t\u00eate d'outil. Si # une grande valeur est sp\u00e9cifi\u00e9e ici alors il peut \u00eatre possible de commander # la t\u00eate d'outil en collision avec une tour. Ce param\u00e8tre g\u00e9n\u00e9ralement # correspond \u00e0 la largeur du lit (en mm). #slow_ratio: 3 # Le rapport utilis\u00e9 pour limiter la vitesse et l'acc\u00e9l\u00e9ration lors des mouvements pr\u00e8s de la # extr\u00eames de l'axe X. Si distance verticale divis\u00e9e par horizontale # la distance d\u00e9passe la valeur de slow_ratio, puis la vitesse et # les acc\u00e9l\u00e9rations sont limit\u00e9es \u00e0 la moiti\u00e9 de leurs valeurs nominales. Si vertical # la distance divis\u00e9e par la distance horizontale d\u00e9passe le double de la valeur de # le slow_ratio, puis la vitesse et l'acc\u00e9l\u00e9ration sont limit\u00e9es \u00e0 un # quart de leurs valeurs nominales. La valeur par d\u00e9faut est 3. # La section stepper_left est utilis\u00e9e pour d\u00e9crire le stepper contr\u00f4lant # la tour de gauche. Cette section contr\u00f4le \u00e9galement les param\u00e8tres de prise d'origine # (homing_speed, homing_retract_dist) pour toutes les tours. [stepper_left] position_endstop: # Distance (en mm) entre la buse et le lit lorsque la buse est # au centre de la zone de construction et les but\u00e9es sont d\u00e9clench\u00e9es. Ce # le param\u00e8tre doit \u00eatre fourni pour stepper_left; stepper_right prend la valeur de stepper_left par d\u00e9faut. arm_length: # Longueur (en mm) de la tige diagonale qui relie le chariot de la tour au # la t\u00eate d'impression. Ce param\u00e8tre doit \u00eatre fourni pour stepper_left; pour # stepper_right, ce param\u00e8tre prend par d\u00e9faut la valeur sp\u00e9cifi\u00e9e pour # stepper_left. arm_x_length: # Distance horizontale entre la t\u00eate d'impression et la tour lorsque l'imprimante est mise \u00e0 l'origine. Ce param\u00e8tre doit \u00eatre fourni pour stepper_left ; # pour stepper_right, ce param\u00e8tre prend par d\u00e9faut la valeur sp\u00e9cifi\u00e9e pour stepper_left. # La section stepper_right est utilis\u00e9e pour d\u00e9crire le stepper contr\u00f4lant le # tour de droite. [stepper_right] # La section stepper_y est utilis\u00e9e pour d\u00e9crire le stepper contr\u00f4lant # l'axe Y dans un robot delt\u00e9sien. [stepper_y]","title":"Cin\u00e9matique deltesienne"},{"location":"Config_Reference.html#cinematique-corexy","text":"Voir example-corexy.cfg pour un exemple de fichier cin\u00e9matique corexy (et h-bot). Seuls les param\u00e8tres sp\u00e9cifiques aux imprimantes corexy sont d\u00e9crits ici - voir param\u00e8tres cin\u00e9matiques communs pour les param\u00e8tres disponibles. [printer] kinematics: corexy max_z_velocity: # Ceci d\u00e9finit la vitesse maximale (en mm/s) du mouvement le long de l'axe z # Ce param\u00e8tre peut \u00eatre utilis\u00e9 pour limiter la vitesse maximale du moteur pas \u00e0 pas z. # La valeur par d\u00e9faut est l'utilisation de max_velocity pour max_z_velocity. max_z_accel: # Ce param\u00e8tre d\u00e9finit l'acc\u00e9l\u00e9ration maximale (en mm/s^2) du mouvement sur l'axe z. # Cela limite l'acc\u00e9l\u00e9ration du moteur pas \u00e0 pas z. La valeur par d\u00e9faut est # d'utiliser max_accel pour max_z_accel. # La section stepper_x est utilis\u00e9e pour d\u00e9crire l'axe X ainsi que le moteur pas \u00e0 pas # contr\u00f4lant le mouvement X+Y. [stepper_x] # La section stepper_y est utilis\u00e9e pour d\u00e9crire l'axe Y ainsi que le moteur pas \u00e0 pas # contr\u00f4lant le mouvement X-Y. [stepper_y] # La section stepper_z est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant l'axe Z. [stepper_z]","title":"Cin\u00e9matique CoreXY"},{"location":"Config_Reference.html#cinematique-corexz","text":"Voir example-corexz.cfg pour un exemple de fichier de configuration de cin\u00e9matique corexz. Seuls les param\u00e8tres sp\u00e9cifiques aux imprimantes corexz sont d\u00e9crits ici - voir param\u00e8tres cin\u00e9matiques communs pour les param\u00e8tres disponibles. [printer] kinematics: corexz max_z_velocity: # Ceci d\u00e9finit la vitesse maximale (en mm/s) du mouvement le long de l'axe z. # La valeur par d\u00e9faut est d'utiliser max_velocity pour max_z_velocity. max_z_accel: # Ceci d\u00e9finit l'acc\u00e9l\u00e9ration maximale (en mm/s^2) du mouvement le long de l'axe z. # La valeur par d\u00e9faut est d'utiliser max_accel pour max_z_accel. # La section stepper_x est utilis\u00e9e pour d\u00e9crire l'axe X ainsi que le moteur pas \u00e0 pas # contr\u00f4lant le mouvement X+Z. [stepper_x] # La section stepper_y est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant l'axe Y. [stepper_y] # La section stepper_z est utilis\u00e9e pour d\u00e9crire l'axe Z ainsi que le moteur pas \u00e0 pas # contr\u00f4lant le mouvement X-Z. [stepper_z]","title":"Cin\u00e9matique CoreXZ"},{"location":"Config_Reference.html#cinematique-hybride-corexy","text":"Voir example-hybrid-corexy.cfg pour un exemple de fichier de configuration de cin\u00e9matique hybride corexy. Cette cin\u00e9matique est \u00e9galement connue sous le nom de cin\u00e9matique Markforged. Seuls les param\u00e8tres sp\u00e9cifiques aux imprimantes hybrides corexy sont d\u00e9crits ici ; voir param\u00e8tres cin\u00e9matiques communs pour les param\u00e8tres disponibles. [printer] kinematics: hybrid_corexy max_z_velocity: # Ceci d\u00e9finit la vitesse maximale (en mm/s) du mouvement le long de l'axe z # La valeur par d\u00e9faut est d'utiliser max_velocity pour max_z_velocity. max_z_acce : # Ceci d\u00e9finit l'acc\u00e9l\u00e9ration maximale (en mm/s^2) du mouvement le long de l'axe z. # La valeur par d\u00e9faut est d'utiliser max_accel pour max_z_accel. # La section stepper_x est utilis\u00e9e pour d\u00e9crire l'axe X ainsi que le moteur pas \u00e0 pas # contr\u00f4lant le mouvement X-Y. [stepper_x] # La section stepper_y est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant # l'axe Y. [stepper_y] # La section stepper_z est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant # l'axe Z. [stepper_z]","title":"Cin\u00e9matique Hybride-CoreXY"},{"location":"Config_Reference.html#cinematique-hybride-corexz","text":"Voir example-hybrid-corexz.cfg pour un exemple de fichier de configuration de cin\u00e9matique hybride corexz. Cette cin\u00e9matique est \u00e9galement connue sous le nom de cin\u00e9matique Markforged. Seuls les param\u00e8tres sp\u00e9cifiques aux imprimantes hybrides corexy sont d\u00e9crits ici ; voir param\u00e8tres cin\u00e9matiques communs pour les param\u00e8tres disponibles. [printer] kinematics: hybrid_corexz max_z_velocity: # Ceci d\u00e9finit la vitesse maximale (en mm/s) du mouvement le long de l'axe z # La valeur par d\u00e9faut est d'utiliser max_velocity pour max_z_velocity. max_z_accel: # Ceci d\u00e9finit l'acc\u00e9l\u00e9ration maximale (en mm/s^2) du mouvement le long de # l'axe z. La valeur par d\u00e9faut est d'utiliser max_accel pour max_z_accel. # La section stepper_x est utilis\u00e9e pour d\u00e9crire l'axe X ainsi que le moteur pas \u00e0 pas # contr\u00f4lant le mouvement X-Z. [stepper_x] # La section stepper_y est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant # l'axe Y. [stepper_y] # La section stepper_z est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant # l'axe Z. [stepper_z]","title":"Cin\u00e9matique Hybride-CoreXZ"},{"location":"Config_Reference.html#cinematique-polaire","text":"Voir example-polar.cfg pour un exemple de fichier de configuration de cin\u00e9matique polaire. Seuls les param\u00e8tres sp\u00e9cifiques aux imprimantes polaires sont d\u00e9crits ici - voir param\u00e8tres cin\u00e9matiques communs pour les param\u00e8tres disponibles. LA CIN\u00c9MATIQUE POLAIRE EST UN TRAVAIL EN COURS. Les d\u00e9placements autour de la position 0, 0 sont connus pour ne pas fonctionner correctement. [printer] kinematics: polar max_z_velocity: # Ceci d\u00e9finit la vitesse maximale (en mm/s) du mouvement le long de l'axe z # Ce param\u00e8tre peut \u00eatre utilis\u00e9 pour limiter la vitesse maximale du moteur z. # La valeur par d\u00e9faut est d'utiliser max_velocity pour max_z_velocity. max_z_accel: # Ce param\u00e8tre d\u00e9finit l'acc\u00e9l\u00e9ration maximale (en mm/s^2) du mouvement sur l'axe z. # Cela limite l'acc\u00e9l\u00e9ration du moteur pas \u00e0 pas z. La valeur par d\u00e9faut est d'utiliser # max_accel pour max_z_accel. # La section stepper_bed est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant # le lit. [stepper_bed] gear_ratio: # Un rapport de vitesse doit \u00eatre sp\u00e9cifi\u00e9 et la distance de rotation ne peut pas \u00eatre # sp\u00e9cifi\u00e9e. Par exemple, si le lit est \u00e9quip\u00e9 d'une poulie \u00e0 80 dents entra\u00een\u00e9e par un # moteur dont l'axe est muni d'une poulie \u00e0 16 dents, il faut sp\u00e9cifier le rapport # d'engrenage de \"80:16\". Ce param\u00e8tre doit \u00eatre fourni. # La section stepper_arm est utilis\u00e9e pour d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant # le chariot sur le bras. [stepper_arm] # La section stepper_z permet de d\u00e9crire le moteur pas \u00e0 pas contr\u00f4lant l'axe Z. [stepper_z]","title":"Cin\u00e9matique polaire"},{"location":"Config_Reference.html#cinematique-rotative-delta","text":"Voir example-rotary-delta.cfg pour un exemple de fichier de configuration de cin\u00e9matique rotative delta. Seuls les param\u00e8tres sp\u00e9cifiques aux imprimantes rotatives delta sont d\u00e9crits ici - voir param\u00e8tres cin\u00e9matiques communs pour les param\u00e8tres disponibles. LA CIN\u00c9MATIQUE ROTATIVE DELTA EST UN TRAVAIL EN COURS. Les mouvements d'orientation peuvent d\u00e9passer le temps imparti et certains contr\u00f4les de limites ne sont pas impl\u00e9ment\u00e9s. [printer] kinematics: rotary_delta max_z_velocity: # Pour les imprimantes delta, ceci limite la vitesse maximale (en mm/s) des d\u00e9placements avec # mouvement de l'axe z. Ce param\u00e8tre peut \u00eatre utilis\u00e9 pour r\u00e9duire la vitesse maximale des # mouvements de mont\u00e9e/descente (n\u00e9cessitant un taux de pas plus \u00e9lev\u00e9 que les autres mouvements # sur une imprimante delta). La valeur par d\u00e9faut est d'utiliser max_velocity pour max_z_velocity. #minimum_z_position: 0 # La position Z minimale \u00e0 laquelle l'utilisateur peut ordonner \u00e0 la t\u00eate de se d\u00e9placer. # La valeur par d\u00e9faut est 0. shoulder_radius: # Rayon (en mm) du cercle horizontal form\u00e9 par les trois articulations de l'effecteur, moins le rayon # du cercle form\u00e9 par l'articulation de l'effecteur. # Ce param\u00e8tre peut \u00e9galement \u00eatre calcul\u00e9 comme suit # shoulder_radius = (delta_f - delta_e) / sqrt(12) # Ce param\u00e8tre doit \u00eatre fourni. shoulder_height: # Distance (en mm) des joints de l'effecteur par rapport au lit, moins la hauteur de la t\u00eate de l'outil # sur l'effecteur. Ce param\u00e8tre doit \u00eatre fourni. # La section stepper_a d\u00e9crit le moteur pas \u00e0 pas contr\u00f4lant le bras arri\u00e8re droit (\u00e0 30 degr\u00e9s). # Cette section contr\u00f4le \u00e9galement les param\u00e8tres de la mise \u00e0 l'origine (homing_speed, # homing_retract_dist) pour tous les bras. [stepper_a] gear_ratio: # Un rapport de vitesse doit \u00eatre sp\u00e9cifi\u00e9 et la rotation_distance ne peut pas \u00eatre sp\u00e9cifi\u00e9e. # Par exemple, si le bras a une poulie de 80 dents entra\u00een\u00e9e par une poulie de 16 dents, \u00e0 son # tour reli\u00e9e \u00e0 une poulie de 60 dents entra\u00een\u00e9e par un moteur dont l'arbre est muni d'une poulie # \u00e0 16 dents, alors on sp\u00e9cifierait un rapport de vitesse de \"80:16, 60:16\". # Ce param\u00e8tre doit \u00eatre fourni. position_endstop: # Distance (en mm) entre la buse et le lit lorsque la buse se trouve au centre de la zone de construction # et que la but\u00e9e se d\u00e9clenche. Ce param\u00e8tre doit \u00eatre fourni pour le stepper_a ; pour le stepper_b et # le stepper_c, ce param\u00e8tre prend par d\u00e9faut la valeur sp\u00e9cifi\u00e9e pour stepper_a. upper_arm_length: # Longueur (en mm) du bras reliant l'\"articulation de l'effecteur\" \u00e0 l'\"articulation du coude\". # Ce param\u00e8tre doit \u00eatre fourni pour stepper_a ; pour stepper_b et stepper_c, ce param\u00e8tre prend par # d\u00e9faut la valeur sp\u00e9cifi\u00e9e pour stepper_a. lower_arm_length: # Longueur (en mm) du bras reliant l'\"articulation du coude\" \u00e0 l'\"articulation de l'effecteur\". # Ce param\u00e8tre doit \u00eatre fourni pour stepper_a ; pour stepper_b et stepper_c, ce param\u00e8tre prend # par d\u00e9faut la valeur sp\u00e9cifi\u00e9e pour stepper_a. #angle: # Cette option sp\u00e9cifie l'angle (en degr\u00e9s) auquel se trouve le bras. # La valeur par d\u00e9faut est 30 pour stepper_a, 150 pour stepper_b et 270 pour stepper_c. # La section stepper_b d\u00e9crit le moteur pas \u00e0 pas contr\u00f4lant le bras arri\u00e8re gauche (\u00e0 150 degr\u00e9s). [stepper_b] # La section stepper_c d\u00e9crit le moteur pas \u00e0 pas contr\u00f4lant le bras avant (\u00e0 270 degr\u00e9s). [stepper_c] # La section delta_calibrate active une commande G-code \u00e9tendue DELTA_CALIBRATE permettant # de calibrer les positions de la but\u00e9e de l'effecteur. [delta_calibrate] radius: # Rayon (en mm) de la zone pouvant \u00eatre palp\u00e9e. Il s'agit du rayon des coordonn\u00e9es de palpage # de la buse; si vous utilisez un palpeur automatique avec un d\u00e9calage XY, choisissez un rayon # suffisamment petit pour que la sonde s'adapte toujours au lit. Ce param\u00e8tre doit \u00eatre fourni. #speed: 50 # La vitesse (en mm/s) des mouvements sans palpage pendant l'\u00e9talonnage. # La valeur par d\u00e9faut est 50. #horizontal_move_z: 5 # La hauteur (en mm) \u00e0 laquelle la t\u00eate doit \u00eatre remont\u00e9e pour se d\u00e9placer juste avant de lancer # une op\u00e9ration de palpage. La valeur par d\u00e9faut est 5.","title":"Cin\u00e9matique rotative delta"},{"location":"Config_Reference.html#cinematique-du-treuil-a-cable","text":"Voir le fichier example-winch.cfg pour un exemple de fichier de configuration cin\u00e9matique d'un treuil \u00e0 c\u00e2ble. Seuls les param\u00e8tres sp\u00e9cifiques aux imprimantes \u00e0 treuil sont d\u00e9crits ici - voir param\u00e8tres cin\u00e9matiques communs pour les param\u00e8tres disponibles. LE SUPPORT DU TREUIL \u00c0 C\u00c2BLE EST EXP\u00c9RIMENTAL. La mise \u00e0 l'origine n'est pas impl\u00e9ment\u00e9e dans la cin\u00e9matique du treuil \u00e0 c\u00e2ble. Pour ramener l'imprimante \u00e0 l'origine, envoyez des commandes manuelles de mouvements jusqu'\u00e0 ce que la t\u00eate de l'outil soit \u00e0 0, 0, 0, puis envoyez la commande G28 . [printer] kinematics: winch # La section stepper_a d\u00e9crit le moteur pas \u00e0 pas connect\u00e9 au premier treuil \u00e0 c\u00e2ble. # Un minimum de 3 et un maximum de 26 treuils \u00e0 c\u00e2ble peuvent \u00eatre d\u00e9finis # (stepper_a \u00e0 stepper_z) bien qu'il soit courant d'en d\u00e9finir 4. [stepper_a] rotation_distance: # La rotation_distance est la distance nominale (en mm) \u00e0 laquelle la t\u00eate de l'outil # se d\u00e9place vers le treuil de c\u00e2ble pour chaque rotation compl\u00e8te du moteur pas # \u00e0 pas. Ce param\u00e8tre doit \u00eatre fourni. anchor_x: anchor_y: anchor_z: # Les positions X, Y et Z du treuil \u00e0 c\u00e2ble dans l'espace cart\u00e9sien. # Ces param\u00e8tres doivent \u00eatre fournis.","title":"Cin\u00e9matique du treuil \u00e0 c\u00e2ble"},{"location":"Config_Reference.html#aucune-cinematique","text":"Il est possible de d\u00e9finir une cin\u00e9matique particuli\u00e8re \"aucune (none)\" pour d\u00e9sactiver le support cin\u00e9matique dans Klipper. Cela peut \u00eatre utile pour contr\u00f4ler des p\u00e9riph\u00e9riques qui ne sont pas des imprimantes 3D typiques ou encore \u00e0 des fins de d\u00e9bogage. [printer] kinematics: none max_velocity: 1 max_accel: 1 # Les param\u00e8tres max_velocity et max_accel doivent \u00eatre d\u00e9finis. Les # valeurs par d\u00e9faut ne sont pas utilis\u00e9es pour la cin\u00e9matique \"none\".","title":"Aucune cin\u00e9matique"},{"location":"Config_Reference.html#extrudeur-commun-et-support-du-lit-chauffant","text":"","title":"Extrudeur commun et support du lit chauffant"},{"location":"Config_Reference.html#extruder","text":"La section de l'extrudeuse est utilis\u00e9e pour d\u00e9crire les param\u00e8tres de chauffe de la buse ainsi que pour les commandes pas \u00e0 pas de l'extrudeuse. Voir la r\u00e9f\u00e9rence de commande pour plus d'informations. Voir le guide d'avance de pression pour des informations sur le r\u00e9glage de l'avance de pression. [extruder] step_pin: dir_pin: enable_pin: microsteps: rotation_distance: #full_steps_per_rotation: #gear_ratio: # Voir la section \"stepper\" pour une description des param\u00e8tres ci-dessus. # Si aucun des param\u00e8tres ci-dessus n'est sp\u00e9cifi\u00e9, alors aucun pilote ne # sera associ\u00e9 \u00e0 la buse (bien qu'une commande SYNC_EXTRUDER_MOTION # puisse en associer un au moment de l'ex\u00e9cution). nozzle_diameter: # Diam\u00e8tre de l'orifice de la buse (en mm). Ce param\u00e8tre doit \u00eatre # fourni. filament_diameter: # Diam\u00e8tre moyen du filament (en mm) lorsqu'il entre dans l'extrudeuse. # Ce param\u00e8tre doit \u00eatre fourni. #max_extrude_cross_section: # Surface maximale (en mm^2) d'une section transversale d'extrusion (ex: # largeur de l'extrusion multipli\u00e9e par la hauteur de la couche). Ce param\u00e8tre # permet d'\u00e9viter d'extruder des quantit\u00e9s excessives durant de petits d\u00e9placements # XY. Si un d\u00e9placement demande une quantit\u00e9 d'extrusion sup\u00e9rieure \u00e0 cette valeur, # une erreur sera renvoy\u00e9e. La valeur par d\u00e9faut est 4.0 *diam\u00e8tre_buse^2 #instantaneous_corner_velocity: 1.000 # La variation instantan\u00e9e maximale de la vitesse (en mm/s) de l'extrudeuse # pendant la jonction de deux mouvements. La valeur par d\u00e9faut est 1mm/s. #max_extrude_only_distance: 50.0 # Longueur maximale (en mm de filament) qu'un mouvement de r\u00e9traction ou d'extrusion # peut fournir. Si un mouvement de r\u00e9traction ou d'extrusion unique demande une # distance sup\u00e9rieure \u00e0 cette valeur, une erreur sera renvoy\u00e9e. # La valeur par d\u00e9faut est 50mm. #max_extrude_only_velocity: #max_extrude_only_accel: # Vitesse maximale (en mm/s) et acc\u00e9l\u00e9ration (en mm/s^2) du moteur de l'extrudeuse # pour les r\u00e9tractions et les mouvements d'extrusion seuls. Ces param\u00e8tres n'ont aucun # impact sur les mouvements d'impression normaux. S'ils ne sont pas sp\u00e9cifi\u00e9s, ils sont # calcul\u00e9s pour correspondre \u00e0 la limite d'un mouvement qu'une impression de # section transversale de 4.0*diam\u00e8tre_buse^2 aurait. #pressure_advance: 0.0 # La quantit\u00e9 de filament \u00e0 pousser dans l'extrudeuse durant l'acc\u00e9l\u00e9ration de celle-ci. # Une quantit\u00e9 \u00e9gale de filament est r\u00e9tract\u00e9e durant la d\u00e9c\u00e9l\u00e9ration. Elle est mesur\u00e9e # en millim\u00e8tre/seconde. La valeur par d\u00e9faut est 0, ce qui d\u00e9sactive la fonctionnalit\u00e9 # d'avance de pression. #pressure_advance_smooth_time: 0.040 # Une dur\u00e9e (en secondes) \u00e0 utiliser lors du calcul de la vitesse moyenne de l'extrudeuse # pour l'avance de pression. Une valeur plus grande donne lieu \u00e0 des mouvements # d'extrusion plus lisses. Ce param\u00e8tre ne doit pas d\u00e9passer 200ms. # Ce param\u00e8tre ne s'applique que si pressure_advance est diff\u00e9rent de z\u00e9ro. La valeur # par d\u00e9faut est 0.040 (40 millisecondes). # # Les variables restantes d\u00e9crivent la chauffe de l'extrudeuse. heater_pin: # Broche de sortie PWM contr\u00f4lant le chauffage. Ce param\u00e8tre doit \u00eatre # fourni. #max_power: 1.0 # La puissance maximale (exprim\u00e9e sous la forme d'une valeur comprise entre 0,0 et 1,0) # de r\u00e9glage du heater_pin . La valeur 1.0 permet \u00e0 la broche d'\u00eatre r\u00e9gl\u00e9e comme toujours # activ\u00e9e durant des p\u00e9riodes prolong\u00e9es, tandis qu'une valeur de 0,5 permet \u00e0 la broche # de n'\u00eatre activ\u00e9e durant au plus la moiti\u00e9 du temps. # Ce r\u00e9glage peut \u00eatre utilis\u00e9 pour limiter la puissance totale de sortie (sur de longues # p\u00e9riodes) de l'\u00e9l\u00e9ment de chauffe. La valeur par d\u00e9faut est 1.0. sensor_type: # Type de capteur - les thermistances courantes sont \"EPCOS 100K B57560G104F\", # \"ATC Semitec 104GT-2\", \"ATC Semitec 104NT-4-R025H42G\", \"Generic # 3950\", \"Honeywell 100K 135-104LAG-J01\", \"NTC 100K MGB18-104F39050L32\", # \"SliceEngineering 450\", et \"TDK NTCG104LH104JT1\". Voir la section \"Capteurs de # temp\u00e9rature\" pour d'autres capteurs. # Ce param\u00e8tre doit \u00eatre fourni. sensor_pin: # Broche d'entr\u00e9e analogique connect\u00e9e au capteur. Ce param\u00e8tre doit \u00eatre # fourni. #pullup_resistor: 4700 # La r\u00e9sistance (en ohms) du pullup reli\u00e9 \u00e0 la thermistance. # Ce param\u00e8tre n'est valable que si le capteur est une thermistance. La valeur par # d\u00e9faut est 4700 ohms. #smooth_time: 1.0 # Une dur\u00e9e (en secondes) sur laquelle les mesures de temp\u00e9rature seront # liss\u00e9es pour r\u00e9duire l'impact du bruit de la mesure. La valeur par d\u00e9faut # est de 1 seconde. control: # Algorithme de contr\u00f4le (soit pid, soit watermark). Ce param\u00e8tre doit # \u00eatre fourni. pid_Kp: pid_Ki: pid_Kd: # Les param\u00e8tres proportionnels (pid_Kp), int\u00e9graux (pid_Ki) et d\u00e9riv\u00e9s (pid_Kd) # du syst\u00e8me de contr\u00f4le de r\u00e9troaction PID. Klipper \u00e9value les param\u00e8tres PID avec # la formule g\u00e9n\u00e9rale suivante : # heater_pwm = (Kp*erreur + Ki*int\u00e9grale(erreur) - Kd*d\u00e9riv\u00e9e(erreur)) / 255 # O\u00f9 \"erreur\" est le r\u00e9sultat de \"requested_temperature - measured_temperature\" et # \"heater_pwm\" est le taux de chauffage demand\u00e9, 0.0 \u00e9tant compl\u00e8tement \u00e9teint et # 1.0 \u00e9tant compl\u00e8tement allum\u00e9. Pensez \u00e0 utiliser la commande PID_CALIBRATE pour # obtenir ces param\u00e8tres. Les param\u00e8tres pid_Kp, pid_Ki, et pid_Kd doivent \u00eatre # fournis pour l'algorithme PID. #max_delta: 2.0 # Sur les \u00e9l\u00e9ments de chauffe contr\u00f4l\u00e9s par watermark, il s'agit du nombre de degr\u00e9s # en Celsius au-dessus de la temp\u00e9rature cible avant de d\u00e9sactiver le chauffage ainsi # que le nombre de degr\u00e9s en dessous de la temp\u00e9rature cible avant la r\u00e9activation du # chauffage. La valeur par d\u00e9faut est de 2 degr\u00e9s Celsius. #pwm_cycle_time: 0.100 # Dur\u00e9e en secondes de chaque cycle PWM logiciel du chauffage. Il n'est # pas recommand\u00e9 de d\u00e9finir cette valeur, sauf s'il existe une exigence # \u00e9lectrique pour commuter le chauffage plus rapidement que 10 fois par seconde. # La valeur par d\u00e9faut est 0,100 seconde. #min_extrude_temp: 170 # La temp\u00e9rature minimale (Celsius) au-dessus de laquelle les commandes de # d\u00e9placement de l'extrudeuse peuvent \u00eatre \u00e9mises. La valeur par d\u00e9faut est 170\u00b0 C. min_temp: max_temp: # La plage maximale de temp\u00e9ratures valides (Celsius) dans laquelle l'\u00e9l\u00e9ment de # chauffe doit rester. Ceci contr\u00f4le une fonction de s\u00e9curit\u00e9 impl\u00e9ment\u00e9e dans le code # du micro-contr\u00f4leur - si la temp\u00e9rature mesur\u00e9e sort de cette plage, le microcontr\u00f4leur # se met en \u00e9tat d'arr\u00eat. Ce contr\u00f4le peut aider \u00e0 d\u00e9tecter certaines d\u00e9faillances mat\u00e9rielles # de l'\u00e9l\u00e9ment chauffant et/ou du capteur. D\u00e9finissez cette plage suffisamment large pour # que des temp\u00e9ratures raisonnables n'entra\u00eenent pas d'erreur. # Ces param\u00e8tres doivent \u00eatre fournis.","title":"[extruder]"},{"location":"Config_Reference.html#heater_bed","text":"La section heater_bed concerne le lit chauffant. Elle utilise les m\u00eames param\u00e8tres de mise en chauffe que ceux d\u00e9crits dans la section \"extrudeuse\". [heater_bed] heater_pin: sensor_type: sensor_pin: control: min_temp: max_temp: # Voir la section \"extruder\" pour une description des param\u00e8tres ci-dessus.","title":"[heater_bed]"},{"location":"Config_Reference.html#support-du-nivelage-du-lit","text":"","title":"Support du nivelage du lit"},{"location":"Config_Reference.html#bed_mesh","text":"Nivelage du maillage du lit. On peut d\u00e9finir une section de configuration bed_mesh pour activer les transformations de d\u00e9placement qui d\u00e9calent l'axe z en fonction d'un maillage g\u00e9n\u00e9r\u00e9 \u00e0 partir de points palp\u00e9s. Lorsqu'on utilise une sonde pour d\u00e9finir l'origine de l'axe z, il est recommand\u00e9 de d\u00e9finir une section safe_z_home dans printer.cfg pour r\u00e9aliser cette mise \u00e0 l'origine au centre de la zone d'impression. Consultez le guide du maillage du lit et la r\u00e9f\u00e9rence de la commande pour plus d'informations. Exemples visuels : lit rectangulaire, probe_count = 3, 3: x---x---x (max_point) | x---x---x | (min_point) x---x---x lit circulaire, round_probe_count = 5, bed_radius = r: x (0, r) fin / x---x---x \\ (-r, 0) x---x---x---x---x (r, 0) \\ x---x---x / x (0, -r) d\u00e9but [bed_mesh] #speed: 50 # The speed (in mm/s) of non-probing moves during the calibration. # The default is 50. #horizontal_move_z: 5 # The height (in mm) that the head should be commanded to move to # just prior to starting a probe operation. The default is 5. #mesh_radius: # Defines the radius of the mesh to probe for round beds. Note that # the radius is relative to the coordinate specified by the # mesh_origin option. This parameter must be provided for round beds # and omitted for rectangular beds. #mesh_origin: # Defines the center X, Y coordinate of the mesh for round beds. This # coordinate is relative to the probe's location. It may be useful # to adjust the mesh_origin in an effort to maximize the size of the # mesh radius. Default is 0, 0. This parameter must be omitted for # rectangular beds. #mesh_min: # Defines the minimum X, Y coordinate of the mesh for rectangular # beds. This coordinate is relative to the probe's location. This # will be the first point probed, nearest to the origin. This # parameter must be provided for rectangular beds. #mesh_max: # Defines the maximum X, Y coordinate of the mesh for rectangular # beds. Adheres to the same principle as mesh_min, however this will # be the furthest point probed from the bed's origin. This parameter # must be provided for rectangular beds. #probe_count: 3, 3 # For rectangular beds, this is a comma separate pair of integer # values X, Y defining the number of points to probe along each # axis. A single value is also valid, in which case that value will # be applied to both axes. Default is 3, 3. #round_probe_count: 5 # For round beds, this integer value defines the maximum number of # points to probe along each axis. This value must be an odd number. # Default is 5. #fade_start: 1.0 # The gcode z position in which to start phasing out z-adjustment # when fade is enabled. Default is 1.0. #fade_end: 0.0 # The gcode z position in which phasing out completes. When set to a # value below fade_start, fade is disabled. It should be noted that # fade may add unwanted scaling along the z-axis of a print. If a # user wishes to enable fade, a value of 10.0 is recommended. # Default is 0.0, which disables fade. #fade_target: # The z position in which fade should converge. When this value is # set to a non-zero value it must be within the range of z-values in # the mesh. Users that wish to converge to the z homing position # should set this to 0. Default is the average z value of the mesh. #split_delta_z: .025 # The amount of Z difference (in mm) along a move that will trigger # a split. Default is .025. #move_check_distance: 5.0 # The distance (in mm) along a move to check for split_delta_z. # This is also the minimum length that a move can be split. Default # is 5.0. #mesh_pps: 2, 2 # A comma separated pair of integers X, Y defining the number of # points per segment to interpolate in the mesh along each axis. A # \"segment\" can be defined as the space between each probed point. # The user may enter a single value which will be applied to both # axes. Default is 2, 2. #algorithm: lagrange # The interpolation algorithm to use. May be either \"lagrange\" or # \"bicubic\". This option will not affect 3x3 grids, which are forced # to use lagrange sampling. Default is lagrange. #bicubic_tension: .2 # When using the bicubic algorithm the tension parameter above may # be applied to change the amount of slope interpolated. Larger # numbers will increase the amount of slope, which results in more # curvature in the mesh. Default is .2. #zero_reference_position: # An optional X,Y coordinate that specifies the location on the bed # where Z = 0. When this option is specified the mesh will be offset # so that zero Z adjustment occurs at this location. The default is # no zero reference. #relative_reference_index: # **DEPRECATED, use the \"zero_reference_position\" option** # The legacy option superceded by the \"zero reference position\". # Rather than a coordinate this option takes an integer \"index\" that # refers to the location of one of the generated points. It is recommended # to use the \"zero_reference_position\" instead of this option for new # configurations. The default is no relative reference index. #faulty_region_1_min: #faulty_region_1_max: # Optional points that define a faulty region. See docs/Bed_Mesh.md # for details on faulty regions. Up to 99 faulty regions may be added. # By default no faulty regions are set.","title":"[bed_mesh]"},{"location":"Config_Reference.html#bed_tilt","text":"Compensation de l'inclinaison du lit. On peut d\u00e9finir une section de configuration bed_tilt pour activer les transformations de d\u00e9placement tenant compte d'un lit inclin\u00e9. Notez que bed_mesh et bed_tilt sont incompatibles ; les deux ne peuvent pas \u00eatre d\u00e9finis en m\u00eame temps. Voir la r\u00e9f\u00e9rence des commandes pour plus d'informations. [bed_tilt] #x_adjust: 0 # Quantit\u00e9 \u00e0 ajouter \u00e0 la hauteur Z de chaque mouvement pour chaque mm sur l'axe X. # La valeur par d\u00e9faut est 0. #y_adjust: 0 # Quantit\u00e9 \u00e0 ajouter \u00e0 la hauteur Z de chaque mouvement pour chaque mm sur l'axe Y. # La valeur par d\u00e9faut est 0. #z_adjust: 0 # Quantit\u00e9 \u00e0 ajouter \u00e0 la hauteur Z lorsque la buse est nominalement \u00e0 0, 0. # La valeur par d\u00e9faut est 0. # Les param\u00e8tres suivants contr\u00f4lent la commande g-code \u00e9tendue BED_TILT_CALIBRATE # utilis\u00e9e pour calibrer les param\u00e8tres de r\u00e9glage x et y appropri\u00e9s. #points: # Une liste de coordonn\u00e9es X, Y (une par ligne ; les lignes suivantes indent\u00e9es) devant # \u00eatre palp\u00e9es pendant une commande BED_TILT_CALIBRATE # Sp\u00e9cifiez les coordonn\u00e9es de la buse et assurez-vous que la sonde est au-dessus du lit # aux coordonn\u00e9es donn\u00e9es de la buse. # La valeur par d\u00e9faut est de ne pas activer la commande. #speed: 50 # Vitesse (en mm/s) des mouvements de d\u00e9placements hors palpage pendant l'\u00e9talonnage. # La valeur par d\u00e9faut est 50. #horizontal_move_z: 5 # Hauteur (en mm) \u00e0 laquelle la t\u00eate doit \u00eatre relev\u00e9e lors du d\u00e9placement juste avant # de lancer une op\u00e9ration de palpage. La valeur par d\u00e9faut est 5.","title":"[bed_tilt]"},{"location":"Config_Reference.html#bed_screws","text":"Outil d'aide au r\u00e9glage des vis de nivellement du lit. On peut d\u00e9finir une section de configuration [bed_screws] pour activer une commande g-code BED_SCREWS_ADJUST. Consultez le guide de nivelage et la r\u00e9f\u00e9rence des commandes pour plus d'informations. [bed_screws] #screw1: # Coordonn\u00e9es X, Y de la premi\u00e8re vis de r\u00e9glage du niveau du lit. Il s'agit # de la position vers laquelle d\u00e9placer la buse afin qu'elle soit plac\u00e9e au- # dessus de cette vis de r\u00e9glage (ou aussi proche que possible tout en \u00e9tant # au-dessus du lit). Ce param\u00e8tre doit \u00eatre fourni. #screw1_name: # Un nom arbitraire pour la vis donn\u00e9e. Ce nom est affich\u00e9 lors de # l'ex\u00e9cution du script d'aide. Par d\u00e9faut, le nom utilis\u00e9 est bas\u00e9 sur la # position XY de la vis. #screw1_fine_adjust : # Coordonn\u00e9es X, Y pour commander la buse afin de pouvoir affiner le # r\u00e9glage de la vis de mise \u00e0 niveau du lit. Par d\u00e9faut, il n'y a pas de # r\u00e9glage fin sur la vis de mise \u00e0 niveau du lit. #screw2: #screw2_name: #screw2_fine_adjust: #... # Vis suppl\u00e9mentaires de mise \u00e0 niveau du lit. Au moins trois vis doivent # \u00eatre d\u00e9finies. #horizontal_move_z: 5 # Hauteur (en mm) \u00e0 laquelle la t\u00eate doit \u00eatre relev\u00e9e pour se d\u00e9placer # lors du passage d'une vis \u00e0 la suivante. La valeur par d\u00e9faut est 5. #probe_height: 0 # Hauteur de la sonde (en mm) apr\u00e8s ajustement d\u00fb \u00e0 la dilatation # thermique du lit et de la buse. La valeur par d\u00e9faut est z\u00e9ro. #speed: 50 # Vitesse (en mm/s) des d\u00e9placements entre les palpages pendant # l'\u00e9talonnage. La valeur par d\u00e9faut est 50. #probe_speed: 5 # Vitesse (en mm/s) lors du d\u00e9placement d'une position # horizontal_move_z \u00e0 la position probe_height. La valeur par # d\u00e9faut est 5.","title":"[bed_screws]"},{"location":"Config_Reference.html#screws_tilt_adjust","text":"Outil d'assistance au nivellement du lit avec les vis de r\u00e9glage et l'aide du palpeur Z. On peut d\u00e9finir une section de configuration screws_tilt_adjust pour activer une commande g-code SCREWS_TILT_CALCULATE. Voir le guide de nivelage et la r\u00e9f\u00e9rence des commandes pour des informations suppl\u00e9mentaires. [screws_tilt_adjust] #screw1: # La coordonn\u00e9e (X, Y) de la premi\u00e8re vis de nivellement du lit. pour que la sonde soit directement # au-dessus de la vis du lit (ou le plus pr\u00e8s possible tout en \u00e9tant # au-dessus du lit). C'est la vis de base utilis\u00e9e dans les calculs. Ce # param\u00e8tre doit \u00eatre fourni. #screw1_name: # Un nom arbitraire pour la vis donn\u00e9e. Ce nom s'affiche lorsque # le script d'assistance s'ex\u00e9cute. La valeur par d\u00e9faut est d'utiliser un nom bas\u00e9 sur # l'emplacement XY de la vis. #screw2: #nom_vis2: #... # Vis suppl\u00e9mentaires de mise \u00e0 niveau du lit. Au moins deux vis doivent \u00eatre # d\u00e9finies. #speed: 50 # La vitesse (en mm/s) des mouvements sans palpage pendant l'\u00e9talonnage. # La valeur par d\u00e9faut est 50. #horizontal_move_z: 5 # La hauteur (en mm) \u00e0 laquelle la t\u00eate doit se d\u00e9placer # juste avant de lancer une op\u00e9ration de d\u00e9tection. La valeur par d\u00e9faut est 5. #screw_thread: CW-M3 # Le type de vis utilis\u00e9 pour le nivellement du lit, M3, M4 ou M5, et la # sens de rotation du bouton qui sert \u00e0 niveler le lit. # Valeurs accept\u00e9es: CW-M3, CCW-M3, CW-M4, CCW-M4, CW-M5, CCW-M5. # La valeur par d\u00e9faut est CW-M3 que la plupart des imprimantes utilisent. A dans le sens des aiguilles d'une montre # la rotation du bouton diminue l'\u00e9cart entre la buse et le # lit. A l'inverse, une rotation dans le sens inverse des aiguilles d'une montre augmente l'\u00e9cart.","title":"[screws_tilt_adjust]"},{"location":"Config_Reference.html#z_tilt","text":"R\u00e9glage multiples de l'inclinaison de moteurs pas \u00e0 pas de l'axe Z. Cette fonction permet d'ajuster de mani\u00e8re ind\u00e9pendante l'inclinaison de plusieurs moteurs Z (voir la section \"stepper_z1\"). Si cette section est pr\u00e9sente, une commande G-Code \u00e9tendue Z_TILT_ADJUST devient disponible. [z_tilt] #z_positions: # Une liste de coordonn\u00e9es X, Y (une par ligne ; les lignes subs\u00e9quentes # indent\u00e9es) d\u00e9crivant l'emplacement de chaque \"point de pivot\" du lit. # Le \"point de pivot\" est le point o\u00f9 le lit s'attache \u00e0 l'\u00e9l\u00e9ment Z # donn\u00e9. Il est d\u00e9crit \u00e0 l'aide des coordonn\u00e9es de la buse (la position X, Y # de la buse si elle pouvait se d\u00e9placer directement au-dessus du point). La # premi\u00e8re entr\u00e9e correspond \u00e0 stepper_z, la deuxi\u00e8me \u00e0 stepper_z1, # la troisi\u00e8me \u00e0 stepper_z2, etc. Ce param\u00e8tre doit \u00eatre fourni. #points: # Une liste de coordonn\u00e9es X, Y (une par ligne ; les lignes ult\u00e9rieures # indent\u00e9es) qui doivent \u00eatre palp\u00e9es pendant une commande Z_TILT_ADJUST. # Sp\u00e9cifiez les coordonn\u00e9es de la buse et assurez-vous que le palpeur est # au-dessus du lit aux coordonn\u00e9es donn\u00e9es de la buse. # Ce param\u00e8tre doit \u00eatre fourni. #speed: 50 # La vitesse (en mm/s) des mouvements de d\u00e9placements hors palpage # pendant l'\u00e9talonnage. La valeur par d\u00e9faut est 50. #horizontal_move_z: 5 # Hauteur (en mm) \u00e0 laquelle la t\u00eate doit \u00eatre relev\u00e9e pour se d\u00e9placer juste # avant de lancer une op\u00e9ration de palpage. La valeur par d\u00e9faut est 5. #retries: 0 # Nombre de tentatives \u00e0 effectuer si les points palp\u00e9s ne sont pas dans la # tol\u00e9rance. #retry_tolerance: 0 # Si les r\u00e9-essais sont activ\u00e9s, r\u00e9essayer si les points sond\u00e9s les plus grands et # les plus petits diff\u00e8rent plus que la tol\u00e9rance retry_tolerance. Notez que la # plus petite unit\u00e9 de changement ici serait un seul pas. Cependant, si vous # sondez plus de points que de moteurs, il est probable que vous aurez une # valeur minimale fixe pour la plage de points sond\u00e9s. Vous pouvez en # apprendre plus en observant la sortie de la commande.","title":"[z_tilt]"},{"location":"Config_Reference.html#quad_gantry_level","text":"Mise \u00e0 niveau du portique mobile \u00e0 l'aide de 4 moteurs Z contr\u00f4l\u00e9s ind\u00e9pendamment. Corrige les effets de paraboles hyperboliques (chips de pommes de terre) sur un portique mobile qui est plus flexible. AVERTISSEMENT : l'utilisation de cette section sur un lit mobile peut conduire \u00e0 des r\u00e9sultats ind\u00e9sirables. Si cette section est pr\u00e9sente, une commande G-Code \u00e9tendue QUAD_GANTRY_LEVEL devient disponible. Cette routine suppose la configuration suivante des moteurs Z : ---------------- |Z1 Z2| | --------- | | | | | | | | | | x-------- | |Z Z3| ---------------- O\u00f9 x est la position 0, 0 sur le lit [quad_gantry_level] #gantry_corners: # Une liste de coordonn\u00e9es X, Y, s\u00e9par\u00e9es par des retours \u00e0 la ligne, d\u00e9crivant les deux # coins oppos\u00e9s du portique. La premi\u00e8re entr\u00e9e correspond \u00e0 Z, la seconde \u00e0 Z2. # Ce param\u00e8tre doit \u00eatre fourni. #points: # Une liste, s\u00e9par\u00e9e par des retours \u00e0 la ligne, de quatre points X, Y devant \u00eatre palp\u00e9s # pendant une commande QUAD_GANTRY_LEVEL. L'ordre des emplacements est # important, il doit correspondre aux emplacements Z, Z1, Z2 et Z3 dans l'ordre. # Ce param\u00e8tre doit \u00eatre fourni. Pour une pr\u00e9cision maximale, assurez-vous que les # d\u00e9calages de votre sonde sont configur\u00e9s. #speed: 50 # La vitesse (en mm/s) des mouvements sans palpage pendant l'\u00e9talonnage. # La valeur par d\u00e9faut est 50. #horizontal_move_z: 5 # La hauteur (en mm) \u00e0 laquelle la t\u00eate doit \u00eatre relev\u00e9e pour se d\u00e9placer juste # avant de lancer une op\u00e9ration de palpage. La valeur par d\u00e9faut est 5. #max_adjust: 4 # Limite de s\u00e9curit\u00e9 quand un ajustement sup\u00e9rieur \u00e0 cette valeur est demand\u00e9. # quad_gantry_level abandonnera. #retries: 0 # Nombre de tentatives si les points palp\u00e9s ne sont pas dans la tol\u00e9rance. #retry_tolerance: 0 # Si les re-tentatives (retries) sont activ\u00e9es, r\u00e9essayer si les points palp\u00e9s les plus grands # et les plus petits diff\u00e8rent plus que la tol\u00e9rance de re-tentative (retry_tolerance).","title":"[quad_gantry_level]"},{"location":"Config_Reference.html#skew_correction","text":"Correction de l'inclinaison de l'imprimante. Il est possible de corriger l'inclinaison de l'imprimante logiciellement sur 3 plans, xy, xz, yz. Pour ce faire, on imprime un mod\u00e8le d'\u00e9talonnage le long d'un plan et on mesure trois longueurs. En raison de la nature de la correction d'inclinaison, ces longueurs sont d\u00e9finies via le gcode. Voir Correction d'inclinaison et R\u00e9f\u00e9rence des commandes pour plus de d\u00e9tails. [skew_correction]","title":"[skew_correction]"},{"location":"Config_Reference.html#z_thermal_adjust","text":"Ajustement de la position Z de la t\u00eate d'impression en fonction de la temp\u00e9rature. Compenser le mouvement vertical de la t\u00eate d'impression caus\u00e9 par la dilatation thermique du ch\u00e2ssis de l'imprimante en temps r\u00e9el \u00e0 l'aide d'un capteur de temp\u00e9rature (g\u00e9n\u00e9ralement coupl\u00e9 \u00e0 une section verticale du ch\u00e2ssis). Voir aussi : commandes de code G \u00e9tendues . [z_thermal_adjust] #temp_coeff: # Le coefficient de dilatation thermique, en mm/\u00b0C. Par exemple, un # temp_coeff de 0,01 mm/\u00b0C d\u00e9placera l'axe Z vers le bas de 0,01 mm pour # chaque degr\u00e9 Celsius d'augmentation du capteur de temp\u00e9rature. La # valeur par d\u00e9faut, 0,0 mm/\u00b0C, n'applique aucun ajustement. #smooth_time: # Fen\u00eatre de lissage appliqu\u00e9e au capteur de temp\u00e9rature, en secondes. # Peut r\u00e9duire le bruit du moteur d\u00fb \u00e0 de petites corrections excessives en # r\u00e9ponse au bruit du capteur. La valeur par d\u00e9faut est de 2,0 secondes. #z_adjust_off_above: # D\u00e9sactive les ajustements au-dessus de cette hauteur Z [mm]. La derni\u00e8re # correction calcul\u00e9e restera appliqu\u00e9e jusqu'\u00e0 ce que la t\u00eate de l'outil passe # \u00e0 nouveau en dessous de la hauteur Z sp\u00e9cifi\u00e9e. La valeur par d\u00e9faut est # 99999999.0 mm (toujours actif). #max_z_adjustment: # Ajustement absolu maximal pouvant \u00eatre appliqu\u00e9 \u00e0 l'axe Z [mm]. # La valeur par d\u00e9faut est 99999999.0 mm (illimit\u00e9). #sensor_type: #sensor_pin: #min_temp: #max_temp: # Configuration du capteur de temp\u00e9rature. # Voir la section \"extrudeuse\" pour la d\u00e9finition des param\u00e8tres ci-dessus. #gcode_id: # Voir la section \"heater_generic\" pour la d\u00e9finition de ce # param\u00e8tre.","title":"[z_thermal_adjust]"},{"location":"Config_Reference.html#mise-a-lorigine-personnalisee","text":"","title":"Mise \u00e0 l'origine personnalis\u00e9e"},{"location":"Config_Reference.html#safe_z_home","text":"Mise \u00e0 l'origine s\u00fbre de l'axe Z. On peut utiliser ce m\u00e9canisme pour centrer l'axe Z sur des coordonn\u00e9es X, Y sp\u00e9cifiques. Ceci est utile si la t\u00eate de l'outil, par exemple, doit se d\u00e9placer vers le centre du lit avant que l'axe Z puisse \u00eatre mis \u00e0 l'origine. [safe_z_home] home_xy_position: # Une coordonn\u00e9e X, Y (par exemple 100, 100) o\u00f9 la mise \u00e0 l'origine Z # doit \u00eatre effectu\u00e9e. Ce param\u00e8tre doit \u00eatre fourni. #speed: 50.0 # Vitesse \u00e0 laquelle la t\u00eate de l'outil est d\u00e9plac\u00e9e vers la position de # r\u00e9f\u00e9rence Z s\u00fbre. La valeur par d\u00e9faut est 50 mm/s #z_hop: # Distance (en mm) pour lever l'axe Z avant le retour au point d'origine. # Cette valeur est appliqu\u00e9e \u00e0 toute commande d'initialisation, m\u00eame # si elle n'initialise pas l'axe Z. Si l'axe Z est d\u00e9j\u00e0 ramen\u00e9 \u00e0 la position # de base et que la position Z actuelle est inf\u00e9rieure \u00e0 z_hop, alors ceci # l\u00e8vera la t\u00eate \u00e0 une hauteur de z_hop. Si l'axe Z n'est pas d\u00e9j\u00e0 centr\u00e9, # la t\u00eate est relev\u00e9e de z_hop. # La valeur par d\u00e9faut est de ne pas impl\u00e9menter le relevage en Z. #z_hop_speed: 15.0 # Vitesse (en mm/s) \u00e0 laquelle l'axe Z est relev\u00e9 avant le retour \u00e0 la # position initiale. La valeur par d\u00e9faut est de 15 mm/s. #move_to_previous: False # Lorsqu'il a la valeur True, les axes X et Y sont r\u00e9initialis\u00e9s \u00e0 leurs # positions pr\u00e9c\u00e9dentes apr\u00e8s retour \u00e0 la position initiale de l'axe Z. # La valeur par d\u00e9faut est False.","title":"[safe_z_home]"},{"location":"Config_Reference.html#homing_override","text":"Homing override. On peut utiliser ce m\u00e9canisme pour ex\u00e9cuter une s\u00e9rie de commandes g-code \u00e0 la place d'un G28 trouv\u00e9 dans l'entr\u00e9e g-code normale. Cela peut \u00eatre utile sur les imprimantes qui n\u00e9cessitent une proc\u00e9dure sp\u00e9cifique du retour au point d'origine de la machine. [homing_override] gcode: # Une liste de commandes G-Code \u00e0 ex\u00e9cuter \u00e0 la place des commandes # G28 trouv\u00e9es dans l'entr\u00e9e g-code normale. Voir # docs/Command_Templates.md pour le format G-Code. Si un G28 est # contenu dans cette liste de commandes alors la proc\u00e9dure de mise \u00e0 # l'origine de l'imprimante sera invoqu\u00e9e. Les commandes \u00e9num\u00e9r\u00e9es # ici doivent ramener tous les axes \u00e0 la position initiale. # Ce param\u00e8tre doit \u00eatre fourni. #axes: xyz # Les axes \u00e0 remplacer. Par exemple, si ce param\u00e8tre est d\u00e9fini sur \"z\", # alors le script d'annulation ne sera ex\u00e9cut\u00e9 que lorsque l'axe z est mis # \u00e0 l'origine (par ex. une commande \"G28\" ou \"G28 Z\"). Remarque : # le script de neutralisation doit toujours g\u00e9rer tous les axes. La valeur # par d\u00e9faut est \"xyz\" ce qui fait que le script de remplacement sera # ex\u00e9cut\u00e9 \u00e0 la place de toutes les commandes G28. #set_position_x: #set_position_y: #set_position_z: # Si sp\u00e9cifi\u00e9, l'imprimante supposera que l'axe est \u00e0 la position indiqu\u00e9e # avant d'ex\u00e9cuter les commandes g-code ci-dessus. Le fait de d\u00e9finir # ceci d\u00e9sactive les contr\u00f4les d'orientation pour cet axe. Cela peut \u00eatre # utile si la t\u00eate doit se d\u00e9placer avant d'invoquer le m\u00e9canisme G28 # normal d'un axe. La valeur par d\u00e9faut est de ne pas forcer une # position pour un axe.","title":"[homing_override]"},{"location":"Config_Reference.html#endstop_phase","text":"Interrupteurs de fin de course ajust\u00e9s \u00e0 la phase du moteur pas \u00e0 pas. Pour utiliser cette fonction, d\u00e9finissez une section de configuration avec un pr\u00e9fixe \"endstop_phase\" suivi du nom de la section de configuration du moteur pas \u00e0 pas correspondante (par exemple, \"[endstop_phase stepper_z]\"). Cette fonctionnalit\u00e9 peut am\u00e9liorer la pr\u00e9cision des interrupteurs de fin de course. Ajoutez une d\u00e9claration nue \"[endstop_phase]\" pour activer la commande ENDSTOP_PHASE_CALIBRATE. Voir le guide de d\u00e9tecteurs de fin de course et la r\u00e9f\u00e9rence des commandes pour plus d'informations. [endstop_phase stepper_z] #endstop_accuracy: # D\u00e9finit la pr\u00e9cision attendue (en mm) de la but\u00e9e. Cela repr\u00e9sente la # distance d'erreur maximale que la but\u00e9e peut d\u00e9clencher (par # exemple, si une but\u00e9e peut occasionnellement se d\u00e9clencher 100um # en avance ou jusqu'\u00e0 100um en retard alors r\u00e9glez cette valeur sur # 0.200 pour 200um). La valeur par d\u00e9faut est # 4*rotation_distance/full_steps_per_rotation. #trigger_phase: # Sp\u00e9cifie la phase du pilote du moteur pas \u00e0 pas \u00e0 attendre lorsque # l'on atteint la but\u00e9e. Compos\u00e9 de deux nombres s\u00e9par\u00e9s par une barre # oblique - la phase et le nombre total de phases (par exemple, \"7/64\"). # Ne d\u00e9finissez cette valeur que si vous \u00eates s\u00fbr que le pilote du moteur # pas \u00e0 pas est r\u00e9initialis\u00e9 \u00e0 chaque fois que le mcu est r\u00e9initialis\u00e9. Si # cette valeur n'est pas d\u00e9finie, alors la phase du moteur pas \u00e0 pas sera # d\u00e9tect\u00e9e \u00e0 la premi\u00e8re mise \u00e0 l'origine et cette phase sera utilis\u00e9e sur # toutes les origines suivantes. #endstop_align_zero: False # Si vrai, la position_endstop de l'axe sera effectivement modifi\u00e9e de # mani\u00e8re \u00e0 ce que la position z\u00e9ro de l'axe se produise sur un pas # complet du moteur pas \u00e0 pas. (Si utilis\u00e9 sur l'axe Z et que la hauteur # de la couche d'impression est un multiple de la distance parcourue # par un pas complet, alors chaque couche se produira sur un pas # complet). La valeur par d\u00e9faut est False.","title":"[endstop_phase]"},{"location":"Config_Reference.html#macros-et-evenements-g-code","text":"","title":"Macros et \u00e9v\u00e9nements G-Code"},{"location":"Config_Reference.html#gcode_macro","text":"Macros G-Code (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"gcode_macro\"). Voir le guide des mod\u00e8les de commande pour plus d'informations. [gcode_macro my_cmd] #gcode: # Une liste de commandes G-Code \u00e0 ex\u00e9cuter \u00e0 la place de \"my_cmd\". # Voir docs/Command_Templates.md pour le format G-Code. Ce param\u00e8tre # doit \u00eatre fourni. #variable_<name>: # On peut sp\u00e9cifier un nombre quelconque d'options avec le pr\u00e9fixe # \"variable_\". Le nom de variable donn\u00e9 se verra attribu\u00e9 la valeur donn\u00e9e # (analys\u00e9e en tant que litt\u00e9ral par Python) et sera disponible pendant # l'expansion de la macro. Par exemple, une configuration avec # \"variable_fan_speed = 75\" pourrait avoir des commandes gcode # contenant \"M106 S{ fan_speed * 255 }\". Ces variables peuvent alors \u00eatre # modifi\u00e9es au moment de l'ex\u00e9cution en utilisant la commande # SET_GCODE_VARIABLE (voir docs/Command_Templates.md pour plus # de d\u00e9tails). Les noms de variables peuvent ne pas utiliser de # caract\u00e8res majuscules. #rename_existing: # Cette option permet \u00e0 la macro de remplacer une commande G-Code # existante et fournira la d\u00e9finition pr\u00e9c\u00e9dente de la commande via le # nom fourni ici. Ceci peut \u00eatre utilis\u00e9 pour remplacer les commandes # G-Code originelles. Il convient d'\u00eatre prudent lorsque l'on remplace # des commandes, cela pouvant provoquer des r\u00e9sultats complexes et # inattendus. La valeur par d\u00e9faut est de ne pas remplacer une # commande G-Code existante. #description: Macro G-Code # Ceci ajoutera une courte description utilis\u00e9e \u00e0 la commande HELP # ou lors de l'utilisation de la fonction de compl\u00e9tion automatique. # Par d\u00e9faut : \"G-Code macro\".","title":"[gcode_macro]"},{"location":"Config_Reference.html#delayed_gcode","text":"Ex\u00e9cute un gcode sur un d\u00e9lai d\u00e9fini. Voir le guide des mod\u00e8les de commande et la r\u00e9f\u00e9rence des commandes pour plus d'informations. [delayed_gcode my_delayed_gcode] gcode: # Une liste de commandes G-Code \u00e0 ex\u00e9cuter lorsque la dur\u00e9e du d\u00e9lai # est \u00e9coul\u00e9e. Les mod\u00e8les G-Code sont support\u00e9s. Ce param\u00e8tre # doit \u00eatre fourni. #initial_duration: 0.0 # Dur\u00e9e du d\u00e9lai initial (en secondes). Si elle est d\u00e9finie \u00e0 une valeur non # nulle, le gcode diff\u00e9r\u00e9 s'ex\u00e9cutera le nombre de secondes sp\u00e9cifi\u00e9 apr\u00e8s # que l'imprimante passe \u00e0 l'\u00e9tat \"pr\u00eat\". Ceci peut \u00eatre utile pour les # proc\u00e9dures d'initialisation ou lors d'une r\u00e9p\u00e9tition de delayed_gcode. # Si la valeur est 0, le delayed_gcode ne sera pas ex\u00e9cut\u00e9 au d\u00e9marrage. # La valeur par d\u00e9faut est 0.","title":"[delayed_gcode]"},{"location":"Config_Reference.html#save_variables","text":"Prise en charge de l'enregistrement des variables sur le disque afin qu'elles soient conserv\u00e9es lors des red\u00e9marrages. Voir mod\u00e8les de commande et r\u00e9f\u00e9rence G-code pour plus d'informations. [save_variables] filename: # Obligatoire - fournir un nom de fichier utilis\u00e9 pour enregistrer les variables # sur le disque, par exemple ~/variables.cfg.","title":"[save_variables]"},{"location":"Config_Reference.html#idle_timeout","text":"D\u00e9lai d'inactivit\u00e9. Un d\u00e9lai d'inactivit\u00e9 est automatiquement activ\u00e9 - ajoutez une section de configuration idle_timeout explicite pour modifier les param\u00e8tres par d\u00e9faut. [idle_timeout] #gcode: # Une liste de commandes G-Code \u00e0 ex\u00e9cuter lors d'un d\u00e9lai d'inactivit\u00e9. Voir # docs/Command_Templates.md pour le format G-Code. La valeur par d\u00e9faut # est d'ex\u00e9cuter \"TURN_OFF_HEATERS\" et \"M84\". #timeout: 600 # Dur\u00e9e d'attente (en secondes) avant d'ex\u00e9cuter les commandes G-Code ci-dessus. # La valeur par d\u00e9faut est de 600 secondes.","title":"[idle_timeout]"},{"location":"Config_Reference.html#fonctionnalites-optionnelles-du-g-code","text":"","title":"Fonctionnalit\u00e9s optionnelles du G-code"},{"location":"Config_Reference.html#virtual_sdcard","text":"Une carte SD virtuelle peut \u00eatre utile si la machine h\u00f4te n'est pas assez rapide pour faire fonctionner OctoPrint correctement. Elle permet au logiciel h\u00f4te Klipper d'imprimer directement les fichiers gcode stock\u00e9s dans un r\u00e9pertoire sur l'h\u00f4te en utilisant les commandes G-Code standard de la carte SD (par exemple, M24). [virtual_sdcard] path: # Le chemin d'acc\u00e8s au r\u00e9pertoire local sur la machine h\u00f4te de recherche # des fichiers g-code. Il s'agit d'un r\u00e9pertoire en lecture seule (les \u00e9critures # de fichiers sur une carte SD ne sont pas support\u00e9es). On peut le faire pointer # vers le r\u00e9pertoire de t\u00e9l\u00e9chargement d'OctoPrint (g\u00e9n\u00e9ralement # ~/.octoprint/uploads/ ). Ce param\u00e8tre doit \u00eatre fourni. #on_error_gcode: # Une liste de commandes G-Code \u00e0 ex\u00e9cuter lorsqu'une erreur est signal\u00e9e.","title":"[virtual_sdcard]"},{"location":"Config_Reference.html#sdcard_loop","text":"Certaines imprimantes dot\u00e9es de fonctions d'\u00e9jections des pi\u00e8ces imprim\u00e9es, comme un \u00e9jecteur de pi\u00e8ces ou une imprimante \u00e0 courroie, peuvent trouver une utilit\u00e9 dans la mise en boucle de sections du fichier de la carte SD (par exemple, pour imprimer la m\u00eame pi\u00e8ce encore et encore, ou r\u00e9p\u00e9ter une section d'une pi\u00e8ce pour une cha\u00eene ou un autre motif r\u00e9p\u00e9t\u00e9). Voir la r\u00e9f\u00e9rence des commandes pour les commandes prises en charge. Voir le fichier sample-macros.cfg pour une macro G-Code compatible avec le M808 de Marlin. [sdcard_loop]","title":"[sdcard_loop]"},{"location":"Config_Reference.html#force_move","text":"Support des d\u00e9placements manuels des moteurs pas \u00e0 pas \u00e0 des fins de diagnostic. Remarque : l'utilisation de cette fonction peut placer l'imprimante dans un \u00e9tat invalide - consultez la r\u00e9f\u00e9rence de la commande pour obtenir des d\u00e9tails importants. [force_move] #enable_force_move: False # D\u00e9fini \u00e0 true pour activer les commandes G-Code \u00e9tendues FORCE_MOVE et # SET_KINEMATIC_POSITION # La valeur par d\u00e9faut est false.","title":"[force_move]"},{"location":"Config_Reference.html#pause_resume","text":"Fonctionnalit\u00e9 Pause/Reprise avec prise en charge de la capture et de la restauration de position. Voir la r\u00e9f\u00e9rence de la commande pour plus d'informations. [pause_resume] #recover_velocity: 50. # Lorsque la capture/restauration est activ\u00e9e, la vitesse \u00e0 laquelle retourner \u00e0 # la position captur\u00e9e (en mm/s). La valeur par d\u00e9faut est 50,0 mm/s.","title":"[pause_resume]"},{"location":"Config_Reference.html#firmware_retraction","text":"R\u00e9traction du filament par le firmware. Cela permet d'activer les commandes GCODE G10 (r\u00e9traction) et G11 (d\u00e9-r\u00e9traction) \u00e9mises par de nombreux trancheurs. Les param\u00e8tres ci-dessous fournissent des valeurs par d\u00e9faut au d\u00e9marrage, ces valeurs peuvent \u00eatre ajust\u00e9es via la commande SET_RETRACTION , ce qui permet des r\u00e9glages par filament et des ajustements en cours d'impression. [firmware_retraction] #retract_length: 0 # La longueur du filament (en mm) \u00e0 r\u00e9tracter lorsque G10 est activ\u00e9, et \u00e0 fournir # lorsque G11 est activ\u00e9 (voir unretract_extra_length ci-dessous). # La valeur par d\u00e9faut est 0 mm. #retract_speed: 20 # La vitesse de r\u00e9traction, en mm/s. La valeur par d\u00e9faut est 20 mm/s. #unretract_extra_length: 0 # Longueur (en mm) de filament *suppl\u00e9mentaire* \u00e0 ajouter lors de la d\u00e9-r\u00e9traction. #unretract_speed: 10 # La vitesse de d\u00e9-r\u00e9traction, en mm/s. La valeur par d\u00e9faut est 10 mm/s.","title":"[firmware_retraction]"},{"location":"Config_Reference.html#gcode_arcs","text":"Support des commandes gcode de courbes (arc) (G2/G3). [gcode_arcs] #resolution: 1.0 # Un arc sera divis\u00e9 en segments. La longueur de chaque segment sera \u00e9gale \u00e0 # la r\u00e9solution en mm d\u00e9finie ci-dessus. Des valeurs plus faibles produiront un # arc plus fin, mais \u00e9galement plus de travail de votre machine. Les arcs plus # petits que la valeur configur\u00e9e deviendront des lignes droites. La valeur par # d\u00e9faut est 1 mm.","title":"[gcode_arcs]"},{"location":"Config_Reference.html#respond","text":"Active les commandes \u00e9tendues \"M118\" et \"RESPOND\" . [respond] #default_type: echo # D\u00e9finit le pr\u00e9fixe par d\u00e9faut de la sortie \"M118\" et \"RESPOND\" \u00e0 l'un des # \u00e9l\u00e9ments suivants : # echo: \"echo : \" (C'est la valeur par d\u00e9faut) # command: \"// \" # error: \" !! \" #default_prefix: echo: # D\u00e9finit directement le pr\u00e9fixe par d\u00e9faut. Si elle est pr\u00e9sente, cette valeur # remplacera celle de \"default_type\".","title":"[respond]"},{"location":"Config_Reference.html#exclude_object","text":"Permet de prendre en charge l'exclusion ou l'annulation d'objets individuels pendant le processus d'impression. Voir le guide des objets exclus et la r\u00e9f\u00e9rence des commandes pour plus d'informations. Voir le fichier sample-macros.cfg pour une macro G-Code M486 compatible avec Marlin/RepRapFirmware. [exclude_object]","title":"[exclude_object]"},{"location":"Config_Reference.html#compensation-de-la-resonance","text":"","title":"Compensation de la r\u00e9sonance"},{"location":"Config_Reference.html#input_shaper","text":"Active la compensation de r\u00e9sonance . Voir \u00e9galement la r\u00e9f\u00e9rence des commandes . [input_shaper] #shaper_freq_x: 0 # Fr\u00e9quence (en Hz) de la mise en forme de l'entr\u00e9e pour l'axe X. Il s'agit g\u00e9n\u00e9ralement # d'une fr\u00e9quence de r\u00e9sonance de l'axe X que la mise en forme de l'entr\u00e9e doit supprimer. # Pour les mises en forme plus complexes, comme les mises en forme \u00e0 2 ou 3 bosses EI # (2hump/3hump), ce param\u00e8tre peut \u00eatre d\u00e9fini \u00e0 partir de diff\u00e9rentes consid\u00e9rations. # La valeur par d\u00e9faut est 0, ce qui d\u00e9sactive la mise en forme de l'entr\u00e9e pour l'axe X. #shaper_freq_y: 0 # Fr\u00e9quence (en Hz) de la mise en forme de l'entr\u00e9e pour l'axe Y. Il s'agit g\u00e9n\u00e9ralement # d'une fr\u00e9quence de r\u00e9sonance de l'axe Y que la mise en forme de l'entr\u00e9e doit supprimer. # Pour les mises en forme plus complexes, comme les mises en forme \u00e0 2 ou 3 bosses EI # (2hump/3hump), ce param\u00e8tre peut \u00eatre d\u00e9fini \u00e0 partir de diff\u00e9rentes consid\u00e9rations. # La valeur par d\u00e9faut est 0, ce qui d\u00e9sactive la mise en forme de l'entr\u00e9e pour l'axe Y. #shaper_type: mzv # Le type de mise en forme de l'entr\u00e9e \u00e0 utiliser pour les axes X et Y. Les types support\u00e9s # sont zv, mzv, zvd, ei, 2hump_ei, et 3hump_ei. # La valeur par d\u00e9faut est la compensation de r\u00e9sonance mzv. #shaper_type_x: #shaper_type_y: # Si shaper_type n'est pas d\u00e9fini, ces deux param\u00e8tres peuvent \u00eatre utilis\u00e9s pour configurer # des formes d'entr\u00e9e diff\u00e9rentes pour les axes X et Y. Les valeurs support\u00e9es sont les # m\u00eames que celles du param\u00e8tre shaper_type. #damping_ratio_x: 0.1 #damping_ratio_y: 0.1 # Taux d'amortissement des vibrations des axes X et Y utilis\u00e9s par les dispositifs de mise # en forme de l'entr\u00e9e afin d'am\u00e9liorer la suppression des vibrations. La valeur par d\u00e9faut est # 0.1 ce qui est une bonne valeur g\u00e9n\u00e9rale pour la plupart des imprimantes. Dans la plupart # des cas, ce param\u00e8tre ne n\u00e9cessite aucun r\u00e9glage et ne doit pas \u00eatre modifi\u00e9.","title":"[input_shaper]"},{"location":"Config_Reference.html#adxl345","text":"Support des acc\u00e9l\u00e9rom\u00e8tres ADXL345. Ce support permet d'interroger les mesures de l'acc\u00e9l\u00e9rom\u00e8tre \u00e0 partir du capteur. Cela active une commande ACCELEROMETER_MEASURE (voir G-Codes pour plus d'informations). Le nom de la puce par d\u00e9faut est \"default\", mais on peut sp\u00e9cifier un nom explicite (par exemple, [adxl345 my_chip_name]). [adxl345] cs_pin: # La broche d'activation SPI du capteur. Ce param\u00e8tre doit \u00eatre fourni. #spi_speed: 5000000 # La vitesse SPI (en hz) \u00e0 utiliser lors de la communication avec la puce. # La valeur par d\u00e9faut est 5000000. #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # Voir la section \"param\u00e8tres SPI communs\" pour une description des # param\u00e8tres ci-dessus. #axes_map : x, y, z # L'axe de l'acc\u00e9l\u00e9rom\u00e8tre de chacun des axes X, Y et Z de l'imprimante. # Ceci peut \u00eatre utile si l'acc\u00e9l\u00e9rom\u00e8tre est mont\u00e9 dans une orientation # qui ne correspond pas \u00e0 celle de l'imprimante. Par exemple, on peut # r\u00e9gler cette option sur \"y, x, z\" pour permuter les axes X et Y. # Il est \u00e9galement possible d'inverser un axe si la direction de l'acc\u00e9l\u00e9rom\u00e8tre # est invers\u00e9e (par exemple, \"x, z, -y\"). La valeur par d\u00e9faut est \"x, y, z\". #Rate: 3200 # D\u00e9bit de donn\u00e9es de sortie pour ADXL345. ADXL345 prend en charge les d\u00e9bits # de donn\u00e9es suivants : 3200, 1600, 800, 400, 200, 100, 50, et 25. Notez qu'il n'est # pas recommand\u00e9 de changer ce d\u00e9bit par rapport au d\u00e9bit par d\u00e9faut de 3200, # les d\u00e9bits inf\u00e9rieurs \u00e0 800 affecteront consid\u00e9rablement la qualit\u00e9 des mesures # de r\u00e9sonance.","title":"[adxl345]"},{"location":"Config_Reference.html#lis2dw","text":"Support for LIS2DW accelerometers. [lis2dw] cs_pin: # The SPI enable pin for the sensor. This parameter must be provided. #spi_speed: 5000000 # The SPI speed (in hz) to use when communicating with the chip. # The default is 5000000. #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. #axes_map: x, y, z # See the \"adxl345\" section for information on this parameter.","title":"[lis2dw]"},{"location":"Config_Reference.html#mpu9250","text":"Prise en charge des acc\u00e9l\u00e9rom\u00e8tres MPU-9250, MPU-9255, MPU-6515, MPU-6050 et MPU-6500 (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"mpu9250\"). [mpu9250 my_accelerometer] #i2c_address: # Default is 104 (0x68). If AD0 is high, it would be 0x69 instead. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: 400000 # See the \"common I2C settings\" section for a description of the # above parameters. The default \"i2c_speed\" is 400000. #axes_map: x, y, z # See the \"adxl345\" section for information on this parameter.","title":"[mpu9250]"},{"location":"Config_Reference.html#resonance_tester","text":"Prise en charge du test de r\u00e9sonance et du calibrage automatique du fa\u00e7onneur d'entr\u00e9e (input shaper). Pour utiliser la plupart des fonctionnalit\u00e9s de ce module, des d\u00e9pendances logicielles suppl\u00e9mentaires doivent \u00eatre install\u00e9es ; reportez-vous \u00e0 Mesurer les r\u00e9sonances et \u00e0 la r\u00e9f\u00e9rence de commande pour plus d'informations. Voir la section Adoucissement Max du guide de mesure des r\u00e9sonances pour plus d'informations sur le param\u00e8tre max_smoothing et son utilisation. [resonance_tester] #probe_points: # Une liste de coordonn\u00e9es X, Y, Z de points (un point par ligne) \u00e0 tester. # Au moins un point est requis. Assurez-vous que tous les points avec une certaine marge # de s\u00e9curit\u00e9 dans le plan XY (~ quelques centim\u00e8tres) sont accessibles par la t\u00eate de l'outil. #accel_chip: # Nom de la puce d'acc\u00e9l\u00e9rom\u00e8tre \u00e0 utiliser pour les mesures. Si la puce adxl345 a \u00e9t\u00e9 d\u00e9finie # sans un nom explicite, ce param\u00e8tre peut simplement la r\u00e9f\u00e9rencer en tant que # \"accel_chip : adxl345\", sinon un nom explicite doit \u00eatre fourni, par exemple # \"accel_chip : adxl345 my_chip_name\". Soit ce param\u00e8tre seul, soit les deux param\u00e8tres # suivants doivent \u00eatre d\u00e9finis. #accel_chip_x: #accel_chip_y: # Noms des puces d'acc\u00e9l\u00e9rom\u00e8tre \u00e0 utiliser pour les mesures de chaque axe. # Peut \u00eatre utile, par exemple, sur une imprimante de type \"bed slinger\", si deux acc\u00e9l\u00e9rom\u00e8tres # s\u00e9par\u00e9s sont mont\u00e9s, un sur le lit (pour l'axe Y), l'autre sur la t\u00eate de l'outil (pour l'axe X). # Ces param\u00e8tres ont le m\u00eame format que le param\u00e8tre 'accel_chip'. Soit le param\u00e8tre # 'accel_chip' soit ces deux param\u00e8tres doivent \u00eatre fournis. #max_smoothing: # Lissage maximal du fa\u00e7onneur (shaper) d'entr\u00e9e \u00e0 autoriser pour chaque axe pendant # l'auto-calibration (avec la commande 'SHAPER_CALIBRATE'). Par d\u00e9faut, aucun lissage # maximal n'est sp\u00e9cifi\u00e9. Reportez-vous au guide Measuring_Resonances pour plus de d\u00e9tails # sur l'utilisation de cette fonction. #min_freq: 5 # Fr\u00e9quence minimale de test des r\u00e9sonances. La valeur par d\u00e9faut est 5 Hz. #max_freq: 133.33 # Fr\u00e9quence maximale de test des r\u00e9sonances. La valeur par d\u00e9faut est 133,33 Hz. #accel_per_hz: 75 # Ce param\u00e8tre permet de d\u00e9terminer l'acc\u00e9l\u00e9ration \u00e0 utiliser pour tester une fr\u00e9quence # sp\u00e9cifique: accel = accel_per_hz * freq. Plus haute est cette valeur, plus l'\u00e9nergie des # oscillations est \u00e9lev\u00e9e. Peut \u00eatre fix\u00e9 \u00e0 une valeur inf\u00e9rieure \u00e0 celle par d\u00e9faut si les # r\u00e9sonances deviennent trop fortes sur l'imprimante. Cependant, des valeurs plus faibles # rendent les mesures des r\u00e9sonances \u00e0 haute fr\u00e9quence moins pr\u00e9cises. La valeur par # d\u00e9faut est de 75 (mm/sec). #hz_per_sec: 1 # D\u00e9termine la vitesse de l'essai. Lors du test de toutes les fr\u00e9quences dans la plage [min_freq, # max_freq], chaque seconde, la fr\u00e9quence augmente de hz_per_sec. # De faibles valeurs rendent le test lent, de grandes valeurs diminueront la pr\u00e9cision du test. # La valeur par d\u00e9faut est 1.0 (Hz/sec == sec^-2).","title":"[resonance_tester]"},{"location":"Config_Reference.html#assistants-de-fichiers-de-configuration","text":"","title":"Assistants de fichiers de configuration"},{"location":"Config_Reference.html#board_pins","text":"Alias des broches de la carte (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"board_pins\"). Utilisez ceci pour d\u00e9finir des alias de broches d'un micro-contr\u00f4leur. [board_pins my_aliases] mcu: mcu # Une liste de micro-contr\u00f4leurs s\u00e9par\u00e9s par des virgules pouvant utiliser les # alias. La valeur par d\u00e9faut est d'appliquer les alias au \"mcu\" principal. alias: aliases_<nom>: # Une liste s\u00e9par\u00e9e par des virgules d'alias \"nom=valeur\" \u00e0 cr\u00e9er pour le micro- # contr\u00f4leur donn\u00e9. Par exemple, \"EXP1_1=PE6\" cr\u00e9era un alias \"EXP1_1\" pour la # broche \"PE6\". Cependant, si la \"valeur\" est incluse dans \"<>\", alors \"nom\" est cr\u00e9\u00e9 # comme une broche r\u00e9serv\u00e9e (par exemple, \"EXP1_9=<GND>\" r\u00e9serverait \"EXP1_9\"). # Un nombre quelconque d'options commen\u00e7ant par \"alias_\" peuvent \u00eatre sp\u00e9cifi\u00e9es.","title":"[board_pins]"},{"location":"Config_Reference.html#include","text":"Prise en charge de l'inclusion de fichiers. On peut inclure des fichiers de configuration suppl\u00e9mentaires \u00e0 partir du fichier de configuration principal de l'imprimante. Les caract\u00e8res g\u00e9n\u00e9riques peuvent \u00e9galement \u00eatre utilis\u00e9s (par exemple, \"configs/*.cfg\"). [include my_other_config.cfg]","title":"[include]"},{"location":"Config_Reference.html#duplicate_pin_override","text":"Cet outil permet de d\u00e9finir plusieurs fois une m\u00eame broche de microcontr\u00f4leur dans un fichier de configuration sans v\u00e9rification normale des erreurs. Ceci est destin\u00e9 \u00e0 des fins de diagnostic et de d\u00e9bogage. Cette section n'est pas n\u00e9cessaire lorsque Klipper prend en charge l'utilisation de la m\u00eame broche plusieurs fois, et l'utilisation de cette d\u00e9rogation peut entra\u00eener des r\u00e9sultats confus et inattendus. [duplicate_pin_override] pins: # Une liste de broches s\u00e9par\u00e9es par des virgules pouvant \u00eatre utilis\u00e9es plusieurs fois dans # un fichier de configuration sans contr\u00f4les d'erreurs normaux. Ce param\u00e8tre doit \u00eatre # fourni.","title":"[duplicate_pin_override]"},{"location":"Config_Reference.html#materiel-de-nivelage-du-lit","text":"","title":"Mat\u00e9riel de nivelage du lit"},{"location":"Config_Reference.html#probe","text":"Sonde de hauteur Z. On peut d\u00e9finir cette section pour activer le mat\u00e9riel de nivellement de l'axe Z. Lorsque cette section est activ\u00e9e, les commandes g-code \u00e9tendus PROBE et QUERY_PROBE deviennent disponibles. Consultez \u00e9galement le guide d'\u00e9talonnage des sondes . La section probe cr\u00e9e \u00e9galement une broche virtuelle \"probe:z_virtual_endstop\". Il est possible de d\u00e9finir la broche du stepper_z, endstop_pin, sur cette broche virtuelle pour les imprimantes de style cart\u00e9sien qui utilisent la sonde \u00e0 la place d'un interrupteur de fin de course Z. Si vous utilisez \"probe:z_virtual_endstop\", ne d\u00e9finissez pas de position_endstop dans la configuration de la section stepper_z. [probe] pin: # Broche de d\u00e9tection de la sonde. Si la broche se trouve sur un microcontr\u00f4leur diff\u00e9rent # de celui des moteurs de l'axe Z alors elle active le \"multi-mcu homing\". Ce param\u00e8tre # doit \u00eatre fourni. #deactivate_on_each_sample: True # Ceci d\u00e9termine si Klipper doit ex\u00e9cuter le gcode de d\u00e9sactivation entre chaque tentative # de palpage lors d'une s\u00e9quence de palpages multiples. # La valeur par d\u00e9faut est True. #x_offset: 0.0 # La distance (en mm) entre la sonde et la buse le long de l'axe x. # La valeur par d\u00e9faut est 0. #y_offset: 0.0 # La distance (en mm) entre la sonde et la buse le long de l'axe y. # La valeur par d\u00e9faut est 0. z_offset: # La distance (en mm) entre le lit et la buse lorsque la sonde se d\u00e9clenche. # Ce param\u00e8tre doit \u00eatre fourni. #speed: 5.0 # Vitesse (en mm/s) de l'axe Z lors du palpage. La valeur par d\u00e9faut est 5mm/s. #samples: 1 # Le nombre de fois o\u00f9 il faut palper chaque point. Les valeurs z palp\u00e9es seront # moyenn\u00e9es. La valeur par d\u00e9faut est de palper 1 fois. #sample_retract_dist: 2.0 # Distance (en mm) \u00e0 parcourir pour relever la t\u00eate de l'outil entre chaque palpage # (en cas d'\u00e9chantillonnage multiple). La valeur par d\u00e9faut est 2mm. #lift_speed: # Vitesse (en mm/s) de l'axe Z lors du levage de la sonde entre les \u00e9chantillons. # La valeur par d\u00e9faut est la m\u00eame que celle du param\u00e8tre 'speed'. #samples_result: average # La m\u00e9thode de calcul lorsque l'on \u00e9chantillonne plusieurs fois - soit \"m\u00e9diane\" # (median) ou \"moyenne\" (average). La valeur par d\u00e9faut est \"moyenne\". #samples_tolerance: 0.100 # La distance Z maximale (en mm) \u00e0 laquelle un \u00e9chantillon peut diff\u00e9rer des autres # \u00e9chantillons. Si cette tol\u00e9rance est d\u00e9pass\u00e9e, soit une erreur est signal\u00e9e soit une # tentative de palpage est recommenc\u00e9e (cf. samples_tolerance_retries). # La valeur par d\u00e9faut est 0.100mm. #samples_tolerance_retries: 0 # Le nombre de fois qu'il faut r\u00e9essayer quand un palpage d\u00e9passe la tol\u00e9rance des # \u00e9chantillons. Lors d'une nouvelle tentative, tous les \u00e9chantillons en cours sont rejet\u00e9s # et une tentative de palpa est relanc\u00e9e. Si un ensemble valide d'\u00e9chantillons n'est pas # obtenu dans le nombre de tentatives donn\u00e9, une erreur est signal\u00e9e. La valeur par d\u00e9faut # est z\u00e9ro, ce qui entra\u00eene le signalement d'une erreur d\u00e8s le premier \u00e9chantillon d\u00e9passant # la tol\u00e9rance de samples_tolerance. #activate_gcode: # Une liste de commandes G-Code \u00e0 ex\u00e9cuter avant chaque tentative de palpage. # Voir docs/Command_Templates.md pour le format G-Code. Cela peut \u00eatre utile si la sonde # doit \u00eatre activ\u00e9e d'une mani\u00e8re particuli\u00e8re. Ne pas envoyer ici de commandes d\u00e9pla\u00e7ant # la t\u00eate de l'outil (par exemple, G1). La valeur par d\u00e9faut est de ne pas ex\u00e9cuter de commandes # G-code sp\u00e9ciales lors de l'activation. #deactivate_gcode: # Une liste de commandes G-Code \u00e0 ex\u00e9cuter apr\u00e8s la fin de chaque tentative de palpage # termin\u00e9e. Voir docs/Command_Templates.md pour le format G-Code. Ne pas envoyer ici # de commandes d\u00e9pla\u00e7ant la t\u00eate de l'outil. La valeur par d\u00e9faut est de ne pas ex\u00e9cuter de # commandes G-code sp\u00e9ciales lors de la d\u00e9sactivation.","title":"[probe]"},{"location":"Config_Reference.html#bltouch","text":"Sonde BLTouch. On peut d\u00e9finir cette section (au lieu d'une section probe) pour activer une sonde BLTouch. Voir Guide BL-Touch et R\u00e9f\u00e9rence des commandes pour plus d'informations. Une broche virtuelle \"probe:z_virtual_endstop\" est \u00e9galement cr\u00e9\u00e9e (voir la section \"probe\" pour les d\u00e9tails). [bltouch] sensor_pin: # Broche connect\u00e9e \u00e0 la broche du capteur (sensor) BLTouch. La plupart des BLTouch # exigent un pullup sur la broche du capteur (pr\u00e9fixez le nom de la broche par \"^\"). # Ce param\u00e8tre doit \u00eatre fourni. control_pin: # Broche connect\u00e9e \u00e0 la broche de commande du BLTouch. # Ce param\u00e8tre doit \u00eatre fourni. #pin_move_time: 0.680 # Dur\u00e9e d'attente (en secondes) pour que la broche BLTouch se d\u00e9place vers # le haut ou le bas. La valeur par d\u00e9faut est de 0,680 seconde. #stow_on_each_sample: True # D\u00e9termine si Klipper doit ordonner \u00e0 la broche de se d\u00e9placer vers le haut entre # chaque palpage lors d'une s\u00e9quence de palpages multiples. # Lisez les instructions dans docs/BLTouch.md avant de r\u00e9gler ce param\u00e8tre \u00e0 False. # La valeur par d\u00e9faut est True. #probe_with_touch_mode: False # Si ce param\u00e8tre est d\u00e9fini sur True, Klipper palpera avec le p\u00e9riph\u00e9rique en # \"touch_mode\". La valeur par d\u00e9faut est False (palpage en mode \"pin_down\"). #pin_up_reports_not_triggered: True # D\u00e9finit si le BLTouch rapporte syst\u00e9matiquement le palpeur dans un \u00e9tat \"non # d\u00e9clench\u00e9\" apr\u00e8s une commande \"pin_up\" r\u00e9ussie. Ceci devrait \u00eatre True pour # tous les BLTouch authentiques. Lisez les instructions de docs/BLTouch.md avant # de r\u00e9gler cette valeur \u00e0 False. La valeur par d\u00e9faut est True. #pin_up_touch_mode_reports_triggered: True # D\u00e9finit si le BLTouch rapporte syst\u00e9matiquement un \u00e9tat \"d\u00e9clench\u00e9\" apr\u00e8s la # commande \"pin_up_mode_reports_triggered\". Ceci devrait \u00eatre True pour tous les # BLTouch authentiques. Lisez les instructions de docs/BLTouch.md avant de r\u00e9gler # cette valeur \u00e0 False. La valeur par d\u00e9faut est True. #set_output_mode: # Demande un mode de sortie particulier de la broche du capteur sur un BLTouch V3.0 # (et ult\u00e9rieurs). Ce param\u00e8tre ne doit pas \u00eatre utilis\u00e9 sur d'autres types de sondes. # R\u00e9glez sur \"5V\" pour demander une sortie de 5 Volts de la broche du capteur (\u00e0 n'utiliser # que si la carte contr\u00f4leur n\u00e9cessite le mode 5V et est tol\u00e9rante \u00e0 5V sur sa ligne de signal # d'entr\u00e9e). R\u00e9glez sur \"OD\" pour demander l'utilisation de la sortie de la broche du capteur # en mode drain ouvert. La valeur par d\u00e9faut est de ne pas demander de mode de sortie. #x_offset: #y_offset: #z_offset: #speed: #lift_speed: #samples: #sample_retract_dist: #samples_result: #samples_tolerance: #samples_tolerance_retries: # Voir la section \"probe\" pour des informations sur ces param\u00e8tres.","title":"[bltouch]"},{"location":"Config_Reference.html#smart_effector","text":"Le \"Smart Effector\" de Duet3d impl\u00e9mente une sonde Z utilisant un capteur de force. On peut d\u00e9finir cette section \u00e0 la place de [probe] pour activer les fonctionnalit\u00e9s sp\u00e9cifiques du Smart Effector. Cela permet \u00e9galement d'activer les commandes d'ex\u00e9cution afin d'ajuster les param\u00e8tres du Smart Effector au moment de son ex\u00e9cution. [smart_effector] pin: # Broche connect\u00e9e \u00e0 la broche de sortie de la sonde Z de Smart Effector (broche 5). Notez qu' une # r\u00e9sistance de tirage (pullup) sur la carte n'est g\u00e9n\u00e9ralement pas n\u00e9cessaire. Cependant, si la broche # de sortie est connect\u00e9e \u00e0 la broche de la carte \u00e0 l'aide d'une r\u00e9sistance de tirage, cette r\u00e9sistance doit # \u00eatre de valeur \u00e9lev\u00e9e (par ex. 10K Ohm ou plus). Certaines cartes ont une r\u00e9sistance de tirage de faible # valeur sur l'entr\u00e9e de la sonde Z, ce qui entra\u00eenera probablement un \u00e9tat de sonde toujours d\u00e9clench\u00e9. # Dans ce cas, connectez le Smart Effector \u00e0 une autre broche sur la carte. Ce param\u00e8tre est n\u00e9cessaire. #control_pin: # Broche connect\u00e9e \u00e0 la broche d'entr\u00e9e de contr\u00f4le du Smart Effector (broche 7). Si elle est fournie, # les commandes de programmation de la sensibilit\u00e9 du Smart Effector deviennent disponibles. #probe_accel: # Si elle est d\u00e9finie, limite l'acc\u00e9l\u00e9ration des mouvements de palpage (en mm/sec^2). # Une grande acc\u00e9l\u00e9ration soudaine au d\u00e9but du mouvement de palpage peut provoquer des # d\u00e9clenchements intempestifs de la sonde, surtout si la t\u00eate de l'outil est lourde. # Pour \u00e9viter cela, il peut \u00eatre n\u00e9cessaire de r\u00e9duire l'acc\u00e9l\u00e9ration des mouvements de palpage # via ce param\u00e8tre. #recovery_time: 0.4 # D\u00e9lai entre les mouvements de d\u00e9placement et les mouvements de palpage en secondes. Un # d\u00e9placement rapide avant le palpage peut entra\u00eener un d\u00e9clenchement intempestif de celui-ci. # Cela peut provoquer des erreurs 'Probe triggered prior to movement' si aucun d\u00e9lai n'est d\u00e9fini. # La valeur 0 d\u00e9sactive le d\u00e9lai de r\u00e9cup\u00e9ration. # La valeur par d\u00e9faut est 0,4. #x_offset: #y_offset: # Doivent \u00eatre laiss\u00e9s non d\u00e9finis (ou d\u00e9finis \u00e0 0). z_offset: # Hauteur de d\u00e9clenchement de la sonde. Commencez avec -0,1 (mm), et ajustez plus tard en # utilisant la commande `PROBE_CALIBRATE`. Ce param\u00e8tre doit \u00eatre fourni. #speed: # Vitesse (en mm/s) de l'axe Z lors du palpage. Il est recommand\u00e9 de commencer avec une # vitesse de palpage de 20 mm/s et d'ajuster si n\u00e9cessaire pour am\u00e9liorer la pr\u00e9cision et la # r\u00e9p\u00e9tabilit\u00e9 du d\u00e9clenchement du palpeur. #samples: #sample_retract_dist: #samples_result: #samples_tolerance: #samples_tolerance_retries: #activate_gcode: #deactivate_gcode: #deactivate_on_each_sample: # Voir la section \"sonde\" (probe) pour plus d'informations sur les param\u00e8tres ci-dessus.","title":"[smart_effector]"},{"location":"Config_Reference.html#axis_twist_compensation","text":"A tool to compensate for inaccurate probe readings due to twist in X gantry. See the Axis Twist Compensation Guide for more detailed information regarding symptoms, configuration and setup. [axis_twist_compensation] #speed: 50 # The speed (in mm/s) of non-probing moves during the calibration. # The default is 50. #horizontal_move_z: 5 # The height (in mm) that the head should be commanded to move to # just prior to starting a probe operation. The default is 5. calibrate_start_x: 20 # Defines the minimum X coordinate of the calibration # This should be the X coordinate that positions the nozzle at the starting # calibration position. This parameter must be provided. calibrate_end_x: 200 # Defines the maximum X coordinate of the calibration # This should be the X coordinate that positions the nozzle at the ending # calibration position. This parameter must be provided. calibrate_y: 112.5 # Defines the Y coordinate of the calibration # This should be the Y coordinate that positions the nozzle during the # calibration process. This parameter must be provided and is recommended to # be near the center of the bed","title":"[axis_twist_compensation]"},{"location":"Config_Reference.html#moteurs-pas-a-pas-et-extrudeurs-additionnels","text":"","title":"Moteurs pas \u00e0  pas et extrudeurs additionnels"},{"location":"Config_Reference.html#stepper_z1","text":"Axes \u00e0 moteurs pas \u00e0 pas multiples. Sur une imprimante de style cart\u00e9sien, le pilote moteur contr\u00f4lant un axe donn\u00e9 peut avoir des blocs de configuration suppl\u00e9mentaires d\u00e9finissant les pilotes moteurs qui doivent \u00eatre mis en marche de concert avec le pilote principal. On peut d\u00e9finir un nombre quelconque de sections avec un suffixe num\u00e9rique commen\u00e7ant \u00e0 1 (par exemple, \"stepper_z1\", \"stepper_z2\", etc.). [stepper_z1] #step_pin: #dir_pin: #enable_pin: #microsteps: #rotation_distanc : # Voir la section \"stepper\" pour la d\u00e9finition des param\u00e8tres ci-dessus. #endstop_pin: # Si une endstop_pin est d\u00e9finie pour le moteur suppl\u00e9mentaire, alors le moteur # se d\u00e9placera \u00e0 l'origine jusqu'\u00e0 ce que la fin de course soit d\u00e9clench\u00e9e. Sinon, le # moteur se d\u00e9placera jusqu'\u00e0 ce que la fin de course du moteur principal de l'axe # soit d\u00e9clench\u00e9e.","title":"[stepper_z1]"},{"location":"Config_Reference.html#extruder1","text":"Dans une imprimante multi-extrudeurs, ajoutez une section d'extrudeur suppl\u00e9mentaire pour chaque extrudeur suppl\u00e9mentaire. Les sections d'extrudeur suppl\u00e9mentaires doivent \u00eatre nomm\u00e9es \"extruder1\", \"extruder2\", \"extruder3\", et ainsi de suite. Voir la section \"extruder\" pour une description des param\u00e8tres disponibles. Voir sample-multi-extruder.cfg pour un exemple de configuration. [extruder1] #step_pin: #dir_pin: #... # Voir la section \"extruder\" pour les param\u00e8tres disponibles pour le pilote de moteur # pas \u00e0 pas et l'\u00e9l\u00e9ment de chauffe. #shared_heater: # Cette option est obsol\u00e8te et ne doit plus \u00eatre utilis\u00e9e.","title":"[extruder1]"},{"location":"Config_Reference.html#dual_carriage","text":"Support for cartesian and hybrid_corexy/z printers with dual carriages on a single axis. The carriage mode can be set via the SET_DUAL_CARRIAGE extended g-code command. For example, \"SET_DUAL_CARRIAGE CARRIAGE=1\" command will activate the carriage defined in this section (CARRIAGE=0 will return activation to the primary carriage). Dual carriage support is typically combined with extra extruders - the SET_DUAL_CARRIAGE command is often called at the same time as the ACTIVATE_EXTRUDER command. Be sure to park the carriages during deactivation. Note that during G28 homing, typically the primary carriage is homed first followed by the carriage defined in the [dual_carriage] config section. However, the [dual_carriage] carriage will be homed first if both carriages home in a positive direction and the [dual_carriage] carriage has a position_endstop greater than the primary carriage, or if both carriages home in a negative direction and the [dual_carriage] carriage has a position_endstop less than the primary carriage. Additionally, one could use \"SET_DUAL_CARRIAGE CARRIAGE=1 MODE=COPY\" or \"SET_DUAL_CARRIAGE CARRIAGE=1 MODE=MIRROR\" commands to activate either copying or mirroring mode of the dual carriage, in which case it will follow the motion of the carriage 0 accordingly. These commands can be used to print two parts simultaneously - either two identical parts (in COPY mode) or mirrored parts (in MIRROR mode). Note that COPY and MIRROR modes also require appropriate configuration of the extruder on the dual carriage, which can typically be achieved with \"SYNC_EXTRUDER_MOTION MOTION_QUEUE=extruder EXTRUDER= \" or a similar command. Voir sample-idex.cfg pour un exemple de configuration. [dual_carriage] axis: # The axis this extra carriage is on (either x or y). This parameter # must be provided. #safe_distance: # The minimum distance (in mm) to enforce between the dual and the primary # carriages. If a G-Code command is executed that will bring the carriages # closer than the specified limit, such a command will be rejected with an # error. If safe_distance is not provided, it will be inferred from # position_min and position_max for the dual and primary carriages. If set # to 0 (or safe_distance is unset and position_min and position_max are # identical for the primary and dual carraiges), the carriages proximity # checks will be disabled. #step_pin: #dir_pin: #enable_pin: #microsteps: #rotation_distance: #endstop_pin: #position_endstop: #position_min: #position_max: # See the \"stepper\" section for the definition of the above parameters.","title":"[dual_carriage]"},{"location":"Config_Reference.html#extruder_stepper","text":"Support pour des moteurs suppl\u00e9mentaires synchronis\u00e9s avec le mouvement d'une extrudeuse (on peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe \"extruder_stepper\"). Voir la r\u00e9f\u00e9rence des commandes pour plus d'informations. [extrudeur_stepper my_extra_stepper] extruder: # L'extrudeur sur lequel ce pilote moteur est synchronis\u00e9. Si ce param\u00e8tre est # d\u00e9fini sur une cha\u00eene vide, le pilote ne sera pas synchronis\u00e9 avec un extrudeur. # Ce param\u00e8tre doit \u00eatre fourni. #step_pin: #dir_pin: #enable_pin: #microsteps: #rotation_distance: # Voir la section \"stepper\" pour la d\u00e9finition des param\u00e8tres # ci-dessus.","title":"[extruder_stepper]"},{"location":"Config_Reference.html#manual_stepper","text":"Pilotes de moteur manuels (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"manual_stepper\"). Ce sont des pilotes de moteur contr\u00f4l\u00e9s par la commande g-code MANUAL_STEPPER. Par exemple \"MANUAL_STEPPER STEPPER=my_stepper MOVE=10 SPEED=5\". Voir le fichier G-Codes pour une description de la commande MANUAL_STEPPER. Les pilotes de moteur ne sont pas connect\u00e9s \u00e0 la cin\u00e9matique normale de l'imprimante. [manual_stepper my_stepper] #step_pin: #dir_pin: #enable_pin: #microsteps: #rotation_distance: # Voir la section \"stepper\" pour une description de ces param\u00e8tres. #velocity: # D\u00e9finit la vitesse par d\u00e9faut (en mm/s) pour le pilote moteur. Cette valeur # sera utilis\u00e9e si une commande MANUAL_STEPPER ne sp\u00e9cifie pas de param\u00e8tre SPEED # La valeur par d\u00e9faut est 5mm/s. #accel # D\u00e9finit l'acc\u00e9l\u00e9ration par d\u00e9faut (en mm/s^2) pour le pilote moteur Une # acc\u00e9l\u00e9ration de z\u00e9ro n'entra\u00eenera aucune acc\u00e9l\u00e9ration. Cette valeur # sera utilis\u00e9e si une commande MANUAL_STEPPER ne sp\u00e9cifie pas de # param\u00e8tre ACCEL. La valeur par d\u00e9faut est z\u00e9ro. #endstop_pin: # Broche de d\u00e9tection de l'interrupteur de fin de course. Si elle est sp\u00e9cifi\u00e9e, on peut effectuer # des \"mouvements de retour \u00e0 l'origine\" en ajoutant un param\u00e8tre STOP_ON_ENDSTOP aux # commandes de mouvement MANUAL_STEPPER.","title":"[manual_stepper]"},{"location":"Config_Reference.html#elements-chauffants-et-capteurs-personnalises","text":"","title":"\u00c9l\u00e9ments chauffants et capteurs personnalis\u00e9s"},{"location":"Config_Reference.html#verify_heater","text":"V\u00e9rification de l'\u00e9l\u00e9ment chauffant et du capteur de temp\u00e9rature. La v\u00e9rification des \u00e9l\u00e9ments de chauffage est automatiquement activ\u00e9e pour chaque mat\u00e9riel de chauffage configur\u00e9 sur l'imprimante. Utilisez les sections verify_heater pour modifier les param\u00e8tres par d\u00e9faut. [verify_heater heater_config_name] #max_error: 120 # L'erreur de temp\u00e9rature cumul\u00e9e maximale avant de d\u00e9clencher une erreur. # Des valeurs plus petites entra\u00eenent une v\u00e9rification plus stricte et des valeurs # plus grandes permettent un d\u00e9lai plus long avant qu'une erreur ne soit signal\u00e9e. # Plus pr\u00e9cis\u00e9ment, la temp\u00e9rature est inspect\u00e9e une fois par seconde et si elle # est proche de la temp\u00e9rature cible, un \"compteur d'erreurs\" interne est remis # \u00e0 z\u00e9ro; sinon, si la temp\u00e9rature est inf\u00e9rieure \u00e0 la plage cible, le compteur est # augment\u00e9 de la quantit\u00e9 de temp\u00e9rature rapport\u00e9e diff\u00e9rant de cette plage. Si # le compteur d\u00e9passe ce \"max_error\", une erreur est signal\u00e9e. La valeur par # d\u00e9faut est 120. #check_gain_time: # Ceci contr\u00f4le la v\u00e9rification du chauffage durant la chauffe initiale. Des valeurs # plus petites entra\u00eenent une v\u00e9rification plus stricte et des valeurs plus grandes # autorisent un d\u00e9lai plus grand avant qu'une erreur ne soit signal\u00e9e. Sp\u00e9cifiquement, # pendant la chauffe initiale, tant que la temp\u00e9rature de l'\u00e9l\u00e9ment chauffant augmente # durant ce laps de temps (sp\u00e9cifi\u00e9 en secondes), le \"compteur d'erreurs\" interne est # remis \u00e0 z\u00e9ro. La valeur par d\u00e9faut est de 20 secondes pour les extrudeuses et 60 # secondes pour le lit chauffant. #hysteresis: 5 # La diff\u00e9rence de temp\u00e9rature maximale (en Celsius) par rapport \u00e0 une temp\u00e9rature # cible consid\u00e9r\u00e9e comme situ\u00e9e dans la plage de la cible. Ceci contr\u00f4le la v\u00e9rification # de la plage du param\u00e8tre max_error. Il est rare de personnaliser cette valeur. # La valeur par d\u00e9faut est 5. #heating_gain: 2 # La temp\u00e9rature minimale (en Celsius) pour laquelle le chauffage doit progresser # pendant la p\u00e9riode de check_gain_time. Il est rare de personnaliser cette valeur. # La valeur par d\u00e9faut est 2.","title":"[verify_heater]"},{"location":"Config_Reference.html#homing_heaters","text":"Outil de d\u00e9sactivation des \u00e9l\u00e9ments chauffants lors de la prise d'origine ou du palpage d'un axe. [homing_heaters] #steppers: # Une liste de pilotes moteurs s\u00e9par\u00e9s par des virgules qui devraient d\u00e9sactiver les chauffages. # La valeur par d\u00e9faut est de d\u00e9sactiver les chauffages pour tout d\u00e9placement (mise \u00e0 # l'origine / palpage). # Exemple typique : stepper_z #heaters: # Une liste, s\u00e9par\u00e9e par des virgules, d'\u00e9l\u00e9ments chauffants \u00e0 d\u00e9sactiver pendant les d\u00e9placements # (mise \u00e0 l'origine / palpage). La valeur par d\u00e9faut est de d\u00e9sactiver tous les \u00e9l\u00e9ments chauffants. # Exemple typique : extruder, heater_bed","title":"[homing_heaters]"},{"location":"Config_Reference.html#thermistor","text":"Thermistances personnalis\u00e9es (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"thermistor\"). Une thermistance personnalis\u00e9e peut \u00eatre utilis\u00e9e dans le champ sensor_type d'une section de configuration de chauffage. (Par exemple, si l'on d\u00e9finit une section \"[thermistor my_thermistor]\", on peut utiliser un \"sensor_type: my_thermistor\" lors de la d\u00e9finition d'un \u00e9l\u00e9ment de chauffe). Veillez \u00e0 placer la section thermistor dans le fichier de configuration avant sa premi\u00e8re utilisation dans une section de chauffage. [thermistor ma_thermistance] #temperature1: #resistance1: #temperature2: #resistance2: #temperature3: #resistance3: # Trois mesures de r\u00e9sistance (en Ohms) aux temp\u00e9ratures donn\u00e9es # (en Celsius). Ces trois mesures seront utilis\u00e9es pour calculer les # coefficients de Steinhart-Hart pour la thermistance. Ces param\u00e8tres # doivent \u00eatre fournis lors de l'utilisation de Steinhart-Hart pour d\u00e9finir la # thermistance. #beta: # Alternativement, on peut d\u00e9finir temp\u00e9rature1, r\u00e9sistance1, et beta # pour d\u00e9finir les param\u00e8tres de la thermistance. Ce param\u00e8tre doit \u00eatre # fourni lorsque l'on utilise \"beta\" pour d\u00e9finir la thermistance.","title":"[thermistor]"},{"location":"Config_Reference.html#adc_temperature","text":"Capteurs de temp\u00e9rature ADC personnalis\u00e9s (on peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe \"adc_temperature\"). Cela permet de d\u00e9finir un capteur de temp\u00e9rature personnalis\u00e9 mesurant une tension sur une broche de convertisseur analogique-num\u00e9rique (ADC) et utilise une interpolation lin\u00e9aire entre un ensemble de mesures configur\u00e9es de temp\u00e9rature/tension (ou de temp\u00e9rature/r\u00e9sistance) pour d\u00e9terminer la temp\u00e9rature. Le capteur r\u00e9sultant peut \u00eatre utilis\u00e9 comme un type de capteur dans une section de chauffage. (Par exemple, si l'on d\u00e9finit une section \"[adc_temperature my_sensor]\", on peut utiliser un \"sensor_type : my_sensor\" lors de la d\u00e9finition d'un \u00e9l\u00e9ment chauffant). Veillez \u00e0 placer la section du capteur dans le fichier de configuration avant sa premi\u00e8re utilisation dans une section de chauffage. [adc_temperature mon_capteur] #temperature1: #voltage1: #temperature2: #voltage2: #... # Un ensemble de temp\u00e9ratures (en Celsius) et de tensions (en Volts) \u00e0 utiliser comme # r\u00e9f\u00e9rence lors de la conversion d'une temp\u00e9rature. Une section de chauffage utilisant # ce capteur peut \u00e9galement sp\u00e9cifier les param\u00e8tres adc_voltage et voltage_offset # pour d\u00e9finir la tension ADC (voir la section \"Amplificateurs communs de temp\u00e9rature\" # pour plus de d\u00e9tails). Au moins deux mesures doivent \u00eatre fournies. #temperature1: #resistance1: #temperature2: #resistance2: #... # Alternativement, on peut indiquer un ensemble de temp\u00e9ratures (en Celsius) # et de r\u00e9sistance (en Ohms) \u00e0 utiliser comme r\u00e9f\u00e9rence lors de la conversion d'une # temp\u00e9rature. Une section de chauffage utilisant ce capteur peut \u00e9galement sp\u00e9cifier un # param\u00e8tre pullup_resistor (voir la section \"extrudeuse\" pour plus de d\u00e9tails). Au # moins deux mesures doivent \u00eatre fournies.","title":"[adc_temperature]"},{"location":"Config_Reference.html#heater_generic","text":"\u00c9l\u00e9ments de chauffe g\u00e9n\u00e9riques (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"heater_generic\"). Ces \u00e9l\u00e9ments de chauffe se comportent de la m\u00eame mani\u00e8re que les \u00e9l\u00e9ments de chauffe standards (extrudeuses, lits chauffants). Utilisez la commande SET_HEATER_TEMPERATURE (voir G-Codes pour plus de d\u00e9tails) pour d\u00e9finir la temp\u00e9rature cible. [heater_generic my_generic_heater] #gcode_id: # L'identifiant \u00e0 utiliser pour signaler la temp\u00e9rature dans la commande M105. # Ce param\u00e8tre doit \u00eatre fourni. #heater_pin: #max_power: #sensor_type: #sensor_pin: #smooth_time: #control: #pid_Kp: #pid_Ki: #pid_Kd: #pwm_cycle_time: #min_temp: #max_temp: # Voir la section \"extruder\" pour la d\u00e9finition des param\u00e8tres # ci-dessus.","title":"[heater_generic]"},{"location":"Config_Reference.html#temperature_sensor","text":"Capteurs de temp\u00e9rature g\u00e9n\u00e9riques. On peut d\u00e9finir un nombre quelconque de capteurs de temp\u00e9rature suppl\u00e9mentaires signal\u00e9s par la commande M105. [temperature_sensor my_sensor] #sensor_type: #sensor_pin: #min_temp: #max_temp: # Voir la section \"extrudeuse\" pour la d\u00e9finition des param\u00e8tres # ci-dessus. #gcode_id: # Voir la section \"heater_generic\" pour la d\u00e9finition de ce # param\u00e8tre.","title":"[temperature_sensor]"},{"location":"Config_Reference.html#capteurs-de-temperature","text":"Klipper inclut les d\u00e9finitions de nombreux types de capteurs de temp\u00e9rature. Ces capteurs peuvent \u00eatre utilis\u00e9s dans n'importe quelle section de la configuration n\u00e9cessitant un capteur de temp\u00e9rature (comme une section [extruder] ou [heater_bed] ).","title":"Capteurs de temp\u00e9rature"},{"location":"Config_Reference.html#thermistances-communes","text":"Thermistances communes. Les param\u00e8tres suivants sont disponibles dans les sections de chauffage utilisant l'un de ces capteurs. sensor_type: # Un parmi \"EPCOS 100K B57560G104F\", \"ATC Semitec 104GT-2\", # \"ATC Semitec 104NT-4-R025H42G\", \"Generic 3950\", # \"Honeywell 100K 135-104LAG-J01\", \"NTC 100K MGB18-104F39050L32\", # \"SliceEngineering 450\", ou \"TDK NTCG104LH104JT1\". sensor_pin: # Broche d'entr\u00e9e analogique connect\u00e9e \u00e0 la thermistance. Ce param\u00e8tre doit # \u00eatre fourni. #pullup_resistor: 4700 # La r\u00e9sistance (en ohms) de tirage (pullup) reli\u00e9e \u00e0 la thermistance. # La valeur par d\u00e9faut est 4700 ohms. #inline_resistor: 0 # La r\u00e9sistance (en ohms) d'une r\u00e9sistance suppl\u00e9mentaire (ne variant pas en fonction de # la chaleur) plac\u00e9e en ligne avec la thermistance. Il est rare de la d\u00e9finir. # La valeur par d\u00e9faut est 0 ohms.","title":"Thermistances communes"},{"location":"Config_Reference.html#amplificateurs-de-temperature-courants","text":"Amplificateurs de temp\u00e9rature courants. Les param\u00e8tres suivants sont disponibles dans les sections de chauffage utilisant l'un de ces capteurs. sensor_type: # Un parmi \"PT100 INA826\", \"AD595\", \"AD597\", \"AD8494\", \"AD8495\", # \"AD8496\", ou \"AD8497\". sensor_pin: # Broche d'entr\u00e9e analogique connect\u00e9e au capteur. Ce param\u00e8tre doit \u00eatre # fourni. #adc_voltage: 5.0 # La tension de comparaison ADC (en Volts). La valeur par d\u00e9faut est de 5 volts. #voltage_offset: 0 # D\u00e9calage de la tension de l'ADC (en Volts). La valeur par d\u00e9faut est 0.","title":"Amplificateurs de temp\u00e9rature courants"},{"location":"Config_Reference.html#capteur-pt1000-directement-connecte","text":"Capteur PT1000 connect\u00e9 en direct. Les param\u00e8tres suivants sont disponibles dans les sections chauffage utilisant ces capteurs. sensor_type : PT1000 sensor_pin: # Broche d'entr\u00e9e analogique connect\u00e9e au capteur. Ce param\u00e8tre doit \u00eatre # fourni. #pullup_resistor: 4700 # La r\u00e9sistance (en ohms) de tirage (pullup) reli\u00e9e au capteur. La valeur par # d\u00e9faut est 4700 ohms.","title":"Capteur PT1000 directement connect\u00e9"},{"location":"Config_Reference.html#capteurs-de-temperature-maxxxxxx","text":"Capteurs MAXxxxxx \u00e0 interface p\u00e9riph\u00e9rique s\u00e9rie (SPI) bas\u00e9s sur la temp\u00e9rature. Les param\u00e8tres suivants sont disponibles dans les sections de chauffage qui utilisent l'un de ces types de capteurs. sensor_type : # Un parmi les types suivants : \"MAX6675\", \"MAX31855\", \"MAX31856\" ou \"MAX31865\". sensor_pin: # La broche de s\u00e9lection de puce pour la puce du capteur. Ce param\u00e8tre doit \u00eatre # fourni. #spi_speed: 4000000 # La vitesse SPI (en hz) \u00e0 utiliser lors de la communication avec la puce. # La valeur par d\u00e9faut est 4000000. #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # Voir la section \"param\u00e8tres SPI communs\" pour une description des # param\u00e8tres ci-dessus. #tc_type: K #tc_use_50Hz_filter: False #tc_averaging_count: 1 # Les param\u00e8tres ci-dessus contr\u00f4lent les param\u00e8tres des capteurs des puces MAX31856 # Les valeurs par d\u00e9faut de chaque param\u00e8tre sont indiqu\u00e9es \u00e0 c\u00f4t\u00e9 du nom du param\u00e8tre # dans la liste ci-dessus. #rtd_nominal_r: 100 #rtd_reference_r: 430 #rtd_num_of_wires: 2 #rtd_use_50Hz_filter: False # Les param\u00e8tres ci-dessus contr\u00f4lent les param\u00e8tres des capteurs des puces MAX31865 # Les valeurs par d\u00e9faut de chaque param\u00e8tre sont indiqu\u00e9es \u00e0 c\u00f4t\u00e9 du nom du param\u00e8tre # dans la liste ci-dessus.","title":"Capteurs de temp\u00e9rature MAXxxxxx"},{"location":"Config_Reference.html#capteurs-de-temperature-bmp280bme280bme680","text":"Capteurs environnementaux BMP280/BME280/BME680 \u00e0 interface \u00e0 deux fils (I2C). Notez que ces capteurs ne sont pas destin\u00e9s \u00e0 \u00eatre utilis\u00e9s avec des extrudeurs et des lits chauffants, mais plut\u00f4t pour surveiller la temp\u00e9rature ambiante (C), la pression (hPa), l'humidit\u00e9 relative et, dans le cas du BME680, le niveau de gaz. Voir sample-macros.cfg pour un gcode_macro pouvant \u00eatre utilis\u00e9 pour signaler la pression et l'humidit\u00e9 en plus de la temp\u00e9rature. sensor_type: BME280 #i2c_address: # Default is 118 (0x76). Some BME280 sensors have an address of 119 # (0x77). #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters.","title":"Capteurs de temp\u00e9rature BMP280/BME280/BME680"},{"location":"Config_Reference.html#aht10aht20aht21-temperature-sensor","text":"AHT10/AHT20/AHT21 two wire interface (I2C) environmental sensors. Note that these sensors are not intended for use with extruders and heater beds, but rather for monitoring ambient temperature (C) and relative humidity. See sample-macros.cfg for a gcode_macro that may be used to report humidity in addition to temperature. sensor_type: AHT10 # Also use AHT10 for AHT20 and AHT21 sensors. #i2c_address: # Default is 56 (0x38). Some AHT10 sensors give the option to use # 57 (0x39) by moving a resistor. #i2c_mcu: #i2c_bus: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #aht10_report_time: # Interval in seconds between readings. Default is 30, minimum is 5","title":"AHT10/AHT20/AHT21 temperature sensor"},{"location":"Config_Reference.html#capteur-htu21d","text":"Capteur d'environnement de la famille HTU21D \u00e0 interface \u00e0 deux fils (I2C). Notez que ce capteur n'est pas destin\u00e9 \u00e0 \u00eatre utilis\u00e9 avec les extrudeuses et les lits chauffants, mais plut\u00f4t \u00e0 surveiller la temp\u00e9rature ambiante (C) et l'humidit\u00e9 relative. Voir sample-macros.cfg pour un gcode_macro utilisable permettant d'indiquer l'humidit\u00e9 en plus de la temp\u00e9rature. sensor_type: # Must be \"HTU21D\" , \"SI7013\", \"SI7020\", \"SI7021\" or \"SHT21\" #i2c_address: # Default is 64 (0x40). #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #htu21d_hold_master: # If the sensor can hold the I2C buf while reading. If True no other # bus communication can be performed while reading is in progress. # Default is False. #htu21d_resolution: # The resolution of temperature and humidity reading. # Valid values are: # 'TEMP14_HUM12' -> 14bit for Temp and 12bit for humidity # 'TEMP13_HUM10' -> 13bit for Temp and 10bit for humidity # 'TEMP12_HUM08' -> 12bit for Temp and 08bit for humidity # 'TEMP11_HUM11' -> 11bit for Temp and 11bit for humidity # Default is: \"TEMP11_HUM11\" #htu21d_report_time: # Interval in seconds between readings. Default is 30","title":"Capteur HTU21D"},{"location":"Config_Reference.html#capteur-de-temperature-lm75","text":"Capteurs de temp\u00e9rature LM75/LM75A connect\u00e9s en deux fils (I2C). Ces capteurs ont une gamme de -55~125 \u00b0C, et sont donc utilisables par exemple pour la surveillance de la temp\u00e9rature d'une chambre. Ils peuvent aussi fonctionner comme de simples contr\u00f4leurs de ventilateurs/\u00e9l\u00e9ments chauffants. sensor_type: LM75 #i2c_address: # Default is 72 (0x48). Normal range is 72-79 (0x48-0x4F) and the 3 # low bits of the address are configured via pins on the chip # (usually with jumpers or hard wired). #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #lm75_report_time: # Interval in seconds between readings. Default is 0.8, with minimum # 0.5.","title":"Capteur de temp\u00e9rature LM75"},{"location":"Config_Reference.html#capteur-de-temperature-integre-au-microcontroleur","text":"Les micro-contr\u00f4leurs atsam, atsamd, et stm32 poss\u00e8dent un capteur de temp\u00e9rature interne. On peut utiliser le capteur \"temperature_mcu\" pour surveiller ces temp\u00e9ratures. sensor_type: temperature_mcu #sensor_mcu: mcu # Le micro-contr\u00f4leur \u00e0 lire. La valeur par d\u00e9faut est \"mcu\". #sensor_temperature1: #sensor_adc1: # Sp\u00e9cifiez les deux param\u00e8tres ci-dessus (une temp\u00e9rature en Celsius et une valeur d' ADC sous # forme de flottant entre 0,0 et 1,0) pour calibrer la temp\u00e9rature du microcontr\u00f4leur. Cela peut # am\u00e9liorer la pr\u00e9cision de la temp\u00e9rature rapport\u00e9e sur certaines puces. Une fa\u00e7on typique d'obtenir # ces informations d'\u00e9talonnage est de couper compl\u00e8tement l'alimentation de l'imprimante pendant # quelques heures (afin de s'assurer qu'elle est \u00e0 la temp\u00e9rature ambiante), puis de la remettre sous # tension et d'utiliser la fonction QUERY_ADC pour obtenir une mesure ADC. # Utilisez un autre capteur de temp\u00e9rature sur l'imprimante pour trouver la temp\u00e9rature ambiante # correspondante. La valeur par d\u00e9faut est d'utiliser les donn\u00e9es d'\u00e9talonnage d'usine du microcontr\u00f4leur # (le cas \u00e9ch\u00e9ant) ou les valeurs nominales de la sp\u00e9cification du microcontr\u00f4leur. #sensor_temperature2: #sensor_adc2: # Si sensor_temperature1/sensor_adc1 est sp\u00e9cifi\u00e9, on peut \u00e9galement sp\u00e9cifier les donn\u00e9es # d'\u00e9talonnage de sensor_temperature2/sensor_adc2. En proc\u00e9dant ainsi on peut fournir des # informations calibr\u00e9es sur la \"pente de temp\u00e9rature\". La valeur par d\u00e9faut est d'utiliser les donn\u00e9es # d'\u00e9talonnage d'usine sur le microcontr\u00f4leur (le cas \u00e9ch\u00e9ant) ou les valeurs nominales de la # sp\u00e9cification du microcontr\u00f4leur.","title":"Capteur de temp\u00e9rature int\u00e9gr\u00e9 au microcontr\u00f4leur"},{"location":"Config_Reference.html#capteur-de-temperature-de-lhote","text":"Temp\u00e9rature de la machine (par exemple Raspberry Pi) ex\u00e9cutant le logiciel h\u00f4te. sensor_type: temperature_host #sensor_path: # Le chemin d'acc\u00e8s au fichier syst\u00e8me de temp\u00e9rature. La valeur par d\u00e9faut est # \" /sys/class/thermal/thermal_zone0/temp \" qui est le fichier syst\u00e8me de # temp\u00e9rature sur un ordinateur Raspberry Pi.","title":"Capteur de temp\u00e9rature de l'h\u00f4te"},{"location":"Config_Reference.html#capteur-de-temperature-ds18b20","text":"Le DS18B20 est un capteur de temp\u00e9rature num\u00e9rique \u00e0 1 fil (w1). Notez que ce capteur n'est pas destin\u00e9 \u00e0 \u00eatre utilis\u00e9 avec les extrudeurs et les lits chauffants, mais plut\u00f4t pour surveiller la temp\u00e9rature ambiante (C). Ces capteurs ont une port\u00e9e allant jusqu'\u00e0 125 \u00b0C et sont donc utilisables pour la surveillance de la temp\u00e9rature d'un caisson par exemple. Ils peuvent \u00e9galement fonctionner comme de simples contr\u00f4leurs de ventilateurs/\u00e9l\u00e9ments chauffants. Les capteurs DS18B20 ne sont support\u00e9s que par un \"mcu h\u00f4te\", par exemple le Raspberry Pi. Le module w1-gpio du noyau Linux doit \u00eatre install\u00e9. sensor_type: DS18B20 serial_no: # Chaque dispositif \u00e0 1-wire poss\u00e8de un num\u00e9ro de s\u00e9rie unique utilis\u00e9 pour l'identifier, # g\u00e9n\u00e9ralement au format 28-031674b175ff. Ce param\u00e8tre doit \u00eatre fourni. # Les p\u00e9riph\u00e9riques 1-wire connect\u00e9s peuvent \u00eatre list\u00e9s \u00e0 l'aide de la commande Linux suivante : # ls /sys/bus/w1/devices/ #ds18_report_time: # Intervalle en secondes entre les lectures. La valeur par d\u00e9faut est de 3,0, avec un minimum de 1,0. #sensor_mcu: # Le micro-contr\u00f4leur \u00e0 lire. Doit \u00eatre le host_mcu","title":"Capteur de temp\u00e9rature DS18B20"},{"location":"Config_Reference.html#combined-temperature-sensor","text":"Combined temperature sensor is a virtual temperature sensor based on several other sensors. This sensor can be used with extruders, heater_generic and heater beds. sensor_type: temperature_combined #sensor_list: # Must be provided. List of sensors to combine to new \"virtual\" # sensor. # E.g. 'temperature_sensor sensor1,extruder,heater_bed' #combination_method: # Must be provided. Combination method used for the sensor. # Available options are 'max', 'min', 'mean'. #maximum_deviation: # Must be provided. Maximum permissible deviation between the sensors # to combine (e.g. 5 degrees). To disable it, use a large value (e.g. 999.9)","title":"Combined temperature sensor"},{"location":"Config_Reference.html#ventilateurs","text":"","title":"Ventilateurs"},{"location":"Config_Reference.html#fan","text":"Ventilateur de refroidissement de la pi\u00e8ce. [fan] pin: # Broche de sortie contr\u00f4lant le ventilateur. Ce param\u00e8tre doit \u00eatre fourni. #max_power: 1.0 # La puissance maximale (exprim\u00e9e en tant que valeur comprise entre 0,0 et 1,0) \u00e0 laquelle # r\u00e9gler la broche. La valeur 1.0 permet de r\u00e9gler la broche enti\u00e8rement activ\u00e9e pendant de # longues p\u00e9riodes, tandis qu'une valeur de 0,5 permet \u00e0 la broche de n'\u00eatre activ\u00e9e que # durant la moiti\u00e9 du temps au maximum. Ce param\u00e8tre peut \u00eatre utilis\u00e9 pour limiter la # puissance totale de sortie (sur des p\u00e9riodes prolong\u00e9es) du ventilateur. # Si cette valeur est inf\u00e9rieure \u00e0 1,0, les demandes de vitesse du ventilateur seront mises \u00e0 # l'\u00e9chelle entre z\u00e9ro et max_power (par exemple, si la puissance maximale est de 0,9 et # qu'une vitesse de 80 % est demand\u00e9e, la puissance du ventilateur sera r\u00e9gl\u00e9e \u00e0 72 %. # La valeur par d\u00e9faut est 1.0. #shutdown_speed: 0 # La vitesse souhait\u00e9e du ventilateur (exprim\u00e9e comme une valeur de 0,0 \u00e0 1,0) si # le logiciel du microcontr\u00f4leur passe dans un \u00e9tat d'erreur. La valeur par d\u00e9faut # est 0. #cycle_time: 0.010 # La dur\u00e9e (en secondes) de chaque cycle d'alimentation PWM du ventilateur. Il est # recommand\u00e9 que cette dur\u00e9e soit de 10 millisecondes ou plus si vous utilisez un PWM logiciel. # La valeur par d\u00e9faut est de 0,010 seconde. #hardware_pwm: False # Activez ceci pour utiliser le PWM mat\u00e9riel au lieu du PWM logiciel. La plupart des ventilateurs # ne fonctionnent pas correctement avec le PWM mat\u00e9riel, il n'est donc pas recommand\u00e9 # d'activer cette option \u00e0 moins qu'il n'y ait une exigence \u00e9lectrique pour obtenir une tr\u00e8s haute # vitesse. Lorsque vous utilisez le PWM mat\u00e9riel, le temps de cycle r\u00e9el est contraint par la mise # en \u0153uvre et peut \u00eatre significativement diff\u00e9rent du temps de cycle demand\u00e9. # La valeur par d\u00e9faut est False. #kick_start_time: 0.100 # Dur\u00e9e (en secondes) de fonctionnement du ventilateur \u00e0 pleine vitesse, soit lors de sa premi\u00e8re # activation soit lors d'une augmentation de plus de 50% (pour faire tourner le ventilateur). # La valeur par d\u00e9faut est de 0,100 seconde. #off_below: 0.0 # La vitesse d'entr\u00e9e minimale qui alimentera le ventilateur (exprim\u00e9e comme une valeur # comprise entre 0,0 et 1,0). Quand une vitesse inf\u00e9rieure \u00e0 off_below est demand\u00e9e le ventilateur # sera d\u00e9sactiv\u00e9. Ce r\u00e9glage peut \u00eatre utilis\u00e9 pour \u00e9viter que le ventilateur ne cale et pour # garantir que les d\u00e9marrages sont efficaces. # La valeur par d\u00e9faut est 0.0. # # Ce param\u00e8tre doit \u00eatre recalibr\u00e9 chaque fois que max_power est ajust\u00e9. # Pour calibrer ce param\u00e8tre, commencez avec off_below r\u00e9gl\u00e9 sur 0.0 et ventilateur tournant. Diminuez # progressivement la vitesse du ventilateur afin de d\u00e9terminer la vitesse d'entr\u00e9e la plus faible entra\u00eenant # le ventilateur de mani\u00e8re fiable sans d\u00e9crochage. R\u00e9glez off_below au rapport cyclique correspondant # \u00e0 cette valeur (par exemple, 12% -> 0,12) ou l\u00e9g\u00e8rement plus. #tachometer_pin: # Broche d'entr\u00e9e tachym\u00e9trique de surveillance de la vitesse du ventilateur. Un pullup est g\u00e9n\u00e9ralement # n\u00e9cessaire. Ce param\u00e8tre est facultatif. #tachometer_ppr: 2 # Lorsque tachometer_pin est sp\u00e9cifi\u00e9, il s'agit du nombre d'impulsions par r\u00e9volution du signal # tachym\u00e9trique. Pour un ventilateur BLDC, c'est normalement la moiti\u00e9 du nombre de p\u00f4les. # La valeur par d\u00e9faut est 2. #tachometer_poll_interval: 0.0015 # Lorsque tachometer_pin est sp\u00e9cifi\u00e9, il s'agit de la p\u00e9riode d'interrogation de la broche tachym\u00e9trique, # en secondes. La valeur par d\u00e9faut est 0.0015, ce qui est suffisamment rapide pour des ventilateurs de # moins de 10000 RPM \u00e0 2 PPR. Cette valeur doit \u00eatre inf\u00e9rieure \u00e0 30/(tachometer_ppr*rpm), avec une # certaine marge, o\u00f9 rpm est la vitesse maximale (en RPM) du ventilateur. #enable_pin: # Broche optionnelle pour d'activation de l'alimentation du ventilateur. Cela peut \u00eatre utile pour les # ventilateurs avec des entr\u00e9es PWM d\u00e9di\u00e9es. Certains de ces ventilateurs restent allum\u00e9s m\u00eame \u00e0 0 % # de PWM. Dans ce cas, la broche PWM peut \u00eatre utilis\u00e9e normalement et, par exemple, un FET commut\u00e9 # \u00e0 la masse (broche de ventilateur standard) peut \u00eatre utilis\u00e9 pour contr\u00f4ler l'alimentation du ventilateur.","title":"[fan]"},{"location":"Config_Reference.html#heater_fan","text":"Ventilateurs de chauffage (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"heater_fan\"). Un \"ventilateur de chauffage\" est un ventilateur activ\u00e9 lorsque le chauffage qui lui est associ\u00e9 est actif. Par d\u00e9faut, un heater_fan a une vitesse d'arr\u00eat \u00e9gale \u00e0 la puissance maximale. [heater_fan heatbreak_cooling_fan] #pin: #max_power: #shutdown_speed: #cycle_time: #hardware_pwm: #kick_start_time: #off_below: #tachometer_pin: #tachometer_ppr: #tachometer_poll_interval: #enable_pin: # See the \"fan\" section for a description of the above parameters. #heater: extruder # Name of the config section defining the heater that this fan is # associated with. If a comma separated list of heater names is # provided here, then the fan will be enabled when any of the given # heaters are enabled. The default is \"extruder\". #heater_temp: 50.0 # A temperature (in Celsius) that the heater must drop below before # the fan is disabled. The default is 50 Celsius. #fan_speed: 1.0 # The fan speed (expressed as a value from 0.0 to 1.0) that the fan # will be set to when its associated heater is enabled. The default # is 1.0","title":"[heater_fan]"},{"location":"Config_Reference.html#controller_fan","text":"Ventilateur de refroidissement du contr\u00f4leur (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"controller_fan\"). Un \"ventilateur de contr\u00f4leur\" est un ventilateur activ\u00e9 chaque fois que l'\u00e9l\u00e9ment chauffant ou le pilote pas \u00e0 pas qui lui est associ\u00e9 est actif. Le ventilateur s'arr\u00eatera chaque fois qu'un idle_timeout sera atteint afin de garantir qu'aucune surchauffe ne se produise apr\u00e8s la d\u00e9sactivation d'un composant surveill\u00e9. [controller_fan my_controller_fan] #pin: #max_power: #shutdown_speed: #cycle_time: #hardware_pwm: #kick_start_time: #off_below: #tachometer_pin: #tachometer_ppr: #tachometer_poll_interval: #enable_pin: # Voir la section \"fan\" pour une description des param\u00e8tres ci-dessus. #fan_speed: 1.0 # Vitesse du ventilateur (exprim\u00e9e comme une valeur de 0,0 \u00e0 1,0) \u00e0 laquelle celui-ci # sera r\u00e9gl\u00e9 lorsqu'un chauffage ou un pilote pas \u00e0 pas est actif. # La valeur par d\u00e9faut est 1.0 #idle_timeout: # Dur\u00e9e (en secondes) apr\u00e8s activit\u00e9 d'un pilote pas \u00e0 pas ou d'un \u00e9l\u00e9ment chauffant # pour laquelle le ventilateur doit continuer de fonctionner. La valeur par d\u00e9faut # est de 30 secondes. #idle_speed: # Vitesse du ventilateur (exprim\u00e9e comme une valeur de 0,0 et 1,0) \u00e0 laquelle le r\u00e9gler # lors de l'activit\u00e9 d'une chauffe ou d'un pilote pas \u00e0 pas avant que le d\u00e9lai d'attente # idle_timeout ne soit atteint. La valeur par d\u00e9faut est fan_speed. #heater: #stepper : # Nom de la section de configuration d\u00e9finissant l'\u00e9l\u00e9ment chauffant/pilote auquel ce ventilateur # est associ\u00e9. Si une liste s\u00e9par\u00e9e par des virgules de noms d'\u00e9l\u00e9ments chauffants/pilotes est # fournie ici, le ventilateur s'activera lorsque l'un des \u00e9l\u00e9ments chauffants/pilotes donn\u00e9s est activ\u00e9. # Le chauffage par d\u00e9faut est \"extruder\", le pilote par d\u00e9faut est tous.","title":"[controller_fan]"},{"location":"Config_Reference.html#temperature_fan","text":"Ventilateurs de refroidissement d\u00e9clench\u00e9s en fonction de la temp\u00e9rature (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"temperature_fan\"). Un \"ventilateur de temp\u00e9rature\" est un ventilateur activ\u00e9 lorsque le capteur qui lui est associ\u00e9 est au-dessus d'une temp\u00e9rature d\u00e9finie. Par d\u00e9faut, un ventilateur de temp\u00e9rature a une vitesse d'arr\u00eat \u00e9gale \u00e0 la puissance maximale. Voir la r\u00e9f\u00e9rence des commandes pour plus d'informations. [temperature_fan my_temp_fan] #pin: #max_power: #shutdown_speed: #cycle_time: #hardware_pwm: #kick_start_time: #off_below: #tachometer_pin: #tachometer_ppr: #tachometer_poll_interval: #enable_pin: # Voir la section \"ventilateur\" pour une description des param\u00e8tres ci-dessus. #sensor_type: #sensor_pin: #control: #max_delta: #min_temp: #max_temp: # Voir la section \"extrudeuse\" pour une description des param\u00e8tres ci-dessus. #pid_Kp: #pid_Ki: #pid_Kd: # Les param\u00e8tres proportionnels (pid_Kp), int\u00e9graux (pid_Ki), et d\u00e9riv\u00e9s (pid_Ki) # du syst\u00e8me de contr\u00f4le par r\u00e9troaction PID. Klipper \u00e9value les param\u00e8tres PID # avec la formule g\u00e9n\u00e9rale suivante : # fan_pwm = max_power - (Kp*e + Ki*integral(e) - Kd*derivative(e)) / 255 # O\u00f9 \"e\" est \"temp\u00e9rature_cible - temp\u00e9rature_mesur\u00e9e\" et # \"fan_pwm\" est le d\u00e9bit du ventilateur demand\u00e9, 0,0 correspondant \u00e0 un arr\u00eat complet # et 1,0 correspond \u00e0 un fonctionnement \u00e0 plein r\u00e9gime. Les param\u00e8tres pid_Kp, pid_Ki, # et pid_Kd doivent \u00eatre fournis lorsque l'algorithme de contr\u00f4le PID est activ\u00e9. #pid_deriv_time: 2.0 # Une dur\u00e9e (en secondes) sur laquelle lisser les mesures de temp\u00e9rature lors de # l'utilisation de l'algorithme de contr\u00f4le PID. Cela peut r\u00e9duire l'impact du bruit de # mesure. La valeur par d\u00e9faut est de 2 secondes. #target_temp: 40.0 # Une temp\u00e9rature (en Celsius) qui sera la temp\u00e9rature cible. # La valeur par d\u00e9faut est 40 degr\u00e9s. #max_speed: 1.0 # La vitesse du ventilateur (exprim\u00e9e comme une valeur de 0,0 \u00e0 1,0) \u00e0 laquelle r\u00e9gler # le ventilateur lorsque la temp\u00e9rature du capteur d\u00e9passera la valeur d\u00e9finie. # La valeur par d\u00e9faut est 1.0. #min_speed: 0.3 # Vitesse minimale du ventilateur (exprim\u00e9e sous forme d'une valeur comprise entre 0,0 # et 1,0) \u00e0 laquelle r\u00e9gler le ventilateur pour les ventilateurs \u00e0 temp\u00e9rature PID. # La valeur par d\u00e9faut est 0,3. #gcode_id: # S'il est d\u00e9fini, la temp\u00e9rature sera signal\u00e9e dans les requ\u00eates M105 en utilisant l'identifiant # d'id donn\u00e9. La valeur par d\u00e9faut est de ne pas rapporter la temp\u00e9rature via M105.","title":"[temperature_fan]"},{"location":"Config_Reference.html#fan_generic","text":"Ventilateur command\u00e9 manuellement (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"fan_generic\"). La vitesse d'un ventilateur command\u00e9 manuellement est r\u00e9gl\u00e9e avec la commande SET_FAN_SPEED commandes G-Code . [fan_generic extruder_partfan] #pin: #max_power: #shutdown_speed: #cycle_time: #hardware_pwm: #kick_start_time: #off_below: #tachometer_pin: #tachometer_ppr: #tachometer_poll_interval: #enable_pin: # Voir la section \"ventilateur\" pour une description des param\u00e8tres ci-dessus.","title":"[fan_generic]"},{"location":"Config_Reference.html#leds","text":"","title":"LEDs"},{"location":"Config_Reference.html#led","text":"Prise en charge des LEDs (et des bandes de LEDs) contr\u00f4l\u00e9es par les broches PWM du microcontr\u00f4leur (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"led\"). Voir la r\u00e9f\u00e9rence de la commande pour plus d'informations. [led my_led] #red_pin: #green_pin: #blue_pin: #white_pin: # La broche contr\u00f4lant la couleur de la LED donn\u00e9e. Au moins un des param\u00e8tres ci-dessus # doit \u00eatre fourni. #cycle_time: 0.010 # Dur\u00e9e (en secondes) par cycle PWM. Il est recommand\u00e9 # que ce soit 10 millisecondes ou plus lorsque l'on utilise un PWM logiciel. # La valeur par d\u00e9faut est de 0,010 seconde. #hardware_pwm: False # Activez ceci pour utiliser le PWM mat\u00e9riel au lieu du PWM logiciel. Lors de # l'utilisation du PWM mat\u00e9riel, le temps de cycle r\u00e9el est contraint par # l'impl\u00e9mentation et peut \u00eatre significativement diff\u00e9rent du # cycle_time demand\u00e9. La valeur par d\u00e9faut est False. #initial_RED: 0.0 #initial_GREEN: 0.0 #initial_BLUE: 0.0 #initial_WHITE: 0.0 # D\u00e9finit la couleur initiale de la LED. Chaque valeur doit \u00eatre comprise entre 0.0 et # 1.0. La valeur par d\u00e9faut pour chaque couleur est 0.","title":"[led]"},{"location":"Config_Reference.html#neopixel","text":"Prise en charge des LED neopixel (alias WS2812) (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"neopixel\"). Voir la r\u00e9f\u00e9rence de commande pour plus d'informations. Notez que l'impl\u00e9mentation du mcu linux ne supporte pas actuellement les neopixels directement connect\u00e9s. La conception actuelle utilisant l'interface du noyau Linux ne permet pas ce sc\u00e9nario car l'interface GPIO du noyau n'est pas assez rapide pour fournir les taux d'impulsion requis. [neopixel my_neopixel] pin: # La broche connect\u00e9e au neopixel. Ce param\u00e8tre doit \u00eatre # fourni. #chain_count: # Le nombre de puces Neopixel connect\u00e9es en \"cha\u00eene\" \u00e0 la broche fournie. # La valeur par d\u00e9faut est 1 (ce qui indique qu'un seul Neopixel est connect\u00e9 \u00e0 la broche). #color_order: GRB # D\u00e9finit l'ordre des pixels requis par le mat\u00e9riel LED (en utilisant une cha\u00eene # contenant les lettres R, G, B, W avec W en option). Alternativement, il peut s'agir d'une liste # d'ordres de pixels s\u00e9par\u00e9s par des virgules - un pour chaque LED de la cha\u00eene. # La valeur par d\u00e9faut est GRB. #initial_RED: 0.0 #initial_GREEN: 0.0 #initial_BLUE: 0.0 #initial_WHITE: 0.0 # Voir la section \"led\" pour des informations sur ces param\u00e8tres.","title":"[neopixel]"},{"location":"Config_Reference.html#dotstar","text":"Prise en charge des LEDs Dotstar (alias APA102) (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"dotstar\"). Voir la r\u00e9f\u00e9rence de commande pour plus d'informations. [dotstar my_dotstar] data_pin: # La broche connect\u00e9e \u00e0 la ligne de donn\u00e9es du dotstar. Ce param\u00e8tre # doit \u00eatre fourni. clock_pin: # La broche connect\u00e9e \u00e0 la ligne d'horloge du dotstar. Ce param\u00e8tre # doit \u00eatre fourni. #chain_count: # Voir la section \"neopixel\" pour des informations sur ce param\u00e8tre. #initial_RED: 0.0 #initial_GREEN: 0.0 #initial_BLUE: 0.0 # Voir la section \"led\" pour des informations sur ces param\u00e8tres.","title":"[dotstar]"},{"location":"Config_Reference.html#pca9533","text":"Support de la LED PCA9533. Le PCA9533 est utilis\u00e9 sur la mightyboard. [pca9533 my_pca9533] #i2c_address: 98 # The i2c address that the chip is using on the i2c bus. Use 98 for # the PCA9533/1, 99 for the PCA9533/2. The default is 98. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #initial_RED: 0.0 #initial_GREEN: 0.0 #initial_BLUE: 0.0 #initial_WHITE: 0.0 # See the \"led\" section for information on these parameters.","title":"[pca9533]"},{"location":"Config_Reference.html#pca9632","text":"Support des LEDs du PCA9632. Le PCA9632 est utilis\u00e9 sur le FlashForge Dreamer. [pca9632 my_pca9632] #i2c_address: 98 # The i2c address that the chip is using on the i2c bus. This may be # 96, 97, 98, or 99. The default is 98. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #scl_pin: #sda_pin: # Alternatively, if the pca9632 is not connected to a hardware I2C # bus, then one may specify the \"clock\" (scl_pin) and \"data\" # (sda_pin) pins. The default is to use hardware I2C. #color_order: RGBW # Set the pixel order of the LED (using a string containing the # letters R, G, B, W). The default is RGBW. #initial_RED: 0.0 #initial_GREEN: 0.0 #initial_BLUE: 0.0 #initial_WHITE: 0.0 # See the \"led\" section for information on these parameters.","title":"[pca9632]"},{"location":"Config_Reference.html#servos-supplementaires-boutons-et-autres-broches","text":"","title":"Servos suppl\u00e9mentaires, boutons et autres broches"},{"location":"Config_Reference.html#servo","text":"Servos (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"servo\"). Les servos peuvent \u00eatre contr\u00f4l\u00e9s en utilisant la commande SET_SERVO g-code . Par exemple : SET_SERVO SERVO=my_servo ANGLE=180 [servo my_servo] pin: # Broche de sortie PWM contr\u00f4lant le servo. Ce param\u00e8tre doit \u00eatre # fourni. #maximum_servo_angle: 180 # L'angle maximum (en degr\u00e9s) auquel ce servo peut \u00eatre r\u00e9gl\u00e9. La valeur # par d\u00e9faut est de 180 degr\u00e9s. #minimum_pulse_width: 0.001 # La dur\u00e9e minimale de la largeur d'impulsion (en secondes). Cela devrait correspondre # avec un angle de 0 degr\u00e9. La valeur par d\u00e9faut est de 0,001 seconde. #maximum_pulse_width: 0.002 # La dur\u00e9e maximale de la largeur d'impulsion (en secondes). Cela devrait correspondre # avec l'angle de maximum_servo_angle. La valeur par d\u00e9faut est 0.002 secondes. #initial_angle: # Angle initial (en degr\u00e9s) sur lequel r\u00e9gler le servo. La valeur par d\u00e9faut est de # ne pas envoyer de signal au d\u00e9marrage. #initial_pulse_width: # Dur\u00e9e initiale de la largeur d'impulsion (en secondes) \u00e0 laquelle le servo doit \u00eatre r\u00e9gl\u00e9. (Ceci # n'est valable que si initial_angle n'est pas d\u00e9fini). La valeur par d\u00e9faut est de n'envoyer # aucun signal au d\u00e9marrage.","title":"[servo]"},{"location":"Config_Reference.html#gcode_button","text":"Ex\u00e9cute le gcode quand un bouton est press\u00e9 ou rel\u00e2ch\u00e9 (ou quand une broche change d'\u00e9tat). Vous pouvez v\u00e9rifier l'\u00e9tat du bouton en utilisant QUERY_BUTTON button=my_gcode_button . [gcode_button my_gcode_button] pin: # La broche sur laquelle le bouton est connect\u00e9. Ce param\u00e8tre doit \u00eatre # fourni. #analog_range: # Deux r\u00e9sistances s\u00e9par\u00e9es par des virgules (en Ohms) sp\u00e9cifiant la plage de # r\u00e9sistance minimale et maximale de la r\u00e9sistance du bouton. Si le param\u00e8tre # analog_range est fourni, la broche doit \u00eatre une broche \u00e0 capacit\u00e9 analogique. # La valeur par d\u00e9faut est d'utiliser un gpio num\u00e9rique pour le bouton. #analog_pullup_resistor: # La r\u00e9sistance d'excursion (en Ohms) lorsque la gamme analogique est sp\u00e9cifi\u00e9e. # La valeur par d\u00e9faut est 4700 ohms. #press_gcode: # Une liste de commandes G-Code \u00e0 ex\u00e9cuter lorsque le bouton est press\u00e9. # Les mod\u00e8les G-Code sont pris en charge. Ce param\u00e8tre doit \u00eatre fourni. #release_gcode: # Une liste de commandes G-code \u00e0 ex\u00e9cuter lorsque le bouton est rel\u00e2ch\u00e9. # Les mod\u00e8les G-Code sont support\u00e9s. La valeur par d\u00e9faut est de ne pas ex\u00e9cuter # de commandes lors du rel\u00e2chement d'un bouton.","title":"[gcode_button]"},{"location":"Config_Reference.html#output_pin","text":"Broches de sortie configurables \u00e0 l'ex\u00e9cution (on peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe \"output_pin\"). Les broches configur\u00e9es ici seront param\u00e9tr\u00e9es comme des broches de sortie modifiables au moment de l'ex\u00e9cution en utilisant des commandes g-code \u00e9tendues de type \"SET_PIN PIN=my_pin VALUE=.1\" [output_pin my_pin] pin: # La broche \u00e0 configurer comme une sortie. Ce param\u00e8tre doit \u00eatre # fourni. #pwm: False # D\u00e9finit si la broche de sortie doit \u00eatre capable de modulation de largeur d'impulsion. # Si ce param\u00e8tre est vrai, les champs de valeur doivent \u00eatre compris entre 0 et 1. # La valeur par d\u00e9faut est False. #static_value: # Si cette valeur est d\u00e9finie, la broche est affect\u00e9e \u00e0 cette valeur au d\u00e9marrage et # la broche ne peut pas \u00eatre modifi\u00e9e pendant l'ex\u00e9cution. Une broche statique utilise # l\u00e9g\u00e8rement moins de RAM dans le micro-contr\u00f4leur. Le d\u00e9faut est d'utiliser # la configuration des broches param\u00e9tr\u00e9es lors du d\u00e9marrage. #value: # La valeur \u00e0 donner initialement \u00e0 la broche pendant la configuration du MCU. # La valeur par d\u00e9faut est 0 (pour une tension basse). #shutdown_value: # La valeur \u00e0 donner \u00e0 la broche lors d'un \u00e9v\u00e9nement d'arr\u00eat du MCU. La valeur par # d\u00e9faut est 0 (pour une tension basse). #maximum_mcu_duration: # La dur\u00e9e maximale pendant laquelle une valeur de non-arr\u00eat peut \u00eatre pilot\u00e9e par # le MCUsans un accus\u00e9 de r\u00e9ception de l'h\u00f4te. # Si l'h\u00f4te ne peut pas suivre une mise \u00e0 jour, le MCU s'\u00e9teindra et mettra # toutes les broches \u00e0 leurs valeurs d'arr\u00eat respectives. # D\u00e9faut : 0 (d\u00e9sactiv\u00e9) # Les valeurs habituelles sont d'environ 5 secondes. #cycle_time: 0.100 # La dur\u00e9e (en secondes) par cycle PWM. Il est recommand\u00e9 que ce soit # 10 millisecondes ou plus lorsque vous utilisez un PWM logiciel. # La valeur par d\u00e9faut est de 0.100 secondes pour les broches PWM. #hardware_pwm: False # Activez pour utiliser le PWM mat\u00e9riel au lieu du PWM logiciel. Lors de # l'utilisation d'un PWM mat\u00e9riel, le temps de cycle r\u00e9el est limit\u00e9 par # l'impl\u00e9mentation et peut \u00eatre significativement diff\u00e9rent du # cycle_time demand\u00e9. La valeur par d\u00e9faut est False. #scale : # Ce param\u00e8tre peut \u00eatre utilis\u00e9 pour modifier la fa\u00e7on dont les param\u00e8tres 'value' # et 'shutdown_value' sont interpr\u00e9t\u00e9s pour les broches pwm. Si fourni, alors # le param\u00e8tre 'value' doit \u00eatre compris entre 0.0 et 'scale'. Cela peut \u00eatre utile # lors de la configuration d'une broche PWM contr\u00f4lant une r\u00e9f\u00e9rence de tension # d'un moteur pas \u00e0 pas. L''\u00e9chelle' peut \u00eatre d\u00e9finie sur l'intensit\u00e9 du moteur pas # \u00e0 pas \u00e9quivalent si le PWM \u00e9tait enti\u00e8rement activ\u00e9, et puis le param\u00e8tre 'value' # peut \u00eatre sp\u00e9cifi\u00e9 en utilisant l'intensit\u00e9 souhait\u00e9e pour le moteur pas \u00e0 pas. La # valeur par d\u00e9faut est de ne pas mettre \u00e0 l'\u00e9chelle le param\u00e8tre 'value'.","title":"[output_pin]"},{"location":"Config_Reference.html#static_digital_output","text":"Broches de sortie num\u00e9rique configur\u00e9es statiquement (on peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe \"static_digital_output\"). Les broches configur\u00e9es ici seront configur\u00e9es comme une sortie GPIO pendant la configuration du MCU. Elles ne peuvent pas \u00eatre modifi\u00e9es en cours d'ex\u00e9cution. [static_digital_output my_output_pins] pins: # Une liste de broches s\u00e9par\u00e9es par des virgules \u00e0 d\u00e9finir comme broches de sortie GPIO. La broche # sera d\u00e9finie \u00e0 un niveau haut, sauf si le nom de la broche est pr\u00e9c\u00e9d\u00e9 de \"!\". # Ce param\u00e8tre doit \u00eatre fourni.","title":"[static_digital_output]"},{"location":"Config_Reference.html#multi_pin","text":"Sorties \u00e0 broches multiples (on peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"multi_pin\"). Une sortie multi_pin cr\u00e9e un alias de broche interne pouvant modifier plusieurs broches de sortie chaque fois que la broche alias est d\u00e9finie. Par exemple, on peut d\u00e9finir un objet \"[multi_pin my_fan]\" contenant deux broches et ensuite d\u00e9finir \"pin=multi_pin:my_fan\" dans la section \"[fan]\" - \u00e0 chaque changement du ventilateur, les deux broches de sortie seront mises \u00e0 jour. Ces alias ne peuvent pas \u00eatre utilis\u00e9s avec des broches de moteur pas \u00e0 pas. [multi_pin my_multi_pin] pins: # Une liste s\u00e9par\u00e9e par des virgules des broches associ\u00e9es \u00e0 cet alias. Ce param\u00e8tre # doit \u00eatre fourni.","title":"[multi_pin]"},{"location":"Config_Reference.html#configuration-des-pilotes-pas-a-pas-tmc","text":"Configuration des pilotes de moteurs pas \u00e0 pas Trinamic en mode UART/SPI. Des informations suppl\u00e9mentaires sont disponibles dans le guide des pilotes TMC et dans la r\u00e9f\u00e9rence des commandes .","title":"Configuration des pilotes pas \u00e0 pas TMC"},{"location":"Config_Reference.html#tmc2130","text":"Configuration d' un pilote de moteur pas \u00e0 pas TMC2130 via le bus SPI. Pour utiliser cette fonctionnalit\u00e9, d\u00e9finissez une section de configuration avec un pr\u00e9fixe \"tmc2130\" suivi du nom de la section de configuration du moteur pas \u00e0 pas correspondant (par exemple, \"[tmc2130 stepper_x]\"). [tmc2130 stepper_x] cs_pin: # La broche correspondant \u00e0 la ligne de s\u00e9lection de puce de la TMC2130. Cette # broche sera mise \u00e0 l'\u00e9tat bas au d\u00e9but des messages SPI et remont\u00e9e \u00e0 l'\u00e9tat haut # apr\u00e8s la fin du message. Ce param\u00e8tre doit \u00eatre fourni. #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # Voir la section \"param\u00e8tres SPI communs\" pour une description des param\u00e8tres # ci-dessus. #chain_position: #chain_length: # Ces param\u00e8tres configurent une guirlande SPI. Les deux param\u00e8tres d\u00e9finissent la # position du pilote moteur dans la cha\u00eene et la longueur totale de la cha\u00eene. # La position 1 correspond au pilote moteur stepper qui se connecte au signal MOSI. # La valeur par d\u00e9faut est de ne pas utiliser de guirlande SPI. # Interpoler: True # Si true, active l'interpolation de pas (le pilote fera un pas interne \u00e0 un taux de 256 # micro-pas). Cette interpolation introduit une petite d\u00e9viation syst\u00e9mique de la # position - voir TMC_Drivers.md pour plus de d\u00e9tails. La valeur par d\u00e9faut est True. run_current: # Configuration de la quantit\u00e9 de courant (en amp\u00e8res RMS) que le pilote utilise # pendant le mouvement du moteur pas \u00e0 pas. Ce param\u00e8tre doit \u00eatre fourni. #hold_current: # Configuration de la quantit\u00e9 de courant (en amp\u00e8res RMS) que le pilote utilise # lorsque le moteur pas \u00e0 pas n'est pas en mouvement. La d\u00e9finition d'un hold_current # n'est pas recommand\u00e9e (voir TMC_Drivers.md pour plus de d\u00e9tails). La valeur par # d\u00e9faut est de ne pas r\u00e9duire le courant. #sense_resistor: 0.110 # La r\u00e9sistance (en ohms) de la r\u00e9sistance de d\u00e9tection du moteur. La valeur par d\u00e9faut # est de 0.110 ohms. #stealthchop_threshold: 0 # La vitesse (en mm/s) \u00e0 laquelle le seuil \"stealthChop\" doit \u00eatre fix\u00e9. Lorsque d\u00e9fini, le # mode \"stealthChop\" sera activ\u00e9 si la vitesse du moteur pas \u00e0 pas est inf\u00e9rieure \u00e0 cette # valeur. La valeur par d\u00e9faut est 0, ce qui d\u00e9sactive le mode \"stealthChop\". #driver_MSLUT0: 2863314260 #driver_MSLUT1: 1251300522 #driver_MSLUT2: 608774441 #driver_MSLUT3: 269500962 #driver_MSLUT4: 4227858431 #driver_MSLUT5: 3048961917 #driver_MSLUT6: 1227445590 #driver_MSLUT7: 4211234 #driver_W0: 2 #driver_W1: 1 #driver_W2: 1 #driver_W3: 1 #driver_X1: 128 #driver_X2: 255 #driver_X3: 255 #driver_START_SIN: 0 #driver_START_SIN90: 247 # Ces champs contr\u00f4lent directement les registres de la table des micro-pas. La table # d'ondes est sp\u00e9cifique \u00e0 chaque moteur et peut varier en fonction du courant. Une # configuration optimale aura un minimum d'artefacts d'impression caus\u00e9s par le # mouvement non lin\u00e9aire du moteur pas \u00e0 pas. Les valeurs sp\u00e9cifi\u00e9es ci-dessus sont # les valeurs par d\u00e9faut utilis\u00e9es par le pilote. La valeur doit \u00eatre sp\u00e9cifi\u00e9e sous la forme # d'un entier d\u00e9cimal (la forme hexad\u00e9cimale n'est pas prise en charge). Afin de calculer # les champs de la table d'onde, consultez la \"feuille de calcul\" tmc2130 sur le site # Web de Trinamic. #driver_IHOLDDELAY: 8 #driver_TPOWERDOWN: 0 #driver_TBL: 1 #driver_TOFF: 4 #driver_HEND: 7 #driver_HSTRT: 0 #driver_PWM_AUTOSCALE: True #driver_PWM_FREQ: 1 #driver_PWM_GRAD: 4 #driver_PWM_AMPL: 128 #driver_SGT: 0 # Permet de d\u00e9finir le registre donn\u00e9 pendant la configuration de la puce TMC2130. # Ceci peut \u00eatre utilis\u00e9 pour d\u00e9finir les param\u00e8tres personnalis\u00e9s du moteur. Les valeurs # par d\u00e9faut de chaque param\u00e8tre sont indiqu\u00e9es \u00e0 c\u00f4t\u00e9 du nom du param\u00e8tre dans la # liste ci-dessus. #diag0_pin: #diag1_pin: # La broche du microcontr\u00f4leur reli\u00e9e \u00e0 l'une des lignes DIAG de la puce TMC2130. # Une seule broche diag doit \u00eatre sp\u00e9cifi\u00e9e. La broche est \"active low\" et est donc # normalement pr\u00e9c\u00e9d\u00e9e de \"^ !\". Le r\u00e9glage de ceci cr\u00e9e une broche virtuelle # \"tmc2130_stepper_x:virtual_endstop\" pouvant \u00eatre utilis\u00e9e comme broche d'arr\u00eat # du moteur. Cela permet d'activer le \"sensorless homing\". (Assurez-vous de r\u00e9gler # \u00e9galement driver_SGT \u00e0 une valeur de sensibilit\u00e9 appropri\u00e9e). # La valeur par d\u00e9faut est de ne pas activer la recherche d'origine sans capteur.","title":"[tmc2130]"},{"location":"Config_Reference.html#tmc2208","text":"Configuration d'un pilote de moteur pas \u00e0 pas TMC2208 (ou TMC2224) via un UART \u00e0 fil unique. Pour utiliser cette fonctionnalit\u00e9, d\u00e9finissez une section de configuration avec un pr\u00e9fixe \"tmc2208\" suivi du nom de la section de configuration du moteur pas \u00e0 pas correspondant (par exemple, \"[tmc2208 stepper_x]\"). [tmc2208 stepper_x] uart_pin: # The pin connected to the TMC2208 PDN_UART line. This parameter # must be provided. #tx_pin: # If using separate receive and transmit lines to communicate with # the driver then set uart_pin to the receive pin and tx_pin to the # transmit pin. The default is to use uart_pin for both reading and # writing. #select_pins: # A comma separated list of pins to set prior to accessing the # tmc2208 UART. This may be useful for configuring an analog mux for # UART communication. The default is to not configure any pins. #interpolate: True # If true, enable step interpolation (the driver will internally # step at a rate of 256 micro-steps). This interpolation does # introduce a small systemic positional deviation - see # TMC_Drivers.md for details. The default is True. run_current: # The amount of current (in amps RMS) to configure the driver to use # during stepper movement. This parameter must be provided. #hold_current: # The amount of current (in amps RMS) to configure the driver to use # when the stepper is not moving. Setting a hold_current is not # recommended (see TMC_Drivers.md for details). The default is to # not reduce the current. #sense_resistor: 0.110 # The resistance (in ohms) of the motor sense resistor. The default # is 0.110 ohms. #stealthchop_threshold: 0 # The velocity (in mm/s) to set the \"stealthChop\" threshold to. When # set, \"stealthChop\" mode will be enabled if the stepper motor # velocity is below this value. The default is 0, which disables # \"stealthChop\" mode. #driver_MULTISTEP_FILT: True #driver_IHOLDDELAY: 8 #driver_TPOWERDOWN: 20 #driver_TBL: 2 #driver_TOFF: 3 #driver_HEND: 0 #driver_HSTRT: 5 #driver_PWM_AUTOGRAD: True #driver_PWM_AUTOSCALE: True #driver_PWM_LIM: 12 #driver_PWM_REG: 8 #driver_PWM_FREQ: 1 #driver_PWM_GRAD: 14 #driver_PWM_OFS: 36 # Set the given register during the configuration of the TMC2208 # chip. This may be used to set custom motor parameters. The # defaults for each parameter are next to the parameter name in the # above list.","title":"[tmc2208]"},{"location":"Config_Reference.html#tmc2209","text":"Configuration d'un pilote de moteur pas \u00e0 pas TMC2209 via un UART \u00e0 fil unique. Pour utiliser cette fonctionnalit\u00e9, d\u00e9finissez une section de configuration avec un pr\u00e9fixe \"tmc2209\" suivi du nom de la section de configuration du moteur pas \u00e0 pas correspondant (par exemple, \"[tmc2209 stepper_x]\"). [tmc2209 stepper_x] uart_pin: #tx_pin: #select_pins: #interpolate: True run_current: #hold_current: #sense_resistor: 0.110 #stealthchop_threshold: 0 # See the \"tmc2208\" section for the definition of these parameters. #uart_address: # The address of the TMC2209 chip for UART messages (an integer # between 0 and 3). This is typically used when multiple TMC2209 # chips are connected to the same UART pin. The default is zero. #driver_MULTISTEP_FILT: True #driver_IHOLDDELAY: 8 #driver_TPOWERDOWN: 20 #driver_TBL: 2 #driver_TOFF: 3 #driver_HEND: 0 #driver_HSTRT: 5 #driver_PWM_AUTOGRAD: True #driver_PWM_AUTOSCALE: True #driver_PWM_LIM: 12 #driver_PWM_REG: 8 #driver_PWM_FREQ: 1 #driver_PWM_GRAD: 14 #driver_PWM_OFS: 36 #driver_SGTHRS: 0 # Set the given register during the configuration of the TMC2209 # chip. This may be used to set custom motor parameters. The # defaults for each parameter are next to the parameter name in the # above list. #diag_pin: # The micro-controller pin attached to the DIAG line of the TMC2209 # chip. The pin is normally prefaced with \"^\" to enable a pullup. # Setting this creates a \"tmc2209_stepper_x:virtual_endstop\" virtual # pin which may be used as the stepper's endstop_pin. Doing this # enables \"sensorless homing\". (Be sure to also set driver_SGTHRS to # an appropriate sensitivity value.) The default is to not enable # sensorless homing.","title":"[tmc2209]"},{"location":"Config_Reference.html#tmc2660","text":"Configuration d'un pilote de moteur pas \u00e0 pas TMC2660 via le bus SPI. Pour utiliser cette fonctionnalit\u00e9, d\u00e9finissez une section de configuration avec un pr\u00e9fixe \"tmc2660\" suivi du nom de la section de configuration du moteur pas \u00e0 pas correspondant (par exemple, \"[tmc2660 stepper_x]\"). [tmc2660 stepper_x] cs_pin: # La broche correspondant \u00e0 la ligne de s\u00e9lection de la puce TMC2660. Cette # broche sera mise \u00e0 l'\u00e9tat bas au d\u00e9but des messages SPI et passera \u00e0 l'\u00e9tat # haut apr\u00e8s la fin du transfert du message. Ce param\u00e8tre doit \u00eatre fourni. #spi_speed: 4000000 # Fr\u00e9quence du bus SPI utilis\u00e9e pour communiquer avec le pilote de pas \u00e0 pas # TMC2660. La valeur par d\u00e9faut est 4000000. #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # Voir la section \"param\u00e8tres SPI communs\" pour une description des # param\u00e8tres ci-dessus. #interpolate: True # Si vrai, active l'interpolation par pas (le pilote fera un pas interne \u00e0 un taux # de 256 micro-pas). Cela ne fonctionne que si les micro-pas sont fix\u00e9s \u00e0 16. # L'interpolation introduit une petite d\u00e9viation de position syst\u00e9mique - voir # TMC_Drivers.md pour plus de d\u00e9tails. La valeur par d\u00e9faut est True. run_current: # La quantit\u00e9 de courant (en amp\u00e8res RMS) utilis\u00e9e par le pilote pendant le # d\u00e9placement du moteur pas \u00e0 pas. Ce param\u00e8tre doit \u00eatre fourni. #sense_resistor: # La r\u00e9sistance (en ohms) de la r\u00e9sistance de d\u00e9tection du moteur (Vr\u00e9f). Ce # param\u00e8tre doit \u00eatre fourni. #idle_current_percent 100 # Le pourcentage du courant de fonctionnement auquel le pilote pas \u00e0 pas # sera abaiss\u00e9 quand le d\u00e9lai d'inactivit\u00e9 expirera (vous devez configurer le # d\u00e9lai \u00e0 l'aide d'une section de configuration [idle_timeout]). Le courant sera # remont\u00e9 d\u00e8s que le moteur devra \u00e0 nouveau se d\u00e9placer. Assurez-vous de # d\u00e9finir une valeur suffisamment \u00e9lev\u00e9e pour que les moteurs ne perdent pas # leur position. Il y a \u00e9galement un petit d\u00e9lai avant que le courant ne soit remis, # il faut donc en tenir compte lors de demandes de mouvements rapides alors # que le pilote est inactif. La valeur par d\u00e9faut est 100 (aucune r\u00e9duction). #driver_TBL: 2 #driver_RNDTF: 0 #driver_HDEC: 0 #driver_CHM: 0 #driver_HEND: 3 #driver_HSTRT: 3 #driver_TOFF: 4 #driver_SEIMIN: 0 #driver_SEDN: 0 #driver_SEMAX: 0 #driver_SEUP: 0 #driver_SEMIN: 0 #driver_SFILT: 0 #driver_SGT: 0 #driver_SLPH: 0 #driver_SLPL: 0 #driver_DISS2G: 0 #driver_TS2G: 3 # D\u00e9finit les param\u00e8tres \u00e0 utiliser pendant la configuration de la puce TMC2660. # Ceci peut \u00eatre utilis\u00e9 pour d\u00e9finir des param\u00e8tres de pilote personnalis\u00e9s. Les # valeurs par d\u00e9faut de chaque param\u00e8tre sont indiqu\u00e9es \u00e0 c\u00f4t\u00e9 du nom du param\u00e8tre # dans la liste ci-dessus. Consultez la fiche technique du TMC2660 pour conna\u00eetre la # fonction de chaque param\u00e8tre ainsi que les restrictions sur les combinaisons de # param\u00e8tres. Soyez particuli\u00e8rement attentif au registre CHOPCONF, o\u00f9 le fait de # r\u00e9gler CHM \u00e0 soit z\u00e9ro, soit un, entra\u00eene des modifications de la disposition (le # premier bit de HDEC est interpr\u00e9t\u00e9 comme le MSB de HSTRT dans ce cas).","title":"[tmc2660]"},{"location":"Config_Reference.html#tmc2240","text":"Configure a TMC2240 stepper motor driver via SPI bus or UART. To use this feature, define a config section with a \"tmc2240\" prefix followed by the name of the corresponding stepper config section (for example, \"[tmc2240 stepper_x]\"). [tmc2240 stepper_x] cs_pin: # The pin corresponding to the TMC2240 chip select line. This pin # will be set to low at the start of SPI messages and raised to high # after the message completes. This parameter must be provided. #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. #uart_pin: # The pin connected to the TMC2240 DIAG1/SW line. If this parameter # is provided UART communication is used rather then SPI. #chain_position: #chain_length: # These parameters configure an SPI daisy chain. The two parameters # define the stepper position in the chain and the total chain length. # Position 1 corresponds to the stepper that connects to the MOSI signal. # The default is to not use an SPI daisy chain. #interpolate: True # If true, enable step interpolation (the driver will internally # step at a rate of 256 micro-steps). The default is True. run_current: # The amount of current (in amps RMS) to configure the driver to use # during stepper movement. This parameter must be provided. #hold_current: # The amount of current (in amps RMS) to configure the driver to use # when the stepper is not moving. Setting a hold_current is not # recommended (see TMC_Drivers.md for details). The default is to # not reduce the current. #rref: 12000 # The resistance (in ohms) of the resistor between IREF and GND. The # default is 12000. #stealthchop_threshold: 0 # The velocity (in mm/s) to set the \"stealthChop\" threshold to. When # set, \"stealthChop\" mode will be enabled if the stepper motor # velocity is below this value. The default is 0, which disables # \"stealthChop\" mode. #driver_MSLUT0: 2863314260 #driver_MSLUT1: 1251300522 #driver_MSLUT2: 608774441 #driver_MSLUT3: 269500962 #driver_MSLUT4: 4227858431 #driver_MSLUT5: 3048961917 #driver_MSLUT6: 1227445590 #driver_MSLUT7: 4211234 #driver_W0: 2 #driver_W1: 1 #driver_W2: 1 #driver_W3: 1 #driver_X1: 128 #driver_X2: 255 #driver_X3: 255 #driver_START_SIN: 0 #driver_START_SIN90: 247 #driver_OFFSET_SIN90: 0 # These fields control the Microstep Table registers directly. The optimal # wave table is specific to each motor and might vary with current. An # optimal configuration will have minimal print artifacts caused by # non-linear stepper movement. The values specified above are the default # values used by the driver. The value must be specified as a decimal integer # (hex form is not supported). In order to compute the wave table fields, # see the tmc2130 \"Calculation Sheet\" from the Trinamic website. # Additionally, this driver also has the OFFSET_SIN90 field which can be used # to tune a motor with unbalanced coils. See the `Sine Wave Lookup Table` # section in the datasheet for information about this field and how to tune # it. #driver_MULTISTEP_FILT: True #driver_IHOLDDELAY: 6 #driver_IRUNDELAY: 4 #driver_TPOWERDOWN: 10 #driver_TBL: 2 #driver_TOFF: 3 #driver_HEND: 2 #driver_HSTRT: 5 #driver_FD3: 0 #driver_TPFD: 4 #driver_CHM: 0 #driver_VHIGHFS: 0 #driver_VHIGHCHM: 0 #driver_DISS2G: 0 #driver_DISS2VS: 0 #driver_PWM_AUTOSCALE: True #driver_PWM_AUTOGRAD: True #driver_PWM_FREQ: 0 #driver_FREEWHEEL: 0 #driver_PWM_GRAD: 0 #driver_PWM_OFS: 29 #driver_PWM_REG: 4 #driver_PWM_LIM: 12 #driver_SGT: 0 #driver_SEMIN: 0 #driver_SEUP: 0 #driver_SEMAX: 0 #driver_SEDN: 0 #driver_SEIMIN: 0 #driver_SFILT: 0 #driver_SG4_ANGLE_OFFSET: 1 # Set the given register during the configuration of the TMC2240 # chip. This may be used to set custom motor parameters. The # defaults for each parameter are next to the parameter name in the # above list. #diag0_pin: #diag1_pin: # The micro-controller pin attached to one of the DIAG lines of the # TMC2240 chip. Only a single diag pin should be specified. The pin # is \"active low\" and is thus normally prefaced with \"^!\". Setting # this creates a \"tmc2240_stepper_x:virtual_endstop\" virtual pin # which may be used as the stepper's endstop_pin. Doing this enables # \"sensorless homing\". (Be sure to also set driver_SGT to an # appropriate sensitivity value.) The default is to not enable # sensorless homing.","title":"[tmc2240]"},{"location":"Config_Reference.html#tmc5160","text":"Configuration d'un pilote de moteur pas \u00e0 pas TMC5160 via le bus SPI. Pour utiliser cette fonctionnalit\u00e9, d\u00e9finissez une section de configuration avec un pr\u00e9fixe \"tmc5160\" suivi du nom de la section de configuration du moteur pas \u00e0 pas correspondant (par exemple, \"[tmc5160 stepper_x]\"). [tmc5160 stepper_x] cs_pin: # The pin corresponding to the TMC5160 chip select line. This pin # will be set to low at the start of SPI messages and raised to high # after the message completes. This parameter must be provided. #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # See the \"common SPI settings\" section for a description of the # above parameters. #chain_position: #chain_length: # These parameters configure an SPI daisy chain. The two parameters # define the stepper position in the chain and the total chain length. # Position 1 corresponds to the stepper that connects to the MOSI signal. # The default is to not use an SPI daisy chain. #interpolate: True # If true, enable step interpolation (the driver will internally # step at a rate of 256 micro-steps). The default is True. run_current: # The amount of current (in amps RMS) to configure the driver to use # during stepper movement. This parameter must be provided. #hold_current: # The amount of current (in amps RMS) to configure the driver to use # when the stepper is not moving. Setting a hold_current is not # recommended (see TMC_Drivers.md for details). The default is to # not reduce the current. #sense_resistor: 0.075 # The resistance (in ohms) of the motor sense resistor. The default # is 0.075 ohms. #stealthchop_threshold: 0 # The velocity (in mm/s) to set the \"stealthChop\" threshold to. When # set, \"stealthChop\" mode will be enabled if the stepper motor # velocity is below this value. The default is 0, which disables # \"stealthChop\" mode. #driver_MSLUT0: 2863314260 #driver_MSLUT1: 1251300522 #driver_MSLUT2: 608774441 #driver_MSLUT3: 269500962 #driver_MSLUT4: 4227858431 #driver_MSLUT5: 3048961917 #driver_MSLUT6: 1227445590 #driver_MSLUT7: 4211234 #driver_W0: 2 #driver_W1: 1 #driver_W2: 1 #driver_W3: 1 #driver_X1: 128 #driver_X2: 255 #driver_X3: 255 #driver_START_SIN: 0 #driver_START_SIN90: 247 # These fields control the Microstep Table registers directly. The optimal # wave table is specific to each motor and might vary with current. An # optimal configuration will have minimal print artifacts caused by # non-linear stepper movement. The values specified above are the default # values used by the driver. The value must be specified as a decimal integer # (hex form is not supported). In order to compute the wave table fields, # see the tmc2130 \"Calculation Sheet\" from the Trinamic website. #driver_MULTISTEP_FILT: True #driver_IHOLDDELAY: 6 #driver_TPOWERDOWN: 10 #driver_TBL: 2 #driver_TOFF: 3 #driver_HEND: 2 #driver_HSTRT: 5 #driver_FD3: 0 #driver_TPFD: 4 #driver_CHM: 0 #driver_VHIGHFS: 0 #driver_VHIGHCHM: 0 #driver_DISS2G: 0 #driver_DISS2VS: 0 #driver_PWM_AUTOSCALE: True #driver_PWM_AUTOGRAD: True #driver_PWM_FREQ: 0 #driver_FREEWHEEL: 0 #driver_PWM_GRAD: 0 #driver_PWM_OFS: 30 #driver_PWM_REG: 4 #driver_PWM_LIM: 12 #driver_SGT: 0 #driver_SEMIN: 0 #driver_SEUP: 0 #driver_SEMAX: 0 #driver_SEDN: 0 #driver_SEIMIN: 0 #driver_SFILT: 0 #driver_DRVSTRENGTH: 0 #driver_BBMCLKS: 4 #driver_BBMTIME: 0 #driver_FILT_ISENSE: 0 # Set the given register during the configuration of the TMC5160 # chip. This may be used to set custom motor parameters. The # defaults for each parameter are next to the parameter name in the # above list. #diag0_pin: #diag1_pin: # The micro-controller pin attached to one of the DIAG lines of the # TMC5160 chip. Only a single diag pin should be specified. The pin # is \"active low\" and is thus normally prefaced with \"^!\". Setting # this creates a \"tmc5160_stepper_x:virtual_endstop\" virtual pin # which may be used as the stepper's endstop_pin. Doing this enables # \"sensorless homing\". (Be sure to also set driver_SGT to an # appropriate sensitivity value.) The default is to not enable # sensorless homing.","title":"[tmc5160]"},{"location":"Config_Reference.html#configuration-du-courant-du-moteur-pas-a-pas-en-temps-reel","text":"","title":"Configuration du courant du moteur pas \u00e0 pas en temps r\u00e9el"},{"location":"Config_Reference.html#ad5206","text":"Digipots AD5206 configur\u00e9s statiquement et connect\u00e9s via un bus SPI (on peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe \"ad5206\"). [ad5206 my_digipot] enable_pin: # La broche correspondant \u00e0 la ligne de s\u00e9lection de la puce AD5206. Cette broche # sera r\u00e9gl\u00e9e \u00e0 un niveau bas au d\u00e9but des messages SPI et sera relev\u00e9e \u00e0 un niveau \u00e9lev\u00e9 # apr\u00e8s la fin du message. Ce param\u00e8tre doit \u00eatre fourni. #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # Voir la section \"param\u00e8tres communs SPI\" pour une description des param\u00e8tres ci-dessus. # #channel_1: #channel_2: #channel_3: #channel_4: #channel_5: #channel_6: # La valeur pour d\u00e9finir statiquement le canal AD5206 donn\u00e9. Cette valeur est # g\u00e9n\u00e9ralement d\u00e9finie sur un nombre compris entre 0,0 et 1,0. 1,0 \u00e9tant la r\u00e9sistance # la plus \u00e9lev\u00e9e et 0,0 la r\u00e9sistance la plus faible. Cependant, la plage peut \u00eatre # modifi\u00e9e \u00e0 l'aide du param\u00e8tre 'scale' (voir ci-dessous). # Si un canal n'est pas sp\u00e9cifi\u00e9, il n'est pas configur\u00e9. # scale: # Ce param\u00e8tre peut \u00eatre utilis\u00e9 pour modifier l'interpr\u00e9tation des param\u00e8tres 'channel_x'. # S'il est fourni, alors les param\u00e8tres 'channel_x' doivent \u00eatre compris entre 0.0 et 'scale'. # Cela peut \u00eatre utile lorsque le AD5206 est utilis\u00e9 pour d\u00e9finir des r\u00e9f\u00e9rences de tension # pas \u00e0 pas. L''\u00e9chelle' peut \u00eatre r\u00e9gl\u00e9e sur l'intensit\u00e9 \u00e9quivalente de la commande pas \u00e0 pas # si l'AD5206 \u00e9tait \u00e0 sa r\u00e9sistance la plus \u00e9lev\u00e9e, puis les param\u00e8tres 'channel_x' peuvent \u00eatre # sp\u00e9cifi\u00e9s en utilisant la valeur d'intensit\u00e9 d\u00e9sir\u00e9e pour le pilote pas \u00e0 pas. La configuration # par d\u00e9faut est de ne pas mettre \u00e0 l'\u00e9chelle les param\u00e8tres 'channel_x'.","title":"[ad5206]"},{"location":"Config_Reference.html#mcp4451","text":"Digipot MCP4451 configur\u00e9 statiquement et connect\u00e9 via le bus I2C (on peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe \"mcp4451\"). [mcp4451 my_digipot] i2c_address: # The i2c address that the chip is using on the i2c bus. This # parameter must be provided. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #wiper_0: #wiper_1: #wiper_2: #wiper_3: # The value to statically set the given MCP4451 \"wiper\" to. This is # typically set to a number between 0.0 and 1.0 with 1.0 being the # highest resistance and 0.0 being the lowest resistance. However, # the range may be changed with the 'scale' parameter (see below). # If a wiper is not specified then it is left unconfigured. #scale: # This parameter can be used to alter how the 'wiper_x' parameters # are interpreted. If provided, then the 'wiper_x' parameters should # be between 0.0 and 'scale'. This may be useful when the MCP4451 is # used to set stepper voltage references. The 'scale' can be set to # the equivalent stepper amperage if the MCP4451 were at its highest # resistance, and then the 'wiper_x' parameters can be specified # using the desired amperage value for the stepper. The default is # to not scale the 'wiper_x' parameters.","title":"[mcp4451]"},{"location":"Config_Reference.html#mcp4728","text":"Convertisseur num\u00e9rique-analogique MCP4728 configur\u00e9 statiquement et connect\u00e9 via le bus I2C (on peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe \"mcp4728\"). [mcp4728 my_dac] #i2c_address: 96 # The i2c address that the chip is using on the i2c bus. The default # is 96. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters. #channel_a: #channel_b: #channel_c: #channel_d: # The value to statically set the given MCP4728 channel to. This is # typically set to a number between 0.0 and 1.0 with 1.0 being the # highest voltage (2.048V) and 0.0 being the lowest voltage. # However, the range may be changed with the 'scale' parameter (see # below). If a channel is not specified then it is left # unconfigured. #scale: # This parameter can be used to alter how the 'channel_x' parameters # are interpreted. If provided, then the 'channel_x' parameters # should be between 0.0 and 'scale'. This may be useful when the # MCP4728 is used to set stepper voltage references. The 'scale' can # be set to the equivalent stepper amperage if the MCP4728 were at # its highest voltage (2.048V), and then the 'channel_x' parameters # can be specified using the desired amperage value for the # stepper. The default is to not scale the 'channel_x' parameters.","title":"[mcp4728]"},{"location":"Config_Reference.html#mcp4018","text":"Digipot MCP4018 configur\u00e9 statiquement et connect\u00e9 via deux broches gpio \"bit banging\" (on peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe \"mcp4018\"). [mcp4018 my_digipot] scl_pin: # La broche d'horloge SCL. Ce param\u00e8tre doit \u00eatre fourni. sda_pin: # La broche de \"donn\u00e9es\" SDA. Ce param\u00e8tre doit \u00eatre fourni. wiper: # La valeur \u00e0 laquelle d\u00e9finir statiquement le \"wiper\" MCP4018 donn\u00e9. Ce param\u00e8tre est # g\u00e9n\u00e9ralement r\u00e9gl\u00e9e sur un nombre compris entre 0,0 et 1,0, 1,0 \u00e9tant la r\u00e9sistance # la plus \u00e9lev\u00e9e et 0.0 la r\u00e9sistance la plus faible. Cependant, la plage peut \u00eatre modifi\u00e9e \u00e0 # l'aide du param\u00e8tre 'scale' (voir ci-dessous). Ce param\u00e8tre doit \u00eatre fourni. #scale: # Ce param\u00e8tre peut \u00eatre utilis\u00e9 pour modifier l'interpr\u00e9tation du param\u00e8tre 'wiper'. # S'il est fourni, le param\u00e8tre 'wiper' doit se situer entre 0,0 et 'scale'. Ceci peut \u00eatre utile # lorsque le MCP4018 est utilis\u00e9 pour d\u00e9finir des r\u00e9f\u00e9rences de tension pas \u00e0 pas. # L''\u00e9chelle' peut \u00eatre r\u00e9gl\u00e9e sur l'intensit\u00e9 du pilote pas \u00e0 pas \u00e9quivalent si le MCP4018 # est \u00e0 sa plus grande# r\u00e9sistance la plus \u00e9lev\u00e9e, puis le param\u00e8tre 'wiper' peut \u00eatre sp\u00e9cifi\u00e9 # en utilisant la valeur d'intensit\u00e9 d\u00e9sir\u00e9e pour le pilote pas \u00e0 pas. La valeur par d\u00e9faut est # de ne pas mettre \u00e0 l'\u00e9chelle le param\u00e8tre 'wiper'.","title":"[mcp4018]"},{"location":"Config_Reference.html#prise-en-charge-de-laffichage","text":"","title":"Prise en charge de l'affichage"},{"location":"Config_Reference.html#display","text":"Prise en charge d'un \u00e9cran reli\u00e9 au microcontr\u00f4leur. [display] lcd_type: # Le type de puce LCD utilis\u00e9. Cela peut \u00eatre \"hd44780\", \"hd44780_spi\", \"st7920\", # \"emulated_st7920\", \"uc1701\", \"ssd1306\", ou \"sh1106\". # Voir les sections d'affichage ci-dessous pour plus d'informations sur chaque type # et les param\u00e8tres suppl\u00e9mentaires qu'ils fournissent. Ce param\u00e8tre doit \u00eatre # fourni. #display_group: # Le nom du groupe de donn\u00e9es \u00e0 afficher sur l'\u00e9cran. Cela contr\u00f4le le contenu de # l'\u00e9cran (voir la section \"display_data\" pour plus d'informations). La valeur par # d\u00e9faut est _default_20x4 pour les \u00e9crans hd44780 et _default_16x4 pour les # autres affichages. #menu_timeout: # D\u00e9lai d'attente pour le menu. Le fait d'\u00eatre inactif pendant ce nombre de secondes # d\u00e9clenchera la sortie du menu ou le retour au menu racine si l'autorun est activ\u00e9. # La valeur par d\u00e9faut est 0 seconde (d\u00e9sactiv\u00e9) #menu_root: # Nom de la section du menu principal \u00e0 afficher lorsque vous cliquez sur l'encodeur # de l'\u00e9cran d'accueil. La valeur par d\u00e9faut est __main, et cela affiche les menus par # d\u00e9faut tels que d\u00e9finis dans klippy/extras/display/menu.cfg #menu_reverse_navigation: # Lorsque activ\u00e9, inverse les directions vers le haut et vers le bas de la liste. # La valeur par d\u00e9faut est False. Ce param\u00e8tre est optionnel. #encoder_pins: # Les broches connect\u00e9es \u00e0 l'encodeur. 2 broches doivent \u00eatre fournies lorsque vous # utilisez l'encodeur. Ce param\u00e8tre doit \u00eatre fourni lors de l'utilisation du menu. #encoder_steps_per_detent: # Combien de pas l'encodeur \u00e9met par cran (\"clic\"). Si l'encodeur prend deux crans pour # se d\u00e9placer entre les entr\u00e9es ou d\u00e9place deux entr\u00e9es \u00e0 partir d'un seul cran, essayez de # modifier cette valeur. Les valeurs autoris\u00e9es sont 2 (demi-step) ou 4 (full-step). # La valeur par d\u00e9faut est 4. #click_pin: # La broche connect\u00e9e au bouton 'entr\u00e9e' ou au 'clic' de l'encodeur. Ce param\u00e8tre doit # \u00eatre fourni lors de l'utilisation du menu. La pr\u00e9sence d'un param\u00e8tre de configuration # 'analog_range_click_pin' fait passer ce param\u00e8tre de num\u00e9rique \u00e0 analogique. #back_pin: # La broche connect\u00e9e au bouton 'retour'. Ce param\u00e8tre est facultatif, le menu peut \u00eatre utilis\u00e9 # sans lui. La pr\u00e9sence d'un param\u00e8tre de configuration 'analog_range_back_pin' transforme # ce param\u00e8tre de num\u00e9rique \u00e0 analogique. #up_pin: # La broche connect\u00e9e au bouton 'haut'. Ce param\u00e8tre doit \u00eatre fourni lorsque vous utilisez un # menu sans encodeur. La pr\u00e9sence d'un param\u00e8tre de configuration 'analog_range_up_pin' # transforme ce param\u00e8tre de num\u00e9rique \u00e0 analogique. #down_pin: # La broche connect\u00e9e au bouton 'bas'. Ce param\u00e8tre doit \u00eatre fourni lorsque vous utilisez un # menu sans encodeur. La pr\u00e9sence d'un param\u00e8tre de configuration 'analog_range_down_pin' # transforme ce param\u00e8tre de num\u00e9rique \u00e0 analogique. #kill_pin: # La broche connect\u00e9e au bouton 'kill'. Ce bouton appellera l'arr\u00eat d'urgence. La pr\u00e9sence d'un # param\u00e8tre 'analog_range_kill_pin' fait passer ce param\u00e8tre de num\u00e9rique \u00e0 analogique. #analog_pullup_resistor: 4700 # La r\u00e9sistance (en ohms) du pullup attach\u00e9 au bouton analogique. # La valeur par d\u00e9faut est de 4700 ohms. #analog_range_click_pin: # La plage de r\u00e9sistances du bouton 'entr\u00e9e'. Les valeurs minimale et maximale de la plage # s\u00e9par\u00e9es par des virgules doivent \u00eatre fournies lors de l'utilisation du bouton analogique. #analog_range_back_pin: # La plage de r\u00e9sistances du bouton 'retour'. Les valeurs minimale et maximale de la plage # s\u00e9par\u00e9es par des virgules doivent \u00eatre fournies lors de l'utilisation du bouton analogique. #analog_range_up_pin: # La plage de r\u00e9sistances du bouton 'haut'. Les valeurs minimale et maximale de la plage # s\u00e9par\u00e9es par des virgules doivent \u00eatre fournies lors de l'utilisation du bouton analogique. #analog_range_down_pin: # La plage de r\u00e9sistances du bouton 'bas'. Les valeurs minimale et maximale de la plage # s\u00e9par\u00e9es par des virgules doivent \u00eatre fournies lors de l'utilisation du bouton analogique. #analog_range_kill_pin: # La plage de r\u00e9sistances du bouton 'kill'. Les valeurs minimale et maximale de la plage # s\u00e9par\u00e9es par des virgules doivent \u00eatre fournies lors de l'utilisation du bouton analogique.","title":"[display]"},{"location":"Config_Reference.html#ecran-hd44780","text":"Informations de configuration des \u00e9crans hd44780 (utilis\u00e9s dans les \u00e9crans de type \"RepRapDiscount 2004 Smart Controller\"). [display] lcd_type: hd44780 # D\u00e9finir \u00e0 \"hd44780\" pour les \u00e9crans hd44780. rs_pin: e_pin: d4_pin: d5_pin: d6_pin: d7_pin: # Broches connect\u00e9es \u00e0 un lcd de type hd44780. Ces param\u00e8tres doivent # \u00eatre fournis. #hd44780_protocol_init: True # Effectuer l'initialisation du protocole 8-bit/4-bit sur un \u00e9cran hd44780. # Ceci est n\u00e9cessaire sur les vrais dispositifs hd44780. Cependant, on peut avoir besoin # de le d\u00e9sactiver avec certains p\u00e9riph\u00e9riques \"clones\". La valeur par d\u00e9faut est True. #line_length: # D\u00e9finit le nombre de caract\u00e8res par ligne pour un lcd de type hd44780. # Les valeurs possibles sont 20 (par d\u00e9faut) et 16. Le nombre de lignes est # fix\u00e9 \u00e0 4. ...","title":"\u00e9cran hd44780"},{"location":"Config_Reference.html#ecran-hd44780_spi","text":"Informations de configuration d'un \u00e9cran hd44780_spi - un \u00e9cran 20x04 contr\u00f4l\u00e9 par un \"registre \u00e0 d\u00e9calage (shift register)\" mat\u00e9riel (utilis\u00e9 dans les imprimantes bas\u00e9es sur mightyboard). [display] lcd_type: hd44780_spi # D\u00e9finir \u00e0 \"hd44780_spi\" pour les \u00e9crans hd44780_spi. latch_pin: spi_software_sclk_pin: spi_software_mosi_pin: spi_software_miso_pin: # Broches connect\u00e9es au registre \u00e0 d\u00e9calage contr\u00f4lant l'affichage. # La broche spi_software_miso_pin doit \u00eatre d\u00e9finie sur une broche inutilis\u00e9e # de la carte m\u00e8re de l'imprimante, car le registre \u00e0 d\u00e9calage contr\u00f4lant l'affichage # n'a pas de broche MISO, mais l'impl\u00e9mentation logicielle de spi n\u00e9cessite que # cette broche soit configur\u00e9e. #hd44780_protocol_init: True # Effectue l'initialisation du protocole 8-bit/4-bit sur un \u00e9cran hd44780. # Ceci est n\u00e9cessaire sur les vrais dispositifs hd44780. Cependant, on peut avoir besoin # de le d\u00e9sactiver avec certains p\u00e9riph\u00e9riques \"clones\". La valeur par d\u00e9faut est True. #line_length: # D\u00e9finit le nombre de caract\u00e8res par ligne pour un lcd de type hd44780. # Les valeurs possibles sont 20 (par d\u00e9faut) et 16. Le nombre de lignes est # fix\u00e9 \u00e0 4. ...","title":"\u00e9cran hd44780_spi"},{"location":"Config_Reference.html#ecran-st7920","text":"Informations de configuration des \u00e9crans st7920 (utilis\u00e9s dans les \u00e9crans de type \"RepRapDiscount 12864 Full Graphic Smart Controller\"). [display] lcd_type: st7920 # D\u00e9finir \u00e0 \"st7920\" pour les \u00e9crans st7920. cs_pin: sclk_pin: sid_pin: # Les broches connect\u00e9es \u00e0 un lcd de type st7920. Ces param\u00e8tres doivent \u00eatre # fournis. ...","title":"\u00e9cran st7920"},{"location":"Config_Reference.html#ecran-emulated_st7920","text":"Informations de configuration d'un \u00e9cran st7920 \u00e9mul\u00e9 - que l'on trouve dans certains \"\u00e9crans tactiles de 2,4 pouces\" et similaires. [display] lcd_type: emulated_st7920 # D\u00e9finir \u00e0 \"emulated_st7920\" pour les \u00e9crans emulated_st7920. en_pin: spi_software_sclk_pin: spi_software_mosi_pin: spi_software_miso_pin: # Les broches connect\u00e9es \u00e0 un lcd de type emulated_st7920. L'en_pin # correspond \u00e0 la cs_pin du lcd de type st7920, # spi_software_sclk_pin correspond \u00e0 sclk_pin et # spi_software_mosi_pin correspond \u00e0 sid_pin. La broche # spi_software_miso_pin doit \u00eatre r\u00e9gl\u00e9e sur une broche non utilis\u00e9e de la carte # m\u00e8re de l'imprimante car le st7920 n'a pas de broche MISO mais l'impl\u00e9mentation # logicielle spi n\u00e9cessite que cette broche soit configur\u00e9e. ...","title":"\u00e9cran emulated_st7920"},{"location":"Config_Reference.html#ecran-uc1701","text":"Informations de configuration des \u00e9crans uc1701 (utilis\u00e9s dans les \u00e9crans de type \"MKS Mini 12864\"). [display] lcd_type: uc1701 # D\u00e9finir \u00e0 \"uc1701\" pour les \u00e9crans uc1701. cs_pin: a0_pin: # Les broches connect\u00e9es \u00e0 un lcd de type uc1701. Ces param\u00e8tres doivent \u00eatre # fournis. #rst_pin: # La broche connect\u00e9e \u00e0 la broche \"rst\" du lcd. Si elle n'est pas sp\u00e9cifi\u00e9e, # le mat\u00e9riel doit avoir un pull-up sur la ligne lcd correspondante. #contrast: # Le contraste \u00e0 d\u00e9finir. La valeur peut aller de 0 \u00e0 63 , la valeur par # d\u00e9faut est 40. ...","title":"\u00e9cran uc1701"},{"location":"Config_Reference.html#ecrans-ssd1306-et-sh1106","text":"Les informations de configuration des \u00e9crans ssd1306 et sh1106. [display] lcd_type: # Set to either \"ssd1306\" or \"sh1106\" for the given display type. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # Optional parameters available for displays connected via an i2c # bus. See the \"common I2C settings\" section for a description of # the above parameters. #cs_pin: #dc_pin: #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # The pins connected to the lcd when in \"4-wire\" spi mode. See the # \"common SPI settings\" section for a description of the parameters # that start with \"spi_\". The default is to use i2c mode for the # display. #reset_pin: # A reset pin may be specified on the display. If it is not # specified then the hardware must have a pull-up on the # corresponding lcd line. #contrast: # The contrast to set. The value may range from 0 to 256 and the # default is 239. #vcomh: 0 # Set the Vcomh value on the display. This value is associated with # a \"smearing\" effect on some OLED displays. The value may range # from 0 to 63. Default is 0. #invert: False # TRUE inverts the pixels on certain OLED displays. The default is # False. #x_offset: 0 # Set the horizontal offset value on SH1106 displays. The default is # 0. ...","title":"\u00e9crans ssd1306 et sh1106"},{"location":"Config_Reference.html#display_data","text":"Support pour l'affichage de donn\u00e9es personnalis\u00e9es sur un \u00e9cran lcd. On peut cr\u00e9er un nombre quelconque de groupes d'affichage et un nombre quelconque d'\u00e9l\u00e9ments de donn\u00e9es sous ces groupes. L'\u00e9cran affichera tous les \u00e9l\u00e9ments de donn\u00e9es d'un groupe donn\u00e9 si l'option display_group de la section [display] est d\u00e9finie sur le nom du groupe en question. Un ensemble par d\u00e9faut de groupes d'affichage est automatiquement cr\u00e9\u00e9. On peut remplacer ou \u00e9tendre ces \u00e9l\u00e9ments display_data en rempla\u00e7ant les valeurs par d\u00e9faut dans le fichier de configuration principal printer.cfg. [display_data my_group_name my_data_name] position: # Ligne et colonne s\u00e9par\u00e9es par des virgules de la position de l'affichage \u00e0 # utiliser pour afficher l'information. Ce param\u00e8tre doit \u00eatre fourni. text: # Le texte \u00e0 afficher \u00e0 la position donn\u00e9e. Ce champ est \u00e9valu\u00e9 en utilisant les # mod\u00e8les de commande (voir docs/Command_Templates.md). # Ce param\u00e8tre doit \u00eatre fourni.","title":"[display_data]"},{"location":"Config_Reference.html#display_template","text":"Les \"macros\" de texte des donn\u00e9es d'affichage (on peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe display_template). Voir le document mod\u00e8les de commande pour des informations sur l'\u00e9valuation des mod\u00e8les. Cette fonctionnalit\u00e9 permet de r\u00e9duire les d\u00e9finitions r\u00e9p\u00e9titives dans les sections display_data. On peut utiliser la fonction int\u00e9gr\u00e9e render() dans les sections display_data pour \u00e9valuer un mod\u00e8le. Par exemple, si l'on d\u00e9finit \"[display_template my_template] \", on peut alors utiliser \"{ render('my_template') } dans une section display_data. Cette fonctionnalit\u00e9 peut \u00e9galement \u00eatre utilis\u00e9e pour des mises \u00e0 jour continues des LEDs \u00e0 l'aide de la commande SET_LED_TEMPLATE . [display_template my_template_name] #param_<name>: # On peut sp\u00e9cifier un nombre quelconque d'options avec le pr\u00e9fixe \"param_\". Le nom # donn\u00e9 se verra attribuer la valeur donn\u00e9e (analys\u00e9e comme un litt\u00e9ral Python) et # sera disponible pendant l'expansion de la macro. Si le param\u00e8tre est pass\u00e9 dans # l'appel \u00e0 render(), alors cette valeur sera utilis\u00e9e pendant l'expansion de la macro. # Par exemple, une configuration avec \"param_speed = 75\" pourrait avoir un appelant # avec \"render('my_template_name', param_speed=80)\". Les noms de param\u00e8tres # peuvent ne pas utiliser de caract\u00e8res majuscules. text: # Le texte \u00e0 renvoyer lors du rendu de ce mod\u00e8le. Ce champ est \u00e9valu\u00e9 \u00e0 l'aide de # mod\u00e8les de commande (voir docs/Command_Templates.md). # Ce param\u00e8tre doit \u00eatre fourni.","title":"[display_template]"},{"location":"Config_Reference.html#display_glyph","text":"Affiche un glyphe personnalis\u00e9 sur les \u00e9crans le supportant. Le nom donn\u00e9 se verra attribu\u00e9 les donn\u00e9es d'affichage, donn\u00e9es qui pourront ensuite \u00eatre r\u00e9f\u00e9renc\u00e9es dans les mod\u00e8les d'affichage par leur nom entour\u00e9 de deux symboles \"tilde\", par exemple ~my_display_glyph~ Voir sample-glyphs.cfg pour quelques exemples. [display_glyph my_display_glyph] #data: # Les donn\u00e9es d'affichage, stock\u00e9es sous forme de 16 lignes compos\u00e9es de 16 bits (1 par # pixel) o\u00f9 '.' est un pixel vide et '*' est un pixel actif (par ex, \"****************\" pour afficher # une ligne horizontale pleine). # On peut \u00e9galement utiliser '0' pour un pixel vide et '1' pour un pixel actif. # Placez chaque ligne d'affichage sur une ligne de configuration distincte. Le glyphe doit \u00eatre # compos\u00e9 d'exactement 16 lignes de 16 bits chacune. Ce param\u00e8tre est facultatif. #hd44780_data: # Glyphe \u00e0 utiliser sur les \u00e9crans 20x4 hd44780. Le glyphe doit \u00eatre compos\u00e9 d'exactement # 8 lignes de 5 bits chacune. Ce param\u00e8tre est facultatif. #hd44780_slot: # L'index mat\u00e9riel hd44780 (0..7) pour stocker le glyphe. Si plusieurs images distinctes # utilisent le m\u00eame slot, assurez-vous de n'utiliser qu'une seule de ces images dans un # \u00e9cran donn\u00e9. Ce param\u00e8tre est requis si hd44780_data est sp\u00e9cifi\u00e9.","title":"[display_glyph]"},{"location":"Config_Reference.html#display-my_extra_display","text":"Si une section principale [display] a \u00e9t\u00e9 d\u00e9finie dans printer.cfg comme indiqu\u00e9 ci-dessus, il est possible de d\u00e9finir plusieurs affichages auxiliaires. Notez que les affichages auxiliaires ne supportent pas actuellement la fonctionnalit\u00e9 de menus, ils ne supportent donc pas les options \"menu\" ou la configuration de boutons. [display my_extra_display] # Voir la section \"affichage\" (display) pour les param\u00e8tres disponibles.","title":"[display my_extra_display]"},{"location":"Config_Reference.html#menu","text":"Menus de l'\u00e9cran LCD personnalisables. Un ensemble de menus par d\u00e9faut est automatiquement cr\u00e9\u00e9. On peut remplacer ou \u00e9tendre le menu en rempla\u00e7ant les valeurs par d\u00e9faut dans le fichier de configuration principal printer.cfg. Consultez le document sur les mod\u00e8les de commande pour obtenir des informations sur les attributs de menu disponibles lors du rendu du mod\u00e8le. # Param\u00e8tres communs disponibles pour toutes les sections de configuration de menu. #[menu __some_list __some_name] #type: disabled # \u00c9l\u00e9ment de menu d\u00e9sactiv\u00e9 de fa\u00e7on permanente, le seul attribut requis est 'type'. # Vous permet de d\u00e9sactiver/masquer facilement des \u00e9l\u00e9ments de menu existants. #[menu some_name] #type: # Un \u00e9l\u00e9ment parmi command, input, list, text : # command - \u00e9l\u00e9ment de menu de base avec divers d\u00e9clencheurs de script. # input - m\u00eame chose que 'command' mais avec des capacit\u00e9s de changement de valeur. # Pressez pour d\u00e9marrer/arr\u00eater le mode d'\u00e9dition. # list - permet de regrouper les \u00e9l\u00e9ments du menu dans une liste d\u00e9roulante. # Ajoutez \u00e0 la liste en cr\u00e9ant des configurations de menu en utilisant # \"some_list\" comme pr\u00e9fixe - par exemple : # [menu some_list some_item_in_the_list]. # vsdlist - identique \u00e0 'list' mais ajoutera les fichiers de la carte SD virtuelle # (sera supprim\u00e9 dans le futur) #name: # Nom de l'\u00e9l\u00e9ment de menu - \u00e9valu\u00e9 comme un mod\u00e8le. #enable: # Mod\u00e8le \u00e9valu\u00e9 \u00e0 True ou False. #index: # Position o\u00f9 l'\u00e9l\u00e9ment doit \u00eatre ins\u00e9r\u00e9 dans la liste. Par d\u00e9faut # l'\u00e9l\u00e9ment est ajout\u00e9 \u00e0 la fin. #[menu some_list] #type: list #name: #enable: # Voir ci-dessus pour une description de ces param\u00e8tres. #[menu some_list some_command] #type: command #name: #enable: # Voir ci-dessus pour une description de ces param\u00e8tres. #gcode: # Script \u00e0 ex\u00e9cuter lors d'un clic sur un bouton ou un clic long. \u00c9valu\u00e9 comme un # mod\u00e8le. #[menu some_list some_input] #type: input #name: #enable: # Voir ci-dessus pour une description de ces param\u00e8tres. #input: # Valeur initiale \u00e0 utiliser lors de l'\u00e9dition - \u00e9valu\u00e9e comme un mod\u00e8le. # Le r\u00e9sultat doit \u00eatre de type flottant. #input_min: # Valeur minimale de l''intervalle - \u00e9valu\u00e9e comme un mod\u00e8le. Par d\u00e9faut -99999. #input_max: # Valeur maximale de l'intervalle - \u00e9valu\u00e9e comme un mod\u00e8le. Par d\u00e9faut 99999. #input_step: # Pas d'\u00e9dition - Doit \u00eatre un nombre entier positif ou une valeur flottante. Poss\u00e8de # un pas de vitesse rapide interne. Lorsque \"(input_max - input_min) / input_step > 100\" # alors le pas de vitesse rapide est 10 * input_step sinon le pas de vitesse rapide # est le m\u00eame que celui de l'input_step. #realtime: # Cet attribut accepte une valeur bool\u00e9enne statique. Lorsqu'il est activ\u00e9, alors le script # gcode est ex\u00e9cut\u00e9 apr\u00e8s chaque changement de valeur. La valeur par d\u00e9faut est False. #gcode: # Script \u00e0 ex\u00e9cuter lors d'un clic sur un bouton, d'un clic long ou d'un changement de valeur. # \u00c9valu\u00e9 comme un mod\u00e8le. Le clic sur le bouton d\u00e9clenchera le d\u00e9but ou fin du mode d'\u00e9dition.","title":"[menu]"},{"location":"Config_Reference.html#capteurs-de-filaments","text":"","title":"Capteurs de filaments"},{"location":"Config_Reference.html#filament_switch_sensor","text":"Capteur de commutation de filament. Prise en charge de la d\u00e9tection de l'insertion et du d\u00e9placement du filament \u00e0 l'aide d'un capteur de commutation, tel qu'un interrupteur de fin de course. Voir la r\u00e9f\u00e9rence des commandes pour plus d'informations. [filament_switch_sensor my_sensor] #pause_on_runout: True # Lorsque d\u00e9fini sur True, une PAUSE sera ex\u00e9cut\u00e9e imm\u00e9diatement apr\u00e8s qu'un runout # soit d\u00e9tect\u00e9. Notez que si pause_on_runout est False et que le runout_gcode est omis, # la d\u00e9tection du runout est d\u00e9sactiv\u00e9e. Par d\u00e9faut, est True. #runout_gcode: # Une liste de commandes G-Code \u00e0 ex\u00e9cuter apr\u00e8s la d\u00e9tection d'une fin de filament. # Voir docs/Command_Templates.md pour le format G-Code. Si pause_on_runout est # r\u00e9gl\u00e9 sur True, ce G-code sera ex\u00e9cut\u00e9 apr\u00e8s la fin de la PAUSE. Par d\u00e9faut, aucune # commande G-Code n'est ex\u00e9cut\u00e9e. #insert_gcode: # Une liste de commandes G-Code \u00e0 ex\u00e9cuter apr\u00e8s qu'une insertion de filament soit d\u00e9tect\u00e9e. # Voir docs/Command_Templates.md pour le format G-Code. La valeur par d\u00e9faut est de # n'ex\u00e9cuter aucune commande G-Code, ce qui d\u00e9sactive la d\u00e9tection de l'insertion. #event_delay 3.0 # La dur\u00e9e minimale en secondes \u00e0 attendre entre les \u00e9v\u00e9nements. # Des \u00e9v\u00e9nements d\u00e9clench\u00e9s durant cette p\u00e9riode seront silencieusement ignor\u00e9s. # La valeur par d\u00e9faut est de 3 secondes. #pause_delay: 0.5 # Le d\u00e9lai, en secondes, entre l'envoi de la commande de pause et l'ex\u00e9cution du runout_gcode. # Il peut \u00eatre utile d'augmenter ce d\u00e9lai si OctoPrint pr\u00e9sente un comportement \u00e9trange lors de # la pause. La valeur par d\u00e9faut est 0.5 secondes. #switch_pin: # La broche sur laquelle l'interrupteur est connect\u00e9. # Ce param\u00e8tre doit \u00eatre fourni.","title":"[filament_switch_sensor]"},{"location":"Config_Reference.html#filament_motion_sensor","text":"Capteur de mouvement de filament. Prise en charge de la d\u00e9tection de pr\u00e9sence et d\u00e9placement du filament \u00e0 l'aide d'un encodeur basculant la broche de sortie pendant le mouvement du filament dans le capteur. Voir la r\u00e9f\u00e9rence des commandes pour plus d'informations. [filament_motion_sensor my_sensor] detection_length: 7.0 # La longueur minimale du filament tir\u00e9 \u00e0 travers le capteur d\u00e9clenchant # un changement d'\u00e9tat sur la broche de commutation. # La valeur par d\u00e9faut est 7 mm. extruder: # Le nom de la section de l'extrudeuse \u00e0 laquelle ce capteur est associ\u00e9. # Ce param\u00e8tre doit \u00eatre fourni. switch_pin: #pause_on_runout: #runout_gcode: #insert_gcode: #event_delay: #pause_delay: # Voir la section \"filament_switch_sensor\" pour une description des # param\u00e8tres ci-dessus.","title":"[filament_motion_sensor]"},{"location":"Config_Reference.html#tsl1401cl_filament_width_sensor","text":"Capteur de largeur de filament bas\u00e9 sur le TSLl401CL. Voir ce guide pour plus d'informations. [tsl1401cl_filament_width_sensor] #pin: #default_nominal_filament_diameter: 1.75 # (mm) # Diff\u00e9rence maximale de diam\u00e8tre de filament autoris\u00e9e en mm. #max_diff\u00e9rence: 0.2 # La distance entre le capteur et la chambre de fusion en mm. #measurement_delay: 100","title":"[tsl1401cl_filament_width_sensor]"},{"location":"Config_Reference.html#hall_filament_width_sensor","text":"Capteur Hall de largeur de filament (voir Capteur Hall de largeur de filament ). [hall_filament_width_sensor] adc1: adc2: # Broches d'entr\u00e9e analogiques connect\u00e9es au capteur. Ces param\u00e8tres doivent # \u00eatre fournis. #cal_dia1: 1.50 #cal_dia2: 2.00 # Les valeurs d'\u00e9talonnage (en mm) pour les capteurs. La valeur par d\u00e9faut est # 1,50 pour cal_dia1 et 2,00 pour cal_dia2. #raw_dia1: 9500 #raw_dia2: 10500 # Les valeurs brutes d'\u00e9talonnage des capteurs. La valeur par d\u00e9faut est 9500 # pour raw_dia1 et 10500 pour raw_dia2. #default_nominal_filament_diameter: 1.75 # Le diam\u00e8tre nominal du filament. Ce param\u00e8tre doit \u00eatre fourni. #max_difference: 0.200 # Diff\u00e9rence maximale autoris\u00e9e de diam\u00e8tre du filament en millim\u00e8tres (mm). # Si la diff\u00e9rence entre le diam\u00e8tre nominal du filament et la sortie du capteur # est sup\u00e9rieure \u00e0 +- max_difference, le multiplicateur d'extrusion est ramen\u00e9 \u00e0 # \u00e0 %100. La valeur par d\u00e9faut est de 0,200. #measurement_delay: 70 # La distance entre le capteur et la chambre de fusion/la buse en # millim\u00e8tres (mm). Le filament situ\u00e9 entre le capteur et la buse # sera trait\u00e9 comme le default_nominal_filament_diameter. # Ce module h\u00f4te fonctionne avec une logique FIFO. Il conserve chaque valeur # de capteur dans un tableau et les remet (POP) dans la bonne position. Ce # param\u00e8tre doit \u00eatre fourni. #enable: False # Capteur activ\u00e9 ou d\u00e9sactiv\u00e9 apr\u00e8s la mise sous tension. La valeur par d\u00e9faut est # d\u00e9sactiv\u00e9. #measurement_interval: 10 # La distance approximative (en mm) entre les lectures du capteur. La valeur # par d\u00e9faut est de 10mm. #logging: False # Le diam\u00e8tre de sortie vers le terminal et vers klipper.log peut \u00eatre activ\u00e9 par # ce param\u00e8tre. #min_diameter: 1.0 # Diam\u00e8tre minimal pour d\u00e9clencher le capteur virtuel filament_switch_sensor. #use_current_dia_while_delay: False # Utiliser le diam\u00e8tre actuel au lieu du diam\u00e8tre nominal pendant que le d\u00e9lai # de mesure n'est pas \u00e9coul\u00e9. #pause_on_runout: #runout_gcode: #insert_gcode: #event_delay: #pause_delay: # Voir la section \"filament_switch_sensor\" pour une description des # param\u00e8tres ci-dessus.","title":"[hall_filament_width_sensor]"},{"location":"Config_Reference.html#support-materiel-specifique-a-une-carte","text":"","title":"Support mat\u00e9riel sp\u00e9cifique \u00e0 une carte"},{"location":"Config_Reference.html#sx1509","text":"Configuration d'un expandeur SX1509 I2C vers GPIO. En raison du d\u00e9lai encouru par la communication I2C, vous ne devez PAS utiliser les broches du SX1509 comme activation du moteur pas \u00e0 pas, pas ou direction ou toute autre broche n\u00e9cessitant un changement de bit rapide. Il est pr\u00e9f\u00e9rable de les utiliser comme sorties num\u00e9riques statiques ou contr\u00f4l\u00e9es par gcode ou comme broches hardware-pwm pour des ventilateurs par exemple. On peut d\u00e9finir un nombre quelconque de sections avec un pr\u00e9fixe \"sx1509\". Chaque expandeur fournit un ensemble de 16 broches (sx1509_my_sx1509:PIN_0 \u00e0 sx1509_my_sx1509:PIN_15) pouvant \u00eatre utilis\u00e9es dans la configuration de l'imprimante. Voir le fichier generic-duet2-duex.cfg pour un exemple. [sx1509 my_sx1509] i2c_address: # I2C address used by this expander. Depending on the hardware # jumpers this is one out of the following addresses: 62 63 112 # 113. This parameter must be provided. #i2c_mcu: #i2c_bus: #i2c_software_scl_pin: #i2c_software_sda_pin: #i2c_speed: # See the \"common I2C settings\" section for a description of the # above parameters.","title":"[sx1509]"},{"location":"Config_Reference.html#samd_sercom","text":"Configuration de SAMD SERCOM pour indiquer les broches \u00e0 utiliser sur un mat\u00e9riel SERCOM. On peut d\u00e9finir un nombre quelconque de sections avec le pr\u00e9fixe \"samd_sercom\". Chaque SERCOM doit \u00eatre configur\u00e9 avant de pouvoir \u00eatre utilis\u00e9 comme p\u00e9riph\u00e9rique SPI ou I2C. Placez cette section de configuration au-dessus de toute autre section qui utilise les bus SPI ou I2C. [samd_sercom my_sercom] sercom: # Le nom du bus sercom \u00e0 configurer dans le micro-contr\u00f4leur. # Les noms disponibles sont \"sercom0\", \"sercom1\", etc. # Ce param\u00e8tredoit \u00eatre fourni. tx_pin: # Broche MOSI pour la communication SPI, ou broche SDA (donn\u00e9es) pour la communication I2C. # La broche doit avoir une configuration pinmux valide pour le p\u00e9riph\u00e9rique SERCOM donn\u00e9. # Ce param\u00e8tre doit \u00eatre fourni. #rx_pin: # Broche MISO pour la communication SPI. Cette broche n'est pas utilis\u00e9e pour la communication I2C # (I2C utilise tx_pin pour l'envoi et la r\u00e9ception). # La broche doit avoir une configuration pinmux valide pour le p\u00e9riph\u00e9rique SERCOM donn\u00e9. # Ce param\u00e8tre est optionnel. clk_pin: # La broche CLK pour la communication SPI, ou la broche SCL (horloge) pour la communication I2C. # La broche doit avoir une configuration pinmux valide pour le p\u00e9riph\u00e9rique SERCOM donn\u00e9. # Ce param\u00e8tre doit \u00eatre fourni","title":"[samd_sercom]"},{"location":"Config_Reference.html#adc_scaled","text":"Mise \u00e0 l'\u00e9chelle analogique du Duet2 Maestro par lectures vref et vssa. D\u00e9finir une section adc_scaled permet d'activer des broches adc virtuelles (telles que \"my_name:PB0\") qui seront automatiquement ajust\u00e9es par les broches de surveillance vref et vssa de la carte. Assurez-vous de d\u00e9finir cette section de configuration au-dessus de toute section de configuration utilisant l'une de ces broches virtuelles. Voir le fichier generic-duet2-maestro.cfg pour un exemple. [adc_scaled my_name] vref_pin : # La broche ADC \u00e0 utiliser pour le contr\u00f4le de VREF. Ce param\u00e8tre doit \u00eatre # fourni. vssa_pin : # La broche ADC \u00e0 utiliser pour la surveillance VSSA. Ce param\u00e8tre doit \u00eatre # fourni. #smooth_time : 2.0 # Une dur\u00e9e (en secondes) durant laquelle les mesures de vref et vssa # seront liss\u00e9es pour r\u00e9duire l'impact du bruit des mesures. # La valeur par d\u00e9faut est de 2 secondes.","title":"[adc_scaled]"},{"location":"Config_Reference.html#replicape","text":"Support de Replicape - voir le guide beaglebone et le fichier generic-replicape.cfg pour un exemple. # La section de configuration \"replicape\" ajoute \"replicape:stepper_x_enable\" pour # l'activation de broches virtuelles de moteur (pour les moteurs X, Y, Z, E et H) et # \"replicape:power_x\" des broches de sortie PWM (pour les pilotes, e, h, fan0, fan1, # fan2, et fan3) utilisables ailleurs dans le fichier de configuration. [replicape] revision: # La r\u00e9vision du mat\u00e9riel replicape. Actuellement, seule la r\u00e9vision \"B3\" est # support\u00e9e. Ce param\u00e8tre doit \u00eatre fourni. #enable_pin: !gpio0_20 # La broche d'activation globale de la replicape. La valeur par d\u00e9faut est !gpio0_20 # (aka P9_41). host_mcu : # Le nom de la section de configuration mcu communiquant avec la section de # l'instance mcu du \"processus linux\" de Klipper. Ce param\u00e8tre doit \u00eatre # fourni. #standstill_power_down: False # Ce param\u00e8tre contr\u00f4le la ligne CFG6_ENN sur tous les moteurs pas \u00e0 pas. # True r\u00e8gle les lignes d'activation sur \"ouvert\". La valeur par d\u00e9faut est # False. #stepper_x_microstep_mode: #stepper_y_microstep_mode: #stepper_z_microstep_mode: #stepper_e_microstep_mode: #stepper_h_microstep_mode: # Ce param\u00e8tre contr\u00f4le les broches CFG1 et CFG2 du pilote de moteur donn\u00e9. # Les options disponibles sont : disable, 1, 2, spread2, 4, 16, spread4, spread16, # stealth4, et stealth16. La valeur par d\u00e9faut est disable. #stepper_x_current: #stepper_y_current: #stepper_z_current: #stepper_e_current: #stepper_h_current: # Le courant maximum configur\u00e9 (en Amp\u00e8res) du moteur pas \u00e0 pas. # Ce param\u00e8tre doit \u00eatre fourni si le moteur pas \u00e0 pas n'est pas dans un # mode d\u00e9sactiv\u00e9. #stepper_x_chopper_off_time_high: #stepper_y_chopper_off_time_high: #stepper_z_chopper_off_time_high: #stepper_e_chopper_off_time_high: #stepper_h_chopper_off_time_high: # Ce param\u00e8tre contr\u00f4le la broche CFG0 du pilote du moteur pas \u00e0 pas. # (True place CFG0 en haut, False le place en bas). La valeur par d\u00e9faut est False. #stepper_x_chopper_hysteresis_high: #stepper_y_chopper_hysteresis_high: #stepper_z_chopper_hysteresis_high: #stepper_e_chopper_hysteresis_high: #stepper_h_chopper_hysteresis_high: # Ce param\u00e8tre contr\u00f4le la broche CFG4 du pilote du moteur pas \u00e0 pas. # (True place CFG4 en haut, False le place en bas). La valeur par d\u00e9faut est False. #stepper_x_chopper_blank_time_high: #stepper_y_chopper_blank_time_high: #stepper_z_chopper_blank_time_high: #stepper_e_chopper_blank_time_high: #stepper_h_chopper_blank_time_high: # Ce param\u00e8tre contr\u00f4le la broche CFG5 du pilote du moteur pas \u00e0 pas. # (True place CFG5 en haut, False le place en bas). La valeur par d\u00e9faut est True.","title":"[replicape]"},{"location":"Config_Reference.html#autres-modules-specifiques","text":"","title":"Autres modules sp\u00e9cifiques"},{"location":"Config_Reference.html#palette2","text":"Prise en charge des multimat\u00e9riaux de la Palette 2 - assure une int\u00e9gration plus \u00e9troite de la prise en charge des p\u00e9riph\u00e9riques de la Palette 2 en mode connect\u00e9. Ce module n\u00e9cessite \u00e9galement [virtual_sdcard] et [pause_resume] pour une fonctionnalit\u00e9 compl\u00e8te. Si vous utilisez ce module, n'utilisez pas le plugin Palette 2 pour Octoprint car ils entreront en conflit, et le module ne pourra pas s'initialiser correctement, ce qui fera \u00e9chouer votre impression. Si vous utilisez Octoprint et que vous diffusez du gcode sur le port s\u00e9rie au lieu d'imprimer \u00e0 partir de virtual_sd, alors supprimez M1 et M0 de Commandes de pause dans Param\u00e8tres > Connexion s\u00e9rie > Firmware & protocole \u00e9vitera d'avoir \u00e0 lancer l'impression sur la Palette 2 et de devoir lever la pause dans Octoprint pour que l'impression commence. [palette2] serial: # Le port s\u00e9rie \u00e0 connecter \u00e0 la Palette 2. #baud: 115200 # Le d\u00e9bit en bauds \u00e0 utiliser. La valeur par d\u00e9faut est 115200. #feedrate_splice: 0.8 # La vitesse d'avance \u00e0 utiliser lors de l'\u00e9pissage, la valeur par d\u00e9faut est 0,8 #feedrate_normal: 1.0 # La vitesse d'avance \u00e0 utiliser apr\u00e8s le raccordement, la valeur par d\u00e9faut est 1.0 #auto_load_speed: 2 # Vitesse d'avance d'extrusion lors du chargement automatique, la valeur par d\u00e9faut est 2 (mm/s) #auto_cancel_variation: 0.1 # Annulation automatique de l'impression lorsque la variation du ping est sup\u00e9rieure \u00e0 ce seuil","title":"[palette2]"},{"location":"Config_Reference.html#angle","text":"Prise en charge du capteur d'angle Hall magn\u00e9tique pour la lecture des mesures de l'angle de l'arbre du moteur pas \u00e0 pas \u00e0 l'aide des puces SPI a1333, as5047d ou tle5012b. Les mesures sont disponibles via le serveur API et l' outil d'analyse de mouvement . Voir la r\u00e9f\u00e9rence G-Code pour les commandes disponibles. [angle my_angle_sensor] sensor_type: # Le type de la puce du capteur magn\u00e9tique \u00e0 effet Hall. Les choix disponibles # sont \"a1333\", \"as5047d\" et \"tle5012b\". Ce param\u00e8tre doit \u00eatre sp\u00e9cifi\u00e9. #sample_period: 0.000400 # La p\u00e9riode de requ\u00eate (en secondes) \u00e0 utiliser lors des mesures. La valeur par # d\u00e9faut est de 0.000400 (ce qui correspond \u00e0 2500 \u00e9chantillons par seconde). #stepper: # Le nom du pilote moteur pas \u00e0 pas auquel le capteur d'angle est attach\u00e9 (ex, # \"stepper_x\"). La d\u00e9finition de cette valeur active un \u00e9talonnage d'angle. # Pour utiliser cette fonction, le paquet Python \"numpy\" doit \u00eatre install\u00e9. # Par d\u00e9faut, l'\u00e9talonnage d'angle n'est pas activ\u00e9 pour un capteur d'angle. cs_pin: # La broche d'activation SPI du capteur. Ce param\u00e8tre doit \u00eatre fourni. #spi_speed: #spi_bus: #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # Voir la section \"param\u00e8tres SPI communs\" pour une description des # param\u00e8tres ci-dessus.","title":"[angle]"},{"location":"Config_Reference.html#parametres-communs-aux-bus","text":"","title":"Param\u00e8tres communs aux bus"},{"location":"Config_Reference.html#parametres-spi-communs","text":"Les param\u00e8tres suivants sont g\u00e9n\u00e9ralement disponibles pour les dispositifs utilisant un bus SPI. #spi_speed: # La vitesse SPI (en hz) \u00e0 utiliser lors de la communication avec le p\u00e9riph\u00e9rique. # La valeur par d\u00e9faut d\u00e9pend du type de p\u00e9riph\u00e9rique. #spi_bus: # Si le micro-contr\u00f4leur supporte plusieurs bus SPI alors on peut sp\u00e9cifier le nom # du bus du micro-contr\u00f4leur ici. La valeur par d\u00e9faut d\u00e9pend du type de # micro-contr\u00f4leur. #spi_software_sclk_pin: #spi_software_mosi_pin: #spi_software_miso_pin: # Sp\u00e9cifiez les param\u00e8tres ci-dessus pour utiliser le \"SPI logiciel\". Ce mode ne # n\u00e9cessite pas le support mat\u00e9riel du micro-contr\u00f4leur (typiquement n'importe # quelle broche d'usage g\u00e9n\u00e9ral peut \u00eatre utilis\u00e9e). La valeur par d\u00e9faut est de # ne pas utiliser le \"spi logiciel\".","title":"Param\u00e8tres SPI communs"},{"location":"Config_Reference.html#parametres-i2c-communs","text":"Les param\u00e8tres suivants sont g\u00e9n\u00e9ralement disponibles pour les dispositifs utilisant un bus I2C. La prise en charge actuelle du microcontr\u00f4leur de Klipper pour I2C n'est g\u00e9n\u00e9ralement pas tol\u00e9rante au bruit de ligne. Des erreurs inattendues sur les fils I2C peuvent amener Klipper \u00e0 g\u00e9n\u00e9rer une erreur d'ex\u00e9cution. La prise en charge de Klipper pour la r\u00e9cup\u00e9ration d'erreur varie selon chaque type de microcontr\u00f4leur. Il est g\u00e9n\u00e9ralement recommand\u00e9 de n'utiliser que des appareils I2C qui se trouvent sur la m\u00eame carte de circuit imprim\u00e9 que le microcontr\u00f4leur. La plupart des impl\u00e9mentations de microcontr\u00f4leurs Klipper ne prennent en charge qu'une i2c_speed de 100000 ( mode standard , 100kbit/s). Le micro-contr\u00f4leur Klipper \"Linux\" supporte une vitesse de 400000 ( fast mode , 400kbit/s), mais il doit \u00eatre d\u00e9fini dans le syst\u00e8me d'exploitation sinon le param\u00e8tre i2c_speed sera ignor\u00e9. Le microcontr\u00f4leur Klipper \"RP2040\" et la famille ATmega AVR supportent un taux de 400000 via le param\u00e8tre i2c_speed . Tous les autres microcontr\u00f4leurs Klipper utilisent un taux de 100000 et ignorent le param\u00e8tre i2c_speed . #i2c_address: # The i2c address of the device. This must specified as a decimal # number (not in hex). The default depends on the type of device. #i2c_mcu: # The name of the micro-controller that the chip is connected to. # The default is \"mcu\". #i2c_bus: # If the micro-controller supports multiple I2C busses then one may # specify the micro-controller bus name here. The default depends on # the type of micro-controller. #i2c_software_scl_pin: #i2c_software_sda_pin: # Specify these parameters to use micro-controller software based # I2C \"bit-banging\" support. The two parameters should the two pins # on the micro-controller to use for the scl and sda wires. The # default is to use hardware based I2C support as specified by the # i2c_bus parameter. #i2c_speed: # The I2C speed (in Hz) to use when communicating with the device. # The Klipper implementation on most micro-controllers is hard-coded # to 100000 and changing this value has no effect. The default is # 100000. Linux, RP2040 and ATmega support 400000.","title":"Param\u00e8tres I2C communs"},{"location":"Config_checks.html","text":"Contr\u00f4les de la configuration \u00b6 Ce document fournit une liste des \u00e9tapes permettant de v\u00e9rifier les affectations des broches dans le fichier printer.cfg de Klipper. Il est conseill\u00e9 d'ex\u00e9cuter ces \u00e9tapes apr\u00e8s avoir suivi les \u00e9tapes du document d'installation . Pendant ce guide, il peut \u00eatre n\u00e9cessaire d'apporter des modifications au fichier de configuration de Klipper. Veillez \u00e0 \u00e9mettre une commande RESTART apr\u00e8s chaque modification du fichier de configuration pour vous assurer que la modification prend effet (tapez \"restart\" dans l'onglet du terminal Octoprint et cliquez ensuite sur \"Send\"). C'est aussi une bonne id\u00e9e d'envoyer une commande STATUS apr\u00e8s chaque RESTART pour v\u00e9rifier que le fichier de configuration a \u00e9t\u00e9 charg\u00e9 avec succ\u00e8s. V\u00e9rifier la temp\u00e9rature \u00b6 Start by verifying that temperatures are being properly reported. Navigate to the temperature graph section in the user interface. Verify that the temperature of the nozzle and bed (if applicable) are present and not increasing. If it is increasing, remove power from the printer. If the temperatures are not accurate, review the \"sensor_type\" and \"sensor_pin\" settings for the nozzle and/or bed. V\u00e9rifier M112 \u00b6 Navigate to the command console and issue an M112 command in the terminal box. This command requests Klipper to go into a \"shutdown\" state. It will cause an error to show, which can be cleared with a FIRMWARE_RESTART command in the command console. Octoprint will also require a reconnect. Then navigate to the temperature graph section and verify that temperatures continue to update and the temperatures are not increasing. If temperatures are increasing, remove power from the printer. V\u00e9rifier la cartouche chauffante \u00b6 Navigate to the temperature graph section and type in 50 followed by enter in the extruder/tool temperature box. The extruder temperature in the graph should start to increase (within about 30 seconds or so). Then go to the extruder temperature drop-down box and select \"Off\". After several minutes the temperature should start to return to its initial room temperature value. If the temperature does not increase then verify the \"heater_pin\" setting in the config. Si l'imprimante est \u00e9quip\u00e9e d'un plateau chauffant, effectuez \u00e0 nouveau le test ci-dessus avec le plateau. V\u00e9rifier l'activation du moteur pas \u00e0 pas \u00b6 Verify that all of the printer axes can manually move freely (the stepper motors are disabled). If not, issue an M84 command to disable the motors. If any of the axes still can not move freely, then verify the stepper \"enable_pin\" configuration for the given axis. On most commodity stepper motor drivers, the motor enable pin is \"active low\" and therefore the enable pin should have a \"!\" before the pin (for example, \"enable_pin: !PA1\"). V\u00e9rifier les capteurs de fin de course \u00b6 Manually move all the printer axes so that none of them are in contact with an endstop. Send a QUERY_ENDSTOPS command via the command console. It should respond with the current state of all of the configured endstops and they should all report a state of \"open\". For each of the endstops, rerun the QUERY_ENDSTOPS command while manually triggering the endstop. The QUERY_ENDSTOPS command should report the endstop as \"TRIGGERED\". If the endstop appears inverted (it reports \"open\" when triggered and vice-versa) then add a \"!\" to the pin definition (for example, \"endstop_pin: ^PA2\"), or remove the \"!\" if there is already one present. Si la fin de course ne change pas du tout, cela indique g\u00e9n\u00e9ralement que la fin de course est connect\u00e9e \u00e0 une autre broche. Cependant, cela peut \u00e9galement n\u00e9cessiter une modification du param\u00e8tre de pullup de la broche (le '^' au d\u00e9but du nom endstop_pin - la plupart des imprimantes utilisent une r\u00e9sistance pullup et le '^' doit \u00eatre pr\u00e9sent). V\u00e9rifier les moteurs pas \u00e0 pas \u00b6 Use the STEPPER_BUZZ command to verify the connectivity of each stepper motor. Start by manually positioning the given axis to a midway point and then run STEPPER_BUZZ STEPPER=stepper_x in the command console. The STEPPER_BUZZ command will cause the given stepper to move one millimeter in a positive direction and then it will return to its starting position. (If the endstop is defined at position_endstop=0 then at the start of each movement the stepper will move away from the endstop.) It will perform this oscillation ten times. Si le moteur pas \u00e0 pas ne bouge pas du tout, v\u00e9rifiez les r\u00e9glages \"enable_pin\" et \"step_pin\" du moteur pas \u00e0 pas. Si le moteur pas \u00e0 pas se d\u00e9place mais ne revient pas \u00e0 sa position initiale, v\u00e9rifiez le r\u00e9glage \"dir_pin\". Si le moteur pas \u00e0 pas oscille dans une direction incorrecte, cela indique g\u00e9n\u00e9ralement que le param\u00e8tre \"dir_pin\" de l'axe doit \u00eatre invers\u00e9. Pour ce faire, il suffit d'ajouter un \" !\" au param\u00e8tre \"dir_pin\" dans le fichier de configuration de l'imprimante (ou de le supprimer s'il y en a d\u00e9j\u00e0 un). Si le moteur se d\u00e9place de mani\u00e8re significativement sup\u00e9rieure ou inf\u00e9rieure \u00e0 un millim\u00e8tre, v\u00e9rifiez le param\u00e8tre \"rotation_distance\". Ex\u00e9cutez le test ci-dessus pour chaque moteur pas \u00e0 pas d\u00e9fini dans le fichier de configuration. (D\u00e9finissez le param\u00e8tre STEPPER de la commande STEPPER_BUZZ au nom de la section de la configuration qui doit \u00eatre test\u00e9e). S'il n'y a pas de filament dans l'extrudeur, on peut utiliser STEPPER_BUZZ pour v\u00e9rifier la connectivit\u00e9 du moteur de l'extrudeur (utilisez STEPPER=extrudeur). Sinon, il est pr\u00e9f\u00e9rable de tester le moteur de l'extrudeur s\u00e9par\u00e9ment (voir la section suivante). Apr\u00e8s avoir v\u00e9rifi\u00e9 tous les arr\u00eats et tous les moteurs pas \u00e0 pas, le m\u00e9canisme d'auto-home doit \u00eatre test\u00e9. Envoyez une commande G28 pour ramener tous les axes \u00e0 leur position initiale. Coupez l'alimentation de l'imprimante si elle ne se positionne pas correctement. R\u00e9p\u00e9tez les \u00e9tapes de v\u00e9rification des fins de course et des moteurs pas \u00e0 pas si n\u00e9cessaire. V\u00e9rifier le moteur de l'extrudeur \u00b6 To test the extruder motor it will be necessary to heat the extruder to a printing temperature. Navigate to the temperature graph section and select a target temperature from the temperature drop-down box (or manually enter an appropriate temperature). Wait for the printer to reach the desired temperature. Then navigate to the command console and click the \"Extrude\" button. Verify that the extruder motor turns in the correct direction. If it does not, see the troubleshooting tips in the previous section to confirm the \"enable_pin\", \"step_pin\", and \"dir_pin\" settings for the extruder. Calibrer les param\u00e8tres PID \u00b6 Klipper prend en charge le r\u00e9gulateur PID pour l'extrudeuse et le chauffage du lit. Afin d'utiliser ce m\u00e9canisme de contr\u00f4le, il est n\u00e9cessaire de calibrer les param\u00e8tres PID sur chaque imprimante (les param\u00e8tres PID trouv\u00e9s dans d'autres micrologiciels ou dans les fichiers de configuration d'exemple fonctionnent souvent mal). To calibrate the extruder, navigate to the command console and run the PID_CALIBRATE command. For example: PID_CALIBRATE HEATER=extruder TARGET=170 A la fin du test de r\u00e9glage, ex\u00e9cutez SAVE_CONFIG pour mettre \u00e0 jour le fichier printer.cfg avec les nouveaux param\u00e8tres PID. Si l'imprimante est \u00e9quip\u00e9e d'un lit chauffant et qu'elle peut \u00eatre pilot\u00e9e par PWM (Pulse Width Modulation), il est recommand\u00e9 d'utiliser la commande PID pour le plateau (lorsque le chauffage du lit est contr\u00f4l\u00e9 \u00e0 l'aide de l'algorithme PID, il peut s'allumer et s'\u00e9teindre dix fois par seconde, ce qui peut ne pas convenir aux chauffages utilisant un interrupteur m\u00e9canique). Une commande typique de calibrage PID du plateau est : PID_CALIBRATE HEATER=heater_bed TARGET=60 Prochaines \u00e9tapes \u00b6 Ce guide a pour but d'aider \u00e0 la v\u00e9rification de base des param\u00e8tres des broches dans le fichier de configuration de Klipper. Veillez \u00e0 lire le guide bed leveling . Consultez \u00e9galement le document Slicers pour obtenir des informations sur la configuration d'un trancheur avec Klipper. Apr\u00e8s avoir v\u00e9rifi\u00e9 que l'impression de base fonctionne, il est bon d'envisager de calibrer l'avance de pression . Il peut \u00eatre n\u00e9cessaire d'effectuer d'autres types de calibrage d\u00e9taill\u00e9 de l'imprimante - un certain nombre de guides sont disponibles en ligne pour vous aider (par exemple, faites une recherche sur le Web pour \"3d printer calibration\"). Par exemple, si vous rencontrez un effet appel\u00e9 \"ringing\", vous pouvez essayer de suivre le guide de r\u00e9glage de la compensation de r\u00e9sonance .","title":"Contr\u00f4les de la configuration"},{"location":"Config_checks.html#controles-de-la-configuration","text":"Ce document fournit une liste des \u00e9tapes permettant de v\u00e9rifier les affectations des broches dans le fichier printer.cfg de Klipper. Il est conseill\u00e9 d'ex\u00e9cuter ces \u00e9tapes apr\u00e8s avoir suivi les \u00e9tapes du document d'installation . Pendant ce guide, il peut \u00eatre n\u00e9cessaire d'apporter des modifications au fichier de configuration de Klipper. Veillez \u00e0 \u00e9mettre une commande RESTART apr\u00e8s chaque modification du fichier de configuration pour vous assurer que la modification prend effet (tapez \"restart\" dans l'onglet du terminal Octoprint et cliquez ensuite sur \"Send\"). C'est aussi une bonne id\u00e9e d'envoyer une commande STATUS apr\u00e8s chaque RESTART pour v\u00e9rifier que le fichier de configuration a \u00e9t\u00e9 charg\u00e9 avec succ\u00e8s.","title":"Contr\u00f4les de la configuration"},{"location":"Config_checks.html#verifier-la-temperature","text":"Start by verifying that temperatures are being properly reported. Navigate to the temperature graph section in the user interface. Verify that the temperature of the nozzle and bed (if applicable) are present and not increasing. If it is increasing, remove power from the printer. If the temperatures are not accurate, review the \"sensor_type\" and \"sensor_pin\" settings for the nozzle and/or bed.","title":"V\u00e9rifier la temp\u00e9rature"},{"location":"Config_checks.html#verifier-m112","text":"Navigate to the command console and issue an M112 command in the terminal box. This command requests Klipper to go into a \"shutdown\" state. It will cause an error to show, which can be cleared with a FIRMWARE_RESTART command in the command console. Octoprint will also require a reconnect. Then navigate to the temperature graph section and verify that temperatures continue to update and the temperatures are not increasing. If temperatures are increasing, remove power from the printer.","title":"V\u00e9rifier M112"},{"location":"Config_checks.html#verifier-la-cartouche-chauffante","text":"Navigate to the temperature graph section and type in 50 followed by enter in the extruder/tool temperature box. The extruder temperature in the graph should start to increase (within about 30 seconds or so). Then go to the extruder temperature drop-down box and select \"Off\". After several minutes the temperature should start to return to its initial room temperature value. If the temperature does not increase then verify the \"heater_pin\" setting in the config. Si l'imprimante est \u00e9quip\u00e9e d'un plateau chauffant, effectuez \u00e0 nouveau le test ci-dessus avec le plateau.","title":"V\u00e9rifier la cartouche chauffante"},{"location":"Config_checks.html#verifier-lactivation-du-moteur-pas-a-pas","text":"Verify that all of the printer axes can manually move freely (the stepper motors are disabled). If not, issue an M84 command to disable the motors. If any of the axes still can not move freely, then verify the stepper \"enable_pin\" configuration for the given axis. On most commodity stepper motor drivers, the motor enable pin is \"active low\" and therefore the enable pin should have a \"!\" before the pin (for example, \"enable_pin: !PA1\").","title":"V\u00e9rifier l'activation du moteur pas \u00e0 pas"},{"location":"Config_checks.html#verifier-les-capteurs-de-fin-de-course","text":"Manually move all the printer axes so that none of them are in contact with an endstop. Send a QUERY_ENDSTOPS command via the command console. It should respond with the current state of all of the configured endstops and they should all report a state of \"open\". For each of the endstops, rerun the QUERY_ENDSTOPS command while manually triggering the endstop. The QUERY_ENDSTOPS command should report the endstop as \"TRIGGERED\". If the endstop appears inverted (it reports \"open\" when triggered and vice-versa) then add a \"!\" to the pin definition (for example, \"endstop_pin: ^PA2\"), or remove the \"!\" if there is already one present. Si la fin de course ne change pas du tout, cela indique g\u00e9n\u00e9ralement que la fin de course est connect\u00e9e \u00e0 une autre broche. Cependant, cela peut \u00e9galement n\u00e9cessiter une modification du param\u00e8tre de pullup de la broche (le '^' au d\u00e9but du nom endstop_pin - la plupart des imprimantes utilisent une r\u00e9sistance pullup et le '^' doit \u00eatre pr\u00e9sent).","title":"V\u00e9rifier les capteurs de fin de course"},{"location":"Config_checks.html#verifier-les-moteurs-pas-a-pas","text":"Use the STEPPER_BUZZ command to verify the connectivity of each stepper motor. Start by manually positioning the given axis to a midway point and then run STEPPER_BUZZ STEPPER=stepper_x in the command console. The STEPPER_BUZZ command will cause the given stepper to move one millimeter in a positive direction and then it will return to its starting position. (If the endstop is defined at position_endstop=0 then at the start of each movement the stepper will move away from the endstop.) It will perform this oscillation ten times. Si le moteur pas \u00e0 pas ne bouge pas du tout, v\u00e9rifiez les r\u00e9glages \"enable_pin\" et \"step_pin\" du moteur pas \u00e0 pas. Si le moteur pas \u00e0 pas se d\u00e9place mais ne revient pas \u00e0 sa position initiale, v\u00e9rifiez le r\u00e9glage \"dir_pin\". Si le moteur pas \u00e0 pas oscille dans une direction incorrecte, cela indique g\u00e9n\u00e9ralement que le param\u00e8tre \"dir_pin\" de l'axe doit \u00eatre invers\u00e9. Pour ce faire, il suffit d'ajouter un \" !\" au param\u00e8tre \"dir_pin\" dans le fichier de configuration de l'imprimante (ou de le supprimer s'il y en a d\u00e9j\u00e0 un). Si le moteur se d\u00e9place de mani\u00e8re significativement sup\u00e9rieure ou inf\u00e9rieure \u00e0 un millim\u00e8tre, v\u00e9rifiez le param\u00e8tre \"rotation_distance\". Ex\u00e9cutez le test ci-dessus pour chaque moteur pas \u00e0 pas d\u00e9fini dans le fichier de configuration. (D\u00e9finissez le param\u00e8tre STEPPER de la commande STEPPER_BUZZ au nom de la section de la configuration qui doit \u00eatre test\u00e9e). S'il n'y a pas de filament dans l'extrudeur, on peut utiliser STEPPER_BUZZ pour v\u00e9rifier la connectivit\u00e9 du moteur de l'extrudeur (utilisez STEPPER=extrudeur). Sinon, il est pr\u00e9f\u00e9rable de tester le moteur de l'extrudeur s\u00e9par\u00e9ment (voir la section suivante). Apr\u00e8s avoir v\u00e9rifi\u00e9 tous les arr\u00eats et tous les moteurs pas \u00e0 pas, le m\u00e9canisme d'auto-home doit \u00eatre test\u00e9. Envoyez une commande G28 pour ramener tous les axes \u00e0 leur position initiale. Coupez l'alimentation de l'imprimante si elle ne se positionne pas correctement. R\u00e9p\u00e9tez les \u00e9tapes de v\u00e9rification des fins de course et des moteurs pas \u00e0 pas si n\u00e9cessaire.","title":"V\u00e9rifier les moteurs pas \u00e0 pas"},{"location":"Config_checks.html#verifier-le-moteur-de-lextrudeur","text":"To test the extruder motor it will be necessary to heat the extruder to a printing temperature. Navigate to the temperature graph section and select a target temperature from the temperature drop-down box (or manually enter an appropriate temperature). Wait for the printer to reach the desired temperature. Then navigate to the command console and click the \"Extrude\" button. Verify that the extruder motor turns in the correct direction. If it does not, see the troubleshooting tips in the previous section to confirm the \"enable_pin\", \"step_pin\", and \"dir_pin\" settings for the extruder.","title":"V\u00e9rifier le moteur de l'extrudeur"},{"location":"Config_checks.html#calibrer-les-parametres-pid","text":"Klipper prend en charge le r\u00e9gulateur PID pour l'extrudeuse et le chauffage du lit. Afin d'utiliser ce m\u00e9canisme de contr\u00f4le, il est n\u00e9cessaire de calibrer les param\u00e8tres PID sur chaque imprimante (les param\u00e8tres PID trouv\u00e9s dans d'autres micrologiciels ou dans les fichiers de configuration d'exemple fonctionnent souvent mal). To calibrate the extruder, navigate to the command console and run the PID_CALIBRATE command. For example: PID_CALIBRATE HEATER=extruder TARGET=170 A la fin du test de r\u00e9glage, ex\u00e9cutez SAVE_CONFIG pour mettre \u00e0 jour le fichier printer.cfg avec les nouveaux param\u00e8tres PID. Si l'imprimante est \u00e9quip\u00e9e d'un lit chauffant et qu'elle peut \u00eatre pilot\u00e9e par PWM (Pulse Width Modulation), il est recommand\u00e9 d'utiliser la commande PID pour le plateau (lorsque le chauffage du lit est contr\u00f4l\u00e9 \u00e0 l'aide de l'algorithme PID, il peut s'allumer et s'\u00e9teindre dix fois par seconde, ce qui peut ne pas convenir aux chauffages utilisant un interrupteur m\u00e9canique). Une commande typique de calibrage PID du plateau est : PID_CALIBRATE HEATER=heater_bed TARGET=60","title":"Calibrer les param\u00e8tres PID"},{"location":"Config_checks.html#prochaines-etapes","text":"Ce guide a pour but d'aider \u00e0 la v\u00e9rification de base des param\u00e8tres des broches dans le fichier de configuration de Klipper. Veillez \u00e0 lire le guide bed leveling . Consultez \u00e9galement le document Slicers pour obtenir des informations sur la configuration d'un trancheur avec Klipper. Apr\u00e8s avoir v\u00e9rifi\u00e9 que l'impression de base fonctionne, il est bon d'envisager de calibrer l'avance de pression . Il peut \u00eatre n\u00e9cessaire d'effectuer d'autres types de calibrage d\u00e9taill\u00e9 de l'imprimante - un certain nombre de guides sont disponibles en ligne pour vous aider (par exemple, faites une recherche sur le Web pour \"3d printer calibration\"). Par exemple, si vous rencontrez un effet appel\u00e9 \"ringing\", vous pouvez essayer de suivre le guide de r\u00e9glage de la compensation de r\u00e9sonance .","title":"Prochaines \u00e9tapes"},{"location":"Contact.html","text":"Contact \u00b6 Ce document fourni les informations de contact pour Klipper. Forum de la Communaut\u00e9 Salon Discord J'ai une question au sujet de Klipper J'ai une demande d'ajout de fonctionnalit\u00e9 A l'aide ! Ca ne fonctionne pas ! J'ai trouv\u00e9 un bug dans le logiciel Klipper J\u2019apporte des modifications que j\u2019aimerais inclure dans Klipper Github Klipper Forum de la communaut\u00e9 \u00b6 Il y a un Serveur Communautaire Discourse Klipper pour les discussions sur Klipper. Salon Discord \u00b6 Un serveur Discord d\u00e9di\u00e9 \u00e0 Klipper est l\u00e0 : https://discord.klipper3d.org . Ce serveur, g\u00e9r\u00e9 par une communaut\u00e9 de passionn\u00e9s de Klipper, est d\u00e9di\u00e9 aux discussions sur Klipper. Il permet aux utilisateurs de discuter en temps r\u00e9el. J'ai une question sur Klipper \u00b6 La plupart des questions que nous recevons ont d\u00e9j\u00e0 une r\u00e9ponse dans la documentation de Klipper . Assurez-vous de bien la lire et de suivre les instructions qui y sont fournies. Il est \u00e9galement possible de rechercher des questions similaires sur le Forum de la communaut\u00e9 Klipper . Si vous souhaitez partager vos connaissances et votre exp\u00e9rience avec d'autres utilisateurs de Klipper, vous pouvez rejoindre le Forum de la communaut\u00e9 Klipper ou encore le Salon Discord Klipper . Il s'agit de deux communaut\u00e9s o\u00f9 les utilisateurs de Klipper peuvent discuter du logiciel avec d'autres. De nombreuses questions que nous recevons sont relatives \u00e0 l'impression 3D en g\u00e9n\u00e9ral et ne sont pas sp\u00e9cifiques \u00e0 Klipper. Si vous avez une question ou si vous rencontrez des probl\u00e8mes d'impression en g\u00e9n\u00e9ral, vous obtiendrez probablement une meilleure r\u00e9ponse en la posant sur un forum consacr\u00e9 \u00e0 l'impression 3D dans la globalit\u00e9 ou bien sur un d\u00e9di\u00e9 au mat\u00e9riel de votre imprimante. J'ai une demande d'ajout de fonctionnalit\u00e9 \u00b6 Toute nouvelle fonctionnalit\u00e9 n\u00e9cessite d'avoir une personne int\u00e9ress\u00e9e et en capacit\u00e9 de la mettre en oeuvre. Si vous souhaitez aider \u00e0 impl\u00e9menter ou tester une fonctionnalit\u00e9, nous pouvez consulter les d\u00e9veloppements en cours sur le Forum de la Communaut\u00e9 Klipper . Le Salon Discord Klipper est \u00e9galement l\u00e0 pour les discussions entre contributeurs. A l'aide ! Ca ne fonctionne pas ! \u00b6 Malheureusement, nous recevons beaucoup plus de demandes d'aide que nous ne pouvons en traiter. La majorit\u00e9 des rapports d'anomalie que nous recevons sont g\u00e9n\u00e9ralement li\u00e9s \u00e0 : Des erreurs subtiles dans le mat\u00e9riel, ou Ne pas avoir suivi toutes les \u00e9tapes d\u00e9crites dans la documentation de Klipper. Si vous rencontrez des soucis, nous vous recommandons de lire attentivement la documentation de Klipper et de v\u00e9rifier que toutes les \u00e9tapes ont \u00e9t\u00e9 suivies. Si vous rencontrez des soucis d'impression, nous vous recommandons d'inspecter minutieusement votre imprimante pour voir s'il n'y a pas d'anomalies (joints, vis, fils, etc). Nous avons remarqu\u00e9 que la plupart des anomalies ne sont pas sp\u00e9cifiquement li\u00e9es \u00e0 Klipper. Si vous avez un probl\u00e8me avec votre imprimante, vous obtiendrez s\u00fbrement une meilleure r\u00e9ponse en recherchant sur un forum d\u00e9di\u00e9 \u00e0 l'impression 3D en g\u00e9n\u00e9ral ou bien sur un consacr\u00e9 au mat\u00e9riel de votre imprimante. Il est \u00e9galement possible de rechercher des questions similaires sur le Forum de la communaut\u00e9 Klipper . Si vous souhaitez partager vos connaissances et votre exp\u00e9rience avec d'autres utilisateurs de Klipper, vous pouvez rejoindre le Forum de la communaut\u00e9 Klipper ou encore le Salon Discord Klipper . Il s'agit de deux communaut\u00e9s o\u00f9 les utilisateurs de Klipper peuvent discuter du logiciel avec d'autres. J'ai trouv\u00e9 un bug dans le logiciel Klipper \u00b6 Klipper est un projet open-source et nous appr\u00e9cions quand des contributeurs diagnostiquent des erreurs dans le logiciel. Les probl\u00e8mes devraient \u00eatre signal\u00e9s dans le Forum communautaire Klipper . Il y a des informations importantes qui sont n\u00e9cessaires pour pouvoir corriger un bug. Veuillez suivre ces \u00e9tapes : Assurez-vous que vous ex\u00e9cutez le code non modifi\u00e9 de https://github.com/Klipper3d/klipper . Si le code a \u00e9t\u00e9 modifi\u00e9 ou provient d'une autre source, vous devez reproduire le probl\u00e8me sur le code non modifi\u00e9 de https://github.com/Klipper3d/klipper avant de le signaler. Si possible, ex\u00e9cutez une commande M112 imm\u00e9diatement apr\u00e8s que l'\u00e9v\u00e9nement ind\u00e9sirable se soit produit. Klipper se met alors dans un \"\u00e9tat d'arr\u00eat\" et des informations de d\u00e9bogage suppl\u00e9mentaires sont \u00e9crites dans le fichier journal. R\u00e9cup\u00e9rez l'\u00e9v\u00e9nement depuis le fichier journal Klipper. Ce journal a \u00e9t\u00e9 con\u00e7u pour r\u00e9pondre aux questions courantes que les d\u00e9veloppeurs de Klipper se posent sur le logiciel et son environnement (version du logiciel, type de mat\u00e9riel, configuration, \u00e0 quel moment l'anomalie eu lieu, et des centaines d'autres questions). Le fichier journal de Klipper est situ\u00e9 dans /tmp/klippy.log sur l'ordinateur \"h\u00f4te\" de Klipper (le Raspberry Pi). Un utilitaire comme \"scp\" ou \"sftp\" est n\u00e9cessaire pour copier ce fichier journal sur votre ordinateur. L'utilitaire \"scp\" est fourni en standard avec les syst\u00e8mes Linux et MacOS. Il existe des utilitaires scp disponibles gratuitement pour d'autres syst\u00e8mes (par exemple, WinSCP). Si vous utilisez un utilitaire scp graphique qui ne peut pas copier directement /tmp/klippy.log , cliquez plusieurs fois sur ... ou dossier parent jusqu'\u00e0 ce que vous arriviez au r\u00e9pertoire racine, cliquez ensuite sur le dossier tmp , puis s\u00e9lectionnez le fichier klippy.log . Copiez le fichier journal sur votre bureau afin de le joindre au rapport d'anomalie. Ne modifiez pas le fichier journal de quelque fa\u00e7on que ce soit ; ne fournissez pas un extrait non plus. Seul le fichier journal complet sans alt\u00e9ration fournira les informations n\u00e9cessaires. C'est une bonne id\u00e9e de compresser le fichier journal avec zip ou gzip. Ouvrez un nouveau sujet sur le Forum communautaire Klipper et fournissez une description claire du probl\u00e8me. Les autres contributeurs de Klipper devront comprendre quelles mesures ont \u00e9t\u00e9 prises, quel \u00e9tait le r\u00e9sultat souhait\u00e9 et quel r\u00e9sultat s'est effectivement produit. Le fichier journal Klipper compress\u00e9 doit \u00eatre joint \u00e0 ce sujet. J\u2019apporte des modifications que j\u2019aimerais inclure dans Klipper \u00b6 Klipper est un logiciel libre et nous appr\u00e9cions les nouvelles contributions. Les nouvelles contributions (que ce soit pour le code ou pour la documentation) sont soumises au moyen de Pull Requests Github. R\u00e9f\u00e9rez-vous au document CONTRIBUTIONS pour conna\u00eetre les informations importantes \u00e0 ce sujet. Il existe plusieurs documents pour les d\u00e9veloppeurs . Si vous avez des questions sur le code, vous pouvez \u00e9galement les poser sur le Forum de la communaut\u00e9 Klipper ou sur le Discord de la communaut\u00e9 Klipper . GitHub Klipper \u00b6 Le GitHub de Klipper peut \u00eatre utilis\u00e9 par les contributeurs pour partager l'\u00e9tat de leur travail pour am\u00e9liorer Klipper. On s'attend \u00e0 ce que la personne qui ouvre un ticket github travaille activement sur la t\u00e2che donn\u00e9e et soit celle qui effectue tout le travail n\u00e9cessaire pour l'accomplir. Le GitHub de Klipper n'est pas utilis\u00e9 pour les demandes, ni pour signaler des bogues, ni pour poser des questions. Utilisez plut\u00f4t le Forum communautaire Klipper ou le Discord communautaire Klipper .","title":"Contact"},{"location":"Contact.html#contact","text":"Ce document fourni les informations de contact pour Klipper. Forum de la Communaut\u00e9 Salon Discord J'ai une question au sujet de Klipper J'ai une demande d'ajout de fonctionnalit\u00e9 A l'aide ! Ca ne fonctionne pas ! J'ai trouv\u00e9 un bug dans le logiciel Klipper J\u2019apporte des modifications que j\u2019aimerais inclure dans Klipper Github Klipper","title":"Contact"},{"location":"Contact.html#forum-de-la-communaute","text":"Il y a un Serveur Communautaire Discourse Klipper pour les discussions sur Klipper.","title":"Forum de la communaut\u00e9"},{"location":"Contact.html#salon-discord","text":"Un serveur Discord d\u00e9di\u00e9 \u00e0 Klipper est l\u00e0 : https://discord.klipper3d.org . Ce serveur, g\u00e9r\u00e9 par une communaut\u00e9 de passionn\u00e9s de Klipper, est d\u00e9di\u00e9 aux discussions sur Klipper. Il permet aux utilisateurs de discuter en temps r\u00e9el.","title":"Salon Discord"},{"location":"Contact.html#jai-une-question-sur-klipper","text":"La plupart des questions que nous recevons ont d\u00e9j\u00e0 une r\u00e9ponse dans la documentation de Klipper . Assurez-vous de bien la lire et de suivre les instructions qui y sont fournies. Il est \u00e9galement possible de rechercher des questions similaires sur le Forum de la communaut\u00e9 Klipper . Si vous souhaitez partager vos connaissances et votre exp\u00e9rience avec d'autres utilisateurs de Klipper, vous pouvez rejoindre le Forum de la communaut\u00e9 Klipper ou encore le Salon Discord Klipper . Il s'agit de deux communaut\u00e9s o\u00f9 les utilisateurs de Klipper peuvent discuter du logiciel avec d'autres. De nombreuses questions que nous recevons sont relatives \u00e0 l'impression 3D en g\u00e9n\u00e9ral et ne sont pas sp\u00e9cifiques \u00e0 Klipper. Si vous avez une question ou si vous rencontrez des probl\u00e8mes d'impression en g\u00e9n\u00e9ral, vous obtiendrez probablement une meilleure r\u00e9ponse en la posant sur un forum consacr\u00e9 \u00e0 l'impression 3D dans la globalit\u00e9 ou bien sur un d\u00e9di\u00e9 au mat\u00e9riel de votre imprimante.","title":"J'ai une question sur Klipper"},{"location":"Contact.html#jai-une-demande-dajout-de-fonctionnalite","text":"Toute nouvelle fonctionnalit\u00e9 n\u00e9cessite d'avoir une personne int\u00e9ress\u00e9e et en capacit\u00e9 de la mettre en oeuvre. Si vous souhaitez aider \u00e0 impl\u00e9menter ou tester une fonctionnalit\u00e9, nous pouvez consulter les d\u00e9veloppements en cours sur le Forum de la Communaut\u00e9 Klipper . Le Salon Discord Klipper est \u00e9galement l\u00e0 pour les discussions entre contributeurs.","title":"J'ai une demande d'ajout de fonctionnalit\u00e9"},{"location":"Contact.html#a-laide-ca-ne-fonctionne-pas","text":"Malheureusement, nous recevons beaucoup plus de demandes d'aide que nous ne pouvons en traiter. La majorit\u00e9 des rapports d'anomalie que nous recevons sont g\u00e9n\u00e9ralement li\u00e9s \u00e0 : Des erreurs subtiles dans le mat\u00e9riel, ou Ne pas avoir suivi toutes les \u00e9tapes d\u00e9crites dans la documentation de Klipper. Si vous rencontrez des soucis, nous vous recommandons de lire attentivement la documentation de Klipper et de v\u00e9rifier que toutes les \u00e9tapes ont \u00e9t\u00e9 suivies. Si vous rencontrez des soucis d'impression, nous vous recommandons d'inspecter minutieusement votre imprimante pour voir s'il n'y a pas d'anomalies (joints, vis, fils, etc). Nous avons remarqu\u00e9 que la plupart des anomalies ne sont pas sp\u00e9cifiquement li\u00e9es \u00e0 Klipper. Si vous avez un probl\u00e8me avec votre imprimante, vous obtiendrez s\u00fbrement une meilleure r\u00e9ponse en recherchant sur un forum d\u00e9di\u00e9 \u00e0 l'impression 3D en g\u00e9n\u00e9ral ou bien sur un consacr\u00e9 au mat\u00e9riel de votre imprimante. Il est \u00e9galement possible de rechercher des questions similaires sur le Forum de la communaut\u00e9 Klipper . Si vous souhaitez partager vos connaissances et votre exp\u00e9rience avec d'autres utilisateurs de Klipper, vous pouvez rejoindre le Forum de la communaut\u00e9 Klipper ou encore le Salon Discord Klipper . Il s'agit de deux communaut\u00e9s o\u00f9 les utilisateurs de Klipper peuvent discuter du logiciel avec d'autres.","title":"A l'aide ! Ca ne fonctionne pas !"},{"location":"Contact.html#jai-trouve-un-bug-dans-le-logiciel-klipper","text":"Klipper est un projet open-source et nous appr\u00e9cions quand des contributeurs diagnostiquent des erreurs dans le logiciel. Les probl\u00e8mes devraient \u00eatre signal\u00e9s dans le Forum communautaire Klipper . Il y a des informations importantes qui sont n\u00e9cessaires pour pouvoir corriger un bug. Veuillez suivre ces \u00e9tapes : Assurez-vous que vous ex\u00e9cutez le code non modifi\u00e9 de https://github.com/Klipper3d/klipper . Si le code a \u00e9t\u00e9 modifi\u00e9 ou provient d'une autre source, vous devez reproduire le probl\u00e8me sur le code non modifi\u00e9 de https://github.com/Klipper3d/klipper avant de le signaler. Si possible, ex\u00e9cutez une commande M112 imm\u00e9diatement apr\u00e8s que l'\u00e9v\u00e9nement ind\u00e9sirable se soit produit. Klipper se met alors dans un \"\u00e9tat d'arr\u00eat\" et des informations de d\u00e9bogage suppl\u00e9mentaires sont \u00e9crites dans le fichier journal. R\u00e9cup\u00e9rez l'\u00e9v\u00e9nement depuis le fichier journal Klipper. Ce journal a \u00e9t\u00e9 con\u00e7u pour r\u00e9pondre aux questions courantes que les d\u00e9veloppeurs de Klipper se posent sur le logiciel et son environnement (version du logiciel, type de mat\u00e9riel, configuration, \u00e0 quel moment l'anomalie eu lieu, et des centaines d'autres questions). Le fichier journal de Klipper est situ\u00e9 dans /tmp/klippy.log sur l'ordinateur \"h\u00f4te\" de Klipper (le Raspberry Pi). Un utilitaire comme \"scp\" ou \"sftp\" est n\u00e9cessaire pour copier ce fichier journal sur votre ordinateur. L'utilitaire \"scp\" est fourni en standard avec les syst\u00e8mes Linux et MacOS. Il existe des utilitaires scp disponibles gratuitement pour d'autres syst\u00e8mes (par exemple, WinSCP). Si vous utilisez un utilitaire scp graphique qui ne peut pas copier directement /tmp/klippy.log , cliquez plusieurs fois sur ... ou dossier parent jusqu'\u00e0 ce que vous arriviez au r\u00e9pertoire racine, cliquez ensuite sur le dossier tmp , puis s\u00e9lectionnez le fichier klippy.log . Copiez le fichier journal sur votre bureau afin de le joindre au rapport d'anomalie. Ne modifiez pas le fichier journal de quelque fa\u00e7on que ce soit ; ne fournissez pas un extrait non plus. Seul le fichier journal complet sans alt\u00e9ration fournira les informations n\u00e9cessaires. C'est une bonne id\u00e9e de compresser le fichier journal avec zip ou gzip. Ouvrez un nouveau sujet sur le Forum communautaire Klipper et fournissez une description claire du probl\u00e8me. Les autres contributeurs de Klipper devront comprendre quelles mesures ont \u00e9t\u00e9 prises, quel \u00e9tait le r\u00e9sultat souhait\u00e9 et quel r\u00e9sultat s'est effectivement produit. Le fichier journal Klipper compress\u00e9 doit \u00eatre joint \u00e0 ce sujet.","title":"J'ai trouv\u00e9 un bug dans le logiciel Klipper"},{"location":"Contact.html#japporte-des-modifications-que-jaimerais-inclure-dans-klipper","text":"Klipper est un logiciel libre et nous appr\u00e9cions les nouvelles contributions. Les nouvelles contributions (que ce soit pour le code ou pour la documentation) sont soumises au moyen de Pull Requests Github. R\u00e9f\u00e9rez-vous au document CONTRIBUTIONS pour conna\u00eetre les informations importantes \u00e0 ce sujet. Il existe plusieurs documents pour les d\u00e9veloppeurs . Si vous avez des questions sur le code, vous pouvez \u00e9galement les poser sur le Forum de la communaut\u00e9 Klipper ou sur le Discord de la communaut\u00e9 Klipper .","title":"J\u2019apporte des modifications que j\u2019aimerais inclure dans Klipper"},{"location":"Contact.html#github-klipper","text":"Le GitHub de Klipper peut \u00eatre utilis\u00e9 par les contributeurs pour partager l'\u00e9tat de leur travail pour am\u00e9liorer Klipper. On s'attend \u00e0 ce que la personne qui ouvre un ticket github travaille activement sur la t\u00e2che donn\u00e9e et soit celle qui effectue tout le travail n\u00e9cessaire pour l'accomplir. Le GitHub de Klipper n'est pas utilis\u00e9 pour les demandes, ni pour signaler des bogues, ni pour poser des questions. Utilisez plut\u00f4t le Forum communautaire Klipper ou le Discord communautaire Klipper .","title":"GitHub Klipper"},{"location":"Debugging.html","text":"D\u00e9bogage \u00b6 Ce document d\u00e9crit certains des outils de d\u00e9bogage de Klipper. Ex\u00e9cution des tests de non-r\u00e9gression \u00b6 Le r\u00e9f\u00e9rentiel principal Klipper GitHub utilise des \"github actions\" pour ex\u00e9cuter une s\u00e9rie de tests de non-r\u00e9gression. Il peut \u00eatre utile d'ex\u00e9cuter certains de ces tests localement. La \"v\u00e9rification des espaces\" dans le code source peut \u00eatre ex\u00e9cut\u00e9e avec : ./scripts/check_whitespace.sh La suite de tests de non-r\u00e9gression Klippy n\u00e9cessite les \"dictionnaires de donn\u00e9es\" de nombreuses plates-formes. Le moyen le plus simple de les obtenir est de les t\u00e9l\u00e9charger depuis github . Une fois les dictionnaires de donn\u00e9es t\u00e9l\u00e9charg\u00e9s, utilisez les \u00e9l\u00e9ments suivants pour ex\u00e9cuter la suite de tests de non-r\u00e9gression : tar xfz klipper-dict-20??????.tar.gz ~/klippy-env/bin/python ~/klipper/scripts/test_klippy.py -d dict/ ~/klipper/test/klippy/*.test Envoi manuel de commandes au microcontr\u00f4leur \u00b6 Normalement, le processus h\u00f4te klippy.py est utilis\u00e9 pour traduire les commandes gcode en commandes de microcontr\u00f4leur Klipper. Cependant, il est \u00e9galement possible d'envoyer manuellement ces commandes MCU (fonctions marqu\u00e9es avec la macro DECL_COMMAND() dans le code source de Klipper). Pour ce faire, ex\u00e9cutez : ~/klippy-env/bin/python ./klippy/console.py /tmp/pseudoserial Voir la commande \"AIDE\" dans l'outil pour plus d'informations sur sa fonctionnalit\u00e9. Certaines options en ligne de commande sont disponibles. Pour plus d'informations, ex\u00e9cutez : ~/klippy-env/bin/python ./klippy/console.py --help Traduction des fichiers G-Code en commandes de microcontr\u00f4leur \u00b6 Le code h\u00f4te Klippy peut \u00eatre execut\u00e9 en mode batch pour produire les commandes bas niveau du microcontr\u00f4leur associ\u00e9es \u00e0 un fichier gcode. L'inspection de ces commandes de bas niveau est utile pour essayer de comprendre les actions du mat\u00e9riel de bas niveau. Il peut \u00e9galement \u00eatre utile de comparer la diff\u00e9rence dans les commandes du microcontr\u00f4leur apr\u00e8s un changement de code. Pour ex\u00e9cuter Klippy dans ce mode batch, une seule \u00e9tape est n\u00e9cessaire pour g\u00e9n\u00e9rer le \"dictionnaire de donn\u00e9es\" du microcontr\u00f4leur. Cela se fait en compilant le code du micro-contr\u00f4leur pour obtenir le fichier out/klipper.dict : make menuconfig make Une fois que ce qui pr\u00e9c\u00e8de a \u00e9t\u00e9 fait, il est possible d'ex\u00e9cuter Klipper en mode batch (voir installation pour les \u00e9tapes n\u00e9cessaires \u00e0 la construction de l'environnement virtuel python et d'un fichier printer.cfg) : ~/klippy-env/bin/python ./klippy/klippy.py ~/printer.cfg -i test.gcode -o test.serial -v -d out/klipper.dict L'op\u00e9ration ci-dessus produira un fichier test.serial avec la sortie s\u00e9rie binaire. Cette sortie peut \u00eatre traduite en texte lisible avec : ~/klippy-env/bin/python ./klippy/parsedump.py out/klipper.dict test.serial > test.txt Le fichier r\u00e9sultant test.txt contient une liste lisible (par un humain) des commandes du microcontr\u00f4leur. Le mode batch d\u00e9sactive certaines commandes de r\u00e9ponse / requ\u00eate pour fonctionner. Par cons\u00e9quent, il y aura des diff\u00e9rences entre les commandes r\u00e9elles et la sortie ci-dessus. Les donn\u00e9es g\u00e9n\u00e9r\u00e9es sont utiles pour les tests et l'inspection ; elles ne sont pas utiles en fonctionnement normal (vers un vrai microcontr\u00f4leur). Analyse de mouvements et enregistrement de donn\u00e9es \u00b6 Klipper prend en charge la journalisation de l'historique des mouvement, qui peut \u00eatre analys\u00e9 ult\u00e9rieurement. Pour utiliser cette fonctionnalit\u00e9, Klipper doit \u00eatre d\u00e9marr\u00e9 avec le Serveur API activ\u00e9. L'enregistrement des donn\u00e9es est activ\u00e9 avec l'outil data_logger.py . Par example\u202f: ~/klipper/scripts/motan/data_logger.py /tmp/klippy_uds mylog Cette commande se connectera au serveur API de Klipper, s'abonnera aux informations d'\u00e9tat et de mouvement et consignera les r\u00e9sultats. Deux fichiers sont g\u00e9n\u00e9r\u00e9s : un fichier de donn\u00e9es compress\u00e9es et un fichier d'index (par exemple, mylog.json.gz et mylog.index.gz ). Apr\u00e8s avoir d\u00e9marr\u00e9 la journalisation, il est possible d'effectuer des impressions et d'autres actions - la journalisation se poursuivra en arri\u00e8re-plan. Une fois la journalisation termin\u00e9e, appuyez sur ctrl-c pour quitter l'outil data_logger.py . Les fichiers r\u00e9sultants peuvent \u00eatre lus et repr\u00e9sent\u00e9s graphiquement \u00e0 l'aide de l'outil motan_graph.py . Pour g\u00e9n\u00e9rer des graphiques sur un Raspberry Pi, une seule \u00e9tape est n\u00e9cessaire pour installer le package \"matplotlib\"\u202f: sudo apt-get update sudo apt-get install python-matplotlib Cependant, il peut \u00eatre plus pratique de copier les fichiers de donn\u00e9es sur une machine de bureau avec le code Python dans le r\u00e9pertoire scripts/motan/ . Les scripts d'analyse de mouvement doivent s'ex\u00e9cuter sur n'importe quelle machine sur laquelle une version r\u00e9cente de Python et Matplotlib est install\u00e9e. Les graphiques peuvent \u00eatre g\u00e9n\u00e9r\u00e9s avec une commande comme celle-ci : ~/klipper/scripts/motan/motan_graph.py mylog -o mygraph.png On peut utiliser l'option -g pour sp\u00e9cifier les jeux de donn\u00e9es \u00e0 repr\u00e9senter graphiquement (il faut un litt\u00e9ral Python contenant une liste de listes). Par exemple\u202f: ~/klipper/scripts/motan/motan_graph.py mylog -g '[[\"trapq(toolhead,velocity)\"], [\"trapq(toolhead,accel)\"]]' La liste des ensembles de donn\u00e9es disponibles peut \u00eatre trouv\u00e9e en utilisant l'option -l - par exemple : ~/klipper/scripts/motan/motan_graph.py -l Il est \u00e9galement possible de sp\u00e9cifier les options de trac\u00e9 matplotlib pour chaque jeu de donn\u00e9es : ~/klipper/scripts/motan/motan_graph.py mylog -g '[[\"trapq(toolhead,velocity)?color=red&alpha=0.4\"]]' De nombreuses options matplotlib sont disponibles ; quelques exemples sont \"color\", \"label\", \"alpha\" et \"linestyle\". L'outil motan_graph.py prend en charge plusieurs autres options de ligne de commande - utilisez l'option --help pour afficher une liste. Il peut \u00e9galement \u00eatre pratique de visualiser/modifier le script motan_graph.py lui-m\u00eame. Les journaux de donn\u00e9es brutes produits par l'outil data_logger.py suivent le format d\u00e9crit dans Serveur API . Il peut \u00eatre utile d'inspecter les donn\u00e9es avec une commande Unix comme celle-ci : gunzip < mylog.json.gz | tr '\\03' '\\n' | moins G\u00e9n\u00e9ration de graphiques de charge \u00b6 Le fichier journal Klippy (/tmp/klippy.log) stocke des statistiques sur la bande passante utilis\u00e9e, la charge du microcontr\u00f4leur et la charge du tampon h\u00f4te. Il peut \u00eatre utile de repr\u00e9senter graphiquement ces statistiques apr\u00e8s une impression. Pour g\u00e9n\u00e9rer un graphique, une seule \u00e9tape est n\u00e9cessaire pour installer le package \"matplotlib\"\u202f: sudo apt-get update sudo apt-get install python-matplotlib Ensuite, les graphiques peuvent \u00eatre produits avec\u202f: ~/klipper/scripts/graphstats.py /tmp/klippy.log -o loadgraph.png On peut alors visualiser le fichier loadgraph.png r\u00e9sultant. Diff\u00e9rents graphiques peuvent \u00eatre produits. Pour plus d'informations, ex\u00e9cutez : ~/klipper/scripts/graphstats.py --help Extraire des informations du fichier klippy.log \u00b6 Le fichier journal Klippy (/tmp/klippy.log) contient \u00e9galement des informations de d\u00e9bogage. Il existe un script logextract.py qui peut \u00eatre utile lors de l'analyse d'un arr\u00eat de microcontr\u00f4leur ou d'un probl\u00e8me similaire. Il est g\u00e9n\u00e9ralement ex\u00e9cut\u00e9 avec quelque chose comme : mkdir work_directory cd work_directory cp /tmp/klippy.log . ~/klipper/scripts/logextract.py ./klippy.log Le script extrait le fichier de configuration de l'imprimante et extrait les informations d'arr\u00eat du MCU. Les vidages d'informations d'un arr\u00eat de MCU (le cas \u00e9ch\u00e9ant) sont r\u00e9organis\u00e9s par horodatage pour faciliter le diagnostic des sc\u00e9narios de cause \u00e0 effet. Tester avec simulavr \u00b6 L'outil simulavr permet de simuler un microcontr\u00f4leur Atmel ATmega. Cette section d\u00e9crit comment ex\u00e9cuter des fichiers gcode de test via simulavr. Il est recommand\u00e9 de l'ex\u00e9cuter sur une machine de bureau (pas un Raspberry Pi) car il n\u00e9cessite un processeur puissant pour fonctionner efficacement. Pour utiliser simulavr, t\u00e9l\u00e9chargez le package simulavr et compilez avec le support python. Notez que le syst\u00e8me de construction peut n\u00e9cessiter l'installation de certains packages (tels que swig) afin de construire le module python. git clone git://git.savannah.nongnu.org/simulavr.git cd simulavr make python make build Assurez-vous qu'un fichier ./build/pysimulavr/_pysimulavr.*.so est pr\u00e9sent apr\u00e8s la compilation ci-dessus : ls ./build/pysimulavr/_pysimulavr.*.so Cette commande doit signaler un fichier sp\u00e9cifique (par exemple ./build/pysimulavr/_pysimulavr.cpython-39-x86_64-linux-gnu.so ) et non une erreur. Si vous \u00eates sur un syst\u00e8me bas\u00e9 sur Debian (Debian, Ubuntu, etc.), vous pouvez installer les packages suivants et g\u00e9n\u00e9rer des fichiers *.deb pour une installation de simulavr \u00e0 l'\u00e9chelle du syst\u00e8me : sudo apt update sudo apt install g++ make cmake swig rst2pdf help2man texinfo make cfgclean python debian sudo dpkg -i build/debian/python3-simulavr*.deb Pour compiler Klipper pour une utilisation dans simulavr, ex\u00e9cutez : cd /path/to/klipper make menuconfig et compilez le logiciel du microcontr\u00f4leur pour un AVR atmega644p et s\u00e9lectionnez le support d'\u00e9mulation du logiciel SIMULAVR. Ensuite on peut compiler Klipper (lancer make ) puis lancer la simulation avec : PYTHONPATH=/path/to/simulavr/build/pysimulavr/ ./scripts/avrsim.py out/klipper.elf Si vous avez install\u00e9 python3-simulavr au niveau syst\u00e8me, vous n'avez pas besoin de d\u00e9finir PYTHONPATH , et vous pouvez simplement ex\u00e9cuter le simulateur comme ./scripts/avrsim.py out/klipper.elf Ensuite, avec simulavr en cours d\u2019ex\u00e9cution dans une autre fen\u00eatre, on peut ex\u00e9cuter ce qui suit pour lire le gcode d\u2019un fichier (par exemple, \u00ab test.gcode \u00bb), le traiter avec Klippy, et l\u2019envoyer \u00e0 Klipper ex\u00e9cut\u00e9 dans simulavr (voir installation pour les \u00e9tapes n\u00e9cessaires \u00e0 la construction de l\u2019environnement virtuel python)\u202f: ~/klippy-env/bin/python ./klippy/klippy.py config/generic-simulavr.cfg -i test.gcode -v Utiliser simulavr avec gtkwave \u00b6 Une fonctionnalit\u00e9 utile de simulavr est sa capacit\u00e9 \u00e0 cr\u00e9er des fichiers de g\u00e9n\u00e9ration d'ondes avec la synchronisation exacte des \u00e9v\u00e9nements. Pour ce faire, suivez les instructions ci-dessus, mais ex\u00e9cutez avrsim.py avec une ligne de commande comme celle-ci : PYTHONPATH=/path/to/simulavr/src/python/ ./scripts/avrsim.py out/klipper.elf -t PORTA.PORT,PORTC.PORT Ce qui pr\u00e9c\u00e8de cr\u00e9era un fichier avrsim.vcd avec des informations sur chaque modification des GPIO sur PORTA et PORTB. Ce fichier pourra ensuite \u00eatre visualis\u00e9 en utilisant gtkwave avec : gtkwave avrsim.vcd","title":"D\u00e9bogage"},{"location":"Debugging.html#debogage","text":"Ce document d\u00e9crit certains des outils de d\u00e9bogage de Klipper.","title":"D\u00e9bogage"},{"location":"Debugging.html#execution-des-tests-de-non-regression","text":"Le r\u00e9f\u00e9rentiel principal Klipper GitHub utilise des \"github actions\" pour ex\u00e9cuter une s\u00e9rie de tests de non-r\u00e9gression. Il peut \u00eatre utile d'ex\u00e9cuter certains de ces tests localement. La \"v\u00e9rification des espaces\" dans le code source peut \u00eatre ex\u00e9cut\u00e9e avec : ./scripts/check_whitespace.sh La suite de tests de non-r\u00e9gression Klippy n\u00e9cessite les \"dictionnaires de donn\u00e9es\" de nombreuses plates-formes. Le moyen le plus simple de les obtenir est de les t\u00e9l\u00e9charger depuis github . Une fois les dictionnaires de donn\u00e9es t\u00e9l\u00e9charg\u00e9s, utilisez les \u00e9l\u00e9ments suivants pour ex\u00e9cuter la suite de tests de non-r\u00e9gression : tar xfz klipper-dict-20??????.tar.gz ~/klippy-env/bin/python ~/klipper/scripts/test_klippy.py -d dict/ ~/klipper/test/klippy/*.test","title":"Ex\u00e9cution des tests de non-r\u00e9gression"},{"location":"Debugging.html#envoi-manuel-de-commandes-au-microcontroleur","text":"Normalement, le processus h\u00f4te klippy.py est utilis\u00e9 pour traduire les commandes gcode en commandes de microcontr\u00f4leur Klipper. Cependant, il est \u00e9galement possible d'envoyer manuellement ces commandes MCU (fonctions marqu\u00e9es avec la macro DECL_COMMAND() dans le code source de Klipper). Pour ce faire, ex\u00e9cutez : ~/klippy-env/bin/python ./klippy/console.py /tmp/pseudoserial Voir la commande \"AIDE\" dans l'outil pour plus d'informations sur sa fonctionnalit\u00e9. Certaines options en ligne de commande sont disponibles. Pour plus d'informations, ex\u00e9cutez : ~/klippy-env/bin/python ./klippy/console.py --help","title":"Envoi manuel de commandes au microcontr\u00f4leur"},{"location":"Debugging.html#traduction-des-fichiers-g-code-en-commandes-de-microcontroleur","text":"Le code h\u00f4te Klippy peut \u00eatre execut\u00e9 en mode batch pour produire les commandes bas niveau du microcontr\u00f4leur associ\u00e9es \u00e0 un fichier gcode. L'inspection de ces commandes de bas niveau est utile pour essayer de comprendre les actions du mat\u00e9riel de bas niveau. Il peut \u00e9galement \u00eatre utile de comparer la diff\u00e9rence dans les commandes du microcontr\u00f4leur apr\u00e8s un changement de code. Pour ex\u00e9cuter Klippy dans ce mode batch, une seule \u00e9tape est n\u00e9cessaire pour g\u00e9n\u00e9rer le \"dictionnaire de donn\u00e9es\" du microcontr\u00f4leur. Cela se fait en compilant le code du micro-contr\u00f4leur pour obtenir le fichier out/klipper.dict : make menuconfig make Une fois que ce qui pr\u00e9c\u00e8de a \u00e9t\u00e9 fait, il est possible d'ex\u00e9cuter Klipper en mode batch (voir installation pour les \u00e9tapes n\u00e9cessaires \u00e0 la construction de l'environnement virtuel python et d'un fichier printer.cfg) : ~/klippy-env/bin/python ./klippy/klippy.py ~/printer.cfg -i test.gcode -o test.serial -v -d out/klipper.dict L'op\u00e9ration ci-dessus produira un fichier test.serial avec la sortie s\u00e9rie binaire. Cette sortie peut \u00eatre traduite en texte lisible avec : ~/klippy-env/bin/python ./klippy/parsedump.py out/klipper.dict test.serial > test.txt Le fichier r\u00e9sultant test.txt contient une liste lisible (par un humain) des commandes du microcontr\u00f4leur. Le mode batch d\u00e9sactive certaines commandes de r\u00e9ponse / requ\u00eate pour fonctionner. Par cons\u00e9quent, il y aura des diff\u00e9rences entre les commandes r\u00e9elles et la sortie ci-dessus. Les donn\u00e9es g\u00e9n\u00e9r\u00e9es sont utiles pour les tests et l'inspection ; elles ne sont pas utiles en fonctionnement normal (vers un vrai microcontr\u00f4leur).","title":"Traduction des fichiers G-Code en commandes de microcontr\u00f4leur"},{"location":"Debugging.html#analyse-de-mouvements-et-enregistrement-de-donnees","text":"Klipper prend en charge la journalisation de l'historique des mouvement, qui peut \u00eatre analys\u00e9 ult\u00e9rieurement. Pour utiliser cette fonctionnalit\u00e9, Klipper doit \u00eatre d\u00e9marr\u00e9 avec le Serveur API activ\u00e9. L'enregistrement des donn\u00e9es est activ\u00e9 avec l'outil data_logger.py . Par example\u202f: ~/klipper/scripts/motan/data_logger.py /tmp/klippy_uds mylog Cette commande se connectera au serveur API de Klipper, s'abonnera aux informations d'\u00e9tat et de mouvement et consignera les r\u00e9sultats. Deux fichiers sont g\u00e9n\u00e9r\u00e9s : un fichier de donn\u00e9es compress\u00e9es et un fichier d'index (par exemple, mylog.json.gz et mylog.index.gz ). Apr\u00e8s avoir d\u00e9marr\u00e9 la journalisation, il est possible d'effectuer des impressions et d'autres actions - la journalisation se poursuivra en arri\u00e8re-plan. Une fois la journalisation termin\u00e9e, appuyez sur ctrl-c pour quitter l'outil data_logger.py . Les fichiers r\u00e9sultants peuvent \u00eatre lus et repr\u00e9sent\u00e9s graphiquement \u00e0 l'aide de l'outil motan_graph.py . Pour g\u00e9n\u00e9rer des graphiques sur un Raspberry Pi, une seule \u00e9tape est n\u00e9cessaire pour installer le package \"matplotlib\"\u202f: sudo apt-get update sudo apt-get install python-matplotlib Cependant, il peut \u00eatre plus pratique de copier les fichiers de donn\u00e9es sur une machine de bureau avec le code Python dans le r\u00e9pertoire scripts/motan/ . Les scripts d'analyse de mouvement doivent s'ex\u00e9cuter sur n'importe quelle machine sur laquelle une version r\u00e9cente de Python et Matplotlib est install\u00e9e. Les graphiques peuvent \u00eatre g\u00e9n\u00e9r\u00e9s avec une commande comme celle-ci : ~/klipper/scripts/motan/motan_graph.py mylog -o mygraph.png On peut utiliser l'option -g pour sp\u00e9cifier les jeux de donn\u00e9es \u00e0 repr\u00e9senter graphiquement (il faut un litt\u00e9ral Python contenant une liste de listes). Par exemple\u202f: ~/klipper/scripts/motan/motan_graph.py mylog -g '[[\"trapq(toolhead,velocity)\"], [\"trapq(toolhead,accel)\"]]' La liste des ensembles de donn\u00e9es disponibles peut \u00eatre trouv\u00e9e en utilisant l'option -l - par exemple : ~/klipper/scripts/motan/motan_graph.py -l Il est \u00e9galement possible de sp\u00e9cifier les options de trac\u00e9 matplotlib pour chaque jeu de donn\u00e9es : ~/klipper/scripts/motan/motan_graph.py mylog -g '[[\"trapq(toolhead,velocity)?color=red&alpha=0.4\"]]' De nombreuses options matplotlib sont disponibles ; quelques exemples sont \"color\", \"label\", \"alpha\" et \"linestyle\". L'outil motan_graph.py prend en charge plusieurs autres options de ligne de commande - utilisez l'option --help pour afficher une liste. Il peut \u00e9galement \u00eatre pratique de visualiser/modifier le script motan_graph.py lui-m\u00eame. Les journaux de donn\u00e9es brutes produits par l'outil data_logger.py suivent le format d\u00e9crit dans Serveur API . Il peut \u00eatre utile d'inspecter les donn\u00e9es avec une commande Unix comme celle-ci : gunzip < mylog.json.gz | tr '\\03' '\\n' | moins","title":"Analyse de mouvements et enregistrement de donn\u00e9es"},{"location":"Debugging.html#generation-de-graphiques-de-charge","text":"Le fichier journal Klippy (/tmp/klippy.log) stocke des statistiques sur la bande passante utilis\u00e9e, la charge du microcontr\u00f4leur et la charge du tampon h\u00f4te. Il peut \u00eatre utile de repr\u00e9senter graphiquement ces statistiques apr\u00e8s une impression. Pour g\u00e9n\u00e9rer un graphique, une seule \u00e9tape est n\u00e9cessaire pour installer le package \"matplotlib\"\u202f: sudo apt-get update sudo apt-get install python-matplotlib Ensuite, les graphiques peuvent \u00eatre produits avec\u202f: ~/klipper/scripts/graphstats.py /tmp/klippy.log -o loadgraph.png On peut alors visualiser le fichier loadgraph.png r\u00e9sultant. Diff\u00e9rents graphiques peuvent \u00eatre produits. Pour plus d'informations, ex\u00e9cutez : ~/klipper/scripts/graphstats.py --help","title":"G\u00e9n\u00e9ration de graphiques de charge"},{"location":"Debugging.html#extraire-des-informations-du-fichier-klippylog","text":"Le fichier journal Klippy (/tmp/klippy.log) contient \u00e9galement des informations de d\u00e9bogage. Il existe un script logextract.py qui peut \u00eatre utile lors de l'analyse d'un arr\u00eat de microcontr\u00f4leur ou d'un probl\u00e8me similaire. Il est g\u00e9n\u00e9ralement ex\u00e9cut\u00e9 avec quelque chose comme : mkdir work_directory cd work_directory cp /tmp/klippy.log . ~/klipper/scripts/logextract.py ./klippy.log Le script extrait le fichier de configuration de l'imprimante et extrait les informations d'arr\u00eat du MCU. Les vidages d'informations d'un arr\u00eat de MCU (le cas \u00e9ch\u00e9ant) sont r\u00e9organis\u00e9s par horodatage pour faciliter le diagnostic des sc\u00e9narios de cause \u00e0 effet.","title":"Extraire des informations du fichier klippy.log"},{"location":"Debugging.html#tester-avec-simulavr","text":"L'outil simulavr permet de simuler un microcontr\u00f4leur Atmel ATmega. Cette section d\u00e9crit comment ex\u00e9cuter des fichiers gcode de test via simulavr. Il est recommand\u00e9 de l'ex\u00e9cuter sur une machine de bureau (pas un Raspberry Pi) car il n\u00e9cessite un processeur puissant pour fonctionner efficacement. Pour utiliser simulavr, t\u00e9l\u00e9chargez le package simulavr et compilez avec le support python. Notez que le syst\u00e8me de construction peut n\u00e9cessiter l'installation de certains packages (tels que swig) afin de construire le module python. git clone git://git.savannah.nongnu.org/simulavr.git cd simulavr make python make build Assurez-vous qu'un fichier ./build/pysimulavr/_pysimulavr.*.so est pr\u00e9sent apr\u00e8s la compilation ci-dessus : ls ./build/pysimulavr/_pysimulavr.*.so Cette commande doit signaler un fichier sp\u00e9cifique (par exemple ./build/pysimulavr/_pysimulavr.cpython-39-x86_64-linux-gnu.so ) et non une erreur. Si vous \u00eates sur un syst\u00e8me bas\u00e9 sur Debian (Debian, Ubuntu, etc.), vous pouvez installer les packages suivants et g\u00e9n\u00e9rer des fichiers *.deb pour une installation de simulavr \u00e0 l'\u00e9chelle du syst\u00e8me : sudo apt update sudo apt install g++ make cmake swig rst2pdf help2man texinfo make cfgclean python debian sudo dpkg -i build/debian/python3-simulavr*.deb Pour compiler Klipper pour une utilisation dans simulavr, ex\u00e9cutez : cd /path/to/klipper make menuconfig et compilez le logiciel du microcontr\u00f4leur pour un AVR atmega644p et s\u00e9lectionnez le support d'\u00e9mulation du logiciel SIMULAVR. Ensuite on peut compiler Klipper (lancer make ) puis lancer la simulation avec : PYTHONPATH=/path/to/simulavr/build/pysimulavr/ ./scripts/avrsim.py out/klipper.elf Si vous avez install\u00e9 python3-simulavr au niveau syst\u00e8me, vous n'avez pas besoin de d\u00e9finir PYTHONPATH , et vous pouvez simplement ex\u00e9cuter le simulateur comme ./scripts/avrsim.py out/klipper.elf Ensuite, avec simulavr en cours d\u2019ex\u00e9cution dans une autre fen\u00eatre, on peut ex\u00e9cuter ce qui suit pour lire le gcode d\u2019un fichier (par exemple, \u00ab test.gcode \u00bb), le traiter avec Klippy, et l\u2019envoyer \u00e0 Klipper ex\u00e9cut\u00e9 dans simulavr (voir installation pour les \u00e9tapes n\u00e9cessaires \u00e0 la construction de l\u2019environnement virtuel python)\u202f: ~/klippy-env/bin/python ./klippy/klippy.py config/generic-simulavr.cfg -i test.gcode -v","title":"Tester avec simulavr"},{"location":"Debugging.html#utiliser-simulavr-avec-gtkwave","text":"Une fonctionnalit\u00e9 utile de simulavr est sa capacit\u00e9 \u00e0 cr\u00e9er des fichiers de g\u00e9n\u00e9ration d'ondes avec la synchronisation exacte des \u00e9v\u00e9nements. Pour ce faire, suivez les instructions ci-dessus, mais ex\u00e9cutez avrsim.py avec une ligne de commande comme celle-ci : PYTHONPATH=/path/to/simulavr/src/python/ ./scripts/avrsim.py out/klipper.elf -t PORTA.PORT,PORTC.PORT Ce qui pr\u00e9c\u00e8de cr\u00e9era un fichier avrsim.vcd avec des informations sur chaque modification des GPIO sur PORTA et PORTB. Ce fichier pourra ensuite \u00eatre visualis\u00e9 en utilisant gtkwave avec : gtkwave avrsim.vcd","title":"Utiliser simulavr avec gtkwave"},{"location":"Delta_Calibrate.html","text":"\u00c9talonnage Delta \u00b6 Ce document d\u00e9crit le syst\u00e8me de calibration automatique de Klipper pour les imprimantes de type \"delta\". L'\u00e9talonnage Delta consiste \u00e0 trouver les positions pour les but\u00e9es de tours, les angles des tours, le rayon et les longueurs de bras. Ces param\u00e8tres contr\u00f4lent le mouvement d'une imprimante Delta. Chacun de ces param\u00e8tres a un impact non trivial et non lin\u00e9aire et il est difficile de les calibrer manuellement. En revanche, le code d'\u00e9talonnage logiciel peut fournir d'excellents r\u00e9sultats en quelques minutes seulement. Aucun mat\u00e9riel de mesure n'est n\u00e9cessaire. L'\u00e9talonnage Delta d\u00e9pend de la pr\u00e9cision des interrupteurs de fin de course de chaque tour. Si l'on utilise des pilotes de moteur pas \u00e0 pas Trinamic, envisagez d'activer la d\u00e9tection de phase d'arr\u00eat pour am\u00e9liorer la pr\u00e9cision de ces commutateurs. Sondage automatique vs manuel \u00b6 Klipper prend en charge l'\u00e9talonnage des param\u00e8tres delta via une m\u00e9thode de sondage manuelle ou via une sonde Z automatique. Un certain nombre de kits d'imprimantes delta sont livr\u00e9s avec des sondes Z automatiques qui ne sont pas suffisamment pr\u00e9cises (en particulier, de petites diff\u00e9rences sur la longueur des bras peuvent provoquer une inclinaison de la sonde qui peut fausser les mesures). Si vous utilisez une sonde automatique, \u00e9talonnez d'abord la sonde , puis recherchez le biais d'emplacement de la sonde . Si la sonde automatique a un biais de plus de 25 microns (0,025 mm), utilisez plut\u00f4t le palpage manuel. Le palpage manuel ne prend que quelques minutes et \u00e9limine les erreurs introduites par la sonde. Si vous utilisez une sonde mont\u00e9e sur le c\u00f4t\u00e9 de la t\u00eate (c'est-\u00e0-dire qu'elle a un d\u00e9calage X ou Y par rapport \u00e0 l'axe de la buse), notez que l'\u00e9talonnage delta invalidera les r\u00e9sultats de l'\u00e9talonnage de la sonde. Ces types de sondes sont rarement adapt\u00e9s \u00e0 une utilisation sur une delta (car une inclinaison mineure de l'effecteur entra\u00eenera un biais de localisation de la sonde). Si vous utilisez quand m\u00eame la sonde, assurez-vous de relancer l'\u00e9talonnage de la sonde apr\u00e8s tout \u00e9talonnage delta. \u00c9talonnage Delta de base \u00b6 Klipper a une commande DELTA_CALIBRATE qui peut effectuer un \u00e9talonnage Delta de base. Cette commande sonde sept points diff\u00e9rents sur le lit et calcule de nouvelles valeurs pour les angles de la tour, les but\u00e9es de la tour et le rayon delta. Afin d'effectuer cet \u00e9talonnage, les param\u00e8tres delta initiaux (longueurs de bras, rayon et positions des fin de course) doivent \u00eatre fournis et ils doivent avoir une pr\u00e9cision de quelques millim\u00e8tres. La plupart des kits d'imprimante delta fournissent ces param\u00e8tres - configurez l'imprimante avec ces valeurs par d\u00e9faut, puis ex\u00e9cutez la commande DELTA_CALIBRATE comme d\u00e9crit ci-dessous. Si aucune valeur par d\u00e9faut n'est disponible, recherchez en ligne un guide d'\u00e9talonnage delta qui pourra vous fournir un point de d\u00e9part de base. Au cours du processus d'\u00e9talonnage Delta, il peut \u00eatre n\u00e9cessaire que l'imprimante sonde 'en dessous' de ce qui serait autrement consid\u00e9r\u00e9 comme le plan du lit. Il est courant d'autoriser cela lors de l'\u00e9talonnage en mettant \u00e0 jour la configuration de sorte que la position minimum_z_position=-5 de l'imprimante. (Une fois l'\u00e9talonnage termin\u00e9, on peut supprimer ce param\u00e8tre de la configuration.) Il existe deux fa\u00e7ons d'effectuer le sondage : le sondage manuel ( DELTA_CALIBRATE METHOD=manual ) et le sondage automatique ( DELTA_CALIBRATE ). La m\u00e9thode de sondage manuel d\u00e9placera la t\u00eate pr\u00e8s du lit, puis attendra que l'utilisateur suive les \u00e9tapes d\u00e9crites dans \"le test du papier\" pour d\u00e9terminer la distance r\u00e9elle entre la buse et lit \u00e0 l'endroit indiqu\u00e9. Pour effectuer le sondage initial, assurez-vous que la configuration a une section [delta_calibrate] d\u00e9finie, puis ex\u00e9cutez l'outil : G28 DELTA_CALIBRATE METHOD=manual Apr\u00e8s avoir sond\u00e9 les sept points, de nouveaux param\u00e8tres Delta seront calcul\u00e9s. Enregistrez et appliquez ces param\u00e8tres en ex\u00e9cutant : SAVE_CONFIG L'\u00e9talonnage initial doit fournir des param\u00e8tres Delta suffisamment pr\u00e9cis pour une impression. S'il s'agit d'une nouvelle imprimante, c'est le bon moment pour imprimer certains objets simples et v\u00e9rifier son bon fonctionnement. \u00c9talonnage Delta avanc\u00e9 \u00b6 L'\u00e9talonnage Delta de base fait g\u00e9n\u00e9ralement un bon travail de calcul des param\u00e8tres delta de sorte que la buse soit \u00e0 la bonne distance du lit. Cependant, il n'essaye pas de calibrer la pr\u00e9cision dimensionnelle X et Y. L'\u00e9talonnage delta am\u00e9lior\u00e9 permet de v\u00e9rifier la pr\u00e9cision dimensionnelle. Cette proc\u00e9dure d'\u00e9talonnage n\u00e9cessite l'impression d'un objet de test et la mesure de parties de cet objet de test avec un pied \u00e0 coulisse. Avant d'ex\u00e9cuter un \u00e9talonnage delta avanc\u00e9, il faut ex\u00e9cuter l'\u00e9talonnage delta de base (via la commande DELTA_CALIBRATE) et enregistrer les r\u00e9sultats (via la commande SAVE_CONFIG). Assurez-vous qu'il n'y a eu aucun changement notable dans la configuration de l'imprimante ni dans le mat\u00e9riel depuis le dernier \u00e9talonnage delta de base (en cas de doute, r\u00e9ex\u00e9cutez l' \u00e9talonnage delta de base , y compris SAVE_CONFIG, juste avant l'impression l'objet de test d\u00e9crit ci-dessous.) Utilisez un trancheur pour g\u00e9n\u00e9rer le G-Code \u00e0 partir du fichier docs/prints/calibrate_size.stl . Tranchez l'objet en utilisant une vitesse lente (par exemple, 40 mm/s). Si possible, utilisez un plastique rigide (comme le PLA) pour l'objet. L'objet a un diam\u00e8tre de 140 mm. Si c'est trop grand pour l'imprimante, il est possible de le r\u00e9duire (mais assurez-vous de mettre uniform\u00e9ment \u00e0 l'\u00e9chelle les axes X et Y). Si l'imprimante prend en charge des impressions beaucoup plus grandes, cet objet peut \u00e9galement \u00eatre agrandi. Une taille plus grande peut am\u00e9liorer la pr\u00e9cision de la mesure, mais une bonne adh\u00e9rence de l'impression est plus importante qu'une taille d'impression plus grande. Imprimez l'objet \u00e0 tester et attendez qu'il refroidisse compl\u00e8tement. Les commandes d\u00e9crites ci-dessous doivent \u00eatre ex\u00e9cut\u00e9es avec les m\u00eames param\u00e8tres d'imprimante que ceux utilis\u00e9s pour imprimer l'objet de calibrage (ne pas ex\u00e9cuter DELTA_CALIBRATE entre l'impression et la mesure, ou faire quelque chose d'autre qui changerait la configuration de l'imprimante). Si possible, effectuez les mesures d\u00e9crites ci-dessous pendant que l'objet est toujours attach\u00e9 au lit d'impression, mais ne vous inqui\u00e9tez pas si la pi\u00e8ce se d\u00e9tache du lit - essayez simplement d'\u00e9viter de tordre l'objet lors de l'ex\u00e9cution des mesures. Commencez par mesurer la distance entre le pilier central et le pilier \u00e0 c\u00f4t\u00e9 de l'\u00e9tiquette \"A\" (qui doit \u00e9galement pointer vers la tour \"A\"). Ensuite, allez dans le sens inverse des aiguilles d'une montre et mesurez les distances entre le pilier central et les autres piliers (distance du centre au pilier en face de l'\u00e9tiquette C, distance du centre au pilier avec l'\u00e9tiquette B, etc.). Entrez ces param\u00e8tres dans Klipper avec une liste de nombres r\u00e9els (/!\\ utilisez le point comme s\u00e9parateur d\u00e9cimal) s\u00e9par\u00e9s par des virgules : DELTA_ANALYZE CENTER_DISTS=<a_dist>,<far_c_dist>,<b_dist>,<far_a_dist>,<c_dist>,<far_b_dist> Fournissez les valeurs sans espaces entre chaque valeurs. Mesurez ensuite la distance entre le pilier A et le pilier en face de l'\u00e9tiquette C. Ensuite, dans le sens antihoraire, mesurez la distance entre le pilier en face de C et le pilier B, la distance entre le pilier B et le pilier en face de A, et ainsi de suite. Saisissez ces param\u00e8tres dans Klipper : DELTA_ANALYZE OUTER_DISTS=<a_to_far_c>,<far_c_to_b>,<b_to_far_a>,<far_a_to_c>,<c_to_far_b>,<far_b_to_a> \u00c0 ce stade, vous pouvez retirer l'objet du lit. Les mesures finales concernent les piliers eux-m\u00eames. Mesurez la taille du pilier central le long du rayon A, puis du rayon B, puis du rayon C. Saisissez-les dans Klipper : DELTA_ANALYZE CENTER_PILLAR_WIDTHS=<a>,<b>,<c> Les mesures finales concernent les piliers ext\u00e9rieurs. Commencez par mesurer la distance du pilier A le long de la ligne allant de A au pilier en face de C. Ensuite, dans le sens antihoraire, mesurez les piliers ext\u00e9rieurs restants (pilier en face de C le long de la ligne vers B, pilier B le long de la ligne vers le pilier en face de A, etc.). Et entrez-les dans Klipper : DELTA_ANALYZE OUTER_PILLAR_WIDTHS=<a>,<far_c>,<b>,<far_a>,<c>,<far_b> Si l'objet a \u00e9t\u00e9 mis \u00e0 l'\u00e9chelle \u00e0 une taille plus petite ou plus grande, indiquez le facteur d'\u00e9chelle utilis\u00e9 lors du d\u00e9coupage de l'objet : DELTA_ANALYZE SCALE=1.0 (Une valeur d'\u00e9chelle de 2,0 signifierait que l'objet est deux fois sa taille d'origine, 0,5 serait la moiti\u00e9 de sa taille d'origine.) Enfin, effectuez l'\u00e9talonnage delta am\u00e9lior\u00e9 en ex\u00e9cutant : DELTA_ANALYZE CALIBRATE=extended Cette commande peut prendre plusieurs minutes. Une fois termin\u00e9, elle calculera les param\u00e8tres delta mis \u00e0 jour (rayon delta, angles de tour, positions de but\u00e9e et longueurs de bras). Utilisez la commande SAVE_CONFIG pour enregistrer et appliquer les param\u00e8tres : SAVE_CONFIG La commande SAVE_CONFIG enregistre \u00e0 la fois les param\u00e8tres delta mis \u00e0 jour et les informations des mesures de distance. Les futures commandes DELTA_CALIBRATE utiliseront \u00e9galement ces informations de distance. N'essayez pas de ressaisir les mesures de distance brutes apr\u00e8s avoir ex\u00e9cut\u00e9 SAVE_CONFIG, car cette commande modifie la configuration de l'imprimante et les mesures brutes ne s'appliquent plus. Notes compl\u00e9mentaires \u00b6 Si l'imprimante Delta a une bonne pr\u00e9cision dimensionnelle, la distance entre deux piliers doit \u00eatre d'environ 74 mm et la largeur de chaque pilier doit \u00eatre d'environ 9 mm. (Plus pr\u00e9cis\u00e9ment, l'objectif est que la distance entre deux piliers moins la largeur de l'un des piliers soit exactement de 65 mm.) S'il y a une inexactitude dimensionnelle dans la pi\u00e8ce, la routine DELTA_ANALYZE calculera de nouveaux param\u00e8tres delta en utilisant \u00e0 la fois les mesures de distance et les mesures de hauteur pr\u00e9c\u00e9dentes de la derni\u00e8re commande DELTA_CALIBRATE. DELTA_ANALYZE peut g\u00e9nerer des param\u00e8tres delta surprenants. Par exemple, il peut sugg\u00e9rer des longueurs de bras qui ne correspondent pas aux longueurs de bras r\u00e9elles de l'imprimante. Malgr\u00e9 cela, les tests ont montr\u00e9 que DELTA_ANALYZE produit souvent de bons r\u00e9sultats. Les param\u00e8tres delta calcul\u00e9s sont capables de tenir compte de l\u00e9g\u00e8res erreurs ailleurs dans le mat\u00e9riel. Par exemple, de petites diff\u00e9rences de longueur de bras peuvent entra\u00eener une inclinaison de l'effecteur et une partie de cette inclinaison peut \u00eatre prise en compte en ajustant les param\u00e8tres de longueur de bras. Utilisation d'un maillage du lit sur une Delta \u00b6 Il est possible d'utiliser le maillage du lit sur une Delta. Cependant, il est important d'obtenir un bon \u00e9talonnage Delta avant d'activer un maillage du lit. L'ex\u00e9cution d'un maillage du lit avec un mauvais calibrage delta entra\u00eenera des r\u00e9sultats m\u00e9diocres. Notez que l'ex\u00e9cution de l'\u00e9talonnage delta invalidera tout maillage de lit pr\u00e9c\u00e9demment obtenu. Apr\u00e8s avoir effectu\u00e9 un nouvel \u00e9talonnage delta, assurez-vous de relancer BED_MESH_CALIBRATE.","title":"\u00c9talonnage Delta"},{"location":"Delta_Calibrate.html#etalonnage-delta","text":"Ce document d\u00e9crit le syst\u00e8me de calibration automatique de Klipper pour les imprimantes de type \"delta\". L'\u00e9talonnage Delta consiste \u00e0 trouver les positions pour les but\u00e9es de tours, les angles des tours, le rayon et les longueurs de bras. Ces param\u00e8tres contr\u00f4lent le mouvement d'une imprimante Delta. Chacun de ces param\u00e8tres a un impact non trivial et non lin\u00e9aire et il est difficile de les calibrer manuellement. En revanche, le code d'\u00e9talonnage logiciel peut fournir d'excellents r\u00e9sultats en quelques minutes seulement. Aucun mat\u00e9riel de mesure n'est n\u00e9cessaire. L'\u00e9talonnage Delta d\u00e9pend de la pr\u00e9cision des interrupteurs de fin de course de chaque tour. Si l'on utilise des pilotes de moteur pas \u00e0 pas Trinamic, envisagez d'activer la d\u00e9tection de phase d'arr\u00eat pour am\u00e9liorer la pr\u00e9cision de ces commutateurs.","title":"\u00c9talonnage Delta"},{"location":"Delta_Calibrate.html#sondage-automatique-vs-manuel","text":"Klipper prend en charge l'\u00e9talonnage des param\u00e8tres delta via une m\u00e9thode de sondage manuelle ou via une sonde Z automatique. Un certain nombre de kits d'imprimantes delta sont livr\u00e9s avec des sondes Z automatiques qui ne sont pas suffisamment pr\u00e9cises (en particulier, de petites diff\u00e9rences sur la longueur des bras peuvent provoquer une inclinaison de la sonde qui peut fausser les mesures). Si vous utilisez une sonde automatique, \u00e9talonnez d'abord la sonde , puis recherchez le biais d'emplacement de la sonde . Si la sonde automatique a un biais de plus de 25 microns (0,025 mm), utilisez plut\u00f4t le palpage manuel. Le palpage manuel ne prend que quelques minutes et \u00e9limine les erreurs introduites par la sonde. Si vous utilisez une sonde mont\u00e9e sur le c\u00f4t\u00e9 de la t\u00eate (c'est-\u00e0-dire qu'elle a un d\u00e9calage X ou Y par rapport \u00e0 l'axe de la buse), notez que l'\u00e9talonnage delta invalidera les r\u00e9sultats de l'\u00e9talonnage de la sonde. Ces types de sondes sont rarement adapt\u00e9s \u00e0 une utilisation sur une delta (car une inclinaison mineure de l'effecteur entra\u00eenera un biais de localisation de la sonde). Si vous utilisez quand m\u00eame la sonde, assurez-vous de relancer l'\u00e9talonnage de la sonde apr\u00e8s tout \u00e9talonnage delta.","title":"Sondage automatique vs manuel"},{"location":"Delta_Calibrate.html#etalonnage-delta-de-base","text":"Klipper a une commande DELTA_CALIBRATE qui peut effectuer un \u00e9talonnage Delta de base. Cette commande sonde sept points diff\u00e9rents sur le lit et calcule de nouvelles valeurs pour les angles de la tour, les but\u00e9es de la tour et le rayon delta. Afin d'effectuer cet \u00e9talonnage, les param\u00e8tres delta initiaux (longueurs de bras, rayon et positions des fin de course) doivent \u00eatre fournis et ils doivent avoir une pr\u00e9cision de quelques millim\u00e8tres. La plupart des kits d'imprimante delta fournissent ces param\u00e8tres - configurez l'imprimante avec ces valeurs par d\u00e9faut, puis ex\u00e9cutez la commande DELTA_CALIBRATE comme d\u00e9crit ci-dessous. Si aucune valeur par d\u00e9faut n'est disponible, recherchez en ligne un guide d'\u00e9talonnage delta qui pourra vous fournir un point de d\u00e9part de base. Au cours du processus d'\u00e9talonnage Delta, il peut \u00eatre n\u00e9cessaire que l'imprimante sonde 'en dessous' de ce qui serait autrement consid\u00e9r\u00e9 comme le plan du lit. Il est courant d'autoriser cela lors de l'\u00e9talonnage en mettant \u00e0 jour la configuration de sorte que la position minimum_z_position=-5 de l'imprimante. (Une fois l'\u00e9talonnage termin\u00e9, on peut supprimer ce param\u00e8tre de la configuration.) Il existe deux fa\u00e7ons d'effectuer le sondage : le sondage manuel ( DELTA_CALIBRATE METHOD=manual ) et le sondage automatique ( DELTA_CALIBRATE ). La m\u00e9thode de sondage manuel d\u00e9placera la t\u00eate pr\u00e8s du lit, puis attendra que l'utilisateur suive les \u00e9tapes d\u00e9crites dans \"le test du papier\" pour d\u00e9terminer la distance r\u00e9elle entre la buse et lit \u00e0 l'endroit indiqu\u00e9. Pour effectuer le sondage initial, assurez-vous que la configuration a une section [delta_calibrate] d\u00e9finie, puis ex\u00e9cutez l'outil : G28 DELTA_CALIBRATE METHOD=manual Apr\u00e8s avoir sond\u00e9 les sept points, de nouveaux param\u00e8tres Delta seront calcul\u00e9s. Enregistrez et appliquez ces param\u00e8tres en ex\u00e9cutant : SAVE_CONFIG L'\u00e9talonnage initial doit fournir des param\u00e8tres Delta suffisamment pr\u00e9cis pour une impression. S'il s'agit d'une nouvelle imprimante, c'est le bon moment pour imprimer certains objets simples et v\u00e9rifier son bon fonctionnement.","title":"\u00c9talonnage Delta de base"},{"location":"Delta_Calibrate.html#etalonnage-delta-avance","text":"L'\u00e9talonnage Delta de base fait g\u00e9n\u00e9ralement un bon travail de calcul des param\u00e8tres delta de sorte que la buse soit \u00e0 la bonne distance du lit. Cependant, il n'essaye pas de calibrer la pr\u00e9cision dimensionnelle X et Y. L'\u00e9talonnage delta am\u00e9lior\u00e9 permet de v\u00e9rifier la pr\u00e9cision dimensionnelle. Cette proc\u00e9dure d'\u00e9talonnage n\u00e9cessite l'impression d'un objet de test et la mesure de parties de cet objet de test avec un pied \u00e0 coulisse. Avant d'ex\u00e9cuter un \u00e9talonnage delta avanc\u00e9, il faut ex\u00e9cuter l'\u00e9talonnage delta de base (via la commande DELTA_CALIBRATE) et enregistrer les r\u00e9sultats (via la commande SAVE_CONFIG). Assurez-vous qu'il n'y a eu aucun changement notable dans la configuration de l'imprimante ni dans le mat\u00e9riel depuis le dernier \u00e9talonnage delta de base (en cas de doute, r\u00e9ex\u00e9cutez l' \u00e9talonnage delta de base , y compris SAVE_CONFIG, juste avant l'impression l'objet de test d\u00e9crit ci-dessous.) Utilisez un trancheur pour g\u00e9n\u00e9rer le G-Code \u00e0 partir du fichier docs/prints/calibrate_size.stl . Tranchez l'objet en utilisant une vitesse lente (par exemple, 40 mm/s). Si possible, utilisez un plastique rigide (comme le PLA) pour l'objet. L'objet a un diam\u00e8tre de 140 mm. Si c'est trop grand pour l'imprimante, il est possible de le r\u00e9duire (mais assurez-vous de mettre uniform\u00e9ment \u00e0 l'\u00e9chelle les axes X et Y). Si l'imprimante prend en charge des impressions beaucoup plus grandes, cet objet peut \u00e9galement \u00eatre agrandi. Une taille plus grande peut am\u00e9liorer la pr\u00e9cision de la mesure, mais une bonne adh\u00e9rence de l'impression est plus importante qu'une taille d'impression plus grande. Imprimez l'objet \u00e0 tester et attendez qu'il refroidisse compl\u00e8tement. Les commandes d\u00e9crites ci-dessous doivent \u00eatre ex\u00e9cut\u00e9es avec les m\u00eames param\u00e8tres d'imprimante que ceux utilis\u00e9s pour imprimer l'objet de calibrage (ne pas ex\u00e9cuter DELTA_CALIBRATE entre l'impression et la mesure, ou faire quelque chose d'autre qui changerait la configuration de l'imprimante). Si possible, effectuez les mesures d\u00e9crites ci-dessous pendant que l'objet est toujours attach\u00e9 au lit d'impression, mais ne vous inqui\u00e9tez pas si la pi\u00e8ce se d\u00e9tache du lit - essayez simplement d'\u00e9viter de tordre l'objet lors de l'ex\u00e9cution des mesures. Commencez par mesurer la distance entre le pilier central et le pilier \u00e0 c\u00f4t\u00e9 de l'\u00e9tiquette \"A\" (qui doit \u00e9galement pointer vers la tour \"A\"). Ensuite, allez dans le sens inverse des aiguilles d'une montre et mesurez les distances entre le pilier central et les autres piliers (distance du centre au pilier en face de l'\u00e9tiquette C, distance du centre au pilier avec l'\u00e9tiquette B, etc.). Entrez ces param\u00e8tres dans Klipper avec une liste de nombres r\u00e9els (/!\\ utilisez le point comme s\u00e9parateur d\u00e9cimal) s\u00e9par\u00e9s par des virgules : DELTA_ANALYZE CENTER_DISTS=<a_dist>,<far_c_dist>,<b_dist>,<far_a_dist>,<c_dist>,<far_b_dist> Fournissez les valeurs sans espaces entre chaque valeurs. Mesurez ensuite la distance entre le pilier A et le pilier en face de l'\u00e9tiquette C. Ensuite, dans le sens antihoraire, mesurez la distance entre le pilier en face de C et le pilier B, la distance entre le pilier B et le pilier en face de A, et ainsi de suite. Saisissez ces param\u00e8tres dans Klipper : DELTA_ANALYZE OUTER_DISTS=<a_to_far_c>,<far_c_to_b>,<b_to_far_a>,<far_a_to_c>,<c_to_far_b>,<far_b_to_a> \u00c0 ce stade, vous pouvez retirer l'objet du lit. Les mesures finales concernent les piliers eux-m\u00eames. Mesurez la taille du pilier central le long du rayon A, puis du rayon B, puis du rayon C. Saisissez-les dans Klipper : DELTA_ANALYZE CENTER_PILLAR_WIDTHS=<a>,<b>,<c> Les mesures finales concernent les piliers ext\u00e9rieurs. Commencez par mesurer la distance du pilier A le long de la ligne allant de A au pilier en face de C. Ensuite, dans le sens antihoraire, mesurez les piliers ext\u00e9rieurs restants (pilier en face de C le long de la ligne vers B, pilier B le long de la ligne vers le pilier en face de A, etc.). Et entrez-les dans Klipper : DELTA_ANALYZE OUTER_PILLAR_WIDTHS=<a>,<far_c>,<b>,<far_a>,<c>,<far_b> Si l'objet a \u00e9t\u00e9 mis \u00e0 l'\u00e9chelle \u00e0 une taille plus petite ou plus grande, indiquez le facteur d'\u00e9chelle utilis\u00e9 lors du d\u00e9coupage de l'objet : DELTA_ANALYZE SCALE=1.0 (Une valeur d'\u00e9chelle de 2,0 signifierait que l'objet est deux fois sa taille d'origine, 0,5 serait la moiti\u00e9 de sa taille d'origine.) Enfin, effectuez l'\u00e9talonnage delta am\u00e9lior\u00e9 en ex\u00e9cutant : DELTA_ANALYZE CALIBRATE=extended Cette commande peut prendre plusieurs minutes. Une fois termin\u00e9, elle calculera les param\u00e8tres delta mis \u00e0 jour (rayon delta, angles de tour, positions de but\u00e9e et longueurs de bras). Utilisez la commande SAVE_CONFIG pour enregistrer et appliquer les param\u00e8tres : SAVE_CONFIG La commande SAVE_CONFIG enregistre \u00e0 la fois les param\u00e8tres delta mis \u00e0 jour et les informations des mesures de distance. Les futures commandes DELTA_CALIBRATE utiliseront \u00e9galement ces informations de distance. N'essayez pas de ressaisir les mesures de distance brutes apr\u00e8s avoir ex\u00e9cut\u00e9 SAVE_CONFIG, car cette commande modifie la configuration de l'imprimante et les mesures brutes ne s'appliquent plus.","title":"\u00c9talonnage Delta avanc\u00e9"},{"location":"Delta_Calibrate.html#notes-complementaires","text":"Si l'imprimante Delta a une bonne pr\u00e9cision dimensionnelle, la distance entre deux piliers doit \u00eatre d'environ 74 mm et la largeur de chaque pilier doit \u00eatre d'environ 9 mm. (Plus pr\u00e9cis\u00e9ment, l'objectif est que la distance entre deux piliers moins la largeur de l'un des piliers soit exactement de 65 mm.) S'il y a une inexactitude dimensionnelle dans la pi\u00e8ce, la routine DELTA_ANALYZE calculera de nouveaux param\u00e8tres delta en utilisant \u00e0 la fois les mesures de distance et les mesures de hauteur pr\u00e9c\u00e9dentes de la derni\u00e8re commande DELTA_CALIBRATE. DELTA_ANALYZE peut g\u00e9nerer des param\u00e8tres delta surprenants. Par exemple, il peut sugg\u00e9rer des longueurs de bras qui ne correspondent pas aux longueurs de bras r\u00e9elles de l'imprimante. Malgr\u00e9 cela, les tests ont montr\u00e9 que DELTA_ANALYZE produit souvent de bons r\u00e9sultats. Les param\u00e8tres delta calcul\u00e9s sont capables de tenir compte de l\u00e9g\u00e8res erreurs ailleurs dans le mat\u00e9riel. Par exemple, de petites diff\u00e9rences de longueur de bras peuvent entra\u00eener une inclinaison de l'effecteur et une partie de cette inclinaison peut \u00eatre prise en compte en ajustant les param\u00e8tres de longueur de bras.","title":"Notes compl\u00e9mentaires"},{"location":"Delta_Calibrate.html#utilisation-dun-maillage-du-lit-sur-une-delta","text":"Il est possible d'utiliser le maillage du lit sur une Delta. Cependant, il est important d'obtenir un bon \u00e9talonnage Delta avant d'activer un maillage du lit. L'ex\u00e9cution d'un maillage du lit avec un mauvais calibrage delta entra\u00eenera des r\u00e9sultats m\u00e9diocres. Notez que l'ex\u00e9cution de l'\u00e9talonnage delta invalidera tout maillage de lit pr\u00e9c\u00e9demment obtenu. Apr\u00e8s avoir effectu\u00e9 un nouvel \u00e9talonnage delta, assurez-vous de relancer BED_MESH_CALIBRATE.","title":"Utilisation d'un maillage du lit sur une Delta"},{"location":"Endstop_Phase.html","text":"Phase de fin de course \u00b6 Ce document d\u00e9crit le syst\u00e8me de but\u00e9e ajust\u00e9e en phase pas \u00e0 pas de Klipper. Cette fonctionnalit\u00e9 peut am\u00e9liorer la pr\u00e9cision des interrupteurs de fin de course traditionnels. Il est particuli\u00e8rement utile lors de l'utilisation d'un pilote de moteur pas \u00e0 pas Trinamic dot\u00e9 d'une configuration d'ex\u00e9cution. Un interrupteur de fin de course standard a une pr\u00e9cision d'environ 100 microns. (Chaque fois qu'un axe est mis \u00e0 l'origine, le commutateur peut se d\u00e9clencher l\u00e9g\u00e8rement plus t\u00f4t ou l\u00e9g\u00e8rement plus tard.) Bien qu'il s'agisse d'une erreur relativement faible, elle peut entra\u00eener des artefacts ind\u00e9sirables. En particulier, cet \u00e9cart de position peut \u00eatre perceptible lors de l'impression de la premi\u00e8re couche d'un objet. En revanche, les moteurs pas \u00e0 pas standard peuvent obtenir une pr\u00e9cision nettement sup\u00e9rieure. Le m\u00e9canisme de fin de course \u00e0 ajustement de phase peut utiliser la pr\u00e9cision des moteurs pas \u00e0 pas pour am\u00e9liorer la pr\u00e9cision des interrupteurs de fin de course. Un moteur pas \u00e0 pas se d\u00e9place en suivant une s\u00e9rie de phase jusqu'\u00e0 ce qu'il effectue quatre \"\u00e9tapes compl\u00e8tes\". Ainsi, un moteur pas \u00e0 pas utilisant 16 micro-pas aura 64 phases et lorsqu'il se d\u00e9place dans le sens positif, il passera par phases : 0, 1, 2, ... 61, 62, 63, 0, 1, 2, etc. Il est important de noter que lorsque le moteur pas \u00e0 pas se trouve \u00e0 une position particuli\u00e8re sur un rail lin\u00e9aire, il doit toujours \u00eatre \u00e0 la m\u00eame phase. Ainsi, lorsqu'un chariot d\u00e9clenche l'interrupteur de fin de course, le moteur pas \u00e0 pas contr\u00f4lant ce chariot doit toujours \u00eatre \u00e0 la m\u00eame phase du moteur pas \u00e0 pas. Le syst\u00e8me de fin de course \u00e0 ajustement de phase de Klipper combine la phase du moteur pas \u00e0 pas avec le d\u00e9clencheur de fin de course pour am\u00e9liorer la pr\u00e9cision de la fin de course. Pour utiliser cette fonctionnalit\u00e9, il est n\u00e9cessaire de pouvoir identifier la phase du moteur pas \u00e0 pas. Si l'on utilise les pilotes Trinamic TMC2130, TMC2208, TMC2224 ou TMC2660 en mode de configuration d'ex\u00e9cution (c'est-\u00e0-dire pas en mode autonome - \"standalone\"), Klipper peut interroger la phase pas \u00e0 pas du pilote. (Il est \u00e9galement possible d'utiliser ce syst\u00e8me sur des pilotes pas \u00e0 pas traditionnels si l'on peut r\u00e9initialiser de mani\u00e8re fiable ces pilotes pas \u00e0 pas - voir ci-dessous pour plus de d\u00e9tails.) \u00c9talonnage des phases de fin de course \u00b6 Si vous utilisez des pilotes de moteurs pas \u00e0 pas Trinamic avec configuration en temps r\u00e9el, vous pouvez calibrer les phases de fin de course \u00e0 l'aide de la commande ENDSTOP_PHASE_CALIBRATE. Commencez par ajouter les \u00e9l\u00e9ments suivants au fichier de configuration : [endstop_phase] Red\u00e9marrez ensuite l'imprimante et ex\u00e9cutez une commande G28 suivie d'une commande ENDSTOP_PHASE_CALIBRATE . D\u00e9placez ensuite la t\u00eate vers un nouvel emplacement et ex\u00e9cutez \u00e0 nouveau G28 . Essayez de d\u00e9placer la t\u00eate \u00e0 plusieurs endroits diff\u00e9rents et r\u00e9ex\u00e9cutez G28 \u00e0 partir de chaque position. Ex\u00e9cutez au moins cinq commandes G28 . Apr\u00e8s avoir effectu\u00e9 ce qui pr\u00e9c\u00e8de, la commande ENDSTOP_PHASE_CALIBRATE signalera souvent la m\u00eame (ou presque la m\u00eame) phase pour le moteur pas \u00e0 pas. Cette phase peut \u00eatre enregistr\u00e9e dans le fichier de configuration afin que toutes les futures commandes G28 utilisent cette phase. (Ainsi, dans les futures op\u00e9rations de prise d'origine, Klipper obtiendra la m\u00eame position m\u00eame si la but\u00e9e de fin de course se d\u00e9clenche un peu plus t\u00f4t ou un peu plus tard.) Pour enregistrer la phase d'arr\u00eat final d'un moteur pas \u00e0 pas particulier, ex\u00e9cutez quelque chose comme ceci : ENDSTOP_PHASE_CALIBRATE STEPPER=stepper_z Ex\u00e9cutez ce qui pr\u00e9c\u00e8de pour tous les steppers que vous souhaitez enregistrer. En r\u00e8gle g\u00e9n\u00e9rale, on l'utiliserait sur stepper_z pour les imprimantes cart\u00e9siennes et corexy, et pour stepper_a, stepper_b et stepper_c sur les imprimantes delta. Enfin, ex\u00e9cutez la commande suivante pour mettre \u00e0 jour le fichier de configuration avec les donn\u00e9es : SAVE_CONFIG Notes compl\u00e9mentaires \u00b6 Cette fonctionnalit\u00e9 est particuli\u00e8rement utile sur les imprimantes delta et sur la but\u00e9e Z des imprimantes cart\u00e9siennes/corexy. Il est possible d'utiliser cette fonctionnalit\u00e9 sur les but\u00e9es XY des imprimantes cart\u00e9siennes, mais cela n'est pas particuli\u00e8rement utile car une erreur mineure dans la position de la but\u00e9e X/Y n'aura probablement pas d'impact sur la qualit\u00e9 d'impression. Il n'est pas valide d'utiliser cette fonctionnalit\u00e9 sur les but\u00e9es XY des imprimantes corexy (car la position XY n'est pas d\u00e9termin\u00e9e par un seul stepper sur la cin\u00e9matique corexy). Il n'est pas valide d'utiliser cette fonctionnalit\u00e9 sur une imprimante utilisant une but\u00e9e Z \"probe:z_virtual_endstop\" (car la phase pas \u00e0 pas n'est stable que si la but\u00e9e se trouve \u00e0 un emplacement statique sur un rail). Apr\u00e8s avoir calibr\u00e9 la phase de fin de course, si la fin de course est d\u00e9plac\u00e9e ou ajust\u00e9e ult\u00e9rieurement, il sera n\u00e9cessaire de recalibrer la phase de fin de course. Supprimez les donn\u00e9es d'\u00e9talonnage du fichier de configuration et r\u00e9ex\u00e9cutez les \u00e9tapes ci-dessus. Pour utiliser ce syst\u00e8me, la but\u00e9e doit \u00eatre suffisamment pr\u00e9cise pour identifier la position du stepper en deux \"pas complets\". Ainsi, par exemple, si un stepper utilise 16 micro-pas avec une distance de pas de 0,005 mm, la but\u00e9e doit avoir une pr\u00e9cision d'au moins 0,160 mm. Si l'on obtient des messages d'erreur de type \"Endstop stepper_z incorrect phase\", cela peut \u00eatre d\u00fb \u00e0 un endstop qui n'est pas suffisamment pr\u00e9cis. Si le recalibrage n'aide pas, d\u00e9sactivez les ajustements de phase de but\u00e9e en les supprimant du fichier de configuration. Si l'on utilise un axe Z traditionnel contr\u00f4l\u00e9 par pas \u00e0 pas (comme sur une imprimante cart\u00e9sienne ou corexy) avec des vis de nivellement de lit traditionnelles, il est \u00e9galement possible d'utiliser ce syst\u00e8me pour faire en sorte que chaque couche d'impression soit effectu\u00e9e sur une limite \"pas complet\" . Pour activer cette fonctionnalit\u00e9, assurez-vous que le slicer G-Code est configur\u00e9 avec une hauteur de couche qui est un multiple d'un \"pas complet\", activez manuellement l'option endstop_align_zero dans la section de configuration endstop_phase (voir reference de configuration pour plus de d\u00e9tails), puis remettez \u00e0 niveau les vis du lit. Il est possible d'utiliser ce syst\u00e8me avec des pilotes de moteurs pas \u00e0 pas traditionnels (non Trinamic). Cependant, cela n\u00e9cessite de s'assurer que les pilotes du moteur pas \u00e0 pas sont r\u00e9initialis\u00e9s \u00e0 chaque fois que le microcontr\u00f4leur est r\u00e9initialis\u00e9. (Si les deux sont toujours r\u00e9initialis\u00e9s ensemble, Klipper peut d\u00e9terminer la phase du moteur pas \u00e0 pas en suivant le nombre total de pas qu'il a command\u00e9 au moteur pas \u00e0 pas.) Actuellement, la seule fa\u00e7on de le faire de mani\u00e8re fiable est que le microcontr\u00f4leur et le moteur pas \u00e0 pas les pilotes soient aliment\u00e9s uniquement par USB et que l'alimentation USB soit fournie par un h\u00f4te fonctionnant sur un Raspberry Pi. Dans cette situation, on peut sp\u00e9cifier une configuration mcu avec \"restart_method\u202f: rpi_usb\" - cette option fera en sorte que le microcontr\u00f4leur soit toujours r\u00e9initialis\u00e9 via une r\u00e9initialisation de l'alimentation USB, ce qui permettrait \u00e0 la fois au microcontr\u00f4leur et aux pilotes de moteur pas \u00e0 pas d'\u00eatre r\u00e9initialiser ensemble. Si vous utilisez ce m\u00e9canisme, vous devrez alors configurer manuellement les sections de configuration \"trigger_phase\" (voir config reference pour les d\u00e9tails).","title":"Phase de fin de course"},{"location":"Endstop_Phase.html#phase-de-fin-de-course","text":"Ce document d\u00e9crit le syst\u00e8me de but\u00e9e ajust\u00e9e en phase pas \u00e0 pas de Klipper. Cette fonctionnalit\u00e9 peut am\u00e9liorer la pr\u00e9cision des interrupteurs de fin de course traditionnels. Il est particuli\u00e8rement utile lors de l'utilisation d'un pilote de moteur pas \u00e0 pas Trinamic dot\u00e9 d'une configuration d'ex\u00e9cution. Un interrupteur de fin de course standard a une pr\u00e9cision d'environ 100 microns. (Chaque fois qu'un axe est mis \u00e0 l'origine, le commutateur peut se d\u00e9clencher l\u00e9g\u00e8rement plus t\u00f4t ou l\u00e9g\u00e8rement plus tard.) Bien qu'il s'agisse d'une erreur relativement faible, elle peut entra\u00eener des artefacts ind\u00e9sirables. En particulier, cet \u00e9cart de position peut \u00eatre perceptible lors de l'impression de la premi\u00e8re couche d'un objet. En revanche, les moteurs pas \u00e0 pas standard peuvent obtenir une pr\u00e9cision nettement sup\u00e9rieure. Le m\u00e9canisme de fin de course \u00e0 ajustement de phase peut utiliser la pr\u00e9cision des moteurs pas \u00e0 pas pour am\u00e9liorer la pr\u00e9cision des interrupteurs de fin de course. Un moteur pas \u00e0 pas se d\u00e9place en suivant une s\u00e9rie de phase jusqu'\u00e0 ce qu'il effectue quatre \"\u00e9tapes compl\u00e8tes\". Ainsi, un moteur pas \u00e0 pas utilisant 16 micro-pas aura 64 phases et lorsqu'il se d\u00e9place dans le sens positif, il passera par phases : 0, 1, 2, ... 61, 62, 63, 0, 1, 2, etc. Il est important de noter que lorsque le moteur pas \u00e0 pas se trouve \u00e0 une position particuli\u00e8re sur un rail lin\u00e9aire, il doit toujours \u00eatre \u00e0 la m\u00eame phase. Ainsi, lorsqu'un chariot d\u00e9clenche l'interrupteur de fin de course, le moteur pas \u00e0 pas contr\u00f4lant ce chariot doit toujours \u00eatre \u00e0 la m\u00eame phase du moteur pas \u00e0 pas. Le syst\u00e8me de fin de course \u00e0 ajustement de phase de Klipper combine la phase du moteur pas \u00e0 pas avec le d\u00e9clencheur de fin de course pour am\u00e9liorer la pr\u00e9cision de la fin de course. Pour utiliser cette fonctionnalit\u00e9, il est n\u00e9cessaire de pouvoir identifier la phase du moteur pas \u00e0 pas. Si l'on utilise les pilotes Trinamic TMC2130, TMC2208, TMC2224 ou TMC2660 en mode de configuration d'ex\u00e9cution (c'est-\u00e0-dire pas en mode autonome - \"standalone\"), Klipper peut interroger la phase pas \u00e0 pas du pilote. (Il est \u00e9galement possible d'utiliser ce syst\u00e8me sur des pilotes pas \u00e0 pas traditionnels si l'on peut r\u00e9initialiser de mani\u00e8re fiable ces pilotes pas \u00e0 pas - voir ci-dessous pour plus de d\u00e9tails.)","title":"Phase de fin de course"},{"location":"Endstop_Phase.html#etalonnage-des-phases-de-fin-de-course","text":"Si vous utilisez des pilotes de moteurs pas \u00e0 pas Trinamic avec configuration en temps r\u00e9el, vous pouvez calibrer les phases de fin de course \u00e0 l'aide de la commande ENDSTOP_PHASE_CALIBRATE. Commencez par ajouter les \u00e9l\u00e9ments suivants au fichier de configuration : [endstop_phase] Red\u00e9marrez ensuite l'imprimante et ex\u00e9cutez une commande G28 suivie d'une commande ENDSTOP_PHASE_CALIBRATE . D\u00e9placez ensuite la t\u00eate vers un nouvel emplacement et ex\u00e9cutez \u00e0 nouveau G28 . Essayez de d\u00e9placer la t\u00eate \u00e0 plusieurs endroits diff\u00e9rents et r\u00e9ex\u00e9cutez G28 \u00e0 partir de chaque position. Ex\u00e9cutez au moins cinq commandes G28 . Apr\u00e8s avoir effectu\u00e9 ce qui pr\u00e9c\u00e8de, la commande ENDSTOP_PHASE_CALIBRATE signalera souvent la m\u00eame (ou presque la m\u00eame) phase pour le moteur pas \u00e0 pas. Cette phase peut \u00eatre enregistr\u00e9e dans le fichier de configuration afin que toutes les futures commandes G28 utilisent cette phase. (Ainsi, dans les futures op\u00e9rations de prise d'origine, Klipper obtiendra la m\u00eame position m\u00eame si la but\u00e9e de fin de course se d\u00e9clenche un peu plus t\u00f4t ou un peu plus tard.) Pour enregistrer la phase d'arr\u00eat final d'un moteur pas \u00e0 pas particulier, ex\u00e9cutez quelque chose comme ceci : ENDSTOP_PHASE_CALIBRATE STEPPER=stepper_z Ex\u00e9cutez ce qui pr\u00e9c\u00e8de pour tous les steppers que vous souhaitez enregistrer. En r\u00e8gle g\u00e9n\u00e9rale, on l'utiliserait sur stepper_z pour les imprimantes cart\u00e9siennes et corexy, et pour stepper_a, stepper_b et stepper_c sur les imprimantes delta. Enfin, ex\u00e9cutez la commande suivante pour mettre \u00e0 jour le fichier de configuration avec les donn\u00e9es : SAVE_CONFIG","title":"\u00c9talonnage des phases de fin de course"},{"location":"Endstop_Phase.html#notes-complementaires","text":"Cette fonctionnalit\u00e9 est particuli\u00e8rement utile sur les imprimantes delta et sur la but\u00e9e Z des imprimantes cart\u00e9siennes/corexy. Il est possible d'utiliser cette fonctionnalit\u00e9 sur les but\u00e9es XY des imprimantes cart\u00e9siennes, mais cela n'est pas particuli\u00e8rement utile car une erreur mineure dans la position de la but\u00e9e X/Y n'aura probablement pas d'impact sur la qualit\u00e9 d'impression. Il n'est pas valide d'utiliser cette fonctionnalit\u00e9 sur les but\u00e9es XY des imprimantes corexy (car la position XY n'est pas d\u00e9termin\u00e9e par un seul stepper sur la cin\u00e9matique corexy). Il n'est pas valide d'utiliser cette fonctionnalit\u00e9 sur une imprimante utilisant une but\u00e9e Z \"probe:z_virtual_endstop\" (car la phase pas \u00e0 pas n'est stable que si la but\u00e9e se trouve \u00e0 un emplacement statique sur un rail). Apr\u00e8s avoir calibr\u00e9 la phase de fin de course, si la fin de course est d\u00e9plac\u00e9e ou ajust\u00e9e ult\u00e9rieurement, il sera n\u00e9cessaire de recalibrer la phase de fin de course. Supprimez les donn\u00e9es d'\u00e9talonnage du fichier de configuration et r\u00e9ex\u00e9cutez les \u00e9tapes ci-dessus. Pour utiliser ce syst\u00e8me, la but\u00e9e doit \u00eatre suffisamment pr\u00e9cise pour identifier la position du stepper en deux \"pas complets\". Ainsi, par exemple, si un stepper utilise 16 micro-pas avec une distance de pas de 0,005 mm, la but\u00e9e doit avoir une pr\u00e9cision d'au moins 0,160 mm. Si l'on obtient des messages d'erreur de type \"Endstop stepper_z incorrect phase\", cela peut \u00eatre d\u00fb \u00e0 un endstop qui n'est pas suffisamment pr\u00e9cis. Si le recalibrage n'aide pas, d\u00e9sactivez les ajustements de phase de but\u00e9e en les supprimant du fichier de configuration. Si l'on utilise un axe Z traditionnel contr\u00f4l\u00e9 par pas \u00e0 pas (comme sur une imprimante cart\u00e9sienne ou corexy) avec des vis de nivellement de lit traditionnelles, il est \u00e9galement possible d'utiliser ce syst\u00e8me pour faire en sorte que chaque couche d'impression soit effectu\u00e9e sur une limite \"pas complet\" . Pour activer cette fonctionnalit\u00e9, assurez-vous que le slicer G-Code est configur\u00e9 avec une hauteur de couche qui est un multiple d'un \"pas complet\", activez manuellement l'option endstop_align_zero dans la section de configuration endstop_phase (voir reference de configuration pour plus de d\u00e9tails), puis remettez \u00e0 niveau les vis du lit. Il est possible d'utiliser ce syst\u00e8me avec des pilotes de moteurs pas \u00e0 pas traditionnels (non Trinamic). Cependant, cela n\u00e9cessite de s'assurer que les pilotes du moteur pas \u00e0 pas sont r\u00e9initialis\u00e9s \u00e0 chaque fois que le microcontr\u00f4leur est r\u00e9initialis\u00e9. (Si les deux sont toujours r\u00e9initialis\u00e9s ensemble, Klipper peut d\u00e9terminer la phase du moteur pas \u00e0 pas en suivant le nombre total de pas qu'il a command\u00e9 au moteur pas \u00e0 pas.) Actuellement, la seule fa\u00e7on de le faire de mani\u00e8re fiable est que le microcontr\u00f4leur et le moteur pas \u00e0 pas les pilotes soient aliment\u00e9s uniquement par USB et que l'alimentation USB soit fournie par un h\u00f4te fonctionnant sur un Raspberry Pi. Dans cette situation, on peut sp\u00e9cifier une configuration mcu avec \"restart_method\u202f: rpi_usb\" - cette option fera en sorte que le microcontr\u00f4leur soit toujours r\u00e9initialis\u00e9 via une r\u00e9initialisation de l'alimentation USB, ce qui permettrait \u00e0 la fois au microcontr\u00f4leur et aux pilotes de moteur pas \u00e0 pas d'\u00eatre r\u00e9initialiser ensemble. Si vous utilisez ce m\u00e9canisme, vous devrez alors configurer manuellement les sections de configuration \"trigger_phase\" (voir config reference pour les d\u00e9tails).","title":"Notes compl\u00e9mentaires"},{"location":"Example_Configs.html","text":"Exemples de configurations \u00b6 Ce document contient des directives pour contribuer \u00e0 un exemple de configuration Klipper dans le d\u00e9p\u00f4t github de Klipper (situ\u00e9 dans le r\u00e9pertoire config ). Notez que le serveur discord communautaire de Klipper est une ressource utile pour trouver et partager des fichiers de configuration. Lignes directives \u00b6 S\u00e9lectionnez le pr\u00e9fixe de nom de fichier de configuration appropri\u00e9 : Le pr\u00e9fixe printer est utilis\u00e9 pour les imprimantes de stock vendues par un fabricant grand public. Le pr\u00e9fixe generic est utilis\u00e9 pour une carte m\u00e8re d'imprimante 3d qui peut \u00eatre utilis\u00e9e sur de nombreux mod\u00e8les d'imprimantes. Le pr\u00e9fixe kit est destin\u00e9 aux imprimantes 3D assembl\u00e9es selon une sp\u00e9cification largement utilis\u00e9e. Ces imprimantes \u00abkit\u00bb se distinguent des imprimantes \"normales\" par le fait qu'elles ne soient pas vendues par un constructeur. Le pr\u00e9fixe sample est utilis\u00e9 pour des \"extraits\" de configuration que l'on peut copier-coller dans le fichier de configuration principal. Le pr\u00e9fixe example est utilis\u00e9 pour d\u00e9crire la cin\u00e9matique de l\u2019imprimante. Ce type de configuration n\u2019est g\u00e9n\u00e9ralement ajout\u00e9 qu\u2019avec le code d\u2019un nouveau type de cin\u00e9matique d\u2019imprimante. Tous les fichiers de configuration doivent se terminer par un suffixe .cfg . Les fichiers de configuration printer doivent se terminer par une ann\u00e9e suivie de .cfg (par exemple, -2019.cfg ). Dans ce cas, l'ann\u00e9e est une ann\u00e9e approximative o\u00f9 l'imprimante donn\u00e9e a \u00e9t\u00e9 vendue. N'utilisez pas d'espaces ou de caract\u00e8res sp\u00e9ciaux dans le nom du fichier de configuration. Le nom du fichier doit contenir uniquement les caract\u00e8res A-Z , a-z , 0-9 , - , et . . Klipper doit \u00eatre capable de d\u00e9marrer les fichiers de configuration d'exemple printer , generic , et kit sans erreur. Ces fichiers de configuration doivent \u00eatre ajout\u00e9s au sc\u00e9nario de test de non r\u00e9gression test/klippy/printers.test . Ajoutez les nouveaux fichiers de configuration \u00e0 ce sc\u00e9nario de test dans la section appropri\u00e9e et par ordre alphab\u00e9tique dans cette section. L'exemple de configuration doit correspondre \u00e0 la configuration \"standard\" de l'imprimante. (Il existe trop de configurations \"personnalis\u00e9es\" pour \u00eatre suivies dans le r\u00e9f\u00e9rentiel principal de Klipper). De m\u00eame, nous n'ajoutons de fichiers de configuration d'exemple que pour les imprimantes, les kits et les cartes contr\u00f4leur qui ont une bonne popularit\u00e9 (par exemple, il devrait y en avoir au moins une centaine en utilisation active). Pensez \u00e0 utiliser le Serveur communautaire Discourse de Klipper pour les autres configurations. Only specify those devices present on the given printer or board. Do not specify settings specific to your particular setup. For generic config files, only those devices on the mainboard should be described. For example, it would not make sense to add a display config section to a \"generic\" config as there is no way to know if the board will be attached to that type of display. If the board has a specific hardware port to facilitate an optional peripheral (eg, a bltouch port) then one can add a \"commented out\" config section for the given device. Ne sp\u00e9cifiez pas pressure_advance dans un exemple de configuration, car cette valeur est sp\u00e9cifique au filament, et non au mat\u00e9riel de l'imprimante. De m\u00eame, ne sp\u00e9cifiez pas les param\u00e8tres max_extrude_only_velocity et max_extrude_only_accel . Ne sp\u00e9cifiez pas une section de configuration contenant un chemin d'acc\u00e8s \u00e0 l'h\u00f4te ou un mat\u00e9riel h\u00f4te. Par exemple, ne sp\u00e9cifiez pas les sections de configuration [virtual_sdcard] et [temperature_host] . Ne d\u00e9finissez que les macros qui utilisent une fonctionnalit\u00e9 sp\u00e9cifique \u00e0 l'imprimante donn\u00e9e ou pour d\u00e9finir les codes g g\u00e9n\u00e9ralement \u00e9mis par les trancheurs configur\u00e9s pour l'imprimante donn\u00e9e. Where possible, it is best to use the same wording, phrasing, indentation, and section ordering as the existing config files. The top of each config file should list the type of micro-controller the user should select during \"make menuconfig\". It should also have a reference to \"docs/Config_Reference.md\". Ne copiez pas la documentation du champ dans les fichiers de configuration d'exemple. (Faire cela cr\u00e9e une charge de maintenance car une mise \u00e0 jour de la documentation n\u00e9cessiterait alors de la modifier \u00e0 de nombreux endroits.) Les exemples de fichiers de configuration ne doivent pas contenir de section \"SAVE_CONFIG\". Si n\u00e9cessaire, copiez les champs pertinents de la section SAVE_CONFIG dans la section appropri\u00e9e de la zone de configuration principale. Utilisez la syntaxe field: value au lieu de field=value . Lorsque vous ajoutez une rotation_distance pour une extrudeuse, il est pr\u00e9f\u00e9rable de sp\u00e9cifier un gear_ratio si l'extrudeuse a un m\u00e9canisme d'engrenage. Nous nous attendons \u00e0 ce que la distance de rotation dans les exemples de configuration corresponde \u00e0 la circonf\u00e9rence de l'engrenage dent\u00e9 dans l'extrudeuse - elle est normalement comprise entre 20 et 35 mm. Lorsque vous sp\u00e9cifiez un gear_ratio , il est pr\u00e9f\u00e9rable de sp\u00e9cifier les engrenages r\u00e9els du m\u00e9canisme (par exemple, pr\u00e9f\u00e9rez gear_ratio : 80:20 \u00e0 gear_ratio : 4:1 ). Voir le document sur la distance de rotation pour plus d'informations. \u00c9vitez de d\u00e9finir des valeurs de champ fix\u00e9es \u00e0 leur valeur par d\u00e9faut. Par exemple, il est inutile de sp\u00e9cifier min_extrude_temp : 170 car c'est d\u00e9j\u00e0 la valeur par d\u00e9faut. Dans la mesure du possible, les lignes ne devraient pas d\u00e9passer 80 colonnes. \u00c9vitez d'ajouter des messages d'attribution ou de r\u00e9vision dans les fichiers de configuration. (Par exemple, \u00e9vitez d'ajouter des lignes telles que \"ce fichier a \u00e9t\u00e9 cr\u00e9\u00e9 par ...\".) Placez l'attribution et l'historique des modifications dans le message git commit. N'utilisez pas de fonctionnalit\u00e9s obsol\u00e8tes dans le fichier de configuration d'exemple. Ne pas d\u00e9sactiver un syst\u00e8me de s\u00e9curit\u00e9 par d\u00e9faut dans un fichier de configuration d'exemple. Par exemple, une configuration ne doit pas sp\u00e9cifier un max_extrude_cross_section personnalis\u00e9. N'activez pas les fonctions de d\u00e9bogage. Par exemple, il ne doit pas y avoir de section de configuration force_move . Toutes les cartes connues que Klipper prend en charge peuvent utiliser la vitesse de transmission s\u00e9rie par d\u00e9faut de 250000. Ne recommandez pas un d\u00e9bit en bauds diff\u00e9rent dans un fichier de configuration d'exemple. Les exemples de fichiers de configuration sont soumis en cr\u00e9ant une \"pull request\" sur github. Veuillez \u00e9galement suivre les instructions du document de contribution .","title":"Exemples de configurations"},{"location":"Example_Configs.html#exemples-de-configurations","text":"Ce document contient des directives pour contribuer \u00e0 un exemple de configuration Klipper dans le d\u00e9p\u00f4t github de Klipper (situ\u00e9 dans le r\u00e9pertoire config ). Notez que le serveur discord communautaire de Klipper est une ressource utile pour trouver et partager des fichiers de configuration.","title":"Exemples de configurations"},{"location":"Example_Configs.html#lignes-directives","text":"S\u00e9lectionnez le pr\u00e9fixe de nom de fichier de configuration appropri\u00e9 : Le pr\u00e9fixe printer est utilis\u00e9 pour les imprimantes de stock vendues par un fabricant grand public. Le pr\u00e9fixe generic est utilis\u00e9 pour une carte m\u00e8re d'imprimante 3d qui peut \u00eatre utilis\u00e9e sur de nombreux mod\u00e8les d'imprimantes. Le pr\u00e9fixe kit est destin\u00e9 aux imprimantes 3D assembl\u00e9es selon une sp\u00e9cification largement utilis\u00e9e. Ces imprimantes \u00abkit\u00bb se distinguent des imprimantes \"normales\" par le fait qu'elles ne soient pas vendues par un constructeur. Le pr\u00e9fixe sample est utilis\u00e9 pour des \"extraits\" de configuration que l'on peut copier-coller dans le fichier de configuration principal. Le pr\u00e9fixe example est utilis\u00e9 pour d\u00e9crire la cin\u00e9matique de l\u2019imprimante. Ce type de configuration n\u2019est g\u00e9n\u00e9ralement ajout\u00e9 qu\u2019avec le code d\u2019un nouveau type de cin\u00e9matique d\u2019imprimante. Tous les fichiers de configuration doivent se terminer par un suffixe .cfg . Les fichiers de configuration printer doivent se terminer par une ann\u00e9e suivie de .cfg (par exemple, -2019.cfg ). Dans ce cas, l'ann\u00e9e est une ann\u00e9e approximative o\u00f9 l'imprimante donn\u00e9e a \u00e9t\u00e9 vendue. N'utilisez pas d'espaces ou de caract\u00e8res sp\u00e9ciaux dans le nom du fichier de configuration. Le nom du fichier doit contenir uniquement les caract\u00e8res A-Z , a-z , 0-9 , - , et . . Klipper doit \u00eatre capable de d\u00e9marrer les fichiers de configuration d'exemple printer , generic , et kit sans erreur. Ces fichiers de configuration doivent \u00eatre ajout\u00e9s au sc\u00e9nario de test de non r\u00e9gression test/klippy/printers.test . Ajoutez les nouveaux fichiers de configuration \u00e0 ce sc\u00e9nario de test dans la section appropri\u00e9e et par ordre alphab\u00e9tique dans cette section. L'exemple de configuration doit correspondre \u00e0 la configuration \"standard\" de l'imprimante. (Il existe trop de configurations \"personnalis\u00e9es\" pour \u00eatre suivies dans le r\u00e9f\u00e9rentiel principal de Klipper). De m\u00eame, nous n'ajoutons de fichiers de configuration d'exemple que pour les imprimantes, les kits et les cartes contr\u00f4leur qui ont une bonne popularit\u00e9 (par exemple, il devrait y en avoir au moins une centaine en utilisation active). Pensez \u00e0 utiliser le Serveur communautaire Discourse de Klipper pour les autres configurations. Only specify those devices present on the given printer or board. Do not specify settings specific to your particular setup. For generic config files, only those devices on the mainboard should be described. For example, it would not make sense to add a display config section to a \"generic\" config as there is no way to know if the board will be attached to that type of display. If the board has a specific hardware port to facilitate an optional peripheral (eg, a bltouch port) then one can add a \"commented out\" config section for the given device. Ne sp\u00e9cifiez pas pressure_advance dans un exemple de configuration, car cette valeur est sp\u00e9cifique au filament, et non au mat\u00e9riel de l'imprimante. De m\u00eame, ne sp\u00e9cifiez pas les param\u00e8tres max_extrude_only_velocity et max_extrude_only_accel . Ne sp\u00e9cifiez pas une section de configuration contenant un chemin d'acc\u00e8s \u00e0 l'h\u00f4te ou un mat\u00e9riel h\u00f4te. Par exemple, ne sp\u00e9cifiez pas les sections de configuration [virtual_sdcard] et [temperature_host] . Ne d\u00e9finissez que les macros qui utilisent une fonctionnalit\u00e9 sp\u00e9cifique \u00e0 l'imprimante donn\u00e9e ou pour d\u00e9finir les codes g g\u00e9n\u00e9ralement \u00e9mis par les trancheurs configur\u00e9s pour l'imprimante donn\u00e9e. Where possible, it is best to use the same wording, phrasing, indentation, and section ordering as the existing config files. The top of each config file should list the type of micro-controller the user should select during \"make menuconfig\". It should also have a reference to \"docs/Config_Reference.md\". Ne copiez pas la documentation du champ dans les fichiers de configuration d'exemple. (Faire cela cr\u00e9e une charge de maintenance car une mise \u00e0 jour de la documentation n\u00e9cessiterait alors de la modifier \u00e0 de nombreux endroits.) Les exemples de fichiers de configuration ne doivent pas contenir de section \"SAVE_CONFIG\". Si n\u00e9cessaire, copiez les champs pertinents de la section SAVE_CONFIG dans la section appropri\u00e9e de la zone de configuration principale. Utilisez la syntaxe field: value au lieu de field=value . Lorsque vous ajoutez une rotation_distance pour une extrudeuse, il est pr\u00e9f\u00e9rable de sp\u00e9cifier un gear_ratio si l'extrudeuse a un m\u00e9canisme d'engrenage. Nous nous attendons \u00e0 ce que la distance de rotation dans les exemples de configuration corresponde \u00e0 la circonf\u00e9rence de l'engrenage dent\u00e9 dans l'extrudeuse - elle est normalement comprise entre 20 et 35 mm. Lorsque vous sp\u00e9cifiez un gear_ratio , il est pr\u00e9f\u00e9rable de sp\u00e9cifier les engrenages r\u00e9els du m\u00e9canisme (par exemple, pr\u00e9f\u00e9rez gear_ratio : 80:20 \u00e0 gear_ratio : 4:1 ). Voir le document sur la distance de rotation pour plus d'informations. \u00c9vitez de d\u00e9finir des valeurs de champ fix\u00e9es \u00e0 leur valeur par d\u00e9faut. Par exemple, il est inutile de sp\u00e9cifier min_extrude_temp : 170 car c'est d\u00e9j\u00e0 la valeur par d\u00e9faut. Dans la mesure du possible, les lignes ne devraient pas d\u00e9passer 80 colonnes. \u00c9vitez d'ajouter des messages d'attribution ou de r\u00e9vision dans les fichiers de configuration. (Par exemple, \u00e9vitez d'ajouter des lignes telles que \"ce fichier a \u00e9t\u00e9 cr\u00e9\u00e9 par ...\".) Placez l'attribution et l'historique des modifications dans le message git commit. N'utilisez pas de fonctionnalit\u00e9s obsol\u00e8tes dans le fichier de configuration d'exemple. Ne pas d\u00e9sactiver un syst\u00e8me de s\u00e9curit\u00e9 par d\u00e9faut dans un fichier de configuration d'exemple. Par exemple, une configuration ne doit pas sp\u00e9cifier un max_extrude_cross_section personnalis\u00e9. N'activez pas les fonctions de d\u00e9bogage. Par exemple, il ne doit pas y avoir de section de configuration force_move . Toutes les cartes connues que Klipper prend en charge peuvent utiliser la vitesse de transmission s\u00e9rie par d\u00e9faut de 250000. Ne recommandez pas un d\u00e9bit en bauds diff\u00e9rent dans un fichier de configuration d'exemple. Les exemples de fichiers de configuration sont soumis en cr\u00e9ant une \"pull request\" sur github. Veuillez \u00e9galement suivre les instructions du document de contribution .","title":"Lignes directives"},{"location":"Exclude_Object.html","text":"Exclure des objets \u00b6 The [exclude_object] module allows Klipper to exclude objects while a print is in progress. To enable this feature include an exclude_object config section (also see the command reference and sample-macros.cfg file for a Marlin/RepRapFirmware compatible M486 G-Code macro.) Contrairement \u00e0 d'autres options de micrologiciel d'imprimante 3D, une imprimante ex\u00e9cutant Klipper utilise une suite de composants et les utilisateurs ont le choix de nombreuses options. Par cons\u00e9quent, afin de fournir une exp\u00e9rience utilisateur coh\u00e9rente, le module [exclude_object] \u00e9tablira un contrat ou une sorte d'API. Le contrat couvre le contenu du fichier gcode, la fa\u00e7on dont l'\u00e9tat interne du module est contr\u00f4l\u00e9, et la fa\u00e7on dont cet \u00e9tat est fourni aux clients. Aper\u00e7u du flux de travail \u00b6 Le flux de travail typique de l'impression d'un fichier peut ressembler \u00e0 ceci : Le tranchage est termin\u00e9 et le fichier a \u00e9t\u00e9 t\u00e9l\u00e9charg\u00e9 pour \u00eatre imprim\u00e9. Pendant le t\u00e9l\u00e9chargement, le fichier est trait\u00e9 et des marqueurs [exclude_object] sont ajout\u00e9s au fichier. Alternativement, les trancheurs peuvent \u00eatre configur\u00e9s pour pr\u00e9parer les marqueurs d'exclusion d'objets de mani\u00e8re native ou dans leur propre \u00e9tape de pr\u00e9traitement. Lorsque l'impression d\u00e9marre, Klipper r\u00e9initialise l' \u00e9tat de [exclude_object] . Lorsque Klipper traite le bloc EXCLUDE_OBJECT_DEFINE , il met \u00e0 jour l'\u00e9tat avec les objets connus et le transmet aux clients. Le client peut utiliser ces informations pour pr\u00e9senter une interface \u00e0 l'utilisateur afin de suivre la progression. Klipper mettra \u00e0 jour l'\u00e9tat pour inclure l'objet en cours d'impression que le client peut utiliser \u00e0 des fins d'affichage. Si l'utilisateur demande l'annulation d'un objet, le client envoie une commande EXCLUDE_OBJECT NAME=<name> \u00e0 Klipper. Lorsque Klipper traite la commande, il ajoute l'objet \u00e0 la liste des objets exclus et met \u00e0 jour le statut du client. Le client recevra l'\u00e9tat mis \u00e0 jour de Klipper et pourra utiliser cette information pour refl\u00e9ter l'\u00e9tat de l'objet dans l'interface utilisateur. Une fois l'impression termin\u00e9e, l'\u00e9tat [exclude_object] continuera \u00e0 \u00eatre disponible jusqu'\u00e0 ce qu'une autre action le r\u00e9initialise. Le fichier GCode \u00b6 Le traitement particulier du gcode n\u00e9cessaire \u00e0 la prise en charge des objets exclus ne correspond pas aux caract\u00e9ristiques de conception de d\u00e9part de Klipper. Par cons\u00e9quent, ce module exige que le fichier soit trait\u00e9 avant d'\u00eatre envoy\u00e9 \u00e0 Klipper pour l'impression. L'utilisation d'un script de post-traitement dans le trancheur ou le traitement du fichier par un logiciel interm\u00e9diaire lors du t\u00e9l\u00e9chargement sont deux possibilit\u00e9s pour pr\u00e9parer le fichier pour Klipper. Un script de post-traitement de r\u00e9f\u00e9rence est disponible \u00e0 la fois comme ex\u00e9cutable et comme biblioth\u00e8que python, voir cancelobject-preprocessor . D\u00e9finitions des objets \u00b6 La commande EXCLUDE_OBJECT_DEFINE est utilis\u00e9e pour fournir un r\u00e9sum\u00e9 de chaque objet du fichier gcode \u00e0 imprimer. Elle fournit le r\u00e9sum\u00e9 d'un objet dans le fichier. Les objets n'ont pas besoin d'\u00eatre d\u00e9finis pour \u00eatre r\u00e9f\u00e9renc\u00e9s par d'autres commandes. Le but principal de cette commande est de fournir des informations \u00e0 l'interface utilisateur sans avoir \u00e0 analyser le fichier gcode en entier. Les d\u00e9finitions d'objets sont nomm\u00e9es, pour permettre aux utilisateurs de s\u00e9lectionner facilement un objet \u00e0 exclure, et des m\u00e9tadonn\u00e9es suppl\u00e9mentaires peuvent \u00eatre fournies pour permettre des affichages graphiques d'annulation. Les m\u00e9tadonn\u00e9es actuellement d\u00e9finies comprennent une coordonn\u00e9e X,Y CENTER , et une liste POLYGON de points X,Y repr\u00e9sentant un contour minimal de l'objet. Il peut s'agir d'une simple bo\u00eete englobante ou d'une coque complexe permettant de visualiser les objets imprim\u00e9s de mani\u00e8re plus d\u00e9taill\u00e9e. En particulier, lorsque les fichiers gcode comprennent plusieurs parties avec des r\u00e9gions limites qui se chevauchent, les points centraux deviennent difficiles \u00e0 distinguer visuellement. POLYGONS doit \u00eatre un tableau compatible json de points [X,Y] ( tuples) sans espace. Les param\u00e8tres suppl\u00e9mentaires seront enregistr\u00e9s sous forme de cha\u00eenes de caract\u00e8res dans la d\u00e9finition de l'objet et fournis dans les mises \u00e0 jour de l'\u00e9tat. EXCLUDE_OBJECT_DEFINE NAME=calibration_pyramid CENTER=50,50 POLYGON=[[40,40],[50,60],[60,40]] All available G-Code commands are documented in the G-Code Reference Informations sur le statut \u00b6 The state of this module is provided to clients by the exclude_object status . L'\u00e9tat est r\u00e9initialis\u00e9 lorsque : Le microprogramme Klipper est red\u00e9marr\u00e9. Il y a une r\u00e9initialisation de la [virtual_sdcard] . Notamment, ceci est remis \u00e0 z\u00e9ro par Klipper au d\u00e9but d'une impression. Lorsqu'une commande EXCLUDE_OBJECT_DEFINE RESET=1 est \u00e9mise. La liste des objets d\u00e9finis est repr\u00e9sent\u00e9e dans le champ d'\u00e9tat exclude_object.objects . Dans un fichier gcode bien d\u00e9fini, cela sera fait avec les commandes EXCLUDE_OBJECT_DEFINE au d\u00e9but du fichier. Cela fournira aux clients les noms et les coordonn\u00e9es des objets afin que l'interface utilisateur puisse fournir une repr\u00e9sentation graphique des objets si n\u00e9cessaire. Au fur et \u00e0 mesure de l'impression, le champ d'\u00e9tat exclude_object.current_object sera mis \u00e0 jour lorsque Klipper traitera les commandes EXCLUDE_OBJECT_START et EXCLUDE_OBJECT_END . Le champ current_object sera activ\u00e9 m\u00eame si l'objet a \u00e9t\u00e9 exclu. Les objets non d\u00e9finis marqu\u00e9s d'un EXCLUDE_OBJECT_START seront ajout\u00e9s aux objets connus pour aider \u00e0 la mise en place de l'interface utilisateur, sans m\u00e9tadonn\u00e9es suppl\u00e9mentaires. Lorsque les commandes EXCLUDE_OBJECT sont \u00e9mises, la liste des objets exclus est fournie dans le tableau exclude_object.excluded_objects . Comme Klipper anticipe le traitement du gcode \u00e0 venir, il peut y avoir un d\u00e9lai entre le moment o\u00f9 la commande est \u00e9mise et celui o\u00f9 le statut est mis \u00e0 jour.","title":"Exclure des objets"},{"location":"Exclude_Object.html#exclure-des-objets","text":"The [exclude_object] module allows Klipper to exclude objects while a print is in progress. To enable this feature include an exclude_object config section (also see the command reference and sample-macros.cfg file for a Marlin/RepRapFirmware compatible M486 G-Code macro.) Contrairement \u00e0 d'autres options de micrologiciel d'imprimante 3D, une imprimante ex\u00e9cutant Klipper utilise une suite de composants et les utilisateurs ont le choix de nombreuses options. Par cons\u00e9quent, afin de fournir une exp\u00e9rience utilisateur coh\u00e9rente, le module [exclude_object] \u00e9tablira un contrat ou une sorte d'API. Le contrat couvre le contenu du fichier gcode, la fa\u00e7on dont l'\u00e9tat interne du module est contr\u00f4l\u00e9, et la fa\u00e7on dont cet \u00e9tat est fourni aux clients.","title":"Exclure des objets"},{"location":"Exclude_Object.html#apercu-du-flux-de-travail","text":"Le flux de travail typique de l'impression d'un fichier peut ressembler \u00e0 ceci : Le tranchage est termin\u00e9 et le fichier a \u00e9t\u00e9 t\u00e9l\u00e9charg\u00e9 pour \u00eatre imprim\u00e9. Pendant le t\u00e9l\u00e9chargement, le fichier est trait\u00e9 et des marqueurs [exclude_object] sont ajout\u00e9s au fichier. Alternativement, les trancheurs peuvent \u00eatre configur\u00e9s pour pr\u00e9parer les marqueurs d'exclusion d'objets de mani\u00e8re native ou dans leur propre \u00e9tape de pr\u00e9traitement. Lorsque l'impression d\u00e9marre, Klipper r\u00e9initialise l' \u00e9tat de [exclude_object] . Lorsque Klipper traite le bloc EXCLUDE_OBJECT_DEFINE , il met \u00e0 jour l'\u00e9tat avec les objets connus et le transmet aux clients. Le client peut utiliser ces informations pour pr\u00e9senter une interface \u00e0 l'utilisateur afin de suivre la progression. Klipper mettra \u00e0 jour l'\u00e9tat pour inclure l'objet en cours d'impression que le client peut utiliser \u00e0 des fins d'affichage. Si l'utilisateur demande l'annulation d'un objet, le client envoie une commande EXCLUDE_OBJECT NAME=<name> \u00e0 Klipper. Lorsque Klipper traite la commande, il ajoute l'objet \u00e0 la liste des objets exclus et met \u00e0 jour le statut du client. Le client recevra l'\u00e9tat mis \u00e0 jour de Klipper et pourra utiliser cette information pour refl\u00e9ter l'\u00e9tat de l'objet dans l'interface utilisateur. Une fois l'impression termin\u00e9e, l'\u00e9tat [exclude_object] continuera \u00e0 \u00eatre disponible jusqu'\u00e0 ce qu'une autre action le r\u00e9initialise.","title":"Aper\u00e7u du flux de travail"},{"location":"Exclude_Object.html#le-fichier-gcode","text":"Le traitement particulier du gcode n\u00e9cessaire \u00e0 la prise en charge des objets exclus ne correspond pas aux caract\u00e9ristiques de conception de d\u00e9part de Klipper. Par cons\u00e9quent, ce module exige que le fichier soit trait\u00e9 avant d'\u00eatre envoy\u00e9 \u00e0 Klipper pour l'impression. L'utilisation d'un script de post-traitement dans le trancheur ou le traitement du fichier par un logiciel interm\u00e9diaire lors du t\u00e9l\u00e9chargement sont deux possibilit\u00e9s pour pr\u00e9parer le fichier pour Klipper. Un script de post-traitement de r\u00e9f\u00e9rence est disponible \u00e0 la fois comme ex\u00e9cutable et comme biblioth\u00e8que python, voir cancelobject-preprocessor .","title":"Le fichier GCode"},{"location":"Exclude_Object.html#definitions-des-objets","text":"La commande EXCLUDE_OBJECT_DEFINE est utilis\u00e9e pour fournir un r\u00e9sum\u00e9 de chaque objet du fichier gcode \u00e0 imprimer. Elle fournit le r\u00e9sum\u00e9 d'un objet dans le fichier. Les objets n'ont pas besoin d'\u00eatre d\u00e9finis pour \u00eatre r\u00e9f\u00e9renc\u00e9s par d'autres commandes. Le but principal de cette commande est de fournir des informations \u00e0 l'interface utilisateur sans avoir \u00e0 analyser le fichier gcode en entier. Les d\u00e9finitions d'objets sont nomm\u00e9es, pour permettre aux utilisateurs de s\u00e9lectionner facilement un objet \u00e0 exclure, et des m\u00e9tadonn\u00e9es suppl\u00e9mentaires peuvent \u00eatre fournies pour permettre des affichages graphiques d'annulation. Les m\u00e9tadonn\u00e9es actuellement d\u00e9finies comprennent une coordonn\u00e9e X,Y CENTER , et une liste POLYGON de points X,Y repr\u00e9sentant un contour minimal de l'objet. Il peut s'agir d'une simple bo\u00eete englobante ou d'une coque complexe permettant de visualiser les objets imprim\u00e9s de mani\u00e8re plus d\u00e9taill\u00e9e. En particulier, lorsque les fichiers gcode comprennent plusieurs parties avec des r\u00e9gions limites qui se chevauchent, les points centraux deviennent difficiles \u00e0 distinguer visuellement. POLYGONS doit \u00eatre un tableau compatible json de points [X,Y] ( tuples) sans espace. Les param\u00e8tres suppl\u00e9mentaires seront enregistr\u00e9s sous forme de cha\u00eenes de caract\u00e8res dans la d\u00e9finition de l'objet et fournis dans les mises \u00e0 jour de l'\u00e9tat. EXCLUDE_OBJECT_DEFINE NAME=calibration_pyramid CENTER=50,50 POLYGON=[[40,40],[50,60],[60,40]] All available G-Code commands are documented in the G-Code Reference","title":"D\u00e9finitions des objets"},{"location":"Exclude_Object.html#informations-sur-le-statut","text":"The state of this module is provided to clients by the exclude_object status . L'\u00e9tat est r\u00e9initialis\u00e9 lorsque : Le microprogramme Klipper est red\u00e9marr\u00e9. Il y a une r\u00e9initialisation de la [virtual_sdcard] . Notamment, ceci est remis \u00e0 z\u00e9ro par Klipper au d\u00e9but d'une impression. Lorsqu'une commande EXCLUDE_OBJECT_DEFINE RESET=1 est \u00e9mise. La liste des objets d\u00e9finis est repr\u00e9sent\u00e9e dans le champ d'\u00e9tat exclude_object.objects . Dans un fichier gcode bien d\u00e9fini, cela sera fait avec les commandes EXCLUDE_OBJECT_DEFINE au d\u00e9but du fichier. Cela fournira aux clients les noms et les coordonn\u00e9es des objets afin que l'interface utilisateur puisse fournir une repr\u00e9sentation graphique des objets si n\u00e9cessaire. Au fur et \u00e0 mesure de l'impression, le champ d'\u00e9tat exclude_object.current_object sera mis \u00e0 jour lorsque Klipper traitera les commandes EXCLUDE_OBJECT_START et EXCLUDE_OBJECT_END . Le champ current_object sera activ\u00e9 m\u00eame si l'objet a \u00e9t\u00e9 exclu. Les objets non d\u00e9finis marqu\u00e9s d'un EXCLUDE_OBJECT_START seront ajout\u00e9s aux objets connus pour aider \u00e0 la mise en place de l'interface utilisateur, sans m\u00e9tadonn\u00e9es suppl\u00e9mentaires. Lorsque les commandes EXCLUDE_OBJECT sont \u00e9mises, la liste des objets exclus est fournie dans le tableau exclude_object.excluded_objects . Comme Klipper anticipe le traitement du gcode \u00e0 venir, il peut y avoir un d\u00e9lai entre le moment o\u00f9 la commande est \u00e9mise et celui o\u00f9 le statut est mis \u00e0 jour.","title":"Informations sur le statut"},{"location":"FAQ.html","text":"Foire Aux Questions \u00b6 Comment puis-je faire un don au projet ? \u00b6 Merci de votre soutien. Voir la page Sponsors pour plus d'informations. Comment calculer le param\u00e8tre de configuration rotation_distance ? \u00b6 Voir le document sur la distance de rotation . O\u00f9 est mon port s\u00e9rie ? \u00b6 De mani\u00e8re g\u00e9n\u00e9rale, on ex\u00e9cute la commande ls /dev/serial/by-id/* \u00e0 partir d'un terminal ssh sur la machine h\u00f4te pour trouver un port s\u00e9rie USB. Cette commande produira s\u00fbrement un r\u00e9sultat similaire \u00e0 celui-ci : /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 Le nom retourn\u00e9 par la commande ci-dessus est constant, il est donc possible de l'utiliser dans le fichier de configuration et lors du flashage du microcontr\u00f4leur. Par exemple, une commande de flash peur ressembler \u00e0 : sudo service klipper stop make flash FLASH_DEVICE=/dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 sudo service klipper start et la configuration mise \u00e0 jour devrait ressembler \u00e0 : [mcu] serial: /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 Veillez \u00e0 copier-coller le nom retourn\u00e9 par la commande \"ls\" que vous avez ex\u00e9cut\u00e9e ci-avant, car le nom sera diff\u00e9rent pour chaque imprimante. Si vous utilisez plusieurs microcontr\u00f4leurs et qu'ils n'ont pas d'identifiant unique (fr\u00e9quent avec les cartes utilisant une puce USB CH340), suivez les instructions ci-dessus en utilisant la commande ls /dev/serial/by-path/* \u00e0 la place. Lorsque le microcontr\u00f4leur red\u00e9marre, le p\u00e9riph\u00e9rique passe \u00e0 /dev/ttyUSB1 \u00b6 Suivez les instructions de la section \" O\u00f9 est mon port s\u00e9rie ? \" pour \u00e9viter que cela ne se produise. La commande \"make flash\" ne fonctionne pas \u00b6 Le code tente de flasher le dispositif en utilisant la m\u00e9thode la plus courante pour chaque plateforme. Malheureusement, il y a beaucoup de variations dans les m\u00e9thodes de flashage, donc la commande \"make flash\" peut ne pas fonctionner avec toutes les cartes. Si vous rencontrez une erreur intermittente ou si votre configuration est standard, v\u00e9rifiez que Klipper est arr\u00eat\u00e9 pendant le flashage (sudo service klipper stop), assurez-vous qu'OctoPrint n'essaye pas de se connecter directement \u00e0 l'appareil (ouvrez l'onglet Connexion de la page web et cliquez sur D\u00e9connecter si le port s\u00e9rie de la carte est s\u00e9lectionn\u00e9), et assurez-vous que FLASH_DEVICE est correctement d\u00e9fini pour votre carte (voir la question ci-dessus ). Toutefois si \"make flash\" ne fonctionne pas pour votre carte, vous devrez flasher manuellement. V\u00e9rifiez s'il existe un fichier de configuration dans le r\u00e9pertoire config avec des instructions sp\u00e9cifiques pour flasher la carte. V\u00e9rifiez \u00e9galement la documentation du fabricant de la carte pour voir si elle d\u00e9crit comment la flasher. Enfin, il peut \u00eatre possible de flasher manuellement la carte en utilisant des outils tels que \"avrdude\" ou \"bossac\" - voir le document sur les booloaders pour plus d'informations. Comment changer la vitesse de communication(baud rate) du port s\u00e9rie ? \u00b6 Le baud rate (taux bit/s) recommand\u00e9 pour Klipper est de 250000. Ce baud rate fonctionne bien sur toutes les cartes microcontr\u00f4leurs que Klipper prend en charge. Si vous avez trouv\u00e9 un guide en ligne recommandant un baud rate diff\u00e9rent, ignorez cette partie du guide et continuez avec la valeur par d\u00e9faut de 250000. Si vous voulez quand m\u00eame changer le baud rate, le nouveau taux devra \u00eatre configur\u00e9e dans le microcontr\u00f4leur (pendant make menuconfig ) et ce code mis \u00e0 jour devra \u00eatre compil\u00e9 et flash\u00e9 dans le microcontr\u00f4leur. Le fichier printer.cfg de Klipper devra \u00e9galement \u00eatre mis \u00e0 jour pour correspondre \u00e0 ce baud rate (voir le document de r\u00e9f\u00e9rence des configurations pour plus de d\u00e9tails). Par exemple : [mcu] baud: 250000 Le baud rate (taux bit/s) indiqu\u00e9 sur la page Web d'OctoPrint n'a aucun impact sur la vitesse de transmission du microcontr\u00f4leur interne de Klipper. R\u00e9glez toujours le taux de bit/s d'OctoPrint sur 250000 lorsque vous utilisez Klipper. Le baud rate utilis\u00e9 avec Klipper n'est pas li\u00e9e au baud rate du bootloader du microcontr\u00f4leur. Voir le document sur les bootloaders pour plus d'informations sur les bootloaders. Puis-je faire fonctionner Klipper sur autre chose qu'un Raspberry Pi 3 ? \u00b6 Le mat\u00e9riel recommand\u00e9 est un Raspberry Pi 2, Raspberry Pi 3 ou Raspberry Pi 4. Klipper fonctionne sur un Raspberry Pi 1 et sur le Raspberry Pi Zero, mais ces cartes n'ont pas assez de puissance de traitement pour faire fonctionner OctoPrint correctement. Il est fr\u00e9quent que l'impression se fasse par \u00e0-coup avec ces machines plus lentes lorsqu'on imprime directement depuis OctoPrint. (L'imprimante peut chercher \u00e0 imprimer plus rapidement que la vitesse \u00e0 laquelle OctoPrint peut envoyer les commandes de mouvement.) Si vous souhaitez quand m\u00eame utiliser une de ces cartes plus lentes, pensez \u00e0 utiliser la fonctionnalit\u00e9 \"virtual_sdcard\" lors de l'impression (voir le document de r\u00e9f\u00e9rence des configurations pour plus de d\u00e9tails). Pour l'ex\u00e9cution sur le Beaglebone, voir les instructions d'installation sp\u00e9cifiques au Beaglebone . Klipper a \u00e9t\u00e9 ex\u00e9cut\u00e9 sur d'autres machines. Le logiciel h\u00f4te de Klipper ne n\u00e9cessite que l'ex\u00e9cution de Python sur un ordinateur Linux (ou similaire). Cependant, si vous souhaitez l'ex\u00e9cuter sur une autre machine, vous aurez besoin de connaissances d'administrateur Linux pour installer les pr\u00e9requis du syst\u00e8me pour cette machine particuli\u00e8re. Consultez le script install-octopi.sh pour plus d'informations sur les \u00e9tapes n\u00e9cessaires \u00e0 l'administration de Linux. Si vous souhaitez ex\u00e9cuter le logiciel h\u00f4te Klipper sur une puce bas de gamme, sachez qu'il faut au minimum une machine dot\u00e9e d'un mat\u00e9riel \u00e0 \"double pr\u00e9cision en virgule flottante\". Si vous souhaitez ex\u00e9cuter le logiciel h\u00f4te Klipper sur un ordinateur de bureau ou un serveur polyvalent partag\u00e9, notez que Klipper a des exigences en mati\u00e8re de programmation en temps r\u00e9el. Si, au cours d'une impression, l'ordinateur h\u00f4te ex\u00e9cute \u00e9galement une t\u00e2che informatique intensive (comme la d\u00e9fragmentation d'un disque dur, un rendu 3D, une forte utilisation du fichier d'\u00e9change, etc.), Klipper pourrait signaler des erreurs d'impression. Note : Si vous n'utilisez pas une image OctoPi, sachez que de nombreuses distributions Linux activent un paquet \"ModemManager\" (ou similaire) pouvant perturber la communication s\u00e9rie. (Ce qui peut amener Klipper \u00e0 rapporter des erreurs apparemment al\u00e9atoires \"Lost communication with MCU\"). Si vous installez Klipper sur une de ces distributions, vous devrez peut-\u00eatre d\u00e9sactiver ce paquet. Puis-je ex\u00e9cuter plusieurs instances de Klipper sur la m\u00eame machine h\u00f4te ? \u00b6 Il est possible d'ex\u00e9cuter plusieurs instances du logiciel h\u00f4te Klipper, mais cela n\u00e9cessite des connaissances en administration Linux. Les scripts d'installation de Klipper entra\u00eenent finalement l'ex\u00e9cution de la commande Unix suivante : ~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer.cfg -l /tmp/klippy.log On peut ex\u00e9cuter plusieurs instances de la commande ci-dessus \u00e0 condition que chaque instance ait son propre fichier de configuration d'imprimante, son propre fichier journal et son propre pseudo-tty. Par exemple : ~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer2.cfg -l /tmp/klippy2.log -I /tmp/printer2 Si vous choisissez de le faire, vous devrez impl\u00e9menter les scripts de d\u00e9marrage, d'arr\u00eat et d'installation n\u00e9cessaires (le cas \u00e9ch\u00e9ant). Le script install-octopi.sh et le script klipper-start.sh peuvent \u00eatre utiles comme exemples. Suis-je oblig\u00e9 d'utiliser Octoprint ? \u00b6 Le logiciel Klipper n'est pas d\u00e9pendant d'OctoPrint. Il est possible d'utiliser un autre logiciel pour envoyer des commandes \u00e0 Klipper, mais cela n\u00e9cessite des connaissances en administration Linux. Klipper cr\u00e9e un \"port s\u00e9rie virtuel\" via le fichier \"/tmp/printer\" qui \u00e9mule une interface s\u00e9rie classique d'imprimante 3d via ce fichier. En g\u00e9n\u00e9ral, les logiciels alternatifs peuvent fonctionner avec Klipper tant qu'ils peuvent \u00eatre configur\u00e9s pour utiliser \"/tmp/printer\" pour le port s\u00e9rie de l'imprimante. Pourquoi ne puis-je pas lancer un d\u00e9placement avant de prendre l'origine ? \u00b6 Le code fait cela pour r\u00e9duire le risque de d\u00e9placer accidentellement la t\u00eate dans le lit ou dans un mur. Une fois que la prise d'origine est effectu\u00e9e, le logiciel v\u00e9rifie que chaque mouvement se situe dans les limites de position_min/max d\u00e9finies dans le fichier de configuration. Si les moteurs sont d\u00e9sactiv\u00e9s (via une commande M84 ou M18), les moteurs devront reprendre l'origine avant tout mouvement. Si vous souhaitez d\u00e9placer la t\u00eate apr\u00e8s avoir annul\u00e9 une impression via OctoPrint, pensez \u00e0 modifier la s\u00e9quence d'annulation d'OctoPrint pour qu'elle le fasse pour vous. Depuis un navigateur web, elle est configur\u00e9e dans OctoPrint sous : Param\u00e8tres->Scripts GCODE Si vous souhaitez d\u00e9placer la t\u00eate apr\u00e8s la fin d'une impression, pensez \u00e0 ajouter le mouvement souhait\u00e9 \u00e0 la section \"G-Code personnalis\u00e9\" de votre slicer. Si l'imprimante n\u00e9cessite un mouvement suppl\u00e9mentaire dans le cadre du processus de mise \u00e0 l'origine (ou si elle n'a pas de processus de mise \u00e0 l'origine), envisagez d'utiliser une section safe_z_home ou homing_override dans le fichier de configuration. Si vous devez d\u00e9placer un moteur \u00e0 des fins de diagnostic ou de d\u00e9bogage, pensez \u00e0 ajouter une section force_move dans le fichier de configuration. Voir r\u00e9f\u00e9rence de configuration pour plus de d\u00e9tails sur ces options. Pourquoi le param\u00e8tre position_endstop de l'axe Z est-il d\u00e9fini \u00e0 0.5 dans les configurations par d\u00e9faut ? \u00b6 Pour les imprimantes de style cart\u00e9sien, la position Z_endstop indique la distance entre la buse et le lit au moment du d\u00e9clenchement de la fin de course. Si possible, il est recommand\u00e9 d'utiliser une but\u00e9e de fin de course Z-max et de s'\u00e9loigner du lit (car cela r\u00e9duit le risque de collision avec le lit). Cependant, si l'on doit se rapprocher du lit, il est recommand\u00e9 de positionner la but\u00e9e de mani\u00e8re \u00e0 ce qu'elle se d\u00e9clenche lorsque la buse est encore \u00e0 une petite distance du lit. De cette fa\u00e7on, lorsque l'axe se dirige vers le lit, il s'arr\u00eate avant que la buse ne touche le lit. Voir le document niveau du lit pour plus d'informations. J'ai converti ma configuration depuis Marlin et les axes X/Y fonctionnent bien, mais j'obtiens un bruit strident lors de l'orientation de l'axe Z \u00b6 R\u00e9ponse courte : Tout d'abord, assurez-vous d'avoir v\u00e9rifi\u00e9 la configuration du moteur comme d\u00e9crit dans le document de v\u00e9rification de la configuration . Si le probl\u00e8me persiste, essayez de r\u00e9duire le param\u00e8tre max_z_velocity dans la configuration de l'imprimante. R\u00e9ponse longue : En pratique, Marlin ne peut se d\u00e9placer qu'\u00e0 une vitesse d'environ 10000 pas par seconde. Si on lui demande de se d\u00e9placer \u00e0 une vitesse n\u00e9cessitant un taux de pas plus \u00e9lev\u00e9, Marlin se contentera g\u00e9n\u00e9ralement de faire des pas aussi rapides qu'il le peut. Klipper est capable d'atteindre des taux de pas beaucoup plus \u00e9lev\u00e9s, mais le moteur pas \u00e0 pas peut ne pas avoir de couple suffisant pour se d\u00e9placer \u00e0 une vitesse plus \u00e9lev\u00e9e. Ainsi, pour un axe Z avec un rapport d'engrenage \u00e9lev\u00e9 ou un r\u00e9glage de micropas \u00e9lev\u00e9, la vitesse max_z_obtenue peut \u00eatre inf\u00e9rieure \u00e0 ce qui est configur\u00e9 dans Marlin. Mes pilotes de moteur TMC s'arr\u00eatent en plein milieu d'une impression \u00b6 Si vous utilisez le pilote TMC2208 (ou TMC2224) en \"mode autonome\", assurez-vous d'utiliser la derni\u00e8re version de Klipper . Une solution de contournement pour un probl\u00e8me avec les pilotes TMC2208 \"stealthchop\" a \u00e9t\u00e9 ajout\u00e9e \u00e0 Klipper \u00e0 la mi-mars 2020. J'ai des erreurs al\u00e9atoires \"Lost communication with MCU\" (communication perdue avec le microcontr\u00f4leur) \u00b6 Ce probl\u00e8me est g\u00e9n\u00e9ralement caus\u00e9 par des erreurs mat\u00e9rielles sur la connexion USB entre la machine h\u00f4te et le microcontr\u00f4leur. Les choses \u00e0 rechercher : Utilisez un c\u00e2ble USB de qualit\u00e9 entre la machine h\u00f4te et le microcontr\u00f4leur. Assurez-vous que les fiches sont bien fix\u00e9es. Si vous utilisez un Raspberry Pi, utilisez une alimentation de bonne qualit\u00e9 pour le Raspberry Pi et utilisez un c\u00e2ble USB de bonne qualit\u00e9 pour connecter cette alimentation au Pi. Si OctoPrint vous avertit que vous \u00eates sous tension, cela est li\u00e9 \u00e0 l'alimentation \u00e9lectrique et doit \u00eatre r\u00e9par\u00e9. Assurez-vous que l'alimentation \u00e9lectrique de l'imprimante n'est pas surcharg\u00e9e. (Les fluctuations d'alimentation de la puce USB du microcontr\u00f4leur peuvent entra\u00eener une r\u00e9initialisation de cette puce.) V\u00e9rifiez que les fils de l'imprimante (pastille, \u00e9l\u00e9ment chauffant et autres) sont bien sertis et pas effiloch\u00e9s. (Le mouvement de l'imprimante peut exercer une contrainte sur un c\u00e2blage d\u00e9fectueux entra\u00eenant une perte de contact, un court-circuit bref ou la production d'un bruit excessif.) Des signalements ont fait \u00e9tat d'un bruit USB \u00e9lev\u00e9 lorsque l'alimentation de l'imprimante et l'alimentation 5V de l'h\u00f4te sont m\u00e9lang\u00e9es. (Si vous constatez que le microcontr\u00f4leur s'allume lorsque l'alimentation de l'imprimante est sous tension ou que le c\u00e2ble USB est branch\u00e9, cela indique que les alimentations 5V sont m\u00e9lang\u00e9es). Il peut \u00eatre utile de configurer le micro-contr\u00f4leur pour qu'il utilise l'alimentation d'une seule source. (Alternativement, si la carte du micro-contr\u00f4leur ne peut pas configurer sa source d'alimentation, on peut modifier un c\u00e2ble USB pour qu'il ne transporte pas de tension de 5V entre l'h\u00f4te et le micro-contr\u00f4leur.) Mon Raspberry Pi red\u00e9marre pendant les impressions \u00b6 Cela est tr\u00e8s probablement d\u00fb \u00e0 des fluctuations de tension. Suivez les m\u00eames \u00e9tapes de d\u00e9pannage que pour une erreur \u00ab Communication perdue avec le MCU \u00bb . Lorsque j'ai d\u00e9fini restart_method=command , mon appareil AVR se bloque lors d'un red\u00e9marrage \u00b6 Certaines anciennes versions du bootloader AVR ont un bogue connu dans la gestion des \u00e9v\u00e9nements de chien de garde. Cela se manifeste typiquement lorsque le param\u00e8tre restart_method est d\u00e9fini sur \"command\" dans le fichier printer.cfg. Lorsque le bogue se produit, le dispositif AVR ne r\u00e9pond pas jusqu'\u00e0 ce que l'alimentation de la carte soit coup\u00e9e puis remise (les DEL d'alimentation ou d'\u00e9tat peuvent \u00e9galement clignoter de mani\u00e8re r\u00e9p\u00e9t\u00e9e jusqu'\u00e0 ce que l'alimentation soit retir\u00e9e). La solution est d'utiliser un restart_method autre que \"command\" ou de flasher un bootloader r\u00e9cent sur le dispositif AVR. Le flashage d'un nouveau bootloader est une \u00e9tape particuli\u00e8re qui n\u00e9cessite g\u00e9n\u00e9ralement un programmateur externe - voir Bootloaders pour plus de d\u00e9tails. Est-ce que les \u00e9l\u00e9ments chauffants restent allum\u00e9s si le Raspberry Pi plante ? \u00b6 Le logiciel a \u00e9t\u00e9 con\u00e7u pour \u00e9viter cela. Une fois que l'h\u00f4te a activ\u00e9 un \u00e9l\u00e9ment chauffant, le logiciel h\u00f4te doit confirmer cette activation toutes les 5 secondes. Si le microcontr\u00f4leur ne re\u00e7oit pas de confirmation toutes les 5 secondes, il passe dans un status \"arr\u00eat\u00e9\" con\u00e7u pour \u00e9teindre tous les \u00e9l\u00e9ments chauffants et les moteurs pas \u00e0 pas. Voir la commande \"config_digital_out\" dans le documentation des commandes MCU pour plus de d\u00e9tails. En outre, le logiciel du microcontr\u00f4leur est configur\u00e9 avec une plage de temp\u00e9rature minimale et maximale pour chaque \u00e9l\u00e9ment chauffant au d\u00e9marrage (voir les param\u00e8tres min_temp et max_temp dans le document de r\u00e9f\u00e9rences des configurations pour plus de d\u00e9tails). Si le microcontr\u00f4leur d\u00e9tecte que la temp\u00e9rature est en dehors de cette plage, il passe \u00e9galement au status \"arr\u00eat\u00e9\". S\u00e9par\u00e9ment, le logiciel h\u00f4te impl\u00e9mente \u00e9galement un code pour v\u00e9rifier que les \u00e9l\u00e9ments chauffants et les capteurs de temp\u00e9rature fonctionnent correctement. Voir le document de r\u00e9f\u00e9rence des configurations pour plus de d\u00e9tails. Comment puis-je convertir les noms de broches de Marlin \u00e0 Klipper ? \u00b6 R\u00e9ponse courte : un mappage est disponible dans le fichier sample-aliases.cfg . Utilisez ce fichier comme guide pour trouver les noms des broches du microcontr\u00f4leur. (Il est \u00e9galement possible de copier la section de configuration board_pins correspondante dans votre fichier de configuration et d'utiliser les alias dans votre configuration, mais il est pr\u00e9f\u00e9rable de traduire et d'utiliser les noms r\u00e9els des broches du microcontr\u00f4leur). Notez que le fichier sample-aliases.cfg utilise des noms de broches qui commencent par le pr\u00e9fixe \"ar\" au lieu de \"D\" (par exemple, la broche Arduino D23 est l'alias Klipper ar23 ) et le pr\u00e9fixe \"analog\" au lieu de \"A\" (par exemple, la broche Arduino A14 est l'alias Klipper analog14 ). R\u00e9ponse longue : Klipper utilise les noms de broches standard d\u00e9finis par le microcontr\u00f4leur. Sur les puces Atmega, ces broches mat\u00e9rielles ont des noms tels que PA4 , PC7 , ou PD2 . Il y a longtemps, le projet Arduino a d\u00e9cid\u00e9 d'\u00e9viter d'utiliser les noms standards du mat\u00e9riel en faveur de leurs propres noms de broches bas\u00e9s sur des nombres incr\u00e9ment\u00e9s - ces noms Arduino ressemblent g\u00e9n\u00e9ralement \u00e0 D23 ou A14 . Il s'agit d'un choix malheureux qui peut pr\u00eater \u00e0 confusion. En particulier parce que les num\u00e9ros de broches Arduino ne correspondent pas syst\u00e9matiquement aux m\u00eames noms mat\u00e9riels. Par exemple, D21 correspond \u00e0 PD0 sur certaines cartes Arduino et \u00e0 PC7 sur d'autres. Pour \u00e9viter cette confusion, le code source de Klipper utilise les noms de broches standard d\u00e9finis par le microcontr\u00f4leur. Dois-je connecter mon appareil \u00e0 un type sp\u00e9cifique de broche de microcontr\u00f4leur ? \u00b6 Cela d\u00e9pend du type d'appareil et du type de broche : Broches ADC (ou broches analogiques) : pour les thermistances et autres capteurs \"analogiques\", l'\u00e9l\u00e9ment doit \u00eatre c\u00e2bl\u00e9 \u00e0 une broche \"analogique\" ou \"ADC\" du microcontr\u00f4leur. Si vous configurez Klipper pour utiliser une broche qui n'est pas capable de fonctionner en analogique, Klipper signalera une erreur \"Not a valid ADC pin\". Broches PWM (ou broches de timer) : Klipper n'utilise pas de PWM mat\u00e9riel par d\u00e9faut pour aucun \u00e9l\u00e9ment. Donc on peut c\u00e2bler des \u00e9l\u00e9ments chauffants, des ventilateurs et des dispositifs similaires \u00e0 n'importe quelle broche d'E/S d'usage g\u00e9n\u00e9ral. Cependant, les ventilateurs et les \u00e9l\u00e9ments param\u00e9tr\u00e9s en output_pin peuvent \u00eatre \u00e9ventuellement configur\u00e9s pour utiliser hardware_pwm : True , auquel cas le micro-contr\u00f4leur doit supporter le PWM mat\u00e9riel sur la broche (sinon, Klipper signalera une erreur \"Not a valid PWM pin\"). Broches IRQ (ou broches d'interruption) : Klipper n'utilise pas d'interruptions mat\u00e9rielles sur les broches d'E/S, il n'est donc jamais n\u00e9cessaire de connecter un p\u00e9riph\u00e9rique \u00e0 l'une de ces broches du microcontr\u00f4leur. Broches SPI : Lors de l'utilisation du SPI mat\u00e9riel, il est n\u00e9cessaire de connecter l\u2019\u00e9l\u00e9ment aux broches SPI du micro-contr\u00f4leur. Toutefois, la plupart des \u00e9l\u00e9ments peuvent \u00eatre configur\u00e9s pour utiliser le \"SPI logiciel\", auquel cas n'importe quelle broche d'E/S d'usage g\u00e9n\u00e9ral peut \u00eatre utilis\u00e9e. Broches I2C : lors de l'utilisation d'I2C, il est n\u00e9cessaire de c\u00e2bler les broches aux broches compatibles I2C du microcontr\u00f4leur. D\u2019autres \u00e9l\u00e9ments peuvent \u00eatre c\u00e2bl\u00e9s \u00e0 n\u2019importe quelle broche d\u2019E/S \u00e0 usage g\u00e9n\u00e9ral. Par exemple, les steppers, les \u00e9l\u00e9ments chauffants, les ventilateurs, les sondes Z, les servos, les LED, les \u00e9crans LCD hd44780 /st7920 courants, le c\u00e2ble de communication UART des pilotes Trinamic peut \u00eatre raccord\u00e9 \u00e0 n\u2019importe quelle broche d'E/S. Comment annuler une commande M109/M190 \u00ab attendre la temp\u00e9rature \u00bb ? \u00b6 Allez dans l'onglet terminal d'OctoPrint et envoyez une commande M112 dans la console. La commande M112 fera entrer Klipper dans un \u00e9tat \"d'arr\u00eat\" et d\u00e9connectera OctoPrint de Klipper. Dans le bloc de connexion d'OctoPrint, cliquez sur \"Connecter\" pour que OctoPrint se reconnecte. Revenez \u00e0 l'onglet du terminal et lancez une commande FIRMWARE_RESTART pour effacer le status en erreur de Klipper. Apr\u00e8s avoir effectu\u00e9 cette s\u00e9quence, la demande de chauffage pr\u00e9c\u00e9dente sera annul\u00e9e et une nouvelle impression pourra \u00eatre lanc\u00e9e. Comment savoir si l'imprimante a perdu des pas ? \u00b6 D'une certaine mani\u00e8re, oui. Effectuez la prise d'origine (homing), lancez la commande GET_POSITION , d\u00e9marrez votre impression, refaite la prise d'origine et lancez \u00e0 nouveau la commande GET_POSITION . Comparez ensuite les valeurs de la ligne mcu : . Cela peut \u00eatre utile pour r\u00e9gler des param\u00e8tres tels que les courants, les acc\u00e9l\u00e9rations et les vitesses des moteurs pas \u00e0 pas sans avoir besoin d'imprimer quelque chose et de gaspiller du filament : il suffit d'ex\u00e9cuter quelques mouvements \u00e0 grande vitesse entre des commandes GET_POSITION . Notez que les interrupteurs de fin de course eux-m\u00eames ont tendance \u00e0 se d\u00e9clencher \u00e0 des positions l\u00e9g\u00e8rement diff\u00e9rentes, de sorte qu'une diff\u00e9rence de quelques micro-pas est probablement caus\u00e9 par l'impr\u00e9cision de la fin de course. Un moteur pas \u00e0 pas ne peut perdre des pas que par incr\u00e9ments de 4 pas complets. (Ainsi, si l'on utilise 16 micropas, un pas r\u00e9ellement perdu par le moteur se traduirait par une diff\u00e9rence multiple de 64 micropas avec le compteur de pas \"mcu :\") Pourquoi Klipper signale-t-il des erreurs ? J\u2019ai rat\u00e9 mon impression ! \u00b6 R\u00e9ponse courte : Nous voulons savoir si nos imprimantes rencontre un probl\u00e8me afin qu'il puisse \u00eatre r\u00e9solu et que nous puissions obtenir des impressions de grande qualit\u00e9. Nous ne voulons surtout pas que nos imprimantes produisent sans le signaler, des impressions de mauvaise qualit\u00e9. R\u00e9ponse longue : Klipper a \u00e9t\u00e9 con\u00e7u pour contourner automatiquement de nombreux probl\u00e8mes passagers. Par exemple, il d\u00e9tecte automatiquement les erreurs de communication et retransmet les donn\u00e9es ; il planifie les actions \u00e0 l'avance et met en m\u00e9moire tampon les commandes \u00e0 plusieurs niveaux pour permettre une synchronisation pr\u00e9cise, m\u00eame en cas d'interf\u00e9rences intermittentes. Toutefois, si le logiciel d\u00e9tecte une erreur dont il ne peut corriger, s'il re\u00e7oit l'ordre d'effectuer une action non valide ou s'il constate qu'il est d\u00e9sesp\u00e9r\u00e9ment incapable d'ex\u00e9cuter la t\u00e2che qui lui est demand\u00e9e, Klipper signalera une erreur. Dans ces situations, le risque est grand de produire une impression de mauvaise qualit\u00e9 (ou pire). Nous esp\u00e9rons que le fait d'alerter l'utilisateur lui permettra de r\u00e9soudre le probl\u00e8me sous-jacent et d'am\u00e9liorer la qualit\u00e9 globale de ses impressions. Il y a quelques questions connexes : Pourquoi Klipper ne met-il pas plut\u00f4t l'impression en pause ? Ne signale-t-il pas plut\u00f4t un avertissement ? Ne v\u00e9rifie-t-il pas les erreurs avant l'impression ? N'ignore-t-il pas les erreurs dans les commandes saisies par l'utilisateur ? etc. Actuellement, Klipper lit les commandes en utilisant le protocole G-Code, et malheureusement le protocole de commande G-Code n'est pas assez flexible pour rendre ces alternatives praticables aujourd'hui. Il y a un int\u00e9r\u00eat certain \u00e0 am\u00e9liorer l'exp\u00e9rience utilisateur pour la gestion de ces \u00e9v\u00e8nements anormaux mais cela n\u00e9cessite un travail notable sur l'infrastructure (incluant de d\u00e9tourner le G-Code). Comment mettre \u00e0 jour vers la derni\u00e8re version du logiciel ? \u00b6 La premi\u00e8re \u00e9tape de la mise \u00e0 jour du logiciel consiste \u00e0 consulter le document le plus r\u00e9cent des changements de configuration . Il arrive que des modifications soient apport\u00e9es au logiciel et que les utilisateurs doivent mettre \u00e0 jour leurs param\u00e8tres dans le cadre d'une mise \u00e0 niveau logicielle. Il est conseill\u00e9 de consulter ce document avant de proc\u00e9der \u00e0 la mise \u00e0 niveau. Lorsque vous \u00eates pr\u00eat \u00e0 mettre \u00e0 jour, la m\u00e9thode g\u00e9n\u00e9rale consiste \u00e0 se connecter au Raspberry Pi et \u00e0 ex\u00e9cuter : cd ~/klipper git pull ~/klipper/scripts/install-octopi.sh On peut ensuite recompiler et flasher le code du microcontr\u00f4leur. Par exemple : make menuconfig make clean make sudo service klipper stop make flash FLASH_DEVICE=/dev/ttyACM0 sudo service klipper start Cependant, il arrive parfois que seul le logiciel h\u00f4te change. Dans ce cas, on peut mettre \u00e0 jour et red\u00e9marrer uniquement le logiciel h\u00f4te avec : cd ~/klipper git pull sudo service klipper restart Si, apr\u00e8s avoir utilis\u00e9 ce raccourci, le logiciel vous avertit qu'il faut reflasher le microcontr\u00f4leur ou qu'une autre erreur inhabituelle se produit, suivez les \u00e9tapes compl\u00e8tes de mise \u00e0 jour d\u00e9crites ci-dessus. Si des erreurs persistent, v\u00e9rifiez le document modifications de configuration , car vous devrez peut-\u00eatre modifier la configuration de l\u2019imprimante. Notez que les commandes G-Code RESTART et FIRMWARE_RESTART ne rechargent pas le logiciel - les commandes \"sudo service klipper restart\" et \"make flash\" ci-dessus sont n\u00e9cessaires pour que les modifications du logiciel prennent effet. Comment d\u00e9sinstaller Klipper ? \u00b6 Pour ce qui est du firmware, il n'y a rien de sp\u00e9cial \u00e0 faire. Suivez simplement les instructions de flashage du nouveau firmware. Du c\u00f4t\u00e9 Raspberry Pi, un script de d\u00e9sinstallation est disponible dans scripts/klipper-uninstall.sh . Par exemple : sudo ~/klipper/scripts/klipper-uninstall.sh rm -rf ~/klippy-env ~/klipper","title":"Foire Aux Questions"},{"location":"FAQ.html#foire-aux-questions","text":"","title":"Foire Aux Questions"},{"location":"FAQ.html#comment-puis-je-faire-un-don-au-projet","text":"Merci de votre soutien. Voir la page Sponsors pour plus d'informations.","title":"Comment puis-je faire un don au projet ?"},{"location":"FAQ.html#comment-calculer-le-parametre-de-configuration-rotation_distance","text":"Voir le document sur la distance de rotation .","title":"Comment calculer le param\u00e8tre de configuration rotation_distance ?"},{"location":"FAQ.html#ou-est-mon-port-serie","text":"De mani\u00e8re g\u00e9n\u00e9rale, on ex\u00e9cute la commande ls /dev/serial/by-id/* \u00e0 partir d'un terminal ssh sur la machine h\u00f4te pour trouver un port s\u00e9rie USB. Cette commande produira s\u00fbrement un r\u00e9sultat similaire \u00e0 celui-ci : /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 Le nom retourn\u00e9 par la commande ci-dessus est constant, il est donc possible de l'utiliser dans le fichier de configuration et lors du flashage du microcontr\u00f4leur. Par exemple, une commande de flash peur ressembler \u00e0 : sudo service klipper stop make flash FLASH_DEVICE=/dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 sudo service klipper start et la configuration mise \u00e0 jour devrait ressembler \u00e0 : [mcu] serial: /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 Veillez \u00e0 copier-coller le nom retourn\u00e9 par la commande \"ls\" que vous avez ex\u00e9cut\u00e9e ci-avant, car le nom sera diff\u00e9rent pour chaque imprimante. Si vous utilisez plusieurs microcontr\u00f4leurs et qu'ils n'ont pas d'identifiant unique (fr\u00e9quent avec les cartes utilisant une puce USB CH340), suivez les instructions ci-dessus en utilisant la commande ls /dev/serial/by-path/* \u00e0 la place.","title":"O\u00f9 est mon port s\u00e9rie ?"},{"location":"FAQ.html#lorsque-le-microcontroleur-redemarre-le-peripherique-passe-a-devttyusb1","text":"Suivez les instructions de la section \" O\u00f9 est mon port s\u00e9rie ? \" pour \u00e9viter que cela ne se produise.","title":"Lorsque le microcontr\u00f4leur red\u00e9marre, le p\u00e9riph\u00e9rique passe \u00e0 /dev/ttyUSB1"},{"location":"FAQ.html#la-commande-make-flash-ne-fonctionne-pas","text":"Le code tente de flasher le dispositif en utilisant la m\u00e9thode la plus courante pour chaque plateforme. Malheureusement, il y a beaucoup de variations dans les m\u00e9thodes de flashage, donc la commande \"make flash\" peut ne pas fonctionner avec toutes les cartes. Si vous rencontrez une erreur intermittente ou si votre configuration est standard, v\u00e9rifiez que Klipper est arr\u00eat\u00e9 pendant le flashage (sudo service klipper stop), assurez-vous qu'OctoPrint n'essaye pas de se connecter directement \u00e0 l'appareil (ouvrez l'onglet Connexion de la page web et cliquez sur D\u00e9connecter si le port s\u00e9rie de la carte est s\u00e9lectionn\u00e9), et assurez-vous que FLASH_DEVICE est correctement d\u00e9fini pour votre carte (voir la question ci-dessus ). Toutefois si \"make flash\" ne fonctionne pas pour votre carte, vous devrez flasher manuellement. V\u00e9rifiez s'il existe un fichier de configuration dans le r\u00e9pertoire config avec des instructions sp\u00e9cifiques pour flasher la carte. V\u00e9rifiez \u00e9galement la documentation du fabricant de la carte pour voir si elle d\u00e9crit comment la flasher. Enfin, il peut \u00eatre possible de flasher manuellement la carte en utilisant des outils tels que \"avrdude\" ou \"bossac\" - voir le document sur les booloaders pour plus d'informations.","title":"La commande \"make flash\" ne fonctionne pas"},{"location":"FAQ.html#comment-changer-la-vitesse-de-communicationbaud-rate-du-port-serie","text":"Le baud rate (taux bit/s) recommand\u00e9 pour Klipper est de 250000. Ce baud rate fonctionne bien sur toutes les cartes microcontr\u00f4leurs que Klipper prend en charge. Si vous avez trouv\u00e9 un guide en ligne recommandant un baud rate diff\u00e9rent, ignorez cette partie du guide et continuez avec la valeur par d\u00e9faut de 250000. Si vous voulez quand m\u00eame changer le baud rate, le nouveau taux devra \u00eatre configur\u00e9e dans le microcontr\u00f4leur (pendant make menuconfig ) et ce code mis \u00e0 jour devra \u00eatre compil\u00e9 et flash\u00e9 dans le microcontr\u00f4leur. Le fichier printer.cfg de Klipper devra \u00e9galement \u00eatre mis \u00e0 jour pour correspondre \u00e0 ce baud rate (voir le document de r\u00e9f\u00e9rence des configurations pour plus de d\u00e9tails). Par exemple : [mcu] baud: 250000 Le baud rate (taux bit/s) indiqu\u00e9 sur la page Web d'OctoPrint n'a aucun impact sur la vitesse de transmission du microcontr\u00f4leur interne de Klipper. R\u00e9glez toujours le taux de bit/s d'OctoPrint sur 250000 lorsque vous utilisez Klipper. Le baud rate utilis\u00e9 avec Klipper n'est pas li\u00e9e au baud rate du bootloader du microcontr\u00f4leur. Voir le document sur les bootloaders pour plus d'informations sur les bootloaders.","title":"Comment changer la vitesse de communication(baud rate) du port s\u00e9rie ?"},{"location":"FAQ.html#puis-je-faire-fonctionner-klipper-sur-autre-chose-quun-raspberry-pi-3","text":"Le mat\u00e9riel recommand\u00e9 est un Raspberry Pi 2, Raspberry Pi 3 ou Raspberry Pi 4. Klipper fonctionne sur un Raspberry Pi 1 et sur le Raspberry Pi Zero, mais ces cartes n'ont pas assez de puissance de traitement pour faire fonctionner OctoPrint correctement. Il est fr\u00e9quent que l'impression se fasse par \u00e0-coup avec ces machines plus lentes lorsqu'on imprime directement depuis OctoPrint. (L'imprimante peut chercher \u00e0 imprimer plus rapidement que la vitesse \u00e0 laquelle OctoPrint peut envoyer les commandes de mouvement.) Si vous souhaitez quand m\u00eame utiliser une de ces cartes plus lentes, pensez \u00e0 utiliser la fonctionnalit\u00e9 \"virtual_sdcard\" lors de l'impression (voir le document de r\u00e9f\u00e9rence des configurations pour plus de d\u00e9tails). Pour l'ex\u00e9cution sur le Beaglebone, voir les instructions d'installation sp\u00e9cifiques au Beaglebone . Klipper a \u00e9t\u00e9 ex\u00e9cut\u00e9 sur d'autres machines. Le logiciel h\u00f4te de Klipper ne n\u00e9cessite que l'ex\u00e9cution de Python sur un ordinateur Linux (ou similaire). Cependant, si vous souhaitez l'ex\u00e9cuter sur une autre machine, vous aurez besoin de connaissances d'administrateur Linux pour installer les pr\u00e9requis du syst\u00e8me pour cette machine particuli\u00e8re. Consultez le script install-octopi.sh pour plus d'informations sur les \u00e9tapes n\u00e9cessaires \u00e0 l'administration de Linux. Si vous souhaitez ex\u00e9cuter le logiciel h\u00f4te Klipper sur une puce bas de gamme, sachez qu'il faut au minimum une machine dot\u00e9e d'un mat\u00e9riel \u00e0 \"double pr\u00e9cision en virgule flottante\". Si vous souhaitez ex\u00e9cuter le logiciel h\u00f4te Klipper sur un ordinateur de bureau ou un serveur polyvalent partag\u00e9, notez que Klipper a des exigences en mati\u00e8re de programmation en temps r\u00e9el. Si, au cours d'une impression, l'ordinateur h\u00f4te ex\u00e9cute \u00e9galement une t\u00e2che informatique intensive (comme la d\u00e9fragmentation d'un disque dur, un rendu 3D, une forte utilisation du fichier d'\u00e9change, etc.), Klipper pourrait signaler des erreurs d'impression. Note : Si vous n'utilisez pas une image OctoPi, sachez que de nombreuses distributions Linux activent un paquet \"ModemManager\" (ou similaire) pouvant perturber la communication s\u00e9rie. (Ce qui peut amener Klipper \u00e0 rapporter des erreurs apparemment al\u00e9atoires \"Lost communication with MCU\"). Si vous installez Klipper sur une de ces distributions, vous devrez peut-\u00eatre d\u00e9sactiver ce paquet.","title":"Puis-je faire fonctionner Klipper sur autre chose qu'un Raspberry Pi 3 ?"},{"location":"FAQ.html#puis-je-executer-plusieurs-instances-de-klipper-sur-la-meme-machine-hote","text":"Il est possible d'ex\u00e9cuter plusieurs instances du logiciel h\u00f4te Klipper, mais cela n\u00e9cessite des connaissances en administration Linux. Les scripts d'installation de Klipper entra\u00eenent finalement l'ex\u00e9cution de la commande Unix suivante : ~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer.cfg -l /tmp/klippy.log On peut ex\u00e9cuter plusieurs instances de la commande ci-dessus \u00e0 condition que chaque instance ait son propre fichier de configuration d'imprimante, son propre fichier journal et son propre pseudo-tty. Par exemple : ~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer2.cfg -l /tmp/klippy2.log -I /tmp/printer2 Si vous choisissez de le faire, vous devrez impl\u00e9menter les scripts de d\u00e9marrage, d'arr\u00eat et d'installation n\u00e9cessaires (le cas \u00e9ch\u00e9ant). Le script install-octopi.sh et le script klipper-start.sh peuvent \u00eatre utiles comme exemples.","title":"Puis-je ex\u00e9cuter plusieurs instances de Klipper sur la m\u00eame machine h\u00f4te ?"},{"location":"FAQ.html#suis-je-oblige-dutiliser-octoprint","text":"Le logiciel Klipper n'est pas d\u00e9pendant d'OctoPrint. Il est possible d'utiliser un autre logiciel pour envoyer des commandes \u00e0 Klipper, mais cela n\u00e9cessite des connaissances en administration Linux. Klipper cr\u00e9e un \"port s\u00e9rie virtuel\" via le fichier \"/tmp/printer\" qui \u00e9mule une interface s\u00e9rie classique d'imprimante 3d via ce fichier. En g\u00e9n\u00e9ral, les logiciels alternatifs peuvent fonctionner avec Klipper tant qu'ils peuvent \u00eatre configur\u00e9s pour utiliser \"/tmp/printer\" pour le port s\u00e9rie de l'imprimante.","title":"Suis-je oblig\u00e9 d'utiliser Octoprint ?"},{"location":"FAQ.html#pourquoi-ne-puis-je-pas-lancer-un-deplacement-avant-de-prendre-lorigine","text":"Le code fait cela pour r\u00e9duire le risque de d\u00e9placer accidentellement la t\u00eate dans le lit ou dans un mur. Une fois que la prise d'origine est effectu\u00e9e, le logiciel v\u00e9rifie que chaque mouvement se situe dans les limites de position_min/max d\u00e9finies dans le fichier de configuration. Si les moteurs sont d\u00e9sactiv\u00e9s (via une commande M84 ou M18), les moteurs devront reprendre l'origine avant tout mouvement. Si vous souhaitez d\u00e9placer la t\u00eate apr\u00e8s avoir annul\u00e9 une impression via OctoPrint, pensez \u00e0 modifier la s\u00e9quence d'annulation d'OctoPrint pour qu'elle le fasse pour vous. Depuis un navigateur web, elle est configur\u00e9e dans OctoPrint sous : Param\u00e8tres->Scripts GCODE Si vous souhaitez d\u00e9placer la t\u00eate apr\u00e8s la fin d'une impression, pensez \u00e0 ajouter le mouvement souhait\u00e9 \u00e0 la section \"G-Code personnalis\u00e9\" de votre slicer. Si l'imprimante n\u00e9cessite un mouvement suppl\u00e9mentaire dans le cadre du processus de mise \u00e0 l'origine (ou si elle n'a pas de processus de mise \u00e0 l'origine), envisagez d'utiliser une section safe_z_home ou homing_override dans le fichier de configuration. Si vous devez d\u00e9placer un moteur \u00e0 des fins de diagnostic ou de d\u00e9bogage, pensez \u00e0 ajouter une section force_move dans le fichier de configuration. Voir r\u00e9f\u00e9rence de configuration pour plus de d\u00e9tails sur ces options.","title":"Pourquoi ne puis-je pas lancer un d\u00e9placement avant de prendre l'origine ?"},{"location":"FAQ.html#pourquoi-le-parametre-position_endstop-de-laxe-z-est-il-defini-a-05-dans-les-configurations-par-defaut","text":"Pour les imprimantes de style cart\u00e9sien, la position Z_endstop indique la distance entre la buse et le lit au moment du d\u00e9clenchement de la fin de course. Si possible, il est recommand\u00e9 d'utiliser une but\u00e9e de fin de course Z-max et de s'\u00e9loigner du lit (car cela r\u00e9duit le risque de collision avec le lit). Cependant, si l'on doit se rapprocher du lit, il est recommand\u00e9 de positionner la but\u00e9e de mani\u00e8re \u00e0 ce qu'elle se d\u00e9clenche lorsque la buse est encore \u00e0 une petite distance du lit. De cette fa\u00e7on, lorsque l'axe se dirige vers le lit, il s'arr\u00eate avant que la buse ne touche le lit. Voir le document niveau du lit pour plus d'informations.","title":"Pourquoi le param\u00e8tre position_endstop de l'axe Z est-il d\u00e9fini \u00e0 0.5 dans les configurations par d\u00e9faut ?"},{"location":"FAQ.html#jai-converti-ma-configuration-depuis-marlin-et-les-axes-xy-fonctionnent-bien-mais-jobtiens-un-bruit-strident-lors-de-lorientation-de-laxe-z","text":"R\u00e9ponse courte : Tout d'abord, assurez-vous d'avoir v\u00e9rifi\u00e9 la configuration du moteur comme d\u00e9crit dans le document de v\u00e9rification de la configuration . Si le probl\u00e8me persiste, essayez de r\u00e9duire le param\u00e8tre max_z_velocity dans la configuration de l'imprimante. R\u00e9ponse longue : En pratique, Marlin ne peut se d\u00e9placer qu'\u00e0 une vitesse d'environ 10000 pas par seconde. Si on lui demande de se d\u00e9placer \u00e0 une vitesse n\u00e9cessitant un taux de pas plus \u00e9lev\u00e9, Marlin se contentera g\u00e9n\u00e9ralement de faire des pas aussi rapides qu'il le peut. Klipper est capable d'atteindre des taux de pas beaucoup plus \u00e9lev\u00e9s, mais le moteur pas \u00e0 pas peut ne pas avoir de couple suffisant pour se d\u00e9placer \u00e0 une vitesse plus \u00e9lev\u00e9e. Ainsi, pour un axe Z avec un rapport d'engrenage \u00e9lev\u00e9 ou un r\u00e9glage de micropas \u00e9lev\u00e9, la vitesse max_z_obtenue peut \u00eatre inf\u00e9rieure \u00e0 ce qui est configur\u00e9 dans Marlin.","title":"J'ai converti ma configuration depuis Marlin et les axes X/Y fonctionnent bien, mais j'obtiens un bruit strident lors de l'orientation de l'axe Z"},{"location":"FAQ.html#mes-pilotes-de-moteur-tmc-sarretent-en-plein-milieu-dune-impression","text":"Si vous utilisez le pilote TMC2208 (ou TMC2224) en \"mode autonome\", assurez-vous d'utiliser la derni\u00e8re version de Klipper . Une solution de contournement pour un probl\u00e8me avec les pilotes TMC2208 \"stealthchop\" a \u00e9t\u00e9 ajout\u00e9e \u00e0 Klipper \u00e0 la mi-mars 2020.","title":"Mes pilotes de moteur TMC s'arr\u00eatent en plein milieu d'une impression"},{"location":"FAQ.html#jai-des-erreurs-aleatoires-lost-communication-with-mcu-communication-perdue-avec-le-microcontroleur","text":"Ce probl\u00e8me est g\u00e9n\u00e9ralement caus\u00e9 par des erreurs mat\u00e9rielles sur la connexion USB entre la machine h\u00f4te et le microcontr\u00f4leur. Les choses \u00e0 rechercher : Utilisez un c\u00e2ble USB de qualit\u00e9 entre la machine h\u00f4te et le microcontr\u00f4leur. Assurez-vous que les fiches sont bien fix\u00e9es. Si vous utilisez un Raspberry Pi, utilisez une alimentation de bonne qualit\u00e9 pour le Raspberry Pi et utilisez un c\u00e2ble USB de bonne qualit\u00e9 pour connecter cette alimentation au Pi. Si OctoPrint vous avertit que vous \u00eates sous tension, cela est li\u00e9 \u00e0 l'alimentation \u00e9lectrique et doit \u00eatre r\u00e9par\u00e9. Assurez-vous que l'alimentation \u00e9lectrique de l'imprimante n'est pas surcharg\u00e9e. (Les fluctuations d'alimentation de la puce USB du microcontr\u00f4leur peuvent entra\u00eener une r\u00e9initialisation de cette puce.) V\u00e9rifiez que les fils de l'imprimante (pastille, \u00e9l\u00e9ment chauffant et autres) sont bien sertis et pas effiloch\u00e9s. (Le mouvement de l'imprimante peut exercer une contrainte sur un c\u00e2blage d\u00e9fectueux entra\u00eenant une perte de contact, un court-circuit bref ou la production d'un bruit excessif.) Des signalements ont fait \u00e9tat d'un bruit USB \u00e9lev\u00e9 lorsque l'alimentation de l'imprimante et l'alimentation 5V de l'h\u00f4te sont m\u00e9lang\u00e9es. (Si vous constatez que le microcontr\u00f4leur s'allume lorsque l'alimentation de l'imprimante est sous tension ou que le c\u00e2ble USB est branch\u00e9, cela indique que les alimentations 5V sont m\u00e9lang\u00e9es). Il peut \u00eatre utile de configurer le micro-contr\u00f4leur pour qu'il utilise l'alimentation d'une seule source. (Alternativement, si la carte du micro-contr\u00f4leur ne peut pas configurer sa source d'alimentation, on peut modifier un c\u00e2ble USB pour qu'il ne transporte pas de tension de 5V entre l'h\u00f4te et le micro-contr\u00f4leur.)","title":"J'ai des erreurs al\u00e9atoires \"Lost communication with MCU\" (communication perdue avec le microcontr\u00f4leur)"},{"location":"FAQ.html#mon-raspberry-pi-redemarre-pendant-les-impressions","text":"Cela est tr\u00e8s probablement d\u00fb \u00e0 des fluctuations de tension. Suivez les m\u00eames \u00e9tapes de d\u00e9pannage que pour une erreur \u00ab Communication perdue avec le MCU \u00bb .","title":"Mon Raspberry Pi red\u00e9marre pendant les impressions"},{"location":"FAQ.html#lorsque-jai-defini-restart_methodcommand-mon-appareil-avr-se-bloque-lors-dun-redemarrage","text":"Certaines anciennes versions du bootloader AVR ont un bogue connu dans la gestion des \u00e9v\u00e9nements de chien de garde. Cela se manifeste typiquement lorsque le param\u00e8tre restart_method est d\u00e9fini sur \"command\" dans le fichier printer.cfg. Lorsque le bogue se produit, le dispositif AVR ne r\u00e9pond pas jusqu'\u00e0 ce que l'alimentation de la carte soit coup\u00e9e puis remise (les DEL d'alimentation ou d'\u00e9tat peuvent \u00e9galement clignoter de mani\u00e8re r\u00e9p\u00e9t\u00e9e jusqu'\u00e0 ce que l'alimentation soit retir\u00e9e). La solution est d'utiliser un restart_method autre que \"command\" ou de flasher un bootloader r\u00e9cent sur le dispositif AVR. Le flashage d'un nouveau bootloader est une \u00e9tape particuli\u00e8re qui n\u00e9cessite g\u00e9n\u00e9ralement un programmateur externe - voir Bootloaders pour plus de d\u00e9tails.","title":"Lorsque j'ai d\u00e9fini restart_method=command, mon appareil AVR se bloque lors d'un red\u00e9marrage"},{"location":"FAQ.html#est-ce-que-les-elements-chauffants-restent-allumes-si-le-raspberry-pi-plante","text":"Le logiciel a \u00e9t\u00e9 con\u00e7u pour \u00e9viter cela. Une fois que l'h\u00f4te a activ\u00e9 un \u00e9l\u00e9ment chauffant, le logiciel h\u00f4te doit confirmer cette activation toutes les 5 secondes. Si le microcontr\u00f4leur ne re\u00e7oit pas de confirmation toutes les 5 secondes, il passe dans un status \"arr\u00eat\u00e9\" con\u00e7u pour \u00e9teindre tous les \u00e9l\u00e9ments chauffants et les moteurs pas \u00e0 pas. Voir la commande \"config_digital_out\" dans le documentation des commandes MCU pour plus de d\u00e9tails. En outre, le logiciel du microcontr\u00f4leur est configur\u00e9 avec une plage de temp\u00e9rature minimale et maximale pour chaque \u00e9l\u00e9ment chauffant au d\u00e9marrage (voir les param\u00e8tres min_temp et max_temp dans le document de r\u00e9f\u00e9rences des configurations pour plus de d\u00e9tails). Si le microcontr\u00f4leur d\u00e9tecte que la temp\u00e9rature est en dehors de cette plage, il passe \u00e9galement au status \"arr\u00eat\u00e9\". S\u00e9par\u00e9ment, le logiciel h\u00f4te impl\u00e9mente \u00e9galement un code pour v\u00e9rifier que les \u00e9l\u00e9ments chauffants et les capteurs de temp\u00e9rature fonctionnent correctement. Voir le document de r\u00e9f\u00e9rence des configurations pour plus de d\u00e9tails.","title":"Est-ce que les \u00e9l\u00e9ments chauffants restent allum\u00e9s si le Raspberry Pi plante ?"},{"location":"FAQ.html#comment-puis-je-convertir-les-noms-de-broches-de-marlin-a-klipper","text":"R\u00e9ponse courte : un mappage est disponible dans le fichier sample-aliases.cfg . Utilisez ce fichier comme guide pour trouver les noms des broches du microcontr\u00f4leur. (Il est \u00e9galement possible de copier la section de configuration board_pins correspondante dans votre fichier de configuration et d'utiliser les alias dans votre configuration, mais il est pr\u00e9f\u00e9rable de traduire et d'utiliser les noms r\u00e9els des broches du microcontr\u00f4leur). Notez que le fichier sample-aliases.cfg utilise des noms de broches qui commencent par le pr\u00e9fixe \"ar\" au lieu de \"D\" (par exemple, la broche Arduino D23 est l'alias Klipper ar23 ) et le pr\u00e9fixe \"analog\" au lieu de \"A\" (par exemple, la broche Arduino A14 est l'alias Klipper analog14 ). R\u00e9ponse longue : Klipper utilise les noms de broches standard d\u00e9finis par le microcontr\u00f4leur. Sur les puces Atmega, ces broches mat\u00e9rielles ont des noms tels que PA4 , PC7 , ou PD2 . Il y a longtemps, le projet Arduino a d\u00e9cid\u00e9 d'\u00e9viter d'utiliser les noms standards du mat\u00e9riel en faveur de leurs propres noms de broches bas\u00e9s sur des nombres incr\u00e9ment\u00e9s - ces noms Arduino ressemblent g\u00e9n\u00e9ralement \u00e0 D23 ou A14 . Il s'agit d'un choix malheureux qui peut pr\u00eater \u00e0 confusion. En particulier parce que les num\u00e9ros de broches Arduino ne correspondent pas syst\u00e9matiquement aux m\u00eames noms mat\u00e9riels. Par exemple, D21 correspond \u00e0 PD0 sur certaines cartes Arduino et \u00e0 PC7 sur d'autres. Pour \u00e9viter cette confusion, le code source de Klipper utilise les noms de broches standard d\u00e9finis par le microcontr\u00f4leur.","title":"Comment puis-je convertir les noms de broches de Marlin \u00e0 Klipper ?"},{"location":"FAQ.html#dois-je-connecter-mon-appareil-a-un-type-specifique-de-broche-de-microcontroleur","text":"Cela d\u00e9pend du type d'appareil et du type de broche : Broches ADC (ou broches analogiques) : pour les thermistances et autres capteurs \"analogiques\", l'\u00e9l\u00e9ment doit \u00eatre c\u00e2bl\u00e9 \u00e0 une broche \"analogique\" ou \"ADC\" du microcontr\u00f4leur. Si vous configurez Klipper pour utiliser une broche qui n'est pas capable de fonctionner en analogique, Klipper signalera une erreur \"Not a valid ADC pin\". Broches PWM (ou broches de timer) : Klipper n'utilise pas de PWM mat\u00e9riel par d\u00e9faut pour aucun \u00e9l\u00e9ment. Donc on peut c\u00e2bler des \u00e9l\u00e9ments chauffants, des ventilateurs et des dispositifs similaires \u00e0 n'importe quelle broche d'E/S d'usage g\u00e9n\u00e9ral. Cependant, les ventilateurs et les \u00e9l\u00e9ments param\u00e9tr\u00e9s en output_pin peuvent \u00eatre \u00e9ventuellement configur\u00e9s pour utiliser hardware_pwm : True , auquel cas le micro-contr\u00f4leur doit supporter le PWM mat\u00e9riel sur la broche (sinon, Klipper signalera une erreur \"Not a valid PWM pin\"). Broches IRQ (ou broches d'interruption) : Klipper n'utilise pas d'interruptions mat\u00e9rielles sur les broches d'E/S, il n'est donc jamais n\u00e9cessaire de connecter un p\u00e9riph\u00e9rique \u00e0 l'une de ces broches du microcontr\u00f4leur. Broches SPI : Lors de l'utilisation du SPI mat\u00e9riel, il est n\u00e9cessaire de connecter l\u2019\u00e9l\u00e9ment aux broches SPI du micro-contr\u00f4leur. Toutefois, la plupart des \u00e9l\u00e9ments peuvent \u00eatre configur\u00e9s pour utiliser le \"SPI logiciel\", auquel cas n'importe quelle broche d'E/S d'usage g\u00e9n\u00e9ral peut \u00eatre utilis\u00e9e. Broches I2C : lors de l'utilisation d'I2C, il est n\u00e9cessaire de c\u00e2bler les broches aux broches compatibles I2C du microcontr\u00f4leur. D\u2019autres \u00e9l\u00e9ments peuvent \u00eatre c\u00e2bl\u00e9s \u00e0 n\u2019importe quelle broche d\u2019E/S \u00e0 usage g\u00e9n\u00e9ral. Par exemple, les steppers, les \u00e9l\u00e9ments chauffants, les ventilateurs, les sondes Z, les servos, les LED, les \u00e9crans LCD hd44780 /st7920 courants, le c\u00e2ble de communication UART des pilotes Trinamic peut \u00eatre raccord\u00e9 \u00e0 n\u2019importe quelle broche d'E/S.","title":"Dois-je connecter mon appareil \u00e0 un type sp\u00e9cifique de broche de microcontr\u00f4leur ?"},{"location":"FAQ.html#comment-annuler-une-commande-m109m190-attendre-la-temperature","text":"Allez dans l'onglet terminal d'OctoPrint et envoyez une commande M112 dans la console. La commande M112 fera entrer Klipper dans un \u00e9tat \"d'arr\u00eat\" et d\u00e9connectera OctoPrint de Klipper. Dans le bloc de connexion d'OctoPrint, cliquez sur \"Connecter\" pour que OctoPrint se reconnecte. Revenez \u00e0 l'onglet du terminal et lancez une commande FIRMWARE_RESTART pour effacer le status en erreur de Klipper. Apr\u00e8s avoir effectu\u00e9 cette s\u00e9quence, la demande de chauffage pr\u00e9c\u00e9dente sera annul\u00e9e et une nouvelle impression pourra \u00eatre lanc\u00e9e.","title":"Comment annuler une commande M109/M190 \u00ab attendre la temp\u00e9rature \u00bb ?"},{"location":"FAQ.html#comment-savoir-si-limprimante-a-perdu-des-pas","text":"D'une certaine mani\u00e8re, oui. Effectuez la prise d'origine (homing), lancez la commande GET_POSITION , d\u00e9marrez votre impression, refaite la prise d'origine et lancez \u00e0 nouveau la commande GET_POSITION . Comparez ensuite les valeurs de la ligne mcu : . Cela peut \u00eatre utile pour r\u00e9gler des param\u00e8tres tels que les courants, les acc\u00e9l\u00e9rations et les vitesses des moteurs pas \u00e0 pas sans avoir besoin d'imprimer quelque chose et de gaspiller du filament : il suffit d'ex\u00e9cuter quelques mouvements \u00e0 grande vitesse entre des commandes GET_POSITION . Notez que les interrupteurs de fin de course eux-m\u00eames ont tendance \u00e0 se d\u00e9clencher \u00e0 des positions l\u00e9g\u00e8rement diff\u00e9rentes, de sorte qu'une diff\u00e9rence de quelques micro-pas est probablement caus\u00e9 par l'impr\u00e9cision de la fin de course. Un moteur pas \u00e0 pas ne peut perdre des pas que par incr\u00e9ments de 4 pas complets. (Ainsi, si l'on utilise 16 micropas, un pas r\u00e9ellement perdu par le moteur se traduirait par une diff\u00e9rence multiple de 64 micropas avec le compteur de pas \"mcu :\")","title":"Comment savoir si l'imprimante a perdu des pas ?"},{"location":"FAQ.html#pourquoi-klipper-signale-t-il-des-erreurs-jai-rate-mon-impression","text":"R\u00e9ponse courte : Nous voulons savoir si nos imprimantes rencontre un probl\u00e8me afin qu'il puisse \u00eatre r\u00e9solu et que nous puissions obtenir des impressions de grande qualit\u00e9. Nous ne voulons surtout pas que nos imprimantes produisent sans le signaler, des impressions de mauvaise qualit\u00e9. R\u00e9ponse longue : Klipper a \u00e9t\u00e9 con\u00e7u pour contourner automatiquement de nombreux probl\u00e8mes passagers. Par exemple, il d\u00e9tecte automatiquement les erreurs de communication et retransmet les donn\u00e9es ; il planifie les actions \u00e0 l'avance et met en m\u00e9moire tampon les commandes \u00e0 plusieurs niveaux pour permettre une synchronisation pr\u00e9cise, m\u00eame en cas d'interf\u00e9rences intermittentes. Toutefois, si le logiciel d\u00e9tecte une erreur dont il ne peut corriger, s'il re\u00e7oit l'ordre d'effectuer une action non valide ou s'il constate qu'il est d\u00e9sesp\u00e9r\u00e9ment incapable d'ex\u00e9cuter la t\u00e2che qui lui est demand\u00e9e, Klipper signalera une erreur. Dans ces situations, le risque est grand de produire une impression de mauvaise qualit\u00e9 (ou pire). Nous esp\u00e9rons que le fait d'alerter l'utilisateur lui permettra de r\u00e9soudre le probl\u00e8me sous-jacent et d'am\u00e9liorer la qualit\u00e9 globale de ses impressions. Il y a quelques questions connexes : Pourquoi Klipper ne met-il pas plut\u00f4t l'impression en pause ? Ne signale-t-il pas plut\u00f4t un avertissement ? Ne v\u00e9rifie-t-il pas les erreurs avant l'impression ? N'ignore-t-il pas les erreurs dans les commandes saisies par l'utilisateur ? etc. Actuellement, Klipper lit les commandes en utilisant le protocole G-Code, et malheureusement le protocole de commande G-Code n'est pas assez flexible pour rendre ces alternatives praticables aujourd'hui. Il y a un int\u00e9r\u00eat certain \u00e0 am\u00e9liorer l'exp\u00e9rience utilisateur pour la gestion de ces \u00e9v\u00e8nements anormaux mais cela n\u00e9cessite un travail notable sur l'infrastructure (incluant de d\u00e9tourner le G-Code).","title":"Pourquoi Klipper signale-t-il des erreurs ? J\u2019ai rat\u00e9 mon impression !"},{"location":"FAQ.html#comment-mettre-a-jour-vers-la-derniere-version-du-logiciel","text":"La premi\u00e8re \u00e9tape de la mise \u00e0 jour du logiciel consiste \u00e0 consulter le document le plus r\u00e9cent des changements de configuration . Il arrive que des modifications soient apport\u00e9es au logiciel et que les utilisateurs doivent mettre \u00e0 jour leurs param\u00e8tres dans le cadre d'une mise \u00e0 niveau logicielle. Il est conseill\u00e9 de consulter ce document avant de proc\u00e9der \u00e0 la mise \u00e0 niveau. Lorsque vous \u00eates pr\u00eat \u00e0 mettre \u00e0 jour, la m\u00e9thode g\u00e9n\u00e9rale consiste \u00e0 se connecter au Raspberry Pi et \u00e0 ex\u00e9cuter : cd ~/klipper git pull ~/klipper/scripts/install-octopi.sh On peut ensuite recompiler et flasher le code du microcontr\u00f4leur. Par exemple : make menuconfig make clean make sudo service klipper stop make flash FLASH_DEVICE=/dev/ttyACM0 sudo service klipper start Cependant, il arrive parfois que seul le logiciel h\u00f4te change. Dans ce cas, on peut mettre \u00e0 jour et red\u00e9marrer uniquement le logiciel h\u00f4te avec : cd ~/klipper git pull sudo service klipper restart Si, apr\u00e8s avoir utilis\u00e9 ce raccourci, le logiciel vous avertit qu'il faut reflasher le microcontr\u00f4leur ou qu'une autre erreur inhabituelle se produit, suivez les \u00e9tapes compl\u00e8tes de mise \u00e0 jour d\u00e9crites ci-dessus. Si des erreurs persistent, v\u00e9rifiez le document modifications de configuration , car vous devrez peut-\u00eatre modifier la configuration de l\u2019imprimante. Notez que les commandes G-Code RESTART et FIRMWARE_RESTART ne rechargent pas le logiciel - les commandes \"sudo service klipper restart\" et \"make flash\" ci-dessus sont n\u00e9cessaires pour que les modifications du logiciel prennent effet.","title":"Comment mettre \u00e0 jour vers la derni\u00e8re version du logiciel ?"},{"location":"FAQ.html#comment-desinstaller-klipper","text":"Pour ce qui est du firmware, il n'y a rien de sp\u00e9cial \u00e0 faire. Suivez simplement les instructions de flashage du nouveau firmware. Du c\u00f4t\u00e9 Raspberry Pi, un script de d\u00e9sinstallation est disponible dans scripts/klipper-uninstall.sh . Par exemple : sudo ~/klipper/scripts/klipper-uninstall.sh rm -rf ~/klippy-env ~/klipper","title":"Comment d\u00e9sinstaller Klipper ?"},{"location":"Features.html","text":"Caract\u00e9ristiques \u00b6 Klipper propose plusieurs caract\u00e9ristiques int\u00e9ressantes : Mouvements pas \u00e0 pas de haute pr\u00e9cision. Klipper utilise un processeur d'application (tel qu'un Raspberry Pi \u00e0 bas prix) pour calculer les mouvements de l'imprimante. Ce processeur d'application d\u00e9termine le moment o\u00f9 il faut faire marcher chaque moteur pas \u00e0 pas, compresse ces \u00e9v\u00e9nements, les transmet au microcontr\u00f4leur pour que celui-ci ex\u00e9cute chaque \u00e9v\u00e9nement au moment demand\u00e9. Chaque \u00e9v\u00e9nement du moteur pas \u00e0 pas est programm\u00e9 avec une pr\u00e9cision de 25 microsecondes ou mieux. Le logiciel n'utilise pas d'estimations cin\u00e9matiques (telles que l'algorithme de Bresenham), au lieu de cela, il calcule des dur\u00e9es de pas pr\u00e9cises bas\u00e9es sur les physiques de l'acc\u00e9l\u00e9ration et de la cin\u00e9matique de la machine. Un mouvement plus pr\u00e9cis des pas permet un fonctionnement plus silencieux et plus stable de l'imprimante. Meilleur dans sa cat\u00e9gorie. Klipper est capable d'atteindre des taux de pas \u00e9lev\u00e9s sur les nouveaux et anciens microcontr\u00f4leurs. M\u00eame les anciens microcontr\u00f4leurs 8 bits peuvent obtenir des vitesses sup\u00e9rieures \u00e0 175 000 pas par seconde. Sur des microcontr\u00f4leurs plus r\u00e9cents, plusieurs millions de pas par seconde sont possibles. Des vitesses pas \u00e0 pas plus \u00e9lev\u00e9es permettent des vitesses d'impression plus \u00e9lev\u00e9es. La synchronisation des \u00e9v\u00e9nements pas \u00e0 pas reste pr\u00e9cise m\u00eame \u00e0 des vitesses \u00e9lev\u00e9es, ce qui am\u00e9liore la stabilit\u00e9 globale. Klipper prend en charge les imprimantes dot\u00e9es de plusieurs microcontr\u00f4leurs. Par exemple, un microcontr\u00f4leur peut \u00eatre utilis\u00e9 pour contr\u00f4ler l'extrudeur, tandis qu'un autre contr\u00f4le les pi\u00e8ces chauffantes de l'imprimante, et un troisi\u00e8me s'occupe du reste de l'imprimante. Le logiciel Klipper met en \u0153uvre la synchronisation de l'horloge pour tenir compte de la d\u00e9rive entre les microcontr\u00f4leurs. Il n'y a pas besoin de code particulier pour activer plusieurs microcontr\u00f4leurs - il suffit de quelques lignes suppl\u00e9mentaires dans le fichier de configuration. Configuration gr\u00e2ce \u00e0 un fichier de configuration unique. Il n'est pas n\u00e9cessaire de reflasher le microcontr\u00f4leur pour modifier un param\u00e8tre. Toute la configuration de Klipper est stock\u00e9e dans un fichier de configuration standard qui peut \u00eatre facilement modifi\u00e9. Cela facilite la configuration et la maintenance du mat\u00e9riel. Klipper prend en charge la fonction \"Smooth Pressure Advance\", un m\u00e9canisme permettant de prendre en compte les effets de la pression dans un extrudeur. Cela r\u00e9duit le \"suintement\" de l'extrudeur et am\u00e9liore la qualit\u00e9 des d'impression des coins. L'impl\u00e9mentation de Klipper n'introduit pas de changements instantan\u00e9s de la vitesse de l'extrudeur, ce qui am\u00e9liore la stabilit\u00e9 et la robustesse g\u00e9n\u00e9rales. Klipper prend en charge la fonction \"Input Shaping\" pour r\u00e9duire l'impact des vibrations sur la qualit\u00e9 d'impression. Cela peut r\u00e9duire ou \u00e9liminer le \"ringing\" (\u00e9galement appel\u00e9 \"ghosting\", \"echoing\" ou \"rippling\") des impressions. Cela peut \u00e9galement permettre d'obtenir des vitesses d'impression plus rapides tout en maintenant une qualit\u00e9 d'impression \u00e9lev\u00e9e. Klipper utilise un \"solveur it\u00e9ratif\" pour calculer des temps de pas pr\u00e9cis \u00e0 partir d'\u00e9quations cin\u00e9matiques simples. Cela facilite le portage de Klipper sur de nouveaux types de robots et permet de conserver un timing pr\u00e9cis m\u00eame avec une cin\u00e9matique complexe (aucune \"segmentation de ligne\" n'est n\u00e9cessaire). Klipper est agnostique vis-\u00e0-vis du mat\u00e9riel. On doit obtenir le m\u00eame timing pr\u00e9cis ind\u00e9pendamment du mat\u00e9riel \u00e9lectronique de bas niveau. Le code du microcontr\u00f4leur de Klipper est con\u00e7u pour suivre fid\u00e8lement l\u2019ordonnancement fourni par le logiciel h\u00f4te de Klipper (ou pour alerter l'utilisateur de mani\u00e8re \u00e9vidente s'il n'y parvient pas). Il est ainsi plus facile d'utiliser le mat\u00e9riel disponible, de mettre \u00e0 niveau vers un nouveau mat\u00e9riel et d'\u00eatre confiant dans ce mat\u00e9riel. Code portable. Klipper fonctionne sur les micro-contr\u00f4leurs bas\u00e9s sur ARM, AVR et PRU. Les imprimantes existantes de type \"reprap\" peuvent utiliser Klipper sans modification mat\u00e9rielle - il suffit d'ajouter un Raspberry Pi. La conception interne du code de Klipper facilite le support d'autres architectures de micro-contr\u00f4leurs. Un code plus simple. Klipper utilise un langage de tr\u00e8s haut niveau (Python) pour la plupart du code. Les algorithmes cin\u00e9matiques, l'analyse du code G, les algorithmes de chauffage et de thermistance, etc. sont tous \u00e9crits en Python. Il est donc plus facile de d\u00e9velopper de nouvelles fonctionnalit\u00e9s. Macros programmables personnalis\u00e9es. De nouvelles commandes G-Code peuvent \u00eatre d\u00e9finies dans le fichier de configuration de l'imprimante (aucune modification du code n'est alors n\u00e9cessaire). Ces commandes sont programmables - ce qui leur permet de produire diff\u00e9rentes actions selon l'\u00e9tat de l'imprimante. Serveur d\u2019API int\u00e9gr\u00e9. En plus de l\u2019interface G-Code standard, Klipper prend en charge une interface d\u2019application en JSON. Cela permet aux programmeurs de cr\u00e9er des applications externes avec un contr\u00f4le pr\u00e9cis de l\u2019imprimante. Caract\u00e9ristiques suppl\u00e9mentaires \u00b6 Klipper prend en charge de nombreuses fonctionnalit\u00e9s standard des imprimantes 3d : Plusieurs interfaces web disponibles. Fonctionne avec Mainsail, Fluidd, OctoPrint et d'autres. Cela permet de contr\u00f4ler l'imprimante \u00e0 l'aide d'un navigateur web ordinaire. Le m\u00eame Raspberry Pi qui fait fonctionner Klipper peut \u00e9galement faire fonctionner l'interface web. Prise en charge du G-Code standard. Les commandes de g-code courantes produites par les \"trancheurs\" (slicers) typiques (SuperSlicer, Cura, PrusaSlicer, etc.) sont prises en charge. Prise en charge de l'extrusion multiple. Les extrudeurs avec r\u00e9chauffeurs partag\u00e9s et les extrudeurs sur chariots ind\u00e9pendants (IDEX) sont \u00e9galement prises en charge. Prise en charge des imprimantes cart\u00e9siennes, delta, corexy, corexz, hybrides-corexy, hybrides-corexz, deltesiennes, rotatives delta, polaires et \u00e0 treuil. Support du nivellement automatique du bed. Klipper peut \u00eatre configur\u00e9 pour une d\u00e9tection de base de l'inclinaison du bed ou pour une mise \u00e0 niveau compl\u00e8te de celui-ci. Si le bed utilise plusieurs steppers Z, Klipper peut \u00e9galement le mettre \u00e0 niveau en manipulant ind\u00e9pendamment les steppers Z. La plupart des capteurs de hauteur Z sont prises en charge, y compris les sondes BL-Touch et les sondes activ\u00e9es par servomoteur. Prise en charge du calibrage delta automatique. L'outil d'\u00e9talonnage peut effectuer un \u00e9talonnage de base de la hauteur ainsi qu'un avanc\u00e9 des dimensions X et Y. L'\u00e9talonnage peut \u00eatre effectu\u00e9 avec un palpeur de l'axe Z ou manuellement. Prise en charge de l'option \"exclure un objet\" lors de l'impression. Lorsqu'il est configur\u00e9, ce module peut faciliter l'annulation d'un seul objet dans une impression en plusieurs parties. Prise en charge des capteurs de temp\u00e9rature courants (par exemple, les thermistances courantes, AD595, AD597, AD849x, PT100, PT1000, MAX6675, MAX31855, MAX31856, MAX31865, BME280, HTU21D, DS18B20 et LM75). Des thermistances et des capteurs de temp\u00e9rature analogiques personnalis\u00e9s peuvent \u00e9galement \u00eatre configur\u00e9s. On peut surveiller le capteur de temp\u00e9rature interne du microcontr\u00f4leur et le capteur de temp\u00e9rature interne d'un Raspberry Pi. Protection thermique basique de l'appareil activ\u00e9e par d\u00e9faut. Prise en charge des ventilateurs standard, des ventilateurs de buses et des ventilateurs \u00e0 temp\u00e9rature contr\u00f4l\u00e9e. Il n'est pas n\u00e9cessaire de faire tourner les ventilateurs lorsque l'imprimante est inactive. La vitesse du ventilateur peut \u00eatre contr\u00f4l\u00e9e sur les ventilateurs dot\u00e9s d'un tachym\u00e8tre. Prise en charge de la configuration en temps r\u00e9el des pilotes de moteurs pas \u00e0 pas TMC2130, TMC2208/TMC2224, TMC2209, TMC2660 et TMC5160. Il existe \u00e9galement un support pour le contr\u00f4le du courant des pilotes de moteurs pas \u00e0 pas traditionnels via AD5206, DAC084S085, MCP4451, MCP4728, MCP4018, et les broches PWM. Prise en charge des \u00e9crans LCD courants fix\u00e9s directement \u00e0 l'imprimante. Un menu par d\u00e9faut est \u00e9galement disponible. Le contenu de l'\u00e9cran et du menu peut \u00eatre enti\u00e8rement personnalis\u00e9 via le fichier de configuration. Acc\u00e9l\u00e9ration constante et prise en charge du \"look-ahead\". Tous les mouvements de l'imprimante s'acc\u00e9l\u00e8rent progressivement de l'arr\u00eat \u00e0 la vitesse de croisi\u00e8re, puis d\u00e9c\u00e9l\u00e8rent pour revenir \u00e0 l'arr\u00eat. Le flux entrant de commandes de mouvement en G-Code est mis en file d'attente et analys\u00e9 - l'acc\u00e9l\u00e9ration entre les mouvements dans une direction similaire sera optimis\u00e9e pour r\u00e9duire les blocages d'impression et am\u00e9liorer le temps d'impression global. Klipper met en \u0153uvre un algorithme de \"fin de phase pas \u00e0 pas\" qui peut am\u00e9liorer la pr\u00e9cision des interrupteurs de but\u00e9e. Lorsqu'il est correctement r\u00e9gl\u00e9, il peut am\u00e9liorer l'adh\u00e9rence de la premi\u00e8re couche d'une impression. Prise en charge des capteurs de pr\u00e9sence de filaments, des capteurs de mouvement de filaments et des capteurs de largeur de filaments. Prise en charge de la mesure et l'enregistrement de l'acc\u00e9l\u00e9ration \u00e0 l'aide d'un acc\u00e9l\u00e9rom\u00e8tre adxl345, mpu9250 et mpu6050. Prise en charge de la limitation de la vitesse maximale des mouvements courts en \"zigzag\" pour r\u00e9duire les vibrations et le bruit de l'imprimante. Voir le document Cin\u00e9matiques pour plus d'informations. Des exemples de fichiers de configuration sont disponibles pour de nombreuses imprimantes courantes. Consultez le r\u00e9pertoire des configurations pour en obtenir la liste. Pour commencer avec Klipper, lisez le guide d' installation . Tests de performance du stepper \u00b6 Ci-apr\u00e8s les r\u00e9sultats des tests de performance du stepper. Les chiffres indiqu\u00e9s repr\u00e9sentent le nombre total de pas par seconde sur le micro-contr\u00f4leur. Microcontr\u00f4leur 1 stepper actif 3 steppers actifs AVR 16Mhz 157K 99K AVR 20Mhz 196K 123K SAMD21 686K 471K STM32F042 814K 578K PRU Beaglebone 866K 708K STM32G0B1 1103K 790K STM32F103 1180K 818K SAM3X8E 1273K 981K SAM4S8C 1690K 1385K LPC1768 1923K 1351K LPC1769 2353K 1622K RP2040 2400K 1636K SAM4E8E 2500K 1674K SAMD51 3077K 1885K AR100 3529K 2507K STM32F407 3652K 2459K STM32F446 3913K 2634K STM32H743 9091K 6061K Si vous n'\u00eates pas s\u00fbr du microcontr\u00f4leur d'une carte particuli\u00e8re, trouvez le fichier de configuration appropri\u00e9 , et cherchez le nom du microcontr\u00f4leur dans les commentaires en haut de ce fichier. De plus amples d\u00e9tails sur les bancs d'essais sont disponibles dans le document des bancs d'essais .","title":"Caract\u00e9ristiques"},{"location":"Features.html#caracteristiques","text":"Klipper propose plusieurs caract\u00e9ristiques int\u00e9ressantes : Mouvements pas \u00e0 pas de haute pr\u00e9cision. Klipper utilise un processeur d'application (tel qu'un Raspberry Pi \u00e0 bas prix) pour calculer les mouvements de l'imprimante. Ce processeur d'application d\u00e9termine le moment o\u00f9 il faut faire marcher chaque moteur pas \u00e0 pas, compresse ces \u00e9v\u00e9nements, les transmet au microcontr\u00f4leur pour que celui-ci ex\u00e9cute chaque \u00e9v\u00e9nement au moment demand\u00e9. Chaque \u00e9v\u00e9nement du moteur pas \u00e0 pas est programm\u00e9 avec une pr\u00e9cision de 25 microsecondes ou mieux. Le logiciel n'utilise pas d'estimations cin\u00e9matiques (telles que l'algorithme de Bresenham), au lieu de cela, il calcule des dur\u00e9es de pas pr\u00e9cises bas\u00e9es sur les physiques de l'acc\u00e9l\u00e9ration et de la cin\u00e9matique de la machine. Un mouvement plus pr\u00e9cis des pas permet un fonctionnement plus silencieux et plus stable de l'imprimante. Meilleur dans sa cat\u00e9gorie. Klipper est capable d'atteindre des taux de pas \u00e9lev\u00e9s sur les nouveaux et anciens microcontr\u00f4leurs. M\u00eame les anciens microcontr\u00f4leurs 8 bits peuvent obtenir des vitesses sup\u00e9rieures \u00e0 175 000 pas par seconde. Sur des microcontr\u00f4leurs plus r\u00e9cents, plusieurs millions de pas par seconde sont possibles. Des vitesses pas \u00e0 pas plus \u00e9lev\u00e9es permettent des vitesses d'impression plus \u00e9lev\u00e9es. La synchronisation des \u00e9v\u00e9nements pas \u00e0 pas reste pr\u00e9cise m\u00eame \u00e0 des vitesses \u00e9lev\u00e9es, ce qui am\u00e9liore la stabilit\u00e9 globale. Klipper prend en charge les imprimantes dot\u00e9es de plusieurs microcontr\u00f4leurs. Par exemple, un microcontr\u00f4leur peut \u00eatre utilis\u00e9 pour contr\u00f4ler l'extrudeur, tandis qu'un autre contr\u00f4le les pi\u00e8ces chauffantes de l'imprimante, et un troisi\u00e8me s'occupe du reste de l'imprimante. Le logiciel Klipper met en \u0153uvre la synchronisation de l'horloge pour tenir compte de la d\u00e9rive entre les microcontr\u00f4leurs. Il n'y a pas besoin de code particulier pour activer plusieurs microcontr\u00f4leurs - il suffit de quelques lignes suppl\u00e9mentaires dans le fichier de configuration. Configuration gr\u00e2ce \u00e0 un fichier de configuration unique. Il n'est pas n\u00e9cessaire de reflasher le microcontr\u00f4leur pour modifier un param\u00e8tre. Toute la configuration de Klipper est stock\u00e9e dans un fichier de configuration standard qui peut \u00eatre facilement modifi\u00e9. Cela facilite la configuration et la maintenance du mat\u00e9riel. Klipper prend en charge la fonction \"Smooth Pressure Advance\", un m\u00e9canisme permettant de prendre en compte les effets de la pression dans un extrudeur. Cela r\u00e9duit le \"suintement\" de l'extrudeur et am\u00e9liore la qualit\u00e9 des d'impression des coins. L'impl\u00e9mentation de Klipper n'introduit pas de changements instantan\u00e9s de la vitesse de l'extrudeur, ce qui am\u00e9liore la stabilit\u00e9 et la robustesse g\u00e9n\u00e9rales. Klipper prend en charge la fonction \"Input Shaping\" pour r\u00e9duire l'impact des vibrations sur la qualit\u00e9 d'impression. Cela peut r\u00e9duire ou \u00e9liminer le \"ringing\" (\u00e9galement appel\u00e9 \"ghosting\", \"echoing\" ou \"rippling\") des impressions. Cela peut \u00e9galement permettre d'obtenir des vitesses d'impression plus rapides tout en maintenant une qualit\u00e9 d'impression \u00e9lev\u00e9e. Klipper utilise un \"solveur it\u00e9ratif\" pour calculer des temps de pas pr\u00e9cis \u00e0 partir d'\u00e9quations cin\u00e9matiques simples. Cela facilite le portage de Klipper sur de nouveaux types de robots et permet de conserver un timing pr\u00e9cis m\u00eame avec une cin\u00e9matique complexe (aucune \"segmentation de ligne\" n'est n\u00e9cessaire). Klipper est agnostique vis-\u00e0-vis du mat\u00e9riel. On doit obtenir le m\u00eame timing pr\u00e9cis ind\u00e9pendamment du mat\u00e9riel \u00e9lectronique de bas niveau. Le code du microcontr\u00f4leur de Klipper est con\u00e7u pour suivre fid\u00e8lement l\u2019ordonnancement fourni par le logiciel h\u00f4te de Klipper (ou pour alerter l'utilisateur de mani\u00e8re \u00e9vidente s'il n'y parvient pas). Il est ainsi plus facile d'utiliser le mat\u00e9riel disponible, de mettre \u00e0 niveau vers un nouveau mat\u00e9riel et d'\u00eatre confiant dans ce mat\u00e9riel. Code portable. Klipper fonctionne sur les micro-contr\u00f4leurs bas\u00e9s sur ARM, AVR et PRU. Les imprimantes existantes de type \"reprap\" peuvent utiliser Klipper sans modification mat\u00e9rielle - il suffit d'ajouter un Raspberry Pi. La conception interne du code de Klipper facilite le support d'autres architectures de micro-contr\u00f4leurs. Un code plus simple. Klipper utilise un langage de tr\u00e8s haut niveau (Python) pour la plupart du code. Les algorithmes cin\u00e9matiques, l'analyse du code G, les algorithmes de chauffage et de thermistance, etc. sont tous \u00e9crits en Python. Il est donc plus facile de d\u00e9velopper de nouvelles fonctionnalit\u00e9s. Macros programmables personnalis\u00e9es. De nouvelles commandes G-Code peuvent \u00eatre d\u00e9finies dans le fichier de configuration de l'imprimante (aucune modification du code n'est alors n\u00e9cessaire). Ces commandes sont programmables - ce qui leur permet de produire diff\u00e9rentes actions selon l'\u00e9tat de l'imprimante. Serveur d\u2019API int\u00e9gr\u00e9. En plus de l\u2019interface G-Code standard, Klipper prend en charge une interface d\u2019application en JSON. Cela permet aux programmeurs de cr\u00e9er des applications externes avec un contr\u00f4le pr\u00e9cis de l\u2019imprimante.","title":"Caract\u00e9ristiques"},{"location":"Features.html#caracteristiques-supplementaires","text":"Klipper prend en charge de nombreuses fonctionnalit\u00e9s standard des imprimantes 3d : Plusieurs interfaces web disponibles. Fonctionne avec Mainsail, Fluidd, OctoPrint et d'autres. Cela permet de contr\u00f4ler l'imprimante \u00e0 l'aide d'un navigateur web ordinaire. Le m\u00eame Raspberry Pi qui fait fonctionner Klipper peut \u00e9galement faire fonctionner l'interface web. Prise en charge du G-Code standard. Les commandes de g-code courantes produites par les \"trancheurs\" (slicers) typiques (SuperSlicer, Cura, PrusaSlicer, etc.) sont prises en charge. Prise en charge de l'extrusion multiple. Les extrudeurs avec r\u00e9chauffeurs partag\u00e9s et les extrudeurs sur chariots ind\u00e9pendants (IDEX) sont \u00e9galement prises en charge. Prise en charge des imprimantes cart\u00e9siennes, delta, corexy, corexz, hybrides-corexy, hybrides-corexz, deltesiennes, rotatives delta, polaires et \u00e0 treuil. Support du nivellement automatique du bed. Klipper peut \u00eatre configur\u00e9 pour une d\u00e9tection de base de l'inclinaison du bed ou pour une mise \u00e0 niveau compl\u00e8te de celui-ci. Si le bed utilise plusieurs steppers Z, Klipper peut \u00e9galement le mettre \u00e0 niveau en manipulant ind\u00e9pendamment les steppers Z. La plupart des capteurs de hauteur Z sont prises en charge, y compris les sondes BL-Touch et les sondes activ\u00e9es par servomoteur. Prise en charge du calibrage delta automatique. L'outil d'\u00e9talonnage peut effectuer un \u00e9talonnage de base de la hauteur ainsi qu'un avanc\u00e9 des dimensions X et Y. L'\u00e9talonnage peut \u00eatre effectu\u00e9 avec un palpeur de l'axe Z ou manuellement. Prise en charge de l'option \"exclure un objet\" lors de l'impression. Lorsqu'il est configur\u00e9, ce module peut faciliter l'annulation d'un seul objet dans une impression en plusieurs parties. Prise en charge des capteurs de temp\u00e9rature courants (par exemple, les thermistances courantes, AD595, AD597, AD849x, PT100, PT1000, MAX6675, MAX31855, MAX31856, MAX31865, BME280, HTU21D, DS18B20 et LM75). Des thermistances et des capteurs de temp\u00e9rature analogiques personnalis\u00e9s peuvent \u00e9galement \u00eatre configur\u00e9s. On peut surveiller le capteur de temp\u00e9rature interne du microcontr\u00f4leur et le capteur de temp\u00e9rature interne d'un Raspberry Pi. Protection thermique basique de l'appareil activ\u00e9e par d\u00e9faut. Prise en charge des ventilateurs standard, des ventilateurs de buses et des ventilateurs \u00e0 temp\u00e9rature contr\u00f4l\u00e9e. Il n'est pas n\u00e9cessaire de faire tourner les ventilateurs lorsque l'imprimante est inactive. La vitesse du ventilateur peut \u00eatre contr\u00f4l\u00e9e sur les ventilateurs dot\u00e9s d'un tachym\u00e8tre. Prise en charge de la configuration en temps r\u00e9el des pilotes de moteurs pas \u00e0 pas TMC2130, TMC2208/TMC2224, TMC2209, TMC2660 et TMC5160. Il existe \u00e9galement un support pour le contr\u00f4le du courant des pilotes de moteurs pas \u00e0 pas traditionnels via AD5206, DAC084S085, MCP4451, MCP4728, MCP4018, et les broches PWM. Prise en charge des \u00e9crans LCD courants fix\u00e9s directement \u00e0 l'imprimante. Un menu par d\u00e9faut est \u00e9galement disponible. Le contenu de l'\u00e9cran et du menu peut \u00eatre enti\u00e8rement personnalis\u00e9 via le fichier de configuration. Acc\u00e9l\u00e9ration constante et prise en charge du \"look-ahead\". Tous les mouvements de l'imprimante s'acc\u00e9l\u00e8rent progressivement de l'arr\u00eat \u00e0 la vitesse de croisi\u00e8re, puis d\u00e9c\u00e9l\u00e8rent pour revenir \u00e0 l'arr\u00eat. Le flux entrant de commandes de mouvement en G-Code est mis en file d'attente et analys\u00e9 - l'acc\u00e9l\u00e9ration entre les mouvements dans une direction similaire sera optimis\u00e9e pour r\u00e9duire les blocages d'impression et am\u00e9liorer le temps d'impression global. Klipper met en \u0153uvre un algorithme de \"fin de phase pas \u00e0 pas\" qui peut am\u00e9liorer la pr\u00e9cision des interrupteurs de but\u00e9e. Lorsqu'il est correctement r\u00e9gl\u00e9, il peut am\u00e9liorer l'adh\u00e9rence de la premi\u00e8re couche d'une impression. Prise en charge des capteurs de pr\u00e9sence de filaments, des capteurs de mouvement de filaments et des capteurs de largeur de filaments. Prise en charge de la mesure et l'enregistrement de l'acc\u00e9l\u00e9ration \u00e0 l'aide d'un acc\u00e9l\u00e9rom\u00e8tre adxl345, mpu9250 et mpu6050. Prise en charge de la limitation de la vitesse maximale des mouvements courts en \"zigzag\" pour r\u00e9duire les vibrations et le bruit de l'imprimante. Voir le document Cin\u00e9matiques pour plus d'informations. Des exemples de fichiers de configuration sont disponibles pour de nombreuses imprimantes courantes. Consultez le r\u00e9pertoire des configurations pour en obtenir la liste. Pour commencer avec Klipper, lisez le guide d' installation .","title":"Caract\u00e9ristiques suppl\u00e9mentaires"},{"location":"Features.html#tests-de-performance-du-stepper","text":"Ci-apr\u00e8s les r\u00e9sultats des tests de performance du stepper. Les chiffres indiqu\u00e9s repr\u00e9sentent le nombre total de pas par seconde sur le micro-contr\u00f4leur. Microcontr\u00f4leur 1 stepper actif 3 steppers actifs AVR 16Mhz 157K 99K AVR 20Mhz 196K 123K SAMD21 686K 471K STM32F042 814K 578K PRU Beaglebone 866K 708K STM32G0B1 1103K 790K STM32F103 1180K 818K SAM3X8E 1273K 981K SAM4S8C 1690K 1385K LPC1768 1923K 1351K LPC1769 2353K 1622K RP2040 2400K 1636K SAM4E8E 2500K 1674K SAMD51 3077K 1885K AR100 3529K 2507K STM32F407 3652K 2459K STM32F446 3913K 2634K STM32H743 9091K 6061K Si vous n'\u00eates pas s\u00fbr du microcontr\u00f4leur d'une carte particuli\u00e8re, trouvez le fichier de configuration appropri\u00e9 , et cherchez le nom du microcontr\u00f4leur dans les commentaires en haut de ce fichier. De plus amples d\u00e9tails sur les bancs d'essais sont disponibles dans le document des bancs d'essais .","title":"Tests de performance du stepper"},{"location":"G-Codes.html","text":"G-Codes \u00b6 Ce document d\u00e9crit les commandes que Klipper supporte. Il s'agit de commandes que l'on peut saisir dans l'onglet du terminal OctoPrint. Commandes G-Code \u00b6 Klipper prend en charge les commandes G-Code standard suivantes : Move (G0 ou G1): G1 [X<pos>] [Y<pos>] [Z<pos>] [E<pos>] [F<speed>] Temporisation : G4 P<millisecondes> D\u00e9placement vers l'origine : G28 [X] [Y] [Z] \u00c9teindre les moteurs : M18 ou M84 Attendre la fin des mouvements en cours : M400 Utiliser l'extrusion absolue/relative : M82 , M83 Utiliser des coordonn\u00e9es absolues/relatives : G90 , G91 D\u00e9finir la position : G92 [X<pos>] [Y<pos>] [Z<pos>] [E<pos>] D\u00e9finir le pourcentage de neutralisation du facteur de vitesse : M220 S<percent> D\u00e9finit le pourcentage d'annulation du facteur d'extrusion : M221 S<percent> R\u00e9gler l'acc\u00e9l\u00e9ration : M204 S<valeur> OU M204 P<valeur> T<valeur> Remarque : si S n'est pas sp\u00e9cifi\u00e9 et que P et T le sont, l'acc\u00e9l\u00e9ration sera r\u00e9gl\u00e9e sur le minimum de P et T. Si un seul P ou T est donn\u00e9, la commande n'aura aucun effet. Obtenir la temp\u00e9rature de l'extrudeur : M105 R\u00e9gler la temp\u00e9rature de l'extrudeur : M104 [T<index>] [S<temp\u00e9rature>] R\u00e9gler la temp\u00e9rature de l'extrudeur et attendre : M109 [T<index>] S<temp\u00e9rature> Note : M109 attendra toujours que la temp\u00e9rature se stabilise \u00e0 la valeur demand\u00e9e. R\u00e9gler la temp\u00e9rature du bed : M140 [S<temperature>] R\u00e9gler la temp\u00e9rature du bed et attendre : M190 S<temperature> Note : M190 attendra toujours que la temp\u00e9rature se stabilise \u00e0 la valeur demand\u00e9e. R\u00e9gler la vitesse du ventilateur : M106 S<valeur> D\u00e9sactiver le ventilateur : M107 Arr\u00eat d'urgence : M112 Obtenir la position actuelle : M114 Obtenir la version du firmware : M115 Pour plus de d\u00e9tails sur les commandes ci-dessus, voir la [documentation RepRap G-Code] ( http://reprap.org/wiki/G-code ). L'objectif de Klipper est de prendre en charge les commandes G-Code produites par les logiciels tiers courants (par exemple, OctoPrint, Printrun, Slic3r, Cura, etc.) dans leurs configurations standards. Le but n'est pas de prendre en charge toutes les commandes G-Code possibles. Au contraire, Klipper pr\u00e9f\u00e8re les [\"commandes G-Code \u00e9tendues\"] (#additional-commands) humainement lisibles. De la m\u00eame mani\u00e8re, la sortie du terminal G-Code est uniquement destin\u00e9e \u00e0 \u00eatre humainement lisible - voir le document du serveur API si vous contr\u00f4lez Klipper depuis un logiciel externe. Si vous avez besoin d'une commande G-Code moins courante, il est possible de l'impl\u00e9menter avec une section de configuration gcode_macro personnalis\u00e9e . Par exemple, on peut utiliser ceci pour impl\u00e9menter : G12 , G29 , G30 , G31 , M42 , M80 , M81 , T1 , etc. Commandes additionnelles \u00b6 Klipper utilise des commandes G-Code \"\u00e9tendues\" pour la configuration g\u00e9n\u00e9rale et l'\u00e9tat. Ces commandes \u00e9tendues suivent toutes un format similaire : elles commencent par le nom de la commande et peuvent \u00eatre suivies d'un ou plusieurs param\u00e8tres. Par exemple : SET_SERVO SERVO=myservo ANGLE=5.3 . Dans ce document, les commandes et les param\u00e8tres sont indiqu\u00e9s en majuscules, mais ils ne sont pas sensibles \u00e0 la casse. (Ainsi, \"SET_SERVO\" et \"set_servo\" ex\u00e9cuteront tous deux la m\u00eame commande). Cette section est organis\u00e9e par nom de module Klipper, en suivant g\u00e9n\u00e9ralement les noms de section sp\u00e9cifi\u00e9s dans le fichier de configuration de l'imprimante . Notez que certains modules sont automatiquement charg\u00e9s. [adxl345] \u00b6 Les commandes suivantes sont disponibles lorsqu'une section adxl345 config est activ\u00e9e. ACCELEROMETER_MEASURE \u00b6 ACCELEROMETER_MEASURE [CHIP=<nom_de_la_configuration>] [NAME=<valeur>] : D\u00e9marre les mesures de l'acc\u00e9l\u00e9rom\u00e8tre au nombre d'\u00e9chantillons par seconde demand\u00e9. Si CHIP n'est pas pr\u00e9cis\u00e9, la valeur par d\u00e9faut est \"adxl345\". La commande fonctionne en mode start-stop : ex\u00e9cut\u00e9e pour la premi\u00e8re fois, elle d\u00e9marre les mesures, l'ex\u00e9cution suivante les arr\u00eate. Les r\u00e9sultats des mesures sont \u00e9crits dans un fichier nomm\u00e9 /tmp/adxl345-<chip>-<nom>.csv o\u00f9 <chip> est le nom de la puce acc\u00e9l\u00e9rom\u00e8tre ( my_chip_name de [adxl345 my_chip_name] ) et <nom> est le param\u00e8tre optionnel NAME. Si le param\u00e8tre NOM n'est pas pr\u00e9cis\u00e9, l'heure actuelle est utilis\u00e9e par d\u00e9faut au format \"AAAAMMJJ_HHMMSS\". Si l'acc\u00e9l\u00e9rom\u00e8tre n'a pas de nom dans sa section de configuration (simplement [adxl345] ) alors la partie <chip> du nom n'est pas g\u00e9n\u00e9r\u00e9e. ACCELEROMETER_QUERY \u00b6 ACCELEROMETER_QUERY [CHIP=<nom_de_la_configuration>] [RATE=<valeur>] : interroge l'acc\u00e9l\u00e9rom\u00e8tre pour la valeur courante. Si CHIP n'est pas pr\u00e9cis\u00e9, la valeur par d\u00e9faut est \"adxl345\". Si RATE n'est pas pr\u00e9cis\u00e9, la valeur par d\u00e9faut est utilis\u00e9e. Cette commande permet de tester la connexion \u00e0 l'acc\u00e9l\u00e9rom\u00e8tre ADXL345 : une des valeurs retourn\u00e9es devrait \u00eatre une acc\u00e9l\u00e9ration en chute libre (+/- un certain bruit de la puce). ACCELEROMETER_DEBUG_READ \u00b6 ACCELEROMETER_DEBUG_READ [CHIP=<nom_de_la_configuration>] REG=<registre> : interroge le registre ADXL345 \"registre\" (par exemple 44 ou 0x2C). Peut \u00eatre utile \u00e0 des fins de d\u00e9bogage. ACCELEROMETER_DEBUG_WRITE \u00b6 ACCELEROMETER_DEBUG_WRITE [CHIP=<nom_de_la_configuration>] REG=<registre> VAL=<valeur> : Ecrit la \"valeur\" brute dans le registre \"registre\". La \"valeur\" et le \"registre\" peuvent \u00eatre des entiers d\u00e9cimaux ou hexad\u00e9cimaux. A utiliser avec pr\u00e9caution, et se r\u00e9f\u00e9rer \u00e0 la fiche technique de l'ADXL345 pour la r\u00e9f\u00e9rence. [angle] \u00b6 Les commandes suivantes sont disponibles lorsqu'une section angle config est activ\u00e9e. ANGLE_CALIBRATE \u00b6 ANGLE_CALIBRATE CHIP=<nom_de_la_puce> : Effectue une calibration d'angle sur le capteur donn\u00e9 (il doit y avoir une section de configuration [angle nom_de_la_puce] qui a indiqu\u00e9 un param\u00e8tre stepper ). IMPORTANT - cet outil commandera au moteur pas \u00e0 pas de se d\u00e9placer sans v\u00e9rifier les limites normales de la cin\u00e9matique. Id\u00e9alement, le moteur devrait \u00eatre d\u00e9connect\u00e9 de tout chariot d'imprimante avant d'effectuer le calibrage. Si le moteur pas \u00e0 pas ne peut pas \u00eatre d\u00e9connect\u00e9 de l'imprimante, assurez-vous que le chariot est proche du centre de son rail avant de commencer l'\u00e9talonnage. (Le moteur pas \u00e0 pas peut se d\u00e9placer vers l'avant ou l'arri\u00e8re de deux rotations compl\u00e8tes durant ce test). Apr\u00e8s avoir termin\u00e9 ce test, utilisez la commande SAVE_CONFIG pour sauvegarder les donn\u00e9es de calibration dans le fichier de configuration. Afin d'utiliser cet outil, le paquetage Python \"numpy\" doit \u00eatre install\u00e9 (voir le document mesurer les r\u00e9sonances pour plus d'informations). ANGLE_DEBUG_READ \u00b6 ANGLE_DEBUG_READ CHIP=<nom_de_la_configuration> REG=<registre> : Interroge le registre \"registre\" du capteur (par exemple 44 ou 0x2C). Peut \u00eatre utile \u00e0 des fins de d\u00e9bogage. Ceci n'est disponible que pour les puces tle5012b. ANGLE_DEBUG_WRITE \u00b6 ANGLE_DEBUG_WRITE CHIP=<nom_de_la_configuration> REG=<registre> VAL=<valeur> : \u00c9crit la \"valeur\" brute dans le registre \"registre\". La \"valeur\" et le \"registre\" peuvent \u00eatre des entiers d\u00e9cimaux ou hexad\u00e9cimaux. A utiliser avec pr\u00e9caution, et se r\u00e9f\u00e9rer \u00e0 la fiche technique du capteur pour la r\u00e9f\u00e9rence. Cette fonction n'est disponible que pour les puces tle5012b. [bed_mesh] \u00b6 Les commandes suivantes sont disponibles lorsque la section configuration de bed_mesh est activ\u00e9e (voir \u00e9galement le guide de bed_mesh ). BED_MESH_CALIBRATE \u00b6 BED_MESH_CALIBRATE [METHOD=manual] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] [<mesh_parameter>=<value>] : Cette commande sonde le lit en utilisant les points g\u00e9n\u00e9r\u00e9s sp\u00e9cifi\u00e9s par les param\u00e8tres dans la configuration. Apr\u00e8s le sondage, un maillage est g\u00e9n\u00e9r\u00e9 et le mouvement z est ajust\u00e9 en fonction du maillage. Voir la commande PROBE pour plus de d\u00e9tails sur les param\u00e8tres de sonde facultatifs. Si METHOD=manual est sp\u00e9cifi\u00e9, l'outil de sondage manuel est activ\u00e9 - voir la commande MANUAL_PROBE ci-dessus pour plus de d\u00e9tails sur les commandes suppl\u00e9mentaires disponibles lorsque cet outil est actif. La valeur facultative HORIZONTAL_MOVE_Z remplace l'option horizontal_move_z sp\u00e9cifi\u00e9e dans le fichier de configuration. BED_MESH_OUTPUT \u00b6 BED_MESH_OUTPUT PGP=[<0:1>] : Cette commande \u00e9crit les valeurs z palp\u00e9es actuelles et les valeurs de maillage actuelles sur le terminal. Si PGP=1 est sp\u00e9cifi\u00e9, les coordonn\u00e9es X, Y g\u00e9n\u00e9r\u00e9es par bed_mesh, ainsi que leurs indices associ\u00e9s, seront envoy\u00e9s au terminal. BED_MESH_MAP \u00b6 BED_MESH_MAP : Comme pour BED_MESH_OUTPUT, cette commande affiche l'\u00e9tat actuel du maillage sur le terminal. L'\u00e9tat sera retourn\u00e9 au format json. Cela permet aux plugins octoprint de r\u00e9cup\u00e9rer facilement les donn\u00e9es et de g\u00e9n\u00e9rer des cartes d'altitude au plus proche de la surface du bed. BED_MESH_CLEAR \u00b6 BED_MESH_CLEAR : Cette commande efface le maillage actuel et supprime les ajustements de l'axe z. Il est recommand\u00e9 de mettre cette commande dans votre gcode de fin. BED_MESH_PROFILE \u00b6 BED_MESH_PROFILE LOAD=<nom> SAVE=<nom> REMOVE=<nom> : Cette commande fournit une gestion de profil pour l'\u00e9tat du maillage. LOAD restaurera l'\u00e9tat du maillage \u00e0 partir du profil correspondant au nom fourni. SAVE sauvegarde l'\u00e9tat du maillage actuel dans un profil correspondant au nom fourni. REMOVE supprimera le profil correspondant au nom fourni de la m\u00e9moire persistante. Notez qu'apr\u00e8s l'ex\u00e9cution des op\u00e9rations SAVE ou REMOVE, le gcode SAVE_CONFIG doit \u00eatre ex\u00e9cut\u00e9 pour rendre les changements de la m\u00e9moire persistante permanents. BED_MESH_OFFSET \u00b6 BED_MESH_OFFSET [X=<value>] [Y=<value>] : Applique des d\u00e9calages X et/ou Y pour l'\u00e9valuation du maillage. Ceci est utile pour les imprimantes avec extrudeurs ind\u00e9pendants, car un d\u00e9calage est n\u00e9cessaire pour obtenir un ajustement Z correct apr\u00e8s un changement d'outil. [bed_screws] \u00b6 Les commandes suivantes sont disponibles lorsque la section config bed_screws est activ\u00e9e (voir \u00e9galement le guide du nivelage manuel ). BED_SCREWS_ADJUST \u00b6 BED_SCREWS_ADJUST : Cette commande fait appel \u00e0 l'outil de r\u00e9glage des vis du bed. Elle commandera la buse \u00e0 diff\u00e9rents endroits (tels que d\u00e9finis dans le fichier de configuration) et permettra d'ajuster les vis du bed afin que celui-ci et la buse soient \u00e0 distance constante. [bed_tilt] \u00b6 Les commandes suivantes sont disponibles lorsque la section config bed_tilt est activ\u00e9e. BED_TILT_CALIBRATE \u00b6 BED_TILT_CALIBRATE [METHOD=manual] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] : Cette commande sondera les points sp\u00e9cifi\u00e9s dans la configuration, puis recommandera des ajustements d'inclinaison x et y mis \u00e0 jour. Voir la commande PROBE pour plus de d\u00e9tails sur les param\u00e8tres de sonde facultatifs. Si METHOD=manual est sp\u00e9cifi\u00e9, l'outil de sondage manuel est activ\u00e9 - voir la commande MANUAL_PROBE ci-dessus pour plus de d\u00e9tails sur les commandes suppl\u00e9mentaires disponibles lorsque cet outil est actif. La valeur facultative HORIZONTAL_MOVE_Z remplace l'option horizontal_move_z sp\u00e9cifi\u00e9e dans le fichier de configuration. [bltouch] \u00b6 La commande suivante est disponible lorsqu'une section bltouch config est activ\u00e9e (voir \u00e9galement le Guide BL-Touch ). BLTOUCH_DEBUG \u00b6 BLTOUCH_DEBUG COMMAND=<commande> : Ceci envoie une commande au BLTouch. Elle peut \u00eatre utile pour le d\u00e9bogage. Les commandes disponibles sont : pin_down , touch_mode , pin_up , self_test , reset . Un BL-Touch V3.0 ou V3.1 accepte en plus les commandes set_5V_output_mode , set_OD_output_mode , output_mode_store . BLTOUCH_STORE \u00b6 BLTOUCH_STORE MODE=<output_mode> : Stocke un mode de sortie dans l'EEPROM d'un BLTouch V3.1 Les modes de sortie disponibles sont : 5V , OD [configfile] \u00b6 Le module configfile est automatiquement charg\u00e9. SAVE_CONFIG \u00b6 SAVE_CONFIG : Cette commande \u00e9crase le fichier de configuration principal de l'imprimante et red\u00e9marre le logiciel h\u00f4te. Cette commande est utilis\u00e9e conjointement avec d'autres commandes d'\u00e9talonnage pour enregistrer les r\u00e9sultats de ces tests. [delayed_gcode] \u00b6 La commande suivante est activ\u00e9e si une section de configuration delayed_gcode a \u00e9t\u00e9 activ\u00e9e (voir \u00e9galement le guide des mod\u00e8les ). UPDATE_DELAYED_GCODE \u00b6 UPDATE_DELAYED_GCODE [ID=<nom>] [DURATION=<secondes>] : Met \u00e0 jour la dur\u00e9e du retard du [delayed_gcode] identifi\u00e9 et d\u00e9marre le minuteur pour l'ex\u00e9cution du gcode. Une valeur de 0 annulera l'ex\u00e9cution d'un gcode retard\u00e9 en attente. [delta_calibrate] \u00b6 Les commandes suivantes sont disponibles lorsque la section delta_calibrate config est activ\u00e9e (voir \u00e9galement le guide delta calibrate ). DELTA_CALIBRATE \u00b6 DELTA_CALIBRATE [METHOD=manual] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] : Cette commande sondera sept points sur le lit et recommandera des positions de but\u00e9es de fin de course, des angles des tours et un rayon. Voir la commande PROBE pour plus de d\u00e9tails sur les param\u00e8tres de sonde facultatifs. Si METHOD=manual est sp\u00e9cifi\u00e9, l'outil de sondage manuel est activ\u00e9 - voir la commande MANUAL_PROBE ci-dessus pour plus de d\u00e9tails sur les commandes suppl\u00e9mentaires disponibles lorsque cet outil est actif. La valeur facultative HORIZONTAL_MOVE_Z remplace l'option horizontal_move_z sp\u00e9cifi\u00e9e dans le fichier de configuration. DELTA_ANALYZE \u00b6 DELTA_ANALYZE : Cette commande est utilis\u00e9e pendant l'\u00e9talonnage delta am\u00e9lior\u00e9. Voir Calibrage delta pour plus de d\u00e9tails. [display] \u00b6 La commande suivante est disponible lorsqu'une section display config est activ\u00e9e. SET_DISPLAY_GROUP \u00b6 SET_DISPLAY_GROUP [DISPLAY=<display>] GROUP=<group> : D\u00e9finit le groupe d'affichage actif d'un \u00e9cran LCD. Cela permet de d\u00e9finir plusieurs groupes de donn\u00e9es d'affichage dans la configuration, par exemple [display_data <group> <elementname>] et de passer de l'un \u00e0 l'autre en utilisant cette commande gcode \u00e9tendue. Si DISPLAY n'est pas sp\u00e9cifi\u00e9, la valeur par d\u00e9faut est \"display\" (l'affichage principal). [display_status] \u00b6 Le module display_status est automatiquement charg\u00e9 si une section display config est activ\u00e9e. Il fournit les commandes G-Code standard suivantes : Afficher un message : M117 <message> D\u00e9finir le pourcentage de g\u00e9n\u00e9ration : M73 P<pourcentage> La commande G-Code \u00e9tendue suivante est \u00e9galement fournie : SET_DISPLAY_TEXT MSG=<message> : Effectue l'\u00e9quivalent de M117, en d\u00e9finissant le MSG fourni comme le message d'affichage actuel. Si MSG est omis, l'affichage est effac\u00e9. [dual_carriage] \u00b6 La commande suivante est disponible lorsque la section config dual_carriage est activ\u00e9e. SET_DUAL_CARRIAGE \u00b6 SET_DUAL_CARRIAGE CARRIAGE=[0|1] [MODE=[PRIMARY|COPY|MIRROR]] : This command will change the mode of the specified carriage. If no MODE is provided it defaults to PRIMARY . Setting the mode to PRIMARY deactivates the other carriage and makes the specified carriage execute subsequent G-Code commands as-is. COPY and MIRROR modes are supported only for CARRIAGE=1 . When set to either of these modes, carriage 1 will then track the subsequent moves of the carriage 0 and either copy relative movements of it (in COPY mode) or execute them in the opposite (mirror) direction (in MIRROR mode). SAVE_DUAL_CARRIAGE_STATE \u00b6 SAVE_DUAL_CARRIAGE_STATE [NAME=<state_name>] : Save the current positions of the dual carriages and their modes. Saving and restoring DUAL_CARRIAGE state can be useful in scripts and macros, as well as in homing routine overrides. If NAME is provided it allows one to name the saved state to the given string. If NAME is not provided it defaults to \"default\". RESTORE_DUAL_CARRIAGE_STATE \u00b6 RESTORE_DUAL_CARRIAGE_STATE [NAME=<state_name>] [MOVE=[0|1] [MOVE_SPEED=<speed>]] : Restore the previously saved positions of the dual carriages and their modes, unless \"MOVE=0\" is specified, in which case only the saved modes will be restored, but not the positions of the carriages. If positions are being restored and \"MOVE_SPEED\" is specified, then the toolhead moves will be performed with the given speed (in mm/s); otherwise the toolhead move will use the rail homing speed. Note that the carriages restore their positions only over their own axis, which may be necessary to correctly restore COPY and MIRROR mode of the dual carraige. [endstop_phase] \u00b6 Les commandes suivantes sont disponibles lorsqu'une section de configuration endstop_phase est activ\u00e9e (voir \u00e9galement le guide de la phase d'arr\u00eat ). ENDSTOP_PHASE_CALIBRATE \u00b6 ENDSTOP_PHASE_CALIBRATE [STEPPER=<config_name>] : Si aucun param\u00e8tre STEPPER n'est fourni, cette commande rapporte des statistiques sur les phases d'arr\u00eat du stepper pendant les pr\u00e9c\u00e9dentes op\u00e9rations de recherche d'origine. Lorsqu'un param\u00e8tre STEPPER est fourni, elle fait en sorte que le param\u00e8tre de phase de fin de course donn\u00e9 soit \u00e9crit dans le fichier de configuration (en lien avec la commande SAVE_CONFIG). [exclude_object] \u00b6 Les commandes suivantes sont disponibles lorsqu'une section de configuration exclude_object est activ\u00e9e (voir \u00e9galement le guide d'exclusion d'objet ) : EXCLUDE_OBJECT \u00b6 EXCLUDE_OBJECT [NAME=nom_objet] [CURRENT=1] [RESET=1] : Sans param\u00e8tres, cette commande renvoie une liste de tous les objets actuellement exclus. Lorsque le param\u00e8tre NAME est donn\u00e9, l'objet nomm\u00e9 sera exclu de l'impression. Lorsque le param\u00e8tre CURRENT est donn\u00e9, l'objet courant sera exclu de l'impression. Lorsque le param\u00e8tre RESET est donn\u00e9, la liste des objets exclus sera effac\u00e9e. De plus, inclure le param\u00e8tre NAME ne r\u00e9initialisera que l'objet nomm\u00e9. Cela peut provoquer des \u00e9checs d'impression, si des couches ont d\u00e9j\u00e0 \u00e9t\u00e9 omises. EXCLUDE_OBJECT_DEFINE \u00b6 EXCLUDE_OBJECT_DEFINE [NAME=nom_objet [CENTER=X,Y] [POLYGON=[[x,y],...]]] [RESET=1] [JSON=1] : Fournit le r\u00e9sum\u00e9 d'un objet dans le fichier. Sans param\u00e8tres fournis, ceci va lister les objets d\u00e9finis connus de Klipper. Retourne une liste de cha\u00eenes de caract\u00e8res, \u00e0 moins que le param\u00e8tre JSON soit donn\u00e9, auquel cas retournera les d\u00e9tails de l'objet au format json. Lorsque le param\u00e8tre NAME est inclus, cela d\u00e9finit un objet \u00e0 exclure. NAME : Ce param\u00e8tre est obligatoire. Il s'agit de l'identifiant utilis\u00e9 par les autres commandes de ce module. CENTER : Une coordonn\u00e9e X,Y pour l'objet. POLYGON : Un tableau de coordonn\u00e9es X,Y fournissant le contour d'un objet. Lorsque le param\u00e8tre RESET est fourni, tous les objets d\u00e9finis seront effac\u00e9s, et le module [exclude_object] sera r\u00e9initialis\u00e9. EXCLUDE_OBJECT_START \u00b6 EXCLUDE_OBJECT_START NAME=nom_objet : Cette commande prend un param\u00e8tre NAME et indique le d\u00e9but du gcode pour un objet sur la couche courante. EXCLUDE_OBJECT_END \u00b6 EXCLUDE_OBJECT_END [NAME=nom_objet] : Indique la fin du gcode de l'objet pour la couche. Il est associ\u00e9 \u00e0 EXCLUDE_OBJECT_START . Le param\u00e8tre NAME est optionnel, et n'avertira que si le nom fourni ne correspond au nom actuel. [extruder] \u00b6 Les commandes suivantes sont disponibles si une section configuration de l'extrudeuse est activ\u00e9e : ACTIVATE_EXTRUDER \u00b6 ACTIVATE_EXTRUDER EXTRUDER=<nom_de_la_configuration> : Dans une imprimante comportant plusieurs sections de configuration d' extrudeuse , cette commande s\u00e9lectionne la t\u00eate d'outil active. SET_PRESSURE_ADVANCE \u00b6 SET_PRESSURE_ADVANCE [EXTRUDER=<nom_de_la_configuration>] [ADVANCE=<avance_de_pression>] [SMOOTH_TIME=<dur\u00e9e_adoucissemt_avance_de_pression>] : D\u00e9finit les param\u00e8tres d'avance de pression du moteur d'extrudeuse (comme d\u00e9fini dans une section de configuration extrudeur ou extruder_stepper ). Si EXTRUDER n'est pas sp\u00e9cifi\u00e9, il s'agit par d\u00e9faut du stepper d\u00e9fini dans la t\u00eate d'outil active. SET_EXTRUDER_ROTATION_DISTANCE \u00b6 SET_EXTRUDER_ROTATION_DISTANCE EXTRUDER=<nom_config> [DISTANCE=<distance>] : D\u00e9finit une nouvelle valeur pour la \"distance de rotation\" du moteur de l'extrudeuse fournie (telle que d\u00e9finie dans une section de configuration extruder ou extruder_stepper ). Si la distance de rotation est un nombre n\u00e9gatif, le mouvement du moteur sera invers\u00e9 (par rapport \u00e0 la direction du moteur sp\u00e9cifi\u00e9e dans le fichier de configuration). Les param\u00e8tres modifi\u00e9s ne sont pas conserv\u00e9s lors de la r\u00e9initialisation de Klipper. Utilisez avec pr\u00e9caution car de petites modifications peuvent entra\u00eener une pression excessive entre l'extrudeuse et la t\u00eate de l'outil. Effectuez un calibrage correct avec le filament avant de l'utiliser. Si la valeur 'DISTANCE' n'est pas fournie, cette commande renvoie la distance de rotation actuelle. SYNC_EXTRUDER_MOTION \u00b6 SYNC_EXTRUDER_MOTION EXTRUDER=<nom> MOTION_QUEUE=<nom> : Cette commande permet de synchroniser le moteur d'entra\u00eenement sp\u00e9cifi\u00e9 par EXTRUDER (tel que d\u00e9fini dans la section de configuration extruder ou extruder_stepper avec le mouvement d'un extrudeur sp\u00e9cifi\u00e9 par MOTION_QUEUE (tel que d\u00e9fini dans la section de configuration extruder ). Si MOTION_QUEUE est une cha\u00eene vide, le stepper sera d\u00e9synchronis\u00e9 de tout mouvement d'extrudeuse. SET_EXTRUDER_STEP_DISTANCE \u00b6 Cette commande est obsol\u00e8te et sera supprim\u00e9e dans un avenir proche. SYNC_STEPPER_TO_EXTRUDER \u00b6 Cette commande est obsol\u00e8te et sera supprim\u00e9e dans un avenir proche. [fan_generic] \u00b6 La commande suivante est disponible lorsqu'une section fan_generic config est activ\u00e9e. SET_FAN_SPEED \u00b6 SET_FAN_SPEED FAN=nom_config SPEED=<vitesse> Cette commande d\u00e9finit la vitesse d'un ventilateur. La valeur de \"vitesse\" doit \u00eatre comprise entre 0,0 et 1,0. [filament_switch_sensor] \u00b6 La commande suivante est disponible lorsqu'une section de configuration filament_switch_sensor ou filament_motion_sensor est activ\u00e9e. QUERY_FILAMENT_SENSOR \u00b6 QUERY_FILAMENT_SENSOR SENSOR=<nom_du_capteur> : Interroge l'\u00e9tat actuel du capteur de filament. Les donn\u00e9es affich\u00e9es sur le terminal d\u00e9pendront du type de capteur d\u00e9fini dans la configuration. SET_FILAMENT_SENSOR \u00b6 SET_FILAMENT_SENSOR SENSOR=<nom_du_capteur> ENABLE=[0|1] : Active/d\u00e9sactive le d\u00e9tecteur de filament. Si ENABLE est r\u00e9gl\u00e9 sur 0, le d\u00e9tecteur de filament est d\u00e9sactiv\u00e9, s'il est r\u00e9gl\u00e9 sur 1, il est activ\u00e9. [firmware_retraction] \u00b6 Les commandes G-Code standard suivantes sont disponibles lorsque la section de configuration firmware_retraction est activ\u00e9e. Ces commandes vous permettent d'utiliser la fonction de r\u00e9traction du micrologiciel disponible dans de nombreux trancheurs, afin de r\u00e9duire le cordage pendant les d\u00e9placements sans extrusion d'une partie de l'impression \u00e0 une autre. Une configuration appropri\u00e9e de l'avance \u00e0 la pression r\u00e9duit la longueur de r\u00e9traction requise. G10 : R\u00e9tracte l'extrudeur en utilisant les param\u00e8tres actuellement configur\u00e9s. G11 : D\u00e9tache l'extrudeur en utilisant les param\u00e8tres actuellement configur\u00e9s. Les commandes suppl\u00e9mentaires suivantes sont \u00e9galement disponibles. SET_RETRACTION \u00b6 SET_RETRACTION [RETRACT_LENGTH=<mm>] [RETRACT_SPEED=<mm/s>] [UNRETRACT_EXTRA_LENGTH=<mm>] [UNRETRACT_SPEED=<mm/s>] : Ajuste les param\u00e8tres utilis\u00e9s par la r\u00e9traction du micrologiciel. RETRACT_LENGTH d\u00e9termine la longueur de filament \u00e0 r\u00e9tracter et \u00e0 d\u00e9r\u00e9tracter. La vitesse de r\u00e9traction est ajust\u00e9e via RETRACT_SPEED, et est g\u00e9n\u00e9ralement r\u00e9gl\u00e9e relativement haut. La vitesse de d\u00e9stratification est ajust\u00e9e via UNRETRACT_SPEED, et n'est pas particuli\u00e8rement critique, bien que souvent inf\u00e9rieure \u00e0 RETRACT_SPEED. Dans certains cas, il est utile d'ajouter une petite quantit\u00e9 de longueur suppl\u00e9mentaire lors de la d\u00e9r\u00e9traction, et ceci est r\u00e9gl\u00e9 via UNRETRACT_EXTRA_LENGTH. SET_RETRACTION est g\u00e9n\u00e9ralement d\u00e9fini dans le cadre de la configuration du slicer par filament, car les diff\u00e9rents filaments n\u00e9cessitent des param\u00e8tres diff\u00e9rents. GET_RETRACTION \u00b6 GET_RETRACTION : Interroge les param\u00e8tres actuellement utilis\u00e9s pour la r\u00e9traction du firmware et les affiche sur le terminal. [force_move] \u00b6 Le module force_move est automatiquement charg\u00e9, mais certaines commandes n\u00e9cessitent de d\u00e9finir enable_force_move dans la configuration de l'imprimante . STEPPER_BUZZ \u00b6 STEPPER_BUZZ STEPPER=<nom_de_la_configuration> : D\u00e9place le moteur donn\u00e9 en avant d'un mm puis en arri\u00e8re d'un mm, r\u00e9p\u00e9t\u00e9 10 fois. Il s'agit d'un outil de diagnostic permettant de v\u00e9rifier la connectivit\u00e9 du moteur. FORCE_MOVE \u00b6 FORCE_MOVE STEPPER=<nom_de_la_configuration> DISTANCE=<valeur> VELOCITE=<valeur> [ACCEL=<valeur>] : Cette commande forcera le d\u00e9placement du stepper donn\u00e9 sur la distance donn\u00e9e (en mm) \u00e0 la vitesse constante donn\u00e9e (en mm/s). Si ACCEL est sp\u00e9cifi\u00e9 et est sup\u00e9rieur \u00e0 z\u00e9ro, alors l'acc\u00e9l\u00e9ration donn\u00e9e (en mm/s^2) sera utilis\u00e9e ; sinon, aucune acc\u00e9l\u00e9ration n'est effectu\u00e9e. Aucune v\u00e9rification des limites n'est effectu\u00e9e ; aucune mise \u00e0 jour cin\u00e9matique n'est faite ; les autres steppers parall\u00e8les sur un axe ne seront pas d\u00e9plac\u00e9s. Soyez prudent car une commande incorrecte pourrait endommager le mat\u00e9riel ! L'utilisation de cette commande placera presque certainement la cin\u00e9matique de bas niveau dans un \u00e9tat incorrect ; \u00e9mettez ensuite un G28 pour r\u00e9initialiser la cin\u00e9matique. Cette commande est destin\u00e9e aux diagnostics de bas niveau et au d\u00e9bogage. SET_KINEMATIC_POSITION \u00b6 SET_KINEMATIC_POSITION [X=<value>] [Y=<value>] [Z=<value>] : Force le code cin\u00e9matique de bas niveau \u00e0 croire que la t\u00eate d'outil est \u00e0 la position cart\u00e9sienne donn\u00e9e. Il s'agit d'une commande de diagnostic et de d\u00e9bogage ; utilisez SET_GCODE_OFFSET et/ou G92 pour des transformations d'axe r\u00e9guli\u00e8res. Si un axe n'est pas sp\u00e9cifi\u00e9, la position par d\u00e9faut sera celle de la derni\u00e8re commande de la t\u00eate. La d\u00e9finition d'une position incorrecte ou invalide peut entra\u00eener des erreurs logicielles internes. Cette commande peut invalider les futures v\u00e9rifications de limites ; \u00e9mettez ensuite un G28 pour r\u00e9initialiser la cin\u00e9matique. [gcode] \u00b6 Le module gcode est automatiquement charg\u00e9. RESTART \u00b6 RESTART : Cette commande permet au logiciel h\u00f4te de recharger sa configuration et d'effectuer une r\u00e9initialisation interne. Cette commande n'efface pas l'\u00e9tat d'erreur du micro-contr\u00f4leur (voir FIRMWARE_RESTART) et ne charge pas de nouveau logiciel (voir la FAQ ). FIRMWARE_RESTART \u00b6 FIRMWARE_RESTART : Cette commande est similaire \u00e0 un RESTART, mais elle efface \u00e9galement tout \u00e9tat d'erreur du micro-contr\u00f4leur. STATUS \u00b6 STATUS : Indique l'\u00e9tat du logiciel de l'h\u00f4te Klipper. HELP \u00b6 HELP : Affiche la liste des commandes G-Code \u00e9tendues disponibles. [gcode_arcs] \u00b6 Les commandes G-Code standard suivantes sont disponibles si une section gcode_arcs config est activ\u00e9e : D\u00e9placement d'un arc dans le sens des aiguilles d'une montre (G2), d\u00e9placement d'un arc dans le sens inverse des aiguilles d'une montre (G3) : G2|G3 [X<pos>] [Y<pos>] [Z<pos>] [E<pos>] [F<speed>] I<value> J<value>|I<value> K<value>|J<value> K<value> S\u00e9lection du plan de l'arc : G17 (plan XY), G18 (plan XZ), G19 (plan YZ) [gcode_macro] \u00b6 La commande suivante est disponible lorsqu'une section de configuration gcode_macro est activ\u00e9e (voir \u00e9galement le guide des mod\u00e8les de commande ). SET_GCODE_VARIABLE \u00b6 SET_GCODE_VARIABLE MACRO=<macro_name> VARIABLE=<name> VALUE=<value> : Cette commande permet de changer la valeur d'une variable gcode_macro au moment de l'ex\u00e9cution. La valeur fournie est analys\u00e9e comme un litt\u00e9ral Python. [gcode_move] \u00b6 Le module gcode_move est automatiquement charg\u00e9. GET_POSITION \u00b6 GET_POSITION : Retourne les informations de l'emplacement actuel de la t\u00eate d'outil. Voir la documentation du d\u00e9veloppeur de restitution de GET_POSITION pour plus d'informations. SET_GCODE_OFFSET \u00b6 SET_GCODE_OFFSET [X=<pos>|X_ADJUST=<adjust>] [Y=<pos>|Y_ADJUST=<adjust>] [Z=<pos>|Z_ADJUST=<adjust>] [MOVE=1 [MOVE_SPEED=<speed>]] : D\u00e9finit un d\u00e9calage positionnel \u00e0 appliquer aux futures commandes G-Code. Ceci est g\u00e9n\u00e9ralement utilis\u00e9 pour changer virtuellement le d\u00e9calage Z du bed ou pour d\u00e9finir les d\u00e9calages XY des buses lors du changement d'extrudeur. Par exemple, si \"SET_GCODE_OFFSET Z=0.2\" est donn\u00e9, les prochains mouvements G-Code auront 0,2mm ajout\u00e9 \u00e0 leur hauteur Z. Si les param\u00e8tres de style X_ADJUST sont utilis\u00e9s, l'ajustement sera ajout\u00e9 \u00e0 tout d\u00e9calage existant (par exemple, \"SET_GCODE_OFFSET Z=-0.2\" suivi de \"SET_GCODE_OFFSET Z_ADJUST=0.3\" donnerait un d\u00e9calage Z total de 0.1). Si \"MOVE=1\" est sp\u00e9cifi\u00e9, un d\u00e9placement de la t\u00eate d'outil sera effectu\u00e9 pour appliquer le d\u00e9calage donn\u00e9 (sinon le d\u00e9calage prendra effet lors du prochain d\u00e9placement absolu en G-code qui sp\u00e9cifie l'axe donn\u00e9). Si \"MOVE_SPEED\" est sp\u00e9cifi\u00e9, le d\u00e9placement de la t\u00eate d'outil sera effectu\u00e9 avec la vitesse donn\u00e9e (en mm/s) ; sinon, le d\u00e9placement de la t\u00eate d'outil utilisera la derni\u00e8re vitesse G-Code sp\u00e9cifi\u00e9e. SAVE_GCODE_STATE \u00b6 SAVE_GCODE_STATE [NAME=<nom_de_l'\u00e9tat>] : Sauvegarde l'\u00e9tat actuel de l'analyse des coordonn\u00e9es du g-code. La sauvegarde et le r\u00e9tablissement de l'\u00e9tat du g-code sont utiles dans les scripts et les macros. Cette commande enregistre le mode actuel de coordonn\u00e9es absolues en g-code (G90/G91), le mode d'extrusion absolue (M82/M83), l'origine (G92), le d\u00e9calage (SET_GCODE_OFFSET), la priorit\u00e9 de vitesse (M220), la priorit\u00e9 d'extrusion (M221), la vitesse de d\u00e9placement, la position XYZ actuelle et la position relative de l'extrudeuse \"E\". Si NOM est fourni, cela permet de nommer l'\u00e9tat sauvegard\u00e9 avec la cha\u00eene de caract\u00e8res donn\u00e9e. Si le NOM n'est pas fourni, la valeur par d\u00e9faut est \"default\". RESTORE_GCODE_STATE \u00b6 RESTORE_GCODE_STATE [NAME=<nom_de_l'\u00e9tat>] [MOVE=1 [MOVE_SPEED=<speed>]] : Restaure un \u00e9tat pr\u00e9c\u00e9demment sauvegard\u00e9 via SAVE_GCODE_STATE. Si \"MOVE=1\" est sp\u00e9cifi\u00e9, un d\u00e9placement de la t\u00eate d'outil sera effectu\u00e9 pour revenir \u00e0 la position XYZ pr\u00e9c\u00e9dente. Si \"MOVE_SPEED\" est sp\u00e9cifi\u00e9, alors le d\u00e9placement de la t\u00eate d'outil sera effectu\u00e9 avec la vitesse donn\u00e9e (en mm/s) ; sinon, le d\u00e9placement de la t\u00eate d'outil utilisera la vitesse du G-Code restaur\u00e9. [hall_filament_width_sensor] \u00b6 Les commandes suivantes sont disponibles lorsque la section de configuration tsl1401cl filament width sensor ou hall filament width sensor est activ\u00e9e (voir \u00e9galement TSLl401CL Filament Width Sensor et Hall Filament Width Sensor ) : QUERY_FILAMENT_WIDTH \u00b6 QUERY_FILAMENT_WIDTH : Renvoie la largeur actuelle du filament mesur\u00e9. RESET_FILAMENT_WIDTH_SENSOR \u00b6 RESET_FILAMENT_WIDTH_SENSOR : Efface toutes les lectures du capteur. Utile apr\u00e8s un changement de filament. DISABLE_FILAMENT_WIDTH_SENSOR \u00b6 DISABLE_FILAMENT_WIDTH_SENSOR : D\u00e9sactiver le capteur de largeur de filament et arr\u00eater de l'utiliser pour le contr\u00f4le du flux. ENABLE_FILAMENT_WIDTH_SENSOR \u00b6 ENABLE_FILAMENT_WIDTH_SENSOR : Activez le capteur de largeur de filament et commencez \u00e0 l'utiliser pour le contr\u00f4le du flux. QUERY_RAW_FILAMENT_WIDTH \u00b6 QUERY_RAW_FILAMENT_WIDTH : Renvoie les lectures actuelles des canaux ADC et la valeur RAW du capteur des points de calibration. ENABLE_FILAMENT_WIDTH_LOG \u00b6 ENABLE_FILAMENT_WIDTH_LOG : Activer la journalisation du diam\u00e8tre. DISABLE_FILAMENT_WIDTH_LOG \u00b6 DISABLE_FILAMENT_WIDTH_LOG : D\u00e9sactiver la journalisation du diam\u00e8tre. [heaters] \u00b6 Le module chauffages est automatiquement charg\u00e9 si un chauffage est d\u00e9fini dans le fichier de configuration. TURN_OFF_HEATERS \u00b6 TURN_OFF_HEATERS : \u00c9teindre tous les chauffages. TEMPERATURE_WAIT \u00b6 TEMPERATURE_WAIT SENSOR=<nom_config> [MINIMUM=<cible>] [MAXIMUM=<cible>] : Attend jusqu'\u00e0 ce que le capteur de temp\u00e9rature donn\u00e9 soit \u00e0 ou au-dessus du MINIMUM fourni et/ou \u00e0 ou en dessous du MAXIMUM fourni. SET_HEATER_TEMPERATURE \u00b6 SET_HEATER_TEMPERATURE HEATER=<nom_du_chauffeur> [TARGET=<temp\u00e9rature_cible>] : D\u00e9finit la temp\u00e9rature cible d'un \u00e9l\u00e9ment chauffant. Si une temp\u00e9rature cible n'est pas fournie, la cible est 0. [idle_timeout] \u00b6 Le module idle_timeout est automatiquement charg\u00e9. SET_IDLE_TIMEOUT \u00b6 SET_IDLE_TIMEOUT [TIMEOUT=<timeout>] : Permet \u00e0 l'utilisateur de d\u00e9finir le d\u00e9lai d'inactivit\u00e9 (en secondes). [input_shaper] \u00b6 La commande suivante est activ\u00e9e si une section de configuration input_shaper a \u00e9t\u00e9 activ\u00e9e (voir \u00e9galement le guide de compensation de r\u00e9sonance ). SET_INPUT_SHAPER \u00b6 SET_INPUT_SHAPER [SHAPER_FREQ_X=<shaper_freq_x>] [SHAPER_FREQ_Y=<shaper_freq_y>] [DAMPING_RATIO_X=<damping_ratio_x>] [DAMPING_RATIO_Y=<damping_ratio_y>] [SHAPER_TYPE=<shaper>] [SHAPER_TYPE_X=<shaper_type_x>] [SHAPER_TYPE_Y=<shaper_type_y>] : Modifie les param\u00e8tres de mise en forme d'entr\u00e9e. Notez que le param\u00e8tre SHAPER_TYPE r\u00e9initialise le shaper d'entr\u00e9e pour les axes X et Y m\u00eame si diff\u00e9rents types de shaper ont \u00e9t\u00e9 configur\u00e9s dans la section [input_shaper]. SHAPER_TYPE ne peut pas \u00eatre utilis\u00e9 avec l'un des param\u00e8tres SHAPER_TYPE_X et SHAPER_TYPE_Y. Voir config reference pour plus de d\u00e9tails sur chacun de ces param\u00e8tres. [manual_probe] \u00b6 Le module manual_probe est automatiquement charg\u00e9. MANUAL_PROBE \u00b6 MANUAL_PROBE [SPEED=<speed>] : Ex\u00e9cute un script d'aide servant \u00e0 mesurer la hauteur de la buse \u00e0 un point donn\u00e9. Si SPEED est sp\u00e9cifi\u00e9, il d\u00e9finit la vitesse des commandes TESTZ (la valeur par d\u00e9faut est 5mm/s). Pendant un sondage manuel, les commandes suppl\u00e9mentaires suivantes sont disponibles : ACCEPT : Cette commande valide la position Z actuelle et met fin au sondage manuel. ABORT : Cette commande interrompt le sondage manuel. TESTZ Z=<valeur> : Cette commande d\u00e9place la buse vers le haut ou vers le bas de la quantit\u00e9 sp\u00e9cifi\u00e9e dans \"valeur\". Par exemple, TESTZ Z=-.1 d\u00e9placera la buse vers le bas de 0,1mm tandis que TESTZ Z=.1 d\u00e9placera la buse vers le haut de 0,1mm. La valeur peut \u00e9galement \u00eatre + , - , ++ , ou -- pour d\u00e9placer la buse vers le haut ou vers le bas d'une quantit\u00e9 relative aux tentatives pr\u00e9c\u00e9dentes. Z_ENDSTOP_CALIBRATE \u00b6 Z_ENDSTOP_CALIBRATE [SPEED=<vitesse>] : Ex\u00e9cute un script d'assistance utile pour calibrer un param\u00e8tre de configuration de la position Z_endstop. Voir la commande MANUAL_PROBE pour plus de d\u00e9tails sur les param\u00e8tres et les commandes suppl\u00e9mentaires disponibles lorsque l'outil est actif. Z_OFFSET_APPLY_ENDSTOP \u00b6 Z_OFFSET_APPLY_ENDSTOP : Prend le d\u00e9calage actuel du Gcode Z (alias, babystepping), et le soustrait de la position endstop_position d\u00e9finie dans stepper_z. Ceci permet de prendre une valeur de babystepping fr\u00e9quemment utilis\u00e9e, et de la rendre permanente. N\u00e9cessite un SAVE_CONFIG pour prendre effet. [manual_stepper] \u00b6 La commande suivante est disponible lorsqu'une section manual_stepper config est activ\u00e9e. MANUAL_STEPPER \u00b6 MANUAL_STEPPER STEPPER=nom_du_config [ENABLE=[0|1]]] [SET_POSITION=<pos>] [SPEED=<speed>] [ACCEL=<accel>] [MOVE=<pos> [STOP_ON_ENDSTOP=[1|2|-1|-2]] [SYNC=0]] : Cette commande modifie l'\u00e9tat du stepper. Utilisez le param\u00e8tre ENABLE pour activer/d\u00e9sactiver le stepper. Utilisez le param\u00e8tre SET_POSITION pour forcer le moteur pas \u00e0 pas \u00e0 penser qu'il se trouve \u00e0 la position donn\u00e9e. Utilisez le param\u00e8tre MOVE pour d\u00e9placer vers la position donn\u00e9e. Si SPEED et/ou ACCEL sont sp\u00e9cifi\u00e9s, les valeurs donn\u00e9es seront utilis\u00e9es \u00e0 la place de celles par d\u00e9faut issues du fichier de configuration. Si un ACCEL de z\u00e9ro est sp\u00e9cifi\u00e9, aucune acc\u00e9l\u00e9ration ne sera effectu\u00e9e. Si STOP_ON_ENDSTOP=1 est sp\u00e9cifi\u00e9, le d\u00e9placement se terminera pr\u00e9matur\u00e9ment si la fin de course est d\u00e9clench\u00e9e (utilisez STOP_ON_ENDSTOP=2 pour terminer le d\u00e9placement sans erreur m\u00eame si la fin de course n'est pas d\u00e9clench\u00e9e, utilisez -1 ou -2 pour s'arr\u00eater lorsque la fin de course n'est pas d\u00e9clench\u00e9e). Normalement, les futures commandes G-Code seront programm\u00e9es pour \u00eatre ex\u00e9cut\u00e9es apr\u00e8s la fin du d\u00e9placement de la commande de pas, mais si un d\u00e9placement manuel de la commande de pas utilise SYNC=0, les futures commandes de d\u00e9placement G-Code peuvent \u00eatre ex\u00e9cut\u00e9es en parall\u00e8le avec le d\u00e9placement de la commande de pas. [mcp4018] \u00b6 La commande suivante est disponible lorsqu'une section mcp4018 config est activ\u00e9e. SET_DIGIPOT \u00b6 SET_DIGIPOT DIGIPOT=config_name WIPER=<valeur> : Cette commande change la valeur actuelle du digipot. Cette valeur devrait typiquement \u00eatre comprise entre 0.0 et 1.0, \u00e0 moins qu'une '\u00e9chelle' soit d\u00e9finie dans la configuration. Lorsque 'scale' est d\u00e9fini, alors cette valeur doit \u00eatre comprise entre 0.0 et 'scale'. [led] \u00b6 La commande suivante est disponible lorsque l'une des sections led config est activ\u00e9e. SET_LED \u00b6 SET_LED LED=<nom_de_la_configuration> RED=<valeur> GREEN=<valeur> BLUE=<valeur> WHITE=<valeur> [INDEX=<index>] [TRANSMIT=0] [SYNC=1] : Ceci d\u00e9finit la sortie de la LED. Chaque <valeur> de couleur doit \u00eatre comprise entre 0.0 et 1.0. L'option WHITE n'est valable que pour les LEDs RGBW. Si la LED supporte plusieurs puces dans une cha\u00eene, on peut sp\u00e9cifier INDEX pour modifier la couleur de la seule puce donn\u00e9e (1 pour la premi\u00e8re puce, 2 pour la seconde, etc.). Si INDEX n'est pas sp\u00e9cifi\u00e9, alors toutes les LEDs de la cha\u00eene seront r\u00e9gl\u00e9es sur la couleur fournie. Si TRANSMIT=0 est sp\u00e9cifi\u00e9, le changement de couleur ne sera effectu\u00e9 que lors de la prochaine commande SET_LED qui ne sp\u00e9cifie pas TRANSMIT=0 ; cela peut \u00eatre utile en combinaison avec le param\u00e8tre INDEX pour effectuer plusieurs mises \u00e0 jour dans une cha\u00eene. Par d\u00e9faut, la commande SET_LED synchronisera ses changements avec les autres commandes gcode en cours. Cela peut conduire \u00e0 un comportement ind\u00e9sirable si les LEDs sont r\u00e9gl\u00e9es alors que l'imprimante n'imprime pas, car cela r\u00e9initialisera le d\u00e9lai d'inactivit\u00e9. Si un timing pr\u00e9cis n'est pas n\u00e9cessaire, le param\u00e8tre optionnel SYNC=0 peut \u00eatre sp\u00e9cifi\u00e9 pour appliquer les changements sans r\u00e9initialiser le d\u00e9lai d'inactivit\u00e9. SET_LED_TEMPLATE \u00b6 SET_LED_TEMPLATE LED=<nom_de_la_led> TEMPLATE=<nom_du_mod\u00e8le> [<param_x>=<literal>] [INDEX=<index>] : Attribue un mod\u00e8le d'affichage \u00e0 une LED donn\u00e9e. Par exemple, si l'on d\u00e9finit une section de configuration [display_template my_led_template] , on peut affecter TEMPLATE=my_led_template ici. Le mod\u00e8le d'affichage doit produire une cha\u00eene de caract\u00e8res s\u00e9par\u00e9e par des virgules contenant quatre nombres \u00e0 virgule flottante correspondant aux param\u00e8tres de couleur rouge, vert, bleu et blanc. Le mod\u00e8le sera continuellement \u00e9valu\u00e9 et la LED sera automatiquement r\u00e9gl\u00e9e sur les couleurs r\u00e9sultantes. On peut d\u00e9finir des param\u00e8tres display_template \u00e0 utiliser pendant l'\u00e9valuation du mod\u00e8le (les param\u00e8tres seront analys\u00e9s comme des litt\u00e9raux Python). Si INDEX n'est pas sp\u00e9cifi\u00e9, alors toutes les puces dans la cha\u00eene de la LED seront r\u00e9gl\u00e9es sur le mod\u00e8le, sinon seule la puce avec l'index donn\u00e9 sera mise \u00e0 jour. Si TEMPLATE est une cha\u00eene vide, cette commande effacera tout mod\u00e8le pr\u00e9c\u00e9dent assign\u00e9 \u00e0 la LED (on peut alors utiliser les commandes SET_LED pour g\u00e9rer les param\u00e8tres de couleur de la LED). [output_pin] \u00b6 La commande suivante est disponible lorsqu'une section output_pin config est activ\u00e9e. SET_PIN \u00b6 SET_PIN PIN=nom_config VALUE=<valeur> [CYCLE_TIME=<dur\u00e9e_du_cycle>] : Fixe la broche \u00e0 la sortie donn\u00e9e VALUE . VALUE doit \u00eatre 0 ou 1 pour les broches de sortie \"num\u00e9riques\". Pour les broches PWM, d\u00e9finissez une valeur entre 0.0 et 1.0, ou entre 0.0 et scale si une \u00e9chelle est configur\u00e9e dans la section output_pin config. Certaines broches (actuellement seulement les broches \"soft PWM\") supportent la d\u00e9finition d'un temps de cycle explicite en utilisant le param\u00e8tre CYCLE_TIME (sp\u00e9cifi\u00e9 en secondes). Notez que le param\u00e8tre CYCLE_TIME n'est pas stock\u00e9 entre les commandes SET_PIN (toute commande SET_PIN sans param\u00e8tre CYCLE_TIME explicite utilisera le cycle_time sp\u00e9cifi\u00e9 dans la section output_pin config). [palette2] \u00b6 Les commandes suivantes sont disponibles lorsque la section palette2 config est activ\u00e9e. Les impressions avec Palette fonctionnent en int\u00e9grant des OCodes (Omega Codes) sp\u00e9ciaux dans le fichier GCode : O1 ... O32 : Ces codes sont lus \u00e0 partir du flux GCode, trait\u00e9s par ce module et transmis au dispositif Palette 2. Les commandes suppl\u00e9mentaires suivantes sont \u00e9galement disponibles. PALETTE_CONNECT \u00b6 PALETTE_CONNECT : Cette commande initie la connexion avec Palette 2. PALETTE_DISCONNECT \u00b6 PALETTE_DISCONNECT : Cette commande permet de se d\u00e9connecter de Palette 2. PALETTE_CLEAR \u00b6 PALETTE_CLEAR : Cette commande demande \u00e0 Palette 2 de purger le filament de tous les chemins d'entr\u00e9e et de sortie. PALETTE_CUT \u00b6 PALETTE_CUT : Cette commande demande \u00e0 Palette 2 de couper le filament actuellement charg\u00e9 dans le noyau de jonction. PALETTE_SMART_LOAD \u00b6 PALETTE_SMART_LOAD : cette commande initialise la s\u00e9quence de chargement intelligente sur Palette 2. Le filament est charg\u00e9 automatiquement en l\u2019extrudant sur la distance calibr\u00e9e sur l\u2019appareil pour l\u2019imprimante, et l'indique \u00e0 Palette 2 une fois le chargement termin\u00e9. Cette commande revient \u00e0 appuyer sur Smart Load directement sur l\u2019\u00e9cran Palette 2 une fois l'insertion du filament faite. [pid_calibrate] \u00b6 Le module pid_calibrate est automatiquement charg\u00e9 si un chauffage est d\u00e9fini dans le fichier de configuration. PID_CALIBRATE \u00b6 PID_CALIBRATE HEATER=<config_name> TARGET=<temperature> [WRITE_FILE=1] : Effectuer un test d\u2019\u00e9talonnage PID. Le chauffage demand\u00e9 sera activ\u00e9 jusqu\u2019\u00e0 ce que la temp\u00e9rature d\u00e9finie soit atteinte, il s'\u00e9teindra et se rallumera durant plusieurs cycles. Si le param\u00e8tre WRITE_FILE est activ\u00e9, le fichier /tmp/heattest.txt sera cr\u00e9\u00e9 avec un journal de tous les \u00e9chantillons de temp\u00e9rature mesur\u00e9s pendant le test. [pause_resume] \u00b6 Les commandes suivantes sont disponibles lorsque la section pause_resume config est activ\u00e9e : PAUSE \u00b6 PAUSE : suspend l\u2019impression en cours. La position actuelle est enregistr\u00e9e pour reprendre lorsque demand\u00e9. RESUME \u00b6 RESUME [VELOCITY=<value>] : Reprend l'impression \u00e0 la suite d'une pause, en r\u00e9tablissant d'abord la position captur\u00e9e pr\u00e9c\u00e9demment. Le param\u00e8tre VELOCITY d\u00e9termine la vitesse \u00e0 laquelle l'outil doit revenir \u00e0 la position captur\u00e9e d'origine. CLEAR_PAUSE \u00b6 CLEAR_PAUSE : Supprime la mise en pause actuelle sans reprendre l'impression. Ceci est utile si l'on d\u00e9cide d'interrompre une impression apr\u00e8s une PAUSE. Il est recommand\u00e9 d'ajouter ceci \u00e0 votre gcode de d\u00e9marrage pour s'assurer que l'\u00e9tat de pause est r\u00e9initialis\u00e9 pour chaque impression. CANCEL_PRINT \u00b6 CANCEL_PRINT : Annule l'impression en cours. [print_stats] \u00b6 Le module print_stats est automatiquement charg\u00e9. SET_PRINT_STATS_INFO \u00b6 SET_PRINT_STATS_INFO [TOTAL_LAYER=<nombre_total_de_couches>] [CURRENT_LAYER= <couche_actuelle>] : Passe les informations du trancheur comme le nombre total de couches et celle actuellement en cours \u00e0 Klipper. Ajoutez SET_PRINT_STATS_INFO [TOTAL_LAYER=<nombre_total_de_couches>] \u00e0 votre section gcode de d\u00e9but du trancheur et SET_PRINT_STATS_INFO [CURRENT_LAYER= <couche_actuelle>] \u00e0 la section gcode de changement de couche pour passer les informations de couche de votre trancheur \u00e0 Klipper. [probe] \u00b6 Les commandes suivantes sont disponibles lorsqu'une section probe config ou bltouch config est activ\u00e9e (voir \u00e9galement le guide d'\u00e9talonnage de la sonde ). PROBE \u00b6 PROBE [PROBE_SPEED=<mm/s>] [LIFT_SPEED=<mm/s>] [SAMPLES=<count>] [SAMPLE_RETRACT_DIST=<mm>] [SAMPLES_TOLERANCE=<mm>] [SAMPLES_TOLERANCE_RETRIES=<count>] [SAMPLES_RESULT=median|average] : D\u00e9place la buse vers le bas jusqu'\u00e0 ce que le palpeur se d\u00e9clenche. Si l'un des param\u00e8tres facultatifs est fourni, il remplace son param\u00e8tre \u00e9quivalent dans la section configuration de la sonde . QUERY_PROBE \u00b6 QUERY_PROBE : Retourne l'\u00e9tat actuel de la sonde (\"triggered\" ou \"open\"). PROBE_ACCURACY \u00b6 PROBE_ACCURACY [PROBE_SPEED=<mm/s>] [SAMPLES=<count>] [SAMPLE_RETRACT_DIST=<mm>] : Calculer le maximum, le minimum, la moyenne, la m\u00e9diane et l\u2019\u00e9cart type des \u00e9chantillons des multiples palpeurs. Par d\u00e9faut, 10 \u00c9CHANTILLONS sont pr\u00e9lev\u00e9s. Sinon, les param\u00e8tres optionnels peuvent \u00eatre d\u00e9finis dans la section de configuration du palpeur. PROBE_CALIBRATE \u00b6 PROBE_CALIBRATE [SPEED=<speed>] [<probe_parameter>=<value>] : Ex\u00e9cute l'assistant servant \u00e0 calibrer le z_offset du palpeur. Consultez la commande PROBE pour plus d\u2019informations sur les param\u00e8tres optionnels du palpeur. Reportez-vous \u00e0 la commande MANUAL_PROBE pour plus d\u2019informations sur le param\u00e8tre SPEED et les commandes suppl\u00e9mentaires disponibles lorsque l'assistant est actif. Veuillez noter que la commande PROBE_CALIBRATE utilise la variable de vitesse pour se d\u00e9placer dans la direction XY ainsi que dans Z. Z_OFFSET_APPLY_PROBE \u00b6 Z_OFFSET_APPLY_PROBE : Prend le d\u00e9calage actuel du Gcode Z (alias, babystepping), et le soustrait du z_offset de la sonde. Cela permet de prendre une valeur de babystepping fr\u00e9quemment utilis\u00e9e, et de la rendre permanente. N\u00e9cessite un SAVE_CONFIG pour prendre effet. [query_adc] \u00b6 Le module query_adc est automatiquement charg\u00e9. QUERY_ADC \u00b6 QUERY_ADC [NAME=<nom_de_la_configuration>] [PULLUP=<valeur>] : Rapporte la derni\u00e8re valeur analogique re\u00e7ue pour une broche analogique donn\u00e9e. Si NAME n'est pas fourni, la liste des noms d'adc disponibles est retourn\u00e9e. Si PULLUP est fourni (comme une valeur en Ohms), la valeur analogique brute ainsi que la r\u00e9sistance \u00e9quivalente relative \u00e0 ce pullup est retourn\u00e9e. [query_endstops] \u00b6 Le module query_endstops est automatiquement charg\u00e9. Les commandes G-Code standard suivantes sont actuellement disponibles, mais leur utilisation n'est pas recommand\u00e9e : Obtenir le statut Fin de course : M119 (Utilisez QUERY_ENDSTOPS \u00e0 la place.) QUERY_ENDSTOPS \u00b6 QUERY_ENDSTOPS : Teste les but\u00e9es d'axe et indique si elles sont \"d\u00e9clench\u00e9es\" ou dans un \u00e9tat \"ouvert\". Cette commande est g\u00e9n\u00e9ralement utilis\u00e9e pour v\u00e9rifier qu'un butoir de fin de course fonctionne correctement. [resonance_tester] \u00b6 Les commandes suivantes sont disponibles lorsqu'une section configuration du testeur de r\u00e9sonances est activ\u00e9e (voir \u00e9galement le guide de mesure des r\u00e9sonances ). MEASURE_AXES_NOISE \u00b6 MEASURE_AXES_NOISE : Mesure et affiche le bruit pour tous les axes de toutes les puces acc\u00e9l\u00e9rom\u00e9triques activ\u00e9es. TEST_RESONANCES \u00b6 TEST_RESONANCES AXE=<axe> OUTPUT=<resonances,raw_data> [NOM=<nom>] [FREQ_START=<freq_min>] [FREQ_END=<freq_max>] [HZ_PER_SEC=<hz_par_sec>] [CHIPS=<nom_puce_adxl345>] [POINT=x,y,z] [INPUT_SHAPING=[<0:1>]] : Ex\u00e9cute le test de r\u00e9sonance dans tous les points de sonde configur\u00e9s pour l'\"axe\" demand\u00e9 et mesure l'acc\u00e9l\u00e9ration en utilisant les puces acc\u00e9l\u00e9rom\u00e9tres configur\u00e9es pour l'axe respectif. L'\"axe\" peut \u00eatre X ou Y, ou sp\u00e9cifier une direction arbitraire comme AXIS=dx,dy , o\u00f9 dx et dy sont des nombres \u00e0 virgule flottante d\u00e9finissant un vecteur de direction (par exemple, AXIS=X , AXIS=Y , ou AXIS=1,-1 pour d\u00e9finir une direction diagonale). Notez que AXIS=dx,dy et AXIS=-dx,-dy sont \u00e9quivalents. nom_puce_adxl345 peut \u00eatre une ou plusieurs puces adxl345 configur\u00e9es, d\u00e9limit\u00e9es par des virgules, par exemple CHIPS=\"adxl345, adxl345 rpi\" . Notez que le terme adxl345 peut \u00eatre omis pour les puces adxl345 nomm\u00e9es. Si POINT est indiqu\u00e9, il remplacera le(s) point(s) configur\u00e9(s) dans [resonance_tester] . Si INPUT_SHAPING=0 ou non d\u00e9fini (par d\u00e9faut), d\u00e9sactive la mise en forme de l'entr\u00e9e pour le test de r\u00e9sonance, car il n'est pas valide d'ex\u00e9cuter le test de r\u00e9sonance avec la mise en forme de l'entr\u00e9e active. Le param\u00e8tre OUTPUT consiste en une liste s\u00e9par\u00e9e par des virgules des sorties qui seront \u00e9crites. Si raw_data est demand\u00e9, alors les donn\u00e9es brutes de l'acc\u00e9l\u00e9rom\u00e8tre sont \u00e9crites dans un fichier ou une s\u00e9rie de fichiers /tmp/raw_data_<axe>_[<nom_puce>_][<point>_]<nom>.csv avec (la partie <point>_ du nom g\u00e9n\u00e9r\u00e9e seulement si plus d'un point de sonde est configur\u00e9 ou si POINT est sp\u00e9cifi\u00e9). Si resonances est sp\u00e9cifi\u00e9, la r\u00e9ponse en fr\u00e9quence est calcul\u00e9e (\u00e0 travers tous les points de sonde) et \u00e9crite dans le fichier /tmp/resonances_<axe>_<nom>.csv . S'il n'est pas d\u00e9fini, OUTPUT prend par d\u00e9faut la valeur de resonances , et NAME prend par d\u00e9faut la valeur de l'heure actuelle au format \"AAAAMMJJ_HHMMSS\". SHAPER_CALIBRATE \u00b6 SHAPER_CALIBRATE [AXIS=<axis>] [NAME=<name>] [FREQ_START=<min_freq>] [FREQ_END=<max_freq>] [HZ_PER_SEC=<hz_per_sec>] [CHIPS=<adxl345_chip_name>] [MAX_SMOOTHING=<max_smoothing>] : Similarly to TEST_RESONANCES , runs the resonance test as configured, and tries to find the optimal parameters for the input shaper for the requested axis (or both X and Y axes if AXIS parameter is unset). If MAX_SMOOTHING is unset, its value is taken from [resonance_tester] section, with the default being unset. See the Max smoothing of the measuring resonances guide for more information on the use of this feature. The results of the tuning are printed to the console, and the frequency responses and the different input shapers values are written to a CSV file(s) /tmp/calibration_data_<axis>_<name>.csv . Unless specified, NAME defaults to the current time in \"YYYYMMDD_HHMMSS\" format. Note that the suggested input shaper parameters can be persisted in the config by issuing SAVE_CONFIG command, and if [input_shaper] was already enabled previously, these parameters take effect immediately. [respond] \u00b6 Les commandes G-Code standard suivantes sont disponibles lorsque la section respond config est activ\u00e9e : M118 <message> : affiche le message pr\u00e9c\u00e9d\u00e9 du pr\u00e9fixe par d\u00e9faut configur\u00e9 (ou echo : si aucun pr\u00e9fixe n'est configur\u00e9). Les commandes suppl\u00e9mentaires suivantes sont \u00e9galement disponibles. RESPOND \u00b6 RESPOND MSG=\"<message>\" : Affiche le message pr\u00e9c\u00e9d\u00e9 du pr\u00e9fixe par d\u00e9faut configur\u00e9 (ou echo : si aucun pr\u00e9fixe n'est configur\u00e9). RESPOND TYPE=echo MSG=\"<message>\" : affiche le message pr\u00e9c\u00e9d\u00e9 par echo : . RESPOND TYPE=echo_no_space MSG=\"<message>\" : renvoie le message pr\u00e9c\u00e9d\u00e9 de echo: sans espace entre le pr\u00e9fixe et le message, utile pour la compatibilit\u00e9 avec certains plugins octoprint qui attendent un formatage tr\u00e8s sp\u00e9cifique. RESPOND TYPE=command MSG=\"<message>\" : renvoie le message pr\u00e9c\u00e9d\u00e9 de // . OctoPrint peut \u00eatre configur\u00e9 pour r\u00e9pondre \u00e0 ces messages (par exemple, RESPOND TYPE=command MSG=action:pause ). RESPOND TYPE=error MSG=\"<message>\" : affiche le message pr\u00e9c\u00e9d\u00e9 par !!! . RESPOND PREFIX=<prefix> MSG=\"<message>\" : renvoie le message pr\u00e9c\u00e9d\u00e9 de <prefix> . (Le param\u00e8tre PREFIX est prioritaire sur le param\u00e8tre TYPE ). [save_variables] \u00b6 La commande suivante est activ\u00e9e si une section save_variables config a \u00e9t\u00e9 activ\u00e9e. SAVE_VARIABLE \u00b6 SAVE_VARIABLE VARIABLE=<nom> VALUE=<valeur> : Enregistre la variable sur le disque afin qu'elle puisse \u00eatre utilis\u00e9e lors des red\u00e9marrages. Toutes les variables enregistr\u00e9es sont charg\u00e9es dans le dict printer.save_variables.variables au d\u00e9marrage et peuvent \u00eatre utilis\u00e9es dans des macros gcode. La VALEUR fournie est analys\u00e9e comme un litt\u00e9ral Python. [screws_tilt_adjust] \u00b6 Les commandes suivantes sont disponibles lorsque la section de configuration screws_tilt_adjust est activ\u00e9e (voir \u00e9galement le guide du nivelage manuel ). SCREWS_TILT_CALCULATE \u00b6 SCREWS_TILT_CALCULATE [DIRECTION=CW|CCW] [MAX_DEVIATION=<value>] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] : Cette commande appellera l'outil de r\u00e9glage des vis de r\u00e9glage du plateau. Elle d\u00e9placera la buse \u00e0 diff\u00e9rents endroits (tels que d\u00e9finis dans le fichier de configuration) en sondant la hauteur z et calculera le nombre de tours de vis n\u00e9cessaires pour ajuster le niveau du lit. Si DIRECTION est sp\u00e9cifi\u00e9, les rotations du bouton se feront toutes dans le m\u00eame sens, dans le sens des aiguilles d'une montre (CW) ou dans le sens inverse des aiguilles d'une montre (CCW). Voir la commande PROBE pour plus de d\u00e9tails sur les param\u00e8tres de sonde facultatifs. IMPORTANT : Vous DEVEZ toujours faire un G28 avant d'utiliser cette commande. Si MAX_DEVIATION est sp\u00e9cifi\u00e9, la commande g\u00e9n\u00e8re une erreur gcode si une diff\u00e9rence de hauteur de vis par rapport \u00e0 la hauteur de vis de base est sup\u00e9rieure \u00e0 la valeur fournie. La valeur facultative HORIZONTAL_MOVE_Z remplace l'option horizontal_move_z sp\u00e9cifi\u00e9e dans le fichier de configuration. [sdcard_loop] \u00b6 Lorsque la section de configuration sdcard_loop est activ\u00e9e, les commandes \u00e9tendues suivantes sont disponibles. SDCARD_LOOP_BEGIN \u00b6 SDCARD_LOOP_BEGIN COUNT=<compte> : Commence une section boucl\u00e9e dans l'impression SD. Un compte de 0 indique que la section doit \u00eatre boucl\u00e9e ind\u00e9finiment. SDCARD_LOOP_END \u00b6 SDCARD_LOOP_END : Termine une section de boucle dans l'impression SD. SDCARD_LOOP_DESIST \u00b6 SDCARD_LOOP_DESIST : Termine les boucles existantes sans autres it\u00e9rations. [servo] \u00b6 Les commandes suivantes sont disponibles lorsqu'une section servo config est activ\u00e9e. SET_SERVO \u00b6 SET_SERVO SERVO=nom_config [ANGLE=<degr\u00e9s> | LARGEUR=<secondes>] : D\u00e9finit la position du servo \u00e0 l'angle (en degr\u00e9s) ou \u00e0 la largeur d'impulsion (en secondes) donn\u00e9s. Utilisez WIDTH=0 pour d\u00e9sactiver la sortie du servo. [skew_correction] \u00b6 Les commandes suivantes sont disponibles lorsque la section de configuration skew_correction est activ\u00e9e (voir \u00e9galement le guide Skew Correction ). SET_SKEW \u00b6 SET_SKEW [XY=<ac_length,bd_length,ad_length>] [XZ=<ac,bd,ad>] [YZ=<ac,bd,ad>] [CLEAR=<0|1>] : Configure le module [skew_correction] avec des mesures (en mm) prises \u00e0 partir d'une impression d'\u00e9talonnage. On peut entrer des mesures pour n'importe quelle combinaison de plans, les plans non entr\u00e9s conserveront leur valeur actuelle. Si CLEAR=1 est entr\u00e9, toute correction d'inclinaison sera d\u00e9sactiv\u00e9e. GET_CURRENT_SKEW \u00b6 GET_CURRENT_SKEW : Indique l'inclinaison actuelle de l'imprimante pour chaque plan en radians et en degr\u00e9s. L'inclinaison est calcul\u00e9e en fonction des param\u00e8tres fournis par le gcode SET_SKEW . CALC_MEASURED_SKEW \u00b6 CALC_MEASURED_SKEW [AC=<ac_length>] [BD=<bd_length>] [AD=<ad_length>] : Calcule et rapporte l'inclinaison (en radians et en degr\u00e9s) bas\u00e9e sur une impression mesur\u00e9e. Cela peut \u00eatre utile pour d\u00e9terminer l'inclinaison actuelle de l'imprimante apr\u00e8s l'application de la correction. Elle peut \u00e9galement \u00eatre utile avant l'application de la correction pour d\u00e9terminer si une correction de l'inclinaison est n\u00e9cessaire. Reportez-vous \u00e0 la section [Correction de l'obliquit\u00e9] (Skew_Correction.md) pour plus de d\u00e9tails sur les objets et les mesures de calibrage de l'obliquit\u00e9. SKEW_PROFILE \u00b6 SKEW_PROFILE [LOAD=<nom>] [SAVE=<nom>] [REMOVE=<nom>] : Gestion des profils pour la correction de l'obliquit\u00e9. LOAD restaurera l'\u00e9tat d'inclinaison \u00e0 partir du profil correspondant au nom fourni. SAVE sauvegardera l'\u00e9tat actuel d'inclinaison dans un profil correspondant au nom fourni. Remove supprimera le profil correspondant au nom fourni de la m\u00e9moire persistante. Notez qu'apr\u00e8s l'ex\u00e9cution des op\u00e9rations SAVE ou REMOVE, le gcode SAVE_CONFIG doit \u00eatre ex\u00e9cut\u00e9 pour que les modifications apport\u00e9es \u00e0 la m\u00e9moire permanente deviennent permanentes. [smart_effector] \u00b6 Plusieurs commandes sont disponibles lorsqu'une section de configuration smart_effector est activ\u00e9e. Assurez-vous de consulter la documentation officielle du Smart Effector sur le Duet3D Wiki avant de modifier les param\u00e8tres du Smart Effector. Consultez \u00e9galement le guide d'\u00e9talonnage de la sonde . SET_SMART_EFFECTOR \u00b6 SET_SMART_EFFECTOR [SENSITIVITY=<sensitivity>] [ACCEL=<accel>] [RECOVERY_TIME=<time>] : D\u00e9finit les param\u00e8tres du Smart Effector. Lorsque SENSITIVITY est sp\u00e9cifi\u00e9, la valeur respective est \u00e9crite dans l'EEPROM du SmartEffecteur (n\u00e9cessite que control_pin soit fourni). Les valeurs acceptables de <sensitivity> sont 0..255, la valeur par d\u00e9faut est 50. Des valeurs plus faibles n\u00e9cessitent moins de force de contact de la buse pour se d\u00e9clencher (mais il y a un plus grand risque de faux d\u00e9clenchement d\u00fb aux vibrations pendant le palpage), des valeurs plus \u00e9lev\u00e9es r\u00e9duisent les faux d\u00e9clenchements (mais n\u00e9cessitent une plus grande force de contact pour se d\u00e9clencher). Comme la sensibilit\u00e9 est \u00e9crite dans l'EEPROM, elle est conserv\u00e9e apr\u00e8s l'arr\u00eat, il n'est donc pas n\u00e9cessaire de la configurer \u00e0 chaque d\u00e9marrage de l'imprimante. ACCEL et RECOVERY_TIME permettent de modifier les param\u00e8tres correspondants lors de l'ex\u00e9cution, voir la section config de Smart Effector pour plus d'informations sur ces param\u00e8tres. RESET_SMART_EFFECTOR \u00b6 RESET_SMART_EFFECTOR : R\u00e9initialise la sensibilit\u00e9 du Smart Effector \u00e0 ses param\u00e8tres d'usine. N\u00e9cessite que control_pin soit fourni dans la section de configuration. [stepper_enable] \u00b6 Le module stepper_enable est automatiquement charg\u00e9. SET_STEPPER_ENABLE \u00b6 SET_STEPPER_ENABLE STEPPER=<nom_de_la_configuration> ENABLE=[0|1] : Active ou d\u00e9sactive uniquement le stepper donn\u00e9. Il s'agit d'un outil de diagnostic et de d\u00e9bogage qui doit donc \u00eatre utilis\u00e9 avec pr\u00e9caution. La d\u00e9sactivation d'un moteur d'axe ne r\u00e9initialise pas les informations d'orientation. Le d\u00e9placement manuel d'un moteur pas \u00e0 pas d\u00e9sactiv\u00e9 peut amener la machine \u00e0 faire fonctionner le moteur en dehors des limites de s\u00e9curit\u00e9. Cela peut entra\u00eener des dommages aux composants de l'axe, aux extr\u00e9mit\u00e9s chaudes et \u00e0 la surface d'impression. [temperature_fan] \u00b6 La commande suivante est disponible lorsqu'une section temperature_fan config est activ\u00e9e. SET_TEMPERATURE_FAN_TARGET \u00b6 SET_TEMPERATURE_FAN_TARGET temperature_fan=<nom_du_ventilateur_temp\u00e9rature> [target=<temp\u00e9rature_cible>] [min_speed=<vitesse_min>] [max_speed=<vitesse_max>] : D\u00e9finit la temp\u00e9rature cible d'un ventilateur_temp\u00e9rature. Si une cible n'est pas fournie, elle est fix\u00e9e \u00e0 la temp\u00e9rature sp\u00e9cifi\u00e9e dans le fichier de configuration. Si les vitesses ne sont pas fournies, aucun changement n'est appliqu\u00e9. [tmcXXXX] \u00b6 Les commandes suivantes sont disponibles lorsque l'une des sections tmcXXXX config est activ\u00e9e. DUMP_TMC \u00b6 DUMP_TMC STEPPER=<name> [REGISTER=<name>] : Cette commande lira tous les registres du pilote TMC et remontera leurs valeurs. Si un REGISTRE est fourni, seul le registre sp\u00e9cifi\u00e9 sera remont\u00e9. INIT_TMC \u00b6 INIT_TMC STEPPER=<nom> : Cette commande initialise les registres de la puce TMC. N\u00e9cessaire pour r\u00e9activer le pilote si l'alimentation de la puce est coup\u00e9e puis r\u00e9tablie. SET_TMC_CURRENT \u00b6 SET_TMC_CURRENT STEPPER=<name> CURRENT=<amps> HOLDCURRENT=<amps> : Cela ajustera les courants de fonctionnement et de maintien du pilote TMC. HOLDCURRENT ne s'applique pas aux pilotes tmc2660. Lorsqu'il est utilis\u00e9 sur un pilote qui a le champ globalscaler (tmc5160 et tmc2240), si StealthChop2 est utilis\u00e9, le stepper doit \u00eatre maintenu \u00e0 l'arr\u00eat pendant > 130 ms afin que le pilote ex\u00e9cute l'\u00e9talonnage AT#1. SET_TMC_FIELD \u00b6 SET_TMC_FIELD STEPPER=<name> FIELD=<field> VALUE=<value> VELOCITY=<value> : cCette commande modifiera la valeur du champ de registre sp\u00e9cifi\u00e9 du pilote TMC. Cette commande est destin\u00e9e uniquement aux diagnostics de bas niveau et au d\u00e9bogage, car la modification des champs pendant l'ex\u00e9cution peut entra\u00eener un comportement ind\u00e9sirable et potentiellement dangereux de votre imprimante. Les modifications permanentes doivent \u00eatre effectu\u00e9es \u00e0 l'aide du fichier de configuration de l'imprimante \u00e0 la place. Aucune v\u00e9rification d'int\u00e9grit\u00e9 n'est effectu\u00e9e pour les valeurs donn\u00e9es. Une VITESSE peut \u00e9galement \u00eatre sp\u00e9cifi\u00e9e \u00e0 la place d'une VALEUR. Cette vitesse est convertie en repr\u00e9sentation de valeur bas\u00e9e sur TSTEP 20 bits. N'utilisez l'argument VELOCITY que pour les champs qui repr\u00e9sentent des vitesses. [toolhead] \u00b6 Le module de t\u00eate d'outil est automatiquement charg\u00e9. SET_VELOCITY_LIMIT \u00b6 SET_VELOCITY_LIMIT [VELOCITY=<valeur>] [ACCEL=<valeur>] [ACCEL_TO_DECEL=<valeur>] [SQUARE_CORNER_VELOCITY=<valeur>] : Modifie les limites de v\u00e9locit\u00e9 de l'imprimante. [tuning_tower] \u00b6 Le module tuning_tower est automatiquement charg\u00e9. TUNING_TOWER \u00b6 TUNING_TOWER COMMAND=<commande> PARAMETER=<nom> START=<valeur> [SKIP=<valeur>] [FACTOR=<valeur> [BAND=<valeur>]]. | [STEP_DELTA=<valeur> STEP_HEIGHT=<valeur>] : Un outil pour affiner un param\u00e8tre sur chaque hauteur Z pendant une impression. L'outil ex\u00e9cutera la COMMANDE donn\u00e9e avec le PARAM\u00c8TRE donn\u00e9 assign\u00e9 \u00e0 une valeur qui varie avec Z selon une formule. Utilisez FACTOR si vous allez utiliser une r\u00e8gle ou un pied \u00e0 coulisse pour mesurer la hauteur Z de la valeur optimale, ou STEP_DELTA et STEP_HEIGHT si le mod\u00e8le de tour de r\u00e9glage a des bandes de valeurs discr\u00e8tes comme c'est le cas avec les tours de temp\u00e9rature. Si SKIP=<valeur> est sp\u00e9cifi\u00e9, le processus de r\u00e9glage ne commence pas avant que la hauteur Z <valeur> soit atteinte, et en dessous, la valeur sera mise \u00e0 START ; dans ce cas, la z_height utilis\u00e9e dans les formules ci-dessous est en fait max(z - skip, 0) . Il y a trois combinaisons possibles d'options : FACTOR : La valeur change \u00e0 un taux de factor par millim\u00e8tre. La formule utilis\u00e9e est : valeur = start + factor * z_height . Vous pouvez ins\u00e9rer la hauteur Z optimale directement dans la formule pour d\u00e9terminer la valeur optimale du param\u00e8tre. FACTOR and BAND : La valeur change \u00e0 un taux moyen de factor par millim\u00e8tre, mais dans des bandes discr\u00e8tes o\u00f9 l'ajustement ne sera fait que tous les BAND millim\u00e8tres de hauteur Z. La formule utilis\u00e9e est : valeur =start + factor * ((floor(z_height / band) + .5) * band) . STEP_DELTA et STEP_HEIGHT : La valeur change de STEP_DELTA tous les millim\u00e8tres de STEP_HEIGHT . La formule utilis\u00e9e est : valeur = start + step_delta * floor(z_height / step_height) . Vous pouvez simplement compter les bandes ou lire les \u00e9tiquettes des tours de r\u00e9glage pour d\u00e9terminer la valeur optimale. [virtual_sdcard] \u00b6 Klipper prend en charge les commandes G-Code standards suivantes si la section de configuration virtual_sdcard est activ\u00e9e : Liste des cartes SD : M20 Initialiser la carte SD : M21 S\u00e9lectionnez le fichier SD : M23 <nom du fichier> D\u00e9marrer/reprendre l'impression SD : M24 Suspendre l'impression depuis la SD : M25 D\u00e9finir la position SD : M26 S<d\u00e9calage> Afficher l'\u00e9tat d'impression depuis la carte SD : M27 En outre, les commandes \u00e9tendues suivantes sont disponibles lorsque la section de configuration \"virtual_sdcard\" est activ\u00e9e. SDCARD_PRINT_FILE \u00b6 SDCARD_PRINT_FILE FILENAME=<nom_fichier> : Charge un fichier et lance l'impression SD. SDCARD_RESET_FILE \u00b6 SDCARD_RESET_FILE : D\u00e9charge le fichier et efface l'\u00e9tat de la carte SD. [axis_twist_compensation] \u00b6 The following commands are available when the axis_twist_compensation config section is enabled. AXIS_TWIST_COMPENSATION_CALIBRATE \u00b6 AXIS_TWIST_COMPENSATION_CALIBRATE [SAMPLE_COUNT=<value>] : Initiates the X twist calibration wizard. SAMPLE_COUNT specifies the number of points along the X axis to calibrate at and defaults to 3. [z_thermal_adjust] \u00b6 Les commandes suivantes sont disponibles lorsque la section z_thermal_adjust config est activ\u00e9e. SET_Z_THERMAL_ADJUST \u00b6 SET_Z_THERMAL_ADJUST [ENABLE=<0:1>] [TEMP_COEFF=<valeur>] [REF_TEMP=<valeur>] : Active ou d\u00e9sactive l'ajustement thermique Z avec ENABLE . La d\u00e9sactivation ne supprime pas l'ajustement d\u00e9j\u00e0 appliqu\u00e9, mais g\u00e8le la valeur d'ajustement actuelle - cela emp\u00eache un mouvement Z vers le bas potentiellement dangereux. La r\u00e9activation peut potentiellement causer un mouvement de l'outil vers le haut lorsque l'ajustement est mis \u00e0 jour et appliqu\u00e9. TEMP_COEFF permet de r\u00e9gler le coefficient de temp\u00e9rature de l'ajustement en cours d'ex\u00e9cution (c'est-\u00e0-dire le param\u00e8tre de configuration TEMP_COEFF ). Les valeurs de TEMP_COEFF ne sont pas sauvegard\u00e9es dans la config. REF_TEMP remplace manuellement la temp\u00e9rature de r\u00e9f\u00e9rence g\u00e9n\u00e9ralement r\u00e9gl\u00e9e pendant le retour \u00e0 l'origine (pour une utilisation dans des routines de retour \u00e0 l'origine non standard) - sera remis \u00e0 z\u00e9ro automatiquement lors du retour \u00e0 l'origine. [z_tilt] \u00b6 Les commandes suivantes sont disponibles lorsque la section z_tilt config est activ\u00e9e. Z_TILT_ADJUST \u00b6 Z_TILT_ADJUST [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] : Cette commande sondera les points sp\u00e9cifi\u00e9s dans la configuration, puis effectuera des ajustements ind\u00e9pendants sur chaque stepper Z pour compenser l'inclinaison. Voir la commande PROBE pour plus de d\u00e9tails sur les param\u00e8tres de sonde facultatifs. La valeur facultative HORIZONTAL_MOVE_Z remplace l'option horizontal_move_z sp\u00e9cifi\u00e9e dans le fichier de configuration.","title":"G-Codes"},{"location":"G-Codes.html#g-codes","text":"Ce document d\u00e9crit les commandes que Klipper supporte. Il s'agit de commandes que l'on peut saisir dans l'onglet du terminal OctoPrint.","title":"G-Codes"},{"location":"G-Codes.html#commandes-g-code","text":"Klipper prend en charge les commandes G-Code standard suivantes : Move (G0 ou G1): G1 [X<pos>] [Y<pos>] [Z<pos>] [E<pos>] [F<speed>] Temporisation : G4 P<millisecondes> D\u00e9placement vers l'origine : G28 [X] [Y] [Z] \u00c9teindre les moteurs : M18 ou M84 Attendre la fin des mouvements en cours : M400 Utiliser l'extrusion absolue/relative : M82 , M83 Utiliser des coordonn\u00e9es absolues/relatives : G90 , G91 D\u00e9finir la position : G92 [X<pos>] [Y<pos>] [Z<pos>] [E<pos>] D\u00e9finir le pourcentage de neutralisation du facteur de vitesse : M220 S<percent> D\u00e9finit le pourcentage d'annulation du facteur d'extrusion : M221 S<percent> R\u00e9gler l'acc\u00e9l\u00e9ration : M204 S<valeur> OU M204 P<valeur> T<valeur> Remarque : si S n'est pas sp\u00e9cifi\u00e9 et que P et T le sont, l'acc\u00e9l\u00e9ration sera r\u00e9gl\u00e9e sur le minimum de P et T. Si un seul P ou T est donn\u00e9, la commande n'aura aucun effet. Obtenir la temp\u00e9rature de l'extrudeur : M105 R\u00e9gler la temp\u00e9rature de l'extrudeur : M104 [T<index>] [S<temp\u00e9rature>] R\u00e9gler la temp\u00e9rature de l'extrudeur et attendre : M109 [T<index>] S<temp\u00e9rature> Note : M109 attendra toujours que la temp\u00e9rature se stabilise \u00e0 la valeur demand\u00e9e. R\u00e9gler la temp\u00e9rature du bed : M140 [S<temperature>] R\u00e9gler la temp\u00e9rature du bed et attendre : M190 S<temperature> Note : M190 attendra toujours que la temp\u00e9rature se stabilise \u00e0 la valeur demand\u00e9e. R\u00e9gler la vitesse du ventilateur : M106 S<valeur> D\u00e9sactiver le ventilateur : M107 Arr\u00eat d'urgence : M112 Obtenir la position actuelle : M114 Obtenir la version du firmware : M115 Pour plus de d\u00e9tails sur les commandes ci-dessus, voir la [documentation RepRap G-Code] ( http://reprap.org/wiki/G-code ). L'objectif de Klipper est de prendre en charge les commandes G-Code produites par les logiciels tiers courants (par exemple, OctoPrint, Printrun, Slic3r, Cura, etc.) dans leurs configurations standards. Le but n'est pas de prendre en charge toutes les commandes G-Code possibles. Au contraire, Klipper pr\u00e9f\u00e8re les [\"commandes G-Code \u00e9tendues\"] (#additional-commands) humainement lisibles. De la m\u00eame mani\u00e8re, la sortie du terminal G-Code est uniquement destin\u00e9e \u00e0 \u00eatre humainement lisible - voir le document du serveur API si vous contr\u00f4lez Klipper depuis un logiciel externe. Si vous avez besoin d'une commande G-Code moins courante, il est possible de l'impl\u00e9menter avec une section de configuration gcode_macro personnalis\u00e9e . Par exemple, on peut utiliser ceci pour impl\u00e9menter : G12 , G29 , G30 , G31 , M42 , M80 , M81 , T1 , etc.","title":"Commandes G-Code"},{"location":"G-Codes.html#commandes-additionnelles","text":"Klipper utilise des commandes G-Code \"\u00e9tendues\" pour la configuration g\u00e9n\u00e9rale et l'\u00e9tat. Ces commandes \u00e9tendues suivent toutes un format similaire : elles commencent par le nom de la commande et peuvent \u00eatre suivies d'un ou plusieurs param\u00e8tres. Par exemple : SET_SERVO SERVO=myservo ANGLE=5.3 . Dans ce document, les commandes et les param\u00e8tres sont indiqu\u00e9s en majuscules, mais ils ne sont pas sensibles \u00e0 la casse. (Ainsi, \"SET_SERVO\" et \"set_servo\" ex\u00e9cuteront tous deux la m\u00eame commande). Cette section est organis\u00e9e par nom de module Klipper, en suivant g\u00e9n\u00e9ralement les noms de section sp\u00e9cifi\u00e9s dans le fichier de configuration de l'imprimante . Notez que certains modules sont automatiquement charg\u00e9s.","title":"Commandes additionnelles"},{"location":"G-Codes.html#adxl345","text":"Les commandes suivantes sont disponibles lorsqu'une section adxl345 config est activ\u00e9e.","title":"[adxl345]"},{"location":"G-Codes.html#accelerometer_measure","text":"ACCELEROMETER_MEASURE [CHIP=<nom_de_la_configuration>] [NAME=<valeur>] : D\u00e9marre les mesures de l'acc\u00e9l\u00e9rom\u00e8tre au nombre d'\u00e9chantillons par seconde demand\u00e9. Si CHIP n'est pas pr\u00e9cis\u00e9, la valeur par d\u00e9faut est \"adxl345\". La commande fonctionne en mode start-stop : ex\u00e9cut\u00e9e pour la premi\u00e8re fois, elle d\u00e9marre les mesures, l'ex\u00e9cution suivante les arr\u00eate. Les r\u00e9sultats des mesures sont \u00e9crits dans un fichier nomm\u00e9 /tmp/adxl345-<chip>-<nom>.csv o\u00f9 <chip> est le nom de la puce acc\u00e9l\u00e9rom\u00e8tre ( my_chip_name de [adxl345 my_chip_name] ) et <nom> est le param\u00e8tre optionnel NAME. Si le param\u00e8tre NOM n'est pas pr\u00e9cis\u00e9, l'heure actuelle est utilis\u00e9e par d\u00e9faut au format \"AAAAMMJJ_HHMMSS\". Si l'acc\u00e9l\u00e9rom\u00e8tre n'a pas de nom dans sa section de configuration (simplement [adxl345] ) alors la partie <chip> du nom n'est pas g\u00e9n\u00e9r\u00e9e.","title":"ACCELEROMETER_MEASURE"},{"location":"G-Codes.html#accelerometer_query","text":"ACCELEROMETER_QUERY [CHIP=<nom_de_la_configuration>] [RATE=<valeur>] : interroge l'acc\u00e9l\u00e9rom\u00e8tre pour la valeur courante. Si CHIP n'est pas pr\u00e9cis\u00e9, la valeur par d\u00e9faut est \"adxl345\". Si RATE n'est pas pr\u00e9cis\u00e9, la valeur par d\u00e9faut est utilis\u00e9e. Cette commande permet de tester la connexion \u00e0 l'acc\u00e9l\u00e9rom\u00e8tre ADXL345 : une des valeurs retourn\u00e9es devrait \u00eatre une acc\u00e9l\u00e9ration en chute libre (+/- un certain bruit de la puce).","title":"ACCELEROMETER_QUERY"},{"location":"G-Codes.html#accelerometer_debug_read","text":"ACCELEROMETER_DEBUG_READ [CHIP=<nom_de_la_configuration>] REG=<registre> : interroge le registre ADXL345 \"registre\" (par exemple 44 ou 0x2C). Peut \u00eatre utile \u00e0 des fins de d\u00e9bogage.","title":"ACCELEROMETER_DEBUG_READ"},{"location":"G-Codes.html#accelerometer_debug_write","text":"ACCELEROMETER_DEBUG_WRITE [CHIP=<nom_de_la_configuration>] REG=<registre> VAL=<valeur> : Ecrit la \"valeur\" brute dans le registre \"registre\". La \"valeur\" et le \"registre\" peuvent \u00eatre des entiers d\u00e9cimaux ou hexad\u00e9cimaux. A utiliser avec pr\u00e9caution, et se r\u00e9f\u00e9rer \u00e0 la fiche technique de l'ADXL345 pour la r\u00e9f\u00e9rence.","title":"ACCELEROMETER_DEBUG_WRITE"},{"location":"G-Codes.html#angle","text":"Les commandes suivantes sont disponibles lorsqu'une section angle config est activ\u00e9e.","title":"[angle]"},{"location":"G-Codes.html#angle_calibrate","text":"ANGLE_CALIBRATE CHIP=<nom_de_la_puce> : Effectue une calibration d'angle sur le capteur donn\u00e9 (il doit y avoir une section de configuration [angle nom_de_la_puce] qui a indiqu\u00e9 un param\u00e8tre stepper ). IMPORTANT - cet outil commandera au moteur pas \u00e0 pas de se d\u00e9placer sans v\u00e9rifier les limites normales de la cin\u00e9matique. Id\u00e9alement, le moteur devrait \u00eatre d\u00e9connect\u00e9 de tout chariot d'imprimante avant d'effectuer le calibrage. Si le moteur pas \u00e0 pas ne peut pas \u00eatre d\u00e9connect\u00e9 de l'imprimante, assurez-vous que le chariot est proche du centre de son rail avant de commencer l'\u00e9talonnage. (Le moteur pas \u00e0 pas peut se d\u00e9placer vers l'avant ou l'arri\u00e8re de deux rotations compl\u00e8tes durant ce test). Apr\u00e8s avoir termin\u00e9 ce test, utilisez la commande SAVE_CONFIG pour sauvegarder les donn\u00e9es de calibration dans le fichier de configuration. Afin d'utiliser cet outil, le paquetage Python \"numpy\" doit \u00eatre install\u00e9 (voir le document mesurer les r\u00e9sonances pour plus d'informations).","title":"ANGLE_CALIBRATE"},{"location":"G-Codes.html#angle_debug_read","text":"ANGLE_DEBUG_READ CHIP=<nom_de_la_configuration> REG=<registre> : Interroge le registre \"registre\" du capteur (par exemple 44 ou 0x2C). Peut \u00eatre utile \u00e0 des fins de d\u00e9bogage. Ceci n'est disponible que pour les puces tle5012b.","title":"ANGLE_DEBUG_READ"},{"location":"G-Codes.html#angle_debug_write","text":"ANGLE_DEBUG_WRITE CHIP=<nom_de_la_configuration> REG=<registre> VAL=<valeur> : \u00c9crit la \"valeur\" brute dans le registre \"registre\". La \"valeur\" et le \"registre\" peuvent \u00eatre des entiers d\u00e9cimaux ou hexad\u00e9cimaux. A utiliser avec pr\u00e9caution, et se r\u00e9f\u00e9rer \u00e0 la fiche technique du capteur pour la r\u00e9f\u00e9rence. Cette fonction n'est disponible que pour les puces tle5012b.","title":"ANGLE_DEBUG_WRITE"},{"location":"G-Codes.html#bed_mesh","text":"Les commandes suivantes sont disponibles lorsque la section configuration de bed_mesh est activ\u00e9e (voir \u00e9galement le guide de bed_mesh ).","title":"[bed_mesh]"},{"location":"G-Codes.html#bed_mesh_calibrate","text":"BED_MESH_CALIBRATE [METHOD=manual] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] [<mesh_parameter>=<value>] : Cette commande sonde le lit en utilisant les points g\u00e9n\u00e9r\u00e9s sp\u00e9cifi\u00e9s par les param\u00e8tres dans la configuration. Apr\u00e8s le sondage, un maillage est g\u00e9n\u00e9r\u00e9 et le mouvement z est ajust\u00e9 en fonction du maillage. Voir la commande PROBE pour plus de d\u00e9tails sur les param\u00e8tres de sonde facultatifs. Si METHOD=manual est sp\u00e9cifi\u00e9, l'outil de sondage manuel est activ\u00e9 - voir la commande MANUAL_PROBE ci-dessus pour plus de d\u00e9tails sur les commandes suppl\u00e9mentaires disponibles lorsque cet outil est actif. La valeur facultative HORIZONTAL_MOVE_Z remplace l'option horizontal_move_z sp\u00e9cifi\u00e9e dans le fichier de configuration.","title":"BED_MESH_CALIBRATE"},{"location":"G-Codes.html#bed_mesh_output","text":"BED_MESH_OUTPUT PGP=[<0:1>] : Cette commande \u00e9crit les valeurs z palp\u00e9es actuelles et les valeurs de maillage actuelles sur le terminal. Si PGP=1 est sp\u00e9cifi\u00e9, les coordonn\u00e9es X, Y g\u00e9n\u00e9r\u00e9es par bed_mesh, ainsi que leurs indices associ\u00e9s, seront envoy\u00e9s au terminal.","title":"BED_MESH_OUTPUT"},{"location":"G-Codes.html#bed_mesh_map","text":"BED_MESH_MAP : Comme pour BED_MESH_OUTPUT, cette commande affiche l'\u00e9tat actuel du maillage sur le terminal. L'\u00e9tat sera retourn\u00e9 au format json. Cela permet aux plugins octoprint de r\u00e9cup\u00e9rer facilement les donn\u00e9es et de g\u00e9n\u00e9rer des cartes d'altitude au plus proche de la surface du bed.","title":"BED_MESH_MAP"},{"location":"G-Codes.html#bed_mesh_clear","text":"BED_MESH_CLEAR : Cette commande efface le maillage actuel et supprime les ajustements de l'axe z. Il est recommand\u00e9 de mettre cette commande dans votre gcode de fin.","title":"BED_MESH_CLEAR"},{"location":"G-Codes.html#bed_mesh_profile","text":"BED_MESH_PROFILE LOAD=<nom> SAVE=<nom> REMOVE=<nom> : Cette commande fournit une gestion de profil pour l'\u00e9tat du maillage. LOAD restaurera l'\u00e9tat du maillage \u00e0 partir du profil correspondant au nom fourni. SAVE sauvegarde l'\u00e9tat du maillage actuel dans un profil correspondant au nom fourni. REMOVE supprimera le profil correspondant au nom fourni de la m\u00e9moire persistante. Notez qu'apr\u00e8s l'ex\u00e9cution des op\u00e9rations SAVE ou REMOVE, le gcode SAVE_CONFIG doit \u00eatre ex\u00e9cut\u00e9 pour rendre les changements de la m\u00e9moire persistante permanents.","title":"BED_MESH_PROFILE"},{"location":"G-Codes.html#bed_mesh_offset","text":"BED_MESH_OFFSET [X=<value>] [Y=<value>] : Applique des d\u00e9calages X et/ou Y pour l'\u00e9valuation du maillage. Ceci est utile pour les imprimantes avec extrudeurs ind\u00e9pendants, car un d\u00e9calage est n\u00e9cessaire pour obtenir un ajustement Z correct apr\u00e8s un changement d'outil.","title":"BED_MESH_OFFSET"},{"location":"G-Codes.html#bed_screws","text":"Les commandes suivantes sont disponibles lorsque la section config bed_screws est activ\u00e9e (voir \u00e9galement le guide du nivelage manuel ).","title":"[bed_screws]"},{"location":"G-Codes.html#bed_screws_adjust","text":"BED_SCREWS_ADJUST : Cette commande fait appel \u00e0 l'outil de r\u00e9glage des vis du bed. Elle commandera la buse \u00e0 diff\u00e9rents endroits (tels que d\u00e9finis dans le fichier de configuration) et permettra d'ajuster les vis du bed afin que celui-ci et la buse soient \u00e0 distance constante.","title":"BED_SCREWS_ADJUST"},{"location":"G-Codes.html#bed_tilt","text":"Les commandes suivantes sont disponibles lorsque la section config bed_tilt est activ\u00e9e.","title":"[bed_tilt]"},{"location":"G-Codes.html#bed_tilt_calibrate","text":"BED_TILT_CALIBRATE [METHOD=manual] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] : Cette commande sondera les points sp\u00e9cifi\u00e9s dans la configuration, puis recommandera des ajustements d'inclinaison x et y mis \u00e0 jour. Voir la commande PROBE pour plus de d\u00e9tails sur les param\u00e8tres de sonde facultatifs. Si METHOD=manual est sp\u00e9cifi\u00e9, l'outil de sondage manuel est activ\u00e9 - voir la commande MANUAL_PROBE ci-dessus pour plus de d\u00e9tails sur les commandes suppl\u00e9mentaires disponibles lorsque cet outil est actif. La valeur facultative HORIZONTAL_MOVE_Z remplace l'option horizontal_move_z sp\u00e9cifi\u00e9e dans le fichier de configuration.","title":"BED_TILT_CALIBRATE"},{"location":"G-Codes.html#bltouch","text":"La commande suivante est disponible lorsqu'une section bltouch config est activ\u00e9e (voir \u00e9galement le Guide BL-Touch ).","title":"[bltouch]"},{"location":"G-Codes.html#bltouch_debug","text":"BLTOUCH_DEBUG COMMAND=<commande> : Ceci envoie une commande au BLTouch. Elle peut \u00eatre utile pour le d\u00e9bogage. Les commandes disponibles sont : pin_down , touch_mode , pin_up , self_test , reset . Un BL-Touch V3.0 ou V3.1 accepte en plus les commandes set_5V_output_mode , set_OD_output_mode , output_mode_store .","title":"BLTOUCH_DEBUG"},{"location":"G-Codes.html#bltouch_store","text":"BLTOUCH_STORE MODE=<output_mode> : Stocke un mode de sortie dans l'EEPROM d'un BLTouch V3.1 Les modes de sortie disponibles sont : 5V , OD","title":"BLTOUCH_STORE"},{"location":"G-Codes.html#configfile","text":"Le module configfile est automatiquement charg\u00e9.","title":"[configfile]"},{"location":"G-Codes.html#save_config","text":"SAVE_CONFIG : Cette commande \u00e9crase le fichier de configuration principal de l'imprimante et red\u00e9marre le logiciel h\u00f4te. Cette commande est utilis\u00e9e conjointement avec d'autres commandes d'\u00e9talonnage pour enregistrer les r\u00e9sultats de ces tests.","title":"SAVE_CONFIG"},{"location":"G-Codes.html#delayed_gcode","text":"La commande suivante est activ\u00e9e si une section de configuration delayed_gcode a \u00e9t\u00e9 activ\u00e9e (voir \u00e9galement le guide des mod\u00e8les ).","title":"[delayed_gcode]"},{"location":"G-Codes.html#update_delayed_gcode","text":"UPDATE_DELAYED_GCODE [ID=<nom>] [DURATION=<secondes>] : Met \u00e0 jour la dur\u00e9e du retard du [delayed_gcode] identifi\u00e9 et d\u00e9marre le minuteur pour l'ex\u00e9cution du gcode. Une valeur de 0 annulera l'ex\u00e9cution d'un gcode retard\u00e9 en attente.","title":"UPDATE_DELAYED_GCODE"},{"location":"G-Codes.html#delta_calibrate","text":"Les commandes suivantes sont disponibles lorsque la section delta_calibrate config est activ\u00e9e (voir \u00e9galement le guide delta calibrate ).","title":"[delta_calibrate]"},{"location":"G-Codes.html#delta_calibrate_1","text":"DELTA_CALIBRATE [METHOD=manual] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] : Cette commande sondera sept points sur le lit et recommandera des positions de but\u00e9es de fin de course, des angles des tours et un rayon. Voir la commande PROBE pour plus de d\u00e9tails sur les param\u00e8tres de sonde facultatifs. Si METHOD=manual est sp\u00e9cifi\u00e9, l'outil de sondage manuel est activ\u00e9 - voir la commande MANUAL_PROBE ci-dessus pour plus de d\u00e9tails sur les commandes suppl\u00e9mentaires disponibles lorsque cet outil est actif. La valeur facultative HORIZONTAL_MOVE_Z remplace l'option horizontal_move_z sp\u00e9cifi\u00e9e dans le fichier de configuration.","title":"DELTA_CALIBRATE"},{"location":"G-Codes.html#delta_analyze","text":"DELTA_ANALYZE : Cette commande est utilis\u00e9e pendant l'\u00e9talonnage delta am\u00e9lior\u00e9. Voir Calibrage delta pour plus de d\u00e9tails.","title":"DELTA_ANALYZE"},{"location":"G-Codes.html#display","text":"La commande suivante est disponible lorsqu'une section display config est activ\u00e9e.","title":"[display]"},{"location":"G-Codes.html#set_display_group","text":"SET_DISPLAY_GROUP [DISPLAY=<display>] GROUP=<group> : D\u00e9finit le groupe d'affichage actif d'un \u00e9cran LCD. Cela permet de d\u00e9finir plusieurs groupes de donn\u00e9es d'affichage dans la configuration, par exemple [display_data <group> <elementname>] et de passer de l'un \u00e0 l'autre en utilisant cette commande gcode \u00e9tendue. Si DISPLAY n'est pas sp\u00e9cifi\u00e9, la valeur par d\u00e9faut est \"display\" (l'affichage principal).","title":"SET_DISPLAY_GROUP"},{"location":"G-Codes.html#display_status","text":"Le module display_status est automatiquement charg\u00e9 si une section display config est activ\u00e9e. Il fournit les commandes G-Code standard suivantes : Afficher un message : M117 <message> D\u00e9finir le pourcentage de g\u00e9n\u00e9ration : M73 P<pourcentage> La commande G-Code \u00e9tendue suivante est \u00e9galement fournie : SET_DISPLAY_TEXT MSG=<message> : Effectue l'\u00e9quivalent de M117, en d\u00e9finissant le MSG fourni comme le message d'affichage actuel. Si MSG est omis, l'affichage est effac\u00e9.","title":"[display_status]"},{"location":"G-Codes.html#dual_carriage","text":"La commande suivante est disponible lorsque la section config dual_carriage est activ\u00e9e.","title":"[dual_carriage]"},{"location":"G-Codes.html#set_dual_carriage","text":"SET_DUAL_CARRIAGE CARRIAGE=[0|1] [MODE=[PRIMARY|COPY|MIRROR]] : This command will change the mode of the specified carriage. If no MODE is provided it defaults to PRIMARY . Setting the mode to PRIMARY deactivates the other carriage and makes the specified carriage execute subsequent G-Code commands as-is. COPY and MIRROR modes are supported only for CARRIAGE=1 . When set to either of these modes, carriage 1 will then track the subsequent moves of the carriage 0 and either copy relative movements of it (in COPY mode) or execute them in the opposite (mirror) direction (in MIRROR mode).","title":"SET_DUAL_CARRIAGE"},{"location":"G-Codes.html#save_dual_carriage_state","text":"SAVE_DUAL_CARRIAGE_STATE [NAME=<state_name>] : Save the current positions of the dual carriages and their modes. Saving and restoring DUAL_CARRIAGE state can be useful in scripts and macros, as well as in homing routine overrides. If NAME is provided it allows one to name the saved state to the given string. If NAME is not provided it defaults to \"default\".","title":"SAVE_DUAL_CARRIAGE_STATE"},{"location":"G-Codes.html#restore_dual_carriage_state","text":"RESTORE_DUAL_CARRIAGE_STATE [NAME=<state_name>] [MOVE=[0|1] [MOVE_SPEED=<speed>]] : Restore the previously saved positions of the dual carriages and their modes, unless \"MOVE=0\" is specified, in which case only the saved modes will be restored, but not the positions of the carriages. If positions are being restored and \"MOVE_SPEED\" is specified, then the toolhead moves will be performed with the given speed (in mm/s); otherwise the toolhead move will use the rail homing speed. Note that the carriages restore their positions only over their own axis, which may be necessary to correctly restore COPY and MIRROR mode of the dual carraige.","title":"RESTORE_DUAL_CARRIAGE_STATE"},{"location":"G-Codes.html#endstop_phase","text":"Les commandes suivantes sont disponibles lorsqu'une section de configuration endstop_phase est activ\u00e9e (voir \u00e9galement le guide de la phase d'arr\u00eat ).","title":"[endstop_phase]"},{"location":"G-Codes.html#endstop_phase_calibrate","text":"ENDSTOP_PHASE_CALIBRATE [STEPPER=<config_name>] : Si aucun param\u00e8tre STEPPER n'est fourni, cette commande rapporte des statistiques sur les phases d'arr\u00eat du stepper pendant les pr\u00e9c\u00e9dentes op\u00e9rations de recherche d'origine. Lorsqu'un param\u00e8tre STEPPER est fourni, elle fait en sorte que le param\u00e8tre de phase de fin de course donn\u00e9 soit \u00e9crit dans le fichier de configuration (en lien avec la commande SAVE_CONFIG).","title":"ENDSTOP_PHASE_CALIBRATE"},{"location":"G-Codes.html#exclude_object","text":"Les commandes suivantes sont disponibles lorsqu'une section de configuration exclude_object est activ\u00e9e (voir \u00e9galement le guide d'exclusion d'objet ) :","title":"[exclude_object]"},{"location":"G-Codes.html#exclude_object_1","text":"EXCLUDE_OBJECT [NAME=nom_objet] [CURRENT=1] [RESET=1] : Sans param\u00e8tres, cette commande renvoie une liste de tous les objets actuellement exclus. Lorsque le param\u00e8tre NAME est donn\u00e9, l'objet nomm\u00e9 sera exclu de l'impression. Lorsque le param\u00e8tre CURRENT est donn\u00e9, l'objet courant sera exclu de l'impression. Lorsque le param\u00e8tre RESET est donn\u00e9, la liste des objets exclus sera effac\u00e9e. De plus, inclure le param\u00e8tre NAME ne r\u00e9initialisera que l'objet nomm\u00e9. Cela peut provoquer des \u00e9checs d'impression, si des couches ont d\u00e9j\u00e0 \u00e9t\u00e9 omises.","title":"EXCLUDE_OBJECT"},{"location":"G-Codes.html#exclude_object_define","text":"EXCLUDE_OBJECT_DEFINE [NAME=nom_objet [CENTER=X,Y] [POLYGON=[[x,y],...]]] [RESET=1] [JSON=1] : Fournit le r\u00e9sum\u00e9 d'un objet dans le fichier. Sans param\u00e8tres fournis, ceci va lister les objets d\u00e9finis connus de Klipper. Retourne une liste de cha\u00eenes de caract\u00e8res, \u00e0 moins que le param\u00e8tre JSON soit donn\u00e9, auquel cas retournera les d\u00e9tails de l'objet au format json. Lorsque le param\u00e8tre NAME est inclus, cela d\u00e9finit un objet \u00e0 exclure. NAME : Ce param\u00e8tre est obligatoire. Il s'agit de l'identifiant utilis\u00e9 par les autres commandes de ce module. CENTER : Une coordonn\u00e9e X,Y pour l'objet. POLYGON : Un tableau de coordonn\u00e9es X,Y fournissant le contour d'un objet. Lorsque le param\u00e8tre RESET est fourni, tous les objets d\u00e9finis seront effac\u00e9s, et le module [exclude_object] sera r\u00e9initialis\u00e9.","title":"EXCLUDE_OBJECT_DEFINE"},{"location":"G-Codes.html#exclude_object_start","text":"EXCLUDE_OBJECT_START NAME=nom_objet : Cette commande prend un param\u00e8tre NAME et indique le d\u00e9but du gcode pour un objet sur la couche courante.","title":"EXCLUDE_OBJECT_START"},{"location":"G-Codes.html#exclude_object_end","text":"EXCLUDE_OBJECT_END [NAME=nom_objet] : Indique la fin du gcode de l'objet pour la couche. Il est associ\u00e9 \u00e0 EXCLUDE_OBJECT_START . Le param\u00e8tre NAME est optionnel, et n'avertira que si le nom fourni ne correspond au nom actuel.","title":"EXCLUDE_OBJECT_END"},{"location":"G-Codes.html#extruder","text":"Les commandes suivantes sont disponibles si une section configuration de l'extrudeuse est activ\u00e9e :","title":"[extruder]"},{"location":"G-Codes.html#activate_extruder","text":"ACTIVATE_EXTRUDER EXTRUDER=<nom_de_la_configuration> : Dans une imprimante comportant plusieurs sections de configuration d' extrudeuse , cette commande s\u00e9lectionne la t\u00eate d'outil active.","title":"ACTIVATE_EXTRUDER"},{"location":"G-Codes.html#set_pressure_advance","text":"SET_PRESSURE_ADVANCE [EXTRUDER=<nom_de_la_configuration>] [ADVANCE=<avance_de_pression>] [SMOOTH_TIME=<dur\u00e9e_adoucissemt_avance_de_pression>] : D\u00e9finit les param\u00e8tres d'avance de pression du moteur d'extrudeuse (comme d\u00e9fini dans une section de configuration extrudeur ou extruder_stepper ). Si EXTRUDER n'est pas sp\u00e9cifi\u00e9, il s'agit par d\u00e9faut du stepper d\u00e9fini dans la t\u00eate d'outil active.","title":"SET_PRESSURE_ADVANCE"},{"location":"G-Codes.html#set_extruder_rotation_distance","text":"SET_EXTRUDER_ROTATION_DISTANCE EXTRUDER=<nom_config> [DISTANCE=<distance>] : D\u00e9finit une nouvelle valeur pour la \"distance de rotation\" du moteur de l'extrudeuse fournie (telle que d\u00e9finie dans une section de configuration extruder ou extruder_stepper ). Si la distance de rotation est un nombre n\u00e9gatif, le mouvement du moteur sera invers\u00e9 (par rapport \u00e0 la direction du moteur sp\u00e9cifi\u00e9e dans le fichier de configuration). Les param\u00e8tres modifi\u00e9s ne sont pas conserv\u00e9s lors de la r\u00e9initialisation de Klipper. Utilisez avec pr\u00e9caution car de petites modifications peuvent entra\u00eener une pression excessive entre l'extrudeuse et la t\u00eate de l'outil. Effectuez un calibrage correct avec le filament avant de l'utiliser. Si la valeur 'DISTANCE' n'est pas fournie, cette commande renvoie la distance de rotation actuelle.","title":"SET_EXTRUDER_ROTATION_DISTANCE"},{"location":"G-Codes.html#sync_extruder_motion","text":"SYNC_EXTRUDER_MOTION EXTRUDER=<nom> MOTION_QUEUE=<nom> : Cette commande permet de synchroniser le moteur d'entra\u00eenement sp\u00e9cifi\u00e9 par EXTRUDER (tel que d\u00e9fini dans la section de configuration extruder ou extruder_stepper avec le mouvement d'un extrudeur sp\u00e9cifi\u00e9 par MOTION_QUEUE (tel que d\u00e9fini dans la section de configuration extruder ). Si MOTION_QUEUE est une cha\u00eene vide, le stepper sera d\u00e9synchronis\u00e9 de tout mouvement d'extrudeuse.","title":"SYNC_EXTRUDER_MOTION"},{"location":"G-Codes.html#set_extruder_step_distance","text":"Cette commande est obsol\u00e8te et sera supprim\u00e9e dans un avenir proche.","title":"SET_EXTRUDER_STEP_DISTANCE"},{"location":"G-Codes.html#sync_stepper_to_extruder","text":"Cette commande est obsol\u00e8te et sera supprim\u00e9e dans un avenir proche.","title":"SYNC_STEPPER_TO_EXTRUDER"},{"location":"G-Codes.html#fan_generic","text":"La commande suivante est disponible lorsqu'une section fan_generic config est activ\u00e9e.","title":"[fan_generic]"},{"location":"G-Codes.html#set_fan_speed","text":"SET_FAN_SPEED FAN=nom_config SPEED=<vitesse> Cette commande d\u00e9finit la vitesse d'un ventilateur. La valeur de \"vitesse\" doit \u00eatre comprise entre 0,0 et 1,0.","title":"SET_FAN_SPEED"},{"location":"G-Codes.html#filament_switch_sensor","text":"La commande suivante est disponible lorsqu'une section de configuration filament_switch_sensor ou filament_motion_sensor est activ\u00e9e.","title":"[filament_switch_sensor]"},{"location":"G-Codes.html#query_filament_sensor","text":"QUERY_FILAMENT_SENSOR SENSOR=<nom_du_capteur> : Interroge l'\u00e9tat actuel du capteur de filament. Les donn\u00e9es affich\u00e9es sur le terminal d\u00e9pendront du type de capteur d\u00e9fini dans la configuration.","title":"QUERY_FILAMENT_SENSOR"},{"location":"G-Codes.html#set_filament_sensor","text":"SET_FILAMENT_SENSOR SENSOR=<nom_du_capteur> ENABLE=[0|1] : Active/d\u00e9sactive le d\u00e9tecteur de filament. Si ENABLE est r\u00e9gl\u00e9 sur 0, le d\u00e9tecteur de filament est d\u00e9sactiv\u00e9, s'il est r\u00e9gl\u00e9 sur 1, il est activ\u00e9.","title":"SET_FILAMENT_SENSOR"},{"location":"G-Codes.html#firmware_retraction","text":"Les commandes G-Code standard suivantes sont disponibles lorsque la section de configuration firmware_retraction est activ\u00e9e. Ces commandes vous permettent d'utiliser la fonction de r\u00e9traction du micrologiciel disponible dans de nombreux trancheurs, afin de r\u00e9duire le cordage pendant les d\u00e9placements sans extrusion d'une partie de l'impression \u00e0 une autre. Une configuration appropri\u00e9e de l'avance \u00e0 la pression r\u00e9duit la longueur de r\u00e9traction requise. G10 : R\u00e9tracte l'extrudeur en utilisant les param\u00e8tres actuellement configur\u00e9s. G11 : D\u00e9tache l'extrudeur en utilisant les param\u00e8tres actuellement configur\u00e9s. Les commandes suppl\u00e9mentaires suivantes sont \u00e9galement disponibles.","title":"[firmware_retraction]"},{"location":"G-Codes.html#set_retraction","text":"SET_RETRACTION [RETRACT_LENGTH=<mm>] [RETRACT_SPEED=<mm/s>] [UNRETRACT_EXTRA_LENGTH=<mm>] [UNRETRACT_SPEED=<mm/s>] : Ajuste les param\u00e8tres utilis\u00e9s par la r\u00e9traction du micrologiciel. RETRACT_LENGTH d\u00e9termine la longueur de filament \u00e0 r\u00e9tracter et \u00e0 d\u00e9r\u00e9tracter. La vitesse de r\u00e9traction est ajust\u00e9e via RETRACT_SPEED, et est g\u00e9n\u00e9ralement r\u00e9gl\u00e9e relativement haut. La vitesse de d\u00e9stratification est ajust\u00e9e via UNRETRACT_SPEED, et n'est pas particuli\u00e8rement critique, bien que souvent inf\u00e9rieure \u00e0 RETRACT_SPEED. Dans certains cas, il est utile d'ajouter une petite quantit\u00e9 de longueur suppl\u00e9mentaire lors de la d\u00e9r\u00e9traction, et ceci est r\u00e9gl\u00e9 via UNRETRACT_EXTRA_LENGTH. SET_RETRACTION est g\u00e9n\u00e9ralement d\u00e9fini dans le cadre de la configuration du slicer par filament, car les diff\u00e9rents filaments n\u00e9cessitent des param\u00e8tres diff\u00e9rents.","title":"SET_RETRACTION"},{"location":"G-Codes.html#get_retraction","text":"GET_RETRACTION : Interroge les param\u00e8tres actuellement utilis\u00e9s pour la r\u00e9traction du firmware et les affiche sur le terminal.","title":"GET_RETRACTION"},{"location":"G-Codes.html#force_move","text":"Le module force_move est automatiquement charg\u00e9, mais certaines commandes n\u00e9cessitent de d\u00e9finir enable_force_move dans la configuration de l'imprimante .","title":"[force_move]"},{"location":"G-Codes.html#stepper_buzz","text":"STEPPER_BUZZ STEPPER=<nom_de_la_configuration> : D\u00e9place le moteur donn\u00e9 en avant d'un mm puis en arri\u00e8re d'un mm, r\u00e9p\u00e9t\u00e9 10 fois. Il s'agit d'un outil de diagnostic permettant de v\u00e9rifier la connectivit\u00e9 du moteur.","title":"STEPPER_BUZZ"},{"location":"G-Codes.html#force_move_1","text":"FORCE_MOVE STEPPER=<nom_de_la_configuration> DISTANCE=<valeur> VELOCITE=<valeur> [ACCEL=<valeur>] : Cette commande forcera le d\u00e9placement du stepper donn\u00e9 sur la distance donn\u00e9e (en mm) \u00e0 la vitesse constante donn\u00e9e (en mm/s). Si ACCEL est sp\u00e9cifi\u00e9 et est sup\u00e9rieur \u00e0 z\u00e9ro, alors l'acc\u00e9l\u00e9ration donn\u00e9e (en mm/s^2) sera utilis\u00e9e ; sinon, aucune acc\u00e9l\u00e9ration n'est effectu\u00e9e. Aucune v\u00e9rification des limites n'est effectu\u00e9e ; aucune mise \u00e0 jour cin\u00e9matique n'est faite ; les autres steppers parall\u00e8les sur un axe ne seront pas d\u00e9plac\u00e9s. Soyez prudent car une commande incorrecte pourrait endommager le mat\u00e9riel ! L'utilisation de cette commande placera presque certainement la cin\u00e9matique de bas niveau dans un \u00e9tat incorrect ; \u00e9mettez ensuite un G28 pour r\u00e9initialiser la cin\u00e9matique. Cette commande est destin\u00e9e aux diagnostics de bas niveau et au d\u00e9bogage.","title":"FORCE_MOVE"},{"location":"G-Codes.html#set_kinematic_position","text":"SET_KINEMATIC_POSITION [X=<value>] [Y=<value>] [Z=<value>] : Force le code cin\u00e9matique de bas niveau \u00e0 croire que la t\u00eate d'outil est \u00e0 la position cart\u00e9sienne donn\u00e9e. Il s'agit d'une commande de diagnostic et de d\u00e9bogage ; utilisez SET_GCODE_OFFSET et/ou G92 pour des transformations d'axe r\u00e9guli\u00e8res. Si un axe n'est pas sp\u00e9cifi\u00e9, la position par d\u00e9faut sera celle de la derni\u00e8re commande de la t\u00eate. La d\u00e9finition d'une position incorrecte ou invalide peut entra\u00eener des erreurs logicielles internes. Cette commande peut invalider les futures v\u00e9rifications de limites ; \u00e9mettez ensuite un G28 pour r\u00e9initialiser la cin\u00e9matique.","title":"SET_KINEMATIC_POSITION"},{"location":"G-Codes.html#gcode","text":"Le module gcode est automatiquement charg\u00e9.","title":"[gcode]"},{"location":"G-Codes.html#restart","text":"RESTART : Cette commande permet au logiciel h\u00f4te de recharger sa configuration et d'effectuer une r\u00e9initialisation interne. Cette commande n'efface pas l'\u00e9tat d'erreur du micro-contr\u00f4leur (voir FIRMWARE_RESTART) et ne charge pas de nouveau logiciel (voir la FAQ ).","title":"RESTART"},{"location":"G-Codes.html#firmware_restart","text":"FIRMWARE_RESTART : Cette commande est similaire \u00e0 un RESTART, mais elle efface \u00e9galement tout \u00e9tat d'erreur du micro-contr\u00f4leur.","title":"FIRMWARE_RESTART"},{"location":"G-Codes.html#status","text":"STATUS : Indique l'\u00e9tat du logiciel de l'h\u00f4te Klipper.","title":"STATUS"},{"location":"G-Codes.html#help","text":"HELP : Affiche la liste des commandes G-Code \u00e9tendues disponibles.","title":"HELP"},{"location":"G-Codes.html#gcode_arcs","text":"Les commandes G-Code standard suivantes sont disponibles si une section gcode_arcs config est activ\u00e9e : D\u00e9placement d'un arc dans le sens des aiguilles d'une montre (G2), d\u00e9placement d'un arc dans le sens inverse des aiguilles d'une montre (G3) : G2|G3 [X<pos>] [Y<pos>] [Z<pos>] [E<pos>] [F<speed>] I<value> J<value>|I<value> K<value>|J<value> K<value> S\u00e9lection du plan de l'arc : G17 (plan XY), G18 (plan XZ), G19 (plan YZ)","title":"[gcode_arcs]"},{"location":"G-Codes.html#gcode_macro","text":"La commande suivante est disponible lorsqu'une section de configuration gcode_macro est activ\u00e9e (voir \u00e9galement le guide des mod\u00e8les de commande ).","title":"[gcode_macro]"},{"location":"G-Codes.html#set_gcode_variable","text":"SET_GCODE_VARIABLE MACRO=<macro_name> VARIABLE=<name> VALUE=<value> : Cette commande permet de changer la valeur d'une variable gcode_macro au moment de l'ex\u00e9cution. La valeur fournie est analys\u00e9e comme un litt\u00e9ral Python.","title":"SET_GCODE_VARIABLE"},{"location":"G-Codes.html#gcode_move","text":"Le module gcode_move est automatiquement charg\u00e9.","title":"[gcode_move]"},{"location":"G-Codes.html#get_position","text":"GET_POSITION : Retourne les informations de l'emplacement actuel de la t\u00eate d'outil. Voir la documentation du d\u00e9veloppeur de restitution de GET_POSITION pour plus d'informations.","title":"GET_POSITION"},{"location":"G-Codes.html#set_gcode_offset","text":"SET_GCODE_OFFSET [X=<pos>|X_ADJUST=<adjust>] [Y=<pos>|Y_ADJUST=<adjust>] [Z=<pos>|Z_ADJUST=<adjust>] [MOVE=1 [MOVE_SPEED=<speed>]] : D\u00e9finit un d\u00e9calage positionnel \u00e0 appliquer aux futures commandes G-Code. Ceci est g\u00e9n\u00e9ralement utilis\u00e9 pour changer virtuellement le d\u00e9calage Z du bed ou pour d\u00e9finir les d\u00e9calages XY des buses lors du changement d'extrudeur. Par exemple, si \"SET_GCODE_OFFSET Z=0.2\" est donn\u00e9, les prochains mouvements G-Code auront 0,2mm ajout\u00e9 \u00e0 leur hauteur Z. Si les param\u00e8tres de style X_ADJUST sont utilis\u00e9s, l'ajustement sera ajout\u00e9 \u00e0 tout d\u00e9calage existant (par exemple, \"SET_GCODE_OFFSET Z=-0.2\" suivi de \"SET_GCODE_OFFSET Z_ADJUST=0.3\" donnerait un d\u00e9calage Z total de 0.1). Si \"MOVE=1\" est sp\u00e9cifi\u00e9, un d\u00e9placement de la t\u00eate d'outil sera effectu\u00e9 pour appliquer le d\u00e9calage donn\u00e9 (sinon le d\u00e9calage prendra effet lors du prochain d\u00e9placement absolu en G-code qui sp\u00e9cifie l'axe donn\u00e9). Si \"MOVE_SPEED\" est sp\u00e9cifi\u00e9, le d\u00e9placement de la t\u00eate d'outil sera effectu\u00e9 avec la vitesse donn\u00e9e (en mm/s) ; sinon, le d\u00e9placement de la t\u00eate d'outil utilisera la derni\u00e8re vitesse G-Code sp\u00e9cifi\u00e9e.","title":"SET_GCODE_OFFSET"},{"location":"G-Codes.html#save_gcode_state","text":"SAVE_GCODE_STATE [NAME=<nom_de_l'\u00e9tat>] : Sauvegarde l'\u00e9tat actuel de l'analyse des coordonn\u00e9es du g-code. La sauvegarde et le r\u00e9tablissement de l'\u00e9tat du g-code sont utiles dans les scripts et les macros. Cette commande enregistre le mode actuel de coordonn\u00e9es absolues en g-code (G90/G91), le mode d'extrusion absolue (M82/M83), l'origine (G92), le d\u00e9calage (SET_GCODE_OFFSET), la priorit\u00e9 de vitesse (M220), la priorit\u00e9 d'extrusion (M221), la vitesse de d\u00e9placement, la position XYZ actuelle et la position relative de l'extrudeuse \"E\". Si NOM est fourni, cela permet de nommer l'\u00e9tat sauvegard\u00e9 avec la cha\u00eene de caract\u00e8res donn\u00e9e. Si le NOM n'est pas fourni, la valeur par d\u00e9faut est \"default\".","title":"SAVE_GCODE_STATE"},{"location":"G-Codes.html#restore_gcode_state","text":"RESTORE_GCODE_STATE [NAME=<nom_de_l'\u00e9tat>] [MOVE=1 [MOVE_SPEED=<speed>]] : Restaure un \u00e9tat pr\u00e9c\u00e9demment sauvegard\u00e9 via SAVE_GCODE_STATE. Si \"MOVE=1\" est sp\u00e9cifi\u00e9, un d\u00e9placement de la t\u00eate d'outil sera effectu\u00e9 pour revenir \u00e0 la position XYZ pr\u00e9c\u00e9dente. Si \"MOVE_SPEED\" est sp\u00e9cifi\u00e9, alors le d\u00e9placement de la t\u00eate d'outil sera effectu\u00e9 avec la vitesse donn\u00e9e (en mm/s) ; sinon, le d\u00e9placement de la t\u00eate d'outil utilisera la vitesse du G-Code restaur\u00e9.","title":"RESTORE_GCODE_STATE"},{"location":"G-Codes.html#hall_filament_width_sensor","text":"Les commandes suivantes sont disponibles lorsque la section de configuration tsl1401cl filament width sensor ou hall filament width sensor est activ\u00e9e (voir \u00e9galement TSLl401CL Filament Width Sensor et Hall Filament Width Sensor ) :","title":"[hall_filament_width_sensor]"},{"location":"G-Codes.html#query_filament_width","text":"QUERY_FILAMENT_WIDTH : Renvoie la largeur actuelle du filament mesur\u00e9.","title":"QUERY_FILAMENT_WIDTH"},{"location":"G-Codes.html#reset_filament_width_sensor","text":"RESET_FILAMENT_WIDTH_SENSOR : Efface toutes les lectures du capteur. Utile apr\u00e8s un changement de filament.","title":"RESET_FILAMENT_WIDTH_SENSOR"},{"location":"G-Codes.html#disable_filament_width_sensor","text":"DISABLE_FILAMENT_WIDTH_SENSOR : D\u00e9sactiver le capteur de largeur de filament et arr\u00eater de l'utiliser pour le contr\u00f4le du flux.","title":"DISABLE_FILAMENT_WIDTH_SENSOR"},{"location":"G-Codes.html#enable_filament_width_sensor","text":"ENABLE_FILAMENT_WIDTH_SENSOR : Activez le capteur de largeur de filament et commencez \u00e0 l'utiliser pour le contr\u00f4le du flux.","title":"ENABLE_FILAMENT_WIDTH_SENSOR"},{"location":"G-Codes.html#query_raw_filament_width","text":"QUERY_RAW_FILAMENT_WIDTH : Renvoie les lectures actuelles des canaux ADC et la valeur RAW du capteur des points de calibration.","title":"QUERY_RAW_FILAMENT_WIDTH"},{"location":"G-Codes.html#enable_filament_width_log","text":"ENABLE_FILAMENT_WIDTH_LOG : Activer la journalisation du diam\u00e8tre.","title":"ENABLE_FILAMENT_WIDTH_LOG"},{"location":"G-Codes.html#disable_filament_width_log","text":"DISABLE_FILAMENT_WIDTH_LOG : D\u00e9sactiver la journalisation du diam\u00e8tre.","title":"DISABLE_FILAMENT_WIDTH_LOG"},{"location":"G-Codes.html#heaters","text":"Le module chauffages est automatiquement charg\u00e9 si un chauffage est d\u00e9fini dans le fichier de configuration.","title":"[heaters]"},{"location":"G-Codes.html#turn_off_heaters","text":"TURN_OFF_HEATERS : \u00c9teindre tous les chauffages.","title":"TURN_OFF_HEATERS"},{"location":"G-Codes.html#temperature_wait","text":"TEMPERATURE_WAIT SENSOR=<nom_config> [MINIMUM=<cible>] [MAXIMUM=<cible>] : Attend jusqu'\u00e0 ce que le capteur de temp\u00e9rature donn\u00e9 soit \u00e0 ou au-dessus du MINIMUM fourni et/ou \u00e0 ou en dessous du MAXIMUM fourni.","title":"TEMPERATURE_WAIT"},{"location":"G-Codes.html#set_heater_temperature","text":"SET_HEATER_TEMPERATURE HEATER=<nom_du_chauffeur> [TARGET=<temp\u00e9rature_cible>] : D\u00e9finit la temp\u00e9rature cible d'un \u00e9l\u00e9ment chauffant. Si une temp\u00e9rature cible n'est pas fournie, la cible est 0.","title":"SET_HEATER_TEMPERATURE"},{"location":"G-Codes.html#idle_timeout","text":"Le module idle_timeout est automatiquement charg\u00e9.","title":"[idle_timeout]"},{"location":"G-Codes.html#set_idle_timeout","text":"SET_IDLE_TIMEOUT [TIMEOUT=<timeout>] : Permet \u00e0 l'utilisateur de d\u00e9finir le d\u00e9lai d'inactivit\u00e9 (en secondes).","title":"SET_IDLE_TIMEOUT"},{"location":"G-Codes.html#input_shaper","text":"La commande suivante est activ\u00e9e si une section de configuration input_shaper a \u00e9t\u00e9 activ\u00e9e (voir \u00e9galement le guide de compensation de r\u00e9sonance ).","title":"[input_shaper]"},{"location":"G-Codes.html#set_input_shaper","text":"SET_INPUT_SHAPER [SHAPER_FREQ_X=<shaper_freq_x>] [SHAPER_FREQ_Y=<shaper_freq_y>] [DAMPING_RATIO_X=<damping_ratio_x>] [DAMPING_RATIO_Y=<damping_ratio_y>] [SHAPER_TYPE=<shaper>] [SHAPER_TYPE_X=<shaper_type_x>] [SHAPER_TYPE_Y=<shaper_type_y>] : Modifie les param\u00e8tres de mise en forme d'entr\u00e9e. Notez que le param\u00e8tre SHAPER_TYPE r\u00e9initialise le shaper d'entr\u00e9e pour les axes X et Y m\u00eame si diff\u00e9rents types de shaper ont \u00e9t\u00e9 configur\u00e9s dans la section [input_shaper]. SHAPER_TYPE ne peut pas \u00eatre utilis\u00e9 avec l'un des param\u00e8tres SHAPER_TYPE_X et SHAPER_TYPE_Y. Voir config reference pour plus de d\u00e9tails sur chacun de ces param\u00e8tres.","title":"SET_INPUT_SHAPER"},{"location":"G-Codes.html#manual_probe","text":"Le module manual_probe est automatiquement charg\u00e9.","title":"[manual_probe]"},{"location":"G-Codes.html#manual_probe_1","text":"MANUAL_PROBE [SPEED=<speed>] : Ex\u00e9cute un script d'aide servant \u00e0 mesurer la hauteur de la buse \u00e0 un point donn\u00e9. Si SPEED est sp\u00e9cifi\u00e9, il d\u00e9finit la vitesse des commandes TESTZ (la valeur par d\u00e9faut est 5mm/s). Pendant un sondage manuel, les commandes suppl\u00e9mentaires suivantes sont disponibles : ACCEPT : Cette commande valide la position Z actuelle et met fin au sondage manuel. ABORT : Cette commande interrompt le sondage manuel. TESTZ Z=<valeur> : Cette commande d\u00e9place la buse vers le haut ou vers le bas de la quantit\u00e9 sp\u00e9cifi\u00e9e dans \"valeur\". Par exemple, TESTZ Z=-.1 d\u00e9placera la buse vers le bas de 0,1mm tandis que TESTZ Z=.1 d\u00e9placera la buse vers le haut de 0,1mm. La valeur peut \u00e9galement \u00eatre + , - , ++ , ou -- pour d\u00e9placer la buse vers le haut ou vers le bas d'une quantit\u00e9 relative aux tentatives pr\u00e9c\u00e9dentes.","title":"MANUAL_PROBE"},{"location":"G-Codes.html#z_endstop_calibrate","text":"Z_ENDSTOP_CALIBRATE [SPEED=<vitesse>] : Ex\u00e9cute un script d'assistance utile pour calibrer un param\u00e8tre de configuration de la position Z_endstop. Voir la commande MANUAL_PROBE pour plus de d\u00e9tails sur les param\u00e8tres et les commandes suppl\u00e9mentaires disponibles lorsque l'outil est actif.","title":"Z_ENDSTOP_CALIBRATE"},{"location":"G-Codes.html#z_offset_apply_endstop","text":"Z_OFFSET_APPLY_ENDSTOP : Prend le d\u00e9calage actuel du Gcode Z (alias, babystepping), et le soustrait de la position endstop_position d\u00e9finie dans stepper_z. Ceci permet de prendre une valeur de babystepping fr\u00e9quemment utilis\u00e9e, et de la rendre permanente. N\u00e9cessite un SAVE_CONFIG pour prendre effet.","title":"Z_OFFSET_APPLY_ENDSTOP"},{"location":"G-Codes.html#manual_stepper","text":"La commande suivante est disponible lorsqu'une section manual_stepper config est activ\u00e9e.","title":"[manual_stepper]"},{"location":"G-Codes.html#manual_stepper_1","text":"MANUAL_STEPPER STEPPER=nom_du_config [ENABLE=[0|1]]] [SET_POSITION=<pos>] [SPEED=<speed>] [ACCEL=<accel>] [MOVE=<pos> [STOP_ON_ENDSTOP=[1|2|-1|-2]] [SYNC=0]] : Cette commande modifie l'\u00e9tat du stepper. Utilisez le param\u00e8tre ENABLE pour activer/d\u00e9sactiver le stepper. Utilisez le param\u00e8tre SET_POSITION pour forcer le moteur pas \u00e0 pas \u00e0 penser qu'il se trouve \u00e0 la position donn\u00e9e. Utilisez le param\u00e8tre MOVE pour d\u00e9placer vers la position donn\u00e9e. Si SPEED et/ou ACCEL sont sp\u00e9cifi\u00e9s, les valeurs donn\u00e9es seront utilis\u00e9es \u00e0 la place de celles par d\u00e9faut issues du fichier de configuration. Si un ACCEL de z\u00e9ro est sp\u00e9cifi\u00e9, aucune acc\u00e9l\u00e9ration ne sera effectu\u00e9e. Si STOP_ON_ENDSTOP=1 est sp\u00e9cifi\u00e9, le d\u00e9placement se terminera pr\u00e9matur\u00e9ment si la fin de course est d\u00e9clench\u00e9e (utilisez STOP_ON_ENDSTOP=2 pour terminer le d\u00e9placement sans erreur m\u00eame si la fin de course n'est pas d\u00e9clench\u00e9e, utilisez -1 ou -2 pour s'arr\u00eater lorsque la fin de course n'est pas d\u00e9clench\u00e9e). Normalement, les futures commandes G-Code seront programm\u00e9es pour \u00eatre ex\u00e9cut\u00e9es apr\u00e8s la fin du d\u00e9placement de la commande de pas, mais si un d\u00e9placement manuel de la commande de pas utilise SYNC=0, les futures commandes de d\u00e9placement G-Code peuvent \u00eatre ex\u00e9cut\u00e9es en parall\u00e8le avec le d\u00e9placement de la commande de pas.","title":"MANUAL_STEPPER"},{"location":"G-Codes.html#mcp4018","text":"La commande suivante est disponible lorsqu'une section mcp4018 config est activ\u00e9e.","title":"[mcp4018]"},{"location":"G-Codes.html#set_digipot","text":"SET_DIGIPOT DIGIPOT=config_name WIPER=<valeur> : Cette commande change la valeur actuelle du digipot. Cette valeur devrait typiquement \u00eatre comprise entre 0.0 et 1.0, \u00e0 moins qu'une '\u00e9chelle' soit d\u00e9finie dans la configuration. Lorsque 'scale' est d\u00e9fini, alors cette valeur doit \u00eatre comprise entre 0.0 et 'scale'.","title":"SET_DIGIPOT"},{"location":"G-Codes.html#led","text":"La commande suivante est disponible lorsque l'une des sections led config est activ\u00e9e.","title":"[led]"},{"location":"G-Codes.html#set_led","text":"SET_LED LED=<nom_de_la_configuration> RED=<valeur> GREEN=<valeur> BLUE=<valeur> WHITE=<valeur> [INDEX=<index>] [TRANSMIT=0] [SYNC=1] : Ceci d\u00e9finit la sortie de la LED. Chaque <valeur> de couleur doit \u00eatre comprise entre 0.0 et 1.0. L'option WHITE n'est valable que pour les LEDs RGBW. Si la LED supporte plusieurs puces dans une cha\u00eene, on peut sp\u00e9cifier INDEX pour modifier la couleur de la seule puce donn\u00e9e (1 pour la premi\u00e8re puce, 2 pour la seconde, etc.). Si INDEX n'est pas sp\u00e9cifi\u00e9, alors toutes les LEDs de la cha\u00eene seront r\u00e9gl\u00e9es sur la couleur fournie. Si TRANSMIT=0 est sp\u00e9cifi\u00e9, le changement de couleur ne sera effectu\u00e9 que lors de la prochaine commande SET_LED qui ne sp\u00e9cifie pas TRANSMIT=0 ; cela peut \u00eatre utile en combinaison avec le param\u00e8tre INDEX pour effectuer plusieurs mises \u00e0 jour dans une cha\u00eene. Par d\u00e9faut, la commande SET_LED synchronisera ses changements avec les autres commandes gcode en cours. Cela peut conduire \u00e0 un comportement ind\u00e9sirable si les LEDs sont r\u00e9gl\u00e9es alors que l'imprimante n'imprime pas, car cela r\u00e9initialisera le d\u00e9lai d'inactivit\u00e9. Si un timing pr\u00e9cis n'est pas n\u00e9cessaire, le param\u00e8tre optionnel SYNC=0 peut \u00eatre sp\u00e9cifi\u00e9 pour appliquer les changements sans r\u00e9initialiser le d\u00e9lai d'inactivit\u00e9.","title":"SET_LED"},{"location":"G-Codes.html#set_led_template","text":"SET_LED_TEMPLATE LED=<nom_de_la_led> TEMPLATE=<nom_du_mod\u00e8le> [<param_x>=<literal>] [INDEX=<index>] : Attribue un mod\u00e8le d'affichage \u00e0 une LED donn\u00e9e. Par exemple, si l'on d\u00e9finit une section de configuration [display_template my_led_template] , on peut affecter TEMPLATE=my_led_template ici. Le mod\u00e8le d'affichage doit produire une cha\u00eene de caract\u00e8res s\u00e9par\u00e9e par des virgules contenant quatre nombres \u00e0 virgule flottante correspondant aux param\u00e8tres de couleur rouge, vert, bleu et blanc. Le mod\u00e8le sera continuellement \u00e9valu\u00e9 et la LED sera automatiquement r\u00e9gl\u00e9e sur les couleurs r\u00e9sultantes. On peut d\u00e9finir des param\u00e8tres display_template \u00e0 utiliser pendant l'\u00e9valuation du mod\u00e8le (les param\u00e8tres seront analys\u00e9s comme des litt\u00e9raux Python). Si INDEX n'est pas sp\u00e9cifi\u00e9, alors toutes les puces dans la cha\u00eene de la LED seront r\u00e9gl\u00e9es sur le mod\u00e8le, sinon seule la puce avec l'index donn\u00e9 sera mise \u00e0 jour. Si TEMPLATE est une cha\u00eene vide, cette commande effacera tout mod\u00e8le pr\u00e9c\u00e9dent assign\u00e9 \u00e0 la LED (on peut alors utiliser les commandes SET_LED pour g\u00e9rer les param\u00e8tres de couleur de la LED).","title":"SET_LED_TEMPLATE"},{"location":"G-Codes.html#output_pin","text":"La commande suivante est disponible lorsqu'une section output_pin config est activ\u00e9e.","title":"[output_pin]"},{"location":"G-Codes.html#set_pin","text":"SET_PIN PIN=nom_config VALUE=<valeur> [CYCLE_TIME=<dur\u00e9e_du_cycle>] : Fixe la broche \u00e0 la sortie donn\u00e9e VALUE . VALUE doit \u00eatre 0 ou 1 pour les broches de sortie \"num\u00e9riques\". Pour les broches PWM, d\u00e9finissez une valeur entre 0.0 et 1.0, ou entre 0.0 et scale si une \u00e9chelle est configur\u00e9e dans la section output_pin config. Certaines broches (actuellement seulement les broches \"soft PWM\") supportent la d\u00e9finition d'un temps de cycle explicite en utilisant le param\u00e8tre CYCLE_TIME (sp\u00e9cifi\u00e9 en secondes). Notez que le param\u00e8tre CYCLE_TIME n'est pas stock\u00e9 entre les commandes SET_PIN (toute commande SET_PIN sans param\u00e8tre CYCLE_TIME explicite utilisera le cycle_time sp\u00e9cifi\u00e9 dans la section output_pin config).","title":"SET_PIN"},{"location":"G-Codes.html#palette2","text":"Les commandes suivantes sont disponibles lorsque la section palette2 config est activ\u00e9e. Les impressions avec Palette fonctionnent en int\u00e9grant des OCodes (Omega Codes) sp\u00e9ciaux dans le fichier GCode : O1 ... O32 : Ces codes sont lus \u00e0 partir du flux GCode, trait\u00e9s par ce module et transmis au dispositif Palette 2. Les commandes suppl\u00e9mentaires suivantes sont \u00e9galement disponibles.","title":"[palette2]"},{"location":"G-Codes.html#palette_connect","text":"PALETTE_CONNECT : Cette commande initie la connexion avec Palette 2.","title":"PALETTE_CONNECT"},{"location":"G-Codes.html#palette_disconnect","text":"PALETTE_DISCONNECT : Cette commande permet de se d\u00e9connecter de Palette 2.","title":"PALETTE_DISCONNECT"},{"location":"G-Codes.html#palette_clear","text":"PALETTE_CLEAR : Cette commande demande \u00e0 Palette 2 de purger le filament de tous les chemins d'entr\u00e9e et de sortie.","title":"PALETTE_CLEAR"},{"location":"G-Codes.html#palette_cut","text":"PALETTE_CUT : Cette commande demande \u00e0 Palette 2 de couper le filament actuellement charg\u00e9 dans le noyau de jonction.","title":"PALETTE_CUT"},{"location":"G-Codes.html#palette_smart_load","text":"PALETTE_SMART_LOAD : cette commande initialise la s\u00e9quence de chargement intelligente sur Palette 2. Le filament est charg\u00e9 automatiquement en l\u2019extrudant sur la distance calibr\u00e9e sur l\u2019appareil pour l\u2019imprimante, et l'indique \u00e0 Palette 2 une fois le chargement termin\u00e9. Cette commande revient \u00e0 appuyer sur Smart Load directement sur l\u2019\u00e9cran Palette 2 une fois l'insertion du filament faite.","title":"PALETTE_SMART_LOAD"},{"location":"G-Codes.html#pid_calibrate","text":"Le module pid_calibrate est automatiquement charg\u00e9 si un chauffage est d\u00e9fini dans le fichier de configuration.","title":"[pid_calibrate]"},{"location":"G-Codes.html#pid_calibrate_1","text":"PID_CALIBRATE HEATER=<config_name> TARGET=<temperature> [WRITE_FILE=1] : Effectuer un test d\u2019\u00e9talonnage PID. Le chauffage demand\u00e9 sera activ\u00e9 jusqu\u2019\u00e0 ce que la temp\u00e9rature d\u00e9finie soit atteinte, il s'\u00e9teindra et se rallumera durant plusieurs cycles. Si le param\u00e8tre WRITE_FILE est activ\u00e9, le fichier /tmp/heattest.txt sera cr\u00e9\u00e9 avec un journal de tous les \u00e9chantillons de temp\u00e9rature mesur\u00e9s pendant le test.","title":"PID_CALIBRATE"},{"location":"G-Codes.html#pause_resume","text":"Les commandes suivantes sont disponibles lorsque la section pause_resume config est activ\u00e9e :","title":"[pause_resume]"},{"location":"G-Codes.html#pause","text":"PAUSE : suspend l\u2019impression en cours. La position actuelle est enregistr\u00e9e pour reprendre lorsque demand\u00e9.","title":"PAUSE"},{"location":"G-Codes.html#resume","text":"RESUME [VELOCITY=<value>] : Reprend l'impression \u00e0 la suite d'une pause, en r\u00e9tablissant d'abord la position captur\u00e9e pr\u00e9c\u00e9demment. Le param\u00e8tre VELOCITY d\u00e9termine la vitesse \u00e0 laquelle l'outil doit revenir \u00e0 la position captur\u00e9e d'origine.","title":"RESUME"},{"location":"G-Codes.html#clear_pause","text":"CLEAR_PAUSE : Supprime la mise en pause actuelle sans reprendre l'impression. Ceci est utile si l'on d\u00e9cide d'interrompre une impression apr\u00e8s une PAUSE. Il est recommand\u00e9 d'ajouter ceci \u00e0 votre gcode de d\u00e9marrage pour s'assurer que l'\u00e9tat de pause est r\u00e9initialis\u00e9 pour chaque impression.","title":"CLEAR_PAUSE"},{"location":"G-Codes.html#cancel_print","text":"CANCEL_PRINT : Annule l'impression en cours.","title":"CANCEL_PRINT"},{"location":"G-Codes.html#print_stats","text":"Le module print_stats est automatiquement charg\u00e9.","title":"[print_stats]"},{"location":"G-Codes.html#set_print_stats_info","text":"SET_PRINT_STATS_INFO [TOTAL_LAYER=<nombre_total_de_couches>] [CURRENT_LAYER= <couche_actuelle>] : Passe les informations du trancheur comme le nombre total de couches et celle actuellement en cours \u00e0 Klipper. Ajoutez SET_PRINT_STATS_INFO [TOTAL_LAYER=<nombre_total_de_couches>] \u00e0 votre section gcode de d\u00e9but du trancheur et SET_PRINT_STATS_INFO [CURRENT_LAYER= <couche_actuelle>] \u00e0 la section gcode de changement de couche pour passer les informations de couche de votre trancheur \u00e0 Klipper.","title":"SET_PRINT_STATS_INFO"},{"location":"G-Codes.html#probe","text":"Les commandes suivantes sont disponibles lorsqu'une section probe config ou bltouch config est activ\u00e9e (voir \u00e9galement le guide d'\u00e9talonnage de la sonde ).","title":"[probe]"},{"location":"G-Codes.html#probe_1","text":"PROBE [PROBE_SPEED=<mm/s>] [LIFT_SPEED=<mm/s>] [SAMPLES=<count>] [SAMPLE_RETRACT_DIST=<mm>] [SAMPLES_TOLERANCE=<mm>] [SAMPLES_TOLERANCE_RETRIES=<count>] [SAMPLES_RESULT=median|average] : D\u00e9place la buse vers le bas jusqu'\u00e0 ce que le palpeur se d\u00e9clenche. Si l'un des param\u00e8tres facultatifs est fourni, il remplace son param\u00e8tre \u00e9quivalent dans la section configuration de la sonde .","title":"PROBE"},{"location":"G-Codes.html#query_probe","text":"QUERY_PROBE : Retourne l'\u00e9tat actuel de la sonde (\"triggered\" ou \"open\").","title":"QUERY_PROBE"},{"location":"G-Codes.html#probe_accuracy","text":"PROBE_ACCURACY [PROBE_SPEED=<mm/s>] [SAMPLES=<count>] [SAMPLE_RETRACT_DIST=<mm>] : Calculer le maximum, le minimum, la moyenne, la m\u00e9diane et l\u2019\u00e9cart type des \u00e9chantillons des multiples palpeurs. Par d\u00e9faut, 10 \u00c9CHANTILLONS sont pr\u00e9lev\u00e9s. Sinon, les param\u00e8tres optionnels peuvent \u00eatre d\u00e9finis dans la section de configuration du palpeur.","title":"PROBE_ACCURACY"},{"location":"G-Codes.html#probe_calibrate","text":"PROBE_CALIBRATE [SPEED=<speed>] [<probe_parameter>=<value>] : Ex\u00e9cute l'assistant servant \u00e0 calibrer le z_offset du palpeur. Consultez la commande PROBE pour plus d\u2019informations sur les param\u00e8tres optionnels du palpeur. Reportez-vous \u00e0 la commande MANUAL_PROBE pour plus d\u2019informations sur le param\u00e8tre SPEED et les commandes suppl\u00e9mentaires disponibles lorsque l'assistant est actif. Veuillez noter que la commande PROBE_CALIBRATE utilise la variable de vitesse pour se d\u00e9placer dans la direction XY ainsi que dans Z.","title":"PROBE_CALIBRATE"},{"location":"G-Codes.html#z_offset_apply_probe","text":"Z_OFFSET_APPLY_PROBE : Prend le d\u00e9calage actuel du Gcode Z (alias, babystepping), et le soustrait du z_offset de la sonde. Cela permet de prendre une valeur de babystepping fr\u00e9quemment utilis\u00e9e, et de la rendre permanente. N\u00e9cessite un SAVE_CONFIG pour prendre effet.","title":"Z_OFFSET_APPLY_PROBE"},{"location":"G-Codes.html#query_adc","text":"Le module query_adc est automatiquement charg\u00e9.","title":"[query_adc]"},{"location":"G-Codes.html#query_adc_1","text":"QUERY_ADC [NAME=<nom_de_la_configuration>] [PULLUP=<valeur>] : Rapporte la derni\u00e8re valeur analogique re\u00e7ue pour une broche analogique donn\u00e9e. Si NAME n'est pas fourni, la liste des noms d'adc disponibles est retourn\u00e9e. Si PULLUP est fourni (comme une valeur en Ohms), la valeur analogique brute ainsi que la r\u00e9sistance \u00e9quivalente relative \u00e0 ce pullup est retourn\u00e9e.","title":"QUERY_ADC"},{"location":"G-Codes.html#query_endstops","text":"Le module query_endstops est automatiquement charg\u00e9. Les commandes G-Code standard suivantes sont actuellement disponibles, mais leur utilisation n'est pas recommand\u00e9e : Obtenir le statut Fin de course : M119 (Utilisez QUERY_ENDSTOPS \u00e0 la place.)","title":"[query_endstops]"},{"location":"G-Codes.html#query_endstops_1","text":"QUERY_ENDSTOPS : Teste les but\u00e9es d'axe et indique si elles sont \"d\u00e9clench\u00e9es\" ou dans un \u00e9tat \"ouvert\". Cette commande est g\u00e9n\u00e9ralement utilis\u00e9e pour v\u00e9rifier qu'un butoir de fin de course fonctionne correctement.","title":"QUERY_ENDSTOPS"},{"location":"G-Codes.html#resonance_tester","text":"Les commandes suivantes sont disponibles lorsqu'une section configuration du testeur de r\u00e9sonances est activ\u00e9e (voir \u00e9galement le guide de mesure des r\u00e9sonances ).","title":"[resonance_tester]"},{"location":"G-Codes.html#measure_axes_noise","text":"MEASURE_AXES_NOISE : Mesure et affiche le bruit pour tous les axes de toutes les puces acc\u00e9l\u00e9rom\u00e9triques activ\u00e9es.","title":"MEASURE_AXES_NOISE"},{"location":"G-Codes.html#test_resonances","text":"TEST_RESONANCES AXE=<axe> OUTPUT=<resonances,raw_data> [NOM=<nom>] [FREQ_START=<freq_min>] [FREQ_END=<freq_max>] [HZ_PER_SEC=<hz_par_sec>] [CHIPS=<nom_puce_adxl345>] [POINT=x,y,z] [INPUT_SHAPING=[<0:1>]] : Ex\u00e9cute le test de r\u00e9sonance dans tous les points de sonde configur\u00e9s pour l'\"axe\" demand\u00e9 et mesure l'acc\u00e9l\u00e9ration en utilisant les puces acc\u00e9l\u00e9rom\u00e9tres configur\u00e9es pour l'axe respectif. L'\"axe\" peut \u00eatre X ou Y, ou sp\u00e9cifier une direction arbitraire comme AXIS=dx,dy , o\u00f9 dx et dy sont des nombres \u00e0 virgule flottante d\u00e9finissant un vecteur de direction (par exemple, AXIS=X , AXIS=Y , ou AXIS=1,-1 pour d\u00e9finir une direction diagonale). Notez que AXIS=dx,dy et AXIS=-dx,-dy sont \u00e9quivalents. nom_puce_adxl345 peut \u00eatre une ou plusieurs puces adxl345 configur\u00e9es, d\u00e9limit\u00e9es par des virgules, par exemple CHIPS=\"adxl345, adxl345 rpi\" . Notez que le terme adxl345 peut \u00eatre omis pour les puces adxl345 nomm\u00e9es. Si POINT est indiqu\u00e9, il remplacera le(s) point(s) configur\u00e9(s) dans [resonance_tester] . Si INPUT_SHAPING=0 ou non d\u00e9fini (par d\u00e9faut), d\u00e9sactive la mise en forme de l'entr\u00e9e pour le test de r\u00e9sonance, car il n'est pas valide d'ex\u00e9cuter le test de r\u00e9sonance avec la mise en forme de l'entr\u00e9e active. Le param\u00e8tre OUTPUT consiste en une liste s\u00e9par\u00e9e par des virgules des sorties qui seront \u00e9crites. Si raw_data est demand\u00e9, alors les donn\u00e9es brutes de l'acc\u00e9l\u00e9rom\u00e8tre sont \u00e9crites dans un fichier ou une s\u00e9rie de fichiers /tmp/raw_data_<axe>_[<nom_puce>_][<point>_]<nom>.csv avec (la partie <point>_ du nom g\u00e9n\u00e9r\u00e9e seulement si plus d'un point de sonde est configur\u00e9 ou si POINT est sp\u00e9cifi\u00e9). Si resonances est sp\u00e9cifi\u00e9, la r\u00e9ponse en fr\u00e9quence est calcul\u00e9e (\u00e0 travers tous les points de sonde) et \u00e9crite dans le fichier /tmp/resonances_<axe>_<nom>.csv . S'il n'est pas d\u00e9fini, OUTPUT prend par d\u00e9faut la valeur de resonances , et NAME prend par d\u00e9faut la valeur de l'heure actuelle au format \"AAAAMMJJ_HHMMSS\".","title":"TEST_RESONANCES"},{"location":"G-Codes.html#shaper_calibrate","text":"SHAPER_CALIBRATE [AXIS=<axis>] [NAME=<name>] [FREQ_START=<min_freq>] [FREQ_END=<max_freq>] [HZ_PER_SEC=<hz_per_sec>] [CHIPS=<adxl345_chip_name>] [MAX_SMOOTHING=<max_smoothing>] : Similarly to TEST_RESONANCES , runs the resonance test as configured, and tries to find the optimal parameters for the input shaper for the requested axis (or both X and Y axes if AXIS parameter is unset). If MAX_SMOOTHING is unset, its value is taken from [resonance_tester] section, with the default being unset. See the Max smoothing of the measuring resonances guide for more information on the use of this feature. The results of the tuning are printed to the console, and the frequency responses and the different input shapers values are written to a CSV file(s) /tmp/calibration_data_<axis>_<name>.csv . Unless specified, NAME defaults to the current time in \"YYYYMMDD_HHMMSS\" format. Note that the suggested input shaper parameters can be persisted in the config by issuing SAVE_CONFIG command, and if [input_shaper] was already enabled previously, these parameters take effect immediately.","title":"SHAPER_CALIBRATE"},{"location":"G-Codes.html#respond","text":"Les commandes G-Code standard suivantes sont disponibles lorsque la section respond config est activ\u00e9e : M118 <message> : affiche le message pr\u00e9c\u00e9d\u00e9 du pr\u00e9fixe par d\u00e9faut configur\u00e9 (ou echo : si aucun pr\u00e9fixe n'est configur\u00e9). Les commandes suppl\u00e9mentaires suivantes sont \u00e9galement disponibles.","title":"[respond]"},{"location":"G-Codes.html#respond_1","text":"RESPOND MSG=\"<message>\" : Affiche le message pr\u00e9c\u00e9d\u00e9 du pr\u00e9fixe par d\u00e9faut configur\u00e9 (ou echo : si aucun pr\u00e9fixe n'est configur\u00e9). RESPOND TYPE=echo MSG=\"<message>\" : affiche le message pr\u00e9c\u00e9d\u00e9 par echo : . RESPOND TYPE=echo_no_space MSG=\"<message>\" : renvoie le message pr\u00e9c\u00e9d\u00e9 de echo: sans espace entre le pr\u00e9fixe et le message, utile pour la compatibilit\u00e9 avec certains plugins octoprint qui attendent un formatage tr\u00e8s sp\u00e9cifique. RESPOND TYPE=command MSG=\"<message>\" : renvoie le message pr\u00e9c\u00e9d\u00e9 de // . OctoPrint peut \u00eatre configur\u00e9 pour r\u00e9pondre \u00e0 ces messages (par exemple, RESPOND TYPE=command MSG=action:pause ). RESPOND TYPE=error MSG=\"<message>\" : affiche le message pr\u00e9c\u00e9d\u00e9 par !!! . RESPOND PREFIX=<prefix> MSG=\"<message>\" : renvoie le message pr\u00e9c\u00e9d\u00e9 de <prefix> . (Le param\u00e8tre PREFIX est prioritaire sur le param\u00e8tre TYPE ).","title":"RESPOND"},{"location":"G-Codes.html#save_variables","text":"La commande suivante est activ\u00e9e si une section save_variables config a \u00e9t\u00e9 activ\u00e9e.","title":"[save_variables]"},{"location":"G-Codes.html#save_variable","text":"SAVE_VARIABLE VARIABLE=<nom> VALUE=<valeur> : Enregistre la variable sur le disque afin qu'elle puisse \u00eatre utilis\u00e9e lors des red\u00e9marrages. Toutes les variables enregistr\u00e9es sont charg\u00e9es dans le dict printer.save_variables.variables au d\u00e9marrage et peuvent \u00eatre utilis\u00e9es dans des macros gcode. La VALEUR fournie est analys\u00e9e comme un litt\u00e9ral Python.","title":"SAVE_VARIABLE"},{"location":"G-Codes.html#screws_tilt_adjust","text":"Les commandes suivantes sont disponibles lorsque la section de configuration screws_tilt_adjust est activ\u00e9e (voir \u00e9galement le guide du nivelage manuel ).","title":"[screws_tilt_adjust]"},{"location":"G-Codes.html#screws_tilt_calculate","text":"SCREWS_TILT_CALCULATE [DIRECTION=CW|CCW] [MAX_DEVIATION=<value>] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] : Cette commande appellera l'outil de r\u00e9glage des vis de r\u00e9glage du plateau. Elle d\u00e9placera la buse \u00e0 diff\u00e9rents endroits (tels que d\u00e9finis dans le fichier de configuration) en sondant la hauteur z et calculera le nombre de tours de vis n\u00e9cessaires pour ajuster le niveau du lit. Si DIRECTION est sp\u00e9cifi\u00e9, les rotations du bouton se feront toutes dans le m\u00eame sens, dans le sens des aiguilles d'une montre (CW) ou dans le sens inverse des aiguilles d'une montre (CCW). Voir la commande PROBE pour plus de d\u00e9tails sur les param\u00e8tres de sonde facultatifs. IMPORTANT : Vous DEVEZ toujours faire un G28 avant d'utiliser cette commande. Si MAX_DEVIATION est sp\u00e9cifi\u00e9, la commande g\u00e9n\u00e8re une erreur gcode si une diff\u00e9rence de hauteur de vis par rapport \u00e0 la hauteur de vis de base est sup\u00e9rieure \u00e0 la valeur fournie. La valeur facultative HORIZONTAL_MOVE_Z remplace l'option horizontal_move_z sp\u00e9cifi\u00e9e dans le fichier de configuration.","title":"SCREWS_TILT_CALCULATE"},{"location":"G-Codes.html#sdcard_loop","text":"Lorsque la section de configuration sdcard_loop est activ\u00e9e, les commandes \u00e9tendues suivantes sont disponibles.","title":"[sdcard_loop]"},{"location":"G-Codes.html#sdcard_loop_begin","text":"SDCARD_LOOP_BEGIN COUNT=<compte> : Commence une section boucl\u00e9e dans l'impression SD. Un compte de 0 indique que la section doit \u00eatre boucl\u00e9e ind\u00e9finiment.","title":"SDCARD_LOOP_BEGIN"},{"location":"G-Codes.html#sdcard_loop_end","text":"SDCARD_LOOP_END : Termine une section de boucle dans l'impression SD.","title":"SDCARD_LOOP_END"},{"location":"G-Codes.html#sdcard_loop_desist","text":"SDCARD_LOOP_DESIST : Termine les boucles existantes sans autres it\u00e9rations.","title":"SDCARD_LOOP_DESIST"},{"location":"G-Codes.html#servo","text":"Les commandes suivantes sont disponibles lorsqu'une section servo config est activ\u00e9e.","title":"[servo]"},{"location":"G-Codes.html#set_servo","text":"SET_SERVO SERVO=nom_config [ANGLE=<degr\u00e9s> | LARGEUR=<secondes>] : D\u00e9finit la position du servo \u00e0 l'angle (en degr\u00e9s) ou \u00e0 la largeur d'impulsion (en secondes) donn\u00e9s. Utilisez WIDTH=0 pour d\u00e9sactiver la sortie du servo.","title":"SET_SERVO"},{"location":"G-Codes.html#skew_correction","text":"Les commandes suivantes sont disponibles lorsque la section de configuration skew_correction est activ\u00e9e (voir \u00e9galement le guide Skew Correction ).","title":"[skew_correction]"},{"location":"G-Codes.html#set_skew","text":"SET_SKEW [XY=<ac_length,bd_length,ad_length>] [XZ=<ac,bd,ad>] [YZ=<ac,bd,ad>] [CLEAR=<0|1>] : Configure le module [skew_correction] avec des mesures (en mm) prises \u00e0 partir d'une impression d'\u00e9talonnage. On peut entrer des mesures pour n'importe quelle combinaison de plans, les plans non entr\u00e9s conserveront leur valeur actuelle. Si CLEAR=1 est entr\u00e9, toute correction d'inclinaison sera d\u00e9sactiv\u00e9e.","title":"SET_SKEW"},{"location":"G-Codes.html#get_current_skew","text":"GET_CURRENT_SKEW : Indique l'inclinaison actuelle de l'imprimante pour chaque plan en radians et en degr\u00e9s. L'inclinaison est calcul\u00e9e en fonction des param\u00e8tres fournis par le gcode SET_SKEW .","title":"GET_CURRENT_SKEW"},{"location":"G-Codes.html#calc_measured_skew","text":"CALC_MEASURED_SKEW [AC=<ac_length>] [BD=<bd_length>] [AD=<ad_length>] : Calcule et rapporte l'inclinaison (en radians et en degr\u00e9s) bas\u00e9e sur une impression mesur\u00e9e. Cela peut \u00eatre utile pour d\u00e9terminer l'inclinaison actuelle de l'imprimante apr\u00e8s l'application de la correction. Elle peut \u00e9galement \u00eatre utile avant l'application de la correction pour d\u00e9terminer si une correction de l'inclinaison est n\u00e9cessaire. Reportez-vous \u00e0 la section [Correction de l'obliquit\u00e9] (Skew_Correction.md) pour plus de d\u00e9tails sur les objets et les mesures de calibrage de l'obliquit\u00e9.","title":"CALC_MEASURED_SKEW"},{"location":"G-Codes.html#skew_profile","text":"SKEW_PROFILE [LOAD=<nom>] [SAVE=<nom>] [REMOVE=<nom>] : Gestion des profils pour la correction de l'obliquit\u00e9. LOAD restaurera l'\u00e9tat d'inclinaison \u00e0 partir du profil correspondant au nom fourni. SAVE sauvegardera l'\u00e9tat actuel d'inclinaison dans un profil correspondant au nom fourni. Remove supprimera le profil correspondant au nom fourni de la m\u00e9moire persistante. Notez qu'apr\u00e8s l'ex\u00e9cution des op\u00e9rations SAVE ou REMOVE, le gcode SAVE_CONFIG doit \u00eatre ex\u00e9cut\u00e9 pour que les modifications apport\u00e9es \u00e0 la m\u00e9moire permanente deviennent permanentes.","title":"SKEW_PROFILE"},{"location":"G-Codes.html#smart_effector","text":"Plusieurs commandes sont disponibles lorsqu'une section de configuration smart_effector est activ\u00e9e. Assurez-vous de consulter la documentation officielle du Smart Effector sur le Duet3D Wiki avant de modifier les param\u00e8tres du Smart Effector. Consultez \u00e9galement le guide d'\u00e9talonnage de la sonde .","title":"[smart_effector]"},{"location":"G-Codes.html#set_smart_effector","text":"SET_SMART_EFFECTOR [SENSITIVITY=<sensitivity>] [ACCEL=<accel>] [RECOVERY_TIME=<time>] : D\u00e9finit les param\u00e8tres du Smart Effector. Lorsque SENSITIVITY est sp\u00e9cifi\u00e9, la valeur respective est \u00e9crite dans l'EEPROM du SmartEffecteur (n\u00e9cessite que control_pin soit fourni). Les valeurs acceptables de <sensitivity> sont 0..255, la valeur par d\u00e9faut est 50. Des valeurs plus faibles n\u00e9cessitent moins de force de contact de la buse pour se d\u00e9clencher (mais il y a un plus grand risque de faux d\u00e9clenchement d\u00fb aux vibrations pendant le palpage), des valeurs plus \u00e9lev\u00e9es r\u00e9duisent les faux d\u00e9clenchements (mais n\u00e9cessitent une plus grande force de contact pour se d\u00e9clencher). Comme la sensibilit\u00e9 est \u00e9crite dans l'EEPROM, elle est conserv\u00e9e apr\u00e8s l'arr\u00eat, il n'est donc pas n\u00e9cessaire de la configurer \u00e0 chaque d\u00e9marrage de l'imprimante. ACCEL et RECOVERY_TIME permettent de modifier les param\u00e8tres correspondants lors de l'ex\u00e9cution, voir la section config de Smart Effector pour plus d'informations sur ces param\u00e8tres.","title":"SET_SMART_EFFECTOR"},{"location":"G-Codes.html#reset_smart_effector","text":"RESET_SMART_EFFECTOR : R\u00e9initialise la sensibilit\u00e9 du Smart Effector \u00e0 ses param\u00e8tres d'usine. N\u00e9cessite que control_pin soit fourni dans la section de configuration.","title":"RESET_SMART_EFFECTOR"},{"location":"G-Codes.html#stepper_enable","text":"Le module stepper_enable est automatiquement charg\u00e9.","title":"[stepper_enable]"},{"location":"G-Codes.html#set_stepper_enable","text":"SET_STEPPER_ENABLE STEPPER=<nom_de_la_configuration> ENABLE=[0|1] : Active ou d\u00e9sactive uniquement le stepper donn\u00e9. Il s'agit d'un outil de diagnostic et de d\u00e9bogage qui doit donc \u00eatre utilis\u00e9 avec pr\u00e9caution. La d\u00e9sactivation d'un moteur d'axe ne r\u00e9initialise pas les informations d'orientation. Le d\u00e9placement manuel d'un moteur pas \u00e0 pas d\u00e9sactiv\u00e9 peut amener la machine \u00e0 faire fonctionner le moteur en dehors des limites de s\u00e9curit\u00e9. Cela peut entra\u00eener des dommages aux composants de l'axe, aux extr\u00e9mit\u00e9s chaudes et \u00e0 la surface d'impression.","title":"SET_STEPPER_ENABLE"},{"location":"G-Codes.html#temperature_fan","text":"La commande suivante est disponible lorsqu'une section temperature_fan config est activ\u00e9e.","title":"[temperature_fan]"},{"location":"G-Codes.html#set_temperature_fan_target","text":"SET_TEMPERATURE_FAN_TARGET temperature_fan=<nom_du_ventilateur_temp\u00e9rature> [target=<temp\u00e9rature_cible>] [min_speed=<vitesse_min>] [max_speed=<vitesse_max>] : D\u00e9finit la temp\u00e9rature cible d'un ventilateur_temp\u00e9rature. Si une cible n'est pas fournie, elle est fix\u00e9e \u00e0 la temp\u00e9rature sp\u00e9cifi\u00e9e dans le fichier de configuration. Si les vitesses ne sont pas fournies, aucun changement n'est appliqu\u00e9.","title":"SET_TEMPERATURE_FAN_TARGET"},{"location":"G-Codes.html#tmcxxxx","text":"Les commandes suivantes sont disponibles lorsque l'une des sections tmcXXXX config est activ\u00e9e.","title":"[tmcXXXX]"},{"location":"G-Codes.html#dump_tmc","text":"DUMP_TMC STEPPER=<name> [REGISTER=<name>] : Cette commande lira tous les registres du pilote TMC et remontera leurs valeurs. Si un REGISTRE est fourni, seul le registre sp\u00e9cifi\u00e9 sera remont\u00e9.","title":"DUMP_TMC"},{"location":"G-Codes.html#init_tmc","text":"INIT_TMC STEPPER=<nom> : Cette commande initialise les registres de la puce TMC. N\u00e9cessaire pour r\u00e9activer le pilote si l'alimentation de la puce est coup\u00e9e puis r\u00e9tablie.","title":"INIT_TMC"},{"location":"G-Codes.html#set_tmc_current","text":"SET_TMC_CURRENT STEPPER=<name> CURRENT=<amps> HOLDCURRENT=<amps> : Cela ajustera les courants de fonctionnement et de maintien du pilote TMC. HOLDCURRENT ne s'applique pas aux pilotes tmc2660. Lorsqu'il est utilis\u00e9 sur un pilote qui a le champ globalscaler (tmc5160 et tmc2240), si StealthChop2 est utilis\u00e9, le stepper doit \u00eatre maintenu \u00e0 l'arr\u00eat pendant > 130 ms afin que le pilote ex\u00e9cute l'\u00e9talonnage AT#1.","title":"SET_TMC_CURRENT"},{"location":"G-Codes.html#set_tmc_field","text":"SET_TMC_FIELD STEPPER=<name> FIELD=<field> VALUE=<value> VELOCITY=<value> : cCette commande modifiera la valeur du champ de registre sp\u00e9cifi\u00e9 du pilote TMC. Cette commande est destin\u00e9e uniquement aux diagnostics de bas niveau et au d\u00e9bogage, car la modification des champs pendant l'ex\u00e9cution peut entra\u00eener un comportement ind\u00e9sirable et potentiellement dangereux de votre imprimante. Les modifications permanentes doivent \u00eatre effectu\u00e9es \u00e0 l'aide du fichier de configuration de l'imprimante \u00e0 la place. Aucune v\u00e9rification d'int\u00e9grit\u00e9 n'est effectu\u00e9e pour les valeurs donn\u00e9es. Une VITESSE peut \u00e9galement \u00eatre sp\u00e9cifi\u00e9e \u00e0 la place d'une VALEUR. Cette vitesse est convertie en repr\u00e9sentation de valeur bas\u00e9e sur TSTEP 20 bits. N'utilisez l'argument VELOCITY que pour les champs qui repr\u00e9sentent des vitesses.","title":"SET_TMC_FIELD"},{"location":"G-Codes.html#toolhead","text":"Le module de t\u00eate d'outil est automatiquement charg\u00e9.","title":"[toolhead]"},{"location":"G-Codes.html#set_velocity_limit","text":"SET_VELOCITY_LIMIT [VELOCITY=<valeur>] [ACCEL=<valeur>] [ACCEL_TO_DECEL=<valeur>] [SQUARE_CORNER_VELOCITY=<valeur>] : Modifie les limites de v\u00e9locit\u00e9 de l'imprimante.","title":"SET_VELOCITY_LIMIT"},{"location":"G-Codes.html#tuning_tower","text":"Le module tuning_tower est automatiquement charg\u00e9.","title":"[tuning_tower]"},{"location":"G-Codes.html#tuning_tower_1","text":"TUNING_TOWER COMMAND=<commande> PARAMETER=<nom> START=<valeur> [SKIP=<valeur>] [FACTOR=<valeur> [BAND=<valeur>]]. | [STEP_DELTA=<valeur> STEP_HEIGHT=<valeur>] : Un outil pour affiner un param\u00e8tre sur chaque hauteur Z pendant une impression. L'outil ex\u00e9cutera la COMMANDE donn\u00e9e avec le PARAM\u00c8TRE donn\u00e9 assign\u00e9 \u00e0 une valeur qui varie avec Z selon une formule. Utilisez FACTOR si vous allez utiliser une r\u00e8gle ou un pied \u00e0 coulisse pour mesurer la hauteur Z de la valeur optimale, ou STEP_DELTA et STEP_HEIGHT si le mod\u00e8le de tour de r\u00e9glage a des bandes de valeurs discr\u00e8tes comme c'est le cas avec les tours de temp\u00e9rature. Si SKIP=<valeur> est sp\u00e9cifi\u00e9, le processus de r\u00e9glage ne commence pas avant que la hauteur Z <valeur> soit atteinte, et en dessous, la valeur sera mise \u00e0 START ; dans ce cas, la z_height utilis\u00e9e dans les formules ci-dessous est en fait max(z - skip, 0) . Il y a trois combinaisons possibles d'options : FACTOR : La valeur change \u00e0 un taux de factor par millim\u00e8tre. La formule utilis\u00e9e est : valeur = start + factor * z_height . Vous pouvez ins\u00e9rer la hauteur Z optimale directement dans la formule pour d\u00e9terminer la valeur optimale du param\u00e8tre. FACTOR and BAND : La valeur change \u00e0 un taux moyen de factor par millim\u00e8tre, mais dans des bandes discr\u00e8tes o\u00f9 l'ajustement ne sera fait que tous les BAND millim\u00e8tres de hauteur Z. La formule utilis\u00e9e est : valeur =start + factor * ((floor(z_height / band) + .5) * band) . STEP_DELTA et STEP_HEIGHT : La valeur change de STEP_DELTA tous les millim\u00e8tres de STEP_HEIGHT . La formule utilis\u00e9e est : valeur = start + step_delta * floor(z_height / step_height) . Vous pouvez simplement compter les bandes ou lire les \u00e9tiquettes des tours de r\u00e9glage pour d\u00e9terminer la valeur optimale.","title":"TUNING_TOWER"},{"location":"G-Codes.html#virtual_sdcard","text":"Klipper prend en charge les commandes G-Code standards suivantes si la section de configuration virtual_sdcard est activ\u00e9e : Liste des cartes SD : M20 Initialiser la carte SD : M21 S\u00e9lectionnez le fichier SD : M23 <nom du fichier> D\u00e9marrer/reprendre l'impression SD : M24 Suspendre l'impression depuis la SD : M25 D\u00e9finir la position SD : M26 S<d\u00e9calage> Afficher l'\u00e9tat d'impression depuis la carte SD : M27 En outre, les commandes \u00e9tendues suivantes sont disponibles lorsque la section de configuration \"virtual_sdcard\" est activ\u00e9e.","title":"[virtual_sdcard]"},{"location":"G-Codes.html#sdcard_print_file","text":"SDCARD_PRINT_FILE FILENAME=<nom_fichier> : Charge un fichier et lance l'impression SD.","title":"SDCARD_PRINT_FILE"},{"location":"G-Codes.html#sdcard_reset_file","text":"SDCARD_RESET_FILE : D\u00e9charge le fichier et efface l'\u00e9tat de la carte SD.","title":"SDCARD_RESET_FILE"},{"location":"G-Codes.html#axis_twist_compensation","text":"The following commands are available when the axis_twist_compensation config section is enabled.","title":"[axis_twist_compensation]"},{"location":"G-Codes.html#axis_twist_compensation_calibrate","text":"AXIS_TWIST_COMPENSATION_CALIBRATE [SAMPLE_COUNT=<value>] : Initiates the X twist calibration wizard. SAMPLE_COUNT specifies the number of points along the X axis to calibrate at and defaults to 3.","title":"AXIS_TWIST_COMPENSATION_CALIBRATE"},{"location":"G-Codes.html#z_thermal_adjust","text":"Les commandes suivantes sont disponibles lorsque la section z_thermal_adjust config est activ\u00e9e.","title":"[z_thermal_adjust]"},{"location":"G-Codes.html#set_z_thermal_adjust","text":"SET_Z_THERMAL_ADJUST [ENABLE=<0:1>] [TEMP_COEFF=<valeur>] [REF_TEMP=<valeur>] : Active ou d\u00e9sactive l'ajustement thermique Z avec ENABLE . La d\u00e9sactivation ne supprime pas l'ajustement d\u00e9j\u00e0 appliqu\u00e9, mais g\u00e8le la valeur d'ajustement actuelle - cela emp\u00eache un mouvement Z vers le bas potentiellement dangereux. La r\u00e9activation peut potentiellement causer un mouvement de l'outil vers le haut lorsque l'ajustement est mis \u00e0 jour et appliqu\u00e9. TEMP_COEFF permet de r\u00e9gler le coefficient de temp\u00e9rature de l'ajustement en cours d'ex\u00e9cution (c'est-\u00e0-dire le param\u00e8tre de configuration TEMP_COEFF ). Les valeurs de TEMP_COEFF ne sont pas sauvegard\u00e9es dans la config. REF_TEMP remplace manuellement la temp\u00e9rature de r\u00e9f\u00e9rence g\u00e9n\u00e9ralement r\u00e9gl\u00e9e pendant le retour \u00e0 l'origine (pour une utilisation dans des routines de retour \u00e0 l'origine non standard) - sera remis \u00e0 z\u00e9ro automatiquement lors du retour \u00e0 l'origine.","title":"SET_Z_THERMAL_ADJUST"},{"location":"G-Codes.html#z_tilt","text":"Les commandes suivantes sont disponibles lorsque la section z_tilt config est activ\u00e9e.","title":"[z_tilt]"},{"location":"G-Codes.html#z_tilt_adjust","text":"Z_TILT_ADJUST [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] : Cette commande sondera les points sp\u00e9cifi\u00e9s dans la configuration, puis effectuera des ajustements ind\u00e9pendants sur chaque stepper Z pour compenser l'inclinaison. Voir la commande PROBE pour plus de d\u00e9tails sur les param\u00e8tres de sonde facultatifs. La valeur facultative HORIZONTAL_MOVE_Z remplace l'option horizontal_move_z sp\u00e9cifi\u00e9e dans le fichier de configuration.","title":"Z_TILT_ADJUST"},{"location":"Hall_Filament_Width_Sensor.html","text":"D\u00e9tecteur de largeur de filament \u00e0 effet hall \u00b6 Ce document d\u00e9crit le module h\u00f4te du capteur de largeur de filament. Le mat\u00e9riel utilis\u00e9 pour d\u00e9velopper ce module h\u00f4te est bas\u00e9 sur deux capteurs lin\u00e9aires Hall (ss49e par exemple). Les capteurs dans le corps sont situ\u00e9s sur des c\u00f4t\u00e9s oppos\u00e9s. Principe de fonctionnement : deux capteurs hall fonctionnent en mode diff\u00e9rentiel, d\u00e9rive de temp\u00e9rature identique pour le capteur. Compensation de temp\u00e9rature sp\u00e9ciale non n\u00e9cessaire. Vous trouverez les mod\u00e8les sur Thingiverse , une vid\u00e9o de montage est \u00e9galement disponible sur Youtube Pour utiliser le capteur de largeur de filament de Hall, consultez R\u00e9f\u00e9rence des configurations et documentation G-Code . Comment cela fonctionne-t-il ? \u00b6 Le capteur g\u00e9n\u00e8re deux sorties analogiques bas\u00e9es sur la largeur de filament calcul\u00e9e. La somme de la tension de sortie est toujours \u00e9gale \u00e0 la largeur de filament d\u00e9tect\u00e9e. Le module h\u00f4te surveille les changements de tension et ajuste le multiplicateur d'extrusion. J'utilise le connecteur aux2 sur une carte de type ramps avec les broches analog11 et analog12. Vous pouvez utiliser diff\u00e9rentes broches et diff\u00e9rentes cartes. Mod\u00e8le pour les variables des menus \u00b6 [menu __main __filament __width_current] type: command enable: {'hall_filament_width_sensor' in printer} name: Dia: {'%.2F' % printer.hall_filament_width_sensor.Diameter} index: 0 [menu __main __filament __raw_width_current] type: command enable: {'hall_filament_width_sensor' in printer} name: Raw: {'%4.0F' % printer.hall_filament_width_sensor.Raw} index: 1 Proc\u00e9dure d'\u00e9talonnage \u00b6 Pour obtenir la valeur brute du capteur, vous pouvez utiliser le menu ou la commande QUERY_RAW_FILAMENT_WIDTH dans le terminal. Ins\u00e9rer la premi\u00e8re tige d'\u00e9talonnage (taille 1,5 mm) pour obtenir la premi\u00e8re valeur brute du capteur Ins\u00e9rer une deuxi\u00e8me tige d'\u00e9talonnage (taille 2,0 mm) pour obtenir la deuxi\u00e8me valeur brute du capteur Enregistrer les valeurs brutes des capteurs dans les param\u00e8tres de configuration Raw_dia1 et Raw_dia2 Comment activer le capteur \u00b6 Par d\u00e9faut, le capteur est d\u00e9sactiv\u00e9 \u00e0 la mise sous tension. Pour activer le capteur, lancez la commande ENABLE_FILAMENT_WIDTH_SENSOR ou d\u00e9finissez le param\u00e8tre enable sur true . Journalisation \u00b6 Par d\u00e9faut, la journalisation du diam\u00e8tre est d\u00e9sactiv\u00e9e \u00e0 la mise sous tension. Executez la commande ENABLE_FILAMENT_WIDTH_LOG pour d\u00e9marrer la journalisation et la commande DISABLE_FILAMENT_WIDTH_LOG pour l'arr\u00eater. Pour activer la journalisation \u00e0 la mise sous tension, d\u00e9finissez le param\u00e8tre logging \u00e0 true . Le diam\u00e8tre du filament est enregistr\u00e9 \u00e0 chaque intervalle de mesure (10 mm par d\u00e9faut).","title":"D\u00e9tecteur de largeur de filament \u00e0 effet hall"},{"location":"Hall_Filament_Width_Sensor.html#detecteur-de-largeur-de-filament-a-effet-hall","text":"Ce document d\u00e9crit le module h\u00f4te du capteur de largeur de filament. Le mat\u00e9riel utilis\u00e9 pour d\u00e9velopper ce module h\u00f4te est bas\u00e9 sur deux capteurs lin\u00e9aires Hall (ss49e par exemple). Les capteurs dans le corps sont situ\u00e9s sur des c\u00f4t\u00e9s oppos\u00e9s. Principe de fonctionnement : deux capteurs hall fonctionnent en mode diff\u00e9rentiel, d\u00e9rive de temp\u00e9rature identique pour le capteur. Compensation de temp\u00e9rature sp\u00e9ciale non n\u00e9cessaire. Vous trouverez les mod\u00e8les sur Thingiverse , une vid\u00e9o de montage est \u00e9galement disponible sur Youtube Pour utiliser le capteur de largeur de filament de Hall, consultez R\u00e9f\u00e9rence des configurations et documentation G-Code .","title":"D\u00e9tecteur de largeur de filament \u00e0 effet hall"},{"location":"Hall_Filament_Width_Sensor.html#comment-cela-fonctionne-t-il","text":"Le capteur g\u00e9n\u00e8re deux sorties analogiques bas\u00e9es sur la largeur de filament calcul\u00e9e. La somme de la tension de sortie est toujours \u00e9gale \u00e0 la largeur de filament d\u00e9tect\u00e9e. Le module h\u00f4te surveille les changements de tension et ajuste le multiplicateur d'extrusion. J'utilise le connecteur aux2 sur une carte de type ramps avec les broches analog11 et analog12. Vous pouvez utiliser diff\u00e9rentes broches et diff\u00e9rentes cartes.","title":"Comment cela fonctionne-t-il ?"},{"location":"Hall_Filament_Width_Sensor.html#modele-pour-les-variables-des-menus","text":"[menu __main __filament __width_current] type: command enable: {'hall_filament_width_sensor' in printer} name: Dia: {'%.2F' % printer.hall_filament_width_sensor.Diameter} index: 0 [menu __main __filament __raw_width_current] type: command enable: {'hall_filament_width_sensor' in printer} name: Raw: {'%4.0F' % printer.hall_filament_width_sensor.Raw} index: 1","title":"Mod\u00e8le pour les variables des menus"},{"location":"Hall_Filament_Width_Sensor.html#procedure-detalonnage","text":"Pour obtenir la valeur brute du capteur, vous pouvez utiliser le menu ou la commande QUERY_RAW_FILAMENT_WIDTH dans le terminal. Ins\u00e9rer la premi\u00e8re tige d'\u00e9talonnage (taille 1,5 mm) pour obtenir la premi\u00e8re valeur brute du capteur Ins\u00e9rer une deuxi\u00e8me tige d'\u00e9talonnage (taille 2,0 mm) pour obtenir la deuxi\u00e8me valeur brute du capteur Enregistrer les valeurs brutes des capteurs dans les param\u00e8tres de configuration Raw_dia1 et Raw_dia2","title":"Proc\u00e9dure d'\u00e9talonnage"},{"location":"Hall_Filament_Width_Sensor.html#comment-activer-le-capteur","text":"Par d\u00e9faut, le capteur est d\u00e9sactiv\u00e9 \u00e0 la mise sous tension. Pour activer le capteur, lancez la commande ENABLE_FILAMENT_WIDTH_SENSOR ou d\u00e9finissez le param\u00e8tre enable sur true .","title":"Comment activer le capteur"},{"location":"Hall_Filament_Width_Sensor.html#journalisation","text":"Par d\u00e9faut, la journalisation du diam\u00e8tre est d\u00e9sactiv\u00e9e \u00e0 la mise sous tension. Executez la commande ENABLE_FILAMENT_WIDTH_LOG pour d\u00e9marrer la journalisation et la commande DISABLE_FILAMENT_WIDTH_LOG pour l'arr\u00eater. Pour activer la journalisation \u00e0 la mise sous tension, d\u00e9finissez le param\u00e8tre logging \u00e0 true . Le diam\u00e8tre du filament est enregistr\u00e9 \u00e0 chaque intervalle de mesure (10 mm par d\u00e9faut).","title":"Journalisation"},{"location":"Installation.html","text":"Installation \u00b6 Ces instructions supposent que le logiciel fonctionnera sur un ordinateur Raspberry Pi en conjonction avec OctoPrint. Il est recommand\u00e9 d'utiliser un ordinateur Raspberry Pi 2, 3 ou 4 comme machine h\u00f4te (voir la FAQ pour les autres machines). Obtenir un fichier de configuration de Klipper \u00b6 La plupart des param\u00e8tres de Klipper sont d\u00e9termin\u00e9s par un \"fichier de configuration d'imprimante\" stock\u00e9 sur le Raspberry Pi. Un fichier de configuration appropri\u00e9 peut souvent \u00eatre trouv\u00e9 en recherchant dans le r\u00e9pertoire des configurations de Klipper, un fichier commen\u00e7ant par un pr\u00e9fixe \"printer-\" correspondant \u00e0 l'imprimante cible. Le fichier de configuration de Klipper contient des informations techniques sur l'imprimante n\u00e9cessaires pendant l'installation. S'il n'y a pas de fichier de configuration d'imprimante appropri\u00e9 dans le r\u00e9pertoire des configurations de Klipper, essayez de rechercher le site Web du fabricant de l'imprimante pour voir s'il y a un fichier de configuration Klipper appropri\u00e9. Si aucun fichier de configuration pour l'imprimante ne peut \u00eatre trouv\u00e9, mais que le type de carte de contr\u00f4le de l'imprimante est connu, recherchez un fichier de configuration appropri\u00e9 commen\u00e7ant par un pr\u00e9fixe \"generic-\". Ces exemples de fichiers de carte d'imprimante devraient permettre de r\u00e9aliser avec succ\u00e8s l'installation initiale, mais n\u00e9cessiteront une personnalisation afin d'obtenir la fonctionnalit\u00e9 compl\u00e8te de l'imprimante. Il est \u00e9galement possible de d\u00e9finir une nouvelle configuration d'imprimante en partant de z\u00e9ro. Toutefois, cela n\u00e9cessite des connaissances techniques importantes sur l'imprimante et son \u00e9lectronique. Il est recommand\u00e9 \u00e0 la plupart des utilisateurs de commencer par un fichier de configuration appropri\u00e9. Si vous cr\u00e9ez un nouveau fichier de configuration d'imprimante personnalis\u00e9, commencez par l'exemple d'un fichier de configuration proche et utilisez la r\u00e9f\u00e9rence de configuration de Klipper pour plus d'informations. Pr\u00e9paration de l'image du syst\u00e8me d'exploitation (OS) \u00b6 Commencez par installer OctoPi sur l'ordinateur Raspberry Pi. Utilisez OctoPi v0.17.0 ou plus r\u00e9cent - voir les OctoPi releases pour les informations de versions. Il faut v\u00e9rifier que OctoPi d\u00e9marre et que le serveur web OctoPrint fonctionne. Apr\u00e8s s'\u00eatre connect\u00e9 \u00e0 la page web d'OctoPrint, suivez les instructions pour mettre \u00e0 jour OctoPrint \u00e0 la version v1.4.2 ou ult\u00e9rieure. Apr\u00e8s avoir install\u00e9 OctoPi et mis \u00e0 jour OctoPrint, il sera n\u00e9cessaire de se connecter via ssh \u00e0 la machine cible pour ex\u00e9cuter quelques commandes syst\u00e8me. Si vous utilisez un bureau Linux ou MacOS, le logiciel \"ssh\" devrait d\u00e9j\u00e0 \u00eatre install\u00e9 sur le bureau. Il existe des clients ssh gratuits pour d'autres ordinateurs de bureau (par exemple, PuTTY ). Utilisez l'utilitaire ssh pour vous connecter au Raspberry Pi (ssh pi@octopi -- le mot de passe par d\u00e9faut est \"raspberry\") et ex\u00e9cutez les commandes suivantes : git clone https://github.com/Klipper3d/klipper ./klipper/scripts/install-octopi.sh L'op\u00e9ration ci-dessus permet de t\u00e9l\u00e9charger Klipper, d'installer certaines d\u00e9pendances du syst\u00e8me, de configurer Klipper pour qu'il soit ex\u00e9cut\u00e9 au d\u00e9marrage du syst\u00e8me et de lancer le logiciel h\u00f4te Klipper. Une connexion Internet est n\u00e9cessaire et l'op\u00e9ration peut prendre quelques minutes. Compilation et flashage du micro-contr\u00f4leur \u00b6 Pour compiler le code du microcontr\u00f4leur, commencez par ex\u00e9cuter ces commandes sur le Raspberry Pi : cd ~/klipper/ make menuconfig Les commentaires en haut du fichier de configuration de l'imprimante devraient d\u00e9crire les param\u00e8tres qui doivent \u00eatre d\u00e9finis pendant le \"make menuconfig\". Ouvrez le fichier dans un navigateur Web ou un \u00e9diteur de texte et recherchez ces instructions en haut du fichier. Une fois que les param\u00e8tres appropri\u00e9s de \"menuconfig\" ont \u00e9t\u00e9 configur\u00e9s, appuyez sur \"Q\" pour quitter, puis sur \"Y\" pour enregistrer. Ensuite, ex\u00e9cutez : make Si les commentaires au haut de printer configuration file d\u00e9crive des \u00e9tapes pour le \"flashing\" de l'image finale sur la carte de contr\u00f4le de l'imprimante alors suivez ces \u00e9tapes puis proc\u00e9dez \u00e0 configuring OctoPrint . Sinon, les \u00e9tapes suivantes sont souvent utilis\u00e9es pour le \"flash\" de la carte de contr\u00f4le de l'imprimante. D'abord, il est n\u00e9cessaire de d\u00e9terminer le port s\u00e9rie connect\u00e9 au micro-contr\u00f4leur. Lancez ceci : ls /dev/serial/by-id/* Il devrait retourner quelque chose de similaire \u00e0 ce qui suit : /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 Il est courant que chaque imprimante ait son propre nom de port s\u00e9rie unique. Ce nom unique sera utilis\u00e9 lors du flashage du micro-contr\u00f4leur. Il est possible qu'il y ait plusieurs lignes dans la sortie ci-dessus - si c'est le cas, choisissez la ligne correspondant au micro-contr\u00f4leur (voir la FAQ pour plus d'informations). Pour les micro-contr\u00f4leurs courants, le code peut \u00eatre flash\u00e9 avec quelque chose de similaire : sudo service klipper stop make flash FLASH_DEVICE=/dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 sudo service klipper start Veillez \u00e0 mettre \u00e0 jour le FLASH_DEVICE avec le nom unique du port s\u00e9rie de l'imprimante. Lors du premier flashage, assurez-vous qu'OctoPrint n'est pas connect\u00e9 directement \u00e0 l'imprimante (\u00e0 partir de la page web d'OctoPrint, sous la section \"Connexion\", cliquez sur \"D\u00e9connecter\"). Configuration d'OctoPrint pour utiliser Klipper \u00b6 Le serveur web OctoPrint doit \u00eatre configur\u00e9 pour communiquer avec le logiciel h\u00f4te Klipper. \u00c0 l'aide d'un navigateur Web, connectez-vous \u00e0 la page Web d'OctoPrint, puis configurez les \u00e9l\u00e9ments suivants : Naviguez vers l'onglet \"Settings\" (l'ic\u00f4ne de la cl\u00e9 \u00e0 molette en haut de la page). Sous \"Serial Connection\" dans \"Additional serial ports\" ajoutez \"/tmp/printer\". Cliquez ensuite sur \"Save\". Entrez \u00e0 nouveau dans l'onglet Param\u00e8tres et, sous \"Connexion s\u00e9rie\", changez le param\u00e8tre \"Port s\u00e9rie\" en \"/tmp/printer\". Dans l'onglet \"Param\u00e8tres\", acc\u00e9dez au sous-onglet \"Behavior\" et s\u00e9lectionnez l'option \"Cancel any ongoing prints but stay connected to the printer\". Cliquez sur \"Enregistrer\". Sur la page principale, dans la section \"Connection\" (en haut \u00e0 gauche de la page), assurez-vous que le \"Serial Port\" est r\u00e9gl\u00e9 sur \"/tmp/printer\" et cliquez sur \"Connect\". (si \"/tmp/printer\" n'est pas une s\u00e9lection disponible, essayez de recharger la page.) Une fois connect\u00e9, naviguez vers l'onglet \"Terminal\" et tapez \"status\" (sans les guillemets) dans la bo\u00eete de saisie de la commande et cliquez sur \"Send\". La fen\u00eatre du terminal indiquera probablement qu'il y a une erreur dans l'ouverture du fichier de configuration - cela signifie qu'OctoPrint communique avec succ\u00e8s avec Klipper. Passez \u00e0 la section suivante. Configuration de Klipper \u00b6 La prochaine \u00e9tape est de copier le printer configuration file dans le Raspberry Pi. La fa\u00e7on la plus simple de d\u00e9finir le fichier de configuration de Klipper est d'utiliser un \u00e9diteur de bureau qui prend en charge l'\u00e9dition de fichiers via les protocoles \"scp\" et/ou \"sftp\". Il existe des outils disponibles gratuitement qui prenant en charge cette fonction (par exemple, Notepad++, WinSCP et Cyberduck). Chargez le fichier de configuration de l'imprimante dans l'\u00e9diteur, puis sauvegardez-le dans un fichier nomm\u00e9 \"printer.cfg\" dans le r\u00e9pertoire personnel de l'utilisateur pi (par exemple, /home/pi/printer.cfg). On peut \u00e9galement copier et modifier le fichier directement sur le Raspberry Pi via ssh. Cela peut ressembler \u00e0 ce qui suit (veillez \u00e0 mettre \u00e0 jour la commande pour utiliser le nom de fichier de configuration de l'imprimante appropri\u00e9) : cp ~/klipper/config/example-cartesian.cfg ~/printer.cfg nano ~/printer.cfg C'est classique pour chaque imprimante d'avoir son propre nom pour le micro-contr\u00f4leur. Le nom peut changer apr\u00e8s le flashing de Klipper, relancez donc ces \u00e9tapes \u00e0 nouveau m\u00eame si elles ont d\u00e9j\u00e0 \u00e9t\u00e9 faites lors du flashing. Lancez : ls /dev/serial/by-id/* Il devrait retourner quelque chose de similaire \u00e0 ce qui suit : /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 Puis mettez \u00e0 jour le fichier de configuration avec un nom unique. Par exemple, mettez \u00e0 jour la section [mcu] pour ressembler \u00e0 quelque chose comme : [mcu] serial: /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 Apr\u00e8s avoir cr\u00e9\u00e9 et \u00e9dit\u00e9 le fichier, il sera n\u00e9cessaire de lancer une commande \"restart\" dans le terminal web OctoPrint pour charger la configuration. Une commande \"status\" indiquera que l'imprimante est pr\u00eate si le fichier de configuration Klipper est lu avec succ\u00e8s et si le micro-contr\u00f4leur est trouv\u00e9 et configur\u00e9 avec succ\u00e8s. Lors de la personnalisation du fichier de configuration de l'imprimante, il n'est pas rare que Klipper signale une erreur de configuration. Si une erreur se produit, apportez les corrections n\u00e9cessaires au fichier de configuration de l'imprimante et lancez \"restart\" jusqu'\u00e0 ce que \"status\" indique que l'imprimante est pr\u00eate. Klipper rapporte les messages d'erreur via l'onglet du terminal OctoPrint. La commande \"status\" peut \u00eatre utilis\u00e9e pour rapporter \u00e0 nouveau les messages d'erreur. Le script de d\u00e9marrage par d\u00e9faut de Klipper place \u00e9galement un journal dans /tmp/klippy.log qui fournit des informations plus d\u00e9taill\u00e9es. Une fois que Klipper a signal\u00e9 que l'imprimante est pr\u00eate, passez au document de v\u00e9rification de la configuration pour effectuer les v\u00e9rifications de base sur les d\u00e9finitions du fichier de configuration. Pour plus d'informations, consultez la r\u00e9f\u00e9rence de documentation principale pour plus d'informations.","title":"Installation"},{"location":"Installation.html#installation","text":"Ces instructions supposent que le logiciel fonctionnera sur un ordinateur Raspberry Pi en conjonction avec OctoPrint. Il est recommand\u00e9 d'utiliser un ordinateur Raspberry Pi 2, 3 ou 4 comme machine h\u00f4te (voir la FAQ pour les autres machines).","title":"Installation"},{"location":"Installation.html#obtenir-un-fichier-de-configuration-de-klipper","text":"La plupart des param\u00e8tres de Klipper sont d\u00e9termin\u00e9s par un \"fichier de configuration d'imprimante\" stock\u00e9 sur le Raspberry Pi. Un fichier de configuration appropri\u00e9 peut souvent \u00eatre trouv\u00e9 en recherchant dans le r\u00e9pertoire des configurations de Klipper, un fichier commen\u00e7ant par un pr\u00e9fixe \"printer-\" correspondant \u00e0 l'imprimante cible. Le fichier de configuration de Klipper contient des informations techniques sur l'imprimante n\u00e9cessaires pendant l'installation. S'il n'y a pas de fichier de configuration d'imprimante appropri\u00e9 dans le r\u00e9pertoire des configurations de Klipper, essayez de rechercher le site Web du fabricant de l'imprimante pour voir s'il y a un fichier de configuration Klipper appropri\u00e9. Si aucun fichier de configuration pour l'imprimante ne peut \u00eatre trouv\u00e9, mais que le type de carte de contr\u00f4le de l'imprimante est connu, recherchez un fichier de configuration appropri\u00e9 commen\u00e7ant par un pr\u00e9fixe \"generic-\". Ces exemples de fichiers de carte d'imprimante devraient permettre de r\u00e9aliser avec succ\u00e8s l'installation initiale, mais n\u00e9cessiteront une personnalisation afin d'obtenir la fonctionnalit\u00e9 compl\u00e8te de l'imprimante. Il est \u00e9galement possible de d\u00e9finir une nouvelle configuration d'imprimante en partant de z\u00e9ro. Toutefois, cela n\u00e9cessite des connaissances techniques importantes sur l'imprimante et son \u00e9lectronique. Il est recommand\u00e9 \u00e0 la plupart des utilisateurs de commencer par un fichier de configuration appropri\u00e9. Si vous cr\u00e9ez un nouveau fichier de configuration d'imprimante personnalis\u00e9, commencez par l'exemple d'un fichier de configuration proche et utilisez la r\u00e9f\u00e9rence de configuration de Klipper pour plus d'informations.","title":"Obtenir un fichier de configuration de Klipper"},{"location":"Installation.html#preparation-de-limage-du-systeme-dexploitation-os","text":"Commencez par installer OctoPi sur l'ordinateur Raspberry Pi. Utilisez OctoPi v0.17.0 ou plus r\u00e9cent - voir les OctoPi releases pour les informations de versions. Il faut v\u00e9rifier que OctoPi d\u00e9marre et que le serveur web OctoPrint fonctionne. Apr\u00e8s s'\u00eatre connect\u00e9 \u00e0 la page web d'OctoPrint, suivez les instructions pour mettre \u00e0 jour OctoPrint \u00e0 la version v1.4.2 ou ult\u00e9rieure. Apr\u00e8s avoir install\u00e9 OctoPi et mis \u00e0 jour OctoPrint, il sera n\u00e9cessaire de se connecter via ssh \u00e0 la machine cible pour ex\u00e9cuter quelques commandes syst\u00e8me. Si vous utilisez un bureau Linux ou MacOS, le logiciel \"ssh\" devrait d\u00e9j\u00e0 \u00eatre install\u00e9 sur le bureau. Il existe des clients ssh gratuits pour d'autres ordinateurs de bureau (par exemple, PuTTY ). Utilisez l'utilitaire ssh pour vous connecter au Raspberry Pi (ssh pi@octopi -- le mot de passe par d\u00e9faut est \"raspberry\") et ex\u00e9cutez les commandes suivantes : git clone https://github.com/Klipper3d/klipper ./klipper/scripts/install-octopi.sh L'op\u00e9ration ci-dessus permet de t\u00e9l\u00e9charger Klipper, d'installer certaines d\u00e9pendances du syst\u00e8me, de configurer Klipper pour qu'il soit ex\u00e9cut\u00e9 au d\u00e9marrage du syst\u00e8me et de lancer le logiciel h\u00f4te Klipper. Une connexion Internet est n\u00e9cessaire et l'op\u00e9ration peut prendre quelques minutes.","title":"Pr\u00e9paration de l'image du syst\u00e8me d'exploitation (OS)"},{"location":"Installation.html#compilation-et-flashage-du-micro-controleur","text":"Pour compiler le code du microcontr\u00f4leur, commencez par ex\u00e9cuter ces commandes sur le Raspberry Pi : cd ~/klipper/ make menuconfig Les commentaires en haut du fichier de configuration de l'imprimante devraient d\u00e9crire les param\u00e8tres qui doivent \u00eatre d\u00e9finis pendant le \"make menuconfig\". Ouvrez le fichier dans un navigateur Web ou un \u00e9diteur de texte et recherchez ces instructions en haut du fichier. Une fois que les param\u00e8tres appropri\u00e9s de \"menuconfig\" ont \u00e9t\u00e9 configur\u00e9s, appuyez sur \"Q\" pour quitter, puis sur \"Y\" pour enregistrer. Ensuite, ex\u00e9cutez : make Si les commentaires au haut de printer configuration file d\u00e9crive des \u00e9tapes pour le \"flashing\" de l'image finale sur la carte de contr\u00f4le de l'imprimante alors suivez ces \u00e9tapes puis proc\u00e9dez \u00e0 configuring OctoPrint . Sinon, les \u00e9tapes suivantes sont souvent utilis\u00e9es pour le \"flash\" de la carte de contr\u00f4le de l'imprimante. D'abord, il est n\u00e9cessaire de d\u00e9terminer le port s\u00e9rie connect\u00e9 au micro-contr\u00f4leur. Lancez ceci : ls /dev/serial/by-id/* Il devrait retourner quelque chose de similaire \u00e0 ce qui suit : /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 Il est courant que chaque imprimante ait son propre nom de port s\u00e9rie unique. Ce nom unique sera utilis\u00e9 lors du flashage du micro-contr\u00f4leur. Il est possible qu'il y ait plusieurs lignes dans la sortie ci-dessus - si c'est le cas, choisissez la ligne correspondant au micro-contr\u00f4leur (voir la FAQ pour plus d'informations). Pour les micro-contr\u00f4leurs courants, le code peut \u00eatre flash\u00e9 avec quelque chose de similaire : sudo service klipper stop make flash FLASH_DEVICE=/dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 sudo service klipper start Veillez \u00e0 mettre \u00e0 jour le FLASH_DEVICE avec le nom unique du port s\u00e9rie de l'imprimante. Lors du premier flashage, assurez-vous qu'OctoPrint n'est pas connect\u00e9 directement \u00e0 l'imprimante (\u00e0 partir de la page web d'OctoPrint, sous la section \"Connexion\", cliquez sur \"D\u00e9connecter\").","title":"Compilation et flashage du micro-contr\u00f4leur"},{"location":"Installation.html#configuration-doctoprint-pour-utiliser-klipper","text":"Le serveur web OctoPrint doit \u00eatre configur\u00e9 pour communiquer avec le logiciel h\u00f4te Klipper. \u00c0 l'aide d'un navigateur Web, connectez-vous \u00e0 la page Web d'OctoPrint, puis configurez les \u00e9l\u00e9ments suivants : Naviguez vers l'onglet \"Settings\" (l'ic\u00f4ne de la cl\u00e9 \u00e0 molette en haut de la page). Sous \"Serial Connection\" dans \"Additional serial ports\" ajoutez \"/tmp/printer\". Cliquez ensuite sur \"Save\". Entrez \u00e0 nouveau dans l'onglet Param\u00e8tres et, sous \"Connexion s\u00e9rie\", changez le param\u00e8tre \"Port s\u00e9rie\" en \"/tmp/printer\". Dans l'onglet \"Param\u00e8tres\", acc\u00e9dez au sous-onglet \"Behavior\" et s\u00e9lectionnez l'option \"Cancel any ongoing prints but stay connected to the printer\". Cliquez sur \"Enregistrer\". Sur la page principale, dans la section \"Connection\" (en haut \u00e0 gauche de la page), assurez-vous que le \"Serial Port\" est r\u00e9gl\u00e9 sur \"/tmp/printer\" et cliquez sur \"Connect\". (si \"/tmp/printer\" n'est pas une s\u00e9lection disponible, essayez de recharger la page.) Une fois connect\u00e9, naviguez vers l'onglet \"Terminal\" et tapez \"status\" (sans les guillemets) dans la bo\u00eete de saisie de la commande et cliquez sur \"Send\". La fen\u00eatre du terminal indiquera probablement qu'il y a une erreur dans l'ouverture du fichier de configuration - cela signifie qu'OctoPrint communique avec succ\u00e8s avec Klipper. Passez \u00e0 la section suivante.","title":"Configuration d'OctoPrint pour utiliser Klipper"},{"location":"Installation.html#configuration-de-klipper","text":"La prochaine \u00e9tape est de copier le printer configuration file dans le Raspberry Pi. La fa\u00e7on la plus simple de d\u00e9finir le fichier de configuration de Klipper est d'utiliser un \u00e9diteur de bureau qui prend en charge l'\u00e9dition de fichiers via les protocoles \"scp\" et/ou \"sftp\". Il existe des outils disponibles gratuitement qui prenant en charge cette fonction (par exemple, Notepad++, WinSCP et Cyberduck). Chargez le fichier de configuration de l'imprimante dans l'\u00e9diteur, puis sauvegardez-le dans un fichier nomm\u00e9 \"printer.cfg\" dans le r\u00e9pertoire personnel de l'utilisateur pi (par exemple, /home/pi/printer.cfg). On peut \u00e9galement copier et modifier le fichier directement sur le Raspberry Pi via ssh. Cela peut ressembler \u00e0 ce qui suit (veillez \u00e0 mettre \u00e0 jour la commande pour utiliser le nom de fichier de configuration de l'imprimante appropri\u00e9) : cp ~/klipper/config/example-cartesian.cfg ~/printer.cfg nano ~/printer.cfg C'est classique pour chaque imprimante d'avoir son propre nom pour le micro-contr\u00f4leur. Le nom peut changer apr\u00e8s le flashing de Klipper, relancez donc ces \u00e9tapes \u00e0 nouveau m\u00eame si elles ont d\u00e9j\u00e0 \u00e9t\u00e9 faites lors du flashing. Lancez : ls /dev/serial/by-id/* Il devrait retourner quelque chose de similaire \u00e0 ce qui suit : /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 Puis mettez \u00e0 jour le fichier de configuration avec un nom unique. Par exemple, mettez \u00e0 jour la section [mcu] pour ressembler \u00e0 quelque chose comme : [mcu] serial: /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 Apr\u00e8s avoir cr\u00e9\u00e9 et \u00e9dit\u00e9 le fichier, il sera n\u00e9cessaire de lancer une commande \"restart\" dans le terminal web OctoPrint pour charger la configuration. Une commande \"status\" indiquera que l'imprimante est pr\u00eate si le fichier de configuration Klipper est lu avec succ\u00e8s et si le micro-contr\u00f4leur est trouv\u00e9 et configur\u00e9 avec succ\u00e8s. Lors de la personnalisation du fichier de configuration de l'imprimante, il n'est pas rare que Klipper signale une erreur de configuration. Si une erreur se produit, apportez les corrections n\u00e9cessaires au fichier de configuration de l'imprimante et lancez \"restart\" jusqu'\u00e0 ce que \"status\" indique que l'imprimante est pr\u00eate. Klipper rapporte les messages d'erreur via l'onglet du terminal OctoPrint. La commande \"status\" peut \u00eatre utilis\u00e9e pour rapporter \u00e0 nouveau les messages d'erreur. Le script de d\u00e9marrage par d\u00e9faut de Klipper place \u00e9galement un journal dans /tmp/klippy.log qui fournit des informations plus d\u00e9taill\u00e9es. Une fois que Klipper a signal\u00e9 que l'imprimante est pr\u00eate, passez au document de v\u00e9rification de la configuration pour effectuer les v\u00e9rifications de base sur les d\u00e9finitions du fichier de configuration. Pour plus d'informations, consultez la r\u00e9f\u00e9rence de documentation principale pour plus d'informations.","title":"Configuration de Klipper"},{"location":"Kinematics.html","text":"Cin\u00e9matiques \u00b6 Ce document donne un aper\u00e7u de la fa\u00e7on dont Klipper impl\u00e9mente le mouvement du robot (sa cin\u00e9matique ). Ce contenu peut int\u00e9resser aussi bien les d\u00e9veloppeurs travaillant sur le logiciel Klipper que les utilisateurs int\u00e9ress\u00e9s \u00e0 mieux comprendre la m\u00e9canique de leurs machines. Acc\u00e9l\u00e9ration \u00b6 Klipper met en \u0153uvre un sch\u00e9ma d'acc\u00e9l\u00e9ration constante chaque fois que la t\u00eate d'impression change de vitesse - la vitesse est progressivement modifi\u00e9e pour atteindre la nouvelle vitesse au lieu d'\u00eatre brusquement atteinte. Klipper applique toujours l'acc\u00e9l\u00e9ration entre la t\u00eate de l'outil et l'impression. Le filament sortant de l'extrudeuse peut \u00eatre assez fragile - des secousses rapides et/ou des changements de d\u00e9bit de l'extrudeuse entra\u00eenent une qualit\u00e9 m\u00e9diocre et une mauvaise adh\u00e9rence du lit. M\u00eame en l'absence d'extrusion, si la t\u00eate d'impression se trouve au m\u00eame niveau que l'impression, des secousses rapides de la t\u00eate peuvent perturber le filament r\u00e9cemment d\u00e9pos\u00e9. Limiter les changements de vitesse de la t\u00eate d'impression (par rapport \u00e0 l'impression) r\u00e9duit les risques de perturbation de l'impression. Il est \u00e9galement important de limiter l'acc\u00e9l\u00e9ration afin que les moteurs pas \u00e0 pas ne perdent pas de pas et ne soumettent pas la machine \u00e0 des contraintes excessives. Klipper limite le couple de chaque moteur pas \u00e0 pas en limitant l'acc\u00e9l\u00e9ration de la t\u00eate d'impression. Le fait d'imposer une acc\u00e9l\u00e9ration \u00e0 la t\u00eate d'impression limite naturellement aussi le couple des moteurs pas \u00e0 pas qui d\u00e9placent la t\u00eate d'impression (l'inverse n'est pas toujours vrai). Klipper met en \u0153uvre une acc\u00e9l\u00e9ration constante. La formule cl\u00e9 de l'acc\u00e9l\u00e9ration constante est la suivante : velocity(time) = start_velocity + accel*time G\u00e9n\u00e9rateur de trap\u00e9zo\u00efdes \u00b6 Klipper utilise un \"g\u00e9n\u00e9rateur de trap\u00e8ze\" traditionnel pour mod\u00e9liser le mouvement de chaque d\u00e9placement - chaque d\u00e9placement a une vitesse de d\u00e9part, il acc\u00e9l\u00e8re jusqu'\u00e0 une vitesse de croisi\u00e8re \u00e0 une acc\u00e9l\u00e9ration constante, il se d\u00e9place \u00e0 une vitesse constante, puis d\u00e9c\u00e9l\u00e8re jusqu'\u00e0 la vitesse finale en utilisant une d\u00e9c\u00e9l\u00e9ration constante. On l'appelle \"g\u00e9n\u00e9rateur de trap\u00e8ze\" parce que le diagramme de vitesse du mouvement ressemble \u00e0 un trap\u00e8ze. La vitesse de croisi\u00e8re est toujours sup\u00e9rieure ou \u00e9gale \u00e0 la fois \u00e0 la vitesse de d\u00e9part et \u00e0 la vitesse d'arriv\u00e9e. La phase d'acc\u00e9l\u00e9ration peut \u00eatre de dur\u00e9e nulle (si la vitesse de d\u00e9part est \u00e9gale \u00e0 la vitesse de croisi\u00e8re), la phase de croisi\u00e8re peut \u00eatre de dur\u00e9e nulle (si le mouvement commence imm\u00e9diatement \u00e0 d\u00e9c\u00e9l\u00e9rer apr\u00e8s l'acc\u00e9l\u00e9ration), et/ou la phase de d\u00e9c\u00e9l\u00e9ration peut \u00eatre de dur\u00e9e nulle (si la vitesse finale est \u00e9gale \u00e0 la vitesse de croisi\u00e8re). Projection \u00b6 Le syst\u00e8me de projection \"look-ahead\" est utilis\u00e9 pour d\u00e9terminer les vitesses lors des virages entre les mouvements. Consid\u00e9rons les deux mouvements suivants contenus dans un plan XY : Dans la situation ci-dessus, il est possible de d\u00e9c\u00e9l\u00e9rer compl\u00e8tement apr\u00e8s le premier mouvement et d'acc\u00e9l\u00e9rer compl\u00e8tement au d\u00e9but du mouvement suivant, mais ce n'est pas id\u00e9al car toutes ces acc\u00e9l\u00e9rations et d\u00e9c\u00e9l\u00e9rations augmenteraient consid\u00e9rablement le temps d'impression et les changements fr\u00e9quents dans le flux de l'extrudeuse entra\u00eeneraient une mauvaise qualit\u00e9 d'impression. Pour r\u00e9soudre ce probl\u00e8me, le m\u00e9canisme de projection \"look-ahead\" met en file d'attente plusieurs mouvements entrants et analyse les angles entre les mouvements pour d\u00e9terminer une vitesse raisonnable pouvant \u00eatre obtenue pendant la \"jonction\" entre deux mouvements. Si le d\u00e9placement suivant est presque dans la m\u00eame direction, la t\u00eate ne doit ralentir que l\u00e9g\u00e8rement (voire pas du tout). Toutefois, si le mouvement suivant forme un angle aigu (la t\u00eate va se d\u00e9placer dans une direction presque inverse lors du mouvement suivant), seule une petite vitesse de jonction est autoris\u00e9e. Les vitesses de jonction sont d\u00e9termin\u00e9es en utilisant \"l'acc\u00e9l\u00e9ration centrip\u00e8te approximative\". Best d\u00e9crit par l'auteur . Cependant, dans Klipper, les vitesses de jonction sont configur\u00e9es en sp\u00e9cifiant la vitesse souhait\u00e9e pour un angle de 90\u00b0 (la \"vitesse de l'angle carr\u00e9\"), et les vitesses de jonction des autres angles en sont d\u00e9riv\u00e9es. Formule cl\u00e9 pour la projection : end_velocity^2 = start_velocity^2 + 2*accel*move_distance Lissage de la projection \u00b6 Klipper met \u00e9galement en \u0153uvre un m\u00e9canisme permettant de lisser les mouvements de courts d\u00e9placements en \"zigzag\". Consid\u00e9rons les mouvements suivants : Dans l'exemple ci-dessus, les passages fr\u00e9quents de l'acc\u00e9l\u00e9ration \u00e0 la d\u00e9c\u00e9l\u00e9ration peuvent faire vibrer la machine provoquant des contraintes sur la machine et augmentant le bruit. Pour r\u00e9duire ce ph\u00e9nom\u00e8ne, Klipper suit \u00e0 la fois l'acc\u00e9l\u00e9ration des mouvements r\u00e9guliers et un taux virtuel \"d'acc\u00e9l\u00e9ration \u00e0 d\u00e9c\u00e9l\u00e9ration\". Gr\u00e2ce \u00e0 ce syst\u00e8me, la vitesse maximale de ces courts mouvements en \"zigzag\" est limit\u00e9e pour lisser le mouvement de l'imprimante : Plus pr\u00e9cis\u00e9ment, le code calcule ce que serait la vitesse de chaque mouvement s'il \u00e9tait limit\u00e9 \u00e0 ce taux virtuel \"d'acc\u00e9l\u00e9ration \u00e0 d\u00e9c\u00e9l\u00e9ration\" (la moiti\u00e9 du taux d'acc\u00e9l\u00e9ration normal par d\u00e9faut). Dans l'image ci-dessus, les lignes grises en pointill\u00e9s repr\u00e9sentent ce taux d'acc\u00e9l\u00e9ration virtuel pour le premier d\u00e9placement. Si un d\u00e9placement ne peut atteindre sa vitesse de croisi\u00e8re maximale en utilisant ce taux d'acc\u00e9l\u00e9ration virtuel, sa vitesse maximale est r\u00e9duite \u00e0 la vitesse maximale obtenu avec ce taux d'acc\u00e9l\u00e9ration virtuel. Pour la plupart des mouvements, la limite sera \u00e9gale ou sup\u00e9rieure aux limites existantes du mouvement et aucun changement de comportement n'est induit. En revanche, pour les d\u00e9placements courts en zigzag, cette limite r\u00e9duit la vitesse maximale. Notez que cela ne modifie pas l'acc\u00e9l\u00e9ration r\u00e9elle du mouvement - le mouvement continue d'utiliser le sch\u00e9ma d'acc\u00e9l\u00e9ration normal jusqu'\u00e0 sa vitesse maximale ajust\u00e9e. \u00c9tapes de la g\u00e9n\u00e9ration \u00b6 Une fois le processus d'anticipation termin\u00e9, le mouvement de la t\u00eate d'impression du mouvement donn\u00e9 est enti\u00e8rement connu (temps, position de d\u00e9part, position finale, vitesse \u00e0 chaque point) et il est possible de g\u00e9n\u00e9rer les dur\u00e9es de pas du mouvement. Ce processus est effectu\u00e9 dans les \"classes cin\u00e9matiques\" du code Klipper. En dehors de ces classes cin\u00e9matiques, tout est suivi en millim\u00e8tres, en secondes et dans un espace de coordonn\u00e9es cart\u00e9siennes. C'est la t\u00e2che des classes cin\u00e9matiques de convertir ce syst\u00e8me de coordonn\u00e9es g\u00e9n\u00e9rique aux sp\u00e9cificit\u00e9s mat\u00e9rielles de l'imprimante particuli\u00e8re. Klipper utilise un solveur it\u00e9ratif pour g\u00e9n\u00e9rer les dur\u00e9s de pas pour chaque moteur. Le code contient les formules permettant de calculer les coordonn\u00e9es cart\u00e9siennes id\u00e9ales de la t\u00eate \u00e0 chaque instant, ainsi que les formules cin\u00e9matiques permettant de calculer les positions id\u00e9ales des moteurs \u00e0 partir de ces coordonn\u00e9es cart\u00e9siennes. Gr\u00e2ce \u00e0 ces formules, Klipper peut d\u00e9terminer le moment id\u00e9al o\u00f9 le moteur doit se trouver \u00e0 chaque position de pas. Les \u00e9tapes donn\u00e9es sont alors programm\u00e9es \u00e0 ces moments calcul\u00e9s. La formule cl\u00e9 d\u00e9terminant la distance qu'un mouvement doit parcourir sous une acc\u00e9l\u00e9ration constante est la suivante : move_distance = (start_velocity + .5 * accel * move_time) * move_time et la formule cl\u00e9 d'un mouvement \u00e0 vitesse constante est : move_distance = cruise_velocity * move_time Les formules cl\u00e9s permettant de d\u00e9terminer la coordonn\u00e9e cart\u00e9sienne d'un d\u00e9placement en fonction de la distance du d\u00e9placement sont les suivantes : cartesian_x_position = start_x + move_distance * total_x_movement / total_movement cartesian_y_position = start_y + move_distance * total_y_movement / total_movement cartesian_z_position = start_z + move_distance * total_z_movement / total_movement Robots cart\u00e9siens \u00b6 La g\u00e9n\u00e9ration de pas des imprimantes cart\u00e9siennes est le cas le plus simple. Le mouvement sur chaque axe est directement li\u00e9 au mouvement dans l'espace cart\u00e9sien. Formules cl\u00e9s : stepper_x_position = cartesian_x_position stepper_y_position = cartesian_y_position stepper_z_position = cartesian_z_position Robots CoreXY \u00b6 La g\u00e9n\u00e9ration de pas d'une machine CoreXY n'est qu'un peu plus complexe que les robots cart\u00e9siens de base. Les formules cl\u00e9s sont les suivantes : stepper_a_position = cartesian_x_position + cartesian_y_position stepper_b_position = cartesian_x_position - cartesian_y_position stepper_z_position = cartesian_z_position Robots Delta \u00b6 La g\u00e9n\u00e9ration de pas d'un robot delta est bas\u00e9e sur le th\u00e9or\u00e8me de Pythagore : stepper_position = (sqrt(arm_length^2 - (cartesian_x_position - tower_x_position)^2 - (cartesian_y_position - tower_y_position)^2) + cartesian_z_position) Limites d'acc\u00e9l\u00e9ration du moteur pas \u00e0 pas \u00b6 Avec la cin\u00e9matique delta, il est possible qu'un mouvement acc\u00e9l\u00e8rant dans l'espace cart\u00e9sien n\u00e9cessite une acc\u00e9l\u00e9ration sur un moteur pas \u00e0 pas particulier sup\u00e9rieure \u00e0 l'acc\u00e9l\u00e9ration du mouvement. Cela peut se produire lorsque le bras d'un moteur pas \u00e0 pas est plus horizontal que vertical et que la ligne de mouvement passe pr\u00e8s de la tour de ce moteur pas \u00e0 pas. Bien que ces mouvements puissent n\u00e9cessiter une acc\u00e9l\u00e9ration du moteur pas \u00e0 pas sup\u00e9rieure \u00e0 l'acc\u00e9l\u00e9ration maximale du mouvement configur\u00e9 de l'imprimante, la masse effective d\u00e9plac\u00e9e par ce moteur pas \u00e0 pas serait plus faible. Ainsi, l'acc\u00e9l\u00e9ration plus \u00e9lev\u00e9e du moteur pas \u00e0 pas n'entra\u00eene pas un couple beaucoup plus \u00e9lev\u00e9 et est donc consid\u00e9r\u00e9e comme inoffensive. Cependant, afin d'\u00e9viter les cas extr\u00eames, Klipper applique un plafond maximal \u00e0 l'acc\u00e9l\u00e9ration du moteur de trois fois l'acc\u00e9l\u00e9ration de d\u00e9placement maximale configur\u00e9e de l'imprimante. (De m\u00eame, la vitesse maximale du moteur est limit\u00e9e \u00e0 trois fois la vitesse de d\u00e9placement maximale). Afin de faire respecter cette limite, les mouvements situ\u00e9s \u00e0 l'extr\u00e9mit\u00e9 de l'enveloppe de construction (o\u00f9 le bras du stepper peut \u00eatre presque horizontal) auront une acc\u00e9l\u00e9ration et une vitesse maximales inf\u00e9rieures. Cin\u00e9matique de l'extrudeuse \u00b6 Klipper impl\u00e9mente le mouvement de l'extrudeuse dans sa propre classe cin\u00e9matique. Comme la dur\u00e9e et la vitesse de chaque mouvement de la t\u00eate d'impression sont enti\u00e8rement connus pour chaque mouvement, il est possible de calculer les dur\u00e9es de pas de l'extrudeuse ind\u00e9pendamment des calculs de dur\u00e9es de pas du mouvement de la t\u00eate d'impression. Le mouvement de base de l'extrudeuse est simple \u00e0 calculer. La g\u00e9n\u00e9ration de dur\u00e9e de pas utilise les m\u00eames formules que celles utilis\u00e9es par les robots cart\u00e9siens : stepper_position = requested_e_position Avance \u00e0 la pression \u00b6 L'exp\u00e9rimentation a montr\u00e9 qu'il est possible d'am\u00e9liorer la mod\u00e9lisation de l'extrudeuse au-del\u00e0 de la formule de base de l'extrudeuse. Dans le cas id\u00e9al, au fur et \u00e0 mesure qu'un mouvement d'extrusion progresse, le m\u00eame volume de filament devrait \u00eatre d\u00e9pos\u00e9 \u00e0 chaque point du mouvement et il ne devrait pas y avoir de volume extrud\u00e9 apr\u00e8s le mouvement. Malheureusement, il est courant de constater que les formules d'extrusion de base font que trop peu de filament sort de l'extrudeuse au d\u00e9but des mouvements d'extrusion et qu'un exc\u00e8s de filament est extrud\u00e9 apr\u00e8s la fin de l'extrusion. Ce ph\u00e9nom\u00e8ne est souvent appel\u00e9 \"suintement\". Le syst\u00e8me d'\"avance \u00e0 la pression\" tente de tenir compte de ce ph\u00e9nom\u00e8ne en utilisant un mod\u00e8le diff\u00e9rent pour l'extrudeuse. Au lieu de croire na\u00efvement que chaque mm^3 de filament introduit dans l'extrudeuse entra\u00eenera la sortie imm\u00e9diate de cette quantit\u00e9 de mm^3, est utilis\u00e9 un mod\u00e8le bas\u00e9 sur la pression. La pression augmente lorsque le filament est pouss\u00e9 dans l'extrudeuse (comme dans la loi de Hooke ) et la pression n\u00e9cessaire pour extruder est domin\u00e9e par le d\u00e9bit \u00e0 travers l'orifice de la buse (comme dans la loi de Poiseuille ). L'id\u00e9e principale est que la relation entre le filament, la pression et le d\u00e9bit peut \u00eatre mod\u00e9lis\u00e9e par un coefficient lin\u00e9aire : pa_position = nominal_position + pressure_advance_coefficient * nominal_velocity Voir le document avance \u00e0 la pression pour savoir comment d\u00e9terminer ce coefficient d'avance \u00e0 la pression. La formule de base de l'avance \u00e0 la pression peut entra\u00eener des changements brusques de la vitesse du moteur de l'extrudeuse. Klipper met en \u0153uvre un \"lissage\" du mouvement de l'extrudeuse pour \u00e9viter cela. Le graphique ci-dessus montre un exemple de deux mouvements d'extrusion avec une vitesse de virage non nulle entre eux. Notez que le syst\u00e8me d'avance \u00e0 la pression fait que du filament suppl\u00e9mentaire est pouss\u00e9 dans l'extrudeuse pendant l'acc\u00e9l\u00e9ration. Plus le d\u00e9bit de filament souhait\u00e9 est \u00e9lev\u00e9, plus il faut pousser de filament dans l'extrudeuse pendant l'acc\u00e9l\u00e9ration pour tenir compte de la pression. Pendant la d\u00e9c\u00e9l\u00e9ration de la t\u00eate, le filament suppl\u00e9mentaire est r\u00e9tract\u00e9 (l'extrudeuse aura une vitesse n\u00e9gative). Le \"lissage\" est impl\u00e9ment\u00e9 en utilisant une moyenne pond\u00e9r\u00e9e de la position de l'extrudeuse sur une tr\u00e8s courte p\u00e9riode de temps (comme sp\u00e9cifi\u00e9 par le param\u00e8tre de configuration pressure_advance_smooth_time ). Cette moyenne peut s'\u00e9tendre sur plusieurs mouvements du g-code. Notez comment le moteur de l'extrudeuse commencera \u00e0 bouger avant le d\u00e9but nominal du premier mouvement d'extrusion et continuera \u00e0 bouger apr\u00e8s la fin nominale du dernier mouvement d'extrusion. Formule cl\u00e9 pour \"l'avance \u00e0 la pression liss\u00e9e\" : smooth_pa_position(t) = ( definitive_integral(pa_position(x) * (smooth_time/2 - abs(t - x)) * dx, from=t-smooth_time/2, to=t+smooth_time/2) / (smooth_time/2)^2 )","title":"Cin\u00e9matiques"},{"location":"Kinematics.html#cinematiques","text":"Ce document donne un aper\u00e7u de la fa\u00e7on dont Klipper impl\u00e9mente le mouvement du robot (sa cin\u00e9matique ). Ce contenu peut int\u00e9resser aussi bien les d\u00e9veloppeurs travaillant sur le logiciel Klipper que les utilisateurs int\u00e9ress\u00e9s \u00e0 mieux comprendre la m\u00e9canique de leurs machines.","title":"Cin\u00e9matiques"},{"location":"Kinematics.html#acceleration","text":"Klipper met en \u0153uvre un sch\u00e9ma d'acc\u00e9l\u00e9ration constante chaque fois que la t\u00eate d'impression change de vitesse - la vitesse est progressivement modifi\u00e9e pour atteindre la nouvelle vitesse au lieu d'\u00eatre brusquement atteinte. Klipper applique toujours l'acc\u00e9l\u00e9ration entre la t\u00eate de l'outil et l'impression. Le filament sortant de l'extrudeuse peut \u00eatre assez fragile - des secousses rapides et/ou des changements de d\u00e9bit de l'extrudeuse entra\u00eenent une qualit\u00e9 m\u00e9diocre et une mauvaise adh\u00e9rence du lit. M\u00eame en l'absence d'extrusion, si la t\u00eate d'impression se trouve au m\u00eame niveau que l'impression, des secousses rapides de la t\u00eate peuvent perturber le filament r\u00e9cemment d\u00e9pos\u00e9. Limiter les changements de vitesse de la t\u00eate d'impression (par rapport \u00e0 l'impression) r\u00e9duit les risques de perturbation de l'impression. Il est \u00e9galement important de limiter l'acc\u00e9l\u00e9ration afin que les moteurs pas \u00e0 pas ne perdent pas de pas et ne soumettent pas la machine \u00e0 des contraintes excessives. Klipper limite le couple de chaque moteur pas \u00e0 pas en limitant l'acc\u00e9l\u00e9ration de la t\u00eate d'impression. Le fait d'imposer une acc\u00e9l\u00e9ration \u00e0 la t\u00eate d'impression limite naturellement aussi le couple des moteurs pas \u00e0 pas qui d\u00e9placent la t\u00eate d'impression (l'inverse n'est pas toujours vrai). Klipper met en \u0153uvre une acc\u00e9l\u00e9ration constante. La formule cl\u00e9 de l'acc\u00e9l\u00e9ration constante est la suivante : velocity(time) = start_velocity + accel*time","title":"Acc\u00e9l\u00e9ration"},{"location":"Kinematics.html#generateur-de-trapezoides","text":"Klipper utilise un \"g\u00e9n\u00e9rateur de trap\u00e8ze\" traditionnel pour mod\u00e9liser le mouvement de chaque d\u00e9placement - chaque d\u00e9placement a une vitesse de d\u00e9part, il acc\u00e9l\u00e8re jusqu'\u00e0 une vitesse de croisi\u00e8re \u00e0 une acc\u00e9l\u00e9ration constante, il se d\u00e9place \u00e0 une vitesse constante, puis d\u00e9c\u00e9l\u00e8re jusqu'\u00e0 la vitesse finale en utilisant une d\u00e9c\u00e9l\u00e9ration constante. On l'appelle \"g\u00e9n\u00e9rateur de trap\u00e8ze\" parce que le diagramme de vitesse du mouvement ressemble \u00e0 un trap\u00e8ze. La vitesse de croisi\u00e8re est toujours sup\u00e9rieure ou \u00e9gale \u00e0 la fois \u00e0 la vitesse de d\u00e9part et \u00e0 la vitesse d'arriv\u00e9e. La phase d'acc\u00e9l\u00e9ration peut \u00eatre de dur\u00e9e nulle (si la vitesse de d\u00e9part est \u00e9gale \u00e0 la vitesse de croisi\u00e8re), la phase de croisi\u00e8re peut \u00eatre de dur\u00e9e nulle (si le mouvement commence imm\u00e9diatement \u00e0 d\u00e9c\u00e9l\u00e9rer apr\u00e8s l'acc\u00e9l\u00e9ration), et/ou la phase de d\u00e9c\u00e9l\u00e9ration peut \u00eatre de dur\u00e9e nulle (si la vitesse finale est \u00e9gale \u00e0 la vitesse de croisi\u00e8re).","title":"G\u00e9n\u00e9rateur de trap\u00e9zo\u00efdes"},{"location":"Kinematics.html#projection","text":"Le syst\u00e8me de projection \"look-ahead\" est utilis\u00e9 pour d\u00e9terminer les vitesses lors des virages entre les mouvements. Consid\u00e9rons les deux mouvements suivants contenus dans un plan XY : Dans la situation ci-dessus, il est possible de d\u00e9c\u00e9l\u00e9rer compl\u00e8tement apr\u00e8s le premier mouvement et d'acc\u00e9l\u00e9rer compl\u00e8tement au d\u00e9but du mouvement suivant, mais ce n'est pas id\u00e9al car toutes ces acc\u00e9l\u00e9rations et d\u00e9c\u00e9l\u00e9rations augmenteraient consid\u00e9rablement le temps d'impression et les changements fr\u00e9quents dans le flux de l'extrudeuse entra\u00eeneraient une mauvaise qualit\u00e9 d'impression. Pour r\u00e9soudre ce probl\u00e8me, le m\u00e9canisme de projection \"look-ahead\" met en file d'attente plusieurs mouvements entrants et analyse les angles entre les mouvements pour d\u00e9terminer une vitesse raisonnable pouvant \u00eatre obtenue pendant la \"jonction\" entre deux mouvements. Si le d\u00e9placement suivant est presque dans la m\u00eame direction, la t\u00eate ne doit ralentir que l\u00e9g\u00e8rement (voire pas du tout). Toutefois, si le mouvement suivant forme un angle aigu (la t\u00eate va se d\u00e9placer dans une direction presque inverse lors du mouvement suivant), seule une petite vitesse de jonction est autoris\u00e9e. Les vitesses de jonction sont d\u00e9termin\u00e9es en utilisant \"l'acc\u00e9l\u00e9ration centrip\u00e8te approximative\". Best d\u00e9crit par l'auteur . Cependant, dans Klipper, les vitesses de jonction sont configur\u00e9es en sp\u00e9cifiant la vitesse souhait\u00e9e pour un angle de 90\u00b0 (la \"vitesse de l'angle carr\u00e9\"), et les vitesses de jonction des autres angles en sont d\u00e9riv\u00e9es. Formule cl\u00e9 pour la projection : end_velocity^2 = start_velocity^2 + 2*accel*move_distance","title":"Projection"},{"location":"Kinematics.html#lissage-de-la-projection","text":"Klipper met \u00e9galement en \u0153uvre un m\u00e9canisme permettant de lisser les mouvements de courts d\u00e9placements en \"zigzag\". Consid\u00e9rons les mouvements suivants : Dans l'exemple ci-dessus, les passages fr\u00e9quents de l'acc\u00e9l\u00e9ration \u00e0 la d\u00e9c\u00e9l\u00e9ration peuvent faire vibrer la machine provoquant des contraintes sur la machine et augmentant le bruit. Pour r\u00e9duire ce ph\u00e9nom\u00e8ne, Klipper suit \u00e0 la fois l'acc\u00e9l\u00e9ration des mouvements r\u00e9guliers et un taux virtuel \"d'acc\u00e9l\u00e9ration \u00e0 d\u00e9c\u00e9l\u00e9ration\". Gr\u00e2ce \u00e0 ce syst\u00e8me, la vitesse maximale de ces courts mouvements en \"zigzag\" est limit\u00e9e pour lisser le mouvement de l'imprimante : Plus pr\u00e9cis\u00e9ment, le code calcule ce que serait la vitesse de chaque mouvement s'il \u00e9tait limit\u00e9 \u00e0 ce taux virtuel \"d'acc\u00e9l\u00e9ration \u00e0 d\u00e9c\u00e9l\u00e9ration\" (la moiti\u00e9 du taux d'acc\u00e9l\u00e9ration normal par d\u00e9faut). Dans l'image ci-dessus, les lignes grises en pointill\u00e9s repr\u00e9sentent ce taux d'acc\u00e9l\u00e9ration virtuel pour le premier d\u00e9placement. Si un d\u00e9placement ne peut atteindre sa vitesse de croisi\u00e8re maximale en utilisant ce taux d'acc\u00e9l\u00e9ration virtuel, sa vitesse maximale est r\u00e9duite \u00e0 la vitesse maximale obtenu avec ce taux d'acc\u00e9l\u00e9ration virtuel. Pour la plupart des mouvements, la limite sera \u00e9gale ou sup\u00e9rieure aux limites existantes du mouvement et aucun changement de comportement n'est induit. En revanche, pour les d\u00e9placements courts en zigzag, cette limite r\u00e9duit la vitesse maximale. Notez que cela ne modifie pas l'acc\u00e9l\u00e9ration r\u00e9elle du mouvement - le mouvement continue d'utiliser le sch\u00e9ma d'acc\u00e9l\u00e9ration normal jusqu'\u00e0 sa vitesse maximale ajust\u00e9e.","title":"Lissage de la projection"},{"location":"Kinematics.html#etapes-de-la-generation","text":"Une fois le processus d'anticipation termin\u00e9, le mouvement de la t\u00eate d'impression du mouvement donn\u00e9 est enti\u00e8rement connu (temps, position de d\u00e9part, position finale, vitesse \u00e0 chaque point) et il est possible de g\u00e9n\u00e9rer les dur\u00e9es de pas du mouvement. Ce processus est effectu\u00e9 dans les \"classes cin\u00e9matiques\" du code Klipper. En dehors de ces classes cin\u00e9matiques, tout est suivi en millim\u00e8tres, en secondes et dans un espace de coordonn\u00e9es cart\u00e9siennes. C'est la t\u00e2che des classes cin\u00e9matiques de convertir ce syst\u00e8me de coordonn\u00e9es g\u00e9n\u00e9rique aux sp\u00e9cificit\u00e9s mat\u00e9rielles de l'imprimante particuli\u00e8re. Klipper utilise un solveur it\u00e9ratif pour g\u00e9n\u00e9rer les dur\u00e9s de pas pour chaque moteur. Le code contient les formules permettant de calculer les coordonn\u00e9es cart\u00e9siennes id\u00e9ales de la t\u00eate \u00e0 chaque instant, ainsi que les formules cin\u00e9matiques permettant de calculer les positions id\u00e9ales des moteurs \u00e0 partir de ces coordonn\u00e9es cart\u00e9siennes. Gr\u00e2ce \u00e0 ces formules, Klipper peut d\u00e9terminer le moment id\u00e9al o\u00f9 le moteur doit se trouver \u00e0 chaque position de pas. Les \u00e9tapes donn\u00e9es sont alors programm\u00e9es \u00e0 ces moments calcul\u00e9s. La formule cl\u00e9 d\u00e9terminant la distance qu'un mouvement doit parcourir sous une acc\u00e9l\u00e9ration constante est la suivante : move_distance = (start_velocity + .5 * accel * move_time) * move_time et la formule cl\u00e9 d'un mouvement \u00e0 vitesse constante est : move_distance = cruise_velocity * move_time Les formules cl\u00e9s permettant de d\u00e9terminer la coordonn\u00e9e cart\u00e9sienne d'un d\u00e9placement en fonction de la distance du d\u00e9placement sont les suivantes : cartesian_x_position = start_x + move_distance * total_x_movement / total_movement cartesian_y_position = start_y + move_distance * total_y_movement / total_movement cartesian_z_position = start_z + move_distance * total_z_movement / total_movement","title":"\u00c9tapes de la g\u00e9n\u00e9ration"},{"location":"Kinematics.html#robots-cartesiens","text":"La g\u00e9n\u00e9ration de pas des imprimantes cart\u00e9siennes est le cas le plus simple. Le mouvement sur chaque axe est directement li\u00e9 au mouvement dans l'espace cart\u00e9sien. Formules cl\u00e9s : stepper_x_position = cartesian_x_position stepper_y_position = cartesian_y_position stepper_z_position = cartesian_z_position","title":"Robots cart\u00e9siens"},{"location":"Kinematics.html#robots-corexy","text":"La g\u00e9n\u00e9ration de pas d'une machine CoreXY n'est qu'un peu plus complexe que les robots cart\u00e9siens de base. Les formules cl\u00e9s sont les suivantes : stepper_a_position = cartesian_x_position + cartesian_y_position stepper_b_position = cartesian_x_position - cartesian_y_position stepper_z_position = cartesian_z_position","title":"Robots CoreXY"},{"location":"Kinematics.html#robots-delta","text":"La g\u00e9n\u00e9ration de pas d'un robot delta est bas\u00e9e sur le th\u00e9or\u00e8me de Pythagore : stepper_position = (sqrt(arm_length^2 - (cartesian_x_position - tower_x_position)^2 - (cartesian_y_position - tower_y_position)^2) + cartesian_z_position)","title":"Robots Delta"},{"location":"Kinematics.html#limites-dacceleration-du-moteur-pas-a-pas","text":"Avec la cin\u00e9matique delta, il est possible qu'un mouvement acc\u00e9l\u00e8rant dans l'espace cart\u00e9sien n\u00e9cessite une acc\u00e9l\u00e9ration sur un moteur pas \u00e0 pas particulier sup\u00e9rieure \u00e0 l'acc\u00e9l\u00e9ration du mouvement. Cela peut se produire lorsque le bras d'un moteur pas \u00e0 pas est plus horizontal que vertical et que la ligne de mouvement passe pr\u00e8s de la tour de ce moteur pas \u00e0 pas. Bien que ces mouvements puissent n\u00e9cessiter une acc\u00e9l\u00e9ration du moteur pas \u00e0 pas sup\u00e9rieure \u00e0 l'acc\u00e9l\u00e9ration maximale du mouvement configur\u00e9 de l'imprimante, la masse effective d\u00e9plac\u00e9e par ce moteur pas \u00e0 pas serait plus faible. Ainsi, l'acc\u00e9l\u00e9ration plus \u00e9lev\u00e9e du moteur pas \u00e0 pas n'entra\u00eene pas un couple beaucoup plus \u00e9lev\u00e9 et est donc consid\u00e9r\u00e9e comme inoffensive. Cependant, afin d'\u00e9viter les cas extr\u00eames, Klipper applique un plafond maximal \u00e0 l'acc\u00e9l\u00e9ration du moteur de trois fois l'acc\u00e9l\u00e9ration de d\u00e9placement maximale configur\u00e9e de l'imprimante. (De m\u00eame, la vitesse maximale du moteur est limit\u00e9e \u00e0 trois fois la vitesse de d\u00e9placement maximale). Afin de faire respecter cette limite, les mouvements situ\u00e9s \u00e0 l'extr\u00e9mit\u00e9 de l'enveloppe de construction (o\u00f9 le bras du stepper peut \u00eatre presque horizontal) auront une acc\u00e9l\u00e9ration et une vitesse maximales inf\u00e9rieures.","title":"Limites d'acc\u00e9l\u00e9ration du moteur pas \u00e0 pas"},{"location":"Kinematics.html#cinematique-de-lextrudeuse","text":"Klipper impl\u00e9mente le mouvement de l'extrudeuse dans sa propre classe cin\u00e9matique. Comme la dur\u00e9e et la vitesse de chaque mouvement de la t\u00eate d'impression sont enti\u00e8rement connus pour chaque mouvement, il est possible de calculer les dur\u00e9es de pas de l'extrudeuse ind\u00e9pendamment des calculs de dur\u00e9es de pas du mouvement de la t\u00eate d'impression. Le mouvement de base de l'extrudeuse est simple \u00e0 calculer. La g\u00e9n\u00e9ration de dur\u00e9e de pas utilise les m\u00eames formules que celles utilis\u00e9es par les robots cart\u00e9siens : stepper_position = requested_e_position","title":"Cin\u00e9matique de l'extrudeuse"},{"location":"Kinematics.html#avance-a-la-pression","text":"L'exp\u00e9rimentation a montr\u00e9 qu'il est possible d'am\u00e9liorer la mod\u00e9lisation de l'extrudeuse au-del\u00e0 de la formule de base de l'extrudeuse. Dans le cas id\u00e9al, au fur et \u00e0 mesure qu'un mouvement d'extrusion progresse, le m\u00eame volume de filament devrait \u00eatre d\u00e9pos\u00e9 \u00e0 chaque point du mouvement et il ne devrait pas y avoir de volume extrud\u00e9 apr\u00e8s le mouvement. Malheureusement, il est courant de constater que les formules d'extrusion de base font que trop peu de filament sort de l'extrudeuse au d\u00e9but des mouvements d'extrusion et qu'un exc\u00e8s de filament est extrud\u00e9 apr\u00e8s la fin de l'extrusion. Ce ph\u00e9nom\u00e8ne est souvent appel\u00e9 \"suintement\". Le syst\u00e8me d'\"avance \u00e0 la pression\" tente de tenir compte de ce ph\u00e9nom\u00e8ne en utilisant un mod\u00e8le diff\u00e9rent pour l'extrudeuse. Au lieu de croire na\u00efvement que chaque mm^3 de filament introduit dans l'extrudeuse entra\u00eenera la sortie imm\u00e9diate de cette quantit\u00e9 de mm^3, est utilis\u00e9 un mod\u00e8le bas\u00e9 sur la pression. La pression augmente lorsque le filament est pouss\u00e9 dans l'extrudeuse (comme dans la loi de Hooke ) et la pression n\u00e9cessaire pour extruder est domin\u00e9e par le d\u00e9bit \u00e0 travers l'orifice de la buse (comme dans la loi de Poiseuille ). L'id\u00e9e principale est que la relation entre le filament, la pression et le d\u00e9bit peut \u00eatre mod\u00e9lis\u00e9e par un coefficient lin\u00e9aire : pa_position = nominal_position + pressure_advance_coefficient * nominal_velocity Voir le document avance \u00e0 la pression pour savoir comment d\u00e9terminer ce coefficient d'avance \u00e0 la pression. La formule de base de l'avance \u00e0 la pression peut entra\u00eener des changements brusques de la vitesse du moteur de l'extrudeuse. Klipper met en \u0153uvre un \"lissage\" du mouvement de l'extrudeuse pour \u00e9viter cela. Le graphique ci-dessus montre un exemple de deux mouvements d'extrusion avec une vitesse de virage non nulle entre eux. Notez que le syst\u00e8me d'avance \u00e0 la pression fait que du filament suppl\u00e9mentaire est pouss\u00e9 dans l'extrudeuse pendant l'acc\u00e9l\u00e9ration. Plus le d\u00e9bit de filament souhait\u00e9 est \u00e9lev\u00e9, plus il faut pousser de filament dans l'extrudeuse pendant l'acc\u00e9l\u00e9ration pour tenir compte de la pression. Pendant la d\u00e9c\u00e9l\u00e9ration de la t\u00eate, le filament suppl\u00e9mentaire est r\u00e9tract\u00e9 (l'extrudeuse aura une vitesse n\u00e9gative). Le \"lissage\" est impl\u00e9ment\u00e9 en utilisant une moyenne pond\u00e9r\u00e9e de la position de l'extrudeuse sur une tr\u00e8s courte p\u00e9riode de temps (comme sp\u00e9cifi\u00e9 par le param\u00e8tre de configuration pressure_advance_smooth_time ). Cette moyenne peut s'\u00e9tendre sur plusieurs mouvements du g-code. Notez comment le moteur de l'extrudeuse commencera \u00e0 bouger avant le d\u00e9but nominal du premier mouvement d'extrusion et continuera \u00e0 bouger apr\u00e8s la fin nominale du dernier mouvement d'extrusion. Formule cl\u00e9 pour \"l'avance \u00e0 la pression liss\u00e9e\" : smooth_pa_position(t) = ( definitive_integral(pa_position(x) * (smooth_time/2 - abs(t - x)) * dx, from=t-smooth_time/2, to=t+smooth_time/2) / (smooth_time/2)^2 )","title":"Avance \u00e0 la pression"},{"location":"MCU_Commands.html","text":"Commandes MCU \u00b6 Ce document fournit des informations sur les commandes de bas niveau du microcontr\u00f4leur qui sont envoy\u00e9es depuis le logiciel \"h\u00f4te\" Klipper et trait\u00e9es par le firmware Klipper du microcontr\u00f4leur. Ce document n'est pas une r\u00e9f\u00e9rence faisant autorit\u00e9 pour ces commandes, ni une liste exclusive de toutes les commandes disponibles. Ce document peut \u00eatre utile aux d\u00e9veloppeurs souhaitant comprendre les commandes de bas niveau du microcontr\u00f4leur. Voir le document protocole pour plus d'informations sur le format des commandes et leur transmission. Les commandes ici sont d\u00e9crites en utilisant une syntaxe de style \"printf\" - pour ceux qui ne connaissent pas ce format, notez simplement que lorsqu'une s\u00e9quence '%...' est vue, elle doit \u00eatre remplac\u00e9e par un entier r\u00e9el. Par exemple, une description avec \"count=%c\" pourrait \u00eatre remplac\u00e9e par le texte \"count=10\". Notez que les param\u00e8tres qui sont consid\u00e9r\u00e9s comme des \"\u00e9num\u00e9rations\" (voir le document de protocole ci-dessus) prennent une valeur de cha\u00eene qui est automatiquement convertie en une valeur enti\u00e8re pour le microcontr\u00f4leur. Ceci est courant avec les param\u00e8tres nomm\u00e9s \"pin\" (ou qui ont le suffixe \"_pin\"). Commandes de d\u00e9marrage \u00b6 Il peut \u00eatre n\u00e9cessaire d'effectuer des actions ponctuelles pour configurer le microcontr\u00f4leur et ses p\u00e9riph\u00e9riques. Cette section r\u00e9pertorie les commandes courantes disponibles \u00e0 cette effet. Contrairement \u00e0 la plupart des commandes de microcontr\u00f4leur, ces commandes s'ex\u00e9cutent d\u00e8s leur r\u00e9ception et ne n\u00e9cessitent aucune configuration particuli\u00e8re. Commandes de d\u00e9marrage courantes : set_digital_out pin=%u value=%c : Cette commande configure imm\u00e9diatement la broche donn\u00e9e en tant que sortie num\u00e9rique GPIO et la d\u00e9finit soit \u00e0 un niveau bas (valeur=0) soit \u00e0 un niveau haut (valeur=1 ). Cette commande peut \u00eatre utile pour configurer la valeur initiale des LED et pour configurer la valeur initiale des broches de micro-pas du pilote de moteur pas \u00e0 pas. set_pwm_out pin=%u cycle_ticks=%u value=%hu : Cette commande configurera la broche donn\u00e9e pour utiliser la modulation de largeur d'impulsion (PWM) bas\u00e9e sur le mat\u00e9riel avec le nombre donn\u00e9 de cycle_ticks. Le \"cycle_ticks\" est le nombre de ticks d'horloge du MCU que chaque cycle de mise sous tension et hors tension doit durer. Une valeur cycle_ticks de 1 peut \u00eatre utilis\u00e9e pour demander le temps de cycle le plus rapide possible. Le param\u00e8tre \"valeur\" est compris entre 0 et 255, 0 indiquant un \u00e9tat enti\u00e8rement d\u00e9sactiv\u00e9 et 255 indiquant un \u00e9tat enti\u00e8rement activ\u00e9. Cette commande peut \u00eatre utile pour activer les ventilateurs de refroidissement du processeur et des buses. Configuration bas niveau du microcontr\u00f4leur \u00b6 La plupart des commandes du microcontr\u00f4leur n\u00e9cessitent une configuration initiale avant de pouvoir \u00eatre appel\u00e9es. Cette section fournit une vue d'ensemble du processus de configuration. Cette section et les sections suivantes ne sont susceptibles d'int\u00e9resser que les d\u00e9veloppeurs int\u00e9ress\u00e9s par les d\u00e9tails internes de Klipper. Lorsque l'h\u00f4te se connecte pour la premi\u00e8re fois au microcontr\u00f4leur, il commence toujours par obtenir un dictionnaire de donn\u00e9es (voir protocole pour plus d'informations). Une fois le dictionnaire de donn\u00e9es obtenu, l'h\u00f4te v\u00e9rifie si le microcontr\u00f4leur est dans un \u00e9tat \"configur\u00e9\" et le configure si ce n'est pas le cas. La configuration comprend les phases suivantes : get_config : L'h\u00f4te commence par v\u00e9rifier si le micro-contr\u00f4leur est d\u00e9j\u00e0 configur\u00e9. Le microcontr\u00f4leur r\u00e9pond \u00e0 cette commande par un message de r\u00e9ponse \u00ab config \u00bb. Le logiciel du microcontr\u00f4leur d\u00e9marre toujours dans un \u00e9tat non configur\u00e9 \u00e0 la mise sous tension. Il reste dans cet \u00e9tat jusqu'\u00e0 ce que l'h\u00f4te termine les processus de configuration (en \u00e9mettant une commande finalize_config). Si le microcontr\u00f4leur est d\u00e9j\u00e0 configur\u00e9 \u00e0 partir d'une session pr\u00e9c\u00e9dente (et est configur\u00e9 avec les param\u00e8tres souhait\u00e9s), aucune autre action n'est requise de la part de l'h\u00f4te et le processus de configuration se termine avec succ\u00e8s. allocate_oids count=%c : cette commande est envoy\u00e9e pour informer le microcontr\u00f4leur du nombre maximal d'identifiants d'objet (oid) requis par l'h\u00f4te. Il n'e faut envoyer cette commande qu'une seule fois. Un oid est un identifiant entier allou\u00e9 \u00e0 chaque stepper, chaque fin de course et chaque broche gpio programmable. L'h\u00f4te d\u00e9termine \u00e0 l'avance le nombre d'oids dont il aura besoin pour faire fonctionner le mat\u00e9riel et le transmet au microcontr\u00f4leur afin qu'il puisse allouer suffisamment de m\u00e9moire pour stocker un mappage de l'oid \u00e0 l'objet interne. config_XXX oid=%c ... : Par convention toute commande commen\u00e7ant par le pr\u00e9fixe \"config_\" cr\u00e9e un nouvel objet microcontr\u00f4leur et lui affecte l'oid donn\u00e9. Par exemple, la commande config_digital_out configurera la broche sp\u00e9cifi\u00e9e en tant que GPIO de sortie num\u00e9rique et cr\u00e9era un objet interne que l'h\u00f4te peut utiliser pour planifier des modifications du GPIO donn\u00e9. Le param\u00e8tre oid pass\u00e9 dans la commande config est s\u00e9lectionn\u00e9 par l'h\u00f4te et doit \u00eatre compris entre z\u00e9ro et le nombre maximal fourni dans la commande allow_oids. Les commandes de configuration ne peuvent \u00eatre ex\u00e9cut\u00e9es que lorsque le microcontr\u00f4leur n'est pas dans un \u00e9tat configur\u00e9 (c'est-\u00e0-dire avant que l'h\u00f4te n'envoie finalize_config) et apr\u00e8s que la commande allow_oids a \u00e9t\u00e9 envoy\u00e9e. finalize_config crc=%u : La commande finalize_config fait passer le microcontr\u00f4leur d'un \u00e9tat non configur\u00e9 \u00e0 un \u00e9tat configur\u00e9. Le param\u00e8tre crc transmis au microcontr\u00f4leur est stock\u00e9 et renvoy\u00e9 \u00e0 l'h\u00f4te dans les messages de r\u00e9ponse \"config\". Par convention, l'h\u00f4te prend un CRC 32 bits de la configuration qu'il demandera et au d\u00e9but des sessions de communication suivantes, il v\u00e9rifie que le CRC stock\u00e9 dans le microcontr\u00f4leur correspond exactement \u00e0 son CRC souhait\u00e9. Si le CRC ne correspond pas, l'h\u00f4te saura que le microcontr\u00f4leur n'a pas \u00e9t\u00e9 configur\u00e9 correctement. Objets de base du microcontr\u00f4leur \u00b6 Cette section r\u00e9pertorie quelques commandes de configuration couramment utilis\u00e9es. config_digital_out oid=%c pin=%u value=%c default_value=%c max_duration=%u : cette commande cr\u00e9e un objet de microcontr\u00f4leur interne pour la \"broche\" GPIO donn\u00e9e. La broche sera configur\u00e9e en mode de sortie num\u00e9rique et d\u00e9finie sur une valeur initiale telle que sp\u00e9cifi\u00e9e par 'value' (0 pour bas, 1 pour haut). La cr\u00e9ation d'un objet digital_out permet \u00e0 l'h\u00f4te de programmer des mises \u00e0 jour GPIO pour la broche donn\u00e9e \u00e0 des heures sp\u00e9cifi\u00e9es (voir la commande queue_digital_out d\u00e9crite ci-dessous). Si le logiciel du microcontr\u00f4leur passe en mode d'arr\u00eat, tous les objets digital_out configur\u00e9s seront d\u00e9finis sur 'default_value'. Le param\u00e8tre 'max_duration' est utilis\u00e9 pour impl\u00e9menter un contr\u00f4le de s\u00e9curit\u00e9 - s'il est diff\u00e9rent de z\u00e9ro, il s'agit du nombre maximal de ticks d'horloge pendannt lesquels l'h\u00f4te peut d\u00e9finir le GPIO donn\u00e9 sur une valeur autre que celle par d\u00e9faut sans autres mises \u00e0 jour. Par exemple, si la default_value est z\u00e9ro et la max_duration est de 16000, alors si l'h\u00f4te d\u00e9finit le gpio sur une valeur de un, il doit planifier une autre mise \u00e0 jour de la broche gpio (\u00e0 z\u00e9ro ou \u00e0 un) dans les 16000 tics d'horloge. Cette fonction de s\u00e9curit\u00e9 peut \u00eatre utilis\u00e9e avec des broches de chauffage pour s'assurer que l'h\u00f4te n'active pas le chauffage puis se d\u00e9connecte en le laissant activ\u00e9. config_pwm_out oid=%c pin=%u cycle_ticks=%u value=%hu default_value=%hu max_duration=%u : cette commande cr\u00e9e un objet interne pour les broches PWM mat\u00e9rielles pour lesquelles l'h\u00f4te peut planifier des mises \u00e0 jour . Son utilisation est analogue \u00e0 config_digital_out - voir la description des commandes 'set_pwm_out' et 'config_digital_out' pour la description des param\u00e8tres. config_analog_in oid=%c pin=%u : Cette commande permet de configurer une broche en mode d'\u00e9chantillonnage d'entr\u00e9e analogique. Une fois configur\u00e9e, la broche peut \u00eatre \u00e9chantillonn\u00e9e \u00e0 intervalle r\u00e9gulier \u00e0 l'aide de la commande query_analog_in (voir ci-dessous). config_stepper oid=%c step_pin=%c dir_pin=%c invert_step=%c step_pulse_ticks=%u : Cette commande cr\u00e9e un objet \"moteur pas \u00e0 pas\" interne. Les param\u00e8tres 'step_pin' et 'dir_pin' sp\u00e9cifient respectivement les broches de pas et de direction ; cette commande les configurera en mode de sortie num\u00e9rique. Le param\u00e8tre 'invert_step' sp\u00e9cifie si une \u00e9tape se produit sur un front montant (invert_step=0) ou descendant (invert_step=1). Le param\u00e8tre 'step_pulse_ticks' sp\u00e9cifie la dur\u00e9e minimale de l'impulsion de pas. Si le mcu exporte la constante 'STEPPER_BOTH_EDGE=1', le r\u00e9glage step_pulse_ticks=0 et invert_step=-1 sera configur\u00e9 pour marcher sur les fronts montant et descendant de la broche de pas. config_endstop oid=%c pin=%c pull_up=%c stepper_count=%c : Cette commande cr\u00e9e un objet \"endstop\" interne. Il est utilis\u00e9 pour sp\u00e9cifier les broches d'arr\u00eat et pour activer les op\u00e9rations de \"homing\" (voir la commande endstop_home ci-dessous). La commande configurera la broche sp\u00e9cifi\u00e9e en mode d'entr\u00e9e num\u00e9rique. Le param\u00e8tre 'pull_up' d\u00e9termine si les r\u00e9sistances pullup fournies par le mat\u00e9riel pour la broche (si disponibles) seront activ\u00e9es. Le param\u00e8tre 'stepper_count' sp\u00e9cifie le nombre maximum de pas dont cette but\u00e9e peut avoir besoin pendant une op\u00e9ration de prise d'origine (voir endstop_home ci-dessous). config_spi oid=%c bus=%u pin=%u mode=%u rate=%u shutdown_msg=%*s : Cette commande cr\u00e9e un objet SPI interne. Il est utilis\u00e9 avec les commandes spi_transfer et spi_send (voir ci-dessous). Le param\u00e8tre \"bus\" identifie le bus SPI \u00e0 utiliser (si le microcontr\u00f4leur a plus d'un bus SPI disponible). Le param\u00e8tre \"broche\" sp\u00e9cifie la broche de s\u00e9lection de puce (CS) pour le p\u00e9riph\u00e9rique. Le param\u00e8tre \"mode\" est le mode SPI (doit \u00eatre compris entre 0 et 3). Le param\u00e8tre \"rate\" sp\u00e9cifie le d\u00e9bit du bus SPI (en cycles par seconde). Enfin, le param\u00e8tre \"shutdown_msg\" est une commande SPI \u00e0 envoyer \u00e0 l'appareil donn\u00e9 si le microcontr\u00f4leur passe en \u00e9tat d'arr\u00eat. config_spi_without_cs oid=%c bus=%u mode=%u rate=%u shutdown_msg=%*s : Cette commande est similaire \u00e0 config_spi, mais sans d\u00e9finition de la broche CS. Il est utile pour les appareils SPI qui n'ont pas de ligne de s\u00e9lection de puce. Commandes courantes \u00b6 Cette section r\u00e9pertorie les commandes les plus couramment utilis\u00e9es. Cela n'int\u00e9resse probablement que les d\u00e9veloppeurs qui cherchent \u00e0 mieux comprendre Klipper. set_digital_out_pwm_cycle oid=%c cycle_ticks=%u : cette commande configure une broche de sortie num\u00e9rique (telle que cr\u00e9\u00e9e par config_digital_out) pour utiliser le \"PWM logciel\". Le 'cycle_ticks' est le nombre de tics d'horloge pour le cycle PWM. \u00c9tant donn\u00e9 que la commutation de sortie est impl\u00e9ment\u00e9e dans le logiciel du microcontr\u00f4leur, il est recommand\u00e9 que 'cycle_ticks' corresponde \u00e0 un temps de 10 ms ou plus. queue_digital_out oid=%c clock=%u on_ticks=%u : Cette commande permet de planifier une changement d'\u00e9tat d'une broche GPIO de sortie num\u00e9rique au tick d'horloge donn\u00e9e. Pour utiliser cette commande, une commande 'config_digital_out' avec le m\u00eame param\u00e8tre 'oid' doit avoir \u00e9t\u00e9 \u00e9mise lors de la configuration du microcontr\u00f4leur. Si 'set_digital_out_pwm_cycle' a \u00e9t\u00e9 appel\u00e9, alors 'on_ticks' est la dur\u00e9e d'activation (en ticks d'horloge) pour le cycle pwm. Sinon, 'on_ticks' doit \u00eatre soit 0 (pour basse tension) soit 1 (pour haute tension). queue_pwm_out oid=%c clock=%u value=%hu : planifie un changement sur une broche de sortie PWM mat\u00e9rielle. Voir les commandes 'queue_digital_out' et 'config_pwm_out' pour plus d'informations. query_analog_in oid=%c clock=%u sample_ticks=%u sample_count=%c rest_ticks=%u min_value=%hu max_value=%hu : Cette commande d\u00e9finit une r\u00e9cup\u00e9ration r\u00e9currente d'\u00e9chantillons d'entr\u00e9e analogique. Pour utiliser cette commande, une commande 'config_analog_in' avec le m\u00eame param\u00e8tre 'oid' doit avoir \u00e9t\u00e9 \u00e9mise lors de la configuration du microcontr\u00f4leur. Les \u00e9chantillons commenceront \u00e0 partir de l'heure 'clock', et ils rapporteront la valeur obtenue \u00e0 chaque tic d'horloge 'rest_ticks', il sur\u00e9chantillonnera avec un nombre 'sample_count' d'\u00e9chantillons et il se mettra en pause pendant le nombre 'sample_ticks' de tic d'horloge entre chaque \u00e9chantillonnage. Les param\u00e8tres 'min_value' et 'max_value' impl\u00e9mentent une fonction de s\u00e9curit\u00e9 - le logiciel du microcontr\u00f4leur v\u00e9rifiera que la valeur \u00e9chantillonn\u00e9e se situe toujours dans la plage fournie. Ceci est destin\u00e9 \u00e0 \u00eatre utilis\u00e9 avec des broches rattach\u00e9es aux thermistances contr\u00f4lant les radiateurs - il peut \u00eatre utilis\u00e9 pour v\u00e9rifier qu'un radiateur se trouve dans une plage de temp\u00e9rature correcte. get_clock : Cette commande am\u00e8ne le microcontr\u00f4leur \u00e0 g\u00e9n\u00e9rer un message de r\u00e9ponse \"clock\". L'h\u00f4te envoie cette commande une fois par seconde pour obtenir la valeur de l'horloge du microcontr\u00f4leur et pour estimer la d\u00e9rive entre les horloges de l'h\u00f4te et du microcontr\u00f4leur. Il permet \u00e0 l'h\u00f4te d'estimer avec pr\u00e9cision l'horloge du microcontr\u00f4leur. Commandes de moteurs pas \u00e0 pas \u00b6 queue_step oid=%c interval=%u count=%hu add=%hi : cette commande planifie le nombre de pas 'count' pour le stepper donn\u00e9, avec un nombre 'd'intervalle' de ticks d'horloge entre chaque pas. La premi\u00e8re \u00e9tape sera le nombre \"d'intervalle\" de ticks d'horloge depuis la derni\u00e8re \u00e9tape planifi\u00e9e pour le stepper donn\u00e9. Si 'add' n'est pas nul, l'intervalle sera ajust\u00e9 du montant 'add' apr\u00e8s chaque pas. Cette commande ajoute la s\u00e9quence d'intervalle/compte/ajout donn\u00e9e \u00e0 une file d'attente des pas. Il peut y avoir des centaines de ces s\u00e9quences en file d'attente pendant le fonctionnement normal. Une nouvelle s\u00e9quence est ajout\u00e9e \u00e0 la fin de la file d'attente et lorsque chaque s\u00e9quence termine son nombre de pas, elle est retir\u00e9e du d\u00e9but de la file d'attente. Ce syst\u00e8me permet au microcontr\u00f4leur de mettre en file d'attente potentiellement des centaines de milliers d'\u00e9tapes, le tout avec des dur\u00e9es fiables et pr\u00e9visibles. set_next_step_dir oid=%c dir=%c : Cette commande sp\u00e9cifie la valeur du dir_pin que la prochaine commande queue_step utilisera. reset_step_clock oid=%c clock=%u : Normalement, la synchronisation des pas est relative au dernier pas pour un stepper donn\u00e9. Cette commande r\u00e9initialise l'horloge de sorte que l'\u00e9tape suivante soit relative \u00e0 l'heure \"horloge\" fournie. L'h\u00f4te n'envoie g\u00e9n\u00e9ralement cette commande qu'au d\u00e9but d'une impression. stepper_get_position oid=%c : Cette commande am\u00e8ne le microcontr\u00f4leur \u00e0 g\u00e9n\u00e9rer un message de r\u00e9ponse \"stepper_position\" avec la position actuelle du stepper. La position est le nombre total d'\u00e9tapes g\u00e9n\u00e9r\u00e9es avec dir=1 moins le nombre total d'\u00e9tapes g\u00e9n\u00e9r\u00e9es avec dir=0. endstop_home oid=%c clock=%u sample_ticks=%u sample_count=%c rest_ticks=%u pin_value=%c : Cette commande est utilis\u00e9e lors des op\u00e9rations de \"homing\" des moteurs pas \u00e0 pas. Pour utiliser cette commande, une commande 'config_endstop' avec le m\u00eame param\u00e8tre 'oid' doit avoir \u00e9t\u00e9 \u00e9mise lors de la configuration du microcontr\u00f4leur. Lorsque cette commande est invoqu\u00e9e, le microcontr\u00f4leur \u00e9chantillonnera la broche endstop \u00e0 chaque tic d'horloge 'rest_ticks' et v\u00e9rifiera si elle a une valeur \u00e9gale \u00e0 'pin_value'. Si la valeur correspond (et continue de correspondre pour 'sample_count' \u00e9chantillons suppl\u00e9mentaires r\u00e9partis 'sample_ticks'), alors la file d'attente de mouvement pour le stepper associ\u00e9 sera effac\u00e9e et le stepper s'arr\u00eatera imm\u00e9diatement. L'h\u00f4te utilise cette commande pour impl\u00e9menter la prise d'origine - l'h\u00f4te demande \u00e0 la but\u00e9e d'\u00e9chantillonner pour le d\u00e9clencheur de but\u00e9e, puis il \u00e9met une s\u00e9rie de commandes queue_step pour d\u00e9placer un stepper vers la but\u00e9e. Une fois que le stepper atteint la but\u00e9e, le d\u00e9clencheur sera d\u00e9tect\u00e9, le mouvement arr\u00eat\u00e9 et l'h\u00f4te notifi\u00e9. D\u00e9placer la file d'attente \u00b6 Chaque commande queue_step utilise une entr\u00e9e dans la \"file d'attente de d\u00e9placement\" du microcontr\u00f4leur. Cette file d'attente est allou\u00e9e lorsqu'elle re\u00e7oit la commande \"finalize_config\", et elle signale le nombre d'entr\u00e9es de file d'attente disponibles dans les messages de r\u00e9ponse \"config\". Il est de la responsabilit\u00e9 de l'h\u00f4te de s'assurer qu'il y a de l'espace disponible dans la file d'attente avant d'envoyer une commande queue_step. Pour ce faire, l'h\u00f4te calcule le moment o\u00f9 chaque commande queue_step se termine et planifie de nouvelles commandes queue_step en cons\u00e9quence. Commandes SPI \u00b6 spi_transfer oid=%c data=%*s : Cette commande am\u00e8ne le microcontr\u00f4leur \u00e0 envoyer des \"donn\u00e9es\" au p\u00e9riph\u00e9rique spi sp\u00e9cifi\u00e9 par \"oid\" et g\u00e9n\u00e8re un message de r\u00e9ponse \"spi_transfer_response\" avec les donn\u00e9es retourn\u00e9es par le p\u00e9riph\u00e9rique. spi_send oid=%c data=%*s : Cette commande est similaire \u00e0 \"spi_transfer\", mais elle ne g\u00e9n\u00e8re pas de message \"spi_transfer_response\".","title":"Commandes MCU"},{"location":"MCU_Commands.html#commandes-mcu","text":"Ce document fournit des informations sur les commandes de bas niveau du microcontr\u00f4leur qui sont envoy\u00e9es depuis le logiciel \"h\u00f4te\" Klipper et trait\u00e9es par le firmware Klipper du microcontr\u00f4leur. Ce document n'est pas une r\u00e9f\u00e9rence faisant autorit\u00e9 pour ces commandes, ni une liste exclusive de toutes les commandes disponibles. Ce document peut \u00eatre utile aux d\u00e9veloppeurs souhaitant comprendre les commandes de bas niveau du microcontr\u00f4leur. Voir le document protocole pour plus d'informations sur le format des commandes et leur transmission. Les commandes ici sont d\u00e9crites en utilisant une syntaxe de style \"printf\" - pour ceux qui ne connaissent pas ce format, notez simplement que lorsqu'une s\u00e9quence '%...' est vue, elle doit \u00eatre remplac\u00e9e par un entier r\u00e9el. Par exemple, une description avec \"count=%c\" pourrait \u00eatre remplac\u00e9e par le texte \"count=10\". Notez que les param\u00e8tres qui sont consid\u00e9r\u00e9s comme des \"\u00e9num\u00e9rations\" (voir le document de protocole ci-dessus) prennent une valeur de cha\u00eene qui est automatiquement convertie en une valeur enti\u00e8re pour le microcontr\u00f4leur. Ceci est courant avec les param\u00e8tres nomm\u00e9s \"pin\" (ou qui ont le suffixe \"_pin\").","title":"Commandes MCU"},{"location":"MCU_Commands.html#commandes-de-demarrage","text":"Il peut \u00eatre n\u00e9cessaire d'effectuer des actions ponctuelles pour configurer le microcontr\u00f4leur et ses p\u00e9riph\u00e9riques. Cette section r\u00e9pertorie les commandes courantes disponibles \u00e0 cette effet. Contrairement \u00e0 la plupart des commandes de microcontr\u00f4leur, ces commandes s'ex\u00e9cutent d\u00e8s leur r\u00e9ception et ne n\u00e9cessitent aucune configuration particuli\u00e8re. Commandes de d\u00e9marrage courantes : set_digital_out pin=%u value=%c : Cette commande configure imm\u00e9diatement la broche donn\u00e9e en tant que sortie num\u00e9rique GPIO et la d\u00e9finit soit \u00e0 un niveau bas (valeur=0) soit \u00e0 un niveau haut (valeur=1 ). Cette commande peut \u00eatre utile pour configurer la valeur initiale des LED et pour configurer la valeur initiale des broches de micro-pas du pilote de moteur pas \u00e0 pas. set_pwm_out pin=%u cycle_ticks=%u value=%hu : Cette commande configurera la broche donn\u00e9e pour utiliser la modulation de largeur d'impulsion (PWM) bas\u00e9e sur le mat\u00e9riel avec le nombre donn\u00e9 de cycle_ticks. Le \"cycle_ticks\" est le nombre de ticks d'horloge du MCU que chaque cycle de mise sous tension et hors tension doit durer. Une valeur cycle_ticks de 1 peut \u00eatre utilis\u00e9e pour demander le temps de cycle le plus rapide possible. Le param\u00e8tre \"valeur\" est compris entre 0 et 255, 0 indiquant un \u00e9tat enti\u00e8rement d\u00e9sactiv\u00e9 et 255 indiquant un \u00e9tat enti\u00e8rement activ\u00e9. Cette commande peut \u00eatre utile pour activer les ventilateurs de refroidissement du processeur et des buses.","title":"Commandes de d\u00e9marrage"},{"location":"MCU_Commands.html#configuration-bas-niveau-du-microcontroleur","text":"La plupart des commandes du microcontr\u00f4leur n\u00e9cessitent une configuration initiale avant de pouvoir \u00eatre appel\u00e9es. Cette section fournit une vue d'ensemble du processus de configuration. Cette section et les sections suivantes ne sont susceptibles d'int\u00e9resser que les d\u00e9veloppeurs int\u00e9ress\u00e9s par les d\u00e9tails internes de Klipper. Lorsque l'h\u00f4te se connecte pour la premi\u00e8re fois au microcontr\u00f4leur, il commence toujours par obtenir un dictionnaire de donn\u00e9es (voir protocole pour plus d'informations). Une fois le dictionnaire de donn\u00e9es obtenu, l'h\u00f4te v\u00e9rifie si le microcontr\u00f4leur est dans un \u00e9tat \"configur\u00e9\" et le configure si ce n'est pas le cas. La configuration comprend les phases suivantes : get_config : L'h\u00f4te commence par v\u00e9rifier si le micro-contr\u00f4leur est d\u00e9j\u00e0 configur\u00e9. Le microcontr\u00f4leur r\u00e9pond \u00e0 cette commande par un message de r\u00e9ponse \u00ab config \u00bb. Le logiciel du microcontr\u00f4leur d\u00e9marre toujours dans un \u00e9tat non configur\u00e9 \u00e0 la mise sous tension. Il reste dans cet \u00e9tat jusqu'\u00e0 ce que l'h\u00f4te termine les processus de configuration (en \u00e9mettant une commande finalize_config). Si le microcontr\u00f4leur est d\u00e9j\u00e0 configur\u00e9 \u00e0 partir d'une session pr\u00e9c\u00e9dente (et est configur\u00e9 avec les param\u00e8tres souhait\u00e9s), aucune autre action n'est requise de la part de l'h\u00f4te et le processus de configuration se termine avec succ\u00e8s. allocate_oids count=%c : cette commande est envoy\u00e9e pour informer le microcontr\u00f4leur du nombre maximal d'identifiants d'objet (oid) requis par l'h\u00f4te. Il n'e faut envoyer cette commande qu'une seule fois. Un oid est un identifiant entier allou\u00e9 \u00e0 chaque stepper, chaque fin de course et chaque broche gpio programmable. L'h\u00f4te d\u00e9termine \u00e0 l'avance le nombre d'oids dont il aura besoin pour faire fonctionner le mat\u00e9riel et le transmet au microcontr\u00f4leur afin qu'il puisse allouer suffisamment de m\u00e9moire pour stocker un mappage de l'oid \u00e0 l'objet interne. config_XXX oid=%c ... : Par convention toute commande commen\u00e7ant par le pr\u00e9fixe \"config_\" cr\u00e9e un nouvel objet microcontr\u00f4leur et lui affecte l'oid donn\u00e9. Par exemple, la commande config_digital_out configurera la broche sp\u00e9cifi\u00e9e en tant que GPIO de sortie num\u00e9rique et cr\u00e9era un objet interne que l'h\u00f4te peut utiliser pour planifier des modifications du GPIO donn\u00e9. Le param\u00e8tre oid pass\u00e9 dans la commande config est s\u00e9lectionn\u00e9 par l'h\u00f4te et doit \u00eatre compris entre z\u00e9ro et le nombre maximal fourni dans la commande allow_oids. Les commandes de configuration ne peuvent \u00eatre ex\u00e9cut\u00e9es que lorsque le microcontr\u00f4leur n'est pas dans un \u00e9tat configur\u00e9 (c'est-\u00e0-dire avant que l'h\u00f4te n'envoie finalize_config) et apr\u00e8s que la commande allow_oids a \u00e9t\u00e9 envoy\u00e9e. finalize_config crc=%u : La commande finalize_config fait passer le microcontr\u00f4leur d'un \u00e9tat non configur\u00e9 \u00e0 un \u00e9tat configur\u00e9. Le param\u00e8tre crc transmis au microcontr\u00f4leur est stock\u00e9 et renvoy\u00e9 \u00e0 l'h\u00f4te dans les messages de r\u00e9ponse \"config\". Par convention, l'h\u00f4te prend un CRC 32 bits de la configuration qu'il demandera et au d\u00e9but des sessions de communication suivantes, il v\u00e9rifie que le CRC stock\u00e9 dans le microcontr\u00f4leur correspond exactement \u00e0 son CRC souhait\u00e9. Si le CRC ne correspond pas, l'h\u00f4te saura que le microcontr\u00f4leur n'a pas \u00e9t\u00e9 configur\u00e9 correctement.","title":"Configuration bas niveau du microcontr\u00f4leur"},{"location":"MCU_Commands.html#objets-de-base-du-microcontroleur","text":"Cette section r\u00e9pertorie quelques commandes de configuration couramment utilis\u00e9es. config_digital_out oid=%c pin=%u value=%c default_value=%c max_duration=%u : cette commande cr\u00e9e un objet de microcontr\u00f4leur interne pour la \"broche\" GPIO donn\u00e9e. La broche sera configur\u00e9e en mode de sortie num\u00e9rique et d\u00e9finie sur une valeur initiale telle que sp\u00e9cifi\u00e9e par 'value' (0 pour bas, 1 pour haut). La cr\u00e9ation d'un objet digital_out permet \u00e0 l'h\u00f4te de programmer des mises \u00e0 jour GPIO pour la broche donn\u00e9e \u00e0 des heures sp\u00e9cifi\u00e9es (voir la commande queue_digital_out d\u00e9crite ci-dessous). Si le logiciel du microcontr\u00f4leur passe en mode d'arr\u00eat, tous les objets digital_out configur\u00e9s seront d\u00e9finis sur 'default_value'. Le param\u00e8tre 'max_duration' est utilis\u00e9 pour impl\u00e9menter un contr\u00f4le de s\u00e9curit\u00e9 - s'il est diff\u00e9rent de z\u00e9ro, il s'agit du nombre maximal de ticks d'horloge pendannt lesquels l'h\u00f4te peut d\u00e9finir le GPIO donn\u00e9 sur une valeur autre que celle par d\u00e9faut sans autres mises \u00e0 jour. Par exemple, si la default_value est z\u00e9ro et la max_duration est de 16000, alors si l'h\u00f4te d\u00e9finit le gpio sur une valeur de un, il doit planifier une autre mise \u00e0 jour de la broche gpio (\u00e0 z\u00e9ro ou \u00e0 un) dans les 16000 tics d'horloge. Cette fonction de s\u00e9curit\u00e9 peut \u00eatre utilis\u00e9e avec des broches de chauffage pour s'assurer que l'h\u00f4te n'active pas le chauffage puis se d\u00e9connecte en le laissant activ\u00e9. config_pwm_out oid=%c pin=%u cycle_ticks=%u value=%hu default_value=%hu max_duration=%u : cette commande cr\u00e9e un objet interne pour les broches PWM mat\u00e9rielles pour lesquelles l'h\u00f4te peut planifier des mises \u00e0 jour . Son utilisation est analogue \u00e0 config_digital_out - voir la description des commandes 'set_pwm_out' et 'config_digital_out' pour la description des param\u00e8tres. config_analog_in oid=%c pin=%u : Cette commande permet de configurer une broche en mode d'\u00e9chantillonnage d'entr\u00e9e analogique. Une fois configur\u00e9e, la broche peut \u00eatre \u00e9chantillonn\u00e9e \u00e0 intervalle r\u00e9gulier \u00e0 l'aide de la commande query_analog_in (voir ci-dessous). config_stepper oid=%c step_pin=%c dir_pin=%c invert_step=%c step_pulse_ticks=%u : Cette commande cr\u00e9e un objet \"moteur pas \u00e0 pas\" interne. Les param\u00e8tres 'step_pin' et 'dir_pin' sp\u00e9cifient respectivement les broches de pas et de direction ; cette commande les configurera en mode de sortie num\u00e9rique. Le param\u00e8tre 'invert_step' sp\u00e9cifie si une \u00e9tape se produit sur un front montant (invert_step=0) ou descendant (invert_step=1). Le param\u00e8tre 'step_pulse_ticks' sp\u00e9cifie la dur\u00e9e minimale de l'impulsion de pas. Si le mcu exporte la constante 'STEPPER_BOTH_EDGE=1', le r\u00e9glage step_pulse_ticks=0 et invert_step=-1 sera configur\u00e9 pour marcher sur les fronts montant et descendant de la broche de pas. config_endstop oid=%c pin=%c pull_up=%c stepper_count=%c : Cette commande cr\u00e9e un objet \"endstop\" interne. Il est utilis\u00e9 pour sp\u00e9cifier les broches d'arr\u00eat et pour activer les op\u00e9rations de \"homing\" (voir la commande endstop_home ci-dessous). La commande configurera la broche sp\u00e9cifi\u00e9e en mode d'entr\u00e9e num\u00e9rique. Le param\u00e8tre 'pull_up' d\u00e9termine si les r\u00e9sistances pullup fournies par le mat\u00e9riel pour la broche (si disponibles) seront activ\u00e9es. Le param\u00e8tre 'stepper_count' sp\u00e9cifie le nombre maximum de pas dont cette but\u00e9e peut avoir besoin pendant une op\u00e9ration de prise d'origine (voir endstop_home ci-dessous). config_spi oid=%c bus=%u pin=%u mode=%u rate=%u shutdown_msg=%*s : Cette commande cr\u00e9e un objet SPI interne. Il est utilis\u00e9 avec les commandes spi_transfer et spi_send (voir ci-dessous). Le param\u00e8tre \"bus\" identifie le bus SPI \u00e0 utiliser (si le microcontr\u00f4leur a plus d'un bus SPI disponible). Le param\u00e8tre \"broche\" sp\u00e9cifie la broche de s\u00e9lection de puce (CS) pour le p\u00e9riph\u00e9rique. Le param\u00e8tre \"mode\" est le mode SPI (doit \u00eatre compris entre 0 et 3). Le param\u00e8tre \"rate\" sp\u00e9cifie le d\u00e9bit du bus SPI (en cycles par seconde). Enfin, le param\u00e8tre \"shutdown_msg\" est une commande SPI \u00e0 envoyer \u00e0 l'appareil donn\u00e9 si le microcontr\u00f4leur passe en \u00e9tat d'arr\u00eat. config_spi_without_cs oid=%c bus=%u mode=%u rate=%u shutdown_msg=%*s : Cette commande est similaire \u00e0 config_spi, mais sans d\u00e9finition de la broche CS. Il est utile pour les appareils SPI qui n'ont pas de ligne de s\u00e9lection de puce.","title":"Objets de base du microcontr\u00f4leur"},{"location":"MCU_Commands.html#commandes-courantes","text":"Cette section r\u00e9pertorie les commandes les plus couramment utilis\u00e9es. Cela n'int\u00e9resse probablement que les d\u00e9veloppeurs qui cherchent \u00e0 mieux comprendre Klipper. set_digital_out_pwm_cycle oid=%c cycle_ticks=%u : cette commande configure une broche de sortie num\u00e9rique (telle que cr\u00e9\u00e9e par config_digital_out) pour utiliser le \"PWM logciel\". Le 'cycle_ticks' est le nombre de tics d'horloge pour le cycle PWM. \u00c9tant donn\u00e9 que la commutation de sortie est impl\u00e9ment\u00e9e dans le logiciel du microcontr\u00f4leur, il est recommand\u00e9 que 'cycle_ticks' corresponde \u00e0 un temps de 10 ms ou plus. queue_digital_out oid=%c clock=%u on_ticks=%u : Cette commande permet de planifier une changement d'\u00e9tat d'une broche GPIO de sortie num\u00e9rique au tick d'horloge donn\u00e9e. Pour utiliser cette commande, une commande 'config_digital_out' avec le m\u00eame param\u00e8tre 'oid' doit avoir \u00e9t\u00e9 \u00e9mise lors de la configuration du microcontr\u00f4leur. Si 'set_digital_out_pwm_cycle' a \u00e9t\u00e9 appel\u00e9, alors 'on_ticks' est la dur\u00e9e d'activation (en ticks d'horloge) pour le cycle pwm. Sinon, 'on_ticks' doit \u00eatre soit 0 (pour basse tension) soit 1 (pour haute tension). queue_pwm_out oid=%c clock=%u value=%hu : planifie un changement sur une broche de sortie PWM mat\u00e9rielle. Voir les commandes 'queue_digital_out' et 'config_pwm_out' pour plus d'informations. query_analog_in oid=%c clock=%u sample_ticks=%u sample_count=%c rest_ticks=%u min_value=%hu max_value=%hu : Cette commande d\u00e9finit une r\u00e9cup\u00e9ration r\u00e9currente d'\u00e9chantillons d'entr\u00e9e analogique. Pour utiliser cette commande, une commande 'config_analog_in' avec le m\u00eame param\u00e8tre 'oid' doit avoir \u00e9t\u00e9 \u00e9mise lors de la configuration du microcontr\u00f4leur. Les \u00e9chantillons commenceront \u00e0 partir de l'heure 'clock', et ils rapporteront la valeur obtenue \u00e0 chaque tic d'horloge 'rest_ticks', il sur\u00e9chantillonnera avec un nombre 'sample_count' d'\u00e9chantillons et il se mettra en pause pendant le nombre 'sample_ticks' de tic d'horloge entre chaque \u00e9chantillonnage. Les param\u00e8tres 'min_value' et 'max_value' impl\u00e9mentent une fonction de s\u00e9curit\u00e9 - le logiciel du microcontr\u00f4leur v\u00e9rifiera que la valeur \u00e9chantillonn\u00e9e se situe toujours dans la plage fournie. Ceci est destin\u00e9 \u00e0 \u00eatre utilis\u00e9 avec des broches rattach\u00e9es aux thermistances contr\u00f4lant les radiateurs - il peut \u00eatre utilis\u00e9 pour v\u00e9rifier qu'un radiateur se trouve dans une plage de temp\u00e9rature correcte. get_clock : Cette commande am\u00e8ne le microcontr\u00f4leur \u00e0 g\u00e9n\u00e9rer un message de r\u00e9ponse \"clock\". L'h\u00f4te envoie cette commande une fois par seconde pour obtenir la valeur de l'horloge du microcontr\u00f4leur et pour estimer la d\u00e9rive entre les horloges de l'h\u00f4te et du microcontr\u00f4leur. Il permet \u00e0 l'h\u00f4te d'estimer avec pr\u00e9cision l'horloge du microcontr\u00f4leur.","title":"Commandes courantes"},{"location":"MCU_Commands.html#commandes-de-moteurs-pas-a-pas","text":"queue_step oid=%c interval=%u count=%hu add=%hi : cette commande planifie le nombre de pas 'count' pour le stepper donn\u00e9, avec un nombre 'd'intervalle' de ticks d'horloge entre chaque pas. La premi\u00e8re \u00e9tape sera le nombre \"d'intervalle\" de ticks d'horloge depuis la derni\u00e8re \u00e9tape planifi\u00e9e pour le stepper donn\u00e9. Si 'add' n'est pas nul, l'intervalle sera ajust\u00e9 du montant 'add' apr\u00e8s chaque pas. Cette commande ajoute la s\u00e9quence d'intervalle/compte/ajout donn\u00e9e \u00e0 une file d'attente des pas. Il peut y avoir des centaines de ces s\u00e9quences en file d'attente pendant le fonctionnement normal. Une nouvelle s\u00e9quence est ajout\u00e9e \u00e0 la fin de la file d'attente et lorsque chaque s\u00e9quence termine son nombre de pas, elle est retir\u00e9e du d\u00e9but de la file d'attente. Ce syst\u00e8me permet au microcontr\u00f4leur de mettre en file d'attente potentiellement des centaines de milliers d'\u00e9tapes, le tout avec des dur\u00e9es fiables et pr\u00e9visibles. set_next_step_dir oid=%c dir=%c : Cette commande sp\u00e9cifie la valeur du dir_pin que la prochaine commande queue_step utilisera. reset_step_clock oid=%c clock=%u : Normalement, la synchronisation des pas est relative au dernier pas pour un stepper donn\u00e9. Cette commande r\u00e9initialise l'horloge de sorte que l'\u00e9tape suivante soit relative \u00e0 l'heure \"horloge\" fournie. L'h\u00f4te n'envoie g\u00e9n\u00e9ralement cette commande qu'au d\u00e9but d'une impression. stepper_get_position oid=%c : Cette commande am\u00e8ne le microcontr\u00f4leur \u00e0 g\u00e9n\u00e9rer un message de r\u00e9ponse \"stepper_position\" avec la position actuelle du stepper. La position est le nombre total d'\u00e9tapes g\u00e9n\u00e9r\u00e9es avec dir=1 moins le nombre total d'\u00e9tapes g\u00e9n\u00e9r\u00e9es avec dir=0. endstop_home oid=%c clock=%u sample_ticks=%u sample_count=%c rest_ticks=%u pin_value=%c : Cette commande est utilis\u00e9e lors des op\u00e9rations de \"homing\" des moteurs pas \u00e0 pas. Pour utiliser cette commande, une commande 'config_endstop' avec le m\u00eame param\u00e8tre 'oid' doit avoir \u00e9t\u00e9 \u00e9mise lors de la configuration du microcontr\u00f4leur. Lorsque cette commande est invoqu\u00e9e, le microcontr\u00f4leur \u00e9chantillonnera la broche endstop \u00e0 chaque tic d'horloge 'rest_ticks' et v\u00e9rifiera si elle a une valeur \u00e9gale \u00e0 'pin_value'. Si la valeur correspond (et continue de correspondre pour 'sample_count' \u00e9chantillons suppl\u00e9mentaires r\u00e9partis 'sample_ticks'), alors la file d'attente de mouvement pour le stepper associ\u00e9 sera effac\u00e9e et le stepper s'arr\u00eatera imm\u00e9diatement. L'h\u00f4te utilise cette commande pour impl\u00e9menter la prise d'origine - l'h\u00f4te demande \u00e0 la but\u00e9e d'\u00e9chantillonner pour le d\u00e9clencheur de but\u00e9e, puis il \u00e9met une s\u00e9rie de commandes queue_step pour d\u00e9placer un stepper vers la but\u00e9e. Une fois que le stepper atteint la but\u00e9e, le d\u00e9clencheur sera d\u00e9tect\u00e9, le mouvement arr\u00eat\u00e9 et l'h\u00f4te notifi\u00e9.","title":"Commandes de moteurs pas \u00e0 pas"},{"location":"MCU_Commands.html#deplacer-la-file-dattente","text":"Chaque commande queue_step utilise une entr\u00e9e dans la \"file d'attente de d\u00e9placement\" du microcontr\u00f4leur. Cette file d'attente est allou\u00e9e lorsqu'elle re\u00e7oit la commande \"finalize_config\", et elle signale le nombre d'entr\u00e9es de file d'attente disponibles dans les messages de r\u00e9ponse \"config\". Il est de la responsabilit\u00e9 de l'h\u00f4te de s'assurer qu'il y a de l'espace disponible dans la file d'attente avant d'envoyer une commande queue_step. Pour ce faire, l'h\u00f4te calcule le moment o\u00f9 chaque commande queue_step se termine et planifie de nouvelles commandes queue_step en cons\u00e9quence.","title":"D\u00e9placer la file d'attente"},{"location":"MCU_Commands.html#commandes-spi","text":"spi_transfer oid=%c data=%*s : Cette commande am\u00e8ne le microcontr\u00f4leur \u00e0 envoyer des \"donn\u00e9es\" au p\u00e9riph\u00e9rique spi sp\u00e9cifi\u00e9 par \"oid\" et g\u00e9n\u00e8re un message de r\u00e9ponse \"spi_transfer_response\" avec les donn\u00e9es retourn\u00e9es par le p\u00e9riph\u00e9rique. spi_send oid=%c data=%*s : Cette commande est similaire \u00e0 \"spi_transfer\", mais elle ne g\u00e9n\u00e8re pas de message \"spi_transfer_response\".","title":"Commandes SPI"},{"location":"Manual_Level.html","text":"Nivellement manuel \u00b6 Ce document d\u00e9crit les outils pour le r\u00e9glage de la fin de course Z et pour effectuer les r\u00e9glages sur les vis de mise \u00e0 niveau du lit. Calibrer la fin de course Z \u00b6 Une position pr\u00e9cise de la but\u00e9e Z est essentielle pour obtenir des impressions de haute qualit\u00e9. Notez que la pr\u00e9cision de l'interrupteur de fin de course Z lui-m\u00eame peut \u00eatre un facteur limitant. Si vous utilisez des pilotes de moteurs pas \u00e0 pas Trinamic, pensez \u00e0 activer la d\u00e9tection endstop phase pour am\u00e9liorer la pr\u00e9cision du commutateur. Pour effectuer un \u00e9talonnage de la fin de course Z, placez l'imprimante \u00e0 l'origine, d\u00e9placez la t\u00eate vers une position Z situ\u00e9e \u00e0 au moins cinq millim\u00e8tres au-dessus du lit (si ce n'est d\u00e9j\u00e0 fait), d\u00e9placez ensuite la t\u00eate vers une position XY pr\u00e8s du centre de le lit, puis acc\u00e9dez \u00e0 l'aide du terminal ex\u00e9cutez : Z_ENDSTOP_CALIBRATE Suivez ensuite les \u00e9tapes d\u00e9crites dans \"le test du papier\" pour d\u00e9terminer la distance r\u00e9elle entre la buse et le lit \u00e0 l'emplacement donn\u00e9. Une fois ces \u00e9tapes termin\u00e9es, on peut taper ACCEPT pour valider la position et enregistrer les r\u00e9sultats dans le fichier de configuration avec : SAVE_CONFIG Il est pr\u00e9f\u00e9rable d'utiliser un interrupteur de fin de course Z \u00e0 l'extr\u00e9mit\u00e9 de l'axe Z oppos\u00e9e au lit (il est plus s\u00e9curisant d'effectuer le retour au point d'origine loin du lit). Cependant, si l'on doit se diriger vers le lit, il est recommand\u00e9 de r\u00e9gler la but\u00e9e de fin de course de mani\u00e8re \u00e0 ce qu'elle se d\u00e9clenche \u00e0 une petite distance (par exemple, 0,5 mm) au-dessus du lit. Presque tous les interrupteurs de fin de course peuvent \u00eatre enfonc\u00e9s en toute s\u00e9curit\u00e9 \u00e0 une petite distance au-del\u00e0 de leur point de d\u00e9clenchement. Lorsque cela est fait, on devrait constater que la commande Z_ENDSTOP_CALIBRATE rapporte une petite valeur positive (par exemple, 0,5 mm) pour la position Z_endstop. D\u00e9clencher la but\u00e9e de fin de course alors qu'elle est encore \u00e0 une certaine distance du lit r\u00e9duit le risque d'\u00e9crasement involontaire de la buse sur le lit. Certaines imprimantes laissent la possibilit\u00e9 d'ajuster manuellement l'emplacement de l'interrupteur de fin de course. Cependant, il est recommand\u00e9 d'effectuer le positionnement de la but\u00e9e Z dans le logiciel avec Klipper - une fois que la but\u00e9e est bien positionn\u00e9, on peut faire d'autres ajustements en ex\u00e9cutant Z_ENDSTOP_CALIBRATE ou en mettant \u00e0 jour manuellement la position Z_endstop dans le fichier de configuration. R\u00e9glage des vis de mise \u00e0 niveau du lit \u00b6 Le secret pour obtenir un bon nivellement du lit avec les vis est d'utiliser le syst\u00e8me de mouvement de haute pr\u00e9cision de l'imprimante pendant le processus de nivellement du lit lui-m\u00eame. Cela se fait en commandant la buse \u00e0 une position proche de chaque vis de r\u00e9glage du lit, puis en ajustant cette vis jusqu'\u00e0 ce que le lit soit \u00e0 une distance d\u00e9finie de la buse. Klipper a un outil pour vous aider. Pour utiliser l'outil, il est n\u00e9cessaire de sp\u00e9cifier l'emplacement XY de chaque vis. Cela se fait en cr\u00e9ant une section de configuration [bed_screws] . Par exemple, cela pourrait ressembler \u00e0 : [bed_screws] screw1: 100, 50 screw2: 100, 150 screw3: 150, 100 Si la vis de r\u00e9glage se trouve sous le lit, sp\u00e9cifiez la position XY directement au-dessus de la vis. Si la vis est \u00e0 l'ext\u00e9rieur du lit, sp\u00e9cifiez une position XY la plus proche de la vis tout en restant dans les limites du lit. Une fois que le fichier de configuration est pr\u00eat, ex\u00e9cutez RESTART pour charger la nouvelle configuration, puis vous pouvez d\u00e9marrer l'outil en ex\u00e9cutant : BED_SCREWS_ADJUST Cet outil va d\u00e9placer la buse de l'imprimante vers chaque emplacement XY de vis, puis d\u00e9placera la buse \u00e0 une hauteur Z = 0. \u00c0 ce stade, on peut utiliser le \"test du papier\" pour ajuster la vis de r\u00e9glage directement sous la buse. Voir les informations d\u00e9crites dans \"le test du papier\" , mais ajustez la vis de r\u00e9glage au lieu de d\u00e9placer la buse \u00e0 diff\u00e9rentes hauteurs. Ajustez la vis de r\u00e9glage jusqu'\u00e0 ce qu'il y ait une petite friction lorsque vous poussez le papier d'avant en arri\u00e8re. Une fois la vis ajust\u00e9e de mani\u00e8re \u00e0 ressentir une l\u00e9g\u00e8re friction, ex\u00e9cutez la commande ACCEPT ou ADJUSTED . Utilisez la commande ADJUSTED si la vis du lit n\u00e9cessitait un ajustement (g\u00e9n\u00e9ralement plus d'environ 1/8 de tour de vis). Utilisez la commande ACCEPTER si aucun ajustement significatif n'est n\u00e9cessaire. Les deux commandes feront passer l'outil \u00e0 la vis suivante. (Lorsqu'une commande ADJUSTED est utilis\u00e9e, l'outil programme un cycle suppl\u00e9mentaire d'ajustements des vis\u202f; l'outil se termine avec succ\u00e8s lorsque toutes les vis d'assise sont v\u00e9rifi\u00e9es pour ne pas n\u00e9cessiter d'ajustements importants.) On peut utiliser la commande ABORT pour quitter l'outil plus t\u00f4t. Ce syst\u00e8me fonctionne mieux lorsque l'imprimante a une surface d'impression plate (telle que du verre) et des rails rectilignes. Une fois l'outil de nivellement du lit termin\u00e9 avec succ\u00e8s, le lit est pr\u00eat pour l'impression. R\u00e9glages fin des vis de nivellement \u00b6 Si l'imprimante utilise trois vis de r\u00e9glages et que les trois vis sont sous le lit, il est alors \u00eatre possible d'effectuer une deuxi\u00e8me \u00e9tape de mise \u00e0 niveau du lit de \u00ab haute pr\u00e9cision \u00bb. Cela se fait en d\u00e9pla\u00e7ant la buse vers les endroits les plus \u00e9loign\u00e9s des vis de r\u00e9glages. Par exemple, consid\u00e9rons un lit avec des vis aux emplacements A, B et C : Pour chaque r\u00e9glage effectu\u00e9 sur la vis du lit \u00e0 l'emplacement C, le lit oscillera le long d'un axe d\u00e9fini par les deux vis du lit restantes (repr\u00e9sent\u00e9es ici par une ligne verte). Dans cette situation, chaque r\u00e9glage de la vis du lit en C d\u00e9placera le lit en position D d'une plus grande distance que directement en C. Il est ainsi possible d'effectuer un r\u00e9glage am\u00e9lior\u00e9 de la vis C lorsque la buse est en position D. Pour activer cette fonctionnalit\u00e9, il faudra d\u00e9terminer les coordonn\u00e9es suppl\u00e9mentaires de la buse et les ajouter au fichier de configuration. Par exemple, cela pourrait ressembler \u00e0 : [bed_screws] screw1: 100, 50 screw1_fine_adjust: 0, 0 screw2: 100, 150 screw2_fine_adjust: 300, 300 screw3: 150, 100 screw3_fine_adjust: 0, 100 Lorsque cette fonctionnalit\u00e9 est activ\u00e9e, la commande BED_SCREWS_ADJUST demandera d'abord des ajustements grossiers directement au-dessus de chaque position de vis, et une fois ceux-ci accept\u00e9s, il demandera des ajustements fins aux emplacements suppl\u00e9mentaires. Continuez \u00e0 utiliser ACCEPT et ADJUSTED \u00e0 chaque position. R\u00e9glage des vis de mise \u00e0 niveau du lit \u00e0 l'aide de la sonde de lit \u00b6 C'est une autre fa\u00e7on de calibrer le niveau du lit avec la sonde de lit. Pour l'utiliser, vous devez disposer d'une sonde Z (BL Touch, capteur inductif, etc.). Pour activer cette fonctionnalit\u00e9, il faut d\u00e9terminer les coordonn\u00e9es de la buse de sorte que la sonde Z soit au-dessus des vis, puis les ajouter au fichier de configuration. Par exemple, cela pourrait ressembler \u00e0 : [screws_tilt_adjust] screw1: -5, 30 screw1_name: front left screw screw2: 155, 30 screw2_name: front right screw screw3: 155, 190 screw3_name: rear right screw screw4: -5, 190 screw4_name: rear left screw horizontal_move_z: 10. speed: 50. screw_thread: CW-M3 La vis1 est toujours le point de r\u00e9f\u00e9rence pour les autres, donc le syst\u00e8me suppose que la vis1 est \u00e0 la bonne hauteur. Ex\u00e9cutez toujours G28 en premier, puis ex\u00e9cutez SCREWS_TILT_CALCULATE - cela devrait produire une sortie similaire \u00e0 : Send: G28 Recv: ok Send: SCREWS_TILT_CALCULATE Recv: // 01:20 means 1 full turn and 20 minutes, CW=clockwise, CCW=counter-clockwise Recv: // front left screw (base) : x=-5.0, y=30.0, z=2.48750 Recv: // front right screw : x=155.0, y=30.0, z=2.36000 : adjust CW 01:15 Recv: // rear right screw : y=155.0, y=190.0, z=2.71500 : adjust CCW 00:50 Recv: // read left screw : x=-5.0, y=190.0, z=2.47250 : adjust CW 00:02 Recv: ok Cela signifie que : la vis avant gauche est le point de r\u00e9f\u00e9rence vous ne devez pas la changer. la vis avant droite doit \u00eatre tourn\u00e9e dans le sens des aiguilles d'une montre d'un tour complet et d'un quart de tour La vis arri\u00e8re droite doit \u00eatre tourn\u00e9e dans le sens inverse des aiguilles d\u2019une montre d'environ 50 minutes la vis arri\u00e8re gauche doit \u00eatre tourn\u00e9e dans le sens des aiguilles d'une montre d'un angle de 2 minutes (pas besoin c'est ok) Notez que \"minutes\" fait r\u00e9f\u00e9rence aux \"minutes d'un cadran d'horloge\". Ainsi, par exemple, 15 minutes correspondent \u00e0 un quart de tour complet. R\u00e9p\u00e9tez le processus plusieurs fois jusqu'\u00e0 ce que vous obteniez un bon niveau de lit - normalement lorsque tous les ajustements sont inf\u00e9rieurs \u00e0 une rotation de 6 minutes des vis de r\u00e9glage. Si vous utilisez une sonde mont\u00e9e sur le c\u00f4t\u00e9 de la hotend (c'est-\u00e0-dire qu'elle a un d\u00e9calage X ou Y), notez que le r\u00e9glage de l'inclinaison du lit rendra caduc l'\u00e9talonnage de sonde pr\u00e9c\u00e9demment effectu\u00e9 avec un lit inclin\u00e9. Assurez-vous d'ex\u00e9cuter \u00e9talonnage de la sonde apr\u00e8s avoir ajust\u00e9 les vis du lit. Le param\u00e8tre MAX_DEVIATION est utile lorsqu'un maillage de lit sauvegard\u00e9 est utilis\u00e9, pour s'assurer que le niveau du lit n'a pas trop d\u00e9riv\u00e9 de l'endroit o\u00f9 il se trouvait lorsque le maillage a \u00e9t\u00e9 cr\u00e9\u00e9. Par exemple, SCREWS_TILT_CALCULATE MAX_DEVIATION=0.01 peut \u00eatre ajout\u00e9 au gcode de d\u00e9marrage personnalis\u00e9 du trancheur avant le chargement du maillage. Il interrompra l'impression si la limite configur\u00e9e est d\u00e9pass\u00e9e (0,01 mm dans cet exemple), donnant \u00e0 l'utilisateur une chance d'ajuster les vis et de red\u00e9marrer l'impression. Le param\u00e8tre DIRECTION est utile si vous ne pouvez tourner les vis de r\u00e9glage de votre lit que dans un seul sens. Par exemple, vous pourriez avoir des vis qui commencent \u00e0 \u00eatre serr\u00e9es dans leur position la plus basse (ou la plus haute) possible, qui ne peuvent \u00eatre tourn\u00e9es que dans une seule direction, pour \u00e9lever (ou abaisser) le lit. Si vous ne pouvez tourner les vis que dans le sens des aiguilles d'une montre, ex\u00e9cutez SCREWS_TILT_CALCULATE DIRECTION=CW . Si vous ne pouvez les tourner que dans le sens antihoraire, ex\u00e9cutez SCREWS_TILT_CALCULATE DIRECTION=CCW . Un point de r\u00e9f\u00e9rence appropri\u00e9 sera choisi de sorte que le lit puisse \u00eatre nivel\u00e9 en tournant toutes les vis dans la direction donn\u00e9e.","title":"Nivellement manuel"},{"location":"Manual_Level.html#nivellement-manuel","text":"Ce document d\u00e9crit les outils pour le r\u00e9glage de la fin de course Z et pour effectuer les r\u00e9glages sur les vis de mise \u00e0 niveau du lit.","title":"Nivellement manuel"},{"location":"Manual_Level.html#calibrer-la-fin-de-course-z","text":"Une position pr\u00e9cise de la but\u00e9e Z est essentielle pour obtenir des impressions de haute qualit\u00e9. Notez que la pr\u00e9cision de l'interrupteur de fin de course Z lui-m\u00eame peut \u00eatre un facteur limitant. Si vous utilisez des pilotes de moteurs pas \u00e0 pas Trinamic, pensez \u00e0 activer la d\u00e9tection endstop phase pour am\u00e9liorer la pr\u00e9cision du commutateur. Pour effectuer un \u00e9talonnage de la fin de course Z, placez l'imprimante \u00e0 l'origine, d\u00e9placez la t\u00eate vers une position Z situ\u00e9e \u00e0 au moins cinq millim\u00e8tres au-dessus du lit (si ce n'est d\u00e9j\u00e0 fait), d\u00e9placez ensuite la t\u00eate vers une position XY pr\u00e8s du centre de le lit, puis acc\u00e9dez \u00e0 l'aide du terminal ex\u00e9cutez : Z_ENDSTOP_CALIBRATE Suivez ensuite les \u00e9tapes d\u00e9crites dans \"le test du papier\" pour d\u00e9terminer la distance r\u00e9elle entre la buse et le lit \u00e0 l'emplacement donn\u00e9. Une fois ces \u00e9tapes termin\u00e9es, on peut taper ACCEPT pour valider la position et enregistrer les r\u00e9sultats dans le fichier de configuration avec : SAVE_CONFIG Il est pr\u00e9f\u00e9rable d'utiliser un interrupteur de fin de course Z \u00e0 l'extr\u00e9mit\u00e9 de l'axe Z oppos\u00e9e au lit (il est plus s\u00e9curisant d'effectuer le retour au point d'origine loin du lit). Cependant, si l'on doit se diriger vers le lit, il est recommand\u00e9 de r\u00e9gler la but\u00e9e de fin de course de mani\u00e8re \u00e0 ce qu'elle se d\u00e9clenche \u00e0 une petite distance (par exemple, 0,5 mm) au-dessus du lit. Presque tous les interrupteurs de fin de course peuvent \u00eatre enfonc\u00e9s en toute s\u00e9curit\u00e9 \u00e0 une petite distance au-del\u00e0 de leur point de d\u00e9clenchement. Lorsque cela est fait, on devrait constater que la commande Z_ENDSTOP_CALIBRATE rapporte une petite valeur positive (par exemple, 0,5 mm) pour la position Z_endstop. D\u00e9clencher la but\u00e9e de fin de course alors qu'elle est encore \u00e0 une certaine distance du lit r\u00e9duit le risque d'\u00e9crasement involontaire de la buse sur le lit. Certaines imprimantes laissent la possibilit\u00e9 d'ajuster manuellement l'emplacement de l'interrupteur de fin de course. Cependant, il est recommand\u00e9 d'effectuer le positionnement de la but\u00e9e Z dans le logiciel avec Klipper - une fois que la but\u00e9e est bien positionn\u00e9, on peut faire d'autres ajustements en ex\u00e9cutant Z_ENDSTOP_CALIBRATE ou en mettant \u00e0 jour manuellement la position Z_endstop dans le fichier de configuration.","title":"Calibrer la fin de course Z"},{"location":"Manual_Level.html#reglage-des-vis-de-mise-a-niveau-du-lit","text":"Le secret pour obtenir un bon nivellement du lit avec les vis est d'utiliser le syst\u00e8me de mouvement de haute pr\u00e9cision de l'imprimante pendant le processus de nivellement du lit lui-m\u00eame. Cela se fait en commandant la buse \u00e0 une position proche de chaque vis de r\u00e9glage du lit, puis en ajustant cette vis jusqu'\u00e0 ce que le lit soit \u00e0 une distance d\u00e9finie de la buse. Klipper a un outil pour vous aider. Pour utiliser l'outil, il est n\u00e9cessaire de sp\u00e9cifier l'emplacement XY de chaque vis. Cela se fait en cr\u00e9ant une section de configuration [bed_screws] . Par exemple, cela pourrait ressembler \u00e0 : [bed_screws] screw1: 100, 50 screw2: 100, 150 screw3: 150, 100 Si la vis de r\u00e9glage se trouve sous le lit, sp\u00e9cifiez la position XY directement au-dessus de la vis. Si la vis est \u00e0 l'ext\u00e9rieur du lit, sp\u00e9cifiez une position XY la plus proche de la vis tout en restant dans les limites du lit. Une fois que le fichier de configuration est pr\u00eat, ex\u00e9cutez RESTART pour charger la nouvelle configuration, puis vous pouvez d\u00e9marrer l'outil en ex\u00e9cutant : BED_SCREWS_ADJUST Cet outil va d\u00e9placer la buse de l'imprimante vers chaque emplacement XY de vis, puis d\u00e9placera la buse \u00e0 une hauteur Z = 0. \u00c0 ce stade, on peut utiliser le \"test du papier\" pour ajuster la vis de r\u00e9glage directement sous la buse. Voir les informations d\u00e9crites dans \"le test du papier\" , mais ajustez la vis de r\u00e9glage au lieu de d\u00e9placer la buse \u00e0 diff\u00e9rentes hauteurs. Ajustez la vis de r\u00e9glage jusqu'\u00e0 ce qu'il y ait une petite friction lorsque vous poussez le papier d'avant en arri\u00e8re. Une fois la vis ajust\u00e9e de mani\u00e8re \u00e0 ressentir une l\u00e9g\u00e8re friction, ex\u00e9cutez la commande ACCEPT ou ADJUSTED . Utilisez la commande ADJUSTED si la vis du lit n\u00e9cessitait un ajustement (g\u00e9n\u00e9ralement plus d'environ 1/8 de tour de vis). Utilisez la commande ACCEPTER si aucun ajustement significatif n'est n\u00e9cessaire. Les deux commandes feront passer l'outil \u00e0 la vis suivante. (Lorsqu'une commande ADJUSTED est utilis\u00e9e, l'outil programme un cycle suppl\u00e9mentaire d'ajustements des vis\u202f; l'outil se termine avec succ\u00e8s lorsque toutes les vis d'assise sont v\u00e9rifi\u00e9es pour ne pas n\u00e9cessiter d'ajustements importants.) On peut utiliser la commande ABORT pour quitter l'outil plus t\u00f4t. Ce syst\u00e8me fonctionne mieux lorsque l'imprimante a une surface d'impression plate (telle que du verre) et des rails rectilignes. Une fois l'outil de nivellement du lit termin\u00e9 avec succ\u00e8s, le lit est pr\u00eat pour l'impression.","title":"R\u00e9glage des vis de mise \u00e0 niveau du lit"},{"location":"Manual_Level.html#reglages-fin-des-vis-de-nivellement","text":"Si l'imprimante utilise trois vis de r\u00e9glages et que les trois vis sont sous le lit, il est alors \u00eatre possible d'effectuer une deuxi\u00e8me \u00e9tape de mise \u00e0 niveau du lit de \u00ab haute pr\u00e9cision \u00bb. Cela se fait en d\u00e9pla\u00e7ant la buse vers les endroits les plus \u00e9loign\u00e9s des vis de r\u00e9glages. Par exemple, consid\u00e9rons un lit avec des vis aux emplacements A, B et C : Pour chaque r\u00e9glage effectu\u00e9 sur la vis du lit \u00e0 l'emplacement C, le lit oscillera le long d'un axe d\u00e9fini par les deux vis du lit restantes (repr\u00e9sent\u00e9es ici par une ligne verte). Dans cette situation, chaque r\u00e9glage de la vis du lit en C d\u00e9placera le lit en position D d'une plus grande distance que directement en C. Il est ainsi possible d'effectuer un r\u00e9glage am\u00e9lior\u00e9 de la vis C lorsque la buse est en position D. Pour activer cette fonctionnalit\u00e9, il faudra d\u00e9terminer les coordonn\u00e9es suppl\u00e9mentaires de la buse et les ajouter au fichier de configuration. Par exemple, cela pourrait ressembler \u00e0 : [bed_screws] screw1: 100, 50 screw1_fine_adjust: 0, 0 screw2: 100, 150 screw2_fine_adjust: 300, 300 screw3: 150, 100 screw3_fine_adjust: 0, 100 Lorsque cette fonctionnalit\u00e9 est activ\u00e9e, la commande BED_SCREWS_ADJUST demandera d'abord des ajustements grossiers directement au-dessus de chaque position de vis, et une fois ceux-ci accept\u00e9s, il demandera des ajustements fins aux emplacements suppl\u00e9mentaires. Continuez \u00e0 utiliser ACCEPT et ADJUSTED \u00e0 chaque position.","title":"R\u00e9glages fin des vis de nivellement"},{"location":"Manual_Level.html#reglage-des-vis-de-mise-a-niveau-du-lit-a-laide-de-la-sonde-de-lit","text":"C'est une autre fa\u00e7on de calibrer le niveau du lit avec la sonde de lit. Pour l'utiliser, vous devez disposer d'une sonde Z (BL Touch, capteur inductif, etc.). Pour activer cette fonctionnalit\u00e9, il faut d\u00e9terminer les coordonn\u00e9es de la buse de sorte que la sonde Z soit au-dessus des vis, puis les ajouter au fichier de configuration. Par exemple, cela pourrait ressembler \u00e0 : [screws_tilt_adjust] screw1: -5, 30 screw1_name: front left screw screw2: 155, 30 screw2_name: front right screw screw3: 155, 190 screw3_name: rear right screw screw4: -5, 190 screw4_name: rear left screw horizontal_move_z: 10. speed: 50. screw_thread: CW-M3 La vis1 est toujours le point de r\u00e9f\u00e9rence pour les autres, donc le syst\u00e8me suppose que la vis1 est \u00e0 la bonne hauteur. Ex\u00e9cutez toujours G28 en premier, puis ex\u00e9cutez SCREWS_TILT_CALCULATE - cela devrait produire une sortie similaire \u00e0 : Send: G28 Recv: ok Send: SCREWS_TILT_CALCULATE Recv: // 01:20 means 1 full turn and 20 minutes, CW=clockwise, CCW=counter-clockwise Recv: // front left screw (base) : x=-5.0, y=30.0, z=2.48750 Recv: // front right screw : x=155.0, y=30.0, z=2.36000 : adjust CW 01:15 Recv: // rear right screw : y=155.0, y=190.0, z=2.71500 : adjust CCW 00:50 Recv: // read left screw : x=-5.0, y=190.0, z=2.47250 : adjust CW 00:02 Recv: ok Cela signifie que : la vis avant gauche est le point de r\u00e9f\u00e9rence vous ne devez pas la changer. la vis avant droite doit \u00eatre tourn\u00e9e dans le sens des aiguilles d'une montre d'un tour complet et d'un quart de tour La vis arri\u00e8re droite doit \u00eatre tourn\u00e9e dans le sens inverse des aiguilles d\u2019une montre d'environ 50 minutes la vis arri\u00e8re gauche doit \u00eatre tourn\u00e9e dans le sens des aiguilles d'une montre d'un angle de 2 minutes (pas besoin c'est ok) Notez que \"minutes\" fait r\u00e9f\u00e9rence aux \"minutes d'un cadran d'horloge\". Ainsi, par exemple, 15 minutes correspondent \u00e0 un quart de tour complet. R\u00e9p\u00e9tez le processus plusieurs fois jusqu'\u00e0 ce que vous obteniez un bon niveau de lit - normalement lorsque tous les ajustements sont inf\u00e9rieurs \u00e0 une rotation de 6 minutes des vis de r\u00e9glage. Si vous utilisez une sonde mont\u00e9e sur le c\u00f4t\u00e9 de la hotend (c'est-\u00e0-dire qu'elle a un d\u00e9calage X ou Y), notez que le r\u00e9glage de l'inclinaison du lit rendra caduc l'\u00e9talonnage de sonde pr\u00e9c\u00e9demment effectu\u00e9 avec un lit inclin\u00e9. Assurez-vous d'ex\u00e9cuter \u00e9talonnage de la sonde apr\u00e8s avoir ajust\u00e9 les vis du lit. Le param\u00e8tre MAX_DEVIATION est utile lorsqu'un maillage de lit sauvegard\u00e9 est utilis\u00e9, pour s'assurer que le niveau du lit n'a pas trop d\u00e9riv\u00e9 de l'endroit o\u00f9 il se trouvait lorsque le maillage a \u00e9t\u00e9 cr\u00e9\u00e9. Par exemple, SCREWS_TILT_CALCULATE MAX_DEVIATION=0.01 peut \u00eatre ajout\u00e9 au gcode de d\u00e9marrage personnalis\u00e9 du trancheur avant le chargement du maillage. Il interrompra l'impression si la limite configur\u00e9e est d\u00e9pass\u00e9e (0,01 mm dans cet exemple), donnant \u00e0 l'utilisateur une chance d'ajuster les vis et de red\u00e9marrer l'impression. Le param\u00e8tre DIRECTION est utile si vous ne pouvez tourner les vis de r\u00e9glage de votre lit que dans un seul sens. Par exemple, vous pourriez avoir des vis qui commencent \u00e0 \u00eatre serr\u00e9es dans leur position la plus basse (ou la plus haute) possible, qui ne peuvent \u00eatre tourn\u00e9es que dans une seule direction, pour \u00e9lever (ou abaisser) le lit. Si vous ne pouvez tourner les vis que dans le sens des aiguilles d'une montre, ex\u00e9cutez SCREWS_TILT_CALCULATE DIRECTION=CW . Si vous ne pouvez les tourner que dans le sens antihoraire, ex\u00e9cutez SCREWS_TILT_CALCULATE DIRECTION=CCW . Un point de r\u00e9f\u00e9rence appropri\u00e9 sera choisi de sorte que le lit puisse \u00eatre nivel\u00e9 en tournant toutes les vis dans la direction donn\u00e9e.","title":"R\u00e9glage des vis de mise \u00e0 niveau du lit \u00e0 l'aide de la sonde de lit"},{"location":"Measuring_Resonances.html","text":"Mesurer la r\u00e9sonance \u00b6 Klipper has built-in support for the ADXL345, MPU-9250 and LIS2DW compatible accelerometers which can be used to measure resonance frequencies of the printer for different axes, and auto-tune input shapers to compensate for resonances. Note that using accelerometers requires some soldering and crimping. The ADXL345/LIS2DW can be connected to the SPI interface of a Raspberry Pi or MCU board (it needs to be reasonably fast). The MPU family can be connected to the I2C interface of a Raspberry Pi directly, or to an I2C interface of an MCU board that supports 400kbit/s fast mode in Klipper. When sourcing accelerometers, be aware that there are a variety of different PCB board designs and different clones of them. If it is going to be connected to a 5V printer MCU ensure it has a voltage regulator and level shifters. For ADXL345s/LIS2DWs, make sure that the board supports SPI mode (a small number of boards appear to be hard-configured for I2C by pulling SDO to GND). For MPU-9250/MPU-9255/MPU-6515/MPU-6050/MPU-6500s there are also a variety of board designs and clones with different I2C pull-up resistors which will need supplementing. MCUs with Klipper I2C fast-mode Support \u00b6 MCU Family MCU(s) Tested MCU(s) with Support Raspberry Pi 3B+, Pico 3A, 3A+, 3B, 4 AVR ATmega ATmega328p ATmega32u4, ATmega128, ATmega168, ATmega328, ATmega644p, ATmega1280, ATmega1284, ATmega2560 AVR AT90 - AT90usb646, AT90usb1286 Instructions d\u2019installation \u00b6 C\u00e2blage \u00b6 An ethernet cable with shielded twisted pairs (cat5e or better) is recommended for signal integrity over a long distance. If you still experience signal integrity issues (SPI/I2C errors): Double check the wiring with a digital multimeter for: Correct connections when turned off (continuity) Correct power and ground voltages I2C only: Check the SCL and SDA lines' resistances to 3.3V are in the range of 900 ohms to 1.8K For full technical details consult chapter 7 of the I2C-bus specification and user manual UM10204 for fast-mode Shorten the cable Connect ethernet cable shielding only to the MCU board/Pi ground. V\u00e9rifiez votre c\u00e2blage avant de mettre sous tension pour \u00e9viter d'endommager votre MCU/Raspberry Pi ou l'acc\u00e9l\u00e9rom\u00e8tre ou les deux. Acc\u00e9l\u00e9rom\u00e8tres SPI \u00b6 Suggested twisted pair order for three twisted pairs: GND+MISO 3.3V+MOSI SCLK+CS Note that unlike a cable shield, GND must be connected at both ends. ADXL345 \u00b6 Directement sur Raspberry Pi \u00b6 Note: Many MCUs will work with an ADXL345 in SPI mode (e.g. Pi Pico), wiring and configuration will vary according to your specific board and available pins. Vous devez connecter votre ADXL345 \u00e0 votre Raspberry Pi via SPI. Notez que la connexion I2C, sugg\u00e9r\u00e9e par la documentation ADXL345, poss\u00e8de un d\u00e9bit trop faible et ne fonctionnera pas . Le sch\u00e9ma de connexion recommand\u00e9 : Brochage de l'ADXL345 Brochage du RPI Nom des broches du RPI 3,3 V (ou VCC) 01 Alimentation 3,3 V CC GND 06 Terre CS 24 GPIO08 (SPI0_CE0_N) SDO 21 GPIO09 (SPI0_MISO) SDA 19 GPIO10 (SPI0_MOSI) SCL 23 GPIO11 (SPI0_SCLK) Sch\u00e9mas de c\u00e2blage de Fritzing pour certaines des cartes ADXL345 : Utilisation d'un Raspberry Pi Pico \u00b6 Vous pouvez connecter l'ADXL345 \u00e0 votre Raspberry Pi Pico, puis connecter le Pico \u00e0 votre Raspberry Pi via USB. Cela facilite la r\u00e9utilisation de l'acc\u00e9l\u00e9rom\u00e8tre sur d'autres appareils Klipper, car vous pouvez vous connecter via USB au lieu de GPIO. Le Pico n'a pas beaucoup de puissance de traitement, alors assurez-vous qu'il n'ex\u00e9cute que l'acc\u00e9l\u00e9rom\u00e8tre et n'effectue aucune autre t\u00e2che. Afin d'\u00e9viter d'endommager votre RPi, assurez-vous de connecter l'ADXL345 uniquement \u00e0 3,3 V. Selon la disposition de la carte, un d\u00e9calage de niveau peut \u00eatre pr\u00e9sent, ce qui rend le 5V dangereux pour votre RPi. Brochage de l'ADXL345 Broche pico Nom de la broche Pico 3,3 V (ou VCC) 36 Alimentation 3,3 V CC GND 38 Terre CS 2 GP1 (SPI0_CSn) SDO 1 GP0 (SPI0_RX) SDA 5 GP3 (SPI0_TX) SCL 4 GP2 (SPI0_SCK) Sch\u00e9mas de c\u00e2blage pour certaines des cartes ADXL345 : Acc\u00e9l\u00e9rom\u00e8tres I2C \u00b6 Suggested twisted pair order for three pairs (preferred): 3.3V+GND SDA+GND SCL+GND or for two pairs: 3.3V+SDA GND+SCL Note that unlike a cable shield, any GND(s) should be connected at both ends. MPU-9250/MPU-9255/MPU-6515/MPU-6050/MPU-6500 \u00b6 These accelerometers have been tested to work over I2C on the RPi, RP2040 (Pico) and AVR at 400kbit/s ( fast mode ). Some MPU accelerometer modules include pull-ups, but some are too large at 10K and must be changed or supplemented by smaller parallel resistors. Sch\u00e9ma de connexion recommand\u00e9 pour I2C sur le Raspberry Pi : brochage du MPU-9250 Brochage du RPI Nom des broches du RPI VCC 01 Alimentation 3.3v continu GND 09 Terre SDA 03 GPIO02 (SDA1) SCL 05 GPIO03 (SCL1) The RPi has buit-in 1.8K pull-ups on both SCL and SDA. Recommended connection scheme for I2C (i2c0a) on the RP2040: brochage du MPU-9250 Broche du RP2040 RP2040 pin name VCC 36 3v3 GND 38 Terre SDA 01 GP0 (I2C0 SDA) SCL 02 GP1 (I2C0 SCL) The Pico does not include any built-in I2C pull-up resistors. Recommended connection scheme for I2C(TWI) on the AVR ATmega328P Arduino Nano: \u00b6 brochage du MPU-9250 Atmega328P TQFP32 pin Atmega328P pin name Arduino Nano pin VCC 39 - - GND 38 Terre GND SDA 27 SDA A4 SCL 28 SCL A5 The Arduino Nano does not include any built-in pull-up resistors nor a 3.3V power pin. Montage de l\u2019acc\u00e9l\u00e9rom\u00e8tre \u00b6 L\u2019acc\u00e9l\u00e9rom\u00e8tre doit \u00eatre fix\u00e9 sur la t\u00eate d'impression. Il faut concevoir un support appropri\u00e9 et adapt\u00e9 \u00e0 l'imprimante 3D. Il est pr\u00e9f\u00e9rable d\u2019aligner les axes de l\u2019acc\u00e9l\u00e9rom\u00e8tre avec les axes de l\u2019imprimante (mais ce n'est pas obligatoire - c\u2019est-\u00e0-dire pas besoin d\u2019aligner l\u2019axe X avec X et ainsi de suite - cela devrait \u00eatre correct m\u00eame si l\u2019axe Z de l\u2019acc\u00e9l\u00e9rom\u00e8tre est l\u2019axe X de l\u2019imprimante, etc.). Exemple de montage d\u2019ADXL345 sur le SmartEffector : Notez que sur une imprimante cart\u00e9sienne, il faut concevoir 2 supports : un pour la t\u00eate et un pour le lit, et ex\u00e9cuter les mesures deux fois. Voir la section correspondante pour plus de d\u00e9tails. Attention : assurez-vous que l\u2019acc\u00e9l\u00e9rom\u00e8tre et les vis qui le maintiennent en place ne touchent aucune partie m\u00e9tallique de l\u2019imprimante. Fondamentalement, le support doit \u00eatre con\u00e7u de mani\u00e8re \u00e0 assurer l\u2019isolation \u00e9lectrique de l\u2019acc\u00e9l\u00e9rom\u00e8tre du ch\u00e2ssis de l\u2019imprimante. Ne pas s\u2019assurer de cette isolation peut cr\u00e9er une boucle de masse dans le syst\u00e8me conduisant \u00e0 l'endommagement de l\u2019\u00e9lectronique. Installation logicielle \u00b6 Notez que les mesures de r\u00e9sonance et l\u2019auto-\u00e9talonnage de l'input shaper n\u00e9cessitent des d\u00e9pendances logicielles suppl\u00e9mentaires non install\u00e9es par d\u00e9faut. Tout d\u2019abord, ex\u00e9cutez sur votre Raspberry Pi les commandes suivantes\u202f: sudo apt update sudo apt install python3-numpy python3-matplotlib libatlas-base-dev Ensuite, pour installer NumPy dans l\u2019environnement Klipper, ex\u00e9cutez la commande\u202f: ~/klippy-env/bin/pip install -v numpy Selon les performances du processeur, cette op\u00e9ration peut prendre jusqu\u2019\u00e0 20 minutes. Soyez patient et attendez la fin de l\u2019installation. Dans certains cas, si la carte a trop peu de m\u00e9moire, l\u2019installation peut \u00e9chouer et vous devrez activer le fichier d\u2019\u00e9change. Configurer l'ADXL345 avec le RPi \u00b6 First, check and follow the instructions in the RPi Microcontroller document to setup the \"linux mcu\" on the Raspberry Pi. This will configure a second Klipper instance that runs on your Pi. Assurez-vous que le pilote SPI Linux est activ\u00e9 en ex\u00e9cutant sudo raspi-config et en activant SPI dans le menu \u00ab Options d\u2019interface \u00bb. Ajoutez les lignes suivantes au fichier printer.cfg : [mcu rpi] serial: /tmp/klipper_host_mcu [adxl345] cs_pin: rpi:None [resonance_tester] accel_chip: adxl345 probe_points: 100, 100, 20 # valeur exemple Il est conseill\u00e9 de commencer par 1 point de test, au milieu du lit d\u2019impression, l\u00e9g\u00e8rement au-dessus. Configurer ADXL345 avec Pi Pico \u00b6 Flash micrologiciel du Pico \u00b6 Sur votre Raspberry Pi, compilez le firmware du Pico. cd ~/klipper make clean make menuconfig Maintenant, tout en maintenant enfonc\u00e9 le bouton BOOTSEL sur le Pico, connectez le Pico au Raspberry Pi via USB. Compilez et flashez le firmware. make flash FLASH_DEVICE=first Si cela \u00e9choue, on vous indiquera quel FLASH_DEVICE utiliser. Dans cet exemple, c'est make flash FLASH_DEVICE=2e8a:0003 . Configurer la connexion \u00b6 Le Pico va maintenant red\u00e9marrer avec le nouveau micrologiciel et devrait appara\u00eetre comme un p\u00e9riph\u00e9rique s\u00e9rie. Trouvez le p\u00e9riph\u00e9rique s\u00e9rie pico avec ls /dev/serial/by-id/* . Vous pouvez maintenant ajouter un fichier adxl.cfg avec les param\u00e8tres suivants : [mcu adxl] # Changez <mySerial> par ce que vous aurez trouv\u00e9 ci-dessus. Par exemple, # usb-Klipper_rp2040_E661640843545B2E-if00 serial: /dev/serial/by-id/usb-Klipper_rp2040_<mySerial> [adxl345] cs_pin: adxl:gpio1 spi_bus: spi0a axes_map: x,z,y [resonance_tester] accel_chip: adxl345 probe_points: # Approximativement au milieu du plateau 147,154, 20 [output_pin power_mode] # Pour am\u00e9liorer la stabilit\u00e9 de l'alimentation pin: adxl:gpio23 Si vous mettez la configuration ADXL345 dans un fichier s\u00e9par\u00e9, comme indiqu\u00e9 ci-dessus, vous devrez \u00e9galement modifier votre fichier printer.cfg pour inclure ceci : [include adxl.cfg] # Commentez cette ligne lorsque vous d\u00e9connectez l'acc\u00e9l\u00e9rom\u00e8tre Red\u00e9marrez Klipper avec la commande RESTART . Configure LIS2DW series \u00b6 [mcu lis] # Change <mySerial> to whatever you found above. For example, # usb-Klipper_rp2040_E661640843545B2E-if00 serial: /dev/serial/by-id/usb-Klipper_rp2040_<mySerial> [lis2dw] cs_pin: lis:gpio1 spi_bus: spi0a axes_map: x,z,y [resonance_tester] accel_chip: lis2dw probe_points: # Somewhere slightly above the middle of your print bed 147,154, 20 Configurer les s\u00e9ries MPU-6000/9000 avec le RPi \u00b6 Assurez-vous que le pilote Linux I2C est activ\u00e9 et que le d\u00e9bit en bauds est d\u00e9fini sur 400 000 (voir la section Activation d'I2C pour plus de d\u00e9tails). Ensuite, ajoutez ce qui suit au fichier printer.cfg : [mcu rpi] serial: /tmp/klipper_host_mcu [mpu9250] i2c_mcu: rpi i2c_bus: i2c.1 [resonance_tester] accel_chip: mpu9250 probe_points: 100, 100, 20 # valeurs exemple Configure MPU-9520 Compatibles With Pico \u00b6 Pico I2C is set to 400000 on default. Simply add the following to the printer.cfg: [mcu pico] serial: /dev/serial/by-id/<your Pico's serial ID> [mpu9250] i2c_mcu: pico i2c_bus: i2c0a [resonance_tester] accel_chip: mpu9250 probe_points: 100, 100, 20 # an example [static_digital_output pico_3V3pwm] # Improve power stability pins: pico:gpio23 Configure MPU-9520 Compatibles with AVR \u00b6 AVR I2C will be set to 400000 by the mpu9250 option. Simply add the following to the printer.cfg: [mcu nano] serial: /dev/serial/by-id/<your nano's serial ID> [mpu9250] i2c_mcu: nano [resonance_tester] accel_chip: mpu9250 probe_points: 100, 100, 20 # an example Red\u00e9marrez Klipper avec la commande RESTART . Mesurer les r\u00e9sonances \u00b6 V\u00e9rification de la configuration \u00b6 Vous pouvez maintenant tester la connexion. Pour les imprimantes non cart\u00e9siennes (celles avec une seul acc\u00e9l\u00e9rom\u00e8tre), dans Octoprint, entrez ACCELEROMETER_QUERY Pour les imprimante cart\u00e9siennes (plus d\u2019un acc\u00e9l\u00e9rom\u00e8tre), entrez ACCELEROMETER_QUERY CHIP=<chip> o\u00f9 <chip> est le nom de la puce tel qu\u2019il a \u00e9t\u00e9 entr\u00e9, par exemple CHIP=bed (voir\u202f: bed-slinger ) faites-le pour tous les acc\u00e9l\u00e9rom\u00e8tre install\u00e9s. Vous devriez voir les mesures actuelles de l\u2019acc\u00e9l\u00e9rom\u00e8tre, y compris l\u2019acc\u00e9l\u00e9ration en chute libre. Recv: // adxl345 values (x, y, z)\u202f: 470.719200, 941.438400, 9728.196800 Si vous obtenez une erreur comme ID adxl345 non valide (got xx vs e5) , o\u00f9 xx est un autre ID, r\u00e9essayez imm\u00e9diatement. Il y a un probl\u00e8me avec l'initialisation SPI. Si vous obtenez toujours une erreur, cela indique un probl\u00e8me de connexion avec ADXL345 ou le capteur d\u00e9fectueux. V\u00e9rifiez \u00e0 nouveau l'alimentation, le c\u00e2blage (qu'il corresponde aux sch\u00e9mas, qu'aucun fil n'est cass\u00e9 ou desserr\u00e9, etc.) et la qualit\u00e9 de la soudure. If you are using a MPU-9250 compatible accelerometer and it shows up as mpu-unknown , use with caution! They are probably refurbished chips! Ensuite, essayez d\u2019ex\u00e9cuter MEASURE_AXES_NOISE dans Octoprint, vous devriez obtenir des chiffres de base pour le bruit de fond de l\u2019acc\u00e9l\u00e9rom\u00e8tre sur les axes (devraient se situer entre 1 et 100). Un bruit de fond d\u2019axe trop \u00e9lev\u00e9 (par exemple 1000 et plus) peut indiquer des probl\u00e8mes de capteur, des probl\u00e8mes de puissance ou des ventilateurs d\u00e9s\u00e9quilibr\u00e9s entrainant trop de vibrations sur l'imprimante 3D. Mesurer les r\u00e9sonances \u00b6 Vous pouvez maintenant ex\u00e9cuter les tests r\u00e9els. Ex\u00e9cutez la commande suivante : TEST_RESONANCES AXIS=X Notez que cela cr\u00e9era des vibrations sur l\u2019axe X. Ce test d\u00e9sactivera les valeurs du formateur d'entr\u00e9e (aka input shapper) d\u00e9j\u00e0 param\u00e9tr\u00e9es. Le test de r\u00e9sonance ne peut pas \u00eatre fait avec le formateur d'entr\u00e9e d\u00e9j\u00e0 activ\u00e9. Attention\u202f! Gardez un \u0153il sur l\u2019imprimante la premi\u00e8re fois, pour vous assurer que les vibrations ne deviennent pas trop violentes (la commande M112 peut \u00eatre utilis\u00e9e pour interrompre le test en cas d\u2019urgence - en esp\u00e9rant ne pas avoir \u00e0 l'utiliser). Si les vibrations deviennent trop fortes, vous pouvez sp\u00e9cifier une valeur inf\u00e9rieure \u00e0 la valeur par d\u00e9faut du param\u00e8tre accel_per_hz dans la section [resonance_tester] . [resonance_tester] accel_chip: adxl345 accel_per_hz: 50 # default is 75 probe_points: ... Si cela fonctionne pour l\u2019axe X, ex\u00e9cutez ensuite la commande pour l\u2019axe Y : TEST_RESONANCES AXIS=Y Cela g\u00e9n\u00e9rera 2 fichiers CSV ( /tmp/resonances_x_*.csv et /tmp/resonances_y_*.csv ). Ces fichiers peuvent \u00eatre trait\u00e9s avec le script autonome sur un Raspberry Pi. Pour ce faire, ex\u00e9cutez les commandes suivantes : ~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o /tmp/shaper_calibrate_x.png ~/klipper/scripts/calibrate_shaper.py /tmp/resonances_y_*.csv -o /tmp/shaper_calibrate_y.png Ce script g\u00e9n\u00e9rera les graphiques /tmp/shaper_calibrate_x.png et /tmp/shaper_calibrate_y.png avec les r\u00e9ponses en fr\u00e9quence. Vous obtiendrez \u00e9galement les fr\u00e9quences sugg\u00e9r\u00e9es pour chaque mode du formateur d'entr\u00e9e (input shapper), ainsi que la valeur recommand\u00e9e pour votre configuration. Par exemple : Fitted shaper 'zv' frequency = 34.4 Hz (vibrations = 4.0%, smoothing ~= 0.132) To avoid too much smoothing with 'zv', suggested max_accel <= 4500 mm/sec^2 Fitted shaper 'mzv' frequency = 34.6 Hz (vibrations = 0.0%, smoothing ~= 0.170) To avoid too much smoothing with 'mzv', suggested max_accel <= 3500 mm/sec^2 Fitted shaper 'ei' frequency = 41.4 Hz (vibrations = 0.0%, smoothing ~= 0.188) To avoid too much smoothing with 'ei', suggested max_accel <= 3200 mm/sec^2 Fitted shaper '2hump_ei' frequency = 51.8 Hz (vibrations = 0.0%, smoothing ~= 0.201) To avoid too much smoothing with '2hump_ei', suggested max_accel <= 3000 mm/sec^2 Fitted shaper '3hump_ei' frequency = 61.8 Hz (vibrations = 0.0%, smoothing ~= 0.215) To avoid too much smoothing with '3hump_ei', suggested max_accel <= 2800 mm/sec^2 Recommended shaper is mzv @ 34.6 Hz La configuration sugg\u00e9r\u00e9e peut \u00eatre ajout\u00e9e \u00e0 la section [input_shaper] de printer.cfg , par exemple : [input_shaper] shaper_freq_x: ... shaper_type_x: ... shaper_freq_y: 34.6 shaper_type_y: mzv [printer] max_accel: 3000 # Ne devrait pas d\u00e9passer les valeurs estim\u00e9es d'acc\u00e9l\u00e9ration calcul\u00e9es pour les axes X et Y Ou vous pouvez choisir vous-m\u00eame une autre configuration en fonction des graphiques g\u00e9n\u00e9r\u00e9s\u202f: les pics de densit\u00e9 spectrale de puissance sur les graphiques correspondent aux fr\u00e9quences de r\u00e9sonance de l\u2019imprimante. Notez que vous pouvez \u00e9galement ex\u00e9cuter l'auto-calibration du shaper d'entr\u00e9e \u00e0 partir de Klipper directement , ce qui peut \u00eatre pratique, par exemple, pour le shaper d'entr\u00e9e re-calibration . Imprimantes cart\u00e9siennes \u00e0 lit mobile \u00b6 Si votre imprimante est une imprimante cart\u00e9sienne dont le plateau est mobile sur l'axe Y, vous devrez changer l\u2019emplacement de l\u2019acc\u00e9l\u00e9rom\u00e8tre entre les mesures des axes X et Y : mesurez les r\u00e9sonances de l\u2019axe X avec l\u2019acc\u00e9l\u00e9rom\u00e8tre fix\u00e9 \u00e0 la t\u00eate et les r\u00e9sonances de l\u2019axe Y - au lit (la configuration habituelle des imprimantes cart\u00e9siennes). However, you can also connect two accelerometers simultaneously, though the ADXL345 must be connected to different boards (say, to an RPi and printer MCU board), or to two different physical SPI interfaces on the same board (rarely available). Then they can be configured in the following manner: [adxl345 hotend] # En consid\u00e9rant que l'adxl de la t\u00eate connect\u00e9e au RPI cs_pin: rpi:None [adxl345 bed] # En consid\u00e9rant que l'adxl du lit est connect\u00e9 au MCU cs_pin: ... # Printer board SPI chip select (CS) pin [resonance_tester] # En consid\u00e9rant un montage standard pour une imprimante cart\u00e9sienne accel_chip_x: adxl345 hotend accel_chip_y: adxl345 bed probe_points: ... Two MPUs can share one I2C bus, but they cannot measure simultaneously as the 400kbit/s I2C bus is not fast enough. One must have its AD0 pin pulled-down to 0V (address 104) and the other its AD0 pin pulled-up to 3.3V (address 105): [mpu9250 hotend] i2c_mcu: rpi i2c_bus: i2c.1 i2c_address: 104 # This MPU has pin AD0 pulled low [mpu9250 bed] i2c_mcu: rpi i2c_bus: i2c.1 i2c_address: 105 # This MPU has pin AD0 pulled high [resonance_tester] # Assuming the typical setup of the bed slinger printer accel_chip_x: mpu9250 hotend accel_chip_y: mpu9250 bed probe_points: ... [Test with each MPU individually before connecting both to the bus for easy debugging.] Ensuite, les commandes TEST_RESONANCES AXIS=X et TEST_RESONANCES AXIS=Y utiliseront le bon acc\u00e9l\u00e9rom\u00e8tre pour chaque axe. Lissage maximum \u00b6 Gardez \u00e0 l'esprit que le formateur d'entr\u00e9e (input shapper) peut cr\u00e9er un lissage sur certaines parties de l'impression. Le r\u00e9glage automatique du formateur d'entr\u00e9e effectu\u00e9 par le script calibrate_shaper.py ou la commande SHAPER_CALIBRATE essaie de limiter le lissage, mais il essaie aussi de minimiser les vibrations r\u00e9sultantes. Cela peut conduire parfois, \u00e0 un choix peu optimis\u00e9 de la fr\u00e9quence du formateur d'entr\u00e9e ou peut-\u00eatre pr\u00e9f\u00e9rez-vous simplement avoir moins de lissage dans certaines parties de l'impression au d\u00e9triment des vibrations restantes. Dans ces cas, vous pouvez demander de limiter le lissage maximal \u00e0 partir du formateur d'entr\u00e9e. Regardons les r\u00e9sultats suivants du r\u00e9glage automatique : Fitted shaper 'zv' frequency = 57.8 Hz (vibrations = 20.3%, smoothing ~= 0.053) To avoid too much smoothing with 'zv', suggested max_accel <= 13000 mm/sec^2 Fitted shaper 'mzv' frequency = 34.8 Hz (vibrations = 3.6%, smoothing ~= 0.168) To avoid too much smoothing with 'mzv', suggested max_accel <= 3600 mm/sec^2 Fitted shaper 'ei' frequency = 48.8 Hz (vibrations = 4.9%, smoothing ~= 0.135) To avoid too much smoothing with 'ei', suggested max_accel <= 4400 mm/sec^2 Fitted shaper '2hump_ei' frequency = 45.2 Hz (vibrations = 0.1%, smoothing ~= 0.264) To avoid too much smoothing with '2hump_ei', suggested max_accel <= 2200 mm/sec^2 Fitted shaper '3hump_ei' frequency = 48.0 Hz (vibrations = 0.0%, smoothing ~= 0.356) To avoid too much smoothing with '3hump_ei', suggested max_accel <= 1500 mm/sec^2 Recommended shaper is 2hump_ei @ 45.2 Hz Notez que les valeurs rapport\u00e9es smoothing sont des valeurs projet\u00e9es abstraites. Ces valeurs peuvent \u00eatre utilis\u00e9es pour comparer diff\u00e9rentes configurations : plus la valeur est \u00e9lev\u00e9e, plus le formateur d'entr\u00e9e cr\u00e9era de lissage. Cependant, ces scores de lissage ne repr\u00e9sentent aucune mesure r\u00e9elle du lissage, car le lissage r\u00e9el d\u00e9pend des param\u00e8tres max_accel et square_corner_velocity . Par cons\u00e9quent, vous devrez faire des impressions de test pour voir exactement le lissage cr\u00e9\u00e9 par la configuration choisie. Dans l'exemple ci-dessus, les param\u00e8tres de mise en forme sugg\u00e9r\u00e9s ne sont pas mauvais, mais que se passe-t-il si vous souhaitez obtenir moins de lissage sur l'axe X ? Vous pouvez essayer de limiter le lissage maximal du formateur d'entr\u00e9e \u00e0 l'aide de la commande suivante : ~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o /tmp/shaper_calibrate_x.png --max_smoothing=0.2 ce qui limite le lissage \u00e0 un score de 0,2. Vous pouvez maintenant obtenir le r\u00e9sultat suivant : Fitted shaper 'zv' frequency = 55.4 Hz (vibrations = 19.7%, smoothing ~= 0.057) To avoid too much smoothing with 'zv', suggested max_accel <= 12000 mm/sec^2 Fitted shaper 'mzv' frequency = 34.6 Hz (vibrations = 3.6%, smoothing ~= 0.170) To avoid too much smoothing with 'mzv', suggested max_accel <= 3500 mm/sec^2 Fitted shaper 'ei' frequency = 48.2 Hz (vibrations = 4.8%, smoothing ~= 0.139) To avoid too much smoothing with 'ei', suggested max_accel <= 4300 mm/sec^2 Fitted shaper '2hump_ei' frequency = 52.0 Hz (vibrations = 2.7%, smoothing ~= 0.200) To avoid too much smoothing with '2hump_ei', suggested max_accel <= 3000 mm/sec^2 Fitted shaper '3hump_ei' frequency = 72.6 Hz (vibrations = 1.4%, smoothing ~= 0.155) To avoid too much smoothing with '3hump_ei', suggested max_accel <= 3900 mm/sec^2 Recommended shaper is 3hump_ei @ 72.6 Hz Si vous comparez avec les pr\u00e9c\u00e9dents param\u00e8tres sugg\u00e9r\u00e9s, les vibrations sont un peu plus importantes, mais le lissage est nettement plus faible qu'auparavant, ce qui permet une acc\u00e9l\u00e9ration maximale plus importante. Lorsque vous choisissez le param\u00e8tre max_smoothing , vous pouvez utiliser une approche par essais et erreurs. Essayez quelques valeurs diff\u00e9rentes et voyez quels r\u00e9sultats vous obtenez. Notez que le lissage r\u00e9el produit par le formateur d'entr\u00e9e d\u00e9pend principalement de la fr\u00e9quence de r\u00e9sonance la plus basse de l'imprimante : plus la fr\u00e9quence de r\u00e9sonance la plus basse est \u00e9lev\u00e9e, plus le lissage est faible. Par cons\u00e9quent, si vous demandez au script de trouver une configuration du formateur d'entr\u00e9e avec un lissage irr\u00e9aliste, cela se fera au d\u00e9triment d'une r\u00e9sonance accrue aux fr\u00e9quences les plus basses (g\u00e9n\u00e9ralement, les plus visibles dans les impressions). V\u00e9rifiez donc toujours les vibrations restantes projet\u00e9es signal\u00e9es par le script et assurez-vous qu'elles ne sont pas trop \u00e9lev\u00e9es. Notez que si vous avez trouv\u00e9 une bonne valeur de max_smoothing pour vos deux axes, vous pouvez la stocker dans printer.cfg comme [resonance_tester] accel_chip: ... probe_points: ... max_smoothing: 0.25 # valeur exemple Ensuite, si vous r\u00e9ex\u00e9cutez le r\u00e9glage automatique du formateur d'entr\u00e9e \u00e0 l'aide de la commande SHAPER_CALIBRATE , c'est cette valeur stock\u00e9e max_smoothing qui sera prise comme r\u00e9f\u00e9rence. S\u00e9lection de max_accel \u00b6 \u00c9tant donn\u00e9 que le formateur d'entr\u00e9e peut cr\u00e9er un certain lissage dans les pi\u00e8ces, en particulier avec des acc\u00e9l\u00e9rations \u00e9lev\u00e9es, vous devrez toujours choisir une valeur max_accel ne cr\u00e9ant pas trop de lissage dans les pi\u00e8ces imprim\u00e9es. Un script d'\u00e9talonnage fournit une estimation du param\u00e8tre max_accel qui ne devrait pas cr\u00e9er trop de lissage. Notez que le max_accel tel qu'affich\u00e9 par le script de calibrage n'est qu'un maximum th\u00e9orique auquel le formateur d'entr\u00e9e est encore capable de travailler sans produire trop de lissage. Il ne s'agit en aucun cas d'une recommandation pour d\u00e9finir cette acc\u00e9l\u00e9ration sur vos impressions. L'acc\u00e9l\u00e9ration maximale support\u00e9e par votre imprimante d\u00e9pend de ses propri\u00e9t\u00e9s m\u00e9caniques et du couple maximal des moteurs pas \u00e0 pas utilis\u00e9s. Par cons\u00e9quent, il est sugg\u00e9r\u00e9 de d\u00e9finir un max_accel dans la section [printer] qui ne d\u00e9passe pas les valeurs estim\u00e9es pour les axes X et Y, probablement avec une marge de s\u00e9curit\u00e9. Vous pouvez \u00e9galement suivre cette partie du guide de r\u00e9glage du formateur d'entr\u00e9e et imprimer un mod\u00e8le de test pour choisir le param\u00e8tre max_accel de mani\u00e8re exp\u00e9rimentale. M\u00eame remarque pour l' auto-calibration du formateur d'entr\u00e9e avec la commande SHAPER_CALIBRATE : il faut encore choisir la bonne valeur max_accel apr\u00e8s l'auto-calibrage, notez que les limites d'acc\u00e9l\u00e9rations sugg\u00e9r\u00e9es ne sont pas appliqu\u00e9es automatiquement. Si vous effectuez un r\u00e9-\u00e9talonnage du formateur d'entr\u00e9e et que le lissage indiqu\u00e9 pour la configuration de formateur sugg\u00e9r\u00e9e est pratiquement le m\u00eame que celui obtenu lors du calibrage pr\u00e9c\u00e9dent, cette \u00e9tape peut \u00eatre ignor\u00e9e. Test des axes personnalis\u00e9s \u00b6 la commande TEST_RESONANCES prend en charge les axes personnalis\u00e9s. Bien que cela ne soit pas vraiment utile pour l\u2019\u00e9talonnage des input shaper, cela peut \u00eatre utilis\u00e9 pour \u00e9tudier en profondeur les r\u00e9sonances de l\u2019imprimante et v\u00e9rifier, par exemple, la tension de la courroie. Pour v\u00e9rifier la tension de la courroie sur les imprimantes CoreXY, ex\u00e9cutez TEST_RESONANCES AXIS=1,1 OUTPUT=raw_data TEST_RESONANCES AXIS=1,-1 OUTPUT=raw_data et utilisez graph_accelerometer.py pour traiter les fichiers g\u00e9n\u00e9r\u00e9s. ~/klipper/scripts/graph_accelerometer.py -c /tmp/raw_data_axis*.csv -o /tmp/resonances.png qui g\u00e9n\u00e9rera /tmp/r\u00e9sonances.png en comparant les r\u00e9sonances. Pour les imprimantes Delta avec le placement des tours par d\u00e9faut (tour A ~= 210 degr\u00e9s, B ~= 330 degr\u00e9s et C ~= 90 degr\u00e9s), ex\u00e9cutez TEST_RESONANCES AXIS=0,1 OUTPUT=raw_data TEST_RESONANCES AXIS=-0.866025404,-0.5 OUTPUT=raw_data TEST_RESONANCES AXIS=0.866025404,-0.5 OUTPUT=raw_data puis utilisez la m\u00eame commande ~/klipper/scripts/graph_accelerometer.py -c /tmp/raw_data_axis*.csv -o /tmp/resonances.png pour g\u00e9n\u00e9rer le fichier de comparaison des r\u00e9sonnances /tmp/r\u00e9sonances.png . Calibrage automatique du formateur d'entr\u00e9e \u00b6 En plus de choisir manuellement les param\u00e8tres appropri\u00e9s pour la fonction de formateur d'entr\u00e9e, il est \u00e9galement possible d'ex\u00e9cuter le r\u00e9glage automatique du formateur d'entr\u00e9e directement \u00e0 partir de Klipper. Ex\u00e9cutez la commande suivante via le terminal Octoprint : SHAPER_CALIBRATE Cela ex\u00e9cutera le test complet pour les deux axes et g\u00e9n\u00e9rera la sortie csv ( /tmp/calibration_data_*.csv par d\u00e9faut) pour la r\u00e9ponse en fr\u00e9quence et les formateurs d'entr\u00e9e sugg\u00e9r\u00e9s. Vous obtiendrez \u00e9galement les fr\u00e9quences sugg\u00e9r\u00e9es pour chaque formateur, ainsi que le mod\u00e8le de formateur d'entr\u00e9e recommand\u00e9 pour votre configuration, sur la console Octoprint. Par exemple\u202f: Calculating the best input shaper parameters for y axis Fitted shaper 'zv' frequency = 39.0 Hz (vibrations = 13.2%, smoothing ~= 0.105) To avoid too much smoothing with 'zv', suggested max_accel <= 5900 mm/sec^2 Fitted shaper 'mzv' frequency = 36.8 Hz (vibrations = 1.7%, smoothing ~= 0.150) To avoid too much smoothing with 'mzv', suggested max_accel <= 4000 mm/sec^2 Fitted shaper 'ei' frequency = 36.6 Hz (vibrations = 2.2%, smoothing ~= 0.240) To avoid too much smoothing with 'ei', suggested max_accel <= 2500 mm/sec^2 Fitted shaper '2hump_ei' frequency = 48.0 Hz (vibrations = 0.0%, smoothing ~= 0.234) To avoid too much smoothing with '2hump_ei', suggested max_accel <= 2500 mm/sec^2 Fitted shaper '3hump_ei' frequency = 59.0 Hz (vibrations = 0.0%, smoothing ~= 0.235) To avoid too much smoothing with '3hump_ei', suggested max_accel <= 2500 mm/sec^2 Recommended shaper_type_y = mzv, shaper_freq_y = 36.8 Hz Si vous \u00eates d'accord avec les param\u00e8tres sugg\u00e9r\u00e9s, vous pouvez ex\u00e9cuter SAVE_CONFIG maintenant pour les enregistrer et red\u00e9marrer Klipper. Notez que cela ne mettra pas \u00e0 jour la valeur max_accel dans la section [printer] . Vous devrez la mettre \u00e0 jour manuellement en suivant les recommandations de la section Choisir l'acc\u00e9l\u00e9ration maximale . Si votre imprimante est une imprimante cart\u00e9sienne, vous pouvez pr\u00e9ciser l'axe \u00e0 tester, afin de pouvoir modifier le point de montage de l'acc\u00e9l\u00e9rom\u00e8tre entre les tests (par d\u00e9faut, le test est effectu\u00e9 pour les deux axes) : SHAPER_CALIBRATE AXIS=Y Vous pouvez ex\u00e9cuter SAVE_CONFIG deux fois - apr\u00e8s avoir calibr\u00e9 chaque axe. Cependant, si vous avez connect\u00e9 deux acc\u00e9l\u00e9rom\u00e8tres simultan\u00e9ment, vous pouvez ex\u00e9cutez simplement SHAPER_CALIBRATE sans sp\u00e9cifier d'axe pour calibrer les formateurs d'entr\u00e9e des deux axes en une seule fois. R\u00e9-\u00e9talonnage du formateur d'entr\u00e9e (aka input shapper) \u00b6 La commande SHAPER_CALIBRATE peut \u00e9galement \u00eatre utilis\u00e9e pour recalibrer le formateur d'entr\u00e9e ult\u00e9rieurement, en particulier si des modifications de l'imprimante pouvant affecter sa cin\u00e9matique sont apport\u00e9es. On peut soit relancer l'\u00e9talonnage complet \u00e0 l'aide de la commande SHAPER_CALIBRATE , soit restreindre l'auto-\u00e9talonnage \u00e0 un seul axe en fournissant le param\u00e8tre AXIS= , comme SHAPER_CALIBRATE AXIS=X Attention ! Il n'est pas conseill\u00e9 d'ex\u00e9cuter l'auto-calibrage du shaper trop fr\u00e9quemment (par exemple, avant chaque impression ou tous les jours). Afin de d\u00e9terminer les fr\u00e9quences de r\u00e9sonance, l'auto-calibrage cr\u00e9e des vibrations intenses sur chacun des axes. G\u00e9n\u00e9ralement, les imprimantes 3D ne sont pas con\u00e7ues pour r\u00e9sister \u00e0 une exposition prolong\u00e9e \u00e0 des vibrations proches des fr\u00e9quences de r\u00e9sonance. Cela pourrait augmenter l'usure des composants de l'imprimante et r\u00e9duire leur dur\u00e9e de vie. Il existe \u00e9galement un risque accru que certaines pi\u00e8ces se d\u00e9vissent ou se desserrent. V\u00e9rifiez toujours que toutes les pi\u00e8ces de l'imprimante (y compris celles qui ne peuvent normalement pas bouger) sont solidement fix\u00e9es en place apr\u00e8s chaque r\u00e9glage automatique. De plus, en raison d'un certain bruit dans les mesures, il est possible que les r\u00e9sultats de r\u00e9glage soient l\u00e9g\u00e8rement diff\u00e9rents d'un calibrage \u00e0 l'autre. Ce bruit ne devrait pas trop affecter la qualit\u00e9 d'impression. Cependant, il est conseill\u00e9 de rev\u00e9rifier les param\u00e8tres sugg\u00e9r\u00e9s et d'imprimer des tests d'impression avant de les utiliser pour confirmer qu'ils sont corrects. Traitement hors ligne des donn\u00e9es de l\u2019acc\u00e9l\u00e9rom\u00e8tre \u00b6 Il est possible de g\u00e9n\u00e9rer les donn\u00e9es brutes de l\u2019acc\u00e9l\u00e9rom\u00e8tre et de les traiter hors ligne (par exemple sur une machine h\u00f4te), par exemple pour trouver des r\u00e9sonances. Pour ce faire, ex\u00e9cutez les commandes suivantes via le terminal Octoprint : SET_INPUT_SHAPER SHAPER_FREQ_X=0 SHAPER_FREQ_Y=0 TEST_RESONANCES AXIS=X OUTPUT=raw_data ignorez toute erreur pour la commande SET_INPUT_SHAPER . Pour la commande TEST_RESONANCES , sp\u00e9cifiez l\u2019axe de test souhait\u00e9. Les donn\u00e9es brutes seront \u00e9crites dans le r\u00e9pertoire /tmp sur le RPi. Les donn\u00e9es brutes peuvent \u00e9galement \u00eatre obtenues en ex\u00e9cutant la commande ACCELEROMETER_MEASURE deux fois - d\u2019abord pour d\u00e9marrer les mesures, puis pour les arr\u00eater et \u00e9crire le fichier de sortie. Reportez-vous \u00e0 G-Codes pour plus de d\u00e9tails. Les donn\u00e9es peuvent \u00eatre trait\u00e9es ult\u00e9rieurement avec les scripts suivants : scripts/graph_accelerometer.py et scripts/calibrate_shaper.py . Les deux acceptent un ou plusieurs fichiers csv bruts comme entr\u00e9e en fonction du mode. Le script graph_accelerometer.py prend en charge plusieurs modes de fonctionnement : pour le tra\u00e7age des donn\u00e9es brutes de l\u2019acc\u00e9l\u00e9rom\u00e8tre (utilisez le param\u00e8tre -r ), seule 1 entr\u00e9e est prise en charge\u202f; tracer une r\u00e9ponse en fr\u00e9quence (aucun param\u00e8tre suppl\u00e9mentaire n'est requis), si plusieurs entr\u00e9es sont sp\u00e9cifi\u00e9es, la r\u00e9ponse en fr\u00e9quence moyenne est calcul\u00e9e ; comparaison de la r\u00e9ponse en fr\u00e9quence entre plusieurs entr\u00e9es (utiliser le param\u00e8tre -c ) ; vous pouvez \u00e9galement sp\u00e9cifier l\u2019axe de l\u2019acc\u00e9l\u00e9rom\u00e8tre \u00e0 prendre en compte via le param\u00e8tre -a x , -a y ou -a z (si aucun n\u2019est sp\u00e9cifi\u00e9, la somme des vibrations pour tous les axes est utilis\u00e9e) ; tra\u00e7age du spectrogramme (utiliser le param\u00e8tre -s ), seule 1 entr\u00e9e est prise en charge\u202f; vous pouvez \u00e9galement sp\u00e9cifier l\u2019axe de l\u2019acc\u00e9l\u00e9rom\u00e8tre \u00e0 prendre en compte via le param\u00e8tre -a x , -a y ou -a z (si aucun n\u2019est sp\u00e9cifi\u00e9, la somme des vibrations pour tous les axes est utilis\u00e9e). Notez que graph_accelerometer.py script ne prend en charge que les fichiers raw_data*.csv et non les fichiers resonances*.csv ou calibration_data*.csv. Par exemple, ~/klipper/scripts/graph_accelerometer.py /tmp/raw_data_x_*.csv -o /tmp/resonances_x.png -c -a z tracera la comparaison de plusieurs fichiers /tmp/raw_data_x_*.csv pour l\u2019axe Z dans le fichier /tmp/resonances_x.png . Le script shaper_calibrate.py accepte 1 ou plusieurs entr\u00e9es et peut ex\u00e9cuter le r\u00e9glage automatique de l'input shaper et sugg\u00e9rer les meilleurs param\u00e8tres pour les entr\u00e9es fournies. Il affiche les param\u00e8tres sugg\u00e9r\u00e9s sur la console et peut en outre g\u00e9n\u00e9rer un graphique si le param\u00e8tre -o output.png est fourni, ou un fichier CSV si le param\u00e8tre -c output.csv est sp\u00e9cifi\u00e9. Fournir plusieurs entr\u00e9es \u00e0 shaper_calibrate.py script peut \u00eatre utile si vous ex\u00e9cutez un r\u00e9glage avanc\u00e9 de l'input shaper, par exemple : Ex\u00e9cutez TEST_RESONANCES AXIS=X OUTPUT=raw_data (et Y axe) pour un seul axe deux fois sur une imprimante cart\u00e9sienne avec l\u2019acc\u00e9l\u00e9rom\u00e8tre fix\u00e9 \u00e0 la t\u00eate d\u2019outil la premi\u00e8re fois, et l\u2019acc\u00e9l\u00e9rom\u00e8tre fix\u00e9 au lit la deuxi\u00e8me fois afin de d\u00e9tecter les r\u00e9sonances crois\u00e9es des axes et de tenter de les annuler avec l'input shaper. Ex\u00e9cutez TEST_RESONANCES AXIS=Y OUTPUT=raw_data deux fois sur le lit avec un lit en verre et une surface magn\u00e9tique (plus l\u00e9g\u00e8re) pour trouver les param\u00e8tres d'input shaper qui fonctionnent bien pour n\u2019importe quelle configuration de surface d\u2019impression. Combinaison des donn\u00e9es de r\u00e9sonance de plusieurs points de test. Combinaison des donn\u00e9es de r\u00e9sonance \u00e0 partir de 2 axes (par exemple, sur une imprimante cart\u00e9sienne pour configurer les input_shaper de l\u2019axe X \u00e0 partir des r\u00e9sonances des axes X et Y pour annuler les vibrations du lit * * au cas o\u00f9 la buse \u00ab attraperait \u00bb une impression lors du d\u00e9placement dans la direction de l\u2019axe X).","title":"Mesurer la r\u00e9sonance"},{"location":"Measuring_Resonances.html#mesurer-la-resonance","text":"Klipper has built-in support for the ADXL345, MPU-9250 and LIS2DW compatible accelerometers which can be used to measure resonance frequencies of the printer for different axes, and auto-tune input shapers to compensate for resonances. Note that using accelerometers requires some soldering and crimping. The ADXL345/LIS2DW can be connected to the SPI interface of a Raspberry Pi or MCU board (it needs to be reasonably fast). The MPU family can be connected to the I2C interface of a Raspberry Pi directly, or to an I2C interface of an MCU board that supports 400kbit/s fast mode in Klipper. When sourcing accelerometers, be aware that there are a variety of different PCB board designs and different clones of them. If it is going to be connected to a 5V printer MCU ensure it has a voltage regulator and level shifters. For ADXL345s/LIS2DWs, make sure that the board supports SPI mode (a small number of boards appear to be hard-configured for I2C by pulling SDO to GND). For MPU-9250/MPU-9255/MPU-6515/MPU-6050/MPU-6500s there are also a variety of board designs and clones with different I2C pull-up resistors which will need supplementing.","title":"Mesurer la r\u00e9sonance"},{"location":"Measuring_Resonances.html#mcus-with-klipper-i2c-fast-mode-support","text":"MCU Family MCU(s) Tested MCU(s) with Support Raspberry Pi 3B+, Pico 3A, 3A+, 3B, 4 AVR ATmega ATmega328p ATmega32u4, ATmega128, ATmega168, ATmega328, ATmega644p, ATmega1280, ATmega1284, ATmega2560 AVR AT90 - AT90usb646, AT90usb1286","title":"MCUs with Klipper I2C fast-mode Support"},{"location":"Measuring_Resonances.html#instructions-dinstallation","text":"","title":"Instructions d\u2019installation"},{"location":"Measuring_Resonances.html#cablage","text":"An ethernet cable with shielded twisted pairs (cat5e or better) is recommended for signal integrity over a long distance. If you still experience signal integrity issues (SPI/I2C errors): Double check the wiring with a digital multimeter for: Correct connections when turned off (continuity) Correct power and ground voltages I2C only: Check the SCL and SDA lines' resistances to 3.3V are in the range of 900 ohms to 1.8K For full technical details consult chapter 7 of the I2C-bus specification and user manual UM10204 for fast-mode Shorten the cable Connect ethernet cable shielding only to the MCU board/Pi ground. V\u00e9rifiez votre c\u00e2blage avant de mettre sous tension pour \u00e9viter d'endommager votre MCU/Raspberry Pi ou l'acc\u00e9l\u00e9rom\u00e8tre ou les deux.","title":"C\u00e2blage"},{"location":"Measuring_Resonances.html#accelerometres-spi","text":"Suggested twisted pair order for three twisted pairs: GND+MISO 3.3V+MOSI SCLK+CS Note that unlike a cable shield, GND must be connected at both ends.","title":"Acc\u00e9l\u00e9rom\u00e8tres SPI"},{"location":"Measuring_Resonances.html#adxl345","text":"","title":"ADXL345"},{"location":"Measuring_Resonances.html#directement-sur-raspberry-pi","text":"Note: Many MCUs will work with an ADXL345 in SPI mode (e.g. Pi Pico), wiring and configuration will vary according to your specific board and available pins. Vous devez connecter votre ADXL345 \u00e0 votre Raspberry Pi via SPI. Notez que la connexion I2C, sugg\u00e9r\u00e9e par la documentation ADXL345, poss\u00e8de un d\u00e9bit trop faible et ne fonctionnera pas . Le sch\u00e9ma de connexion recommand\u00e9 : Brochage de l'ADXL345 Brochage du RPI Nom des broches du RPI 3,3 V (ou VCC) 01 Alimentation 3,3 V CC GND 06 Terre CS 24 GPIO08 (SPI0_CE0_N) SDO 21 GPIO09 (SPI0_MISO) SDA 19 GPIO10 (SPI0_MOSI) SCL 23 GPIO11 (SPI0_SCLK) Sch\u00e9mas de c\u00e2blage de Fritzing pour certaines des cartes ADXL345 :","title":"Directement sur Raspberry Pi"},{"location":"Measuring_Resonances.html#utilisation-dun-raspberry-pi-pico","text":"Vous pouvez connecter l'ADXL345 \u00e0 votre Raspberry Pi Pico, puis connecter le Pico \u00e0 votre Raspberry Pi via USB. Cela facilite la r\u00e9utilisation de l'acc\u00e9l\u00e9rom\u00e8tre sur d'autres appareils Klipper, car vous pouvez vous connecter via USB au lieu de GPIO. Le Pico n'a pas beaucoup de puissance de traitement, alors assurez-vous qu'il n'ex\u00e9cute que l'acc\u00e9l\u00e9rom\u00e8tre et n'effectue aucune autre t\u00e2che. Afin d'\u00e9viter d'endommager votre RPi, assurez-vous de connecter l'ADXL345 uniquement \u00e0 3,3 V. Selon la disposition de la carte, un d\u00e9calage de niveau peut \u00eatre pr\u00e9sent, ce qui rend le 5V dangereux pour votre RPi. Brochage de l'ADXL345 Broche pico Nom de la broche Pico 3,3 V (ou VCC) 36 Alimentation 3,3 V CC GND 38 Terre CS 2 GP1 (SPI0_CSn) SDO 1 GP0 (SPI0_RX) SDA 5 GP3 (SPI0_TX) SCL 4 GP2 (SPI0_SCK) Sch\u00e9mas de c\u00e2blage pour certaines des cartes ADXL345 :","title":"Utilisation d'un Raspberry Pi Pico"},{"location":"Measuring_Resonances.html#accelerometres-i2c","text":"Suggested twisted pair order for three pairs (preferred): 3.3V+GND SDA+GND SCL+GND or for two pairs: 3.3V+SDA GND+SCL Note that unlike a cable shield, any GND(s) should be connected at both ends.","title":"Acc\u00e9l\u00e9rom\u00e8tres I2C"},{"location":"Measuring_Resonances.html#mpu-9250mpu-9255mpu-6515mpu-6050mpu-6500","text":"These accelerometers have been tested to work over I2C on the RPi, RP2040 (Pico) and AVR at 400kbit/s ( fast mode ). Some MPU accelerometer modules include pull-ups, but some are too large at 10K and must be changed or supplemented by smaller parallel resistors. Sch\u00e9ma de connexion recommand\u00e9 pour I2C sur le Raspberry Pi : brochage du MPU-9250 Brochage du RPI Nom des broches du RPI VCC 01 Alimentation 3.3v continu GND 09 Terre SDA 03 GPIO02 (SDA1) SCL 05 GPIO03 (SCL1) The RPi has buit-in 1.8K pull-ups on both SCL and SDA. Recommended connection scheme for I2C (i2c0a) on the RP2040: brochage du MPU-9250 Broche du RP2040 RP2040 pin name VCC 36 3v3 GND 38 Terre SDA 01 GP0 (I2C0 SDA) SCL 02 GP1 (I2C0 SCL) The Pico does not include any built-in I2C pull-up resistors.","title":"MPU-9250/MPU-9255/MPU-6515/MPU-6050/MPU-6500"},{"location":"Measuring_Resonances.html#recommended-connection-scheme-for-i2ctwi-on-the-avr-atmega328p-arduino-nano","text":"brochage du MPU-9250 Atmega328P TQFP32 pin Atmega328P pin name Arduino Nano pin VCC 39 - - GND 38 Terre GND SDA 27 SDA A4 SCL 28 SCL A5 The Arduino Nano does not include any built-in pull-up resistors nor a 3.3V power pin.","title":"Recommended connection scheme for I2C(TWI) on the AVR ATmega328P Arduino Nano:"},{"location":"Measuring_Resonances.html#montage-de-laccelerometre","text":"L\u2019acc\u00e9l\u00e9rom\u00e8tre doit \u00eatre fix\u00e9 sur la t\u00eate d'impression. Il faut concevoir un support appropri\u00e9 et adapt\u00e9 \u00e0 l'imprimante 3D. Il est pr\u00e9f\u00e9rable d\u2019aligner les axes de l\u2019acc\u00e9l\u00e9rom\u00e8tre avec les axes de l\u2019imprimante (mais ce n'est pas obligatoire - c\u2019est-\u00e0-dire pas besoin d\u2019aligner l\u2019axe X avec X et ainsi de suite - cela devrait \u00eatre correct m\u00eame si l\u2019axe Z de l\u2019acc\u00e9l\u00e9rom\u00e8tre est l\u2019axe X de l\u2019imprimante, etc.). Exemple de montage d\u2019ADXL345 sur le SmartEffector : Notez que sur une imprimante cart\u00e9sienne, il faut concevoir 2 supports : un pour la t\u00eate et un pour le lit, et ex\u00e9cuter les mesures deux fois. Voir la section correspondante pour plus de d\u00e9tails. Attention : assurez-vous que l\u2019acc\u00e9l\u00e9rom\u00e8tre et les vis qui le maintiennent en place ne touchent aucune partie m\u00e9tallique de l\u2019imprimante. Fondamentalement, le support doit \u00eatre con\u00e7u de mani\u00e8re \u00e0 assurer l\u2019isolation \u00e9lectrique de l\u2019acc\u00e9l\u00e9rom\u00e8tre du ch\u00e2ssis de l\u2019imprimante. Ne pas s\u2019assurer de cette isolation peut cr\u00e9er une boucle de masse dans le syst\u00e8me conduisant \u00e0 l'endommagement de l\u2019\u00e9lectronique.","title":"Montage de l\u2019acc\u00e9l\u00e9rom\u00e8tre"},{"location":"Measuring_Resonances.html#installation-logicielle","text":"Notez que les mesures de r\u00e9sonance et l\u2019auto-\u00e9talonnage de l'input shaper n\u00e9cessitent des d\u00e9pendances logicielles suppl\u00e9mentaires non install\u00e9es par d\u00e9faut. Tout d\u2019abord, ex\u00e9cutez sur votre Raspberry Pi les commandes suivantes\u202f: sudo apt update sudo apt install python3-numpy python3-matplotlib libatlas-base-dev Ensuite, pour installer NumPy dans l\u2019environnement Klipper, ex\u00e9cutez la commande\u202f: ~/klippy-env/bin/pip install -v numpy Selon les performances du processeur, cette op\u00e9ration peut prendre jusqu\u2019\u00e0 20 minutes. Soyez patient et attendez la fin de l\u2019installation. Dans certains cas, si la carte a trop peu de m\u00e9moire, l\u2019installation peut \u00e9chouer et vous devrez activer le fichier d\u2019\u00e9change.","title":"Installation logicielle"},{"location":"Measuring_Resonances.html#configurer-ladxl345-avec-le-rpi","text":"First, check and follow the instructions in the RPi Microcontroller document to setup the \"linux mcu\" on the Raspberry Pi. This will configure a second Klipper instance that runs on your Pi. Assurez-vous que le pilote SPI Linux est activ\u00e9 en ex\u00e9cutant sudo raspi-config et en activant SPI dans le menu \u00ab Options d\u2019interface \u00bb. Ajoutez les lignes suivantes au fichier printer.cfg : [mcu rpi] serial: /tmp/klipper_host_mcu [adxl345] cs_pin: rpi:None [resonance_tester] accel_chip: adxl345 probe_points: 100, 100, 20 # valeur exemple Il est conseill\u00e9 de commencer par 1 point de test, au milieu du lit d\u2019impression, l\u00e9g\u00e8rement au-dessus.","title":"Configurer l'ADXL345 avec le RPi"},{"location":"Measuring_Resonances.html#configurer-adxl345-avec-pi-pico","text":"","title":"Configurer ADXL345 avec Pi Pico"},{"location":"Measuring_Resonances.html#flash-micrologiciel-du-pico","text":"Sur votre Raspberry Pi, compilez le firmware du Pico. cd ~/klipper make clean make menuconfig Maintenant, tout en maintenant enfonc\u00e9 le bouton BOOTSEL sur le Pico, connectez le Pico au Raspberry Pi via USB. Compilez et flashez le firmware. make flash FLASH_DEVICE=first Si cela \u00e9choue, on vous indiquera quel FLASH_DEVICE utiliser. Dans cet exemple, c'est make flash FLASH_DEVICE=2e8a:0003 .","title":"Flash micrologiciel du Pico"},{"location":"Measuring_Resonances.html#configurer-la-connexion","text":"Le Pico va maintenant red\u00e9marrer avec le nouveau micrologiciel et devrait appara\u00eetre comme un p\u00e9riph\u00e9rique s\u00e9rie. Trouvez le p\u00e9riph\u00e9rique s\u00e9rie pico avec ls /dev/serial/by-id/* . Vous pouvez maintenant ajouter un fichier adxl.cfg avec les param\u00e8tres suivants : [mcu adxl] # Changez <mySerial> par ce que vous aurez trouv\u00e9 ci-dessus. Par exemple, # usb-Klipper_rp2040_E661640843545B2E-if00 serial: /dev/serial/by-id/usb-Klipper_rp2040_<mySerial> [adxl345] cs_pin: adxl:gpio1 spi_bus: spi0a axes_map: x,z,y [resonance_tester] accel_chip: adxl345 probe_points: # Approximativement au milieu du plateau 147,154, 20 [output_pin power_mode] # Pour am\u00e9liorer la stabilit\u00e9 de l'alimentation pin: adxl:gpio23 Si vous mettez la configuration ADXL345 dans un fichier s\u00e9par\u00e9, comme indiqu\u00e9 ci-dessus, vous devrez \u00e9galement modifier votre fichier printer.cfg pour inclure ceci : [include adxl.cfg] # Commentez cette ligne lorsque vous d\u00e9connectez l'acc\u00e9l\u00e9rom\u00e8tre Red\u00e9marrez Klipper avec la commande RESTART .","title":"Configurer la connexion"},{"location":"Measuring_Resonances.html#configure-lis2dw-series","text":"[mcu lis] # Change <mySerial> to whatever you found above. For example, # usb-Klipper_rp2040_E661640843545B2E-if00 serial: /dev/serial/by-id/usb-Klipper_rp2040_<mySerial> [lis2dw] cs_pin: lis:gpio1 spi_bus: spi0a axes_map: x,z,y [resonance_tester] accel_chip: lis2dw probe_points: # Somewhere slightly above the middle of your print bed 147,154, 20","title":"Configure LIS2DW series"},{"location":"Measuring_Resonances.html#configurer-les-series-mpu-60009000-avec-le-rpi","text":"Assurez-vous que le pilote Linux I2C est activ\u00e9 et que le d\u00e9bit en bauds est d\u00e9fini sur 400 000 (voir la section Activation d'I2C pour plus de d\u00e9tails). Ensuite, ajoutez ce qui suit au fichier printer.cfg : [mcu rpi] serial: /tmp/klipper_host_mcu [mpu9250] i2c_mcu: rpi i2c_bus: i2c.1 [resonance_tester] accel_chip: mpu9250 probe_points: 100, 100, 20 # valeurs exemple","title":"Configurer les s\u00e9ries MPU-6000/9000 avec le RPi"},{"location":"Measuring_Resonances.html#configure-mpu-9520-compatibles-with-pico","text":"Pico I2C is set to 400000 on default. Simply add the following to the printer.cfg: [mcu pico] serial: /dev/serial/by-id/<your Pico's serial ID> [mpu9250] i2c_mcu: pico i2c_bus: i2c0a [resonance_tester] accel_chip: mpu9250 probe_points: 100, 100, 20 # an example [static_digital_output pico_3V3pwm] # Improve power stability pins: pico:gpio23","title":"Configure MPU-9520 Compatibles With Pico"},{"location":"Measuring_Resonances.html#configure-mpu-9520-compatibles-with-avr","text":"AVR I2C will be set to 400000 by the mpu9250 option. Simply add the following to the printer.cfg: [mcu nano] serial: /dev/serial/by-id/<your nano's serial ID> [mpu9250] i2c_mcu: nano [resonance_tester] accel_chip: mpu9250 probe_points: 100, 100, 20 # an example Red\u00e9marrez Klipper avec la commande RESTART .","title":"Configure MPU-9520 Compatibles with AVR"},{"location":"Measuring_Resonances.html#mesurer-les-resonances","text":"","title":"Mesurer les r\u00e9sonances"},{"location":"Measuring_Resonances.html#verification-de-la-configuration","text":"Vous pouvez maintenant tester la connexion. Pour les imprimantes non cart\u00e9siennes (celles avec une seul acc\u00e9l\u00e9rom\u00e8tre), dans Octoprint, entrez ACCELEROMETER_QUERY Pour les imprimante cart\u00e9siennes (plus d\u2019un acc\u00e9l\u00e9rom\u00e8tre), entrez ACCELEROMETER_QUERY CHIP=<chip> o\u00f9 <chip> est le nom de la puce tel qu\u2019il a \u00e9t\u00e9 entr\u00e9, par exemple CHIP=bed (voir\u202f: bed-slinger ) faites-le pour tous les acc\u00e9l\u00e9rom\u00e8tre install\u00e9s. Vous devriez voir les mesures actuelles de l\u2019acc\u00e9l\u00e9rom\u00e8tre, y compris l\u2019acc\u00e9l\u00e9ration en chute libre. Recv: // adxl345 values (x, y, z)\u202f: 470.719200, 941.438400, 9728.196800 Si vous obtenez une erreur comme ID adxl345 non valide (got xx vs e5) , o\u00f9 xx est un autre ID, r\u00e9essayez imm\u00e9diatement. Il y a un probl\u00e8me avec l'initialisation SPI. Si vous obtenez toujours une erreur, cela indique un probl\u00e8me de connexion avec ADXL345 ou le capteur d\u00e9fectueux. V\u00e9rifiez \u00e0 nouveau l'alimentation, le c\u00e2blage (qu'il corresponde aux sch\u00e9mas, qu'aucun fil n'est cass\u00e9 ou desserr\u00e9, etc.) et la qualit\u00e9 de la soudure. If you are using a MPU-9250 compatible accelerometer and it shows up as mpu-unknown , use with caution! They are probably refurbished chips! Ensuite, essayez d\u2019ex\u00e9cuter MEASURE_AXES_NOISE dans Octoprint, vous devriez obtenir des chiffres de base pour le bruit de fond de l\u2019acc\u00e9l\u00e9rom\u00e8tre sur les axes (devraient se situer entre 1 et 100). Un bruit de fond d\u2019axe trop \u00e9lev\u00e9 (par exemple 1000 et plus) peut indiquer des probl\u00e8mes de capteur, des probl\u00e8mes de puissance ou des ventilateurs d\u00e9s\u00e9quilibr\u00e9s entrainant trop de vibrations sur l'imprimante 3D.","title":"V\u00e9rification de la configuration"},{"location":"Measuring_Resonances.html#mesurer-les-resonances_1","text":"Vous pouvez maintenant ex\u00e9cuter les tests r\u00e9els. Ex\u00e9cutez la commande suivante : TEST_RESONANCES AXIS=X Notez que cela cr\u00e9era des vibrations sur l\u2019axe X. Ce test d\u00e9sactivera les valeurs du formateur d'entr\u00e9e (aka input shapper) d\u00e9j\u00e0 param\u00e9tr\u00e9es. Le test de r\u00e9sonance ne peut pas \u00eatre fait avec le formateur d'entr\u00e9e d\u00e9j\u00e0 activ\u00e9. Attention\u202f! Gardez un \u0153il sur l\u2019imprimante la premi\u00e8re fois, pour vous assurer que les vibrations ne deviennent pas trop violentes (la commande M112 peut \u00eatre utilis\u00e9e pour interrompre le test en cas d\u2019urgence - en esp\u00e9rant ne pas avoir \u00e0 l'utiliser). Si les vibrations deviennent trop fortes, vous pouvez sp\u00e9cifier une valeur inf\u00e9rieure \u00e0 la valeur par d\u00e9faut du param\u00e8tre accel_per_hz dans la section [resonance_tester] . [resonance_tester] accel_chip: adxl345 accel_per_hz: 50 # default is 75 probe_points: ... Si cela fonctionne pour l\u2019axe X, ex\u00e9cutez ensuite la commande pour l\u2019axe Y : TEST_RESONANCES AXIS=Y Cela g\u00e9n\u00e9rera 2 fichiers CSV ( /tmp/resonances_x_*.csv et /tmp/resonances_y_*.csv ). Ces fichiers peuvent \u00eatre trait\u00e9s avec le script autonome sur un Raspberry Pi. Pour ce faire, ex\u00e9cutez les commandes suivantes : ~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o /tmp/shaper_calibrate_x.png ~/klipper/scripts/calibrate_shaper.py /tmp/resonances_y_*.csv -o /tmp/shaper_calibrate_y.png Ce script g\u00e9n\u00e9rera les graphiques /tmp/shaper_calibrate_x.png et /tmp/shaper_calibrate_y.png avec les r\u00e9ponses en fr\u00e9quence. Vous obtiendrez \u00e9galement les fr\u00e9quences sugg\u00e9r\u00e9es pour chaque mode du formateur d'entr\u00e9e (input shapper), ainsi que la valeur recommand\u00e9e pour votre configuration. Par exemple : Fitted shaper 'zv' frequency = 34.4 Hz (vibrations = 4.0%, smoothing ~= 0.132) To avoid too much smoothing with 'zv', suggested max_accel <= 4500 mm/sec^2 Fitted shaper 'mzv' frequency = 34.6 Hz (vibrations = 0.0%, smoothing ~= 0.170) To avoid too much smoothing with 'mzv', suggested max_accel <= 3500 mm/sec^2 Fitted shaper 'ei' frequency = 41.4 Hz (vibrations = 0.0%, smoothing ~= 0.188) To avoid too much smoothing with 'ei', suggested max_accel <= 3200 mm/sec^2 Fitted shaper '2hump_ei' frequency = 51.8 Hz (vibrations = 0.0%, smoothing ~= 0.201) To avoid too much smoothing with '2hump_ei', suggested max_accel <= 3000 mm/sec^2 Fitted shaper '3hump_ei' frequency = 61.8 Hz (vibrations = 0.0%, smoothing ~= 0.215) To avoid too much smoothing with '3hump_ei', suggested max_accel <= 2800 mm/sec^2 Recommended shaper is mzv @ 34.6 Hz La configuration sugg\u00e9r\u00e9e peut \u00eatre ajout\u00e9e \u00e0 la section [input_shaper] de printer.cfg , par exemple : [input_shaper] shaper_freq_x: ... shaper_type_x: ... shaper_freq_y: 34.6 shaper_type_y: mzv [printer] max_accel: 3000 # Ne devrait pas d\u00e9passer les valeurs estim\u00e9es d'acc\u00e9l\u00e9ration calcul\u00e9es pour les axes X et Y Ou vous pouvez choisir vous-m\u00eame une autre configuration en fonction des graphiques g\u00e9n\u00e9r\u00e9s\u202f: les pics de densit\u00e9 spectrale de puissance sur les graphiques correspondent aux fr\u00e9quences de r\u00e9sonance de l\u2019imprimante. Notez que vous pouvez \u00e9galement ex\u00e9cuter l'auto-calibration du shaper d'entr\u00e9e \u00e0 partir de Klipper directement , ce qui peut \u00eatre pratique, par exemple, pour le shaper d'entr\u00e9e re-calibration .","title":"Mesurer les r\u00e9sonances"},{"location":"Measuring_Resonances.html#imprimantes-cartesiennes-a-lit-mobile","text":"Si votre imprimante est une imprimante cart\u00e9sienne dont le plateau est mobile sur l'axe Y, vous devrez changer l\u2019emplacement de l\u2019acc\u00e9l\u00e9rom\u00e8tre entre les mesures des axes X et Y : mesurez les r\u00e9sonances de l\u2019axe X avec l\u2019acc\u00e9l\u00e9rom\u00e8tre fix\u00e9 \u00e0 la t\u00eate et les r\u00e9sonances de l\u2019axe Y - au lit (la configuration habituelle des imprimantes cart\u00e9siennes). However, you can also connect two accelerometers simultaneously, though the ADXL345 must be connected to different boards (say, to an RPi and printer MCU board), or to two different physical SPI interfaces on the same board (rarely available). Then they can be configured in the following manner: [adxl345 hotend] # En consid\u00e9rant que l'adxl de la t\u00eate connect\u00e9e au RPI cs_pin: rpi:None [adxl345 bed] # En consid\u00e9rant que l'adxl du lit est connect\u00e9 au MCU cs_pin: ... # Printer board SPI chip select (CS) pin [resonance_tester] # En consid\u00e9rant un montage standard pour une imprimante cart\u00e9sienne accel_chip_x: adxl345 hotend accel_chip_y: adxl345 bed probe_points: ... Two MPUs can share one I2C bus, but they cannot measure simultaneously as the 400kbit/s I2C bus is not fast enough. One must have its AD0 pin pulled-down to 0V (address 104) and the other its AD0 pin pulled-up to 3.3V (address 105): [mpu9250 hotend] i2c_mcu: rpi i2c_bus: i2c.1 i2c_address: 104 # This MPU has pin AD0 pulled low [mpu9250 bed] i2c_mcu: rpi i2c_bus: i2c.1 i2c_address: 105 # This MPU has pin AD0 pulled high [resonance_tester] # Assuming the typical setup of the bed slinger printer accel_chip_x: mpu9250 hotend accel_chip_y: mpu9250 bed probe_points: ... [Test with each MPU individually before connecting both to the bus for easy debugging.] Ensuite, les commandes TEST_RESONANCES AXIS=X et TEST_RESONANCES AXIS=Y utiliseront le bon acc\u00e9l\u00e9rom\u00e8tre pour chaque axe.","title":"Imprimantes cart\u00e9siennes \u00e0 lit mobile"},{"location":"Measuring_Resonances.html#lissage-maximum","text":"Gardez \u00e0 l'esprit que le formateur d'entr\u00e9e (input shapper) peut cr\u00e9er un lissage sur certaines parties de l'impression. Le r\u00e9glage automatique du formateur d'entr\u00e9e effectu\u00e9 par le script calibrate_shaper.py ou la commande SHAPER_CALIBRATE essaie de limiter le lissage, mais il essaie aussi de minimiser les vibrations r\u00e9sultantes. Cela peut conduire parfois, \u00e0 un choix peu optimis\u00e9 de la fr\u00e9quence du formateur d'entr\u00e9e ou peut-\u00eatre pr\u00e9f\u00e9rez-vous simplement avoir moins de lissage dans certaines parties de l'impression au d\u00e9triment des vibrations restantes. Dans ces cas, vous pouvez demander de limiter le lissage maximal \u00e0 partir du formateur d'entr\u00e9e. Regardons les r\u00e9sultats suivants du r\u00e9glage automatique : Fitted shaper 'zv' frequency = 57.8 Hz (vibrations = 20.3%, smoothing ~= 0.053) To avoid too much smoothing with 'zv', suggested max_accel <= 13000 mm/sec^2 Fitted shaper 'mzv' frequency = 34.8 Hz (vibrations = 3.6%, smoothing ~= 0.168) To avoid too much smoothing with 'mzv', suggested max_accel <= 3600 mm/sec^2 Fitted shaper 'ei' frequency = 48.8 Hz (vibrations = 4.9%, smoothing ~= 0.135) To avoid too much smoothing with 'ei', suggested max_accel <= 4400 mm/sec^2 Fitted shaper '2hump_ei' frequency = 45.2 Hz (vibrations = 0.1%, smoothing ~= 0.264) To avoid too much smoothing with '2hump_ei', suggested max_accel <= 2200 mm/sec^2 Fitted shaper '3hump_ei' frequency = 48.0 Hz (vibrations = 0.0%, smoothing ~= 0.356) To avoid too much smoothing with '3hump_ei', suggested max_accel <= 1500 mm/sec^2 Recommended shaper is 2hump_ei @ 45.2 Hz Notez que les valeurs rapport\u00e9es smoothing sont des valeurs projet\u00e9es abstraites. Ces valeurs peuvent \u00eatre utilis\u00e9es pour comparer diff\u00e9rentes configurations : plus la valeur est \u00e9lev\u00e9e, plus le formateur d'entr\u00e9e cr\u00e9era de lissage. Cependant, ces scores de lissage ne repr\u00e9sentent aucune mesure r\u00e9elle du lissage, car le lissage r\u00e9el d\u00e9pend des param\u00e8tres max_accel et square_corner_velocity . Par cons\u00e9quent, vous devrez faire des impressions de test pour voir exactement le lissage cr\u00e9\u00e9 par la configuration choisie. Dans l'exemple ci-dessus, les param\u00e8tres de mise en forme sugg\u00e9r\u00e9s ne sont pas mauvais, mais que se passe-t-il si vous souhaitez obtenir moins de lissage sur l'axe X ? Vous pouvez essayer de limiter le lissage maximal du formateur d'entr\u00e9e \u00e0 l'aide de la commande suivante : ~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o /tmp/shaper_calibrate_x.png --max_smoothing=0.2 ce qui limite le lissage \u00e0 un score de 0,2. Vous pouvez maintenant obtenir le r\u00e9sultat suivant : Fitted shaper 'zv' frequency = 55.4 Hz (vibrations = 19.7%, smoothing ~= 0.057) To avoid too much smoothing with 'zv', suggested max_accel <= 12000 mm/sec^2 Fitted shaper 'mzv' frequency = 34.6 Hz (vibrations = 3.6%, smoothing ~= 0.170) To avoid too much smoothing with 'mzv', suggested max_accel <= 3500 mm/sec^2 Fitted shaper 'ei' frequency = 48.2 Hz (vibrations = 4.8%, smoothing ~= 0.139) To avoid too much smoothing with 'ei', suggested max_accel <= 4300 mm/sec^2 Fitted shaper '2hump_ei' frequency = 52.0 Hz (vibrations = 2.7%, smoothing ~= 0.200) To avoid too much smoothing with '2hump_ei', suggested max_accel <= 3000 mm/sec^2 Fitted shaper '3hump_ei' frequency = 72.6 Hz (vibrations = 1.4%, smoothing ~= 0.155) To avoid too much smoothing with '3hump_ei', suggested max_accel <= 3900 mm/sec^2 Recommended shaper is 3hump_ei @ 72.6 Hz Si vous comparez avec les pr\u00e9c\u00e9dents param\u00e8tres sugg\u00e9r\u00e9s, les vibrations sont un peu plus importantes, mais le lissage est nettement plus faible qu'auparavant, ce qui permet une acc\u00e9l\u00e9ration maximale plus importante. Lorsque vous choisissez le param\u00e8tre max_smoothing , vous pouvez utiliser une approche par essais et erreurs. Essayez quelques valeurs diff\u00e9rentes et voyez quels r\u00e9sultats vous obtenez. Notez que le lissage r\u00e9el produit par le formateur d'entr\u00e9e d\u00e9pend principalement de la fr\u00e9quence de r\u00e9sonance la plus basse de l'imprimante : plus la fr\u00e9quence de r\u00e9sonance la plus basse est \u00e9lev\u00e9e, plus le lissage est faible. Par cons\u00e9quent, si vous demandez au script de trouver une configuration du formateur d'entr\u00e9e avec un lissage irr\u00e9aliste, cela se fera au d\u00e9triment d'une r\u00e9sonance accrue aux fr\u00e9quences les plus basses (g\u00e9n\u00e9ralement, les plus visibles dans les impressions). V\u00e9rifiez donc toujours les vibrations restantes projet\u00e9es signal\u00e9es par le script et assurez-vous qu'elles ne sont pas trop \u00e9lev\u00e9es. Notez que si vous avez trouv\u00e9 une bonne valeur de max_smoothing pour vos deux axes, vous pouvez la stocker dans printer.cfg comme [resonance_tester] accel_chip: ... probe_points: ... max_smoothing: 0.25 # valeur exemple Ensuite, si vous r\u00e9ex\u00e9cutez le r\u00e9glage automatique du formateur d'entr\u00e9e \u00e0 l'aide de la commande SHAPER_CALIBRATE , c'est cette valeur stock\u00e9e max_smoothing qui sera prise comme r\u00e9f\u00e9rence.","title":"Lissage maximum"},{"location":"Measuring_Resonances.html#selection-de-max_accel","text":"\u00c9tant donn\u00e9 que le formateur d'entr\u00e9e peut cr\u00e9er un certain lissage dans les pi\u00e8ces, en particulier avec des acc\u00e9l\u00e9rations \u00e9lev\u00e9es, vous devrez toujours choisir une valeur max_accel ne cr\u00e9ant pas trop de lissage dans les pi\u00e8ces imprim\u00e9es. Un script d'\u00e9talonnage fournit une estimation du param\u00e8tre max_accel qui ne devrait pas cr\u00e9er trop de lissage. Notez que le max_accel tel qu'affich\u00e9 par le script de calibrage n'est qu'un maximum th\u00e9orique auquel le formateur d'entr\u00e9e est encore capable de travailler sans produire trop de lissage. Il ne s'agit en aucun cas d'une recommandation pour d\u00e9finir cette acc\u00e9l\u00e9ration sur vos impressions. L'acc\u00e9l\u00e9ration maximale support\u00e9e par votre imprimante d\u00e9pend de ses propri\u00e9t\u00e9s m\u00e9caniques et du couple maximal des moteurs pas \u00e0 pas utilis\u00e9s. Par cons\u00e9quent, il est sugg\u00e9r\u00e9 de d\u00e9finir un max_accel dans la section [printer] qui ne d\u00e9passe pas les valeurs estim\u00e9es pour les axes X et Y, probablement avec une marge de s\u00e9curit\u00e9. Vous pouvez \u00e9galement suivre cette partie du guide de r\u00e9glage du formateur d'entr\u00e9e et imprimer un mod\u00e8le de test pour choisir le param\u00e8tre max_accel de mani\u00e8re exp\u00e9rimentale. M\u00eame remarque pour l' auto-calibration du formateur d'entr\u00e9e avec la commande SHAPER_CALIBRATE : il faut encore choisir la bonne valeur max_accel apr\u00e8s l'auto-calibrage, notez que les limites d'acc\u00e9l\u00e9rations sugg\u00e9r\u00e9es ne sont pas appliqu\u00e9es automatiquement. Si vous effectuez un r\u00e9-\u00e9talonnage du formateur d'entr\u00e9e et que le lissage indiqu\u00e9 pour la configuration de formateur sugg\u00e9r\u00e9e est pratiquement le m\u00eame que celui obtenu lors du calibrage pr\u00e9c\u00e9dent, cette \u00e9tape peut \u00eatre ignor\u00e9e.","title":"S\u00e9lection de max_accel"},{"location":"Measuring_Resonances.html#test-des-axes-personnalises","text":"la commande TEST_RESONANCES prend en charge les axes personnalis\u00e9s. Bien que cela ne soit pas vraiment utile pour l\u2019\u00e9talonnage des input shaper, cela peut \u00eatre utilis\u00e9 pour \u00e9tudier en profondeur les r\u00e9sonances de l\u2019imprimante et v\u00e9rifier, par exemple, la tension de la courroie. Pour v\u00e9rifier la tension de la courroie sur les imprimantes CoreXY, ex\u00e9cutez TEST_RESONANCES AXIS=1,1 OUTPUT=raw_data TEST_RESONANCES AXIS=1,-1 OUTPUT=raw_data et utilisez graph_accelerometer.py pour traiter les fichiers g\u00e9n\u00e9r\u00e9s. ~/klipper/scripts/graph_accelerometer.py -c /tmp/raw_data_axis*.csv -o /tmp/resonances.png qui g\u00e9n\u00e9rera /tmp/r\u00e9sonances.png en comparant les r\u00e9sonances. Pour les imprimantes Delta avec le placement des tours par d\u00e9faut (tour A ~= 210 degr\u00e9s, B ~= 330 degr\u00e9s et C ~= 90 degr\u00e9s), ex\u00e9cutez TEST_RESONANCES AXIS=0,1 OUTPUT=raw_data TEST_RESONANCES AXIS=-0.866025404,-0.5 OUTPUT=raw_data TEST_RESONANCES AXIS=0.866025404,-0.5 OUTPUT=raw_data puis utilisez la m\u00eame commande ~/klipper/scripts/graph_accelerometer.py -c /tmp/raw_data_axis*.csv -o /tmp/resonances.png pour g\u00e9n\u00e9rer le fichier de comparaison des r\u00e9sonnances /tmp/r\u00e9sonances.png .","title":"Test des axes personnalis\u00e9s"},{"location":"Measuring_Resonances.html#calibrage-automatique-du-formateur-dentree","text":"En plus de choisir manuellement les param\u00e8tres appropri\u00e9s pour la fonction de formateur d'entr\u00e9e, il est \u00e9galement possible d'ex\u00e9cuter le r\u00e9glage automatique du formateur d'entr\u00e9e directement \u00e0 partir de Klipper. Ex\u00e9cutez la commande suivante via le terminal Octoprint : SHAPER_CALIBRATE Cela ex\u00e9cutera le test complet pour les deux axes et g\u00e9n\u00e9rera la sortie csv ( /tmp/calibration_data_*.csv par d\u00e9faut) pour la r\u00e9ponse en fr\u00e9quence et les formateurs d'entr\u00e9e sugg\u00e9r\u00e9s. Vous obtiendrez \u00e9galement les fr\u00e9quences sugg\u00e9r\u00e9es pour chaque formateur, ainsi que le mod\u00e8le de formateur d'entr\u00e9e recommand\u00e9 pour votre configuration, sur la console Octoprint. Par exemple\u202f: Calculating the best input shaper parameters for y axis Fitted shaper 'zv' frequency = 39.0 Hz (vibrations = 13.2%, smoothing ~= 0.105) To avoid too much smoothing with 'zv', suggested max_accel <= 5900 mm/sec^2 Fitted shaper 'mzv' frequency = 36.8 Hz (vibrations = 1.7%, smoothing ~= 0.150) To avoid too much smoothing with 'mzv', suggested max_accel <= 4000 mm/sec^2 Fitted shaper 'ei' frequency = 36.6 Hz (vibrations = 2.2%, smoothing ~= 0.240) To avoid too much smoothing with 'ei', suggested max_accel <= 2500 mm/sec^2 Fitted shaper '2hump_ei' frequency = 48.0 Hz (vibrations = 0.0%, smoothing ~= 0.234) To avoid too much smoothing with '2hump_ei', suggested max_accel <= 2500 mm/sec^2 Fitted shaper '3hump_ei' frequency = 59.0 Hz (vibrations = 0.0%, smoothing ~= 0.235) To avoid too much smoothing with '3hump_ei', suggested max_accel <= 2500 mm/sec^2 Recommended shaper_type_y = mzv, shaper_freq_y = 36.8 Hz Si vous \u00eates d'accord avec les param\u00e8tres sugg\u00e9r\u00e9s, vous pouvez ex\u00e9cuter SAVE_CONFIG maintenant pour les enregistrer et red\u00e9marrer Klipper. Notez que cela ne mettra pas \u00e0 jour la valeur max_accel dans la section [printer] . Vous devrez la mettre \u00e0 jour manuellement en suivant les recommandations de la section Choisir l'acc\u00e9l\u00e9ration maximale . Si votre imprimante est une imprimante cart\u00e9sienne, vous pouvez pr\u00e9ciser l'axe \u00e0 tester, afin de pouvoir modifier le point de montage de l'acc\u00e9l\u00e9rom\u00e8tre entre les tests (par d\u00e9faut, le test est effectu\u00e9 pour les deux axes) : SHAPER_CALIBRATE AXIS=Y Vous pouvez ex\u00e9cuter SAVE_CONFIG deux fois - apr\u00e8s avoir calibr\u00e9 chaque axe. Cependant, si vous avez connect\u00e9 deux acc\u00e9l\u00e9rom\u00e8tres simultan\u00e9ment, vous pouvez ex\u00e9cutez simplement SHAPER_CALIBRATE sans sp\u00e9cifier d'axe pour calibrer les formateurs d'entr\u00e9e des deux axes en une seule fois.","title":"Calibrage automatique du formateur d'entr\u00e9e"},{"location":"Measuring_Resonances.html#re-etalonnage-du-formateur-dentree-aka-input-shapper","text":"La commande SHAPER_CALIBRATE peut \u00e9galement \u00eatre utilis\u00e9e pour recalibrer le formateur d'entr\u00e9e ult\u00e9rieurement, en particulier si des modifications de l'imprimante pouvant affecter sa cin\u00e9matique sont apport\u00e9es. On peut soit relancer l'\u00e9talonnage complet \u00e0 l'aide de la commande SHAPER_CALIBRATE , soit restreindre l'auto-\u00e9talonnage \u00e0 un seul axe en fournissant le param\u00e8tre AXIS= , comme SHAPER_CALIBRATE AXIS=X Attention ! Il n'est pas conseill\u00e9 d'ex\u00e9cuter l'auto-calibrage du shaper trop fr\u00e9quemment (par exemple, avant chaque impression ou tous les jours). Afin de d\u00e9terminer les fr\u00e9quences de r\u00e9sonance, l'auto-calibrage cr\u00e9e des vibrations intenses sur chacun des axes. G\u00e9n\u00e9ralement, les imprimantes 3D ne sont pas con\u00e7ues pour r\u00e9sister \u00e0 une exposition prolong\u00e9e \u00e0 des vibrations proches des fr\u00e9quences de r\u00e9sonance. Cela pourrait augmenter l'usure des composants de l'imprimante et r\u00e9duire leur dur\u00e9e de vie. Il existe \u00e9galement un risque accru que certaines pi\u00e8ces se d\u00e9vissent ou se desserrent. V\u00e9rifiez toujours que toutes les pi\u00e8ces de l'imprimante (y compris celles qui ne peuvent normalement pas bouger) sont solidement fix\u00e9es en place apr\u00e8s chaque r\u00e9glage automatique. De plus, en raison d'un certain bruit dans les mesures, il est possible que les r\u00e9sultats de r\u00e9glage soient l\u00e9g\u00e8rement diff\u00e9rents d'un calibrage \u00e0 l'autre. Ce bruit ne devrait pas trop affecter la qualit\u00e9 d'impression. Cependant, il est conseill\u00e9 de rev\u00e9rifier les param\u00e8tres sugg\u00e9r\u00e9s et d'imprimer des tests d'impression avant de les utiliser pour confirmer qu'ils sont corrects.","title":"R\u00e9-\u00e9talonnage du formateur d'entr\u00e9e (aka input shapper)"},{"location":"Measuring_Resonances.html#traitement-hors-ligne-des-donnees-de-laccelerometre","text":"Il est possible de g\u00e9n\u00e9rer les donn\u00e9es brutes de l\u2019acc\u00e9l\u00e9rom\u00e8tre et de les traiter hors ligne (par exemple sur une machine h\u00f4te), par exemple pour trouver des r\u00e9sonances. Pour ce faire, ex\u00e9cutez les commandes suivantes via le terminal Octoprint : SET_INPUT_SHAPER SHAPER_FREQ_X=0 SHAPER_FREQ_Y=0 TEST_RESONANCES AXIS=X OUTPUT=raw_data ignorez toute erreur pour la commande SET_INPUT_SHAPER . Pour la commande TEST_RESONANCES , sp\u00e9cifiez l\u2019axe de test souhait\u00e9. Les donn\u00e9es brutes seront \u00e9crites dans le r\u00e9pertoire /tmp sur le RPi. Les donn\u00e9es brutes peuvent \u00e9galement \u00eatre obtenues en ex\u00e9cutant la commande ACCELEROMETER_MEASURE deux fois - d\u2019abord pour d\u00e9marrer les mesures, puis pour les arr\u00eater et \u00e9crire le fichier de sortie. Reportez-vous \u00e0 G-Codes pour plus de d\u00e9tails. Les donn\u00e9es peuvent \u00eatre trait\u00e9es ult\u00e9rieurement avec les scripts suivants : scripts/graph_accelerometer.py et scripts/calibrate_shaper.py . Les deux acceptent un ou plusieurs fichiers csv bruts comme entr\u00e9e en fonction du mode. Le script graph_accelerometer.py prend en charge plusieurs modes de fonctionnement : pour le tra\u00e7age des donn\u00e9es brutes de l\u2019acc\u00e9l\u00e9rom\u00e8tre (utilisez le param\u00e8tre -r ), seule 1 entr\u00e9e est prise en charge\u202f; tracer une r\u00e9ponse en fr\u00e9quence (aucun param\u00e8tre suppl\u00e9mentaire n'est requis), si plusieurs entr\u00e9es sont sp\u00e9cifi\u00e9es, la r\u00e9ponse en fr\u00e9quence moyenne est calcul\u00e9e ; comparaison de la r\u00e9ponse en fr\u00e9quence entre plusieurs entr\u00e9es (utiliser le param\u00e8tre -c ) ; vous pouvez \u00e9galement sp\u00e9cifier l\u2019axe de l\u2019acc\u00e9l\u00e9rom\u00e8tre \u00e0 prendre en compte via le param\u00e8tre -a x , -a y ou -a z (si aucun n\u2019est sp\u00e9cifi\u00e9, la somme des vibrations pour tous les axes est utilis\u00e9e) ; tra\u00e7age du spectrogramme (utiliser le param\u00e8tre -s ), seule 1 entr\u00e9e est prise en charge\u202f; vous pouvez \u00e9galement sp\u00e9cifier l\u2019axe de l\u2019acc\u00e9l\u00e9rom\u00e8tre \u00e0 prendre en compte via le param\u00e8tre -a x , -a y ou -a z (si aucun n\u2019est sp\u00e9cifi\u00e9, la somme des vibrations pour tous les axes est utilis\u00e9e). Notez que graph_accelerometer.py script ne prend en charge que les fichiers raw_data*.csv et non les fichiers resonances*.csv ou calibration_data*.csv. Par exemple, ~/klipper/scripts/graph_accelerometer.py /tmp/raw_data_x_*.csv -o /tmp/resonances_x.png -c -a z tracera la comparaison de plusieurs fichiers /tmp/raw_data_x_*.csv pour l\u2019axe Z dans le fichier /tmp/resonances_x.png . Le script shaper_calibrate.py accepte 1 ou plusieurs entr\u00e9es et peut ex\u00e9cuter le r\u00e9glage automatique de l'input shaper et sugg\u00e9rer les meilleurs param\u00e8tres pour les entr\u00e9es fournies. Il affiche les param\u00e8tres sugg\u00e9r\u00e9s sur la console et peut en outre g\u00e9n\u00e9rer un graphique si le param\u00e8tre -o output.png est fourni, ou un fichier CSV si le param\u00e8tre -c output.csv est sp\u00e9cifi\u00e9. Fournir plusieurs entr\u00e9es \u00e0 shaper_calibrate.py script peut \u00eatre utile si vous ex\u00e9cutez un r\u00e9glage avanc\u00e9 de l'input shaper, par exemple : Ex\u00e9cutez TEST_RESONANCES AXIS=X OUTPUT=raw_data (et Y axe) pour un seul axe deux fois sur une imprimante cart\u00e9sienne avec l\u2019acc\u00e9l\u00e9rom\u00e8tre fix\u00e9 \u00e0 la t\u00eate d\u2019outil la premi\u00e8re fois, et l\u2019acc\u00e9l\u00e9rom\u00e8tre fix\u00e9 au lit la deuxi\u00e8me fois afin de d\u00e9tecter les r\u00e9sonances crois\u00e9es des axes et de tenter de les annuler avec l'input shaper. Ex\u00e9cutez TEST_RESONANCES AXIS=Y OUTPUT=raw_data deux fois sur le lit avec un lit en verre et une surface magn\u00e9tique (plus l\u00e9g\u00e8re) pour trouver les param\u00e8tres d'input shaper qui fonctionnent bien pour n\u2019importe quelle configuration de surface d\u2019impression. Combinaison des donn\u00e9es de r\u00e9sonance de plusieurs points de test. Combinaison des donn\u00e9es de r\u00e9sonance \u00e0 partir de 2 axes (par exemple, sur une imprimante cart\u00e9sienne pour configurer les input_shaper de l\u2019axe X \u00e0 partir des r\u00e9sonances des axes X et Y pour annuler les vibrations du lit * * au cas o\u00f9 la buse \u00ab attraperait \u00bb une impression lors du d\u00e9placement dans la direction de l\u2019axe X).","title":"Traitement hors ligne des donn\u00e9es de l\u2019acc\u00e9l\u00e9rom\u00e8tre"},{"location":"Multi_MCU_Homing.html","text":"Mise \u00e0 l'origine et Palpage multi contr\u00f4leurs \u00b6 Klipper poss\u00e8de un m\u00e9canisme pour la mise \u00e0 l'origine avec une fin de course raccord\u00e9e \u00e0 un microcontr\u00f4leur et des moteurs pas \u00e0 pas raccord\u00e9s \u00e0 un autre microcontr\u00f4leur. Ce m\u00e9canisme est connu sous le nom de \"multi-mcu homing\". Cette fonctionnalit\u00e9 est aussi utilis\u00e9e si la sonde de palpage Z est raccord\u00e9e \u00e0 un microcontr\u00f4leur diff\u00e9rent de celui des moteurs Z. Cette fonctionnalit\u00e9 peut \u00eatre utile pour simplifier le c\u00e2blage : il peut \u00eatre plus simple de raccorder un fin de course ou une sonde au microcontr\u00f4leur le plus proche. Cependant, l'utilisation de cette fonctionnalit\u00e9 peut provoquer un \"d\u00e9passement\" des moteurs pas \u00e0 pas pendant les op\u00e9ration de mise \u00e0 l'origine ou de palpage. Cette possibilit\u00e9 de \"d\u00e9passement\" peut arriver \u00e0 cause des d\u00e9lais de transmission entre le microcontr\u00f4leur des endstop et le microcontr\u00f4leur qui d\u00e9plce les moteurs pas \u00e0 pas. Le code de Klipper a \u00e9t\u00e9 con\u00e7u pour limiter ce d\u00e9lai a moins de 25 ms. (Quand la mise \u00e0 l'origine multi contr\u00f4leurs est active, les microcontr\u00f4leurs envoient des messages d'\u00e9tat p\u00e9riodiquement et il y a une v\u00e9rification que ces messages sont bien re\u00e7us dans la limite des 25 ms.) Donc, par exemple, si l'on fait une mise \u00e0 l'origine \u00e0 10 mm/s, il est alors possible de d\u00e9passer de 0.250 mm maximum (10 mm/s * 0.25 s = 0.250 mm).Il faut bien faire attention \u00e0 cette possibilit\u00e9 de \"d\u00e9passement\" lors de la configuration d'une mise \u00e0 l'origine avec multiples contr\u00f4leurs. Une mise \u00e0 l'origine ou un palpage plus lent peut r\u00e9duite le \"d\u00e9passement\". Ce d\u00e9passement des moteurs pas \u00e0 pas ne nuit pas \u00e0 la pr\u00e9cision de la proc\u00e9dure de mise \u00e0 l'origine et de palpage. Le code de Klipper d\u00e9tectera le d\u00e9passement et en tiendra compte dans ses calculs. Cependant, il est important que la conception mat\u00e9rielle soit capable de g\u00e9rer les d\u00e9passements sans endommager la machine. Si Klipper d\u00e9tecte un probl\u00e8me de communication entre les microcontr\u00f4leurs lors de la mise \u00e0 l'origine multi-mcu, il d\u00e9clenchera une erreur \"D\u00e9lai de communication pendant la mise \u00e0 l'origine\". Notez qu'un axe avec plusieurs steppers (par exemple, stepper_z et stepper_z1 ) doit avoir tous les meteeurs pas \u00e0 pas sur le m\u00eame microcontr\u00f4leur afin d'utiliser le r\u00e9f\u00e9rencement multi-mcu. Par exemple, si une fin de course est sur un microcontr\u00f4leur distinct de stepper_z alors stepper_z1 doit \u00eatre sur le m\u00eame microcontr\u00f4leur que stepper_z .","title":"Mise \u00e0 l'origine et Palpage multi contr\u00f4leurs"},{"location":"Multi_MCU_Homing.html#mise-a-lorigine-et-palpage-multi-controleurs","text":"Klipper poss\u00e8de un m\u00e9canisme pour la mise \u00e0 l'origine avec une fin de course raccord\u00e9e \u00e0 un microcontr\u00f4leur et des moteurs pas \u00e0 pas raccord\u00e9s \u00e0 un autre microcontr\u00f4leur. Ce m\u00e9canisme est connu sous le nom de \"multi-mcu homing\". Cette fonctionnalit\u00e9 est aussi utilis\u00e9e si la sonde de palpage Z est raccord\u00e9e \u00e0 un microcontr\u00f4leur diff\u00e9rent de celui des moteurs Z. Cette fonctionnalit\u00e9 peut \u00eatre utile pour simplifier le c\u00e2blage : il peut \u00eatre plus simple de raccorder un fin de course ou une sonde au microcontr\u00f4leur le plus proche. Cependant, l'utilisation de cette fonctionnalit\u00e9 peut provoquer un \"d\u00e9passement\" des moteurs pas \u00e0 pas pendant les op\u00e9ration de mise \u00e0 l'origine ou de palpage. Cette possibilit\u00e9 de \"d\u00e9passement\" peut arriver \u00e0 cause des d\u00e9lais de transmission entre le microcontr\u00f4leur des endstop et le microcontr\u00f4leur qui d\u00e9plce les moteurs pas \u00e0 pas. Le code de Klipper a \u00e9t\u00e9 con\u00e7u pour limiter ce d\u00e9lai a moins de 25 ms. (Quand la mise \u00e0 l'origine multi contr\u00f4leurs est active, les microcontr\u00f4leurs envoient des messages d'\u00e9tat p\u00e9riodiquement et il y a une v\u00e9rification que ces messages sont bien re\u00e7us dans la limite des 25 ms.) Donc, par exemple, si l'on fait une mise \u00e0 l'origine \u00e0 10 mm/s, il est alors possible de d\u00e9passer de 0.250 mm maximum (10 mm/s * 0.25 s = 0.250 mm).Il faut bien faire attention \u00e0 cette possibilit\u00e9 de \"d\u00e9passement\" lors de la configuration d'une mise \u00e0 l'origine avec multiples contr\u00f4leurs. Une mise \u00e0 l'origine ou un palpage plus lent peut r\u00e9duite le \"d\u00e9passement\". Ce d\u00e9passement des moteurs pas \u00e0 pas ne nuit pas \u00e0 la pr\u00e9cision de la proc\u00e9dure de mise \u00e0 l'origine et de palpage. Le code de Klipper d\u00e9tectera le d\u00e9passement et en tiendra compte dans ses calculs. Cependant, il est important que la conception mat\u00e9rielle soit capable de g\u00e9rer les d\u00e9passements sans endommager la machine. Si Klipper d\u00e9tecte un probl\u00e8me de communication entre les microcontr\u00f4leurs lors de la mise \u00e0 l'origine multi-mcu, il d\u00e9clenchera une erreur \"D\u00e9lai de communication pendant la mise \u00e0 l'origine\". Notez qu'un axe avec plusieurs steppers (par exemple, stepper_z et stepper_z1 ) doit avoir tous les meteeurs pas \u00e0 pas sur le m\u00eame microcontr\u00f4leur afin d'utiliser le r\u00e9f\u00e9rencement multi-mcu. Par exemple, si une fin de course est sur un microcontr\u00f4leur distinct de stepper_z alors stepper_z1 doit \u00eatre sur le m\u00eame microcontr\u00f4leur que stepper_z .","title":"Mise \u00e0 l'origine et Palpage multi contr\u00f4leurs"},{"location":"Navigation.html","text":"Documentation Klipper Installation et configuration R\u00e9f\u00e9rence de configuration Nivellement du lit Compensation de la r\u00e9sonance Mod\u00e8les de commandes Documentation pour les d\u00e9veloppeurs Documents sp\u00e9cifiques \u00e0 certains appareils","title":"Navigation"},{"location":"Overview.html","text":"Vue d'ensemble \u00b6 Bienvenue dans la documentation de Klipper. Si vous d\u00e9butez avec Klipper, commencez par les sections fonctionnalit\u00e9s et installation . Informations g\u00e9n\u00e9rales \u00b6 Fonctionnalit\u00e9s : Une liste avanc\u00e9e des fonctionnalit\u00e9s de Klipper. FAQ \u202f: Foire aux questions. Versions : L'historique des versions de Klipper. Modifications de configuration \u202f: Modifications r\u00e9centes du logiciel pouvant n\u00e9cessiter que les utilisateurs mettent \u00e0 jour la configuration de leur imprimante. Contact \u202f: Informations sur les rapports d'anomalies et communication g\u00e9n\u00e9rale avec les d\u00e9veloppeurs de Klipper. Installation et configuration \u00b6 Installation \u202f: Guide d'installation de Klipper. R\u00e9f\u00e9rence de la configuration : Description de tous les param\u00e8tres de configuration. Distance de rotation : Calcul du param\u00e8tre rotation_distance du moteur. V\u00e9rifications de la configuration : V\u00e9rification des param\u00e8tres de base des broches du fichier de configuration. Nivelage du lit : Informations sur le \"nivelage du lit\" dans Klipper. Calibration delta : Calibration de la cin\u00e9matique Delta. Calibration de la sonde : Calibration automatique des sondes Z. BL-Touch : Configuration d'une sonde \"BL-Touch\". Nivelage manuel : Calibration des but\u00e9es Z (et similaires). Maillage du lit : Correction de la hauteur du lit bas\u00e9e sur les emplacements XY. Phase de fin de course : Positionnement de la but\u00e9e Z assist\u00e9 par moteur. Axis Twist Compensation : A tool to compensate for inaccurate probe readings due to twist in X gantry. Compensation de la r\u00e9sonance : Un outil permettant de r\u00e9duire la r\u00e9sonance durant les impressions. Mesure des r\u00e9sonances : Informations sur l'utilisation d'un acc\u00e9l\u00e9rom\u00e8tre adxl345 pour mesurer les r\u00e9sonances. Avance \u00e0 la pression : Calibration de la pression dans l'extrudeur. G-Codes : Informations sur les instructions prises en charge par Klipper. Mod\u00e8les de commande : Macros G-Code et \u00e9valuation conditionnelle. R\u00e9f\u00e9rence des \u00e9tats : Informations disponibles pour les macros (et similaires). Pilotes TMC : Utilisation des pilotes de moteurs pas \u00e0 pas Trinamic avec Klipper. Prise origine multi-MCU : Mise \u00e0 l'origine et palpage utilisant plusieurs micro-contr\u00f4leurs. Trancheurs : Configuration d'un logiciel de \"tranchage\" pour Klipper. Correction d'obliquit\u00e9 : Ajustements des axes qui ne sont pas parfaitement d'\u00e9querre. Outils PWM : Guide sur l'utilisation des outils contr\u00f4l\u00e9s par PWM tels que les lasers ou les broches. Exclude Object : Le guide de l'impl\u00e9mentation d'Exclude Objects. Documentation pour les d\u00e9veloppeurs \u00b6 Aper\u00e7u du code : Les d\u00e9veloppeurs devraient lire ceci en premier. Cin\u00e9matiques : D\u00e9tails techniques sur la fa\u00e7on dont Klipper met en \u0153uvre les mouvements. Protocole : Informations sur le protocole de messagerie de bas niveau entre l'h\u00f4te et le microcontr\u00f4leur. API du serveur : Informations sur l'API de commande et de contr\u00f4le de Klipper. Commandes MCU : Une description des commandes de bas niveau impl\u00e9ment\u00e9es dans le logiciel du micro-contr\u00f4leur. Protocole du bus CAN : Format de messages du bus CAN de Klipper. D\u00e9bogage : Informations sur la fa\u00e7on de tester et d\u00e9boguer Klipper. Tests de charge : Informations sur la m\u00e9thode de tests de charge de Klipper. Contribuer : Comment proposer des am\u00e9liorations pour Klipper. Packaging : Informations sur la construction de paquets de syst\u00e8me d'exploitation. Documents sp\u00e9cifiques \u00e0 certains appareils \u00b6 Exemples de configurations : Informations sur l'ajout d'un exemple de fichier de configuration \u00e0 Klipper. Mises \u00e0 jour par carte SD : Flasher le micro-contr\u00f4leur en copiant un binaire sur une carte SD. Raspberry Pi en tant que micro-contr\u00f4leur : D\u00e9tails pour contr\u00f4ler les appareils connect\u00e9s aux broches GPIO d'un Raspberry Pi. Beaglebone : D\u00e9tails pour l'ex\u00e9cution de Klipper sur le SBC Beaglebone. Bootloaders : Informations pour les d\u00e9veloppeurs sur le flashage des microcontr\u00f4leurs. Bootloader Entry : Requesting the bootloader. Bus CAN : Informations sur l'utilisation du bus CAN avec Klipper. CAN bus troubleshooting : Tips for troubleshooting CAN bus. Capteur de largeur de filament TSL1401CL D\u00e9tecteur de largeur de filament \u00e0 effet hall","title":"Vue d'ensemble"},{"location":"Overview.html#vue-densemble","text":"Bienvenue dans la documentation de Klipper. Si vous d\u00e9butez avec Klipper, commencez par les sections fonctionnalit\u00e9s et installation .","title":"Vue d'ensemble"},{"location":"Overview.html#informations-generales","text":"Fonctionnalit\u00e9s : Une liste avanc\u00e9e des fonctionnalit\u00e9s de Klipper. FAQ \u202f: Foire aux questions. Versions : L'historique des versions de Klipper. Modifications de configuration \u202f: Modifications r\u00e9centes du logiciel pouvant n\u00e9cessiter que les utilisateurs mettent \u00e0 jour la configuration de leur imprimante. Contact \u202f: Informations sur les rapports d'anomalies et communication g\u00e9n\u00e9rale avec les d\u00e9veloppeurs de Klipper.","title":"Informations g\u00e9n\u00e9rales"},{"location":"Overview.html#installation-et-configuration","text":"Installation \u202f: Guide d'installation de Klipper. R\u00e9f\u00e9rence de la configuration : Description de tous les param\u00e8tres de configuration. Distance de rotation : Calcul du param\u00e8tre rotation_distance du moteur. V\u00e9rifications de la configuration : V\u00e9rification des param\u00e8tres de base des broches du fichier de configuration. Nivelage du lit : Informations sur le \"nivelage du lit\" dans Klipper. Calibration delta : Calibration de la cin\u00e9matique Delta. Calibration de la sonde : Calibration automatique des sondes Z. BL-Touch : Configuration d'une sonde \"BL-Touch\". Nivelage manuel : Calibration des but\u00e9es Z (et similaires). Maillage du lit : Correction de la hauteur du lit bas\u00e9e sur les emplacements XY. Phase de fin de course : Positionnement de la but\u00e9e Z assist\u00e9 par moteur. Axis Twist Compensation : A tool to compensate for inaccurate probe readings due to twist in X gantry. Compensation de la r\u00e9sonance : Un outil permettant de r\u00e9duire la r\u00e9sonance durant les impressions. Mesure des r\u00e9sonances : Informations sur l'utilisation d'un acc\u00e9l\u00e9rom\u00e8tre adxl345 pour mesurer les r\u00e9sonances. Avance \u00e0 la pression : Calibration de la pression dans l'extrudeur. G-Codes : Informations sur les instructions prises en charge par Klipper. Mod\u00e8les de commande : Macros G-Code et \u00e9valuation conditionnelle. R\u00e9f\u00e9rence des \u00e9tats : Informations disponibles pour les macros (et similaires). Pilotes TMC : Utilisation des pilotes de moteurs pas \u00e0 pas Trinamic avec Klipper. Prise origine multi-MCU : Mise \u00e0 l'origine et palpage utilisant plusieurs micro-contr\u00f4leurs. Trancheurs : Configuration d'un logiciel de \"tranchage\" pour Klipper. Correction d'obliquit\u00e9 : Ajustements des axes qui ne sont pas parfaitement d'\u00e9querre. Outils PWM : Guide sur l'utilisation des outils contr\u00f4l\u00e9s par PWM tels que les lasers ou les broches. Exclude Object : Le guide de l'impl\u00e9mentation d'Exclude Objects.","title":"Installation et configuration"},{"location":"Overview.html#documentation-pour-les-developpeurs","text":"Aper\u00e7u du code : Les d\u00e9veloppeurs devraient lire ceci en premier. Cin\u00e9matiques : D\u00e9tails techniques sur la fa\u00e7on dont Klipper met en \u0153uvre les mouvements. Protocole : Informations sur le protocole de messagerie de bas niveau entre l'h\u00f4te et le microcontr\u00f4leur. API du serveur : Informations sur l'API de commande et de contr\u00f4le de Klipper. Commandes MCU : Une description des commandes de bas niveau impl\u00e9ment\u00e9es dans le logiciel du micro-contr\u00f4leur. Protocole du bus CAN : Format de messages du bus CAN de Klipper. D\u00e9bogage : Informations sur la fa\u00e7on de tester et d\u00e9boguer Klipper. Tests de charge : Informations sur la m\u00e9thode de tests de charge de Klipper. Contribuer : Comment proposer des am\u00e9liorations pour Klipper. Packaging : Informations sur la construction de paquets de syst\u00e8me d'exploitation.","title":"Documentation pour les d\u00e9veloppeurs"},{"location":"Overview.html#documents-specifiques-a-certains-appareils","text":"Exemples de configurations : Informations sur l'ajout d'un exemple de fichier de configuration \u00e0 Klipper. Mises \u00e0 jour par carte SD : Flasher le micro-contr\u00f4leur en copiant un binaire sur une carte SD. Raspberry Pi en tant que micro-contr\u00f4leur : D\u00e9tails pour contr\u00f4ler les appareils connect\u00e9s aux broches GPIO d'un Raspberry Pi. Beaglebone : D\u00e9tails pour l'ex\u00e9cution de Klipper sur le SBC Beaglebone. Bootloaders : Informations pour les d\u00e9veloppeurs sur le flashage des microcontr\u00f4leurs. Bootloader Entry : Requesting the bootloader. Bus CAN : Informations sur l'utilisation du bus CAN avec Klipper. CAN bus troubleshooting : Tips for troubleshooting CAN bus. Capteur de largeur de filament TSL1401CL D\u00e9tecteur de largeur de filament \u00e0 effet hall","title":"Documents sp\u00e9cifiques \u00e0 certains appareils"},{"location":"Packaging.html","text":"Packager Klipper \u00b6 Klipper est en quelque sorte comme une anomalie de packaging au sein des programmes Python, car il ne requiert pas d'outils de configuration pour \u00eatre construit et install\u00e9. Quelques notes en ce qui concerne comment package au mieux sont : Modules C \u00b6 Klipper utilise un module en langage C pour g\u00e9rer plus rapidement certains calculs cin\u00e9matiques. Ce module doit \u00eatre compil\u00e9 au moment de l'empaquetage pour \u00e9viter d'introduire une d\u00e9pendance d'ex\u00e9cution sur un compilateur. Pour compiler le module C, ex\u00e9cutez python2 klippy/chelper/__init__.py . Compiler du code python \u00b6 De nombreuses distributions compilent tout le code python avant de l'empaqueter pour am\u00e9liorer le temps de d\u00e9marrage. Vous pouvez le faire en ex\u00e9cutant python2 -m compileall klippy . Versionnage \u00b6 Si vous construisez un paquet de Klipper \u00e0 partir de git, il est d'usage de ne pas envoyer de r\u00e9pertoire .git, donc la gestion des versions doit \u00eatre g\u00e9r\u00e9e sans git. Pour ce faire, utilisez le script fourni dans scripts/make_version.py qui doit \u00eatre ex\u00e9cut\u00e9 comme suit : python2 scripts/make_version.py YOURDISTRONAME > klippy/.version . Exemple de script de pr\u00e9compilation \u00b6 klipper-git est packag\u00e9 pour Arch Linux et poss\u00e8de un PKGBUILD (script de construction de paquet) disponible sur Arch User Repository .","title":"Packager Klipper"},{"location":"Packaging.html#packager-klipper","text":"Klipper est en quelque sorte comme une anomalie de packaging au sein des programmes Python, car il ne requiert pas d'outils de configuration pour \u00eatre construit et install\u00e9. Quelques notes en ce qui concerne comment package au mieux sont :","title":"Packager Klipper"},{"location":"Packaging.html#modules-c","text":"Klipper utilise un module en langage C pour g\u00e9rer plus rapidement certains calculs cin\u00e9matiques. Ce module doit \u00eatre compil\u00e9 au moment de l'empaquetage pour \u00e9viter d'introduire une d\u00e9pendance d'ex\u00e9cution sur un compilateur. Pour compiler le module C, ex\u00e9cutez python2 klippy/chelper/__init__.py .","title":"Modules C"},{"location":"Packaging.html#compiler-du-code-python","text":"De nombreuses distributions compilent tout le code python avant de l'empaqueter pour am\u00e9liorer le temps de d\u00e9marrage. Vous pouvez le faire en ex\u00e9cutant python2 -m compileall klippy .","title":"Compiler du code python"},{"location":"Packaging.html#versionnage","text":"Si vous construisez un paquet de Klipper \u00e0 partir de git, il est d'usage de ne pas envoyer de r\u00e9pertoire .git, donc la gestion des versions doit \u00eatre g\u00e9r\u00e9e sans git. Pour ce faire, utilisez le script fourni dans scripts/make_version.py qui doit \u00eatre ex\u00e9cut\u00e9 comme suit : python2 scripts/make_version.py YOURDISTRONAME > klippy/.version .","title":"Versionnage"},{"location":"Packaging.html#exemple-de-script-de-precompilation","text":"klipper-git est packag\u00e9 pour Arch Linux et poss\u00e8de un PKGBUILD (script de construction de paquet) disponible sur Arch User Repository .","title":"Exemple de script de pr\u00e9compilation"},{"location":"Pressure_Advance.html","text":"Avance \u00e0 la pression \u00b6 Ce document fournit des informations sur les r\u00e9glages de la variable \"pressure advance\" pour une buse et un filament donn\u00e9. La fonctionnalit\u00e9 pressure advance peut aider \u00e0 r\u00e9duire le suintement. Pour plus d'informations sur l'impl\u00e9mentation du pressure advance, vous pouvez lire le document kinematics . R\u00e9glage du pressure advance \u00b6 Pressure advance permet deux choses importantes - r\u00e9duire le suintement pendant les d\u00e9placements sans extrusion et r\u00e9duire les bavures dans les coins. Ce guide utilise la r\u00e9duction des bavures dans les angles comme base de r\u00e9glage. Pour r\u00e9gler le pressure advance, l'imprimante doit \u00eatre configur\u00e9e et en \u00e9tat de marche le test n\u00e9cessitant une impression et une inspection de l'objet imprim\u00e9. Il est conseill\u00e9 de lire ce document en int\u00e9gralit\u00e9 avant de lancer les tests. Utilisez un trancheur pour g\u00e9n\u00e9rer le g-code du grand carr\u00e9 creux disponible dans docs/prints/square_tower.stl . Utilisez un vitesse rapide (ex 100mm/s), pas de remplissage et une hauteur de couche grossi\u00e8re (la hauteur de couche devrait \u00eatre dans les 75% du diam\u00e8tre de la buse). Pensez \u00e0 d\u00e9sactiver toutes les contr\u00f4le d'\"acc\u00e9l\u00e9ration dynamique\" dans le trancheur. Pr\u00e9parez le test en ex\u00e9cutant la commande G-Code suivante : SET_VELOCITY_LIMIT SQUARE_CORNER_VELOCITY=1 ACCEL=500 Cette commande ralentit le d\u00e9placement de la buse dans les angles pour maximiser les effets de la pression de l'extrudeur. Pour les imprimantes munies de direct drive ex\u00e9cutez cette commande : TUNING_TOWER COMMAND=SET_PRESSURE_ADVANCE PARAMETER=ADVANCE START=0 FACTOR=.005 Pour les longs extrudeurs bowden , utilisez : TUNING_TOWER COMMAND=SET_PRESSURE_ADVANCE PARAMETER=ADVANCE START=0 FACTOR=.020 Puis imprimez la pi\u00e8ce. Une fois l'impression termin\u00e9e, l'objet ressemble \u00e0 : La commande TUNING_TOWER ci-dessus demande \u00e0 Klipper de modifier le param\u00e8tre pressure_advance apr\u00e8s chaque couche de l'impression. Les couches sup\u00e9rieures de l'impression auront une valeur de pressure_advance plus \u00e9lev\u00e9e. Les couches en dessous du r\u00e9glage de pressure_advance optimal auront des bavures dans les angles et celles au-dessus du r\u00e9glage id\u00e9ale pourront avoir des coins arrondis ou une mauvaise extrusion dans les angles. Vous pouvez arr\u00eater l'impression si vous observez que les angles ne s'impriment plus correctement. (cela permet d'\u00e9viter d'imprimer les couches qui sont au-dessus de la valeur id\u00e9ale pour le pressure_advance). Inspectez l'impression et utilisez un pied \u00e0 coulisse digital pour trouver la hauteur \u00e0 laquelle les angles sont de bonne qualit\u00e9. En cas de doute, choisissez une hauteur inf\u00e9rieure. La valeur du pressure_advance peut \u00eatre calcul\u00e9e de la mani\u00e8re suivante pressure_advance = <d\u00e9but> + <hauteur_mesur\u00e9e> * <facteur> . (Par exemple, 0 + 12.90 *0 .020 donnera 0.258 .) Il est possible de choisir des valeurs personnalis\u00e9es pour START et FACTOR si cela permet d'identifier le meilleur r\u00e9glage de pressure advance. Si vous utilisez des valeurs personnalis\u00e9es, assurez-vous d'envoyer la commande TUNING_TOWER au d\u00e9but de chaque impression. Les valeurs d\u2019avance de pression moyennes se situent entre 0,050 et 1,000 (le haut de la fourchette est g\u00e9n\u00e9ralement pour les extrudeurs Bowden). S\u2019il n\u2019y a pas d\u2019am\u00e9lioration significative avec une avance de pression jusqu\u2019\u00e0 1.000, il est peu probable que l\u2019avance de pression am\u00e9liore la qualit\u00e9 des impressions. Revenez \u00e0 une configuration par d\u00e9faut avec l\u2019avance de pression d\u00e9sactiv\u00e9e. Bien que cet exercice de r\u00e9glage am\u00e9liore directement la qualit\u00e9 des coins, il convient de rappeler qu\u2019une bonne configuration d\u2019avance de pression r\u00e9duit \u00e9galement le suintement tout au long de l\u2019impression. \u00c0 la fin de ce test, d\u00e9finissez pressure_advance = <calculated_value> dans la section [extruder]` du fichier de configuration et ex\u00e9cutez une commande RESTART. La commande RESTART effacera l\u2019\u00e9tat de test et r\u00e9tablira les param\u00e8tres de vitesse \u00e0 leur valeurs normales. Informations importantes \u00b6 La valeur d\u2019avance de pression d\u00e9pend de l\u2019extrudeur, de la buse et du filament. Il est courant que les filaments de diff\u00e9rents fabricants ou avec diff\u00e9rents pigments n\u00e9cessitent des valeurs d\u2019avance de pression significativement diff\u00e9rentes. Par cons\u00e9quent, il faut calibrer l\u2019avance de pression sur chaque imprimante et avec chaque bobine de filament. La temp\u00e9rature d\u2019impression et les taux d\u2019extrusion peuvent avoir un impact sur l\u2019avancement de la pression. Assurez-vous de r\u00e9gler la rotation_distance de l'extrudeur et temp\u00e9rature de la buse avant de r\u00e9gler l'avance de pression. L\u2019impression de test est con\u00e7ue pour fonctionner avec un d\u00e9bit d\u2019extrudeur \u00e9lev\u00e9, mais avec des r\u00e9glages de trancheur \u00ab normaux \u00bb. Un d\u00e9bit \u00e9lev\u00e9 est obtenu en utilisant une vitesse d\u2019impression \u00e9lev\u00e9e (par exemple, 100 mm/s) et une hauteur de couche grossi\u00e8re (g\u00e9n\u00e9ralement 75% du diam\u00e8tre de la buse). Les autres param\u00e8tres du segment doivent \u00eatre similaires \u00e0 leurs valeurs par d\u00e9faut (par exemple, p\u00e9rim\u00e8tres de 2 ou 3 lignes, distance de r\u00e9traction normale). Il peut \u00eatre utile de d\u00e9finir la vitesse du p\u00e9rim\u00e8tre externe pour qu\u2019elle soit la m\u00eame que le reste de l\u2019impression, mais ce n\u2019est pas une exigence. Il est fr\u00e9quent que l\u2019impression de test montre un comportement diff\u00e9rent \u00e0 chaque coin. Souvent, le trancheur s\u2019arrange pour changer les couches dans un coin, ce qui peut entra\u00eener une diff\u00e9rence significative entre ce coin et les trois coins restants. Si cela se produit, ignorez ce coin et r\u00e9glez l\u2019avance de pression en utilisant les trois autres coins. Il est \u00e9galement courant que les coins restants varient l\u00e9g\u00e8rement. (Cela peut se produire en raison de petites diff\u00e9rences dans la fa\u00e7on dont le cadre de l\u2019imprimante r\u00e9agit aux virages dans certaines directions.) Essayez de choisir une valeur qui fonctionne bien pour tous les coins restants. En cas de doute, pr\u00e9f\u00e9rez une valeur d\u2019avance de pression inf\u00e9rieure. Si une valeur d'avance de pression \u00e9lev\u00e9e (par exemple sup\u00e9rieure \u00e0 0,200) est utilis\u00e9e, il est possible que l'extrudeur saute lors du retour \u00e0 l'acc\u00e9l\u00e9ration normale de l'imprimante. Le syst\u00e8me d'avance de pression tient compte de la pression en poussant un peu plus de filament pendant l'acc\u00e9l\u00e9ration et en r\u00e9tractant ce filament pendant la d\u00e9c\u00e9l\u00e9ration. Avec une acc\u00e9l\u00e9ration \u00e9lev\u00e9e et une avance \u00e0 haute pression, l'extrudeur peut ne pas avoir assez de couple pour pousser la quantit\u00e9 de filament requise. Si cela se produit, utilisez une valeur d'acc\u00e9l\u00e9ration inf\u00e9rieure ou d\u00e9sactivez l'avance de pression. Une fois que l'avance de pression est r\u00e9gl\u00e9e dans Klipper, il peut toujours \u00eatre utile de configurer une petite valeur de r\u00e9traction dans le trancheur (par exemple, 0,75 mm) et d'utiliser l'option \"essuyer lors de la r\u00e9traction\" du trancheur si elle est disponible. Ces r\u00e9glages du trancheur peuvent aider \u00e0 contrecarrer le suintement caus\u00e9 par la coh\u00e9sion du filament (filament retir\u00e9 de la buse en raison de l'adh\u00e9rence du plastique). Il est recommand\u00e9 de d\u00e9sactiver l'option \"relever le Z lors de la r\u00e9traction\" du trancheur. Le syst\u00e8me d'avance de pression ne modifie pas la synchronisation ou la trajectoire de la t\u00eate. Une impression avec l'avance de pression activ\u00e9e prendra le m\u00eame temps qu'une impression sans avance de pression. L'avance de pression ne modifie pas non plus la quantit\u00e9 totale de filament extrud\u00e9 lors d'une impression. L'avance de pression entra\u00eene un mouvement suppl\u00e9mentaire de l'extrudeur pendant l'acc\u00e9l\u00e9ration et la d\u00e9c\u00e9l\u00e9ration du mouvement. Un r\u00e9glage d'avance de pression tr\u00e8s \u00e9lev\u00e9 entra\u00eenera une tr\u00e8s grande quantit\u00e9 de mouvement de l'extrudeur pendant l'acc\u00e9l\u00e9ration et la d\u00e9c\u00e9l\u00e9ration, et aucun r\u00e9glage de configuration ne limite la quantit\u00e9 de ce mouvement.","title":"Avance \u00e0 la pression"},{"location":"Pressure_Advance.html#avance-a-la-pression","text":"Ce document fournit des informations sur les r\u00e9glages de la variable \"pressure advance\" pour une buse et un filament donn\u00e9. La fonctionnalit\u00e9 pressure advance peut aider \u00e0 r\u00e9duire le suintement. Pour plus d'informations sur l'impl\u00e9mentation du pressure advance, vous pouvez lire le document kinematics .","title":"Avance \u00e0 la pression"},{"location":"Pressure_Advance.html#reglage-du-pressure-advance","text":"Pressure advance permet deux choses importantes - r\u00e9duire le suintement pendant les d\u00e9placements sans extrusion et r\u00e9duire les bavures dans les coins. Ce guide utilise la r\u00e9duction des bavures dans les angles comme base de r\u00e9glage. Pour r\u00e9gler le pressure advance, l'imprimante doit \u00eatre configur\u00e9e et en \u00e9tat de marche le test n\u00e9cessitant une impression et une inspection de l'objet imprim\u00e9. Il est conseill\u00e9 de lire ce document en int\u00e9gralit\u00e9 avant de lancer les tests. Utilisez un trancheur pour g\u00e9n\u00e9rer le g-code du grand carr\u00e9 creux disponible dans docs/prints/square_tower.stl . Utilisez un vitesse rapide (ex 100mm/s), pas de remplissage et une hauteur de couche grossi\u00e8re (la hauteur de couche devrait \u00eatre dans les 75% du diam\u00e8tre de la buse). Pensez \u00e0 d\u00e9sactiver toutes les contr\u00f4le d'\"acc\u00e9l\u00e9ration dynamique\" dans le trancheur. Pr\u00e9parez le test en ex\u00e9cutant la commande G-Code suivante : SET_VELOCITY_LIMIT SQUARE_CORNER_VELOCITY=1 ACCEL=500 Cette commande ralentit le d\u00e9placement de la buse dans les angles pour maximiser les effets de la pression de l'extrudeur. Pour les imprimantes munies de direct drive ex\u00e9cutez cette commande : TUNING_TOWER COMMAND=SET_PRESSURE_ADVANCE PARAMETER=ADVANCE START=0 FACTOR=.005 Pour les longs extrudeurs bowden , utilisez : TUNING_TOWER COMMAND=SET_PRESSURE_ADVANCE PARAMETER=ADVANCE START=0 FACTOR=.020 Puis imprimez la pi\u00e8ce. Une fois l'impression termin\u00e9e, l'objet ressemble \u00e0 : La commande TUNING_TOWER ci-dessus demande \u00e0 Klipper de modifier le param\u00e8tre pressure_advance apr\u00e8s chaque couche de l'impression. Les couches sup\u00e9rieures de l'impression auront une valeur de pressure_advance plus \u00e9lev\u00e9e. Les couches en dessous du r\u00e9glage de pressure_advance optimal auront des bavures dans les angles et celles au-dessus du r\u00e9glage id\u00e9ale pourront avoir des coins arrondis ou une mauvaise extrusion dans les angles. Vous pouvez arr\u00eater l'impression si vous observez que les angles ne s'impriment plus correctement. (cela permet d'\u00e9viter d'imprimer les couches qui sont au-dessus de la valeur id\u00e9ale pour le pressure_advance). Inspectez l'impression et utilisez un pied \u00e0 coulisse digital pour trouver la hauteur \u00e0 laquelle les angles sont de bonne qualit\u00e9. En cas de doute, choisissez une hauteur inf\u00e9rieure. La valeur du pressure_advance peut \u00eatre calcul\u00e9e de la mani\u00e8re suivante pressure_advance = <d\u00e9but> + <hauteur_mesur\u00e9e> * <facteur> . (Par exemple, 0 + 12.90 *0 .020 donnera 0.258 .) Il est possible de choisir des valeurs personnalis\u00e9es pour START et FACTOR si cela permet d'identifier le meilleur r\u00e9glage de pressure advance. Si vous utilisez des valeurs personnalis\u00e9es, assurez-vous d'envoyer la commande TUNING_TOWER au d\u00e9but de chaque impression. Les valeurs d\u2019avance de pression moyennes se situent entre 0,050 et 1,000 (le haut de la fourchette est g\u00e9n\u00e9ralement pour les extrudeurs Bowden). S\u2019il n\u2019y a pas d\u2019am\u00e9lioration significative avec une avance de pression jusqu\u2019\u00e0 1.000, il est peu probable que l\u2019avance de pression am\u00e9liore la qualit\u00e9 des impressions. Revenez \u00e0 une configuration par d\u00e9faut avec l\u2019avance de pression d\u00e9sactiv\u00e9e. Bien que cet exercice de r\u00e9glage am\u00e9liore directement la qualit\u00e9 des coins, il convient de rappeler qu\u2019une bonne configuration d\u2019avance de pression r\u00e9duit \u00e9galement le suintement tout au long de l\u2019impression. \u00c0 la fin de ce test, d\u00e9finissez pressure_advance = <calculated_value> dans la section [extruder]` du fichier de configuration et ex\u00e9cutez une commande RESTART. La commande RESTART effacera l\u2019\u00e9tat de test et r\u00e9tablira les param\u00e8tres de vitesse \u00e0 leur valeurs normales.","title":"R\u00e9glage du pressure advance"},{"location":"Pressure_Advance.html#informations-importantes","text":"La valeur d\u2019avance de pression d\u00e9pend de l\u2019extrudeur, de la buse et du filament. Il est courant que les filaments de diff\u00e9rents fabricants ou avec diff\u00e9rents pigments n\u00e9cessitent des valeurs d\u2019avance de pression significativement diff\u00e9rentes. Par cons\u00e9quent, il faut calibrer l\u2019avance de pression sur chaque imprimante et avec chaque bobine de filament. La temp\u00e9rature d\u2019impression et les taux d\u2019extrusion peuvent avoir un impact sur l\u2019avancement de la pression. Assurez-vous de r\u00e9gler la rotation_distance de l'extrudeur et temp\u00e9rature de la buse avant de r\u00e9gler l'avance de pression. L\u2019impression de test est con\u00e7ue pour fonctionner avec un d\u00e9bit d\u2019extrudeur \u00e9lev\u00e9, mais avec des r\u00e9glages de trancheur \u00ab normaux \u00bb. Un d\u00e9bit \u00e9lev\u00e9 est obtenu en utilisant une vitesse d\u2019impression \u00e9lev\u00e9e (par exemple, 100 mm/s) et une hauteur de couche grossi\u00e8re (g\u00e9n\u00e9ralement 75% du diam\u00e8tre de la buse). Les autres param\u00e8tres du segment doivent \u00eatre similaires \u00e0 leurs valeurs par d\u00e9faut (par exemple, p\u00e9rim\u00e8tres de 2 ou 3 lignes, distance de r\u00e9traction normale). Il peut \u00eatre utile de d\u00e9finir la vitesse du p\u00e9rim\u00e8tre externe pour qu\u2019elle soit la m\u00eame que le reste de l\u2019impression, mais ce n\u2019est pas une exigence. Il est fr\u00e9quent que l\u2019impression de test montre un comportement diff\u00e9rent \u00e0 chaque coin. Souvent, le trancheur s\u2019arrange pour changer les couches dans un coin, ce qui peut entra\u00eener une diff\u00e9rence significative entre ce coin et les trois coins restants. Si cela se produit, ignorez ce coin et r\u00e9glez l\u2019avance de pression en utilisant les trois autres coins. Il est \u00e9galement courant que les coins restants varient l\u00e9g\u00e8rement. (Cela peut se produire en raison de petites diff\u00e9rences dans la fa\u00e7on dont le cadre de l\u2019imprimante r\u00e9agit aux virages dans certaines directions.) Essayez de choisir une valeur qui fonctionne bien pour tous les coins restants. En cas de doute, pr\u00e9f\u00e9rez une valeur d\u2019avance de pression inf\u00e9rieure. Si une valeur d'avance de pression \u00e9lev\u00e9e (par exemple sup\u00e9rieure \u00e0 0,200) est utilis\u00e9e, il est possible que l'extrudeur saute lors du retour \u00e0 l'acc\u00e9l\u00e9ration normale de l'imprimante. Le syst\u00e8me d'avance de pression tient compte de la pression en poussant un peu plus de filament pendant l'acc\u00e9l\u00e9ration et en r\u00e9tractant ce filament pendant la d\u00e9c\u00e9l\u00e9ration. Avec une acc\u00e9l\u00e9ration \u00e9lev\u00e9e et une avance \u00e0 haute pression, l'extrudeur peut ne pas avoir assez de couple pour pousser la quantit\u00e9 de filament requise. Si cela se produit, utilisez une valeur d'acc\u00e9l\u00e9ration inf\u00e9rieure ou d\u00e9sactivez l'avance de pression. Une fois que l'avance de pression est r\u00e9gl\u00e9e dans Klipper, il peut toujours \u00eatre utile de configurer une petite valeur de r\u00e9traction dans le trancheur (par exemple, 0,75 mm) et d'utiliser l'option \"essuyer lors de la r\u00e9traction\" du trancheur si elle est disponible. Ces r\u00e9glages du trancheur peuvent aider \u00e0 contrecarrer le suintement caus\u00e9 par la coh\u00e9sion du filament (filament retir\u00e9 de la buse en raison de l'adh\u00e9rence du plastique). Il est recommand\u00e9 de d\u00e9sactiver l'option \"relever le Z lors de la r\u00e9traction\" du trancheur. Le syst\u00e8me d'avance de pression ne modifie pas la synchronisation ou la trajectoire de la t\u00eate. Une impression avec l'avance de pression activ\u00e9e prendra le m\u00eame temps qu'une impression sans avance de pression. L'avance de pression ne modifie pas non plus la quantit\u00e9 totale de filament extrud\u00e9 lors d'une impression. L'avance de pression entra\u00eene un mouvement suppl\u00e9mentaire de l'extrudeur pendant l'acc\u00e9l\u00e9ration et la d\u00e9c\u00e9l\u00e9ration du mouvement. Un r\u00e9glage d'avance de pression tr\u00e8s \u00e9lev\u00e9 entra\u00eenera une tr\u00e8s grande quantit\u00e9 de mouvement de l'extrudeur pendant l'acc\u00e9l\u00e9ration et la d\u00e9c\u00e9l\u00e9ration, et aucun r\u00e9glage de configuration ne limite la quantit\u00e9 de ce mouvement.","title":"Informations importantes"},{"location":"Probe_Calibrate.html","text":"\u00c9talonnage de la sonde \u00b6 Ce document d\u00e9crit la m\u00e9thode de r\u00e9glage des d\u00e9calages X, Y et Z d'une \"sonde z automatique\" dans Klipper. Ceci est utile pour les utilisateurs qui ont une section [probe] ou [bltouch] dans leur fichier de configuration. \u00c9talonnage des d\u00e9calages X et Y de la sonde \u00b6 Pour calibrer le d\u00e9calage X et Y, acc\u00e9dez \u00e0 l'onglet \"Contr\u00f4le\" d'OctoPrint, placez l'imprimante \u00e0 l'origine, puis utilisez les fl\u00e8ches de d\u00e9placement pour amener la t\u00eate vers une position proche du centre du lit. Placez un morceau de ruban adh\u00e9sif bleu (ou similaire) sur le lit sous la sonde. Acc\u00e9dez \u00e0 l'onglet \"Terminal\" d'OctoPrint et lancez une commande PROBE : SONDE Placez une marque sur le ruban directement sous l'endroit o\u00f9 se trouve la sonde (ou utilisez une m\u00e9thode similaire pour noter l'emplacement sur le lit). Ex\u00e9cutez une commande GET_POSITION et enregistrez l'emplacement XY de la t\u00eate d'outil signal\u00e9 par cette commande. Par exemple si l'on voit : Recv: // toolhead: X:46.500000 Y:27.000000 Z:15.000000 E:0.000000 La position d l a sonde serait de 46,5 en X et de 27 en Y. Apr\u00e8s avoir enregistr\u00e9 la position de la sonde, lancez une s\u00e9rie de commandes G1 jusqu'\u00e0 ce que la buse soit directement au-dessus de la marque sur le lit. Par exemple, on pourrait lancer : G1 F300 X57 Y30 Z15 pour d\u00e9placer la buse vers une position X de 57 et Y de 30. Une fois que l'on a trouv\u00e9 la position directement au-dessus de la marque, utilisez la commande GET_POSITION pour afficher cette position. C'est la position de la buse. Le x_offset est alors la nozzle_x_position - probe_x_position et y_offset est de m\u00eame la nozzle_y_position - probe_y_position . Mettez \u00e0 jour le fichier printer.cfg avec les valeurs donn\u00e9es, retirez la bande/les marques du lit, puis \u00e9mettez une commande RESTART afin que les nouvelles valeurs prennent effet. \u00c9talonnage de l'offset Z de la sonde \u00b6 Avoir un z offset pr\u00e9cis est essentiel pour obtenir des impressions de haute qualit\u00e9. Le z_offset est la distance entre la buse et le lit lorsque la sonde se d\u00e9clenche. L'outil Klipper PROBE_CALIBRATE peut \u00eatre utilis\u00e9 pour obtenir cette valeur - il ex\u00e9cutera un sondage automatique pour mesurer la position de d\u00e9clenchement Z de la sonde, puis d\u00e9marrera un sondage manuel pour obtenir la hauteur Z de la buse. Le z_offset sera alors calcul\u00e9e \u00e0 partir de ces mesures. Commencez par mettre l'imprimante \u00e0 l'origine, puis d\u00e9placez la t\u00eate vers une position proche du centre du lit. Acc\u00e9dez \u00e0 l'onglet du terminal OctoPrint et ex\u00e9cutez la commande PROBE_CALIBRATE pour d\u00e9marrer l'outil. Cet outil effectuera un sondage automatique, puis soul\u00e8vera la t\u00eate, d\u00e9placera la buse sur l'emplacement du point de sonde et d\u00e9marrera l'outil de sondage manuel. Si la buse ne se d\u00e9place pas vers une position au-dessus du point de sonde automatique, tapez ABORT pour annuler le sondage manuel et effectuez l'\u00e9talonnage de d\u00e9calage de sonde XY d\u00e9crit ci-dessus. Une fois que l'outil de sondage manuel d\u00e9marre, suivez les \u00e9tapes d\u00e9crites dans \"le test du papier\" ) pour d\u00e9terminer la distance r\u00e9elle entre la buse et le lit \u00e0 l'emplacement donn\u00e9. Une fois ces \u00e9tapes termin\u00e9es, vous pouvez taper ACCEPT pour enregistrer les r\u00e9sultats dans le fichier de configuration avec : SAVE_CONFIG Notez que si une modification est apport\u00e9e au syst\u00e8me de mouvement de l'imprimante, \u00e0 la position de la hotend ou \u00e0 l'emplacement de la sonde, cela invalidera les r\u00e9sultats de PROBE_CALIBRATE. Si la sonde a un d\u00e9calage X ou Y et que l'inclinaison du lit est modifi\u00e9e (par exemple, en ajustant les vis du lit, en ex\u00e9cutant DELTA_CALIBRATE, en ex\u00e9cutant Z_TILT_ADJUST, en ex\u00e9cutant QUAD_GANTRY_LEVEL, ou similaire), les r\u00e9sultats de PROBE_CALIBRATE seront invalid\u00e9s. Apr\u00e8s avoir effectu\u00e9 l'un des ajustements ci-dessus, il sera n\u00e9cessaire d'ex\u00e9cuter \u00e0 nouveau PROBE_CALIBRATE. Si les r\u00e9sultats de PROBE_CALIBRATE sont invalid\u00e9s, tous les r\u00e9sultats pr\u00e9c\u00e9dents bed mesh qui ont \u00e9t\u00e9 obtenus \u00e0 l'aide de la sonde sont \u00e9galement invalid\u00e9s - il sera n\u00e9cessaire de r\u00e9ex\u00e9cuter BED_MESH_CALIBRATE apr\u00e8s avoir recalibr\u00e9 la sonde. Contr\u00f4le de r\u00e9p\u00e9tabilit\u00e9 \u00b6 Apr\u00e8s avoir calibr\u00e9 les d\u00e9calages X, Y et Z de la sonde, il est conseill\u00e9 de v\u00e9rifier que la sonde fournit des r\u00e9sultats reproductibles. Commencez par mettre l'imprimante \u00e0 l'origine, puis d\u00e9placez la t\u00eate vers une position proche du centre du lit. Acc\u00e9dez \u00e0 l'onglet du terminal OctoPrint et ex\u00e9cutez la commande PROBE_ACCURACY . Cette commande ex\u00e9cutera le sondage dix fois et produira une sortie semblable \u00e0 la suivante : Recv: // probe accuracy: at X:0.000 Y:0.000 Z:10.000 Recv: // and read 10 times with speed of 5 mm/s Recv: // probe at -0.003,0.005 is z=2.506948 Recv: // probe at -0.003,0.005 is z=2.519448 Recv: // probe at -0.003,0.005 is z=2.519448 Recv: // probe at -0.003,0.005 is z=2.506948 Recv: // probe at -0.003,0.005 is z=2.519448 Recv: // probe at -0.003,0.005 is z=2.519448 Recv: // probe at -0.003,0.005 is z=2.506948 Recv: // probe at -0.003,0.005 is z=2.506948 Recv: // probe at -0.003,0.005 is z=2.519448 Recv: // probe at -0.003,0.005 is z=2.506948 Recv: // probe accuracy results: maximum 2.519448, minimum 2.506948, range 0.012500, average 2.513198, median 2.513198, standard deviation 0.006250 Id\u00e9alement, l'outil rapportera une valeur maximale et minimale identique. (C'est-\u00e0-dire que, id\u00e9alement, la sonde obtient un r\u00e9sultat identique sur les dix sondes.) Cependant, il est normal que les valeurs minimale et maximale diff\u00e8rent d'une \"distance de pas\" Z ou jusqu'\u00e0 5 microns (0,005 mm). Une \"distance de pas\" est distance_rotation/(full_steps_per_rotation*microsteps) . La distance entre la valeur minimale et la valeur maximale s'appelle la plage. Ainsi, dans l'exemple ci-dessus, \u00e9tant donn\u00e9 que l'imprimante utilise une distance de pas Z de 0,0125, une plage de 0,012500 serait consid\u00e9r\u00e9e comme normale. Si les r\u00e9sultats du test indiquent une plage de valeur sup\u00e9rieure \u00e0 25 microns (0,025 mm), la sonde n'a pas une pr\u00e9cision suffisante pour les proc\u00e9dures de nivellement de lit typiques. Il peut \u00eatre possible de r\u00e9gler la vitesse de la sonde et/ou la hauteur de d\u00e9part de la sonde pour am\u00e9liorer la r\u00e9p\u00e9tabilit\u00e9 de la sonde. La commande PROBE_ACCURACY permet d'ex\u00e9cuter des tests avec diff\u00e9rents param\u00e8tres pour voir leur impact - voir le document G-Codes pour plus de d\u00e9tails. Si la sonde obtient g\u00e9n\u00e9ralement des r\u00e9sultats reproductibles mais pr\u00e9sente une valeur aberrante occasionnelle, il peut \u00eatre possible d'en tenir compte en utilisant plusieurs \u00e9chantillons sur chaque sonde - lisez la description des param\u00e8tres de configuration de la sonde samples dans la r\u00e9f\u00e9rence de configuration pour plus de d\u00e9tails. Si une nouvelle vitesse de sondage, un nouveau nombre d'\u00e9chantillons ou d'autres param\u00e8tres sont n\u00e9cessaires, mettez \u00e0 jour le fichier printer.cfg et lancez une commande RESTART . Si c'est le cas, c'est une bonne id\u00e9e de calibrer le z_offset \u00e0 nouveau. Si des r\u00e9sultats reproductibles ne peuvent pas \u00eatre obtenus, n'utilisez pas la sonde pour le nivellement du lit. Klipper dispose de plusieurs outils de sondage manuels qui peuvent \u00eatre utilis\u00e9s \u00e0 la place - voir le Mise \u00e0 niveau du lit pour plus de d\u00e9tails. V\u00e9rification des erreurs de localisation \u00b6 Certaines sondes peuvent avoir une erreur syst\u00e9mique qui corrompt les r\u00e9sultats de la sonde \u00e0 certains emplacements de la t\u00eate d'outil. Par exemple, si le support de la sonde s'incline l\u00e9g\u00e8rement lorsqu'il se d\u00e9place le long de l'axe Y, la sonde peut alors signaler des r\u00e9sultats fauss\u00e9s \u00e0 diff\u00e9rentes positions Y. Il s'agit d'un probl\u00e8me courant avec les sondes sur les imprimantes delta, mais il peut se produire sur toutes les imprimantes. On peut v\u00e9rifier une erreur d'emplacement en utilisant la commande PROBE_CALIBRATE pour mesurer le d\u00e9calage z_offset de la sonde \u00e0 divers emplacements X et Y. Id\u00e9alement, le z_offset serait une valeur constante \u00e0 chaque emplacement d'imprimante. Pour les imprimantes delta, essayez de mesurer le z_offset \u00e0 une position proche de la tour A, \u00e0 une position proche de la tour B et \u00e0 une position proche de la tour C. Pour les imprimantes cart\u00e9siennes, corexy et similaires, essayez de mesurer le z_offset \u00e0 des positions proches des quatre coins du lit. Avant de commencer ce test, calibrez d'abord les d\u00e9calages X, Y et Z de la sonde comme d\u00e9crit au d\u00e9but de ce document. Remettez ensuite l'imprimante \u00e0 l'origine et naviguez jusqu'\u00e0 la premi\u00e8re position XY. Suivez les \u00e9tapes de calibrer le d\u00e9calage en Z de la sonde en ex\u00e9cutant la commande PROBE_CALIBRATE , les commandes TESTZ et la commande ACCEPT . , mais n'ex\u00e9cutez pas SAVE_CONFIG . Notez le rapport z_offset trouv\u00e9. Naviguez ensuite vers les autres positions XY, r\u00e9p\u00e9tez ces \u00e9tapes PROBE_CALIBRATE et notez le d\u00e9calage z signal\u00e9. Si la diff\u00e9rence entre le d\u00e9calage z_offset minimum signal\u00e9 et le d\u00e9calage z_maximum signal\u00e9 est sup\u00e9rieure \u00e0 25 microns (0,025 mm), la sonde n'est pas adapt\u00e9e aux proc\u00e9dures de nivellement de lit typiques. Voir le document mise \u00e0 niveau du lit pour les alternatives de sonde manuelle. Erreurs de temp\u00e9rature \u00b6 De nombreuses sondes ont une erreur syst\u00e9mique lorsqu'elles sondent \u00e0 diff\u00e9rentes temp\u00e9ratures. Par exemple, la sonde peut se d\u00e9clencher syst\u00e9matiquement \u00e0 une hauteur inf\u00e9rieure lorsque la sonde est \u00e0 une temp\u00e9rature plus \u00e9lev\u00e9e. Il est recommand\u00e9 de faire fonctionner les outils de nivellement du lit \u00e0 une temp\u00e9rature constante pour tenir compte de cette erreur. Par exemple, ex\u00e9cutez toujours les outils lorsque l'imprimante est \u00e0 temp\u00e9rature ambiante ou ex\u00e9cutez toujours les outils une fois que l'imprimante a obtenu une temp\u00e9rature d'impression constante. Dans les deux cas, c'est une bonne id\u00e9e d'attendre plusieurs minutes apr\u00e8s que la temp\u00e9rature souhait\u00e9e est atteinte, de sorte que l'appareil d'impression soit constamment \u00e0 la temp\u00e9rature souhait\u00e9e. Pour v\u00e9rifier une erreur de temp\u00e9rature, commencez avec l'imprimante \u00e0 temp\u00e9rature ambiante, puis mettez l'imprimante \u00e0 l'origine, d\u00e9placez la t\u00eate vers une position proche du centre du lit et ex\u00e9cutez la commande PROBE_ACCURACY . Notez les r\u00e9sultats. Ensuite, sans mise \u00e0 l'origine ou d\u00e9sactiver les moteurs pas \u00e0 pas, chauffez la buse et le lit de l'imprimante \u00e0 la temp\u00e9rature d'impression, puis ex\u00e9cutez \u00e0 nouveau la commande PROBE_ACCURACY . Id\u00e9alement, la commande rapportera des r\u00e9sultats identiques. Comme ci-dessus, si la sonde a un d\u00e9calage en temp\u00e9rature, veillez \u00e0 toujours utiliser la sonde \u00e0 une temp\u00e9rature constante.","title":"\u00c9talonnage de la sonde"},{"location":"Probe_Calibrate.html#etalonnage-de-la-sonde","text":"Ce document d\u00e9crit la m\u00e9thode de r\u00e9glage des d\u00e9calages X, Y et Z d'une \"sonde z automatique\" dans Klipper. Ceci est utile pour les utilisateurs qui ont une section [probe] ou [bltouch] dans leur fichier de configuration.","title":"\u00c9talonnage de la sonde"},{"location":"Probe_Calibrate.html#etalonnage-des-decalages-x-et-y-de-la-sonde","text":"Pour calibrer le d\u00e9calage X et Y, acc\u00e9dez \u00e0 l'onglet \"Contr\u00f4le\" d'OctoPrint, placez l'imprimante \u00e0 l'origine, puis utilisez les fl\u00e8ches de d\u00e9placement pour amener la t\u00eate vers une position proche du centre du lit. Placez un morceau de ruban adh\u00e9sif bleu (ou similaire) sur le lit sous la sonde. Acc\u00e9dez \u00e0 l'onglet \"Terminal\" d'OctoPrint et lancez une commande PROBE : SONDE Placez une marque sur le ruban directement sous l'endroit o\u00f9 se trouve la sonde (ou utilisez une m\u00e9thode similaire pour noter l'emplacement sur le lit). Ex\u00e9cutez une commande GET_POSITION et enregistrez l'emplacement XY de la t\u00eate d'outil signal\u00e9 par cette commande. Par exemple si l'on voit : Recv: // toolhead: X:46.500000 Y:27.000000 Z:15.000000 E:0.000000 La position d l a sonde serait de 46,5 en X et de 27 en Y. Apr\u00e8s avoir enregistr\u00e9 la position de la sonde, lancez une s\u00e9rie de commandes G1 jusqu'\u00e0 ce que la buse soit directement au-dessus de la marque sur le lit. Par exemple, on pourrait lancer : G1 F300 X57 Y30 Z15 pour d\u00e9placer la buse vers une position X de 57 et Y de 30. Une fois que l'on a trouv\u00e9 la position directement au-dessus de la marque, utilisez la commande GET_POSITION pour afficher cette position. C'est la position de la buse. Le x_offset est alors la nozzle_x_position - probe_x_position et y_offset est de m\u00eame la nozzle_y_position - probe_y_position . Mettez \u00e0 jour le fichier printer.cfg avec les valeurs donn\u00e9es, retirez la bande/les marques du lit, puis \u00e9mettez une commande RESTART afin que les nouvelles valeurs prennent effet.","title":"\u00c9talonnage des d\u00e9calages X et Y de la sonde"},{"location":"Probe_Calibrate.html#etalonnage-de-loffset-z-de-la-sonde","text":"Avoir un z offset pr\u00e9cis est essentiel pour obtenir des impressions de haute qualit\u00e9. Le z_offset est la distance entre la buse et le lit lorsque la sonde se d\u00e9clenche. L'outil Klipper PROBE_CALIBRATE peut \u00eatre utilis\u00e9 pour obtenir cette valeur - il ex\u00e9cutera un sondage automatique pour mesurer la position de d\u00e9clenchement Z de la sonde, puis d\u00e9marrera un sondage manuel pour obtenir la hauteur Z de la buse. Le z_offset sera alors calcul\u00e9e \u00e0 partir de ces mesures. Commencez par mettre l'imprimante \u00e0 l'origine, puis d\u00e9placez la t\u00eate vers une position proche du centre du lit. Acc\u00e9dez \u00e0 l'onglet du terminal OctoPrint et ex\u00e9cutez la commande PROBE_CALIBRATE pour d\u00e9marrer l'outil. Cet outil effectuera un sondage automatique, puis soul\u00e8vera la t\u00eate, d\u00e9placera la buse sur l'emplacement du point de sonde et d\u00e9marrera l'outil de sondage manuel. Si la buse ne se d\u00e9place pas vers une position au-dessus du point de sonde automatique, tapez ABORT pour annuler le sondage manuel et effectuez l'\u00e9talonnage de d\u00e9calage de sonde XY d\u00e9crit ci-dessus. Une fois que l'outil de sondage manuel d\u00e9marre, suivez les \u00e9tapes d\u00e9crites dans \"le test du papier\" ) pour d\u00e9terminer la distance r\u00e9elle entre la buse et le lit \u00e0 l'emplacement donn\u00e9. Une fois ces \u00e9tapes termin\u00e9es, vous pouvez taper ACCEPT pour enregistrer les r\u00e9sultats dans le fichier de configuration avec : SAVE_CONFIG Notez que si une modification est apport\u00e9e au syst\u00e8me de mouvement de l'imprimante, \u00e0 la position de la hotend ou \u00e0 l'emplacement de la sonde, cela invalidera les r\u00e9sultats de PROBE_CALIBRATE. Si la sonde a un d\u00e9calage X ou Y et que l'inclinaison du lit est modifi\u00e9e (par exemple, en ajustant les vis du lit, en ex\u00e9cutant DELTA_CALIBRATE, en ex\u00e9cutant Z_TILT_ADJUST, en ex\u00e9cutant QUAD_GANTRY_LEVEL, ou similaire), les r\u00e9sultats de PROBE_CALIBRATE seront invalid\u00e9s. Apr\u00e8s avoir effectu\u00e9 l'un des ajustements ci-dessus, il sera n\u00e9cessaire d'ex\u00e9cuter \u00e0 nouveau PROBE_CALIBRATE. Si les r\u00e9sultats de PROBE_CALIBRATE sont invalid\u00e9s, tous les r\u00e9sultats pr\u00e9c\u00e9dents bed mesh qui ont \u00e9t\u00e9 obtenus \u00e0 l'aide de la sonde sont \u00e9galement invalid\u00e9s - il sera n\u00e9cessaire de r\u00e9ex\u00e9cuter BED_MESH_CALIBRATE apr\u00e8s avoir recalibr\u00e9 la sonde.","title":"\u00c9talonnage de l'offset Z de la sonde"},{"location":"Probe_Calibrate.html#controle-de-repetabilite","text":"Apr\u00e8s avoir calibr\u00e9 les d\u00e9calages X, Y et Z de la sonde, il est conseill\u00e9 de v\u00e9rifier que la sonde fournit des r\u00e9sultats reproductibles. Commencez par mettre l'imprimante \u00e0 l'origine, puis d\u00e9placez la t\u00eate vers une position proche du centre du lit. Acc\u00e9dez \u00e0 l'onglet du terminal OctoPrint et ex\u00e9cutez la commande PROBE_ACCURACY . Cette commande ex\u00e9cutera le sondage dix fois et produira une sortie semblable \u00e0 la suivante : Recv: // probe accuracy: at X:0.000 Y:0.000 Z:10.000 Recv: // and read 10 times with speed of 5 mm/s Recv: // probe at -0.003,0.005 is z=2.506948 Recv: // probe at -0.003,0.005 is z=2.519448 Recv: // probe at -0.003,0.005 is z=2.519448 Recv: // probe at -0.003,0.005 is z=2.506948 Recv: // probe at -0.003,0.005 is z=2.519448 Recv: // probe at -0.003,0.005 is z=2.519448 Recv: // probe at -0.003,0.005 is z=2.506948 Recv: // probe at -0.003,0.005 is z=2.506948 Recv: // probe at -0.003,0.005 is z=2.519448 Recv: // probe at -0.003,0.005 is z=2.506948 Recv: // probe accuracy results: maximum 2.519448, minimum 2.506948, range 0.012500, average 2.513198, median 2.513198, standard deviation 0.006250 Id\u00e9alement, l'outil rapportera une valeur maximale et minimale identique. (C'est-\u00e0-dire que, id\u00e9alement, la sonde obtient un r\u00e9sultat identique sur les dix sondes.) Cependant, il est normal que les valeurs minimale et maximale diff\u00e8rent d'une \"distance de pas\" Z ou jusqu'\u00e0 5 microns (0,005 mm). Une \"distance de pas\" est distance_rotation/(full_steps_per_rotation*microsteps) . La distance entre la valeur minimale et la valeur maximale s'appelle la plage. Ainsi, dans l'exemple ci-dessus, \u00e9tant donn\u00e9 que l'imprimante utilise une distance de pas Z de 0,0125, une plage de 0,012500 serait consid\u00e9r\u00e9e comme normale. Si les r\u00e9sultats du test indiquent une plage de valeur sup\u00e9rieure \u00e0 25 microns (0,025 mm), la sonde n'a pas une pr\u00e9cision suffisante pour les proc\u00e9dures de nivellement de lit typiques. Il peut \u00eatre possible de r\u00e9gler la vitesse de la sonde et/ou la hauteur de d\u00e9part de la sonde pour am\u00e9liorer la r\u00e9p\u00e9tabilit\u00e9 de la sonde. La commande PROBE_ACCURACY permet d'ex\u00e9cuter des tests avec diff\u00e9rents param\u00e8tres pour voir leur impact - voir le document G-Codes pour plus de d\u00e9tails. Si la sonde obtient g\u00e9n\u00e9ralement des r\u00e9sultats reproductibles mais pr\u00e9sente une valeur aberrante occasionnelle, il peut \u00eatre possible d'en tenir compte en utilisant plusieurs \u00e9chantillons sur chaque sonde - lisez la description des param\u00e8tres de configuration de la sonde samples dans la r\u00e9f\u00e9rence de configuration pour plus de d\u00e9tails. Si une nouvelle vitesse de sondage, un nouveau nombre d'\u00e9chantillons ou d'autres param\u00e8tres sont n\u00e9cessaires, mettez \u00e0 jour le fichier printer.cfg et lancez une commande RESTART . Si c'est le cas, c'est une bonne id\u00e9e de calibrer le z_offset \u00e0 nouveau. Si des r\u00e9sultats reproductibles ne peuvent pas \u00eatre obtenus, n'utilisez pas la sonde pour le nivellement du lit. Klipper dispose de plusieurs outils de sondage manuels qui peuvent \u00eatre utilis\u00e9s \u00e0 la place - voir le Mise \u00e0 niveau du lit pour plus de d\u00e9tails.","title":"Contr\u00f4le de r\u00e9p\u00e9tabilit\u00e9"},{"location":"Probe_Calibrate.html#verification-des-erreurs-de-localisation","text":"Certaines sondes peuvent avoir une erreur syst\u00e9mique qui corrompt les r\u00e9sultats de la sonde \u00e0 certains emplacements de la t\u00eate d'outil. Par exemple, si le support de la sonde s'incline l\u00e9g\u00e8rement lorsqu'il se d\u00e9place le long de l'axe Y, la sonde peut alors signaler des r\u00e9sultats fauss\u00e9s \u00e0 diff\u00e9rentes positions Y. Il s'agit d'un probl\u00e8me courant avec les sondes sur les imprimantes delta, mais il peut se produire sur toutes les imprimantes. On peut v\u00e9rifier une erreur d'emplacement en utilisant la commande PROBE_CALIBRATE pour mesurer le d\u00e9calage z_offset de la sonde \u00e0 divers emplacements X et Y. Id\u00e9alement, le z_offset serait une valeur constante \u00e0 chaque emplacement d'imprimante. Pour les imprimantes delta, essayez de mesurer le z_offset \u00e0 une position proche de la tour A, \u00e0 une position proche de la tour B et \u00e0 une position proche de la tour C. Pour les imprimantes cart\u00e9siennes, corexy et similaires, essayez de mesurer le z_offset \u00e0 des positions proches des quatre coins du lit. Avant de commencer ce test, calibrez d'abord les d\u00e9calages X, Y et Z de la sonde comme d\u00e9crit au d\u00e9but de ce document. Remettez ensuite l'imprimante \u00e0 l'origine et naviguez jusqu'\u00e0 la premi\u00e8re position XY. Suivez les \u00e9tapes de calibrer le d\u00e9calage en Z de la sonde en ex\u00e9cutant la commande PROBE_CALIBRATE , les commandes TESTZ et la commande ACCEPT . , mais n'ex\u00e9cutez pas SAVE_CONFIG . Notez le rapport z_offset trouv\u00e9. Naviguez ensuite vers les autres positions XY, r\u00e9p\u00e9tez ces \u00e9tapes PROBE_CALIBRATE et notez le d\u00e9calage z signal\u00e9. Si la diff\u00e9rence entre le d\u00e9calage z_offset minimum signal\u00e9 et le d\u00e9calage z_maximum signal\u00e9 est sup\u00e9rieure \u00e0 25 microns (0,025 mm), la sonde n'est pas adapt\u00e9e aux proc\u00e9dures de nivellement de lit typiques. Voir le document mise \u00e0 niveau du lit pour les alternatives de sonde manuelle.","title":"V\u00e9rification des erreurs de localisation"},{"location":"Probe_Calibrate.html#erreurs-de-temperature","text":"De nombreuses sondes ont une erreur syst\u00e9mique lorsqu'elles sondent \u00e0 diff\u00e9rentes temp\u00e9ratures. Par exemple, la sonde peut se d\u00e9clencher syst\u00e9matiquement \u00e0 une hauteur inf\u00e9rieure lorsque la sonde est \u00e0 une temp\u00e9rature plus \u00e9lev\u00e9e. Il est recommand\u00e9 de faire fonctionner les outils de nivellement du lit \u00e0 une temp\u00e9rature constante pour tenir compte de cette erreur. Par exemple, ex\u00e9cutez toujours les outils lorsque l'imprimante est \u00e0 temp\u00e9rature ambiante ou ex\u00e9cutez toujours les outils une fois que l'imprimante a obtenu une temp\u00e9rature d'impression constante. Dans les deux cas, c'est une bonne id\u00e9e d'attendre plusieurs minutes apr\u00e8s que la temp\u00e9rature souhait\u00e9e est atteinte, de sorte que l'appareil d'impression soit constamment \u00e0 la temp\u00e9rature souhait\u00e9e. Pour v\u00e9rifier une erreur de temp\u00e9rature, commencez avec l'imprimante \u00e0 temp\u00e9rature ambiante, puis mettez l'imprimante \u00e0 l'origine, d\u00e9placez la t\u00eate vers une position proche du centre du lit et ex\u00e9cutez la commande PROBE_ACCURACY . Notez les r\u00e9sultats. Ensuite, sans mise \u00e0 l'origine ou d\u00e9sactiver les moteurs pas \u00e0 pas, chauffez la buse et le lit de l'imprimante \u00e0 la temp\u00e9rature d'impression, puis ex\u00e9cutez \u00e0 nouveau la commande PROBE_ACCURACY . Id\u00e9alement, la commande rapportera des r\u00e9sultats identiques. Comme ci-dessus, si la sonde a un d\u00e9calage en temp\u00e9rature, veillez \u00e0 toujours utiliser la sonde \u00e0 une temp\u00e9rature constante.","title":"Erreurs de temp\u00e9rature"},{"location":"Protocol.html","text":"Protocole \u00b6 Le protocole de messagerie Klipper est utilis\u00e9 pour la communication de bas niveau entre le logiciel h\u00f4te Klipper et le logiciel du microcontr\u00f4leur Klipper. \u00c0 un niveau \u00e9lev\u00e9, le protocole peut \u00eatre consid\u00e9r\u00e9 comme une s\u00e9rie de cha\u00eenes de commandes et de r\u00e9ponses qui sont compress\u00e9es, transmises, puis trait\u00e9es du c\u00f4t\u00e9 r\u00e9ception. Un exemple d'une s\u00e9ries de commandes dans un format non compress\u00e9 lisible par l'homme pourrait ressembler \u00e0 : set_digital_out pin=PA3 value=1 set_digital_out pin=PA7 value=1 schedule_digital_out oid=8 clock=4000000 value=0 queue_step oid=7 interval=7458 count=10 add=331 queue_step oid=7 interval=11717 count=4 add=1281 Voir le document commandes mcu pour plus d'informations sur les commandes disponibles. Voir le document deboguage pour plus d'informations sur la fa\u00e7on de traduire un fichier G-Code en commandes de microcontr\u00f4leur lisibles (par l'homme). Cette page fournit une description de haut niveau du protocole de communication de Klipper. Elle d\u00e9crit comment les messages sont d\u00e9clar\u00e9s, encod\u00e9s au format binaire (le format de \"compression\") et transmis. L'objectif du protocole est de permettre un canal de communication sans erreur entre l'h\u00f4te et le microcontr\u00f4leur avec une faible latence, une faible bande passante et une faible complexit\u00e9 pour le microcontr\u00f4leur. Interface du micro-contr\u00f4leur \u00b6 Le protocole de transmission Klipper peut \u00eatre consid\u00e9r\u00e9 comme un m\u00e9canisme d' Appel de proc\u00e9dure \u00e0 distance entre le microcontr\u00f4leur et l'h\u00f4te. Le logiciel du microcontr\u00f4leur d\u00e9clare les commandes que l'h\u00f4te peut invoquer ainsi que les messages de r\u00e9ponse qu'il peut g\u00e9n\u00e9rer. L'h\u00f4te utilise ces informations pour ordonner au microcontr\u00f4leur d'effectuer des actions et d'interpr\u00e9ter les r\u00e9sultats. D\u00e9claration des commandes \u00b6 Le logiciel du microcontr\u00f4leur d\u00e9clare une \"commande\" en utilisant la macro DECL_COMMAND() dans le code C. Par exemple\u202f: DECL_COMMAND(command_update_digital_out, \"update_digital_out oid=%c value=%c\"); Ce qui pr\u00e9c\u00e8de d\u00e9clare une commande nomm\u00e9e \"update_digital_out\". Cela permet \u00e0 l'h\u00f4te \"d'appeler\" cette commande qui entra\u00eenerait l'ex\u00e9cution de la fonction C command_update_digital_out() dans le microcontr\u00f4leur. Ce qui pr\u00e9c\u00e8de indique \u00e9galement que la commande prend deux param\u00e8tres entiers. Lorsque le code C command_update_digital_out() est ex\u00e9cut\u00e9, un tableau contenant ces deux entiers lui sera transmis - le premier correspondant \u00e0 'oid' et le second correspondant \u00e0 'value'. En g\u00e9n\u00e9ral, les param\u00e8tres sont d\u00e9crits avec une syntaxe de style printf() (par exemple, \"%u\"). Le formatage correspond directement \u00e0 une vue \"lisible\" (par un Humain) des commandes (par exemple, \"update_digital_out oid=7 value=1\"). Dans l'exemple ci-dessus, \"value=\" est un nom de param\u00e8tre et \"%c\" indique que le param\u00e8tre est un entier. En interne, le nom du param\u00e8tre n'est utilis\u00e9 que comme documentation. Dans cet exemple, le \"%c\" est \u00e9galement utilis\u00e9 comme documentation pour indiquer que l'entier attendu a une taille de 1 octet (la taille d\u00e9clar\u00e9e de l'entier n'a pas d'impact sur l'analyse ou l'encodage). La compilation du micrologiciel du microcontr\u00f4leur collectera toutes les commandes d\u00e9clar\u00e9es avec DECL_COMMAND(), d\u00e9terminera leurs param\u00e8tres et s'arrangera pour qu'elles soient appelables. D\u00e9claration des r\u00e9ponses \u00b6 Pour envoyer des informations du microcontr\u00f4leur \u00e0 l'h\u00f4te, des \"r\u00e9ponses\" sont g\u00e9n\u00e9r\u00e9es. Celles-ci sont \u00e0 la fois d\u00e9clar\u00e9es et transmises \u00e0 l'aide de la macro C sendf(). Par example\u202f: sendf(\"status clock=%u status=%c\", sched_read_time(), sched_is_shutdown()); Ce qui pr\u00e9c\u00e8de transmet un message de r\u00e9ponse \"status\" qui contient deux param\u00e8tres entiers (\"clock\" et \"status\"). La construction du microcontr\u00f4leur trouve automatiquement tous les appels sendf() et g\u00e9n\u00e8re des encodeurs pour eux. Le premier param\u00e8tre de la fonction sendf() d\u00e9crit la r\u00e9ponse et il est dans le m\u00eame format que les d\u00e9clarations de commande. L'h\u00f4te peut enregistrer une fonction de rappel pour chaque r\u00e9ponse. Ainsi, les commandes permettent \u00e0 l'h\u00f4te d'invoquer des fonctions C dans le microcontr\u00f4leur et les r\u00e9ponses permettent au logiciel du microcontr\u00f4leur d'invoquer du code dans l'h\u00f4te. La macro sendf() ne doit \u00eatre appel\u00e9e qu'\u00e0 partir de commandes ou de gestionnaires de t\u00e2ches, et elle ne doit pas \u00eatre appel\u00e9e \u00e0 partir d'interruptions ou de timers. Le code n'a pas besoin d'\u00e9mettre un sendf() en r\u00e9ponse \u00e0 une commande re\u00e7ue, le nombre d'appels \u00e0 sendf() n'est pas limi\u00e9, et il est possible d'appeler sendf() \u00e0 tout moment \u00e0 partir d'un gestionnaire de t\u00e2ches. R\u00e9ponses de sortie \u00b6 Pour simplifier le d\u00e9bogage, il existe \u00e9galement une fonction C output(). Par exemple\u202f: output(\"La valeur de %u est %s avec une taille de %u.\", x, buf, buf_len); La fonction output() est similaire \u00e0 printf() - elle est destin\u00e9e \u00e0 g\u00e9n\u00e9rer et formater des messages de d\u00e9bogage avec un affichage dans un format compr\u00e9hensible (ndt : par un humain normalement constitu\u00e9 :-)). D\u00e9clarer des \u00e9num\u00e9rations \u00b6 Les \u00e9num\u00e9rations permettent au code h\u00f4te d'utiliser des identificateurs de type cha\u00eene pour des param\u00e8tres que le microcontr\u00f4leur g\u00e8re comme des entiers. Ils sont d\u00e9clar\u00e9s dans le code du microcontr\u00f4leur - par exemple : DECL_ENUMERATION(\"spi_bus\", \"spi\", 0); DECL_ENUMERATION_RANGE(\"pin\", \"PC0\", 16, 8); Dans le premier exemple, la macro DECL_ENUMERATION() d\u00e9finit une \u00e9num\u00e9ration pour les messages de commande/r\u00e9ponse avec un nom de param\u00e8tre \"spi_bus\" ou un nom de param\u00e8tre avec un suffixe \"_spi_bus\". Pour ces param\u00e8tres, la cha\u00eene \"spi\" sera une valeur valide et elle sera transmise comme une valeur enti\u00e8re \u00e9gale \u00e0 z\u00e9ro. Il est \u00e9galement possible de d\u00e9clarer une plage d'\u00e9num\u00e9ration. Dans le deuxi\u00e8me exemple, un param\u00e8tre \"pin\" (ou tout param\u00e8tre avec le suffixe \"_pin\") accepterait PC0, PC1, PC2, ..., PC7 comme valeurs valides. Les cha\u00eenes seront transmises comme des entiers 16, 17, 18, ..., 23. D\u00e9claration de constantes \u00b6 Les constantes peuvent \u00eatre export\u00e9es. Par exemple, les \u00e9l\u00e9ments suivants : DECL_CONSTANT(\"SERIAL_BAUD\", 250000); exporterait une constante nomm\u00e9e \"SERIAL_BAUD\" avec une valeur de 250000 du microcontr\u00f4leur vers l'h\u00f4te. Il est \u00e9galement possible de d\u00e9clarer une constante de type cha\u00eene - par exemple : DECL_CONSTANT_STR(\"MCU\", \"pru\"); Encodage des message de bas niveau \u00b6 Pour accomplir le m\u00e9canisme \"RPC\" ci-dessus, chaque commandes et r\u00e9ponses sont cod\u00e9es dans un format binaire pour la transmission. Cette section d\u00e9crit le syst\u00e8me de transmission. Blocs de message \u00b6 Toutes les donn\u00e9es envoy\u00e9es de l'h\u00f4te au microcontr\u00f4leur et vice-versa sont contenues dans des \"blocs de message\". Un bloc de message a un en-t\u00eate de deux octets et une fin de trois octets. Le format d'un bloc de message est : <1 byte length><1 byte sequence><n-byte content><2 byte crc><1 byte sync> L'octet de longueur contient le nombre d'octets dans le bloc de message, y compris les octets d'en-t\u00eate et de fin (la longueur minimale du message est donc de 5 octets). La longueur maximale d'un bloc de message est de 64 octets. L'octet de s\u00e9quence contient un num\u00e9ro de s\u00e9quence de 4 bits dans les bits de poids faible et les bits de poids fort contiennent toujours 0x10 (les bits de poids fort sont r\u00e9serv\u00e9s pour une utilisation future). Les octets de contenu contiennent les donn\u00e9es du message et leur format est d\u00e9crit dans la section suivante. Les octets crc contiennent un CCITT CRC 16 bits du bloc de message incluant les octets d'en-t\u00eate mais excluant les octets de fin. L'octet de synchronisation est 0x7e. Le format du bloc de message est inspir\u00e9 des trames de message HDLC . Comme dans HDLC, le bloc de message peut \u00e9ventuellement contenir un caract\u00e8re de synchronisation suppl\u00e9mentaire au d\u00e9but du bloc. Contrairement \u00e0 HDLC, un caract\u00e8re de synchronisation n'est pas propre au header et peut \u00eatre pr\u00e9sent dans le contenu du bloc de message. Contenu du bloc de message \u00b6 Chaque bloc de message envoy\u00e9 de l'h\u00f4te au microcontr\u00f4leur contient une s\u00e9rie de z\u00e9ro ou plusieurs commandes de message dans son contenu. Chaque commande commence par une Quantit\u00e9 de longueur variable (VLQ) encod\u00e9 entier command-id suivi de z\u00e9ro ou plusieurs param\u00e8tres VLQ pour la commande donn\u00e9e. Par exemple, les quatre commandes suivantes peuvent \u00eatre plac\u00e9es dans un seul bloc de message : update_digital_out oid=6 value=1 update_digital_out oid=5 value=0 get_config get_clock et cod\u00e9 dans les huit entiers VLQ suivants : <id_update_digital_out><6><1><id_update_digital_out><5><0><id_get_config><id_get_clock> Afin d'encoder et d'analyser le contenu du message, l'h\u00f4te et le microcontr\u00f4leur doivent s'accorder sur les identifiants de commande et le nombre de param\u00e8tres de chaque commande. Ainsi, dans l'exemple ci-dessus, l'h\u00f4te et le microcontr\u00f4leur savent que \"id_update_digital_out\" est toujours suivi de deux param\u00e8tres, et \"id_get_config\" et \"id_get_clock\" n'ont aucun param\u00e8tre. L'h\u00f4te et le microcontr\u00f4leur partagent un \"dictionnaire de donn\u00e9es\" qui mappe les descriptions de commande (par exemple, \"update_digital_out oid=%c value=%c\") \u00e0 leurs identifiants de commande \"entiers\". Lors du traitement des donn\u00e9es, l'analyseur saura s'attendre \u00e0 un nombre sp\u00e9cifique de param\u00e8tres cod\u00e9s VLQ apr\u00e8s un identifiant de commande donn\u00e9. Le contenu des messages pour les blocs envoy\u00e9s du microcontr\u00f4leur \u00e0 l'h\u00f4te suit le m\u00eame format. Les identifiants de ces messages sont des \"identifiants de r\u00e9ponse\", mais ils ont le m\u00eame objectif et suivent les m\u00eames r\u00e8gles de codage. En pratique, les blocs de message envoy\u00e9s du microcontr\u00f4leur \u00e0 l'h\u00f4te ne contiennent jamais plus d'une r\u00e9ponse dans le contenu du bloc de message. Quantit\u00e9s de longueur variable \u00b6 Voir l' article wikipedia sur les VLQ pour plus d'informations sur le format g\u00e9n\u00e9ral des entiers cod\u00e9s VLQ. Klipper utilise un sch\u00e9ma de codage qui prend en charge les entiers positifs et n\u00e9gatifs. Les entiers proches de z\u00e9ro utilisent moins d'octets pour coder et les entiers positifs cod\u00e9s utilisent moins d'octets - en g\u00e9n\u00e9ral - que les entiers n\u00e9gatifs. Le tableau suivant indique le nombre d'octets n\u00e9cessaires \u00e0 l'encodage de chaque entier : Integer Taille encod\u00e9e -32 .. 95 1 -4096 .. 12287 2 -524288 .. 1572863 3 -67108864 .. 201326591 4 -2147483648 .. 4294967295 5 Cha\u00eenes de longueur variable \u00b6 Une exception aux r\u00e8gles de codage ci-dessus, si le param\u00e8tre d'une commande ou d'une r\u00e9ponse est une cha\u00eene dynamique, le param\u00e8tre n'est pas cod\u00e9 comme un simple entier VLQ. Au lieu de cela, il est cod\u00e9 en transmettant la longueur sous la forme d'un entier cod\u00e9 VLQ suivi du contenu de la cha\u00eene lui-m\u00eame : <VLQ encoded length><n-byte contents> Les descriptions de commande trouv\u00e9es dans le dictionnaire de donn\u00e9es permettent \u00e0 la fois \u00e0 l'h\u00f4te et au microcontr\u00f4leur de savoir quels param\u00e8tres de commande utilisent un codage VLQ simple et quels param\u00e8tres utilisent un codage de cha\u00eene. Dictionnaire de donn\u00e9es \u00b6 Pour que des communications significatives soient \u00e9tablies entre le microcontr\u00f4leur et l'h\u00f4te, les deux parties doivent s'entendre sur un \"dictionnaire de donn\u00e9es\". Ce dictionnaire de donn\u00e9es contient les identificateurs entiers des commandes et des r\u00e9ponses ainsi que leurs descriptions. La construction du micrologiciel du microcontr\u00f4leur utilise le contenu des macros DECL_COMMAND() et sendf() pour g\u00e9n\u00e9rer le dictionnaire de donn\u00e9es. La construction attribue automatiquement des identifiants uniques \u00e0 chaque commande et r\u00e9ponse. Ce syst\u00e8me permet \u00e0 la fois au code h\u00f4te et au code du microcontr\u00f4leur d'utiliser de mani\u00e8re transparente des noms descriptifs lisibles par l'homme tout en utilisant une bande passante minimale. L'h\u00f4te interroge le dictionnaire de donn\u00e9es lors de sa premi\u00e8re connexion au microcontr\u00f4leur. Une fois que l'h\u00f4te a t\u00e9l\u00e9charg\u00e9 le dictionnaire de donn\u00e9es du microcontr\u00f4leur, il utilise ce dictionnaire de donn\u00e9es pour coder toutes les commandes et analyser toutes les r\u00e9ponses du microcontr\u00f4leur. L'h\u00f4te doit donc g\u00e9rer un dictionnaire de donn\u00e9es dynamique. Cependant, pour garder le logiciel du microcontr\u00f4leur simple, le microcontr\u00f4leur utilise - lui - toujours son dictionnaire de donn\u00e9es statique (compil\u00e9). Le dictionnaire de donn\u00e9es est demand\u00e9 en envoyant des commandes \"identify\" au microcontr\u00f4leur. Le microcontr\u00f4leur r\u00e9pond \u00e0 chaque commande d'identification par un message \"identifier_response\". \u00c9tant donn\u00e9 que ces deux commandes sont n\u00e9cessaires avant d'obtenir le dictionnaire de donn\u00e9es, leurs identifiants entiers et leurs types de param\u00e8tres sont cod\u00e9s en dur \u00e0 la fois dans le microcontr\u00f4leur et dans l'h\u00f4te. L'identifiant de r\u00e9ponse \"identifier_response\" est 0, l'identifiant de commande \"identify\" est 1. En plus d'avoir des identifiants cod\u00e9s en dur, la commande d'identification et sa r\u00e9ponse sont d\u00e9clar\u00e9es et transmises de la m\u00eame mani\u00e8re que les autres commandes et r\u00e9ponses. Aucune autre commande ou r\u00e9ponse n'est cod\u00e9e en dur. Le format du dictionnaire de donn\u00e9es transmis est une cha\u00eene JSON compress\u00e9e zlib. Le processus de construction du microcontr\u00f4leur g\u00e9n\u00e8re la cha\u00eene, la comprime et la stocke dans la section texte du flash du microcontr\u00f4leur. Le dictionnaire de donn\u00e9es peut \u00eatre beaucoup plus grand que la taille maximale du bloc de message - l'h\u00f4te le t\u00e9l\u00e9charge en envoyant plusieurs commandes d'identification demandant des blocs progressifs du dictionnaire de donn\u00e9es. Une fois que tous les morceaux sont obtenus, l'h\u00f4te r\u00e9assemble les morceaux, d\u00e9compresse les donn\u00e9es et analyse le contenu. En plus des informations sur le protocole de communication, le dictionnaire de donn\u00e9es contient \u00e9galement la version du logiciel, les \u00e9num\u00e9rations (telles que d\u00e9finies par DECL_ENUMERATION) et les constantes (telles que d\u00e9finies par DECL_CONSTANT). Flux de messages \u00b6 Les message de commande envoy\u00e9es de l'h\u00f4te au microcontr\u00f4leur sont cens\u00e9es \u00eatre sans erreur. Le microcontr\u00f4leur v\u00e9rifiera le CRC et les num\u00e9ros de s\u00e9quence dans chaque bloc de message pour s'assurer que les commandes sont exactes et dans l'ordre. Le microcontr\u00f4leur traite toujours les blocs de message dans l'ordre - s'il re\u00e7oit un bloc dans le d\u00e9sordre, il le rejettera ainsi que tout autre bloc dans le d\u00e9sordre jusqu'\u00e0 ce qu'il re\u00e7oive des blocs avec le bon s\u00e9quencement. Le code de bas niveau de l'h\u00f4te impl\u00e9mente un syst\u00e8me de retransmission automatique des blocs de messages perdus ou corrompus envoy\u00e9s au microcontr\u00f4leur. Pour faciliter cela, le microcontr\u00f4leur transmet un \"bloc de message ack\" apr\u00e8s chaque bloc de message re\u00e7u avec succ\u00e8s. L'h\u00f4te planifie un d\u00e9lai apr\u00e8s l'envoi de chaque bloc et il retransmettra si le d\u00e9lai expire sans recevoir de \"ack\" correspondant. De plus, si le microcontr\u00f4leur d\u00e9tecte un bloc corrompu ou dans le d\u00e9sordre, il peut transmettre un \"bloc de message nak\" pour faciliter une retransmission rapide. Un \"ack\" est un bloc de message avec un contenu vide (c'est-\u00e0-dire un bloc de message de 5 octets) et un num\u00e9ro de s\u00e9quence sup\u00e9rieur au dernier num\u00e9ro de s\u00e9quence d'h\u00f4te re\u00e7u. Un \"nak\" est un bloc de message avec un contenu vide et un num\u00e9ro de s\u00e9quence inf\u00e9rieur au dernier num\u00e9ro de s\u00e9quence d'h\u00f4te re\u00e7u. Le protocole facilite un syst\u00e8me de transmission \"fen\u00eatr\u00e9\" : l'h\u00f4te peut avoir de nombreux blocs de messages en cours \u00e0 la fois. (Ceci s'ajoute aux nombreuses commandes qui peuvent \u00eatre pr\u00e9sentes dans un bloc de message.) Cela permet une utilisation maximale de la bande passante m\u00eame en cas de latence de transmission. Les m\u00e9canismes de temporisation, de retransmission, de fen\u00eatrage et d'accus\u00e9 de r\u00e9ception sont inspir\u00e9s de m\u00e9canismes similaires de TCP . Dans l'autre sens, les blocs de messages envoy\u00e9s du microcontr\u00f4leur \u00e0 l'h\u00f4te sont aussi con\u00e7us pour \u00eatre sans erreur, mais ils n'ont pas de validation de transmission. (Les r\u00e9ponses ne doivent pas \u00eatre corrompues, mais elles peuvent dispara\u00eetre.) Cette conception a \u00e9t\u00e9 choisie pour garder une mise en \u0153uvre simple dans le microcontr\u00f4leur. Il n'y a pas de syst\u00e8me de retransmission automatique des r\u00e9ponses - le code de haut niveau devrait \u00eatre capable de g\u00e9rer une r\u00e9ponse manquante occasionnelle (g\u00e9n\u00e9ralement en redemandant le contenu ou en \u00e9tablissant un calendrier r\u00e9current de transmission des r\u00e9ponses). Le champ du num\u00e9ro de s\u00e9quence dans les blocs de message envoy\u00e9s \u00e0 l'h\u00f4te est toujours sup\u00e9rieur d'une unit\u00e9 au dernier num\u00e9ro de s\u00e9quence envoy\u00e9 par l'h\u00f4te. Il n'est pas utilis\u00e9 pour suivre les s\u00e9quences de blocs de message de r\u00e9ponse.","title":"Protocole"},{"location":"Protocol.html#protocole","text":"Le protocole de messagerie Klipper est utilis\u00e9 pour la communication de bas niveau entre le logiciel h\u00f4te Klipper et le logiciel du microcontr\u00f4leur Klipper. \u00c0 un niveau \u00e9lev\u00e9, le protocole peut \u00eatre consid\u00e9r\u00e9 comme une s\u00e9rie de cha\u00eenes de commandes et de r\u00e9ponses qui sont compress\u00e9es, transmises, puis trait\u00e9es du c\u00f4t\u00e9 r\u00e9ception. Un exemple d'une s\u00e9ries de commandes dans un format non compress\u00e9 lisible par l'homme pourrait ressembler \u00e0 : set_digital_out pin=PA3 value=1 set_digital_out pin=PA7 value=1 schedule_digital_out oid=8 clock=4000000 value=0 queue_step oid=7 interval=7458 count=10 add=331 queue_step oid=7 interval=11717 count=4 add=1281 Voir le document commandes mcu pour plus d'informations sur les commandes disponibles. Voir le document deboguage pour plus d'informations sur la fa\u00e7on de traduire un fichier G-Code en commandes de microcontr\u00f4leur lisibles (par l'homme). Cette page fournit une description de haut niveau du protocole de communication de Klipper. Elle d\u00e9crit comment les messages sont d\u00e9clar\u00e9s, encod\u00e9s au format binaire (le format de \"compression\") et transmis. L'objectif du protocole est de permettre un canal de communication sans erreur entre l'h\u00f4te et le microcontr\u00f4leur avec une faible latence, une faible bande passante et une faible complexit\u00e9 pour le microcontr\u00f4leur.","title":"Protocole"},{"location":"Protocol.html#interface-du-micro-controleur","text":"Le protocole de transmission Klipper peut \u00eatre consid\u00e9r\u00e9 comme un m\u00e9canisme d' Appel de proc\u00e9dure \u00e0 distance entre le microcontr\u00f4leur et l'h\u00f4te. Le logiciel du microcontr\u00f4leur d\u00e9clare les commandes que l'h\u00f4te peut invoquer ainsi que les messages de r\u00e9ponse qu'il peut g\u00e9n\u00e9rer. L'h\u00f4te utilise ces informations pour ordonner au microcontr\u00f4leur d'effectuer des actions et d'interpr\u00e9ter les r\u00e9sultats.","title":"Interface du micro-contr\u00f4leur"},{"location":"Protocol.html#declaration-des-commandes","text":"Le logiciel du microcontr\u00f4leur d\u00e9clare une \"commande\" en utilisant la macro DECL_COMMAND() dans le code C. Par exemple\u202f: DECL_COMMAND(command_update_digital_out, \"update_digital_out oid=%c value=%c\"); Ce qui pr\u00e9c\u00e8de d\u00e9clare une commande nomm\u00e9e \"update_digital_out\". Cela permet \u00e0 l'h\u00f4te \"d'appeler\" cette commande qui entra\u00eenerait l'ex\u00e9cution de la fonction C command_update_digital_out() dans le microcontr\u00f4leur. Ce qui pr\u00e9c\u00e8de indique \u00e9galement que la commande prend deux param\u00e8tres entiers. Lorsque le code C command_update_digital_out() est ex\u00e9cut\u00e9, un tableau contenant ces deux entiers lui sera transmis - le premier correspondant \u00e0 'oid' et le second correspondant \u00e0 'value'. En g\u00e9n\u00e9ral, les param\u00e8tres sont d\u00e9crits avec une syntaxe de style printf() (par exemple, \"%u\"). Le formatage correspond directement \u00e0 une vue \"lisible\" (par un Humain) des commandes (par exemple, \"update_digital_out oid=7 value=1\"). Dans l'exemple ci-dessus, \"value=\" est un nom de param\u00e8tre et \"%c\" indique que le param\u00e8tre est un entier. En interne, le nom du param\u00e8tre n'est utilis\u00e9 que comme documentation. Dans cet exemple, le \"%c\" est \u00e9galement utilis\u00e9 comme documentation pour indiquer que l'entier attendu a une taille de 1 octet (la taille d\u00e9clar\u00e9e de l'entier n'a pas d'impact sur l'analyse ou l'encodage). La compilation du micrologiciel du microcontr\u00f4leur collectera toutes les commandes d\u00e9clar\u00e9es avec DECL_COMMAND(), d\u00e9terminera leurs param\u00e8tres et s'arrangera pour qu'elles soient appelables.","title":"D\u00e9claration des commandes"},{"location":"Protocol.html#declaration-des-reponses","text":"Pour envoyer des informations du microcontr\u00f4leur \u00e0 l'h\u00f4te, des \"r\u00e9ponses\" sont g\u00e9n\u00e9r\u00e9es. Celles-ci sont \u00e0 la fois d\u00e9clar\u00e9es et transmises \u00e0 l'aide de la macro C sendf(). Par example\u202f: sendf(\"status clock=%u status=%c\", sched_read_time(), sched_is_shutdown()); Ce qui pr\u00e9c\u00e8de transmet un message de r\u00e9ponse \"status\" qui contient deux param\u00e8tres entiers (\"clock\" et \"status\"). La construction du microcontr\u00f4leur trouve automatiquement tous les appels sendf() et g\u00e9n\u00e8re des encodeurs pour eux. Le premier param\u00e8tre de la fonction sendf() d\u00e9crit la r\u00e9ponse et il est dans le m\u00eame format que les d\u00e9clarations de commande. L'h\u00f4te peut enregistrer une fonction de rappel pour chaque r\u00e9ponse. Ainsi, les commandes permettent \u00e0 l'h\u00f4te d'invoquer des fonctions C dans le microcontr\u00f4leur et les r\u00e9ponses permettent au logiciel du microcontr\u00f4leur d'invoquer du code dans l'h\u00f4te. La macro sendf() ne doit \u00eatre appel\u00e9e qu'\u00e0 partir de commandes ou de gestionnaires de t\u00e2ches, et elle ne doit pas \u00eatre appel\u00e9e \u00e0 partir d'interruptions ou de timers. Le code n'a pas besoin d'\u00e9mettre un sendf() en r\u00e9ponse \u00e0 une commande re\u00e7ue, le nombre d'appels \u00e0 sendf() n'est pas limi\u00e9, et il est possible d'appeler sendf() \u00e0 tout moment \u00e0 partir d'un gestionnaire de t\u00e2ches.","title":"D\u00e9claration des r\u00e9ponses"},{"location":"Protocol.html#reponses-de-sortie","text":"Pour simplifier le d\u00e9bogage, il existe \u00e9galement une fonction C output(). Par exemple\u202f: output(\"La valeur de %u est %s avec une taille de %u.\", x, buf, buf_len); La fonction output() est similaire \u00e0 printf() - elle est destin\u00e9e \u00e0 g\u00e9n\u00e9rer et formater des messages de d\u00e9bogage avec un affichage dans un format compr\u00e9hensible (ndt : par un humain normalement constitu\u00e9 :-)).","title":"R\u00e9ponses de sortie"},{"location":"Protocol.html#declarer-des-enumerations","text":"Les \u00e9num\u00e9rations permettent au code h\u00f4te d'utiliser des identificateurs de type cha\u00eene pour des param\u00e8tres que le microcontr\u00f4leur g\u00e8re comme des entiers. Ils sont d\u00e9clar\u00e9s dans le code du microcontr\u00f4leur - par exemple : DECL_ENUMERATION(\"spi_bus\", \"spi\", 0); DECL_ENUMERATION_RANGE(\"pin\", \"PC0\", 16, 8); Dans le premier exemple, la macro DECL_ENUMERATION() d\u00e9finit une \u00e9num\u00e9ration pour les messages de commande/r\u00e9ponse avec un nom de param\u00e8tre \"spi_bus\" ou un nom de param\u00e8tre avec un suffixe \"_spi_bus\". Pour ces param\u00e8tres, la cha\u00eene \"spi\" sera une valeur valide et elle sera transmise comme une valeur enti\u00e8re \u00e9gale \u00e0 z\u00e9ro. Il est \u00e9galement possible de d\u00e9clarer une plage d'\u00e9num\u00e9ration. Dans le deuxi\u00e8me exemple, un param\u00e8tre \"pin\" (ou tout param\u00e8tre avec le suffixe \"_pin\") accepterait PC0, PC1, PC2, ..., PC7 comme valeurs valides. Les cha\u00eenes seront transmises comme des entiers 16, 17, 18, ..., 23.","title":"D\u00e9clarer des \u00e9num\u00e9rations"},{"location":"Protocol.html#declaration-de-constantes","text":"Les constantes peuvent \u00eatre export\u00e9es. Par exemple, les \u00e9l\u00e9ments suivants : DECL_CONSTANT(\"SERIAL_BAUD\", 250000); exporterait une constante nomm\u00e9e \"SERIAL_BAUD\" avec une valeur de 250000 du microcontr\u00f4leur vers l'h\u00f4te. Il est \u00e9galement possible de d\u00e9clarer une constante de type cha\u00eene - par exemple : DECL_CONSTANT_STR(\"MCU\", \"pru\");","title":"D\u00e9claration de constantes"},{"location":"Protocol.html#encodage-des-message-de-bas-niveau","text":"Pour accomplir le m\u00e9canisme \"RPC\" ci-dessus, chaque commandes et r\u00e9ponses sont cod\u00e9es dans un format binaire pour la transmission. Cette section d\u00e9crit le syst\u00e8me de transmission.","title":"Encodage des message de bas niveau"},{"location":"Protocol.html#blocs-de-message","text":"Toutes les donn\u00e9es envoy\u00e9es de l'h\u00f4te au microcontr\u00f4leur et vice-versa sont contenues dans des \"blocs de message\". Un bloc de message a un en-t\u00eate de deux octets et une fin de trois octets. Le format d'un bloc de message est : <1 byte length><1 byte sequence><n-byte content><2 byte crc><1 byte sync> L'octet de longueur contient le nombre d'octets dans le bloc de message, y compris les octets d'en-t\u00eate et de fin (la longueur minimale du message est donc de 5 octets). La longueur maximale d'un bloc de message est de 64 octets. L'octet de s\u00e9quence contient un num\u00e9ro de s\u00e9quence de 4 bits dans les bits de poids faible et les bits de poids fort contiennent toujours 0x10 (les bits de poids fort sont r\u00e9serv\u00e9s pour une utilisation future). Les octets de contenu contiennent les donn\u00e9es du message et leur format est d\u00e9crit dans la section suivante. Les octets crc contiennent un CCITT CRC 16 bits du bloc de message incluant les octets d'en-t\u00eate mais excluant les octets de fin. L'octet de synchronisation est 0x7e. Le format du bloc de message est inspir\u00e9 des trames de message HDLC . Comme dans HDLC, le bloc de message peut \u00e9ventuellement contenir un caract\u00e8re de synchronisation suppl\u00e9mentaire au d\u00e9but du bloc. Contrairement \u00e0 HDLC, un caract\u00e8re de synchronisation n'est pas propre au header et peut \u00eatre pr\u00e9sent dans le contenu du bloc de message.","title":"Blocs de message"},{"location":"Protocol.html#contenu-du-bloc-de-message","text":"Chaque bloc de message envoy\u00e9 de l'h\u00f4te au microcontr\u00f4leur contient une s\u00e9rie de z\u00e9ro ou plusieurs commandes de message dans son contenu. Chaque commande commence par une Quantit\u00e9 de longueur variable (VLQ) encod\u00e9 entier command-id suivi de z\u00e9ro ou plusieurs param\u00e8tres VLQ pour la commande donn\u00e9e. Par exemple, les quatre commandes suivantes peuvent \u00eatre plac\u00e9es dans un seul bloc de message : update_digital_out oid=6 value=1 update_digital_out oid=5 value=0 get_config get_clock et cod\u00e9 dans les huit entiers VLQ suivants : <id_update_digital_out><6><1><id_update_digital_out><5><0><id_get_config><id_get_clock> Afin d'encoder et d'analyser le contenu du message, l'h\u00f4te et le microcontr\u00f4leur doivent s'accorder sur les identifiants de commande et le nombre de param\u00e8tres de chaque commande. Ainsi, dans l'exemple ci-dessus, l'h\u00f4te et le microcontr\u00f4leur savent que \"id_update_digital_out\" est toujours suivi de deux param\u00e8tres, et \"id_get_config\" et \"id_get_clock\" n'ont aucun param\u00e8tre. L'h\u00f4te et le microcontr\u00f4leur partagent un \"dictionnaire de donn\u00e9es\" qui mappe les descriptions de commande (par exemple, \"update_digital_out oid=%c value=%c\") \u00e0 leurs identifiants de commande \"entiers\". Lors du traitement des donn\u00e9es, l'analyseur saura s'attendre \u00e0 un nombre sp\u00e9cifique de param\u00e8tres cod\u00e9s VLQ apr\u00e8s un identifiant de commande donn\u00e9. Le contenu des messages pour les blocs envoy\u00e9s du microcontr\u00f4leur \u00e0 l'h\u00f4te suit le m\u00eame format. Les identifiants de ces messages sont des \"identifiants de r\u00e9ponse\", mais ils ont le m\u00eame objectif et suivent les m\u00eames r\u00e8gles de codage. En pratique, les blocs de message envoy\u00e9s du microcontr\u00f4leur \u00e0 l'h\u00f4te ne contiennent jamais plus d'une r\u00e9ponse dans le contenu du bloc de message.","title":"Contenu du bloc de message"},{"location":"Protocol.html#quantites-de-longueur-variable","text":"Voir l' article wikipedia sur les VLQ pour plus d'informations sur le format g\u00e9n\u00e9ral des entiers cod\u00e9s VLQ. Klipper utilise un sch\u00e9ma de codage qui prend en charge les entiers positifs et n\u00e9gatifs. Les entiers proches de z\u00e9ro utilisent moins d'octets pour coder et les entiers positifs cod\u00e9s utilisent moins d'octets - en g\u00e9n\u00e9ral - que les entiers n\u00e9gatifs. Le tableau suivant indique le nombre d'octets n\u00e9cessaires \u00e0 l'encodage de chaque entier : Integer Taille encod\u00e9e -32 .. 95 1 -4096 .. 12287 2 -524288 .. 1572863 3 -67108864 .. 201326591 4 -2147483648 .. 4294967295 5","title":"Quantit\u00e9s de longueur variable"},{"location":"Protocol.html#chaines-de-longueur-variable","text":"Une exception aux r\u00e8gles de codage ci-dessus, si le param\u00e8tre d'une commande ou d'une r\u00e9ponse est une cha\u00eene dynamique, le param\u00e8tre n'est pas cod\u00e9 comme un simple entier VLQ. Au lieu de cela, il est cod\u00e9 en transmettant la longueur sous la forme d'un entier cod\u00e9 VLQ suivi du contenu de la cha\u00eene lui-m\u00eame : <VLQ encoded length><n-byte contents> Les descriptions de commande trouv\u00e9es dans le dictionnaire de donn\u00e9es permettent \u00e0 la fois \u00e0 l'h\u00f4te et au microcontr\u00f4leur de savoir quels param\u00e8tres de commande utilisent un codage VLQ simple et quels param\u00e8tres utilisent un codage de cha\u00eene.","title":"Cha\u00eenes de longueur variable"},{"location":"Protocol.html#dictionnaire-de-donnees","text":"Pour que des communications significatives soient \u00e9tablies entre le microcontr\u00f4leur et l'h\u00f4te, les deux parties doivent s'entendre sur un \"dictionnaire de donn\u00e9es\". Ce dictionnaire de donn\u00e9es contient les identificateurs entiers des commandes et des r\u00e9ponses ainsi que leurs descriptions. La construction du micrologiciel du microcontr\u00f4leur utilise le contenu des macros DECL_COMMAND() et sendf() pour g\u00e9n\u00e9rer le dictionnaire de donn\u00e9es. La construction attribue automatiquement des identifiants uniques \u00e0 chaque commande et r\u00e9ponse. Ce syst\u00e8me permet \u00e0 la fois au code h\u00f4te et au code du microcontr\u00f4leur d'utiliser de mani\u00e8re transparente des noms descriptifs lisibles par l'homme tout en utilisant une bande passante minimale. L'h\u00f4te interroge le dictionnaire de donn\u00e9es lors de sa premi\u00e8re connexion au microcontr\u00f4leur. Une fois que l'h\u00f4te a t\u00e9l\u00e9charg\u00e9 le dictionnaire de donn\u00e9es du microcontr\u00f4leur, il utilise ce dictionnaire de donn\u00e9es pour coder toutes les commandes et analyser toutes les r\u00e9ponses du microcontr\u00f4leur. L'h\u00f4te doit donc g\u00e9rer un dictionnaire de donn\u00e9es dynamique. Cependant, pour garder le logiciel du microcontr\u00f4leur simple, le microcontr\u00f4leur utilise - lui - toujours son dictionnaire de donn\u00e9es statique (compil\u00e9). Le dictionnaire de donn\u00e9es est demand\u00e9 en envoyant des commandes \"identify\" au microcontr\u00f4leur. Le microcontr\u00f4leur r\u00e9pond \u00e0 chaque commande d'identification par un message \"identifier_response\". \u00c9tant donn\u00e9 que ces deux commandes sont n\u00e9cessaires avant d'obtenir le dictionnaire de donn\u00e9es, leurs identifiants entiers et leurs types de param\u00e8tres sont cod\u00e9s en dur \u00e0 la fois dans le microcontr\u00f4leur et dans l'h\u00f4te. L'identifiant de r\u00e9ponse \"identifier_response\" est 0, l'identifiant de commande \"identify\" est 1. En plus d'avoir des identifiants cod\u00e9s en dur, la commande d'identification et sa r\u00e9ponse sont d\u00e9clar\u00e9es et transmises de la m\u00eame mani\u00e8re que les autres commandes et r\u00e9ponses. Aucune autre commande ou r\u00e9ponse n'est cod\u00e9e en dur. Le format du dictionnaire de donn\u00e9es transmis est une cha\u00eene JSON compress\u00e9e zlib. Le processus de construction du microcontr\u00f4leur g\u00e9n\u00e8re la cha\u00eene, la comprime et la stocke dans la section texte du flash du microcontr\u00f4leur. Le dictionnaire de donn\u00e9es peut \u00eatre beaucoup plus grand que la taille maximale du bloc de message - l'h\u00f4te le t\u00e9l\u00e9charge en envoyant plusieurs commandes d'identification demandant des blocs progressifs du dictionnaire de donn\u00e9es. Une fois que tous les morceaux sont obtenus, l'h\u00f4te r\u00e9assemble les morceaux, d\u00e9compresse les donn\u00e9es et analyse le contenu. En plus des informations sur le protocole de communication, le dictionnaire de donn\u00e9es contient \u00e9galement la version du logiciel, les \u00e9num\u00e9rations (telles que d\u00e9finies par DECL_ENUMERATION) et les constantes (telles que d\u00e9finies par DECL_CONSTANT).","title":"Dictionnaire de donn\u00e9es"},{"location":"Protocol.html#flux-de-messages","text":"Les message de commande envoy\u00e9es de l'h\u00f4te au microcontr\u00f4leur sont cens\u00e9es \u00eatre sans erreur. Le microcontr\u00f4leur v\u00e9rifiera le CRC et les num\u00e9ros de s\u00e9quence dans chaque bloc de message pour s'assurer que les commandes sont exactes et dans l'ordre. Le microcontr\u00f4leur traite toujours les blocs de message dans l'ordre - s'il re\u00e7oit un bloc dans le d\u00e9sordre, il le rejettera ainsi que tout autre bloc dans le d\u00e9sordre jusqu'\u00e0 ce qu'il re\u00e7oive des blocs avec le bon s\u00e9quencement. Le code de bas niveau de l'h\u00f4te impl\u00e9mente un syst\u00e8me de retransmission automatique des blocs de messages perdus ou corrompus envoy\u00e9s au microcontr\u00f4leur. Pour faciliter cela, le microcontr\u00f4leur transmet un \"bloc de message ack\" apr\u00e8s chaque bloc de message re\u00e7u avec succ\u00e8s. L'h\u00f4te planifie un d\u00e9lai apr\u00e8s l'envoi de chaque bloc et il retransmettra si le d\u00e9lai expire sans recevoir de \"ack\" correspondant. De plus, si le microcontr\u00f4leur d\u00e9tecte un bloc corrompu ou dans le d\u00e9sordre, il peut transmettre un \"bloc de message nak\" pour faciliter une retransmission rapide. Un \"ack\" est un bloc de message avec un contenu vide (c'est-\u00e0-dire un bloc de message de 5 octets) et un num\u00e9ro de s\u00e9quence sup\u00e9rieur au dernier num\u00e9ro de s\u00e9quence d'h\u00f4te re\u00e7u. Un \"nak\" est un bloc de message avec un contenu vide et un num\u00e9ro de s\u00e9quence inf\u00e9rieur au dernier num\u00e9ro de s\u00e9quence d'h\u00f4te re\u00e7u. Le protocole facilite un syst\u00e8me de transmission \"fen\u00eatr\u00e9\" : l'h\u00f4te peut avoir de nombreux blocs de messages en cours \u00e0 la fois. (Ceci s'ajoute aux nombreuses commandes qui peuvent \u00eatre pr\u00e9sentes dans un bloc de message.) Cela permet une utilisation maximale de la bande passante m\u00eame en cas de latence de transmission. Les m\u00e9canismes de temporisation, de retransmission, de fen\u00eatrage et d'accus\u00e9 de r\u00e9ception sont inspir\u00e9s de m\u00e9canismes similaires de TCP . Dans l'autre sens, les blocs de messages envoy\u00e9s du microcontr\u00f4leur \u00e0 l'h\u00f4te sont aussi con\u00e7us pour \u00eatre sans erreur, mais ils n'ont pas de validation de transmission. (Les r\u00e9ponses ne doivent pas \u00eatre corrompues, mais elles peuvent dispara\u00eetre.) Cette conception a \u00e9t\u00e9 choisie pour garder une mise en \u0153uvre simple dans le microcontr\u00f4leur. Il n'y a pas de syst\u00e8me de retransmission automatique des r\u00e9ponses - le code de haut niveau devrait \u00eatre capable de g\u00e9rer une r\u00e9ponse manquante occasionnelle (g\u00e9n\u00e9ralement en redemandant le contenu ou en \u00e9tablissant un calendrier r\u00e9current de transmission des r\u00e9ponses). Le champ du num\u00e9ro de s\u00e9quence dans les blocs de message envoy\u00e9s \u00e0 l'h\u00f4te est toujours sup\u00e9rieur d'une unit\u00e9 au dernier num\u00e9ro de s\u00e9quence envoy\u00e9 par l'h\u00f4te. Il n'est pas utilis\u00e9 pour suivre les s\u00e9quences de blocs de message de r\u00e9ponse.","title":"Flux de messages"},{"location":"RPi_microcontroller.html","text":"Microcontr\u00f4leur RPi \u00b6 Ce document d\u00e9crit le processus via lequel il est possible de lancer Klipper sur un Raspberry Pi et d'utiliser le m\u00eame Raspberry Pi comme mcu secondaire. Pourquoi utiliser un RPi comme microcontr\u00f4leur secondaire ? \u00b6 Souvent les microcontr\u00f4leurs d\u00e9di\u00e9s au contr\u00f4le des imprimantes 3D disposent d'un nombre limit\u00e9 et pr\u00e9-configur\u00e9 de broches expos\u00e9es pour g\u00e9rer les principales fonctions d'impression (r\u00e9sistances thermiques, extrudeuses, steppers...). L'utilisation du RPi o\u00f9 Klipper est install\u00e9 en tant que MCU secondaire donne la possibilit\u00e9 d'utiliser directement les GPIO et les bus (i2c, spi) du RPi \u00e0 l'int\u00e9rieur de klipper sans utiliser de plugins Octoprint (le cas \u00e9ch\u00e9ant) ou de programmes externes donnant la possibilit\u00e9 de tout contr\u00f4ler \u00e0 l'int\u00e9rieur l'impression GCODE. Avertissement : Si votre plate-forme est un Beaglebone et que vous avez correctement suivi les \u00e9tapes d'installation, le mcu linux est d\u00e9j\u00e0 install\u00e9 et configur\u00e9 pour votre syst\u00e8me. Installer le script rc \u00b6 Si vous souhaitez utiliser l'h\u00f4te comme MCU secondaire, le processus klipper_mcu doit s'ex\u00e9cuter avant le processus klippy. Apr\u00e8s avoir install\u00e9 Klipper, installez le script. Executez : cd ~/klipper/ sudo cp ./scripts/klipper-mcu.service /etc/systemd/system/ sudo systemctl enable klipper-mcu.service Construire le code du microcontr\u00f4leur \u00b6 Pour compiler le code du micro-contr\u00f4leur Klipper, commencez par le configurer pour le \"Linux process\"\u202f: cd ~/klipper/ make menuconfig Dans le menu, d\u00e9finissez \"Architecture du microcontr\u00f4leur\" sur \"Processus Linux\", puis enregistrez et quittez. Pour compiler et installer le nouveau code du microcontr\u00f4leur, ex\u00e9cutez : sudo service klipper stop make flash sudo service klipper start Si klippy.log signale une erreur \"Autorisation refus\u00e9e\" lors de la tentative de connexion \u00e0 /tmp/klipper_host_mcu , vous devez ajouter votre utilisateur au groupe tty. La commande suivante ajoutera l'utilisateur \"pi\" au groupe tty : sudo usermod -a -G tty pi Configuration restante \u00b6 Terminez l'installation en configurant le MCU secondaire de Klipper en suivant les instructions dans RaspberryPi exemlple de configuration et Exemples de configuration Multi MCU . Facultatif : Activer SPI \u00b6 Assurez-vous que le pilote SPI Linux est activ\u00e9 en ex\u00e9cutant sudo raspi-config et en activant SPI dans le menu \u00ab Options d\u2019interface \u00bb. Facultatif : Activer I2C \u00b6 Assurez-vous que le pilote Linux I2C est activ\u00e9 en ex\u00e9cutant sudo raspi-config et en activant I2C dans le menu \"Interfacing options\". Si vous pr\u00e9voyez d'utiliser I2C pour l'acc\u00e9l\u00e9rom\u00e8tre MPU, il est \u00e9galement n\u00e9cessaire de d\u00e9finir le d\u00e9bit en bauds sur 400 000 en : ajoutant/d\u00e9commentant dtparam=i2c_arm=on,i2c_arm_baudrate=400000 dans /boot/config. txt (ou /boot/firmware/config.txt dans certaines distributions). Facultatif : identifiez la bonne puce gpio \u00b6 Sur Raspberry Pi et sur de nombreux clones, les broches disponibles sur le connecteur GPIO appartiennent \u00e0 la premi\u00e8re puce gpio. Ils peuvent donc \u00eatre utilis\u00e9s sur klipper simplement en les r\u00e9f\u00e9ren\u00e7ant avec le nom gpio0..n . Cependant, il existe des cas dans lesquels les broches disponibles appartiennent \u00e0 des puces gpio autres que la premi\u00e8re. Par exemple dans le cas de certains mod\u00e8les OrangePi ou si un \"Port Expander\" est utilis\u00e9. Dans ces cas, il est utile d'utiliser les commandes pour acc\u00e9der au P\u00e9riph\u00e9rique de caract\u00e8res GPIO Linux pour v\u00e9rifier la configuration. Pour installer le p\u00e9riph\u00e9rique de caract\u00e8res *Linux GPIO - binaire * sur une distribution bas\u00e9e sur Debian comme Octopi, ex\u00e9cutez : sudo apt-get install gpiod Pour v\u00e9rifier la puce gpio disponible ex\u00e9cutez : gpiodetect Pour v\u00e9rifier la num\u00e9rotation des broches du connecteur GPIO et leur disponibilit\u00e9, ex\u00e9cutez : gpioinfo La broche choisie peut donc \u00eatre utilis\u00e9e dans la configuration comme gpiochip<n>/gpio<o> o\u00f9 n est le num\u00e9ro de puce tel qu'il est vu par la commande gpiodetect et o est le num\u00e9ro de ligne vu par la commande gpioinfo . Avertissement : seul les broches gpio marqu\u00e9es comme inutilis\u00e9es peuvent \u00eatre utilis\u00e9es. Il n'est pas possible qu'une ligne soit utilis\u00e9e par plusieurs processus simultan\u00e9ment. Par exemple sur un RPi 3B+ o\u00f9 klipper utilise le GPIO20 comme un interrupteur : $ gpiodetect gpiochip0 [pinctrl-bcm2835] (54 lines) gpiochip1 [raspberrypi-exp-gpio] (8 lines) $ gpioinfo gpiochip0 - 54 lines: line 0: unnamed unused input active-high line 1: unnamed unused input active-high line 2: unnamed unused input active-high line 3: unnamed unused input active-high line 4: unnamed unused input active-high line 5: unnamed unused input active-high line 6: unnamed unused input active-high line 7: unnamed unused input active-high line 8: unnamed unused input active-high line 9: unnamed unused input active-high line 10: unnamed unused input active-high line 11: unnamed unused input active-high line 12: unnamed unused input active-high line 13: unnamed unused input active-high line 14: unnamed unused input active-high line 15: unnamed unused input active-high line 16: unnamed unused input active-high line 17: unnamed unused input active-high line 18: unnamed unused input active-high line 19: unnamed unused input active-high line 20: unnamed \"klipper\" output active-high [used] line 21: unnamed unused input active-high line 22: unnamed unused input active-high line 23: unnamed unused input active-high line 24: unnamed unused input active-high line 25: unnamed unused input active-high line 26: unnamed unused input active-high line 27: unnamed unused input active-high line 28: unnamed unused input active-high line 29: unnamed \"led0\" output active-high [used] line 30: unnamed unused input active-high line 31: unnamed unused input active-high line 32: unnamed unused input active-high line 33: unnamed unused input active-high line 34: unnamed unused input active-high line 35: unnamed unused input active-high line 36: unnamed unused input active-high line 37: unnamed unused input active-high line 38: unnamed unused input active-high line 39: unnamed unused input active-high line 40: unnamed unused input active-high line 41: unnamed unused input active-high line 42: unnamed unused input active-high line 43: unnamed unused input active-high line 44: unnamed unused input active-high line 45: unnamed unused input active-high line 46: unnamed unused input active-high line 47: unnamed unused input active-high line 48: unnamed unused input active-high line 49: unnamed unused input active-high line 50: unnamed unused input active-high line 51: unnamed unused input active-high line 52: unnamed unused input active-high line 53: unnamed unused input active-high gpiochip1 - 8 lines: line 0: unnamed unused input active-high line 1: unnamed unused input active-high line 2: unnamed \"led1\" output active-low [used] line 3: unnamed unused input active-high line 4: unnamed unused input active-high line 5: unnamed unused input active-high line 6: unnamed unused input active-high line 7: unnamed unused input active-high Facultatif : PWM mat\u00e9riel \u00b6 Les Raspberry Pi ont deux canaux PWM (PWM0 et PWM1) qui sont disponibles sur le connecteur ou, sinon, peuvent \u00eatre redirig\u00e9s vers des broches gpio existantes. Le service mcu Linux utilise l'interface pwmchip sysfs pour contr\u00f4ler les p\u00e9riph\u00e9riques mat\u00e9riels pwm sur les h\u00f4tes Linux. L'interface pwm sysfs n'est pas disponible par d\u00e9faut sur un Raspberry et peut \u00eatre activ\u00e9e en ajoutant une ligne \u00e0 /boot/config.txt : # Activer l'interface pwmchip sysfs dtoverlay=pwm,pin=12,func=4 This example enables only PWM0 and routes it to gpio12. If both PWM channels need to be enabled you can use pwm-2chan : # Enable pwmchip sysfs interface dtoverlay=pwm-2chan,pin=12,func=4,pin2=13,func2=4 This example additionally enables PWM1 and routes it to gpio13. The overlay does not expose the pwm line on sysfs on boot and needs to be exported by echo'ing the number of the pwm channel to /sys/class/pwm/pwmchip0/export . This will create device /sys/class/pwm/pwmchip0/pwm0 in the filesystem. The easiest way to do this is by adding this to /etc/rc.local before the exit 0 line: # Enable pwmchip sysfs interface echo 0 > /sys/class/pwm/pwmchip0/export When using both PWM channels, the number of the second channel needs to be echo'd as well: # Enable pwmchip sysfs interface echo 0 > /sys/class/pwm/pwmchip0/export echo 1 > /sys/class/pwm/pwmchip0/export Avec le sysfs en place, vous pouvez maintenant utiliser l'un ou l'autre des canaux pwm en ajoutant la configuration suivante \u00e0 votre printer.cfg : [output_pin caselight] pin: host:pwmchip0/pwm0 pwm: True hardware_pwm: True cycle_time: 0.000001 [output_pin beeper] pin: host:pwmchip0/pwm1 pwm: True hardware_pwm: True value: 0 shutdown_value: 0 cycle_time: 0.0005 This will add hardware pwm control to gpio12 and gpio13 on the Pi (because the overlay was configured to route pwm0 to pin=12 and pwm1 to pin=13). PWM0 peut \u00eatre redirig\u00e9 vers gpio12 et gpio18, PWM1 peut \u00eatre redirig\u00e9 vers gpio13 et gpio19 : PWM (Modulation en Largeur d'Impulsion) Broche gpio Func 0 12 4 0 18 2 1 13 4 1 19 2","title":"Microcontr\u00f4leur RPi"},{"location":"RPi_microcontroller.html#microcontroleur-rpi","text":"Ce document d\u00e9crit le processus via lequel il est possible de lancer Klipper sur un Raspberry Pi et d'utiliser le m\u00eame Raspberry Pi comme mcu secondaire.","title":"Microcontr\u00f4leur RPi"},{"location":"RPi_microcontroller.html#pourquoi-utiliser-un-rpi-comme-microcontroleur-secondaire","text":"Souvent les microcontr\u00f4leurs d\u00e9di\u00e9s au contr\u00f4le des imprimantes 3D disposent d'un nombre limit\u00e9 et pr\u00e9-configur\u00e9 de broches expos\u00e9es pour g\u00e9rer les principales fonctions d'impression (r\u00e9sistances thermiques, extrudeuses, steppers...). L'utilisation du RPi o\u00f9 Klipper est install\u00e9 en tant que MCU secondaire donne la possibilit\u00e9 d'utiliser directement les GPIO et les bus (i2c, spi) du RPi \u00e0 l'int\u00e9rieur de klipper sans utiliser de plugins Octoprint (le cas \u00e9ch\u00e9ant) ou de programmes externes donnant la possibilit\u00e9 de tout contr\u00f4ler \u00e0 l'int\u00e9rieur l'impression GCODE. Avertissement : Si votre plate-forme est un Beaglebone et que vous avez correctement suivi les \u00e9tapes d'installation, le mcu linux est d\u00e9j\u00e0 install\u00e9 et configur\u00e9 pour votre syst\u00e8me.","title":"Pourquoi utiliser un RPi comme microcontr\u00f4leur secondaire ?"},{"location":"RPi_microcontroller.html#installer-le-script-rc","text":"Si vous souhaitez utiliser l'h\u00f4te comme MCU secondaire, le processus klipper_mcu doit s'ex\u00e9cuter avant le processus klippy. Apr\u00e8s avoir install\u00e9 Klipper, installez le script. Executez : cd ~/klipper/ sudo cp ./scripts/klipper-mcu.service /etc/systemd/system/ sudo systemctl enable klipper-mcu.service","title":"Installer le script rc"},{"location":"RPi_microcontroller.html#construire-le-code-du-microcontroleur","text":"Pour compiler le code du micro-contr\u00f4leur Klipper, commencez par le configurer pour le \"Linux process\"\u202f: cd ~/klipper/ make menuconfig Dans le menu, d\u00e9finissez \"Architecture du microcontr\u00f4leur\" sur \"Processus Linux\", puis enregistrez et quittez. Pour compiler et installer le nouveau code du microcontr\u00f4leur, ex\u00e9cutez : sudo service klipper stop make flash sudo service klipper start Si klippy.log signale une erreur \"Autorisation refus\u00e9e\" lors de la tentative de connexion \u00e0 /tmp/klipper_host_mcu , vous devez ajouter votre utilisateur au groupe tty. La commande suivante ajoutera l'utilisateur \"pi\" au groupe tty : sudo usermod -a -G tty pi","title":"Construire le code du microcontr\u00f4leur"},{"location":"RPi_microcontroller.html#configuration-restante","text":"Terminez l'installation en configurant le MCU secondaire de Klipper en suivant les instructions dans RaspberryPi exemlple de configuration et Exemples de configuration Multi MCU .","title":"Configuration restante"},{"location":"RPi_microcontroller.html#facultatif-activer-spi","text":"Assurez-vous que le pilote SPI Linux est activ\u00e9 en ex\u00e9cutant sudo raspi-config et en activant SPI dans le menu \u00ab Options d\u2019interface \u00bb.","title":"Facultatif\u00a0: Activer SPI"},{"location":"RPi_microcontroller.html#facultatif-activer-i2c","text":"Assurez-vous que le pilote Linux I2C est activ\u00e9 en ex\u00e9cutant sudo raspi-config et en activant I2C dans le menu \"Interfacing options\". Si vous pr\u00e9voyez d'utiliser I2C pour l'acc\u00e9l\u00e9rom\u00e8tre MPU, il est \u00e9galement n\u00e9cessaire de d\u00e9finir le d\u00e9bit en bauds sur 400 000 en : ajoutant/d\u00e9commentant dtparam=i2c_arm=on,i2c_arm_baudrate=400000 dans /boot/config. txt (ou /boot/firmware/config.txt dans certaines distributions).","title":"Facultatif\u00a0: Activer I2C"},{"location":"RPi_microcontroller.html#facultatif-identifiez-la-bonne-puce-gpio","text":"Sur Raspberry Pi et sur de nombreux clones, les broches disponibles sur le connecteur GPIO appartiennent \u00e0 la premi\u00e8re puce gpio. Ils peuvent donc \u00eatre utilis\u00e9s sur klipper simplement en les r\u00e9f\u00e9ren\u00e7ant avec le nom gpio0..n . Cependant, il existe des cas dans lesquels les broches disponibles appartiennent \u00e0 des puces gpio autres que la premi\u00e8re. Par exemple dans le cas de certains mod\u00e8les OrangePi ou si un \"Port Expander\" est utilis\u00e9. Dans ces cas, il est utile d'utiliser les commandes pour acc\u00e9der au P\u00e9riph\u00e9rique de caract\u00e8res GPIO Linux pour v\u00e9rifier la configuration. Pour installer le p\u00e9riph\u00e9rique de caract\u00e8res *Linux GPIO - binaire * sur une distribution bas\u00e9e sur Debian comme Octopi, ex\u00e9cutez : sudo apt-get install gpiod Pour v\u00e9rifier la puce gpio disponible ex\u00e9cutez : gpiodetect Pour v\u00e9rifier la num\u00e9rotation des broches du connecteur GPIO et leur disponibilit\u00e9, ex\u00e9cutez : gpioinfo La broche choisie peut donc \u00eatre utilis\u00e9e dans la configuration comme gpiochip<n>/gpio<o> o\u00f9 n est le num\u00e9ro de puce tel qu'il est vu par la commande gpiodetect et o est le num\u00e9ro de ligne vu par la commande gpioinfo . Avertissement : seul les broches gpio marqu\u00e9es comme inutilis\u00e9es peuvent \u00eatre utilis\u00e9es. Il n'est pas possible qu'une ligne soit utilis\u00e9e par plusieurs processus simultan\u00e9ment. Par exemple sur un RPi 3B+ o\u00f9 klipper utilise le GPIO20 comme un interrupteur : $ gpiodetect gpiochip0 [pinctrl-bcm2835] (54 lines) gpiochip1 [raspberrypi-exp-gpio] (8 lines) $ gpioinfo gpiochip0 - 54 lines: line 0: unnamed unused input active-high line 1: unnamed unused input active-high line 2: unnamed unused input active-high line 3: unnamed unused input active-high line 4: unnamed unused input active-high line 5: unnamed unused input active-high line 6: unnamed unused input active-high line 7: unnamed unused input active-high line 8: unnamed unused input active-high line 9: unnamed unused input active-high line 10: unnamed unused input active-high line 11: unnamed unused input active-high line 12: unnamed unused input active-high line 13: unnamed unused input active-high line 14: unnamed unused input active-high line 15: unnamed unused input active-high line 16: unnamed unused input active-high line 17: unnamed unused input active-high line 18: unnamed unused input active-high line 19: unnamed unused input active-high line 20: unnamed \"klipper\" output active-high [used] line 21: unnamed unused input active-high line 22: unnamed unused input active-high line 23: unnamed unused input active-high line 24: unnamed unused input active-high line 25: unnamed unused input active-high line 26: unnamed unused input active-high line 27: unnamed unused input active-high line 28: unnamed unused input active-high line 29: unnamed \"led0\" output active-high [used] line 30: unnamed unused input active-high line 31: unnamed unused input active-high line 32: unnamed unused input active-high line 33: unnamed unused input active-high line 34: unnamed unused input active-high line 35: unnamed unused input active-high line 36: unnamed unused input active-high line 37: unnamed unused input active-high line 38: unnamed unused input active-high line 39: unnamed unused input active-high line 40: unnamed unused input active-high line 41: unnamed unused input active-high line 42: unnamed unused input active-high line 43: unnamed unused input active-high line 44: unnamed unused input active-high line 45: unnamed unused input active-high line 46: unnamed unused input active-high line 47: unnamed unused input active-high line 48: unnamed unused input active-high line 49: unnamed unused input active-high line 50: unnamed unused input active-high line 51: unnamed unused input active-high line 52: unnamed unused input active-high line 53: unnamed unused input active-high gpiochip1 - 8 lines: line 0: unnamed unused input active-high line 1: unnamed unused input active-high line 2: unnamed \"led1\" output active-low [used] line 3: unnamed unused input active-high line 4: unnamed unused input active-high line 5: unnamed unused input active-high line 6: unnamed unused input active-high line 7: unnamed unused input active-high","title":"Facultatif\u00a0: identifiez la bonne puce gpio"},{"location":"RPi_microcontroller.html#facultatif-pwm-materiel","text":"Les Raspberry Pi ont deux canaux PWM (PWM0 et PWM1) qui sont disponibles sur le connecteur ou, sinon, peuvent \u00eatre redirig\u00e9s vers des broches gpio existantes. Le service mcu Linux utilise l'interface pwmchip sysfs pour contr\u00f4ler les p\u00e9riph\u00e9riques mat\u00e9riels pwm sur les h\u00f4tes Linux. L'interface pwm sysfs n'est pas disponible par d\u00e9faut sur un Raspberry et peut \u00eatre activ\u00e9e en ajoutant une ligne \u00e0 /boot/config.txt : # Activer l'interface pwmchip sysfs dtoverlay=pwm,pin=12,func=4 This example enables only PWM0 and routes it to gpio12. If both PWM channels need to be enabled you can use pwm-2chan : # Enable pwmchip sysfs interface dtoverlay=pwm-2chan,pin=12,func=4,pin2=13,func2=4 This example additionally enables PWM1 and routes it to gpio13. The overlay does not expose the pwm line on sysfs on boot and needs to be exported by echo'ing the number of the pwm channel to /sys/class/pwm/pwmchip0/export . This will create device /sys/class/pwm/pwmchip0/pwm0 in the filesystem. The easiest way to do this is by adding this to /etc/rc.local before the exit 0 line: # Enable pwmchip sysfs interface echo 0 > /sys/class/pwm/pwmchip0/export When using both PWM channels, the number of the second channel needs to be echo'd as well: # Enable pwmchip sysfs interface echo 0 > /sys/class/pwm/pwmchip0/export echo 1 > /sys/class/pwm/pwmchip0/export Avec le sysfs en place, vous pouvez maintenant utiliser l'un ou l'autre des canaux pwm en ajoutant la configuration suivante \u00e0 votre printer.cfg : [output_pin caselight] pin: host:pwmchip0/pwm0 pwm: True hardware_pwm: True cycle_time: 0.000001 [output_pin beeper] pin: host:pwmchip0/pwm1 pwm: True hardware_pwm: True value: 0 shutdown_value: 0 cycle_time: 0.0005 This will add hardware pwm control to gpio12 and gpio13 on the Pi (because the overlay was configured to route pwm0 to pin=12 and pwm1 to pin=13). PWM0 peut \u00eatre redirig\u00e9 vers gpio12 et gpio18, PWM1 peut \u00eatre redirig\u00e9 vers gpio13 et gpio19 : PWM (Modulation en Largeur d'Impulsion) Broche gpio Func 0 12 4 0 18 2 1 13 4 1 19 2","title":"Facultatif : PWM mat\u00e9riel"},{"location":"Releases.html","text":"Versions \u00b6 Historique de versions de Klipper. Merci de vous r\u00e9f\u00e9rer a la ressource installation pour plus d'information sur l'installation de Klipper. Klipper 0.11.0 \u00b6 Disponible le 28/11/2022. Changements majeurs dans cette version : Optimisation du pilote de moteur pas \u00e0 pas trinamic \"pas sur les deux c\u00f4t\u00e9s\" (\"step on both edges\"). Prise en charge de Python3. Le code h\u00f4te Klipper fonctionnera avec Python2 ou Python3. Prise en charge am\u00e9lior\u00e9e du bus CAN. Prise en charge du bus CAN sur les puces rp2040, stm32g0, stm32h7, same51 et same54. Prise en charge du mode \"pont USB vers bus CAN\". Prise en charge du chargeur de d\u00e9marrage CanBoot. Prise en charge des acc\u00e9l\u00e9rom\u00e8tres mpu9250 et mpu6050. Am\u00e9lioration de la gestion des erreurs pour les capteurs de temp\u00e9rature max31856, max31855, max31865 et max6675. Il est d\u00e9sormais possible de configurer les LED pour qu'elles se mettent \u00e0 jour pendant les longues commandes G-Code \u00e0 l'aide de la prise en charge du \"mod\u00e8le\" de LED. Plusieurs am\u00e9liorations sur le microcontr\u00f4leur. Nouvelle prise en charge des puces stm32h743, stm32h750, stm32l412, stm32g0b1, same70, same51 et same54. Prise en charge des lectures i2c sur atsamd et stm32f0. Prise en charge pwm mat\u00e9rielle sur stm32. Envoi d'\u00e9v\u00e9nements bas\u00e9 sur le signal Linux mcu. Nouveau support rp2040 pour \"make flash\", i2c et rp2040-e5 USB errata. Nouveaux modules ajout\u00e9s : angle, dac084S085, exclude_object, led, mpu9250, pca9632, smart_effector, z_thermal_adjust. Nouvelle cin\u00e9matique \"delt\u00e9sienne\" ajout\u00e9e. Nouvel outil dump_mcu ajout\u00e9. Plusieurs corrections de bogues et nettoyages de code. Klipper 0.10.0 \u00b6 Disponible le 29/09/2021. Changements majeurs dans cette version : Prise en charge de la mise \u00e0 l'origine \"Multi-MCU\". Il est d\u00e9sormais possible de c\u00e2bler un pilote de moteur pas \u00e0 pas et sa fin de course sur des microcontr\u00f4leurs s\u00e9par\u00e9s. Cela simplifie le c\u00e2blage des sondes Z sur les \"cartes de t\u00eate d'outil\". Klipper a maintenant un Serveur Discord et un Serveur Discourse . Le site Web de Klipper utilise d\u00e9sormais l'infrastructure \"mkdocs\". Il existe \u00e9galement un projet Klipper Translations . Prise en charge automatis\u00e9e du flash du micrologiciel via une carte SD sur de nombreuses cartes. Nouveau support cin\u00e9matique pour les imprimantes \"Hybrid CoreXY\" et \"Hybrid CoreXZ\". Klipper utilise maintenant rotation_distance pour configurer les distances de d\u00e9placement du moteur pas \u00e0 pas. Le code h\u00f4te principal de Klipper peut d\u00e9sormais communiquer directement avec les microcontr\u00f4leurs via le bus CAN. Nouveau syst\u00e8me \"d'analyse de mouvement\". Les mises \u00e0 jour des mouvements internes de Klipper et les r\u00e9sultats des capteurs peuvent \u00eatre suivis et enregistr\u00e9s pour analyse. Les pilotes de moteur pas \u00e0 pas Trinamic sont d\u00e9sormais surveill\u00e9s en permanence pour les conditions d'erreur. Prise en charge du microcontr\u00f4leur rp2040 (cartes Raspberry Pi Pico). Le syst\u00e8me \"make menuconfig\" utilise maintenant kconfiglib. De nombreux modules suppl\u00e9mentaires ajout\u00e9s : ds18b20, duplicate_pin_override, filament_motion_sensor, palette2, motion_report, pca9533, pulse_counter, save_variables, sdcard_loop, temperature_host, temperature_mcu Plusieurs corrections de bogues et nettoyages de code. Klipper 0.9.0 \u00b6 Disponible le 20/10/2020. Changements majeurs dans cette version : Prise en charge de l'\"Input Shaping\" - un m\u00e9canisme permettant de contrer la r\u00e9sonance de l'imprimante. Il peut r\u00e9duire ou \u00e9liminer les \"ondulations\" dans les impressions. Nouveau syst\u00e8me \"Smooth Pressure Advance\". Cela impl\u00e9mente \"Pressure Advance\" sans introduire de changements de vitesse instantan\u00e9s. Il est d\u00e9sormais possible de r\u00e9gler l'avance de pression \u00e0 l'aide d'une m\u00e9thode \"Tour de r\u00e9glage\". Nouveau serveur API \"webhooks\". Fournit une interface JSON programmable \u00e0 Klipper. L'\u00e9cran LCD et le menu sont d\u00e9sormais configurables \u00e0 l'aide du langage Jinja2. Les pilotes de moteur pas \u00e0 pas TMC2208 peuvent d\u00e9sormais \u00eatre utilis\u00e9s en mode \"standalone\" avec Klipper. Prise en charge am\u00e9lior\u00e9e du BL-Touch v3. Identification USB am\u00e9lior\u00e9e. Klipper dispose d\u00e9sormais de son propre code d'identification USB et les micro-contr\u00f4leurs peuvent d\u00e9sormais signaler leurs num\u00e9ros de s\u00e9rie lors de l'identification USB. Nouveau support cin\u00e9matique pour les imprimantes \"Rotary Delta\" et \"CoreXZ\". Am\u00e9liorations du microcontr\u00f4leur : prise en charge de stm32f070, prise en charge de stm32f207, prise en charge des broches GPIO sur \"Linux MCU\", prise en charge du \"chargeur de d\u00e9marrage HID\" stm32, prise en charge du chargeur de d\u00e9marrage Chitu, prise en charge du chargeur de d\u00e9marrage MKS Robin. Am\u00e9lioration de la gestion des \u00e9v\u00e9nements Python pour \"garbage collection\". Nombreux modules suppl\u00e9mentaires ajout\u00e9s : adc_scaled, adxl345, bme280, display_status, extruder_stepper, fan_generic, hall_filament_width_sensor, htu21d, homing_heaters, input_shaper, lm75, print_stats, resonance_tester, shaper_calibrate, query_adc, graph_accelerometer, graph_extruder, graph_motion, graph_shaper, graph_temp_sensor, whconsole Plusieurs corrections de bogues et nettoyages de code. Klipper 0.9.1 \u00b6 Disponible le 28/10/2020. Version contenant uniquement des corrections de bogues. Klipper 0.8.0 \u00b6 Disponible le 21/10/2019. Changements majeurs dans cette version : Prise en charge du nouveau mod\u00e8le de commande G-Code. Le G-Code dans le fichier de configuration est maintenant \u00e9valu\u00e9 avec le langage Jinja2. Am\u00e9liorations de la gestion des pilotes pas \u00e0 pas Trinamic : Nouvelle prise en charge pour les pilotes TMC2209 et TMC5160. Commandes G-Code DUMP_TMC, SET_TMC_CURRENT et INIT_TMC am\u00e9lior\u00e9es. Prise en charge am\u00e9lior\u00e9e de la gestion TMC UART avec un multiplexage analogique. Prise en charge am\u00e9lior\u00e9e de la mise \u00e0 l'origine, du sondage et de la mise \u00e0 niveau du lit : Nouveaux modules manual_probe, bed_screws, screw_tilt_adjust, skew_correction, safe_z_home ajout\u00e9s. Sondage multi-\u00e9chantillons am\u00e9lior\u00e9 avec une logique de m\u00e9diane, de moyenne et de nouvel essai. Documentation am\u00e9lior\u00e9e pour le BL-Touch, l'\u00e9talonnage de la sonde, l'\u00e9talonnage de la fin de course, l'\u00e9talonnage des imprimantes delta, la mise \u00e0 l'origine sans capteur et l'\u00e9talonnage de la phase de fin de course. Prise en charge am\u00e9lior\u00e9e de la mise \u00e0 l'origine sur un axe Z de grande taille. De nombreuses am\u00e9liorations du micro-contr\u00f4leur Klipper : Klipper port\u00e9 sur : SAM3X8C, SAM4S8C, SAMD51, STM32F042, STM32F4 Nouvelles impl\u00e9mentations des pilotes USB CDC sur SAM3X, SAM4, STM32F4. Prise en charge am\u00e9lior\u00e9e du flashage de Klipper via USB. Prise en charge du SPI logiciel. Filtrage de temp\u00e9rature grandement am\u00e9lior\u00e9 sur le capteur LPC176x. Les param\u00e8tres de d\u00e9marrage des broches de sortie peuvent \u00eatre configur\u00e9s dans le micro-contr\u00f4leur. Nouveau site web avec la documentation Klipper : http://klipper3d.org/ Klipper a maintenant un logo. Support exp\u00e9rimental pour la cin\u00e9matique polaire et \"treuil \u00e0 c\u00e2ble\". Le fichier de configuration peut maintenant inclure d'autres fichiers de configuration. De nombreux modules suppl\u00e9mentaires ajout\u00e9s : board_pins, controller_fan, delay_gcode, dotstar, filament_switch_sensor, firmware_retraction, gcode_arcs, gcode_button, heater_generic, manual_stepper, mcp4018, mcp4728, neopixel, pause_resume, respond, temperature_sensor tsl1401cl_filament_width_sensor, tuning_tower De nombreuses commandes suppl\u00e9mentaires ajout\u00e9es : RESTORE_GCODE_STATE, SAVE_GCODE_STATE, SET_GCODE_VARIABLE, SET_HEATER_TEMPERATURE, SET_IDLE_TIMEOUT, SET_TEMPERATURE_FAN_TARGET Plusieurs corrections de bogues et nettoyages de code. Klipper 0.7.0 \u00b6 Disponible le 20/12/2018. Changements majeurs dans cette version : Klipper prend d\u00e9sormais en charge le nivellement du lit par maillage Nouvel \u00e9talonnage des imprimantes delta \"am\u00e9lior\u00e9\" (\u00e9talonne les dimensions d'impression x/y sur les imprimantes delta) Gestion de la configuration pendant l'ex\u00e9cution des pilotes de moteur pas \u00e0 pas Trinamic (tmc2130, tmc2208, tmc2660) Prise en charge am\u00e9lior\u00e9e des capteurs de temp\u00e9rature : MAX6675, MAX31855, MAX31856, MAX31865, thermistances personnalis\u00e9es, capteurs de style pt100 Plusieurs nouveaux modules : temperature_fan, sx1509, force_move, mcp4451, z_tilt, quad_gantry_level, endstop_phase, bltouch Plusieurs nouvelles commandes ajout\u00e9es : SAVE_CONFIG, SET_PRESSURE_ADVANCE, SET_GCODE_OFFSET, SET_VELOCITY_LIMIT, STEPPER_BUZZ, TURN_OFF_HEATERS, M204, macros g-code personnalis\u00e9es Prise en charge \u00e9tendue de l'\u00e9cran LCD : Prise en charge des menus d'ex\u00e9cution Nouvelles ic\u00f4nes d'affichage Prise en charge des \u00e9crans \"uc1701\" et \"ssd1306\" Prise en charge de nouveaux micro-contr\u00f4leurs : Klipper port\u00e9 sur : LPC176x (Smoothieboards), SAM4E8E (Duet2), SAMD21 (Arduino Zero), STM32F103 (appareils \"Blue pill\"), atmega32u4 Nouveau pilote CDC USB g\u00e9n\u00e9rique impl\u00e9ment\u00e9 sur AVR, LPC176x, SAMD21 et STM32F103 Am\u00e9liorations des performances sur les processeurs ARM Le code cin\u00e9matique a \u00e9t\u00e9 r\u00e9\u00e9crit pour utiliser un \"solveur it\u00e9ratif\" Nouveaux tests automatis\u00e9s pour le logiciel h\u00f4te Klipper De nombreux nouveaux exemples de fichiers de configuration pour les imprimantes les plus courantes Mises \u00e0 jour de la documentation pour les chargeurs de d\u00e9marrage, l'analyse comparative, le portage des micro-contr\u00f4leurs, les v\u00e9rifications de configuration, le mappage des broches, les param\u00e8tres du trancheur, le packaging, et plus Plusieurs corrections de bogues et nettoyages de code Klipper 0.6.0 \u00b6 Disponible le 31/03/2018. Changements majeurs dans cette version : V\u00e9rifications am\u00e9lior\u00e9es des d\u00e9faillances mat\u00e9rielles des \u00e9l\u00e9ments chauffants et des thermistances Prise en charge des sondes Z Premi\u00e8re prise en charge de l'\u00e9talonnage automatique des param\u00e8tres sur les deltas (via une nouvelle commande delta_calibrate) Premi\u00e8re prise en charge de la compensation d'inclinaison du lit (via la commande bed_tilt_calibrate) Premi\u00e8re prise en charge de la \u00ab mise \u00e0 l'origine 's\u00fbre' \u00bb et des surcharges des mises \u00e0 l'origine Prise en charge de l'affichage de l'\u00e9tat sur les \u00e9crans RepRapDiscount style 2004 et 12864 Nouvelles am\u00e9liorations pour la multi-extrusion : Prise en charge des chauffages partag\u00e9s Prise en charge des chariots doubles (IDEX) Prise en charge de la configuration de plusieurs steppers par axe (par exemple, double Z) Prise en charge des broches de sortie num\u00e9riques et pwm personnalis\u00e9es (avec une nouvelle commande SET_PIN) Prise en charge d'une \"carte SD virtuelle\" qui permet d'imprimer directement depuis Klipper (aide sur les machines trop lentes pour bien ex\u00e9cuter OctoPrint) Prise en charge du r\u00e9glage de diff\u00e9rentes longueurs de bras sur chaque tour d'une delta Prise en charge des commandes G-Code M220/M221 (remplacement du facteur de vitesse/remplacement du facteur d'extrusion) Plusieurs mises \u00e0 jour de la documentation : De nombreux nouveaux exemples de fichiers de configuration pour les imprimantes les plus courantes Nouvel exemple de configuration multi-MCU Nouvel exemple de configuration du capteur bltouch Nouveaux documents sur la FAQ, la v\u00e9rification de la configuration et le G-Code Prise en charge des tests d'int\u00e9gration continue sur tous les commits github Plusieurs corrections de bogues et nettoyages de code Klipper 0.5.0 \u00b6 Disponible le 25/10/2017. Changements majeurs dans cette version : Prise en charge des imprimantes avec plusieurs extrudeuses. Prise en charge pour l'ex\u00e9cution sur le PRU Beaglebone. Prise en charge de la carte Replicape. Prise en charge de l'ex\u00e9cution du code du microcontr\u00f4leur dans un processus Linux en temps r\u00e9el. Prise en charge de plusieurs microcontr\u00f4leurs. (Par exemple, on pourrait contr\u00f4ler une extrudeuse avec un microcontr\u00f4leur et le reste de l'imprimante avec un autre.) Une synchronisation d'horloge logicielle est mise en \u0153uvre pour coordonner les actions entre les microcontr\u00f4leurs. Am\u00e9liorations des performances des moteurs pas \u00e0 pas (AVR 20Mhz jusqu'\u00e0 189K pas par seconde). Prise en charge du contr\u00f4le des servos et prise en charge de la d\u00e9finition des ventilateurs de refroidissement des buses. Plusieurs corrections de bogues et nettoyages de code Klipper 0.4.0 \u00b6 Disponible le 03/05/2017. Changements majeurs dans cette version : Installation am\u00e9lior\u00e9e sur les machines Raspberry Pi. La majeure partie de l'installation est maintenant script\u00e9e. Prise en charge des imprimantes corexy Mises \u00e0 jour de la documentation : nouveau document cin\u00e9matique, nouveau guide de r\u00e9glage Pressure Advance, nouveaux exemples de fichiers de configuration, et plus Am\u00e9liorations des performances des moteurs pas \u00e0 pas (AVR 20Mhz sur 175K pas par seconde, Arduino Due sur 460K) Prise en charge des r\u00e9initialisations automatiques du microcontr\u00f4leur. Prise en charge des r\u00e9initialisations via basculement de l'alimentation USB sur Raspberry Pi. L'algorithme d'avance de pression fonctionne d\u00e9sormais avec anticipation pour r\u00e9duire les changements de pression dans les virages. Prise en charge de la limitation de la vitesse maximale des mouvements courts en zigzag Prise en charge des capteurs AD595 Plusieurs corrections de bogues et nettoyages de code Klipper 0.3.0 \u00b6 Disponible le 23/12/2016. Changements majeurs dans cette version : Documentation am\u00e9lior\u00e9e Prise en charge des imprimantes avec cin\u00e9matique delta Prise en charge du microcontr\u00f4leur Arduino Due (ARM cortex-M3) Prise en charge des microcontr\u00f4leurs AVR bas\u00e9s sur USB Prise en charge de l'algorithme \"d'avance de pression\" - il r\u00e9duit le suintement pendant les impressions. Nouvelle fonctionnalit\u00e9 \"but\u00e9e de fin de course bas\u00e9e sur la phase de moteurs pas \u00e0 pas\" - permet une plus grande pr\u00e9cision sur la prise d'origine de la fin de course. Prise en charge des commandes \"g-code \u00e9tendu\" telles que \"help\", \"restart\" et \"status\". Prise en charge du rechargement de la configuration Klipper et du red\u00e9marrage du logiciel h\u00f4te en \u00e9mettant une commande \"restart\" depuis le terminal. Am\u00e9liorations des performances des moteurs pas \u00e0 pas (AVR 20Mhz jusqu'\u00e0 158K pas par seconde). Gestion des erreurs am\u00e9lior\u00e9e. La plupart des erreurs sont maintenant affich\u00e9es via le terminal avec une aide sur la fa\u00e7on de les r\u00e9soudre. Plusieurs corrections de bogues et nettoyages de code Klipper 0.2.0 \u00b6 Premi\u00e8re version de Klipper. Disponible le 25/05/2016. Les principales fonctionnalit\u00e9s disponibles dans la version initiale incluent : Prise en charge de base des imprimantes cart\u00e9siennes (moteurs pas \u00e0 pas, extrudeur, lit chauffant, ventilateur de refroidissement). Prise en charge des commandes g-code de base. Prise en charge de l'interfa\u00e7age avec OctoPrint. Acc\u00e9l\u00e9ration et gestion de l'anticipation Prise en charge des microcontr\u00f4leurs AVR via des ports s\u00e9rie standard","title":"Versions"},{"location":"Releases.html#versions","text":"Historique de versions de Klipper. Merci de vous r\u00e9f\u00e9rer a la ressource installation pour plus d'information sur l'installation de Klipper.","title":"Versions"},{"location":"Releases.html#klipper-0110","text":"Disponible le 28/11/2022. Changements majeurs dans cette version : Optimisation du pilote de moteur pas \u00e0 pas trinamic \"pas sur les deux c\u00f4t\u00e9s\" (\"step on both edges\"). Prise en charge de Python3. Le code h\u00f4te Klipper fonctionnera avec Python2 ou Python3. Prise en charge am\u00e9lior\u00e9e du bus CAN. Prise en charge du bus CAN sur les puces rp2040, stm32g0, stm32h7, same51 et same54. Prise en charge du mode \"pont USB vers bus CAN\". Prise en charge du chargeur de d\u00e9marrage CanBoot. Prise en charge des acc\u00e9l\u00e9rom\u00e8tres mpu9250 et mpu6050. Am\u00e9lioration de la gestion des erreurs pour les capteurs de temp\u00e9rature max31856, max31855, max31865 et max6675. Il est d\u00e9sormais possible de configurer les LED pour qu'elles se mettent \u00e0 jour pendant les longues commandes G-Code \u00e0 l'aide de la prise en charge du \"mod\u00e8le\" de LED. Plusieurs am\u00e9liorations sur le microcontr\u00f4leur. Nouvelle prise en charge des puces stm32h743, stm32h750, stm32l412, stm32g0b1, same70, same51 et same54. Prise en charge des lectures i2c sur atsamd et stm32f0. Prise en charge pwm mat\u00e9rielle sur stm32. Envoi d'\u00e9v\u00e9nements bas\u00e9 sur le signal Linux mcu. Nouveau support rp2040 pour \"make flash\", i2c et rp2040-e5 USB errata. Nouveaux modules ajout\u00e9s : angle, dac084S085, exclude_object, led, mpu9250, pca9632, smart_effector, z_thermal_adjust. Nouvelle cin\u00e9matique \"delt\u00e9sienne\" ajout\u00e9e. Nouvel outil dump_mcu ajout\u00e9. Plusieurs corrections de bogues et nettoyages de code.","title":"Klipper 0.11.0"},{"location":"Releases.html#klipper-0100","text":"Disponible le 29/09/2021. Changements majeurs dans cette version : Prise en charge de la mise \u00e0 l'origine \"Multi-MCU\". Il est d\u00e9sormais possible de c\u00e2bler un pilote de moteur pas \u00e0 pas et sa fin de course sur des microcontr\u00f4leurs s\u00e9par\u00e9s. Cela simplifie le c\u00e2blage des sondes Z sur les \"cartes de t\u00eate d'outil\". Klipper a maintenant un Serveur Discord et un Serveur Discourse . Le site Web de Klipper utilise d\u00e9sormais l'infrastructure \"mkdocs\". Il existe \u00e9galement un projet Klipper Translations . Prise en charge automatis\u00e9e du flash du micrologiciel via une carte SD sur de nombreuses cartes. Nouveau support cin\u00e9matique pour les imprimantes \"Hybrid CoreXY\" et \"Hybrid CoreXZ\". Klipper utilise maintenant rotation_distance pour configurer les distances de d\u00e9placement du moteur pas \u00e0 pas. Le code h\u00f4te principal de Klipper peut d\u00e9sormais communiquer directement avec les microcontr\u00f4leurs via le bus CAN. Nouveau syst\u00e8me \"d'analyse de mouvement\". Les mises \u00e0 jour des mouvements internes de Klipper et les r\u00e9sultats des capteurs peuvent \u00eatre suivis et enregistr\u00e9s pour analyse. Les pilotes de moteur pas \u00e0 pas Trinamic sont d\u00e9sormais surveill\u00e9s en permanence pour les conditions d'erreur. Prise en charge du microcontr\u00f4leur rp2040 (cartes Raspberry Pi Pico). Le syst\u00e8me \"make menuconfig\" utilise maintenant kconfiglib. De nombreux modules suppl\u00e9mentaires ajout\u00e9s : ds18b20, duplicate_pin_override, filament_motion_sensor, palette2, motion_report, pca9533, pulse_counter, save_variables, sdcard_loop, temperature_host, temperature_mcu Plusieurs corrections de bogues et nettoyages de code.","title":"Klipper 0.10.0"},{"location":"Releases.html#klipper-090","text":"Disponible le 20/10/2020. Changements majeurs dans cette version : Prise en charge de l'\"Input Shaping\" - un m\u00e9canisme permettant de contrer la r\u00e9sonance de l'imprimante. Il peut r\u00e9duire ou \u00e9liminer les \"ondulations\" dans les impressions. Nouveau syst\u00e8me \"Smooth Pressure Advance\". Cela impl\u00e9mente \"Pressure Advance\" sans introduire de changements de vitesse instantan\u00e9s. Il est d\u00e9sormais possible de r\u00e9gler l'avance de pression \u00e0 l'aide d'une m\u00e9thode \"Tour de r\u00e9glage\". Nouveau serveur API \"webhooks\". Fournit une interface JSON programmable \u00e0 Klipper. L'\u00e9cran LCD et le menu sont d\u00e9sormais configurables \u00e0 l'aide du langage Jinja2. Les pilotes de moteur pas \u00e0 pas TMC2208 peuvent d\u00e9sormais \u00eatre utilis\u00e9s en mode \"standalone\" avec Klipper. Prise en charge am\u00e9lior\u00e9e du BL-Touch v3. Identification USB am\u00e9lior\u00e9e. Klipper dispose d\u00e9sormais de son propre code d'identification USB et les micro-contr\u00f4leurs peuvent d\u00e9sormais signaler leurs num\u00e9ros de s\u00e9rie lors de l'identification USB. Nouveau support cin\u00e9matique pour les imprimantes \"Rotary Delta\" et \"CoreXZ\". Am\u00e9liorations du microcontr\u00f4leur : prise en charge de stm32f070, prise en charge de stm32f207, prise en charge des broches GPIO sur \"Linux MCU\", prise en charge du \"chargeur de d\u00e9marrage HID\" stm32, prise en charge du chargeur de d\u00e9marrage Chitu, prise en charge du chargeur de d\u00e9marrage MKS Robin. Am\u00e9lioration de la gestion des \u00e9v\u00e9nements Python pour \"garbage collection\". Nombreux modules suppl\u00e9mentaires ajout\u00e9s : adc_scaled, adxl345, bme280, display_status, extruder_stepper, fan_generic, hall_filament_width_sensor, htu21d, homing_heaters, input_shaper, lm75, print_stats, resonance_tester, shaper_calibrate, query_adc, graph_accelerometer, graph_extruder, graph_motion, graph_shaper, graph_temp_sensor, whconsole Plusieurs corrections de bogues et nettoyages de code.","title":"Klipper 0.9.0"},{"location":"Releases.html#klipper-091","text":"Disponible le 28/10/2020. Version contenant uniquement des corrections de bogues.","title":"Klipper 0.9.1"},{"location":"Releases.html#klipper-080","text":"Disponible le 21/10/2019. Changements majeurs dans cette version : Prise en charge du nouveau mod\u00e8le de commande G-Code. Le G-Code dans le fichier de configuration est maintenant \u00e9valu\u00e9 avec le langage Jinja2. Am\u00e9liorations de la gestion des pilotes pas \u00e0 pas Trinamic : Nouvelle prise en charge pour les pilotes TMC2209 et TMC5160. Commandes G-Code DUMP_TMC, SET_TMC_CURRENT et INIT_TMC am\u00e9lior\u00e9es. Prise en charge am\u00e9lior\u00e9e de la gestion TMC UART avec un multiplexage analogique. Prise en charge am\u00e9lior\u00e9e de la mise \u00e0 l'origine, du sondage et de la mise \u00e0 niveau du lit : Nouveaux modules manual_probe, bed_screws, screw_tilt_adjust, skew_correction, safe_z_home ajout\u00e9s. Sondage multi-\u00e9chantillons am\u00e9lior\u00e9 avec une logique de m\u00e9diane, de moyenne et de nouvel essai. Documentation am\u00e9lior\u00e9e pour le BL-Touch, l'\u00e9talonnage de la sonde, l'\u00e9talonnage de la fin de course, l'\u00e9talonnage des imprimantes delta, la mise \u00e0 l'origine sans capteur et l'\u00e9talonnage de la phase de fin de course. Prise en charge am\u00e9lior\u00e9e de la mise \u00e0 l'origine sur un axe Z de grande taille. De nombreuses am\u00e9liorations du micro-contr\u00f4leur Klipper : Klipper port\u00e9 sur : SAM3X8C, SAM4S8C, SAMD51, STM32F042, STM32F4 Nouvelles impl\u00e9mentations des pilotes USB CDC sur SAM3X, SAM4, STM32F4. Prise en charge am\u00e9lior\u00e9e du flashage de Klipper via USB. Prise en charge du SPI logiciel. Filtrage de temp\u00e9rature grandement am\u00e9lior\u00e9 sur le capteur LPC176x. Les param\u00e8tres de d\u00e9marrage des broches de sortie peuvent \u00eatre configur\u00e9s dans le micro-contr\u00f4leur. Nouveau site web avec la documentation Klipper : http://klipper3d.org/ Klipper a maintenant un logo. Support exp\u00e9rimental pour la cin\u00e9matique polaire et \"treuil \u00e0 c\u00e2ble\". Le fichier de configuration peut maintenant inclure d'autres fichiers de configuration. De nombreux modules suppl\u00e9mentaires ajout\u00e9s : board_pins, controller_fan, delay_gcode, dotstar, filament_switch_sensor, firmware_retraction, gcode_arcs, gcode_button, heater_generic, manual_stepper, mcp4018, mcp4728, neopixel, pause_resume, respond, temperature_sensor tsl1401cl_filament_width_sensor, tuning_tower De nombreuses commandes suppl\u00e9mentaires ajout\u00e9es : RESTORE_GCODE_STATE, SAVE_GCODE_STATE, SET_GCODE_VARIABLE, SET_HEATER_TEMPERATURE, SET_IDLE_TIMEOUT, SET_TEMPERATURE_FAN_TARGET Plusieurs corrections de bogues et nettoyages de code.","title":"Klipper 0.8.0"},{"location":"Releases.html#klipper-070","text":"Disponible le 20/12/2018. Changements majeurs dans cette version : Klipper prend d\u00e9sormais en charge le nivellement du lit par maillage Nouvel \u00e9talonnage des imprimantes delta \"am\u00e9lior\u00e9\" (\u00e9talonne les dimensions d'impression x/y sur les imprimantes delta) Gestion de la configuration pendant l'ex\u00e9cution des pilotes de moteur pas \u00e0 pas Trinamic (tmc2130, tmc2208, tmc2660) Prise en charge am\u00e9lior\u00e9e des capteurs de temp\u00e9rature : MAX6675, MAX31855, MAX31856, MAX31865, thermistances personnalis\u00e9es, capteurs de style pt100 Plusieurs nouveaux modules : temperature_fan, sx1509, force_move, mcp4451, z_tilt, quad_gantry_level, endstop_phase, bltouch Plusieurs nouvelles commandes ajout\u00e9es : SAVE_CONFIG, SET_PRESSURE_ADVANCE, SET_GCODE_OFFSET, SET_VELOCITY_LIMIT, STEPPER_BUZZ, TURN_OFF_HEATERS, M204, macros g-code personnalis\u00e9es Prise en charge \u00e9tendue de l'\u00e9cran LCD : Prise en charge des menus d'ex\u00e9cution Nouvelles ic\u00f4nes d'affichage Prise en charge des \u00e9crans \"uc1701\" et \"ssd1306\" Prise en charge de nouveaux micro-contr\u00f4leurs : Klipper port\u00e9 sur : LPC176x (Smoothieboards), SAM4E8E (Duet2), SAMD21 (Arduino Zero), STM32F103 (appareils \"Blue pill\"), atmega32u4 Nouveau pilote CDC USB g\u00e9n\u00e9rique impl\u00e9ment\u00e9 sur AVR, LPC176x, SAMD21 et STM32F103 Am\u00e9liorations des performances sur les processeurs ARM Le code cin\u00e9matique a \u00e9t\u00e9 r\u00e9\u00e9crit pour utiliser un \"solveur it\u00e9ratif\" Nouveaux tests automatis\u00e9s pour le logiciel h\u00f4te Klipper De nombreux nouveaux exemples de fichiers de configuration pour les imprimantes les plus courantes Mises \u00e0 jour de la documentation pour les chargeurs de d\u00e9marrage, l'analyse comparative, le portage des micro-contr\u00f4leurs, les v\u00e9rifications de configuration, le mappage des broches, les param\u00e8tres du trancheur, le packaging, et plus Plusieurs corrections de bogues et nettoyages de code","title":"Klipper 0.7.0"},{"location":"Releases.html#klipper-060","text":"Disponible le 31/03/2018. Changements majeurs dans cette version : V\u00e9rifications am\u00e9lior\u00e9es des d\u00e9faillances mat\u00e9rielles des \u00e9l\u00e9ments chauffants et des thermistances Prise en charge des sondes Z Premi\u00e8re prise en charge de l'\u00e9talonnage automatique des param\u00e8tres sur les deltas (via une nouvelle commande delta_calibrate) Premi\u00e8re prise en charge de la compensation d'inclinaison du lit (via la commande bed_tilt_calibrate) Premi\u00e8re prise en charge de la \u00ab mise \u00e0 l'origine 's\u00fbre' \u00bb et des surcharges des mises \u00e0 l'origine Prise en charge de l'affichage de l'\u00e9tat sur les \u00e9crans RepRapDiscount style 2004 et 12864 Nouvelles am\u00e9liorations pour la multi-extrusion : Prise en charge des chauffages partag\u00e9s Prise en charge des chariots doubles (IDEX) Prise en charge de la configuration de plusieurs steppers par axe (par exemple, double Z) Prise en charge des broches de sortie num\u00e9riques et pwm personnalis\u00e9es (avec une nouvelle commande SET_PIN) Prise en charge d'une \"carte SD virtuelle\" qui permet d'imprimer directement depuis Klipper (aide sur les machines trop lentes pour bien ex\u00e9cuter OctoPrint) Prise en charge du r\u00e9glage de diff\u00e9rentes longueurs de bras sur chaque tour d'une delta Prise en charge des commandes G-Code M220/M221 (remplacement du facteur de vitesse/remplacement du facteur d'extrusion) Plusieurs mises \u00e0 jour de la documentation : De nombreux nouveaux exemples de fichiers de configuration pour les imprimantes les plus courantes Nouvel exemple de configuration multi-MCU Nouvel exemple de configuration du capteur bltouch Nouveaux documents sur la FAQ, la v\u00e9rification de la configuration et le G-Code Prise en charge des tests d'int\u00e9gration continue sur tous les commits github Plusieurs corrections de bogues et nettoyages de code","title":"Klipper 0.6.0"},{"location":"Releases.html#klipper-050","text":"Disponible le 25/10/2017. Changements majeurs dans cette version : Prise en charge des imprimantes avec plusieurs extrudeuses. Prise en charge pour l'ex\u00e9cution sur le PRU Beaglebone. Prise en charge de la carte Replicape. Prise en charge de l'ex\u00e9cution du code du microcontr\u00f4leur dans un processus Linux en temps r\u00e9el. Prise en charge de plusieurs microcontr\u00f4leurs. (Par exemple, on pourrait contr\u00f4ler une extrudeuse avec un microcontr\u00f4leur et le reste de l'imprimante avec un autre.) Une synchronisation d'horloge logicielle est mise en \u0153uvre pour coordonner les actions entre les microcontr\u00f4leurs. Am\u00e9liorations des performances des moteurs pas \u00e0 pas (AVR 20Mhz jusqu'\u00e0 189K pas par seconde). Prise en charge du contr\u00f4le des servos et prise en charge de la d\u00e9finition des ventilateurs de refroidissement des buses. Plusieurs corrections de bogues et nettoyages de code","title":"Klipper 0.5.0"},{"location":"Releases.html#klipper-040","text":"Disponible le 03/05/2017. Changements majeurs dans cette version : Installation am\u00e9lior\u00e9e sur les machines Raspberry Pi. La majeure partie de l'installation est maintenant script\u00e9e. Prise en charge des imprimantes corexy Mises \u00e0 jour de la documentation : nouveau document cin\u00e9matique, nouveau guide de r\u00e9glage Pressure Advance, nouveaux exemples de fichiers de configuration, et plus Am\u00e9liorations des performances des moteurs pas \u00e0 pas (AVR 20Mhz sur 175K pas par seconde, Arduino Due sur 460K) Prise en charge des r\u00e9initialisations automatiques du microcontr\u00f4leur. Prise en charge des r\u00e9initialisations via basculement de l'alimentation USB sur Raspberry Pi. L'algorithme d'avance de pression fonctionne d\u00e9sormais avec anticipation pour r\u00e9duire les changements de pression dans les virages. Prise en charge de la limitation de la vitesse maximale des mouvements courts en zigzag Prise en charge des capteurs AD595 Plusieurs corrections de bogues et nettoyages de code","title":"Klipper 0.4.0"},{"location":"Releases.html#klipper-030","text":"Disponible le 23/12/2016. Changements majeurs dans cette version : Documentation am\u00e9lior\u00e9e Prise en charge des imprimantes avec cin\u00e9matique delta Prise en charge du microcontr\u00f4leur Arduino Due (ARM cortex-M3) Prise en charge des microcontr\u00f4leurs AVR bas\u00e9s sur USB Prise en charge de l'algorithme \"d'avance de pression\" - il r\u00e9duit le suintement pendant les impressions. Nouvelle fonctionnalit\u00e9 \"but\u00e9e de fin de course bas\u00e9e sur la phase de moteurs pas \u00e0 pas\" - permet une plus grande pr\u00e9cision sur la prise d'origine de la fin de course. Prise en charge des commandes \"g-code \u00e9tendu\" telles que \"help\", \"restart\" et \"status\". Prise en charge du rechargement de la configuration Klipper et du red\u00e9marrage du logiciel h\u00f4te en \u00e9mettant une commande \"restart\" depuis le terminal. Am\u00e9liorations des performances des moteurs pas \u00e0 pas (AVR 20Mhz jusqu'\u00e0 158K pas par seconde). Gestion des erreurs am\u00e9lior\u00e9e. La plupart des erreurs sont maintenant affich\u00e9es via le terminal avec une aide sur la fa\u00e7on de les r\u00e9soudre. Plusieurs corrections de bogues et nettoyages de code","title":"Klipper 0.3.0"},{"location":"Releases.html#klipper-020","text":"Premi\u00e8re version de Klipper. Disponible le 25/05/2016. Les principales fonctionnalit\u00e9s disponibles dans la version initiale incluent : Prise en charge de base des imprimantes cart\u00e9siennes (moteurs pas \u00e0 pas, extrudeur, lit chauffant, ventilateur de refroidissement). Prise en charge des commandes g-code de base. Prise en charge de l'interfa\u00e7age avec OctoPrint. Acc\u00e9l\u00e9ration et gestion de l'anticipation Prise en charge des microcontr\u00f4leurs AVR via des ports s\u00e9rie standard","title":"Klipper 0.2.0"},{"location":"Resonance_Compensation.html","text":"Compensation de la r\u00e9sonance \u00b6 Klipper prend en charge l'\"input shaping\", une technique utilis\u00e9e pour r\u00e9duire l'effet de r\u00e9sonance (\u00e9galement connu sous le nom d'\u00e9cho, d'image fant\u00f4me - \"ghosting\" - ou d'ondulation - \"ringing\") dans les impressions. La r\u00e9sonance est un d\u00e9faut d'impression de surface lorsque des \u00e9l\u00e9ments tels que des bords se r\u00e9p\u00e8tent sous la forme d'un l\u00e9ger \"\u00e9cho\" : | | | La r\u00e9sonance est caus\u00e9e par des vibrations m\u00e9caniques dans l'imprimante dues \u00e0 des changements rapides de direction pendant l'impression. La r\u00e9sonance a g\u00e9n\u00e9ralement des origines m\u00e9caniques : cadre de l'imprimante insuffisamment rigide, courroies non tendues ou trop \u00e9lastiques, probl\u00e8mes d'alignement des pi\u00e8ces m\u00e9caniques, masse mobile importante, etc. Ces probl\u00e8mes doivent \u00eatre v\u00e9rifi\u00e9s et corrig\u00e9s en premier lieu, si possible. L' input shaping est une technique de contr\u00f4le en boucle ouverte qui cr\u00e9e un signal de commande annulant ses propres vibrations. L'input shaping n\u00e9cessite quelques r\u00e9glages et mesures avant de pouvoir \u00eatre activ\u00e9e. Outre la r\u00e9sonance, l'input shaping r\u00e9duit aussi les vibrations et les secousses de l'imprimante en g\u00e9n\u00e9ral, et peut \u00e9galement am\u00e9liorer la fiabilit\u00e9 du mode stealthChop des pilotes Trinamic. R\u00e9glages \u00b6 Le r\u00e9glage de base n\u00e9cessite de mesurer les fr\u00e9quences de r\u00e9sonance de l'imprimante en imprimant un mod\u00e8le de test. Tranchez le mod\u00e8le de test de r\u00e9sonance, qui se trouve dans docs/prints/ringing_tower.stl , avec votre trancheur : La hauteur de couche recommand\u00e9e est de 0,2 ou 0,25 mm. Le remplissage et le nombre de couches sup\u00e9rieures peuvent \u00eatre r\u00e9gl\u00e9s sur 0. Utilisez 1 ou 2 parois, ou mieux encore le mode vase avec une base de 1 ou 2 mm. Utilisez une vitesse suffisamment \u00e9lev\u00e9e, entre 80 et 100 mm/s, pour les parois externes . Veillez \u00e0 ce que le temps minimum par couche soit au maximum de 3 secondes. Assurez-vous que toutes les options de \"contr\u00f4le d'acc\u00e9l\u00e9ration\" soient bien d\u00e9sactiv\u00e9es dans le trancheur. Ne tournez pas le mod\u00e8le. Le mod\u00e8le comporte des marques X et Y \u00e0 l'arri\u00e8re du mod\u00e8le. L'emplacement inhabituel des marques par rapport aux axes de l'imprimante n'est pas une erreur. Ces marques pourront \u00eatre utilis\u00e9es plus tard - comme r\u00e9f\u00e9rence - dans le processus de r\u00e9glage, car elles indiquent \u00e0 quel axe correspondent les mesures. Fr\u00e9quence de r\u00e9sonance \u00b6 En premier lieu, mesurez la fr\u00e9quence de r\u00e9sonance . Si le param\u00e8tre square_corner_velocity a \u00e9t\u00e9 modifi\u00e9, remettez-le \u00e0 5.0. Il n'est pas conseill\u00e9 de l'augmenter lors de l'utilisation de l'input shaper car cela peut provoquer plus de lissage dans les pi\u00e8ces - il est pr\u00e9f\u00e9rable d'utiliser une valeur d'acc\u00e9l\u00e9ration plus \u00e9lev\u00e9e \u00e0 la place. Augmentez max_accel_to_decel en lan\u00e7ant la commande suivante : SET_VELOCITY_LIMIT ACCEL_TO_DECEL=7000 D\u00e9sactivez l'avance de pression : SET_PRESSURE_ADVANCE ADVANCE=0 Si vous avez d\u00e9j\u00e0 ajout\u00e9 la section [input_shaper] au fichier printer.cfg, ex\u00e9cutez la commande SET_INPUT_SHAPER SHAPER_FREQ_X=0 SHAPER_FREQ_Y=0 . Si vous obtenez l'erreur \"Unknown command\", vous pouvez l'ignorer - pour le moment - et continuer les mesures. Ex\u00e9cutez la commande : TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 Dans la pratique, nous essayons de rendre la r\u00e9sonance plus prononc\u00e9e en d\u00e9finissant diff\u00e9rentes valeurs \u00e9lev\u00e9es pour l'acc\u00e9l\u00e9ration. Cette commande augmentera l'acc\u00e9l\u00e9ration tous les 5 mm \u00e0 partir de 1500 mm/sec\u00b2 : 1500 mm/sec\u00b2, 2000 mm/sec\u00b2, 2500 mm/sec\u00b2 et ainsi de suite jusqu'\u00e0 7000 mm/sec\u00b2 pour la derni\u00e8re bande. Imprimez le mod\u00e8le de test tranch\u00e9 avec les param\u00e8tres indiqu\u00e9s. Vous pouvez arr\u00eater l'impression avant la fin si la r\u00e9sonance est clairement visible et si vous constatez que l'acc\u00e9l\u00e9ration devient trop forte pour votre imprimante (par exemple, l'imprimante tremble trop ou commence \u00e0 sauter des pas). Utilisez les marques X et Y \u00e0 l'arri\u00e8re du mod\u00e8le comme r\u00e9f\u00e9rence. Les mesures du c\u00f4t\u00e9 avec la marque X doivent \u00eatre utilis\u00e9es pour la configuration de l'axe X, et les mesures du c\u00f4t\u00e9 avec la marque Y pour la configuration de l'axe Y. Mesurez la distance D (en mm) entre plusieurs oscillations sur la partie de la pi\u00e8ce avec la marque X, pr\u00e8s des encoches et en sautant de pr\u00e9f\u00e9rence la ou les deux premi\u00e8res oscillations. Pour mesurer plus facilement la distance entre les oscillations, marquez d'abord les oscillations, puis mesurez la distance entre les marques avec une r\u00e8gle ou un pied \u00e0 coulisse :| | | Comptez le nombre d'oscillations N correspondant \u00e0 la distance mesur\u00e9e D . Si vous ne savez pas comment compter les oscillations, reportez-vous \u00e0 l'image ci-dessus, qui montre N = 6 oscillations. Calculez la fr\u00e9quence de r\u00e9sonance de l'axe X : V \u00b7 N / D (Hz), o\u00f9 V est la vitesse des p\u00e9rim\u00e8tres ext\u00e9rieurs (mm/s). Pour l'exemple ci-dessus, nous avons marqu\u00e9 6 oscillations (N) sur une distance de 12,14 mm (D), et le test a \u00e9t\u00e9 imprim\u00e9 \u00e0 une vitesse de 100 mm/s (V), donc la fr\u00e9quence est 100 * 6 / 12,14 \u2248 49,4 Hz. Faites (8) - (10) pour la marque Y \u00e9galement. Notez que la r\u00e9sonance sur l'impression de test devrait suivre les encoches courb\u00e9es de la pi\u00e8ce, comme dans l'image ci-dessus. Si ce n'est pas le cas, alors ce d\u00e9faut n'est pas vraiment une r\u00e9sonance et a probablement une origine diff\u00e9rente - soit m\u00e9canique, soit un probl\u00e8me d'extrudeuse. Ce probl\u00e8me doit \u00eatre r\u00e9solu avant d'activer et de r\u00e9gler les input shapers. Si les mesures ne sont pas fiables parce que, par exemple, la distance entre les oscillations n'est pas r\u00e9guli\u00e8re, cela peut signifier que l'imprimante a plusieurs fr\u00e9quences de r\u00e9sonance sur le m\u00eame axe. On peut essayer de suivre le processus de r\u00e9glage d\u00e9crit dans la section Mesures peu fiables des fr\u00e9quences de r\u00e9sonance \u00e0 la place et obtenir quand m\u00eame une am\u00e9lioration gr\u00e2ce \u00e0 l'input shaping. La fr\u00e9quence de r\u00e9sonance peut d\u00e9pendre de la position du mod\u00e8le sur le plateau et de la hauteur Z, surtout sur les imprimantes delta ; vous pouvez v\u00e9rifier si vous observez des diff\u00e9rences de fr\u00e9quences \u00e0 diff\u00e9rentes positions le long des c\u00f4t\u00e9s du mod\u00e8le de test et \u00e0 diff\u00e9rentes hauteurs. Si c'est le cas, vous pouvez calculer les fr\u00e9quences de r\u00e9sonance moyennes sur les axes X et Y. Si la fr\u00e9quence de r\u00e9sonance mesur\u00e9e est tr\u00e8s basse (inf\u00e9rieure \u00e0 20-25 Hz), il peut \u00eatre judicieux de penser \u00e0 rigidifier la structure de l'imprimante ou \u00e0 r\u00e9duire la masse mobile - dans la mesure du possible - avant de poursuivre le r\u00e9glage de l'input shaping et de mesurer \u00e0 nouveau les fr\u00e9quences. Pour de nombreux mod\u00e8les d'imprimantes populaires, il existe souvent des solutions d\u00e9j\u00e0 disponibles. Les fr\u00e9quences de r\u00e9sonance peuvent changer si des modifications sont apport\u00e9es \u00e0 l'imprimante qui affectent la masse en mouvement ou modifient la rigidit\u00e9 du syst\u00e8me, par exemple : Si la t\u00eate d'impression est modifi\u00e9e, par ex. changement de moteur pas \u00e0 pas (plus lourd ou plus l\u00e9ger) pour une extrusion directe, remplacement de la t\u00eate de l'outil (plus ou moins lourde), ajout d'un ventilateur plus lourd, etc. La tension des courroies a \u00e9t\u00e9 modifi\u00e9e. Des pi\u00e8ces con\u00e7ues pour augmenter la rigidit\u00e9 du cadre sont install\u00e9es. Un plateau diff\u00e9rent est install\u00e9 sur une imprimante \u00e0 lit mobile, ou une plaque de verre est ajout\u00e9e, etc. Si de telles modifications sont apport\u00e9es, Il est conseill\u00e9 - au minimum - de mesurer les fr\u00e9quences de r\u00e9sonance pour v\u00e9rifier s'il elles ont chang\u00e9es (ou pas). Configuration de l'input shaper \u00b6 Une fois les fr\u00e9quences de r\u00e9sonance des axes X et Y mesur\u00e9es, vous pouvez ajouter la section suivante \u00e0 votre fichier printer.cfg : [input_shaper] shaper_freq_x: ... # frequence pour la marque X sur le mod\u00e8le de test shaper_freq_y: ... # frequence pour la marque Y sur le mod\u00e8le de test Pour l'exemple ci-dessus, nous obtenons shaper_freq_x/y = 49,4. Choix de l'input shaper \u00b6 Klipper prend en charge plusieurs type d'\"input shaper\". Ils diff\u00e8rent par leur sensibilit\u00e9 aux erreurs d\u00e9terminant la fr\u00e9quence de r\u00e9sonance et le degr\u00e9 de lissage qu'ils provoquent dans les pi\u00e8ces imprim\u00e9es. De plus, certains de ces \"input shaper\" comme 2HUMP_EI et 3HUMP_EI ne doivent g\u00e9n\u00e9ralement pas \u00eatre utilis\u00e9s avec shaper_freq = fr\u00e9quence de r\u00e9sonance - ils sont configur\u00e9s \u00e0 partir de diff\u00e9rentes consid\u00e9rations pour r\u00e9duire plusieurs r\u00e9sonances \u00e0 la fois (ndt\u202f: le 2HUMP_EI est \u00e0 utiliser lorsque deux pics de r\u00e9sonance sont d\u00e9tect\u00e9s, le 3HUMP_EI est \u00e0 utiliser lorsque trois pics de r\u00e9sonance sont d\u00e9tect\u00e9s). Pour la plupart des imprimantes, les types MZV ou EI sont recommand\u00e9s. Cette section d\u00e9crit un processus de test pour choisir entre eux et d\u00e9terminer quelques autres param\u00e8tres connexes. Imprimez le mod\u00e8le de test de r\u00e9sonance comme suit : Red\u00e9marrez le micrologiciel : RESTART Pr\u00e9parez-vous pour le test : SET_VELOCITY_LIMIT ACCEL_TO_DECEL=7000 D\u00e9sactivez l'avance de pression : SET_PRESSURE_ADVANCE ADVANCE=0 Ex\u00e9cutez : SET_INPUT_SHAPER SHAPER_TYPE=MZV Ex\u00e9cutez la commande : TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 Imprimez le mod\u00e8le de test tranch\u00e9 avec les param\u00e8tres indiqu\u00e9s. Si vous ne voyez pas de r\u00e9sonance \u00e0 ce stade, l'utilisation du type MZV peut \u00eatre recommand\u00e9e. Si vous voyez une r\u00e9sonance, mesurez \u00e0 nouveau les fr\u00e9quences en suivant les \u00e9tapes (8) \u00e0 (10) d\u00e9crites dans la section Fr\u00e9quence de r\u00e9sonance . Si les fr\u00e9quences diff\u00e8rent consid\u00e9rablement des valeurs obtenues pr\u00e9c\u00e9demment, une configuration d'input shaper plus complexe est n\u00e9cessaire. Vous pouvez vous r\u00e9f\u00e9rer aux d\u00e9tails techniques de la section Input shapers . Sinon, passez \u00e0 l'\u00e9tape suivante. Essayez l'input shaper EI. Pour l'essayer, r\u00e9p\u00e9tez les \u00e9tapes (1) \u00e0 (6) ci-dessus, mais en ex\u00e9cutant \u00e0 l'\u00e9tape 4 la commande suivante \u00e0 la place : SET_INPUT_SHAPER SHAPER_TYPE=EI . Comparez deux impressions avec les types MZV et EI. Si EI montre des r\u00e9sultats sensiblement meilleurs que MZV, utilisez EI, sinon pr\u00e9f\u00e9rez MZV. Notez que le type EI provoquera plus de lissage dans les pi\u00e8ces imprim\u00e9es (voir la section suivante pour plus de d\u00e9tails). Ajoutez le param\u00e8tre shaper_type: mzv (ou ei) \u00e0 la section [input_shaper], par exemple : [input_shaper] shaper_freq_x: ... shaper_freq_y: ... shaper_type: mzv Quelques notes sur le choix de l'input shaper : Le type EI peut \u00eatre plus adapt\u00e9 aux imprimantes \u00e0 lit mobile (si la fr\u00e9quence de r\u00e9sonance et le lissage r\u00e9sultant le permettent) : plus le filament est d\u00e9pos\u00e9 sur le lit en mouvement, plus la masse du lit augmente et la fr\u00e9quence de r\u00e9sonance diminue. \u00c9tant donn\u00e9 que le type EI est plus robuste aux changements de fr\u00e9quence de r\u00e9sonance, il peut \u00eatre plus efficace lors de l'impression de grandes pi\u00e8ces. En raison de la nature de la cin\u00e9matique delta, les fr\u00e9quences de r\u00e9sonance peuvent diff\u00e9rer consid\u00e9rablement dans diff\u00e9rentes parties du volume de construction. Par cons\u00e9quent, le type EI peut \u00eatre mieux adapt\u00e9 aux imprimantes delta plut\u00f4t que MZV ou ZV. Si la fr\u00e9quence de r\u00e9sonance est suffisamment grande (plus de 50-60 Hz), alors on peut m\u00eame essayer de tester 2HUMP_EI (en ex\u00e9cutant le test sugg\u00e9r\u00e9 ci-dessus avec SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI ), mais v\u00e9rifiez les consid\u00e9rations dans la section ci-dessous avant de l'activer. S\u00e9lection de max_accel \u00b6 Vous devriez obtenir le test imprim\u00e9 avec l'input shaper choisi \u00e0 l'\u00e9tape pr\u00e9c\u00e9dente (si vous ne le faites pas, imprimez le mod\u00e8le de test d\u00e9coup\u00e9 avec les param\u00e8tres sugg\u00e9r\u00e9s avec l'avance de pression d\u00e9sactiv\u00e9e SET_PRESSURE_ADVANCE ADVANCE=0 et avec la tour de r\u00e9glage activ\u00e9e comme TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 ). Notez qu'\u00e0 des acc\u00e9l\u00e9rations tr\u00e8s \u00e9lev\u00e9es, selon la fr\u00e9quence de r\u00e9sonance et l'input shaper choisi (par exemple, le shaper EI cr\u00e9e plus de lissage que MZV), cela peut provoquer trop de lissage et d'arrondi des pi\u00e8ces. Ainsi, max_accel doit \u00eatre choisi de mani\u00e8re \u00e0 l'\u00e9viter. Un autre param\u00e8tre ayant un impact sur le lissage est square_corner_velocity , il n'est donc pas conseill\u00e9 de l'augmenter au-dessus de la valeur par d\u00e9faut de 5 mm/s pour \u00e9viter un lissage accru. Afin de s\u00e9lectionner une valeur correcte pour max_accel, inspectez le mod\u00e8le imprim\u00e9 pour l'input shaper choisi. Tout d'abord, notez \u00e0 quelle acc\u00e9l\u00e9ration la r\u00e9sonance reste imperceptible. Ensuite, v\u00e9rifiez le lissage. Pour vous aider, le mod\u00e8le de test a un petit espace dans la paroi (0,15 mm) : \u00c0 mesure que l'acc\u00e9l\u00e9ration augmente, le lissage augmente \u00e9galement et l'espacement r\u00e9el dans l'impression s'\u00e9largit : Sur cette image, l'acc\u00e9l\u00e9ration augmente de gauche \u00e0 droite, et l'\u00e9cart commence \u00e0 cro\u00eetre \u00e0 partir de 3500 mm/s\u00b2 (5\u00e8me bande \u00e0 partir de la gauche). Dans ce cas, la valeur pour max_accel = 3000 (mm/s\u00b2) permet d'\u00e9viter un lissage excessif. Notez l'acc\u00e9l\u00e9ration lorsque l'\u00e9cart est encore tr\u00e8s faible dans votre test d'impression. Si vous voyez des renflements, mais aucun espace dans le mur, m\u00eame \u00e0 des acc\u00e9l\u00e9rations \u00e9lev\u00e9es, cela peut \u00eatre d\u00fb \u00e0 une avance de pression (PA) d\u00e9sactiv\u00e9e, en particulier sur les extrudeurs de type Bowden. Si tel est le cas, vous devrez peut-\u00eatre relancer l'impression avec le PA activ\u00e9. Cela peut \u00e9galement \u00eatre le r\u00e9sultat d'un extrudeur mal calibr\u00e9 (trop \u00e9lev\u00e9), il faut donc v\u00e9rifier cela aussi. Choisissez la valeur minimale des deux valeurs d'acc\u00e9l\u00e9ration (de la r\u00e9sonance et du lissage) et affectez-l\u00e0 \u00e0 max_accel dans printer.cfg. Notez qu'il peut arriver - en particulier \u00e0 des fr\u00e9quences de r\u00e9sonance basses - que l'input shaper EI provoque trop de lissage, m\u00eame \u00e0 des acc\u00e9l\u00e9rations faibles. Dans ce cas, MZV peut \u00eatre un meilleur choix, car il peut permettre des valeurs d'acc\u00e9l\u00e9ration plus \u00e9lev\u00e9es. \u00c0 des fr\u00e9quences de r\u00e9sonance tr\u00e8s basses (~ 25 Hz et moins), m\u00eame l'input shaper MZV peut cr\u00e9er trop de lissage. Si tel est le cas, vous pouvez \u00e9galement essayer de r\u00e9p\u00e9ter les \u00e9tapes de la section Choix de l'input shaper avec l'input shaper ZV, en utilisant la commande SET_INPUT_SHAPER SHAPER_TYPE=ZV \u00e0 la place. L'input shaper ZV devrait montrer encore moins de lissage que MZV, mais il est plus sensible aux erreurs de mesure des fr\u00e9quences de r\u00e9sonance. Si une fr\u00e9quence de r\u00e9sonance est trop faible (inf\u00e9rieure \u00e0 20-25 Hz), il peut \u00eatre judicieux d'augmenter la rigidit\u00e9 de l'imprimante ou de r\u00e9duire la masse en mouvement. Sinon, l'acc\u00e9l\u00e9ration et la vitesse d'impression peuvent \u00eatre limit\u00e9es en raison d'un lissage trop important qui remplacera la r\u00e9sonance. R\u00e9glage fin des fr\u00e9quences de r\u00e9sonance \u00b6 Notez que la pr\u00e9cision des mesures des fr\u00e9quences de r\u00e9sonance \u00e0 l'aide du mod\u00e8le de test de r\u00e9sonance est suffisante dans la plupart des cas, donc un r\u00e9glage suppl\u00e9mentaire n'est pas utile. Si vous voulez toujours essayer de rev\u00e9rifier vos r\u00e9sultats (par exemple, si vous voyez toujours une r\u00e9sonance apr\u00e8s avoir imprim\u00e9 un mod\u00e8le de test avec un input shaper de votre choix avec les fr\u00e9quences mesur\u00e9es pr\u00e9c\u00e9demment), vous pouvez suivre les \u00e9tapes de cette section. Notez que si vous voyez une r\u00e9sonance \u00e0 diff\u00e9rentes fr\u00e9quences apr\u00e8s avoir activ\u00e9 [input_shaper], cette section ne vous aidera pas. En consid\u00e9rant que vous avez tranch\u00e9 le mod\u00e8le de r\u00e9sonance avec les param\u00e8tres sugg\u00e9r\u00e9s, effectuez les \u00e9tapes suivantes pour chacun des axes X et Y : Pr\u00e9parez-vous pour le test : SET_VELOCITY_LIMIT ACCEL_TO_DECEL=7000 Assurez-vous que l'avance de pression est d\u00e9sactiv\u00e9e : SET_PRESSURE_ADVANCE ADVANCE=0 Ex\u00e9cutez : SET_INPUT_SHAPER SHAPER_TYPE=ZV \u00c0 partir du mod\u00e8le de test de r\u00e9sonance imprim\u00e9 avec l'input shaper choisi, s\u00e9lectionnez l'acc\u00e9l\u00e9ration montrant suffisamment bien la r\u00e9sonance et d\u00e9finissez-la avec : SET_VELOCITY_LIMIT ACCEL=... Calculez les param\u00e8tres n\u00e9cessaires pour que la commande TUNING_TOWER r\u00e8gle le param\u00e8tre shaper_freq_x comme suit : start = shaper_freq_x * 83 / 132 et factor = shaper_freq_x / 66, o\u00f9 shaper_freq_x est la valeur indiqu\u00e9e dans printer.cfg . Ex\u00e9cutez la commande : TUNING_TOWER COMMAND=SET_INPUT_SHAPER PARAMETER=SHAPER_FREQ_X START=start FACTOR=factor BAND=5 en utilisant les valeurs start et factor calcul\u00e9es \u00e0 l'\u00e9tape (5). Imprimez le mod\u00e8le de test. Remettez la valeur de fr\u00e9quence d'origine : SET_INPUT_SHAPER SHAPER_FREQ_X=... . Trouvez la bande r\u00e9sonnant le moins et comptez son num\u00e9ro \u00e0 partir du bas en commen\u00e7ant \u00e0 1. Calculez la nouvelle valeur shaper_freq_x selon la formule : ancien shaper_freq_x * (39 + 5 * #band-number) / 66. R\u00e9p\u00e9tez ces \u00e9tapes pour l'axe Y de la m\u00eame mani\u00e8re, en rempla\u00e7ant les r\u00e9f\u00e9rences \u00e0 l'axe X par l'axe Y (par exemple, remplacez shaper_freq_x par shaper_freq_y dans les formules et dans la commande TUNING_TOWER ). A titre d'exemple, supposons que vous ayez mesur\u00e9 la fr\u00e9quence de r\u00e9sonance pour l'un des axes \u00e0 45 Hz. Cela donne les valeurs start = 45 * 83 / 132 = 28,30 et factor = 45 / 66 = 0,6818 pour la commande TUNING_TOWER . Supposons maintenant qu'apr\u00e8s l'impression du mod\u00e8le de test, la quatri\u00e8me bande \u00e0 partir du bas donne le moins de r\u00e9sonance. Cela donne le shaper_freq_ mis \u00e0 jour \u00e9gal \u00e0 45 * (39 + 5 * 4) / 66 \u2248 40,23. Une fois les deux nouveaux param\u00e8tres shaper_freq_x et shaper_freq_y calcul\u00e9s, vous pouvez mettre \u00e0 jour la section [input_shaper] dans printer.cfg avec le nouveau shaper_freq_x et shaper_freq_y . Avance de pression (PA) \u00b6 Si vous utilisiez l'avance de pression, il pourra \u00eatre n\u00e9cessaire de la r\u00e9ajuster. Suivez les instructions pour trouver la nouvelle valeur, si elle diff\u00e8re de la pr\u00e9c\u00e9dente. Assurez-vous de red\u00e9marrer Klipper avant de r\u00e9gler l'avance de pression. Mesures peu fiables des fr\u00e9quences de r\u00e9sonance \u00b6 Si vous ne parvenez pas \u00e0 mesurer les fr\u00e9quences de r\u00e9sonance, par ex. si la distance entre les oscillations n'est pas stable, vous pouvez toujours profiter des techniques de l'input shaper, mais les r\u00e9sultats peuvent ne pas \u00eatre aussi bons qu'avec des mesures appropri\u00e9es des fr\u00e9quences, et n\u00e9cessiteront un peu plus de r\u00e9glages et d'impressions du mod\u00e8le de test. Notez qu'une autre possibilit\u00e9 est d'acheter et d'installer un acc\u00e9l\u00e9rom\u00e8tre et de mesurer les r\u00e9sonances avec (reportez-vous \u00e0 la documentation d\u00e9crivant le mat\u00e9riel requis et le processus de configuration) - mais cette option n\u00e9cessite quelques soudures et un peu de sertissage. Pour le r\u00e9glage, ajoutez une section [input_shaper] vide \u00e0 votre printer.cfg . Ensuite, en supposant que vous avez tranch\u00e9 le mod\u00e8le de r\u00e9sonance avec les param\u00e8tres sugg\u00e9r\u00e9s, imprimez le mod\u00e8le de test 3 fois comme suit. Premi\u00e8re fois, avant l'impression, ex\u00e9cutez RESTART SET_VELOCITY_LIMIT ACCEL_TO_DECEL=7000 SET_PRESSURE_ADVANCE ADVANCE=0 SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=60 SHAPER_FREQ_Y=60 TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 et imprimez le mod\u00e8le. Ensuite, imprimez \u00e0 nouveau le mod\u00e8le, mais avant d'imprimer, ex\u00e9cutez \u00e0 la place SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=50 SHAPER_FREQ_Y=50 TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 Imprimez ensuite le mod\u00e8le pour la 3\u00e8me fois, mais ex\u00e9cutez maintenant SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=40 SHAPER_FREQ_Y=40 TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 Dans la pratique nous imprimons le mod\u00e8le de test de r\u00e9sonance avec TUNING_TOWER en utilisant l'input shaper 2HUMP_EI avec shaper_freq = 60 Hz, 50 Hz et 40 Hz. Si aucun des mod\u00e8les ne d\u00e9montre d'am\u00e9lioration de la r\u00e9sonance, aucune des techniques d'input shaper ne pourra vous aider. Sinon, il se peut que tous les mod\u00e8les n'affichent aucune r\u00e9sonance, ou que certains affichent la r\u00e9sonance et d'autres pas trop. Choisissez le mod\u00e8le de test avec la fr\u00e9quence la plus \u00e9lev\u00e9e qui montre encore de bonnes am\u00e9liorations dans la r\u00e9sonance. Par exemple, si les mod\u00e8les 40 Hz et 50 Hz n'affichent presque aucune r\u00e9sonance et que le mod\u00e8le 60 Hz affiche d\u00e9j\u00e0 un peu plus de r\u00e9sonance, restez \u00e0 50 Hz. V\u00e9rifiez maintenant si l'input shaper EI peut fonctionner dans votre cas. Choisissez la fr\u00e9quence de l'input shaper EI en fonction de la fr\u00e9quence de l'input shaper 2HUMP_EI que vous avez choisie : Pour l'input shaper 2HUMP_EI 60 Hz, utilisez l'input shaper EI avec shaper_freq = 50 Hz. Pour l'input shaper 2HUMP_EI 50 Hz, utilisez l'input shaper EI avec shaper_freq = 40 Hz. Pour l'input shaper 2HUMP_EI \u00e0 40 Hz, utilisez l'input shaper EI avec shaper_freq = 33 Hz. Imprimez le mod\u00e8le de test une fois de plus, en ex\u00e9cutant SET_INPUT_SHAPER SHAPER_TYPE=EI SHAPER_FREQ_X=... SHAPER_FREQ_Y=... TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 en fournissant le shaper_freq_x=... et shaper_freq_y=... comme d\u00e9termin\u00e9 pr\u00e9c\u00e9demment. Si l'input shaper EI montre de bons r\u00e9sultats comparables \u00e0 ceux de l'input shaper 2HUMP_EI, restez avec l'input shaper EI et la fr\u00e9quence d\u00e9termin\u00e9e pr\u00e9c\u00e9demment, sinon utilisez l'input shaper 2HUMP_EI avec la fr\u00e9quence correspondante. Ajoutez les r\u00e9sultats \u00e0 printer.cfg comme, par ex. [input_shaper] shaper_freq_x: 50 shaper_freq_y: 50 shaper_type: 2hump_ei Continuez le r\u00e9glage avec la section Choix de l'acc\u00e9l\u00e9ration maximale . D\u00e9pannage et FAQ \u00b6 Je n'arrive pas \u00e0 obtenir de mesures fiables des fr\u00e9quences de r\u00e9sonance \u00b6 En premier lieu, assurez-vous qu'il ne s'agit pas d'un autre probl\u00e8me avec l'imprimante plut\u00f4t que de la r\u00e9sonance. Si les mesures ne sont pas fiables parce que, par exemple, la distance entre les oscillations n'est pas stable, cela peut signifier que l'imprimante a plusieurs fr\u00e9quences de r\u00e9sonance sur le m\u00eame axe. On peut essayer de suivre le processus de r\u00e9glage d\u00e9crit dans la section Mesures non fiables des fr\u00e9quences de r\u00e9sonance et tirer encore quelque chose de la technique de l'input shaper. Une autre possibilit\u00e9 consiste \u00e0 installer un acc\u00e9l\u00e9rom\u00e8tre, \u00e0 mesurer les r\u00e9sonances avec celui-ci et \u00e0 r\u00e9gler automatiquement l'input shaper en utilisant les r\u00e9sultats de ces mesures. Apr\u00e8s avoir activ\u00e9 [input_shaper], j'obtiens des pi\u00e8ces imprim\u00e9es trop liss\u00e9es et les d\u00e9tails fins sont perdus \u00b6 V\u00e9rifiez les informations dans la section Choix de l'acc\u00e9l\u00e9ration maximale . Si la fr\u00e9quence de r\u00e9sonance est faible, il ne faut pas d\u00e9finir une valeur trop \u00e9lev\u00e9e pour max_accel ou augmenter les param\u00e8tres square_corner_velocity. Il peut \u00e9galement \u00eatre pr\u00e9f\u00e9rable de choisir un input shaper de type MZV ou m\u00eame ZV plut\u00f4t que EI (ou des shapers 2HUMP_EI et 3HUMP_EI). Apr\u00e8s avoir r\u00e9ussi \u00e0 imprimer pendant un certain temps sans r\u00e9sonance, elle semble revenir \u00b6 Il est possible qu'apr\u00e8s un certain temps, les fr\u00e9quences de r\u00e9sonance aient chang\u00e9. Par exemple. peut-\u00eatre que la tension des courroies a chang\u00e9 (les courroies sont devenues plus l\u00e2ches), etc. Il est bon de v\u00e9rifier et de mesurer \u00e0 nouveau les fr\u00e9quences de r\u00e9sonance comme d\u00e9crit dans la section Fr\u00e9quence de r\u00e9sonance et de mettre \u00e0 jour votre fichier de configuration si n\u00e9cessaire . La configuration \u00e0 double chariot est-elle prise en charge avec l'input shaper ? \u00b6 Yes. In this case, one should measure the resonances twice for each carriage. For example, if the second (dual) carriage is installed on X axis, it is possible to set different input shapers for X axis for the primary and dual carriages. However, the input shaper for Y axis should be the same for both carriages (as ultimately this axis is driven by one or more stepper motors each commanded to perform exactly the same steps). One possibility to configure the input shaper for such setups is to keep [input_shaper] section empty and additionally define a [delayed_gcode] section in the printer.cfg as follows: [input_shaper] # Intentionally empty [delayed_gcode init_shaper] initial_duration: 0.1 gcode: SET_DUAL_CARRIAGE CARRIAGE=1 SET_INPUT_SHAPER SHAPER_TYPE_X=<dual_carriage_shaper> SHAPER_FREQ_X=<dual_carriage_freq> SHAPER_TYPE_Y=<y_shaper> SHAPER_FREQ_Y=<y_freq> SET_DUAL_CARRIAGE CARRIAGE=0 SET_INPUT_SHAPER SHAPER_TYPE_X=<primary_carriage_shaper> SHAPER_FREQ_X=<primary_carriage_freq> SHAPER_TYPE_Y=<y_shaper> SHAPER_FREQ_Y=<y_freq> Note that SHAPER_TYPE_Y and SHAPER_FREQ_Y should be the same in both commands. It is also possible to put a similar snippet into the start g-code in the slicer, however then the shaper will not be enabled until any print is started. Note that the input shaper only needs to be configured once. Subsequent changes of the carriages or their modes via SET_DUAL_CARRIAGE command will preserve the configured input shaper parameters. input_shaper affecte-t-il le temps d'impression ? \u00b6 Non, la fonctionnalit\u00e9 input_shaper n'a pratiquement aucun impact sur les temps d'impression. Cependant, la valeur de max_accel en a un (r\u00e9glage de ce param\u00e8tre d\u00e9crit dans cette section ). D\u00e9tails techniques \u00b6 Input shapers \u00b6 Les input shaper utilis\u00e9s dans Klipper sont plut\u00f4t standards, et on peut en trouver un aper\u00e7u plus d\u00e9taill\u00e9 dans les articles d\u00e9crivant les input shaper correspondants. Cette section contient un bref aper\u00e7u de certains aspects techniques des input shapers pris en charge. Le tableau ci-dessous montre certains param\u00e8tres (g\u00e9n\u00e9ralement approximatifs) pour chaque input shaper. Input shaper Dur\u00e9e de l'input shaper R\u00e9duction des vibrations 20x (5 % de tol\u00e9rance aux vibrations) R\u00e9duction des vibrations 10x (tol\u00e9rance aux vibrations de 10 %) ZV 0,5 / shaper_freq N/A \u00b1 5% shaper_freq MZV 0,75 / shaper_freq \u00b1 4% shaper_freq -10%...+15% shaper_freq ZVD 1 / shaper_freq \u00b1 15% shaper_freq \u00b1 22% shaper_freq EI 1 / shaper_freq \u00b1 20% shaper_freq \u00b1 25% shaper_freq 2HUMP_EI 1,5 / shaper_freq \u00b1 35% shaper_freq \u00b1 40 shaper_freq 3HUMP_EI 2 / shaper_freq -45...+50% shaper_freq -50%...+55% shaper_freq Remarque concernant l'att\u00e9nuation des vibrations : les valeurs du tableau ci-dessus sont approximatives. Si le taux d'amortissement de l'imprimante est connu pour chaque axe, l'input shaper peut \u00eatre configur\u00e9 plus pr\u00e9cis\u00e9ment ce qui r\u00e9duira alors les r\u00e9sonances dans une plage de fr\u00e9quences un peu plus large. Cependant, le taux d'amortissement est g\u00e9n\u00e9ralement inconnu et difficile \u00e0 estimer sans \u00e9quipement sp\u00e9cial. Klipper utilise donc la valeur 0,1 par d\u00e9faut, ce qui est une bonne valeur globale. Les gammes de fr\u00e9quences du tableau couvrent un certain nombre de diff\u00e9rents rapports d'amortissement possibles autour de cette valeur (environ de 0,05 \u00e0 0,2). Notez \u00e9galement que EI, 2HUMP_EI et 3HUMP_EI sont r\u00e9gl\u00e9s pour r\u00e9duire les vibrations \u00e0 5 %, les valeurs pour une tol\u00e9rance de vibration de 10 % sont fournies uniquement \u00e0 titre indicatif. Comment utiliser ce tableau : La dur\u00e9e de l'input shaper affecte le lissage des pi\u00e8ces - plus elle est grande, plus les pi\u00e8ces sont lisses. Cette d\u00e9pendance n'est pas lin\u00e9aire, mais peut donner une id\u00e9e des input shapers qui \"lissent\" le plus pour une m\u00eame fr\u00e9quence. L'ordre par lissage est le suivant : ZV < MZV < ZVD \u2248 EI < 2HUMP_EI < 3HUMP_EI. De plus, il est rarement pratique de r\u00e9gler shaper_freq = fr\u00e9quence de r\u00e9sonance des types 2HUMP_EI et 3HUMP_EI (utilis\u00e9s pour r\u00e9duire les vibrations sur plusieurs fr\u00e9quences). On peut estimer une gamme de fr\u00e9quences pour laquelle l'input shaper r\u00e9duit les vibrations. Par exemple, MZV avec shaper_freq = 35 Hz r\u00e9duit les vibrations \u00e0 5 % pour les fr\u00e9quences [33,6, 36,4] Hz. 3HUMP_EI avec shaper_freq = 50 Hz r\u00e9duit les vibrations \u00e0 5 % dans la plage [27,5 - 75] Hz. On peut utiliser ce tableau pour v\u00e9rifier quel input shaper choisir pour la r\u00e9duction des vibrations de plusieurs fr\u00e9quences. Par exemple, si on a des r\u00e9sonances \u00e0 35 Hz et 60 Hz sur le m\u00eame axe : a) EI doit avoir shaper_freq = 35 / (1 - 0.2) = 43.75 Hz, ce qui r\u00e9duirait les r\u00e9sonances jusqu'\u00e0 43.75 * (1 + 0,2) = 52,5 Hz, donc ce n'est pas suffisant ; b) Le 2HUMP_EI doit avoir shaper_freq = 35 / (1 - 0,35) = 53,85 Hz ce qui r\u00e9duira les vibrations jusqu'\u00e0 53,85 * (1 + 0,35) = 72,7 Hz - c'est donc une configuration acceptable. Essayez toujours d'utiliser le plus haut shaper_freq possible pour un input shaper donn\u00e9 (peut-\u00eatre avec une certaine marge de s\u00e9curit\u00e9, donc dans cet exemple shaper_freq \u2248 50-52 Hz fonctionnerait mieux), et essayez d'utiliser un input shaper avec une dur\u00e9e aussi petite que possible. Si l'on a besoin de r\u00e9duire les vibrations de plusieurs fr\u00e9quences tr\u00e8s diff\u00e9rentes (par exemple, 30 Hz et 100 Hz), le tableau ci-dessus ne fournit pas suffisamment d'informations. Dans ce cas, on peut avoir plus de chance avec le script scripts/graph_shaper.py , qui est plus flexible.","title":"Compensation de la r\u00e9sonance"},{"location":"Resonance_Compensation.html#compensation-de-la-resonance","text":"Klipper prend en charge l'\"input shaping\", une technique utilis\u00e9e pour r\u00e9duire l'effet de r\u00e9sonance (\u00e9galement connu sous le nom d'\u00e9cho, d'image fant\u00f4me - \"ghosting\" - ou d'ondulation - \"ringing\") dans les impressions. La r\u00e9sonance est un d\u00e9faut d'impression de surface lorsque des \u00e9l\u00e9ments tels que des bords se r\u00e9p\u00e8tent sous la forme d'un l\u00e9ger \"\u00e9cho\" : | | | La r\u00e9sonance est caus\u00e9e par des vibrations m\u00e9caniques dans l'imprimante dues \u00e0 des changements rapides de direction pendant l'impression. La r\u00e9sonance a g\u00e9n\u00e9ralement des origines m\u00e9caniques : cadre de l'imprimante insuffisamment rigide, courroies non tendues ou trop \u00e9lastiques, probl\u00e8mes d'alignement des pi\u00e8ces m\u00e9caniques, masse mobile importante, etc. Ces probl\u00e8mes doivent \u00eatre v\u00e9rifi\u00e9s et corrig\u00e9s en premier lieu, si possible. L' input shaping est une technique de contr\u00f4le en boucle ouverte qui cr\u00e9e un signal de commande annulant ses propres vibrations. L'input shaping n\u00e9cessite quelques r\u00e9glages et mesures avant de pouvoir \u00eatre activ\u00e9e. Outre la r\u00e9sonance, l'input shaping r\u00e9duit aussi les vibrations et les secousses de l'imprimante en g\u00e9n\u00e9ral, et peut \u00e9galement am\u00e9liorer la fiabilit\u00e9 du mode stealthChop des pilotes Trinamic.","title":"Compensation de la r\u00e9sonance"},{"location":"Resonance_Compensation.html#reglages","text":"Le r\u00e9glage de base n\u00e9cessite de mesurer les fr\u00e9quences de r\u00e9sonance de l'imprimante en imprimant un mod\u00e8le de test. Tranchez le mod\u00e8le de test de r\u00e9sonance, qui se trouve dans docs/prints/ringing_tower.stl , avec votre trancheur : La hauteur de couche recommand\u00e9e est de 0,2 ou 0,25 mm. Le remplissage et le nombre de couches sup\u00e9rieures peuvent \u00eatre r\u00e9gl\u00e9s sur 0. Utilisez 1 ou 2 parois, ou mieux encore le mode vase avec une base de 1 ou 2 mm. Utilisez une vitesse suffisamment \u00e9lev\u00e9e, entre 80 et 100 mm/s, pour les parois externes . Veillez \u00e0 ce que le temps minimum par couche soit au maximum de 3 secondes. Assurez-vous que toutes les options de \"contr\u00f4le d'acc\u00e9l\u00e9ration\" soient bien d\u00e9sactiv\u00e9es dans le trancheur. Ne tournez pas le mod\u00e8le. Le mod\u00e8le comporte des marques X et Y \u00e0 l'arri\u00e8re du mod\u00e8le. L'emplacement inhabituel des marques par rapport aux axes de l'imprimante n'est pas une erreur. Ces marques pourront \u00eatre utilis\u00e9es plus tard - comme r\u00e9f\u00e9rence - dans le processus de r\u00e9glage, car elles indiquent \u00e0 quel axe correspondent les mesures.","title":"R\u00e9glages"},{"location":"Resonance_Compensation.html#frequence-de-resonance","text":"En premier lieu, mesurez la fr\u00e9quence de r\u00e9sonance . Si le param\u00e8tre square_corner_velocity a \u00e9t\u00e9 modifi\u00e9, remettez-le \u00e0 5.0. Il n'est pas conseill\u00e9 de l'augmenter lors de l'utilisation de l'input shaper car cela peut provoquer plus de lissage dans les pi\u00e8ces - il est pr\u00e9f\u00e9rable d'utiliser une valeur d'acc\u00e9l\u00e9ration plus \u00e9lev\u00e9e \u00e0 la place. Augmentez max_accel_to_decel en lan\u00e7ant la commande suivante : SET_VELOCITY_LIMIT ACCEL_TO_DECEL=7000 D\u00e9sactivez l'avance de pression : SET_PRESSURE_ADVANCE ADVANCE=0 Si vous avez d\u00e9j\u00e0 ajout\u00e9 la section [input_shaper] au fichier printer.cfg, ex\u00e9cutez la commande SET_INPUT_SHAPER SHAPER_FREQ_X=0 SHAPER_FREQ_Y=0 . Si vous obtenez l'erreur \"Unknown command\", vous pouvez l'ignorer - pour le moment - et continuer les mesures. Ex\u00e9cutez la commande : TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 Dans la pratique, nous essayons de rendre la r\u00e9sonance plus prononc\u00e9e en d\u00e9finissant diff\u00e9rentes valeurs \u00e9lev\u00e9es pour l'acc\u00e9l\u00e9ration. Cette commande augmentera l'acc\u00e9l\u00e9ration tous les 5 mm \u00e0 partir de 1500 mm/sec\u00b2 : 1500 mm/sec\u00b2, 2000 mm/sec\u00b2, 2500 mm/sec\u00b2 et ainsi de suite jusqu'\u00e0 7000 mm/sec\u00b2 pour la derni\u00e8re bande. Imprimez le mod\u00e8le de test tranch\u00e9 avec les param\u00e8tres indiqu\u00e9s. Vous pouvez arr\u00eater l'impression avant la fin si la r\u00e9sonance est clairement visible et si vous constatez que l'acc\u00e9l\u00e9ration devient trop forte pour votre imprimante (par exemple, l'imprimante tremble trop ou commence \u00e0 sauter des pas). Utilisez les marques X et Y \u00e0 l'arri\u00e8re du mod\u00e8le comme r\u00e9f\u00e9rence. Les mesures du c\u00f4t\u00e9 avec la marque X doivent \u00eatre utilis\u00e9es pour la configuration de l'axe X, et les mesures du c\u00f4t\u00e9 avec la marque Y pour la configuration de l'axe Y. Mesurez la distance D (en mm) entre plusieurs oscillations sur la partie de la pi\u00e8ce avec la marque X, pr\u00e8s des encoches et en sautant de pr\u00e9f\u00e9rence la ou les deux premi\u00e8res oscillations. Pour mesurer plus facilement la distance entre les oscillations, marquez d'abord les oscillations, puis mesurez la distance entre les marques avec une r\u00e8gle ou un pied \u00e0 coulisse :| | | Comptez le nombre d'oscillations N correspondant \u00e0 la distance mesur\u00e9e D . Si vous ne savez pas comment compter les oscillations, reportez-vous \u00e0 l'image ci-dessus, qui montre N = 6 oscillations. Calculez la fr\u00e9quence de r\u00e9sonance de l'axe X : V \u00b7 N / D (Hz), o\u00f9 V est la vitesse des p\u00e9rim\u00e8tres ext\u00e9rieurs (mm/s). Pour l'exemple ci-dessus, nous avons marqu\u00e9 6 oscillations (N) sur une distance de 12,14 mm (D), et le test a \u00e9t\u00e9 imprim\u00e9 \u00e0 une vitesse de 100 mm/s (V), donc la fr\u00e9quence est 100 * 6 / 12,14 \u2248 49,4 Hz. Faites (8) - (10) pour la marque Y \u00e9galement. Notez que la r\u00e9sonance sur l'impression de test devrait suivre les encoches courb\u00e9es de la pi\u00e8ce, comme dans l'image ci-dessus. Si ce n'est pas le cas, alors ce d\u00e9faut n'est pas vraiment une r\u00e9sonance et a probablement une origine diff\u00e9rente - soit m\u00e9canique, soit un probl\u00e8me d'extrudeuse. Ce probl\u00e8me doit \u00eatre r\u00e9solu avant d'activer et de r\u00e9gler les input shapers. Si les mesures ne sont pas fiables parce que, par exemple, la distance entre les oscillations n'est pas r\u00e9guli\u00e8re, cela peut signifier que l'imprimante a plusieurs fr\u00e9quences de r\u00e9sonance sur le m\u00eame axe. On peut essayer de suivre le processus de r\u00e9glage d\u00e9crit dans la section Mesures peu fiables des fr\u00e9quences de r\u00e9sonance \u00e0 la place et obtenir quand m\u00eame une am\u00e9lioration gr\u00e2ce \u00e0 l'input shaping. La fr\u00e9quence de r\u00e9sonance peut d\u00e9pendre de la position du mod\u00e8le sur le plateau et de la hauteur Z, surtout sur les imprimantes delta ; vous pouvez v\u00e9rifier si vous observez des diff\u00e9rences de fr\u00e9quences \u00e0 diff\u00e9rentes positions le long des c\u00f4t\u00e9s du mod\u00e8le de test et \u00e0 diff\u00e9rentes hauteurs. Si c'est le cas, vous pouvez calculer les fr\u00e9quences de r\u00e9sonance moyennes sur les axes X et Y. Si la fr\u00e9quence de r\u00e9sonance mesur\u00e9e est tr\u00e8s basse (inf\u00e9rieure \u00e0 20-25 Hz), il peut \u00eatre judicieux de penser \u00e0 rigidifier la structure de l'imprimante ou \u00e0 r\u00e9duire la masse mobile - dans la mesure du possible - avant de poursuivre le r\u00e9glage de l'input shaping et de mesurer \u00e0 nouveau les fr\u00e9quences. Pour de nombreux mod\u00e8les d'imprimantes populaires, il existe souvent des solutions d\u00e9j\u00e0 disponibles. Les fr\u00e9quences de r\u00e9sonance peuvent changer si des modifications sont apport\u00e9es \u00e0 l'imprimante qui affectent la masse en mouvement ou modifient la rigidit\u00e9 du syst\u00e8me, par exemple : Si la t\u00eate d'impression est modifi\u00e9e, par ex. changement de moteur pas \u00e0 pas (plus lourd ou plus l\u00e9ger) pour une extrusion directe, remplacement de la t\u00eate de l'outil (plus ou moins lourde), ajout d'un ventilateur plus lourd, etc. La tension des courroies a \u00e9t\u00e9 modifi\u00e9e. Des pi\u00e8ces con\u00e7ues pour augmenter la rigidit\u00e9 du cadre sont install\u00e9es. Un plateau diff\u00e9rent est install\u00e9 sur une imprimante \u00e0 lit mobile, ou une plaque de verre est ajout\u00e9e, etc. Si de telles modifications sont apport\u00e9es, Il est conseill\u00e9 - au minimum - de mesurer les fr\u00e9quences de r\u00e9sonance pour v\u00e9rifier s'il elles ont chang\u00e9es (ou pas).","title":"Fr\u00e9quence de r\u00e9sonance"},{"location":"Resonance_Compensation.html#configuration-de-linput-shaper","text":"Une fois les fr\u00e9quences de r\u00e9sonance des axes X et Y mesur\u00e9es, vous pouvez ajouter la section suivante \u00e0 votre fichier printer.cfg : [input_shaper] shaper_freq_x: ... # frequence pour la marque X sur le mod\u00e8le de test shaper_freq_y: ... # frequence pour la marque Y sur le mod\u00e8le de test Pour l'exemple ci-dessus, nous obtenons shaper_freq_x/y = 49,4.","title":"Configuration de l'input shaper"},{"location":"Resonance_Compensation.html#choix-de-linput-shaper","text":"Klipper prend en charge plusieurs type d'\"input shaper\". Ils diff\u00e8rent par leur sensibilit\u00e9 aux erreurs d\u00e9terminant la fr\u00e9quence de r\u00e9sonance et le degr\u00e9 de lissage qu'ils provoquent dans les pi\u00e8ces imprim\u00e9es. De plus, certains de ces \"input shaper\" comme 2HUMP_EI et 3HUMP_EI ne doivent g\u00e9n\u00e9ralement pas \u00eatre utilis\u00e9s avec shaper_freq = fr\u00e9quence de r\u00e9sonance - ils sont configur\u00e9s \u00e0 partir de diff\u00e9rentes consid\u00e9rations pour r\u00e9duire plusieurs r\u00e9sonances \u00e0 la fois (ndt\u202f: le 2HUMP_EI est \u00e0 utiliser lorsque deux pics de r\u00e9sonance sont d\u00e9tect\u00e9s, le 3HUMP_EI est \u00e0 utiliser lorsque trois pics de r\u00e9sonance sont d\u00e9tect\u00e9s). Pour la plupart des imprimantes, les types MZV ou EI sont recommand\u00e9s. Cette section d\u00e9crit un processus de test pour choisir entre eux et d\u00e9terminer quelques autres param\u00e8tres connexes. Imprimez le mod\u00e8le de test de r\u00e9sonance comme suit : Red\u00e9marrez le micrologiciel : RESTART Pr\u00e9parez-vous pour le test : SET_VELOCITY_LIMIT ACCEL_TO_DECEL=7000 D\u00e9sactivez l'avance de pression : SET_PRESSURE_ADVANCE ADVANCE=0 Ex\u00e9cutez : SET_INPUT_SHAPER SHAPER_TYPE=MZV Ex\u00e9cutez la commande : TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 Imprimez le mod\u00e8le de test tranch\u00e9 avec les param\u00e8tres indiqu\u00e9s. Si vous ne voyez pas de r\u00e9sonance \u00e0 ce stade, l'utilisation du type MZV peut \u00eatre recommand\u00e9e. Si vous voyez une r\u00e9sonance, mesurez \u00e0 nouveau les fr\u00e9quences en suivant les \u00e9tapes (8) \u00e0 (10) d\u00e9crites dans la section Fr\u00e9quence de r\u00e9sonance . Si les fr\u00e9quences diff\u00e8rent consid\u00e9rablement des valeurs obtenues pr\u00e9c\u00e9demment, une configuration d'input shaper plus complexe est n\u00e9cessaire. Vous pouvez vous r\u00e9f\u00e9rer aux d\u00e9tails techniques de la section Input shapers . Sinon, passez \u00e0 l'\u00e9tape suivante. Essayez l'input shaper EI. Pour l'essayer, r\u00e9p\u00e9tez les \u00e9tapes (1) \u00e0 (6) ci-dessus, mais en ex\u00e9cutant \u00e0 l'\u00e9tape 4 la commande suivante \u00e0 la place : SET_INPUT_SHAPER SHAPER_TYPE=EI . Comparez deux impressions avec les types MZV et EI. Si EI montre des r\u00e9sultats sensiblement meilleurs que MZV, utilisez EI, sinon pr\u00e9f\u00e9rez MZV. Notez que le type EI provoquera plus de lissage dans les pi\u00e8ces imprim\u00e9es (voir la section suivante pour plus de d\u00e9tails). Ajoutez le param\u00e8tre shaper_type: mzv (ou ei) \u00e0 la section [input_shaper], par exemple : [input_shaper] shaper_freq_x: ... shaper_freq_y: ... shaper_type: mzv Quelques notes sur le choix de l'input shaper : Le type EI peut \u00eatre plus adapt\u00e9 aux imprimantes \u00e0 lit mobile (si la fr\u00e9quence de r\u00e9sonance et le lissage r\u00e9sultant le permettent) : plus le filament est d\u00e9pos\u00e9 sur le lit en mouvement, plus la masse du lit augmente et la fr\u00e9quence de r\u00e9sonance diminue. \u00c9tant donn\u00e9 que le type EI est plus robuste aux changements de fr\u00e9quence de r\u00e9sonance, il peut \u00eatre plus efficace lors de l'impression de grandes pi\u00e8ces. En raison de la nature de la cin\u00e9matique delta, les fr\u00e9quences de r\u00e9sonance peuvent diff\u00e9rer consid\u00e9rablement dans diff\u00e9rentes parties du volume de construction. Par cons\u00e9quent, le type EI peut \u00eatre mieux adapt\u00e9 aux imprimantes delta plut\u00f4t que MZV ou ZV. Si la fr\u00e9quence de r\u00e9sonance est suffisamment grande (plus de 50-60 Hz), alors on peut m\u00eame essayer de tester 2HUMP_EI (en ex\u00e9cutant le test sugg\u00e9r\u00e9 ci-dessus avec SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI ), mais v\u00e9rifiez les consid\u00e9rations dans la section ci-dessous avant de l'activer.","title":"Choix de l'input shaper"},{"location":"Resonance_Compensation.html#selection-de-max_accel","text":"Vous devriez obtenir le test imprim\u00e9 avec l'input shaper choisi \u00e0 l'\u00e9tape pr\u00e9c\u00e9dente (si vous ne le faites pas, imprimez le mod\u00e8le de test d\u00e9coup\u00e9 avec les param\u00e8tres sugg\u00e9r\u00e9s avec l'avance de pression d\u00e9sactiv\u00e9e SET_PRESSURE_ADVANCE ADVANCE=0 et avec la tour de r\u00e9glage activ\u00e9e comme TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 ). Notez qu'\u00e0 des acc\u00e9l\u00e9rations tr\u00e8s \u00e9lev\u00e9es, selon la fr\u00e9quence de r\u00e9sonance et l'input shaper choisi (par exemple, le shaper EI cr\u00e9e plus de lissage que MZV), cela peut provoquer trop de lissage et d'arrondi des pi\u00e8ces. Ainsi, max_accel doit \u00eatre choisi de mani\u00e8re \u00e0 l'\u00e9viter. Un autre param\u00e8tre ayant un impact sur le lissage est square_corner_velocity , il n'est donc pas conseill\u00e9 de l'augmenter au-dessus de la valeur par d\u00e9faut de 5 mm/s pour \u00e9viter un lissage accru. Afin de s\u00e9lectionner une valeur correcte pour max_accel, inspectez le mod\u00e8le imprim\u00e9 pour l'input shaper choisi. Tout d'abord, notez \u00e0 quelle acc\u00e9l\u00e9ration la r\u00e9sonance reste imperceptible. Ensuite, v\u00e9rifiez le lissage. Pour vous aider, le mod\u00e8le de test a un petit espace dans la paroi (0,15 mm) : \u00c0 mesure que l'acc\u00e9l\u00e9ration augmente, le lissage augmente \u00e9galement et l'espacement r\u00e9el dans l'impression s'\u00e9largit : Sur cette image, l'acc\u00e9l\u00e9ration augmente de gauche \u00e0 droite, et l'\u00e9cart commence \u00e0 cro\u00eetre \u00e0 partir de 3500 mm/s\u00b2 (5\u00e8me bande \u00e0 partir de la gauche). Dans ce cas, la valeur pour max_accel = 3000 (mm/s\u00b2) permet d'\u00e9viter un lissage excessif. Notez l'acc\u00e9l\u00e9ration lorsque l'\u00e9cart est encore tr\u00e8s faible dans votre test d'impression. Si vous voyez des renflements, mais aucun espace dans le mur, m\u00eame \u00e0 des acc\u00e9l\u00e9rations \u00e9lev\u00e9es, cela peut \u00eatre d\u00fb \u00e0 une avance de pression (PA) d\u00e9sactiv\u00e9e, en particulier sur les extrudeurs de type Bowden. Si tel est le cas, vous devrez peut-\u00eatre relancer l'impression avec le PA activ\u00e9. Cela peut \u00e9galement \u00eatre le r\u00e9sultat d'un extrudeur mal calibr\u00e9 (trop \u00e9lev\u00e9), il faut donc v\u00e9rifier cela aussi. Choisissez la valeur minimale des deux valeurs d'acc\u00e9l\u00e9ration (de la r\u00e9sonance et du lissage) et affectez-l\u00e0 \u00e0 max_accel dans printer.cfg. Notez qu'il peut arriver - en particulier \u00e0 des fr\u00e9quences de r\u00e9sonance basses - que l'input shaper EI provoque trop de lissage, m\u00eame \u00e0 des acc\u00e9l\u00e9rations faibles. Dans ce cas, MZV peut \u00eatre un meilleur choix, car il peut permettre des valeurs d'acc\u00e9l\u00e9ration plus \u00e9lev\u00e9es. \u00c0 des fr\u00e9quences de r\u00e9sonance tr\u00e8s basses (~ 25 Hz et moins), m\u00eame l'input shaper MZV peut cr\u00e9er trop de lissage. Si tel est le cas, vous pouvez \u00e9galement essayer de r\u00e9p\u00e9ter les \u00e9tapes de la section Choix de l'input shaper avec l'input shaper ZV, en utilisant la commande SET_INPUT_SHAPER SHAPER_TYPE=ZV \u00e0 la place. L'input shaper ZV devrait montrer encore moins de lissage que MZV, mais il est plus sensible aux erreurs de mesure des fr\u00e9quences de r\u00e9sonance. Si une fr\u00e9quence de r\u00e9sonance est trop faible (inf\u00e9rieure \u00e0 20-25 Hz), il peut \u00eatre judicieux d'augmenter la rigidit\u00e9 de l'imprimante ou de r\u00e9duire la masse en mouvement. Sinon, l'acc\u00e9l\u00e9ration et la vitesse d'impression peuvent \u00eatre limit\u00e9es en raison d'un lissage trop important qui remplacera la r\u00e9sonance.","title":"S\u00e9lection de max_accel"},{"location":"Resonance_Compensation.html#reglage-fin-des-frequences-de-resonance","text":"Notez que la pr\u00e9cision des mesures des fr\u00e9quences de r\u00e9sonance \u00e0 l'aide du mod\u00e8le de test de r\u00e9sonance est suffisante dans la plupart des cas, donc un r\u00e9glage suppl\u00e9mentaire n'est pas utile. Si vous voulez toujours essayer de rev\u00e9rifier vos r\u00e9sultats (par exemple, si vous voyez toujours une r\u00e9sonance apr\u00e8s avoir imprim\u00e9 un mod\u00e8le de test avec un input shaper de votre choix avec les fr\u00e9quences mesur\u00e9es pr\u00e9c\u00e9demment), vous pouvez suivre les \u00e9tapes de cette section. Notez que si vous voyez une r\u00e9sonance \u00e0 diff\u00e9rentes fr\u00e9quences apr\u00e8s avoir activ\u00e9 [input_shaper], cette section ne vous aidera pas. En consid\u00e9rant que vous avez tranch\u00e9 le mod\u00e8le de r\u00e9sonance avec les param\u00e8tres sugg\u00e9r\u00e9s, effectuez les \u00e9tapes suivantes pour chacun des axes X et Y : Pr\u00e9parez-vous pour le test : SET_VELOCITY_LIMIT ACCEL_TO_DECEL=7000 Assurez-vous que l'avance de pression est d\u00e9sactiv\u00e9e : SET_PRESSURE_ADVANCE ADVANCE=0 Ex\u00e9cutez : SET_INPUT_SHAPER SHAPER_TYPE=ZV \u00c0 partir du mod\u00e8le de test de r\u00e9sonance imprim\u00e9 avec l'input shaper choisi, s\u00e9lectionnez l'acc\u00e9l\u00e9ration montrant suffisamment bien la r\u00e9sonance et d\u00e9finissez-la avec : SET_VELOCITY_LIMIT ACCEL=... Calculez les param\u00e8tres n\u00e9cessaires pour que la commande TUNING_TOWER r\u00e8gle le param\u00e8tre shaper_freq_x comme suit : start = shaper_freq_x * 83 / 132 et factor = shaper_freq_x / 66, o\u00f9 shaper_freq_x est la valeur indiqu\u00e9e dans printer.cfg . Ex\u00e9cutez la commande : TUNING_TOWER COMMAND=SET_INPUT_SHAPER PARAMETER=SHAPER_FREQ_X START=start FACTOR=factor BAND=5 en utilisant les valeurs start et factor calcul\u00e9es \u00e0 l'\u00e9tape (5). Imprimez le mod\u00e8le de test. Remettez la valeur de fr\u00e9quence d'origine : SET_INPUT_SHAPER SHAPER_FREQ_X=... . Trouvez la bande r\u00e9sonnant le moins et comptez son num\u00e9ro \u00e0 partir du bas en commen\u00e7ant \u00e0 1. Calculez la nouvelle valeur shaper_freq_x selon la formule : ancien shaper_freq_x * (39 + 5 * #band-number) / 66. R\u00e9p\u00e9tez ces \u00e9tapes pour l'axe Y de la m\u00eame mani\u00e8re, en rempla\u00e7ant les r\u00e9f\u00e9rences \u00e0 l'axe X par l'axe Y (par exemple, remplacez shaper_freq_x par shaper_freq_y dans les formules et dans la commande TUNING_TOWER ). A titre d'exemple, supposons que vous ayez mesur\u00e9 la fr\u00e9quence de r\u00e9sonance pour l'un des axes \u00e0 45 Hz. Cela donne les valeurs start = 45 * 83 / 132 = 28,30 et factor = 45 / 66 = 0,6818 pour la commande TUNING_TOWER . Supposons maintenant qu'apr\u00e8s l'impression du mod\u00e8le de test, la quatri\u00e8me bande \u00e0 partir du bas donne le moins de r\u00e9sonance. Cela donne le shaper_freq_ mis \u00e0 jour \u00e9gal \u00e0 45 * (39 + 5 * 4) / 66 \u2248 40,23. Une fois les deux nouveaux param\u00e8tres shaper_freq_x et shaper_freq_y calcul\u00e9s, vous pouvez mettre \u00e0 jour la section [input_shaper] dans printer.cfg avec le nouveau shaper_freq_x et shaper_freq_y .","title":"R\u00e9glage fin des fr\u00e9quences de r\u00e9sonance"},{"location":"Resonance_Compensation.html#avance-de-pression-pa","text":"Si vous utilisiez l'avance de pression, il pourra \u00eatre n\u00e9cessaire de la r\u00e9ajuster. Suivez les instructions pour trouver la nouvelle valeur, si elle diff\u00e8re de la pr\u00e9c\u00e9dente. Assurez-vous de red\u00e9marrer Klipper avant de r\u00e9gler l'avance de pression.","title":"Avance de pression (PA)"},{"location":"Resonance_Compensation.html#mesures-peu-fiables-des-frequences-de-resonance","text":"Si vous ne parvenez pas \u00e0 mesurer les fr\u00e9quences de r\u00e9sonance, par ex. si la distance entre les oscillations n'est pas stable, vous pouvez toujours profiter des techniques de l'input shaper, mais les r\u00e9sultats peuvent ne pas \u00eatre aussi bons qu'avec des mesures appropri\u00e9es des fr\u00e9quences, et n\u00e9cessiteront un peu plus de r\u00e9glages et d'impressions du mod\u00e8le de test. Notez qu'une autre possibilit\u00e9 est d'acheter et d'installer un acc\u00e9l\u00e9rom\u00e8tre et de mesurer les r\u00e9sonances avec (reportez-vous \u00e0 la documentation d\u00e9crivant le mat\u00e9riel requis et le processus de configuration) - mais cette option n\u00e9cessite quelques soudures et un peu de sertissage. Pour le r\u00e9glage, ajoutez une section [input_shaper] vide \u00e0 votre printer.cfg . Ensuite, en supposant que vous avez tranch\u00e9 le mod\u00e8le de r\u00e9sonance avec les param\u00e8tres sugg\u00e9r\u00e9s, imprimez le mod\u00e8le de test 3 fois comme suit. Premi\u00e8re fois, avant l'impression, ex\u00e9cutez RESTART SET_VELOCITY_LIMIT ACCEL_TO_DECEL=7000 SET_PRESSURE_ADVANCE ADVANCE=0 SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=60 SHAPER_FREQ_Y=60 TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 et imprimez le mod\u00e8le. Ensuite, imprimez \u00e0 nouveau le mod\u00e8le, mais avant d'imprimer, ex\u00e9cutez \u00e0 la place SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=50 SHAPER_FREQ_Y=50 TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 Imprimez ensuite le mod\u00e8le pour la 3\u00e8me fois, mais ex\u00e9cutez maintenant SET_INPUT_SHAPER SHAPER_TYPE=2HUMP_EI SHAPER_FREQ_X=40 SHAPER_FREQ_Y=40 TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 Dans la pratique nous imprimons le mod\u00e8le de test de r\u00e9sonance avec TUNING_TOWER en utilisant l'input shaper 2HUMP_EI avec shaper_freq = 60 Hz, 50 Hz et 40 Hz. Si aucun des mod\u00e8les ne d\u00e9montre d'am\u00e9lioration de la r\u00e9sonance, aucune des techniques d'input shaper ne pourra vous aider. Sinon, il se peut que tous les mod\u00e8les n'affichent aucune r\u00e9sonance, ou que certains affichent la r\u00e9sonance et d'autres pas trop. Choisissez le mod\u00e8le de test avec la fr\u00e9quence la plus \u00e9lev\u00e9e qui montre encore de bonnes am\u00e9liorations dans la r\u00e9sonance. Par exemple, si les mod\u00e8les 40 Hz et 50 Hz n'affichent presque aucune r\u00e9sonance et que le mod\u00e8le 60 Hz affiche d\u00e9j\u00e0 un peu plus de r\u00e9sonance, restez \u00e0 50 Hz. V\u00e9rifiez maintenant si l'input shaper EI peut fonctionner dans votre cas. Choisissez la fr\u00e9quence de l'input shaper EI en fonction de la fr\u00e9quence de l'input shaper 2HUMP_EI que vous avez choisie : Pour l'input shaper 2HUMP_EI 60 Hz, utilisez l'input shaper EI avec shaper_freq = 50 Hz. Pour l'input shaper 2HUMP_EI 50 Hz, utilisez l'input shaper EI avec shaper_freq = 40 Hz. Pour l'input shaper 2HUMP_EI \u00e0 40 Hz, utilisez l'input shaper EI avec shaper_freq = 33 Hz. Imprimez le mod\u00e8le de test une fois de plus, en ex\u00e9cutant SET_INPUT_SHAPER SHAPER_TYPE=EI SHAPER_FREQ_X=... SHAPER_FREQ_Y=... TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=1500 STEP_DELTA=500 STEP_HEIGHT=5 en fournissant le shaper_freq_x=... et shaper_freq_y=... comme d\u00e9termin\u00e9 pr\u00e9c\u00e9demment. Si l'input shaper EI montre de bons r\u00e9sultats comparables \u00e0 ceux de l'input shaper 2HUMP_EI, restez avec l'input shaper EI et la fr\u00e9quence d\u00e9termin\u00e9e pr\u00e9c\u00e9demment, sinon utilisez l'input shaper 2HUMP_EI avec la fr\u00e9quence correspondante. Ajoutez les r\u00e9sultats \u00e0 printer.cfg comme, par ex. [input_shaper] shaper_freq_x: 50 shaper_freq_y: 50 shaper_type: 2hump_ei Continuez le r\u00e9glage avec la section Choix de l'acc\u00e9l\u00e9ration maximale .","title":"Mesures peu fiables des fr\u00e9quences de r\u00e9sonance"},{"location":"Resonance_Compensation.html#depannage-et-faq","text":"","title":"D\u00e9pannage et FAQ"},{"location":"Resonance_Compensation.html#je-narrive-pas-a-obtenir-de-mesures-fiables-des-frequences-de-resonance","text":"En premier lieu, assurez-vous qu'il ne s'agit pas d'un autre probl\u00e8me avec l'imprimante plut\u00f4t que de la r\u00e9sonance. Si les mesures ne sont pas fiables parce que, par exemple, la distance entre les oscillations n'est pas stable, cela peut signifier que l'imprimante a plusieurs fr\u00e9quences de r\u00e9sonance sur le m\u00eame axe. On peut essayer de suivre le processus de r\u00e9glage d\u00e9crit dans la section Mesures non fiables des fr\u00e9quences de r\u00e9sonance et tirer encore quelque chose de la technique de l'input shaper. Une autre possibilit\u00e9 consiste \u00e0 installer un acc\u00e9l\u00e9rom\u00e8tre, \u00e0 mesurer les r\u00e9sonances avec celui-ci et \u00e0 r\u00e9gler automatiquement l'input shaper en utilisant les r\u00e9sultats de ces mesures.","title":"Je n'arrive pas \u00e0 obtenir de mesures fiables des fr\u00e9quences de r\u00e9sonance"},{"location":"Resonance_Compensation.html#apres-avoir-active-input_shaper-jobtiens-des-pieces-imprimees-trop-lissees-et-les-details-fins-sont-perdus","text":"V\u00e9rifiez les informations dans la section Choix de l'acc\u00e9l\u00e9ration maximale . Si la fr\u00e9quence de r\u00e9sonance est faible, il ne faut pas d\u00e9finir une valeur trop \u00e9lev\u00e9e pour max_accel ou augmenter les param\u00e8tres square_corner_velocity. Il peut \u00e9galement \u00eatre pr\u00e9f\u00e9rable de choisir un input shaper de type MZV ou m\u00eame ZV plut\u00f4t que EI (ou des shapers 2HUMP_EI et 3HUMP_EI).","title":"Apr\u00e8s avoir activ\u00e9 [input_shaper], j'obtiens des pi\u00e8ces imprim\u00e9es trop liss\u00e9es et les d\u00e9tails fins sont perdus"},{"location":"Resonance_Compensation.html#apres-avoir-reussi-a-imprimer-pendant-un-certain-temps-sans-resonance-elle-semble-revenir","text":"Il est possible qu'apr\u00e8s un certain temps, les fr\u00e9quences de r\u00e9sonance aient chang\u00e9. Par exemple. peut-\u00eatre que la tension des courroies a chang\u00e9 (les courroies sont devenues plus l\u00e2ches), etc. Il est bon de v\u00e9rifier et de mesurer \u00e0 nouveau les fr\u00e9quences de r\u00e9sonance comme d\u00e9crit dans la section Fr\u00e9quence de r\u00e9sonance et de mettre \u00e0 jour votre fichier de configuration si n\u00e9cessaire .","title":"Apr\u00e8s avoir r\u00e9ussi \u00e0 imprimer pendant un certain temps sans r\u00e9sonance, elle semble revenir"},{"location":"Resonance_Compensation.html#la-configuration-a-double-chariot-est-elle-prise-en-charge-avec-linput-shaper","text":"Yes. In this case, one should measure the resonances twice for each carriage. For example, if the second (dual) carriage is installed on X axis, it is possible to set different input shapers for X axis for the primary and dual carriages. However, the input shaper for Y axis should be the same for both carriages (as ultimately this axis is driven by one or more stepper motors each commanded to perform exactly the same steps). One possibility to configure the input shaper for such setups is to keep [input_shaper] section empty and additionally define a [delayed_gcode] section in the printer.cfg as follows: [input_shaper] # Intentionally empty [delayed_gcode init_shaper] initial_duration: 0.1 gcode: SET_DUAL_CARRIAGE CARRIAGE=1 SET_INPUT_SHAPER SHAPER_TYPE_X=<dual_carriage_shaper> SHAPER_FREQ_X=<dual_carriage_freq> SHAPER_TYPE_Y=<y_shaper> SHAPER_FREQ_Y=<y_freq> SET_DUAL_CARRIAGE CARRIAGE=0 SET_INPUT_SHAPER SHAPER_TYPE_X=<primary_carriage_shaper> SHAPER_FREQ_X=<primary_carriage_freq> SHAPER_TYPE_Y=<y_shaper> SHAPER_FREQ_Y=<y_freq> Note that SHAPER_TYPE_Y and SHAPER_FREQ_Y should be the same in both commands. It is also possible to put a similar snippet into the start g-code in the slicer, however then the shaper will not be enabled until any print is started. Note that the input shaper only needs to be configured once. Subsequent changes of the carriages or their modes via SET_DUAL_CARRIAGE command will preserve the configured input shaper parameters.","title":"La configuration \u00e0 double chariot est-elle prise en charge avec l'input shaper\u00a0?"},{"location":"Resonance_Compensation.html#input_shaper-affecte-t-il-le-temps-dimpression","text":"Non, la fonctionnalit\u00e9 input_shaper n'a pratiquement aucun impact sur les temps d'impression. Cependant, la valeur de max_accel en a un (r\u00e9glage de ce param\u00e8tre d\u00e9crit dans cette section ).","title":"input_shaper affecte-t-il le temps d'impression\u00a0?"},{"location":"Resonance_Compensation.html#details-techniques","text":"","title":"D\u00e9tails techniques"},{"location":"Resonance_Compensation.html#input-shapers","text":"Les input shaper utilis\u00e9s dans Klipper sont plut\u00f4t standards, et on peut en trouver un aper\u00e7u plus d\u00e9taill\u00e9 dans les articles d\u00e9crivant les input shaper correspondants. Cette section contient un bref aper\u00e7u de certains aspects techniques des input shapers pris en charge. Le tableau ci-dessous montre certains param\u00e8tres (g\u00e9n\u00e9ralement approximatifs) pour chaque input shaper. Input shaper Dur\u00e9e de l'input shaper R\u00e9duction des vibrations 20x (5 % de tol\u00e9rance aux vibrations) R\u00e9duction des vibrations 10x (tol\u00e9rance aux vibrations de 10 %) ZV 0,5 / shaper_freq N/A \u00b1 5% shaper_freq MZV 0,75 / shaper_freq \u00b1 4% shaper_freq -10%...+15% shaper_freq ZVD 1 / shaper_freq \u00b1 15% shaper_freq \u00b1 22% shaper_freq EI 1 / shaper_freq \u00b1 20% shaper_freq \u00b1 25% shaper_freq 2HUMP_EI 1,5 / shaper_freq \u00b1 35% shaper_freq \u00b1 40 shaper_freq 3HUMP_EI 2 / shaper_freq -45...+50% shaper_freq -50%...+55% shaper_freq Remarque concernant l'att\u00e9nuation des vibrations : les valeurs du tableau ci-dessus sont approximatives. Si le taux d'amortissement de l'imprimante est connu pour chaque axe, l'input shaper peut \u00eatre configur\u00e9 plus pr\u00e9cis\u00e9ment ce qui r\u00e9duira alors les r\u00e9sonances dans une plage de fr\u00e9quences un peu plus large. Cependant, le taux d'amortissement est g\u00e9n\u00e9ralement inconnu et difficile \u00e0 estimer sans \u00e9quipement sp\u00e9cial. Klipper utilise donc la valeur 0,1 par d\u00e9faut, ce qui est une bonne valeur globale. Les gammes de fr\u00e9quences du tableau couvrent un certain nombre de diff\u00e9rents rapports d'amortissement possibles autour de cette valeur (environ de 0,05 \u00e0 0,2). Notez \u00e9galement que EI, 2HUMP_EI et 3HUMP_EI sont r\u00e9gl\u00e9s pour r\u00e9duire les vibrations \u00e0 5 %, les valeurs pour une tol\u00e9rance de vibration de 10 % sont fournies uniquement \u00e0 titre indicatif. Comment utiliser ce tableau : La dur\u00e9e de l'input shaper affecte le lissage des pi\u00e8ces - plus elle est grande, plus les pi\u00e8ces sont lisses. Cette d\u00e9pendance n'est pas lin\u00e9aire, mais peut donner une id\u00e9e des input shapers qui \"lissent\" le plus pour une m\u00eame fr\u00e9quence. L'ordre par lissage est le suivant : ZV < MZV < ZVD \u2248 EI < 2HUMP_EI < 3HUMP_EI. De plus, il est rarement pratique de r\u00e9gler shaper_freq = fr\u00e9quence de r\u00e9sonance des types 2HUMP_EI et 3HUMP_EI (utilis\u00e9s pour r\u00e9duire les vibrations sur plusieurs fr\u00e9quences). On peut estimer une gamme de fr\u00e9quences pour laquelle l'input shaper r\u00e9duit les vibrations. Par exemple, MZV avec shaper_freq = 35 Hz r\u00e9duit les vibrations \u00e0 5 % pour les fr\u00e9quences [33,6, 36,4] Hz. 3HUMP_EI avec shaper_freq = 50 Hz r\u00e9duit les vibrations \u00e0 5 % dans la plage [27,5 - 75] Hz. On peut utiliser ce tableau pour v\u00e9rifier quel input shaper choisir pour la r\u00e9duction des vibrations de plusieurs fr\u00e9quences. Par exemple, si on a des r\u00e9sonances \u00e0 35 Hz et 60 Hz sur le m\u00eame axe : a) EI doit avoir shaper_freq = 35 / (1 - 0.2) = 43.75 Hz, ce qui r\u00e9duirait les r\u00e9sonances jusqu'\u00e0 43.75 * (1 + 0,2) = 52,5 Hz, donc ce n'est pas suffisant ; b) Le 2HUMP_EI doit avoir shaper_freq = 35 / (1 - 0,35) = 53,85 Hz ce qui r\u00e9duira les vibrations jusqu'\u00e0 53,85 * (1 + 0,35) = 72,7 Hz - c'est donc une configuration acceptable. Essayez toujours d'utiliser le plus haut shaper_freq possible pour un input shaper donn\u00e9 (peut-\u00eatre avec une certaine marge de s\u00e9curit\u00e9, donc dans cet exemple shaper_freq \u2248 50-52 Hz fonctionnerait mieux), et essayez d'utiliser un input shaper avec une dur\u00e9e aussi petite que possible. Si l'on a besoin de r\u00e9duire les vibrations de plusieurs fr\u00e9quences tr\u00e8s diff\u00e9rentes (par exemple, 30 Hz et 100 Hz), le tableau ci-dessus ne fournit pas suffisamment d'informations. Dans ce cas, on peut avoir plus de chance avec le script scripts/graph_shaper.py , qui est plus flexible.","title":"Input shapers"},{"location":"Rotation_Distance.html","text":"Distance de rotation \u00b6 Les pilotes de moteur pas \u00e0 pas avec Klipper n\u00e9cessitent un param\u00e8tre rotation_distance dans chaque section de configuration des pilotes pas \u00e0 pas . La rotation_distance est la distance parcourue par l'axe apr\u00e8s un tour complet du moteur pas \u00e0 pas. Ce document d\u00e9crit comment configurer cette valeur. Obtention de la distance de rotation \u00e0 partir de steps_per_mm (ou step_distance) \u00b6 Les concepteurs de votre imprimante 3d ont calcul\u00e9 \u00e0 l'origine les pas_par_mm \u00e0 partir d'une distance de rotation. Si vous connaissez les pas_par_mm, il est possible d'utiliser cette formule g\u00e9n\u00e9rale pour obtenir cette distance de rotation originale : rotation_distance = <full_steps_par_rotation> * <microsteps> / <steps_par_mm> Ou, si vous avez une ancienne configuration Klipper et que vous connaissez le param\u00e8tre step_distance , vous pouvez utiliser cette formule : rotation_distance = <full_steps_per_rotation> * <microsteps> * <step_distance> Le param\u00e8tre <full_steps_per_rotation> est d\u00e9termin\u00e9 par le type du moteur pas \u00e0 pas. La plupart des moteurs pas \u00e0 pas sont des \"pas \u00e0 pas de 1,8 degr\u00e9\" et ont donc 200 pas complets par rotation (360 divis\u00e9 par 1,8 est \u00e9gal \u00e0 200). Certains moteurs pas \u00e0 pas sont des \"pas \u00e0 pas de 0,9 degr\u00e9\" et ont donc 400 pas complets par rotation. D'autres type de moteurs pas \u00e0 pas sont rares. En cas de doute, ne d\u00e9finissez pas full_steps_per_rotation dans le fichier de configuration et utilisez 200 dans la formule ci-dessus. Le param\u00e8tre <microsteps> est d\u00e9termin\u00e9 par le pilote du moteur pas \u00e0 pas. La plupart des pilotes utilisent 16 micro-pas. Si vous n'\u00eates pas s\u00fbr, d\u00e9finissez microsteps : 16 dans la configuration et utilisez 16 dans la formule ci-dessus. Presque toutes les imprimantes devraient utiliser un nombre entier pour la distance de rotation des axes de type X, Y, et Z. Si la formule ci-dessus donne une distance de rotation qui est \u00e0 moins de 0,01 d'un nombre entier, arrondissez la valeur finale \u00e0 ce nombre entier. Calibration de la distance de rotation des extrudeuses \u00b6 Sur une extrudeuse, la rotation_distance est la distance que parcourt le filament durant une rotation compl\u00e8te du moteur pas \u00e0 pas. La meilleure fa\u00e7on d'obtenir une valeur pr\u00e9cise pour ce param\u00e8tre est d'utiliser une proc\u00e9dure de \"mesure et ajustement\". Commencez par une estimation initiale de la distance de rotation. Elle peut \u00eatre obtenue \u00e0 partir de pas_par_mm ou en inspectant le mat\u00e9riel . Utilisez ensuite la proc\u00e9dure suivante pour \"mesurer et ajuster\" : Assurez-vous que l'extrudeuse contient du filament, que le bloc chauffant est \u00e0 une temp\u00e9rature appropri\u00e9e et que l'imprimante est pr\u00eate \u00e0 extruder. Utilisez un marqueur pour placer une marque sur le filament \u00e0 environ 70 mm de l'entr\u00e9e du corps de l'extrudeuse. Utilisez ensuite un pied \u00e0 coulisse num\u00e9rique pour mesurer la distance r\u00e9elle de cette marque aussi pr\u00e9cis\u00e9ment que possible. Notez cette mesure comme <initial_mark_distance> . Extrudez 50 mm de filament avec la s\u00e9quence de commandes suivante : G91 suivi de G1 E50 F60 . Notez 50mm comme <distance_extrud\u00e9e_requise> . Attendez que l'extrudeuse termine son mouvement (cela prendra environ 50 secondes). Il est important d'utiliser la vitesse d'extrusion lente pour ce test car une vitesse plus rapide peut provoquer une pression \u00e9lev\u00e9e dans l'extrudeuse qui fausserait les r\u00e9sultats. (N'utilisez pas le \"bouton d'extrusion\" des interfaces graphiques pour ce test car ils extrudent \u00e0 une vitesse rapide.) Utilisez le pied \u00e0 coulisse num\u00e9rique pour mesurer la nouvelle distance entre le corps de l'extrudeuse et la marque sur le filament. Notez cette distance comme <distance_marque_suivante> . Calculez ensuite : Distance_extrud\u00e9e_r\u00e9elle = <distance_marque_initiale> - <distance_marque_suivante> Calculez la distance de rotation comme suit : distance_rotation = <distance_rotation_pr\u00e9c\u00e9dente> * <distance_extrusion_r\u00e9elle> / <distance_extrusion_demand\u00e9e> Arrondissez la nouvelle distance_rotation \u00e0 trois d\u00e9cimales. Si la distance_extrud\u00e9e_r\u00e9elle diff\u00e8re de la distance_extrud\u00e9e_requise de plus de 2 mm environ, il est bon d'effectuer les \u00e9tapes ci-dessus une nouvelle fois. Remarque : n'utilisez pas une m\u00e9thode de type \" mesurer et ajuster \" pour calibrer les axes de type x, y ou z. La m\u00e9thode \" mesurer et ajuster \" n'est pas assez pr\u00e9cise pour ces axes et conduira probablement \u00e0 une configuration moins bonne. Au lieu de cela, si n\u00e9cessaire, ces axes peuvent \u00eatre d\u00e9termin\u00e9s en mesurant les courroies, les poulies et les vis-m\u00e8re . Obtention de la distance de rotation par l'inspection du mat\u00e9riel \u00b6 Il est possible de calculer la distance de rotation en connaissant les moteurs pas \u00e0 pas et la cin\u00e9matique de l'imprimante. Cela peut \u00eatre utile si le nombre de pas par mm n'est pas connu ou si l'on con\u00e7oit une nouvelle imprimante. Axes entra\u00een\u00e9s par courroie \u00b6 Il est facile de calculer la distance de rotation pour un axe lin\u00e9aire utilisant une courroie et une poulie. D\u00e9terminez d'abord le type de courroie. La plupart des imprimantes utilisent un pas de courroie de 2 mm (c'est-\u00e0-dire que chaque dent de la courroie est espac\u00e9e de 2 mm). Comptez ensuite le nombre de dents sur la poulie du moteur pas \u00e0 pas. La distance de rotation est alors calcul\u00e9e comme suit : rotation_distance = <belt_pitch> * <number_of_teeth_on_pulley> Par exemple, si une imprimante a une courroie dont le pas est de 2 mm et utilise une poulie \u00e0 20 dents, la distance de rotation est de 40. Axes avec vis-m\u00e8re \u00b6 Il est facile de calculer la distance de rotation pour les vis-m\u00e8res communes \u00e0 l'aide de la formule suivante : rotation_distance = <screw_pitch> * <number_of_separate_threads> Par exemple, la \"vis-m\u00e8re T8\" courante a une distance de rotation de 8 (elle a un pas de 2 mm et comporte 4 filets s\u00e9par\u00e9s). Les imprimantes plus anciennes \u00e9quip\u00e9es de \"tiges filet\u00e9es\" n'ont qu'un seul \"filetage\" sur la vis-m\u00e8re et la distance de rotation correspond donc au pas de la vis. (Le pas de la vis est la distance entre chaque rainure de la vis). Ainsi, par exemple, une tige m\u00e9trique M6 a une distance de rotation de 1 et une tige M8 a une distance de rotation de 1,25. Extrudeuse \u00b6 Il est possible d'obtenir une distance de rotation initiale pour les extrudeuses en mesurant le diam\u00e8tre de la \"roue dent\u00e9e\" entrainant le filament, en utilisant la formule suivante : distance_de_rotation = <diam\u00e8tre> * 3.14 Si l'extrudeuse utilise des engrenages, il faudra \u00e9galement d\u00e9terminer et r\u00e9gler le rapport de d\u00e9multiplication pour celle-ci. La distance de rotation r\u00e9elle d'une extrudeuse varie d'une imprimante \u00e0 l'autre, car la prise de la \"roue cr\u00e9nel\u00e9e\" qui s'engage dans le filament peut varier. Elle peut m\u00eame varier d'une bobine de filament \u00e0 l'autre. Apr\u00e8s avoir obtenu une distance de rotation initiale, utilisez la proc\u00e9dure de mesure et d'ajustement pour obtenir un r\u00e9glage plus pr\u00e9cis. Utilisation d'un gear_ratio \u00b6 D\u00e9finir un gear_ratio peut faciliter la configuration de la rotation_distance des moteurs ayant une bo\u00eete de vitesse (ou similaire) attach\u00e9e \u00e0 eux. La plupart des moteurs n'ont pas de bo\u00eete de vitesse - si vous n'\u00eates pas s\u00fbr, n'utilisez pas de gear_ratio dans la configuration. Lorsqu'un gear_ratio est d\u00e9fini, la rotation_distance repr\u00e9sente la distance parcourue par l'axe lors d'une rotation compl\u00e8te du dernier engrenage de la bo\u00eete de vitesses. Si, par exemple, on utilise une bo\u00eete de vitesses avec un rapport \"5:1\", on peut calculer la distance de rotation avec connaissance du mat\u00e9riel et ensuite ajouter gear_ratio : 5:1 \u00e0 la configuration. Pour des engrenages mis en \u0153uvre avec des courroies et des poulies, il est possible de d\u00e9terminer le rapport de d\u00e9multiplication en comptant les dents des poulies. Par exemple, si une poulie de 16 dents entra\u00eene la poulie suivante de 80 dents, on utilisera gear_ratio : 80:16 . En effet, on peut ouvrir une \"bo\u00eete de vitesse\" courante et compter les dents pour confirmer le rapport d'engrenage. Notez que parfois, une bo\u00eete de vitesses aura un rapport de transmission l\u00e9g\u00e8rement diff\u00e9rent de celui qui est annonc\u00e9. Les engrenages courants du moteur d'extrudeuse BMG en sont un exemple - ils sont annonc\u00e9s comme \u00e9tant de \"3:1\" mais utilisent en r\u00e9alit\u00e9 un engrenage de \"50:17\". (L'utilisation de nombres de dents sans d\u00e9nominateur commun peut am\u00e9liorer l'usure globale de l'engrenage car les dents ne s'engr\u00e8nent pas toujours de la m\u00eame mani\u00e8re \u00e0 chaque tour). La \"boite de vitesses plan\u00e9taire 5.18:1\" commune, est plus pr\u00e9cis\u00e9ment configur\u00e9e avec un gear_ratio : 57:11 . Si plusieurs engrenages sont utilis\u00e9s sur un axe, il est possible de fournir une liste s\u00e9par\u00e9e par des virgules au param\u00e8tre gear_ratio. Par exemple, une bo\u00eete de vitesse \"5:1\" entra\u00eenant une poulie de 16 \u00e0 80 dents pourrait utiliser gear_ratio : 5:1, 80:16 . Dans la plupart des cas, le param\u00e8tre gear_ratio doit \u00eatre d\u00e9fini avec des nombres entiers, car les engrenages et les poulies les plus courants ont un nombre entier de dents. Cependant, dans les cas o\u00f9 une courroie entra\u00eene une poulie en utilisant la friction au lieu des dents, il peut \u00eatre utile d'utiliser un nombre \u00e0 virgule flottante dans le rapport de vitesse (par exemple, gear_ratio : 107.237:16 ).","title":"Distance de rotation"},{"location":"Rotation_Distance.html#distance-de-rotation","text":"Les pilotes de moteur pas \u00e0 pas avec Klipper n\u00e9cessitent un param\u00e8tre rotation_distance dans chaque section de configuration des pilotes pas \u00e0 pas . La rotation_distance est la distance parcourue par l'axe apr\u00e8s un tour complet du moteur pas \u00e0 pas. Ce document d\u00e9crit comment configurer cette valeur.","title":"Distance de rotation"},{"location":"Rotation_Distance.html#obtention-de-la-distance-de-rotation-a-partir-de-steps_per_mm-ou-step_distance","text":"Les concepteurs de votre imprimante 3d ont calcul\u00e9 \u00e0 l'origine les pas_par_mm \u00e0 partir d'une distance de rotation. Si vous connaissez les pas_par_mm, il est possible d'utiliser cette formule g\u00e9n\u00e9rale pour obtenir cette distance de rotation originale : rotation_distance = <full_steps_par_rotation> * <microsteps> / <steps_par_mm> Ou, si vous avez une ancienne configuration Klipper et que vous connaissez le param\u00e8tre step_distance , vous pouvez utiliser cette formule : rotation_distance = <full_steps_per_rotation> * <microsteps> * <step_distance> Le param\u00e8tre <full_steps_per_rotation> est d\u00e9termin\u00e9 par le type du moteur pas \u00e0 pas. La plupart des moteurs pas \u00e0 pas sont des \"pas \u00e0 pas de 1,8 degr\u00e9\" et ont donc 200 pas complets par rotation (360 divis\u00e9 par 1,8 est \u00e9gal \u00e0 200). Certains moteurs pas \u00e0 pas sont des \"pas \u00e0 pas de 0,9 degr\u00e9\" et ont donc 400 pas complets par rotation. D'autres type de moteurs pas \u00e0 pas sont rares. En cas de doute, ne d\u00e9finissez pas full_steps_per_rotation dans le fichier de configuration et utilisez 200 dans la formule ci-dessus. Le param\u00e8tre <microsteps> est d\u00e9termin\u00e9 par le pilote du moteur pas \u00e0 pas. La plupart des pilotes utilisent 16 micro-pas. Si vous n'\u00eates pas s\u00fbr, d\u00e9finissez microsteps : 16 dans la configuration et utilisez 16 dans la formule ci-dessus. Presque toutes les imprimantes devraient utiliser un nombre entier pour la distance de rotation des axes de type X, Y, et Z. Si la formule ci-dessus donne une distance de rotation qui est \u00e0 moins de 0,01 d'un nombre entier, arrondissez la valeur finale \u00e0 ce nombre entier.","title":"Obtention de la distance de rotation \u00e0 partir de steps_per_mm (ou step_distance)"},{"location":"Rotation_Distance.html#calibration-de-la-distance-de-rotation-des-extrudeuses","text":"Sur une extrudeuse, la rotation_distance est la distance que parcourt le filament durant une rotation compl\u00e8te du moteur pas \u00e0 pas. La meilleure fa\u00e7on d'obtenir une valeur pr\u00e9cise pour ce param\u00e8tre est d'utiliser une proc\u00e9dure de \"mesure et ajustement\". Commencez par une estimation initiale de la distance de rotation. Elle peut \u00eatre obtenue \u00e0 partir de pas_par_mm ou en inspectant le mat\u00e9riel . Utilisez ensuite la proc\u00e9dure suivante pour \"mesurer et ajuster\" : Assurez-vous que l'extrudeuse contient du filament, que le bloc chauffant est \u00e0 une temp\u00e9rature appropri\u00e9e et que l'imprimante est pr\u00eate \u00e0 extruder. Utilisez un marqueur pour placer une marque sur le filament \u00e0 environ 70 mm de l'entr\u00e9e du corps de l'extrudeuse. Utilisez ensuite un pied \u00e0 coulisse num\u00e9rique pour mesurer la distance r\u00e9elle de cette marque aussi pr\u00e9cis\u00e9ment que possible. Notez cette mesure comme <initial_mark_distance> . Extrudez 50 mm de filament avec la s\u00e9quence de commandes suivante : G91 suivi de G1 E50 F60 . Notez 50mm comme <distance_extrud\u00e9e_requise> . Attendez que l'extrudeuse termine son mouvement (cela prendra environ 50 secondes). Il est important d'utiliser la vitesse d'extrusion lente pour ce test car une vitesse plus rapide peut provoquer une pression \u00e9lev\u00e9e dans l'extrudeuse qui fausserait les r\u00e9sultats. (N'utilisez pas le \"bouton d'extrusion\" des interfaces graphiques pour ce test car ils extrudent \u00e0 une vitesse rapide.) Utilisez le pied \u00e0 coulisse num\u00e9rique pour mesurer la nouvelle distance entre le corps de l'extrudeuse et la marque sur le filament. Notez cette distance comme <distance_marque_suivante> . Calculez ensuite : Distance_extrud\u00e9e_r\u00e9elle = <distance_marque_initiale> - <distance_marque_suivante> Calculez la distance de rotation comme suit : distance_rotation = <distance_rotation_pr\u00e9c\u00e9dente> * <distance_extrusion_r\u00e9elle> / <distance_extrusion_demand\u00e9e> Arrondissez la nouvelle distance_rotation \u00e0 trois d\u00e9cimales. Si la distance_extrud\u00e9e_r\u00e9elle diff\u00e8re de la distance_extrud\u00e9e_requise de plus de 2 mm environ, il est bon d'effectuer les \u00e9tapes ci-dessus une nouvelle fois. Remarque : n'utilisez pas une m\u00e9thode de type \" mesurer et ajuster \" pour calibrer les axes de type x, y ou z. La m\u00e9thode \" mesurer et ajuster \" n'est pas assez pr\u00e9cise pour ces axes et conduira probablement \u00e0 une configuration moins bonne. Au lieu de cela, si n\u00e9cessaire, ces axes peuvent \u00eatre d\u00e9termin\u00e9s en mesurant les courroies, les poulies et les vis-m\u00e8re .","title":"Calibration de la distance de rotation des extrudeuses"},{"location":"Rotation_Distance.html#obtention-de-la-distance-de-rotation-par-linspection-du-materiel","text":"Il est possible de calculer la distance de rotation en connaissant les moteurs pas \u00e0 pas et la cin\u00e9matique de l'imprimante. Cela peut \u00eatre utile si le nombre de pas par mm n'est pas connu ou si l'on con\u00e7oit une nouvelle imprimante.","title":"Obtention de la distance de rotation par l'inspection du mat\u00e9riel"},{"location":"Rotation_Distance.html#axes-entraines-par-courroie","text":"Il est facile de calculer la distance de rotation pour un axe lin\u00e9aire utilisant une courroie et une poulie. D\u00e9terminez d'abord le type de courroie. La plupart des imprimantes utilisent un pas de courroie de 2 mm (c'est-\u00e0-dire que chaque dent de la courroie est espac\u00e9e de 2 mm). Comptez ensuite le nombre de dents sur la poulie du moteur pas \u00e0 pas. La distance de rotation est alors calcul\u00e9e comme suit : rotation_distance = <belt_pitch> * <number_of_teeth_on_pulley> Par exemple, si une imprimante a une courroie dont le pas est de 2 mm et utilise une poulie \u00e0 20 dents, la distance de rotation est de 40.","title":"Axes entra\u00een\u00e9s par courroie"},{"location":"Rotation_Distance.html#axes-avec-vis-mere","text":"Il est facile de calculer la distance de rotation pour les vis-m\u00e8res communes \u00e0 l'aide de la formule suivante : rotation_distance = <screw_pitch> * <number_of_separate_threads> Par exemple, la \"vis-m\u00e8re T8\" courante a une distance de rotation de 8 (elle a un pas de 2 mm et comporte 4 filets s\u00e9par\u00e9s). Les imprimantes plus anciennes \u00e9quip\u00e9es de \"tiges filet\u00e9es\" n'ont qu'un seul \"filetage\" sur la vis-m\u00e8re et la distance de rotation correspond donc au pas de la vis. (Le pas de la vis est la distance entre chaque rainure de la vis). Ainsi, par exemple, une tige m\u00e9trique M6 a une distance de rotation de 1 et une tige M8 a une distance de rotation de 1,25.","title":"Axes avec vis-m\u00e8re"},{"location":"Rotation_Distance.html#extrudeuse","text":"Il est possible d'obtenir une distance de rotation initiale pour les extrudeuses en mesurant le diam\u00e8tre de la \"roue dent\u00e9e\" entrainant le filament, en utilisant la formule suivante : distance_de_rotation = <diam\u00e8tre> * 3.14 Si l'extrudeuse utilise des engrenages, il faudra \u00e9galement d\u00e9terminer et r\u00e9gler le rapport de d\u00e9multiplication pour celle-ci. La distance de rotation r\u00e9elle d'une extrudeuse varie d'une imprimante \u00e0 l'autre, car la prise de la \"roue cr\u00e9nel\u00e9e\" qui s'engage dans le filament peut varier. Elle peut m\u00eame varier d'une bobine de filament \u00e0 l'autre. Apr\u00e8s avoir obtenu une distance de rotation initiale, utilisez la proc\u00e9dure de mesure et d'ajustement pour obtenir un r\u00e9glage plus pr\u00e9cis.","title":"Extrudeuse"},{"location":"Rotation_Distance.html#utilisation-dun-gear_ratio","text":"D\u00e9finir un gear_ratio peut faciliter la configuration de la rotation_distance des moteurs ayant une bo\u00eete de vitesse (ou similaire) attach\u00e9e \u00e0 eux. La plupart des moteurs n'ont pas de bo\u00eete de vitesse - si vous n'\u00eates pas s\u00fbr, n'utilisez pas de gear_ratio dans la configuration. Lorsqu'un gear_ratio est d\u00e9fini, la rotation_distance repr\u00e9sente la distance parcourue par l'axe lors d'une rotation compl\u00e8te du dernier engrenage de la bo\u00eete de vitesses. Si, par exemple, on utilise une bo\u00eete de vitesses avec un rapport \"5:1\", on peut calculer la distance de rotation avec connaissance du mat\u00e9riel et ensuite ajouter gear_ratio : 5:1 \u00e0 la configuration. Pour des engrenages mis en \u0153uvre avec des courroies et des poulies, il est possible de d\u00e9terminer le rapport de d\u00e9multiplication en comptant les dents des poulies. Par exemple, si une poulie de 16 dents entra\u00eene la poulie suivante de 80 dents, on utilisera gear_ratio : 80:16 . En effet, on peut ouvrir une \"bo\u00eete de vitesse\" courante et compter les dents pour confirmer le rapport d'engrenage. Notez que parfois, une bo\u00eete de vitesses aura un rapport de transmission l\u00e9g\u00e8rement diff\u00e9rent de celui qui est annonc\u00e9. Les engrenages courants du moteur d'extrudeuse BMG en sont un exemple - ils sont annonc\u00e9s comme \u00e9tant de \"3:1\" mais utilisent en r\u00e9alit\u00e9 un engrenage de \"50:17\". (L'utilisation de nombres de dents sans d\u00e9nominateur commun peut am\u00e9liorer l'usure globale de l'engrenage car les dents ne s'engr\u00e8nent pas toujours de la m\u00eame mani\u00e8re \u00e0 chaque tour). La \"boite de vitesses plan\u00e9taire 5.18:1\" commune, est plus pr\u00e9cis\u00e9ment configur\u00e9e avec un gear_ratio : 57:11 . Si plusieurs engrenages sont utilis\u00e9s sur un axe, il est possible de fournir une liste s\u00e9par\u00e9e par des virgules au param\u00e8tre gear_ratio. Par exemple, une bo\u00eete de vitesse \"5:1\" entra\u00eenant une poulie de 16 \u00e0 80 dents pourrait utiliser gear_ratio : 5:1, 80:16 . Dans la plupart des cas, le param\u00e8tre gear_ratio doit \u00eatre d\u00e9fini avec des nombres entiers, car les engrenages et les poulies les plus courants ont un nombre entier de dents. Cependant, dans les cas o\u00f9 une courroie entra\u00eene une poulie en utilisant la friction au lieu des dents, il peut \u00eatre utile d'utiliser un nombre \u00e0 virgule flottante dans le rapport de vitesse (par exemple, gear_ratio : 107.237:16 ).","title":"Utilisation d'un gear_ratio"},{"location":"SDCard_Updates.html","text":"Mises \u00e0 jour via la carte SD \u00b6 La plupart des microcontr\u00f4leurs actuels sont livr\u00e9s avec un programme d'amor\u00e7age capable de mettre \u00e0 jour le micrologiciel via une carte SD. Bien que cela soit pratique dans de nombreux cas, ces programmes d'amor\u00e7age ne fournissent g\u00e9n\u00e9ralement aucun autre moyen de mettre \u00e0 jour le micrologiciel. Cela peut s'av\u00e9rer g\u00eanant si votre carte est install\u00e9e dans un endroit difficile d'acc\u00e8s ou si vous avez besoin de mettre \u00e0 jour le firmware r\u00e9guli\u00e8rement. Apr\u00e8s avoir initialement flash\u00e9 Klipper sur un microcontr\u00f4leur, il est possible de transf\u00e9rer le nouveau micrologiciel sur la carte SD et de lancer le processus de mise \u00e0 jour via ssh. Proc\u00e9dure de mise \u00e0 jour classique \u00b6 La proc\u00e9dure pour mettre \u00e0 jour le firmware du MCU en utilisant la carte SD est similaire \u00e0 celle des autres m\u00e9thodes. Au lieu d'utiliser make flash , il est n\u00e9cessaire d'ex\u00e9cuter un script d'aide, flash-sdcard.sh . La mise \u00e0 jour d'un BigTreeTech SKR 1.3 pourrait ressembler \u00e0 ce qui suit : sudo service klipper stop cd ~/klipper git pull make clean make menuconfig make ./scripts/flash-sdcard.sh /dev/ttyACM0 btt-skr-v1.3 sudo service klipper start C'est \u00e0 l'utilisateur de d\u00e9terminer l'emplacement du p\u00e9riph\u00e9rique et le nom de la carte. Si un utilisateur a besoin de flasher plusieurs cartes, flash-sdcard.sh (ou make flash si appropri\u00e9) doit \u00eatre ex\u00e9cut\u00e9 pour chaque carte avant de red\u00e9marrer le service Klipper. Les cartes support\u00e9es peuvent \u00eatre list\u00e9es avec la commande suivante : ./scripts/flash-sdcard.sh -l Si votre carte ne figure pas dans la liste, il peut \u00eatre n\u00e9cessaire d'ajouter une nouvelle d\u00e9finition de carte comme d\u00e9crit ci-dessous . Utilisation avanc\u00e9e \u00b6 Les commandes ci-dessus supposent que votre MCU se connecte \u00e0 la vitesse de transmission par d\u00e9faut de 250000 et que le firmware se trouve dans ~/klipper/out/klipper.bin . Le script flash-sdcard.sh fournit des options pour changer ces valeurs par d\u00e9faut. Toutes les options peuvent \u00eatre visualis\u00e9es par l'\u00e9cran d'aide : ./scripts/flash-sdcard.sh -h SD Card upload utility for Klipper usage: flash_sdcard.sh [-h] [-l] [-c] [-b <baud>] [-f <firmware>] <device> <board> positional arguments: <device> device serial port <board> board type optional arguments: -h show this message -l list available boards -c run flash check/verify only (skip upload) -b <baud> serial baud rate (default is 250000) -f <firmware> path to klipper.bin Si votre carte est flash\u00e9e avec un micro logiciel qui se connecte \u00e0 une vitesse (baud rate) personnalis\u00e9e, il est possible de mettre \u00e0 jour en sp\u00e9cifiant l'option -b : ./scripts/flash-sdcard.sh -b 115200 /dev/ttyAMA0 btt-skr-v1.3 Si vous souhaitez flasher une version de Klipper situ\u00e9e ailleurs que dans l'emplacement par d\u00e9faut, vous pouvez le faire en sp\u00e9cifiant l'option -f : ./scripts/flash-sdcard.sh -f ~/downloads/klipper.bin /dev/ttyAMA0 btt-skr-v1.3 Notez que lors de la mise \u00e0 jour d'un MKS Robin E3, il n'est pas n\u00e9cessaire d'ex\u00e9cuter manuellement update_mks_robin.py et de fournir le binaire r\u00e9sultant \u00e0 flash-sdcard.sh . Cette proc\u00e9dure est automatis\u00e9e pendant le processus de t\u00e9l\u00e9versement. L'option -c est utilis\u00e9e pour effectuer une op\u00e9ration de contr\u00f4le ou de v\u00e9rification uniquement pour tester si la carte ex\u00e9cute correctement le firmware sp\u00e9cifi\u00e9. Cette option est principalement destin\u00e9e aux cas o\u00f9 un cycle d'alimentation manuel est n\u00e9cessaire pour compl\u00e9ter la proc\u00e9dure de flashage, comme avec des chargeurs de d\u00e9marrage utilisant le mode SDIO au lieu de SPI pour acc\u00e9der \u00e0 leurs cartes SD. (Voir Caveats ci-dessous) Mais, elle peut \u00e9galement \u00eatre utilis\u00e9e \u00e0 tout moment pour v\u00e9rifier si le code flash\u00e9 dans la carte correspond \u00e0 la version dans votre dossier de construction sur toute carte support\u00e9e. Avertissements \u00b6 Comme mentionn\u00e9 dans l'introduction, cette m\u00e9thode ne fonctionne que pour la mise \u00e0 jour du firmware. La proc\u00e9dure de flashage initial doit \u00eatre effectu\u00e9e manuellement selon les instructions qui s'appliquent \u00e0 votre carte contr\u00f4leur. Bien qu'il soit possible de flasher un build qui change le Baud s\u00e9rie ou l'interface de connexion (par exemple, de USB \u00e0 UART), la v\u00e9rification \u00e9chouera toujours car le script ne pourra pas se reconnecter au MCU pour v\u00e9rifier la version actuelle. Seules les cartes utilisant SPI pour la communication avec la carte SD sont support\u00e9es. Les cartes utiliaent SDIO, comme la Flymaker Flyboard et la MKS Robin Nano V1/V2, ne fonctionneront pas en mode SDIO. Cependant, il est g\u00e9n\u00e9ralement possible de flasher ces cartes en utilisant le mode SPI logiciel. Mais si le chargeur d'amor\u00e7age de la carte n'utilise que le mode SDIO pour acc\u00e9der \u00e0 la carte SD, un cycle d'alimentation de la carte et de la carte SD sera n\u00e9cessaire pour que le mode puisse passer de SPI \u00e0 SDIO pour terminer le flashage. De telles cartes devraient \u00eatre d\u00e9finies avec skip_verify activ\u00e9 pour sauter l'\u00e9tape de v\u00e9rification imm\u00e9diatement apr\u00e8s le flashage. Ensuite, apr\u00e8s le power-cycle manuel, vous pouvez r\u00e9-ex\u00e9cuter exactement la m\u00eame commande ./scripts/flash-sdcard.sh , mais ajouter l'option -c pour compl\u00e9ter l'op\u00e9ration de v\u00e9rification. Voir Flasher des cartes utilisant SDIO pour des exemples. D\u00e9finitions des cartes \u00b6 La plupart des cartes courantes devraient \u00eatre disponibles, mais il est possible d'ajouter une nouvelle d\u00e9finition de carte si n\u00e9cessaire. Les d\u00e9finitions des cartes sont situ\u00e9es dans ~/klipper/scripts/spi_flash/board_defs.py . Les d\u00e9finitions sont stock\u00e9es dans un dictionnaire, par exemple : BOARD_DEFS = { 'generic-lpc1768' : { 'mcu' : \"lpc1768\" , 'spi_bus' : \"ssp1\" , \"cs_pin\" : \"P0.6\" }, ...< further definitions > } Les champs suivants peuvent \u00eatre pr\u00e9cis\u00e9s : mcu : le type de mcu. Il peut \u00eatre r\u00e9cup\u00e9r\u00e9 apr\u00e8s avoir configur\u00e9 la construction via make menuconfig en ex\u00e9cutant cat .config | grepCONFIG_MCU . Ce champ est obligatoire. spi_bus : Le bus SPI connect\u00e9 \u00e0 la carte SD. Cette information doit \u00eatre r\u00e9cup\u00e9r\u00e9e \u00e0 partir du sch\u00e9ma de la carte. Ce champ est obligatoire. cs_pin : La broche de s\u00e9lection de puce connect\u00e9e \u00e0 la carte SD. Cette information doit \u00eatre r\u00e9cup\u00e9r\u00e9e \u00e0 partir du sch\u00e9ma de la carte. Ce champ est obligatoire. firmware_path : Le chemin sur la carte SD o\u00f9 le firmware doit \u00eatre transf\u00e9r\u00e9. La valeur par d\u00e9faut est firmware.bin . current_firmware_path : Le chemin sur la carte SD o\u00f9 le fichier du firmware renomm\u00e9 est situ\u00e9 apr\u00e8s un flash r\u00e9ussi. La valeur par d\u00e9faut est firmware.cur . skip_verify : d\u00e9finit une valeur bool\u00e9enne indiquant aux scripts d'ignorer l'\u00e9tape de v\u00e9rification du firmware pendant le processus de flashage. La valeur par d\u00e9faut est False . Peut \u00eatre d\u00e9fini \u00e0 True pour les cartes n\u00e9cessitant un cycle d'alimentation manuel pour terminer le flashage. Pour v\u00e9rifier le firmware par la suite, ex\u00e9cutez \u00e0 nouveau le script avec l'option -c pour effectuer l'\u00e9tape de v\u00e9rification. Voir les avertissements avec les cartes SDIO Si le SPI logiciel est requis, le champ spi_bus doit \u00eatre r\u00e9gl\u00e9 sur swspi et le champ suppl\u00e9mentaire suivant doit \u00eatre sp\u00e9cifi\u00e9 : spi_pins : Ceci devrait \u00eatre 3 broches s\u00e9par\u00e9es par des virgules qui sont connect\u00e9es \u00e0 la carte SD dans le format de miso,mosi,sclk . Il devrait \u00eatre extr\u00eamement rare que le SPI logiciel soit n\u00e9cessaire, typiquement seules les cartes avec des erreurs de conception ou les cartes ne supportant que le mode SDIO pour leur carte SD en auront besoin. La d\u00e9finition de la carte btt-skr-pro fournit un exemple du premier cas, et la d\u00e9finition de la carte btt-octopus-f446-v1 fournit un exemple du second. Avant de cr\u00e9er une nouvelle d\u00e9finition de carte, il faut v\u00e9rifier si la d\u00e9finition d'une carte existante r\u00e9pond aux crit\u00e8res n\u00e9cessaires pour la nouvelle carte. Si c'est le cas, un BOARD_ALIAS peut \u00eatre utilis\u00e9. Par exemple, l'alias suivant peut \u00eatre ajout\u00e9 pour sp\u00e9cifier my-new-board comme alias de generic-lpc1768 : BOARD_ALIASES = { ...< previous aliases > , 'my-new-board' : BOARD_DEFS [ 'generic-lpc1768' ], } Si vous avez besoin d'une nouvelle d\u00e9finition de carte et que vous n'\u00eates pas \u00e0 l'aise avec la proc\u00e9dure d\u00e9crite ci-dessus, il est recommand\u00e9 d'en demander une sur le Discord de la communaut\u00e9 Klipper . Flashage des cartes utilisant SDIO \u00b6 Comme mentionn\u00e9 dans les Caveats , les cartes dont le chargeur de d\u00e9marrage utilise le mode SDIO pour l'acc\u00e8s \u00e0 leur carte SD n\u00e9cessitent un power-cycle de la carte, et plus particuli\u00e8rement de la carte SD elle-m\u00eame, afin de passer du mode SPI utilis\u00e9 lors de l'\u00e9criture du fichier sur la carte SD au mode SDIO pour que le chargeur de d\u00e9marrage puisse le flasher sur la carte. Ces d\u00e9finitions de cartes utiliseront le drapeau skip_verify , qui indique \u00e0 l'outil de flashage de s'arr\u00eater apr\u00e8s l'\u00e9criture du firmware sur la carte SD afin que la carte puisse \u00eatre mise sous tension manuellement et que l'\u00e9tape de v\u00e9rification soit report\u00e9e jusqu'\u00e0 ce qu'elle soit termin\u00e9e. Il y a deux sc\u00e9narios : l'un avec l'h\u00f4te RPi fonctionnant sur une alimentation s\u00e9par\u00e9e et l'autre lorsque l'h\u00f4te RPi fonctionne sur la m\u00eame alimentation que la carte principale \u00e0 flasher. La diff\u00e9rence est de savoir s'il est n\u00e9cessaire ou non d'\u00e9teindre le RPi et ensuite ssh de nouveau apr\u00e8s que le flashage soit termin\u00e9 afin de faire l'\u00e9tape de v\u00e9rification, ou si la v\u00e9rification peut \u00eatre faite imm\u00e9diatement. Voici des exemples des deux sc\u00e9narios : Programmation SDIO avec RPi sur alimentation s\u00e9par\u00e9e \u00b6 Une session typique avec le RPi sur une alimentation s\u00e9par\u00e9e ressemble \u00e0 ce qui suit. Vous devrez, bien s\u00fbr, utiliser le chemin du p\u00e9riph\u00e9rique et le nom de la carte : sudo service klipper stop cd ~/klipper git pull make clean make menuconfig make ./scripts/flash-sdcard.sh /dev/ttyACM0 btt-octopus-f446-v1 [[[\u00e9teindre-allumer manuellement la carte de l'imprimante quand vous y \u00eates invit\u00e9]]] ./scripts/flash-sdcard.sh -c /dev/ttyACM0 btt-octopus-f446-v1 sudo service klipper start Programmation SDIO avec RPi sur la m\u00eame alimentation \u00e9lectrique \u00b6 Une session typique avec le RPi sur la m\u00eame alimentation ressemble \u00e0 ce qui suit. Vous devrez, bien s\u00fbr, utiliser le chemin du p\u00e9riph\u00e9rique et le nom de la carte : sudo service klipper stop cd ~/klipper git pull make clean make menuconfig make ./scripts/flash-sdcard.sh /dev/ttyACM0 btt-octopus-f446-v1 sudo shutdown -h now [[[attendre que le RPi s'arr\u00eate, puis \u00e9teindre-allumer et ssh \u00e0 nouveau sur le RPi quand il a red\u00e9marr\u00e9]]] sudo service klipper stop cd ~/klipper ./scripts/flash-sdcard.sh -c /dev/ttyACM0 btt-octopus-f446-v1 sudo service klipper start Dans ce cas, puisque l'h\u00f4te RPi est en train d'\u00eatre red\u00e9marr\u00e9, ce qui va red\u00e9marrer le service klipper , il est n\u00e9cessaire d'arr\u00eater le service klipper avant de faire l'\u00e9tape de v\u00e9rification et de le red\u00e9marrer une fois la v\u00e9rification termin\u00e9e. Mappage des broches SDIO vers SPI \u00b6 Si le sch\u00e9ma de votre carte utilise SDIO pour sa carte SD, vous pouvez mapper les broches comme d\u00e9crit dans le tableau ci-dessous pour d\u00e9terminer les broches SPI logicielles compatibles \u00e0 assigner dans le fichier board_defs.py : Broche de la carte SD Broche pour carte micro SD Nom de la broche SDIO Nom de la broche SPI 9 1 DATA2 None (PU)* 1 2 CD/DATA3 CS 2 3 CMD MOSI 4 4 +3.3V (VDD) +3.3V (VDD) 5 5 CLK SCLK 3 6 GND (VSS) GND (VSS) 7 7 DATA0 MISO 8 8 DATA1 None (PU)* N/A 9 Card Detect (CD) Card Detect (CD) 6 10 GND GND * None (PU) indique une broche inutilis\u00e9e avec une r\u00e9sistance de tirage haut","title":"Mises \u00e0 jour via la carte SD"},{"location":"SDCard_Updates.html#mises-a-jour-via-la-carte-sd","text":"La plupart des microcontr\u00f4leurs actuels sont livr\u00e9s avec un programme d'amor\u00e7age capable de mettre \u00e0 jour le micrologiciel via une carte SD. Bien que cela soit pratique dans de nombreux cas, ces programmes d'amor\u00e7age ne fournissent g\u00e9n\u00e9ralement aucun autre moyen de mettre \u00e0 jour le micrologiciel. Cela peut s'av\u00e9rer g\u00eanant si votre carte est install\u00e9e dans un endroit difficile d'acc\u00e8s ou si vous avez besoin de mettre \u00e0 jour le firmware r\u00e9guli\u00e8rement. Apr\u00e8s avoir initialement flash\u00e9 Klipper sur un microcontr\u00f4leur, il est possible de transf\u00e9rer le nouveau micrologiciel sur la carte SD et de lancer le processus de mise \u00e0 jour via ssh.","title":"Mises \u00e0 jour via la carte SD"},{"location":"SDCard_Updates.html#procedure-de-mise-a-jour-classique","text":"La proc\u00e9dure pour mettre \u00e0 jour le firmware du MCU en utilisant la carte SD est similaire \u00e0 celle des autres m\u00e9thodes. Au lieu d'utiliser make flash , il est n\u00e9cessaire d'ex\u00e9cuter un script d'aide, flash-sdcard.sh . La mise \u00e0 jour d'un BigTreeTech SKR 1.3 pourrait ressembler \u00e0 ce qui suit : sudo service klipper stop cd ~/klipper git pull make clean make menuconfig make ./scripts/flash-sdcard.sh /dev/ttyACM0 btt-skr-v1.3 sudo service klipper start C'est \u00e0 l'utilisateur de d\u00e9terminer l'emplacement du p\u00e9riph\u00e9rique et le nom de la carte. Si un utilisateur a besoin de flasher plusieurs cartes, flash-sdcard.sh (ou make flash si appropri\u00e9) doit \u00eatre ex\u00e9cut\u00e9 pour chaque carte avant de red\u00e9marrer le service Klipper. Les cartes support\u00e9es peuvent \u00eatre list\u00e9es avec la commande suivante : ./scripts/flash-sdcard.sh -l Si votre carte ne figure pas dans la liste, il peut \u00eatre n\u00e9cessaire d'ajouter une nouvelle d\u00e9finition de carte comme d\u00e9crit ci-dessous .","title":"Proc\u00e9dure de mise \u00e0 jour classique"},{"location":"SDCard_Updates.html#utilisation-avancee","text":"Les commandes ci-dessus supposent que votre MCU se connecte \u00e0 la vitesse de transmission par d\u00e9faut de 250000 et que le firmware se trouve dans ~/klipper/out/klipper.bin . Le script flash-sdcard.sh fournit des options pour changer ces valeurs par d\u00e9faut. Toutes les options peuvent \u00eatre visualis\u00e9es par l'\u00e9cran d'aide : ./scripts/flash-sdcard.sh -h SD Card upload utility for Klipper usage: flash_sdcard.sh [-h] [-l] [-c] [-b <baud>] [-f <firmware>] <device> <board> positional arguments: <device> device serial port <board> board type optional arguments: -h show this message -l list available boards -c run flash check/verify only (skip upload) -b <baud> serial baud rate (default is 250000) -f <firmware> path to klipper.bin Si votre carte est flash\u00e9e avec un micro logiciel qui se connecte \u00e0 une vitesse (baud rate) personnalis\u00e9e, il est possible de mettre \u00e0 jour en sp\u00e9cifiant l'option -b : ./scripts/flash-sdcard.sh -b 115200 /dev/ttyAMA0 btt-skr-v1.3 Si vous souhaitez flasher une version de Klipper situ\u00e9e ailleurs que dans l'emplacement par d\u00e9faut, vous pouvez le faire en sp\u00e9cifiant l'option -f : ./scripts/flash-sdcard.sh -f ~/downloads/klipper.bin /dev/ttyAMA0 btt-skr-v1.3 Notez que lors de la mise \u00e0 jour d'un MKS Robin E3, il n'est pas n\u00e9cessaire d'ex\u00e9cuter manuellement update_mks_robin.py et de fournir le binaire r\u00e9sultant \u00e0 flash-sdcard.sh . Cette proc\u00e9dure est automatis\u00e9e pendant le processus de t\u00e9l\u00e9versement. L'option -c est utilis\u00e9e pour effectuer une op\u00e9ration de contr\u00f4le ou de v\u00e9rification uniquement pour tester si la carte ex\u00e9cute correctement le firmware sp\u00e9cifi\u00e9. Cette option est principalement destin\u00e9e aux cas o\u00f9 un cycle d'alimentation manuel est n\u00e9cessaire pour compl\u00e9ter la proc\u00e9dure de flashage, comme avec des chargeurs de d\u00e9marrage utilisant le mode SDIO au lieu de SPI pour acc\u00e9der \u00e0 leurs cartes SD. (Voir Caveats ci-dessous) Mais, elle peut \u00e9galement \u00eatre utilis\u00e9e \u00e0 tout moment pour v\u00e9rifier si le code flash\u00e9 dans la carte correspond \u00e0 la version dans votre dossier de construction sur toute carte support\u00e9e.","title":"Utilisation avanc\u00e9e"},{"location":"SDCard_Updates.html#avertissements","text":"Comme mentionn\u00e9 dans l'introduction, cette m\u00e9thode ne fonctionne que pour la mise \u00e0 jour du firmware. La proc\u00e9dure de flashage initial doit \u00eatre effectu\u00e9e manuellement selon les instructions qui s'appliquent \u00e0 votre carte contr\u00f4leur. Bien qu'il soit possible de flasher un build qui change le Baud s\u00e9rie ou l'interface de connexion (par exemple, de USB \u00e0 UART), la v\u00e9rification \u00e9chouera toujours car le script ne pourra pas se reconnecter au MCU pour v\u00e9rifier la version actuelle. Seules les cartes utilisant SPI pour la communication avec la carte SD sont support\u00e9es. Les cartes utiliaent SDIO, comme la Flymaker Flyboard et la MKS Robin Nano V1/V2, ne fonctionneront pas en mode SDIO. Cependant, il est g\u00e9n\u00e9ralement possible de flasher ces cartes en utilisant le mode SPI logiciel. Mais si le chargeur d'amor\u00e7age de la carte n'utilise que le mode SDIO pour acc\u00e9der \u00e0 la carte SD, un cycle d'alimentation de la carte et de la carte SD sera n\u00e9cessaire pour que le mode puisse passer de SPI \u00e0 SDIO pour terminer le flashage. De telles cartes devraient \u00eatre d\u00e9finies avec skip_verify activ\u00e9 pour sauter l'\u00e9tape de v\u00e9rification imm\u00e9diatement apr\u00e8s le flashage. Ensuite, apr\u00e8s le power-cycle manuel, vous pouvez r\u00e9-ex\u00e9cuter exactement la m\u00eame commande ./scripts/flash-sdcard.sh , mais ajouter l'option -c pour compl\u00e9ter l'op\u00e9ration de v\u00e9rification. Voir Flasher des cartes utilisant SDIO pour des exemples.","title":"Avertissements"},{"location":"SDCard_Updates.html#definitions-des-cartes","text":"La plupart des cartes courantes devraient \u00eatre disponibles, mais il est possible d'ajouter une nouvelle d\u00e9finition de carte si n\u00e9cessaire. Les d\u00e9finitions des cartes sont situ\u00e9es dans ~/klipper/scripts/spi_flash/board_defs.py . Les d\u00e9finitions sont stock\u00e9es dans un dictionnaire, par exemple : BOARD_DEFS = { 'generic-lpc1768' : { 'mcu' : \"lpc1768\" , 'spi_bus' : \"ssp1\" , \"cs_pin\" : \"P0.6\" }, ...< further definitions > } Les champs suivants peuvent \u00eatre pr\u00e9cis\u00e9s : mcu : le type de mcu. Il peut \u00eatre r\u00e9cup\u00e9r\u00e9 apr\u00e8s avoir configur\u00e9 la construction via make menuconfig en ex\u00e9cutant cat .config | grepCONFIG_MCU . Ce champ est obligatoire. spi_bus : Le bus SPI connect\u00e9 \u00e0 la carte SD. Cette information doit \u00eatre r\u00e9cup\u00e9r\u00e9e \u00e0 partir du sch\u00e9ma de la carte. Ce champ est obligatoire. cs_pin : La broche de s\u00e9lection de puce connect\u00e9e \u00e0 la carte SD. Cette information doit \u00eatre r\u00e9cup\u00e9r\u00e9e \u00e0 partir du sch\u00e9ma de la carte. Ce champ est obligatoire. firmware_path : Le chemin sur la carte SD o\u00f9 le firmware doit \u00eatre transf\u00e9r\u00e9. La valeur par d\u00e9faut est firmware.bin . current_firmware_path : Le chemin sur la carte SD o\u00f9 le fichier du firmware renomm\u00e9 est situ\u00e9 apr\u00e8s un flash r\u00e9ussi. La valeur par d\u00e9faut est firmware.cur . skip_verify : d\u00e9finit une valeur bool\u00e9enne indiquant aux scripts d'ignorer l'\u00e9tape de v\u00e9rification du firmware pendant le processus de flashage. La valeur par d\u00e9faut est False . Peut \u00eatre d\u00e9fini \u00e0 True pour les cartes n\u00e9cessitant un cycle d'alimentation manuel pour terminer le flashage. Pour v\u00e9rifier le firmware par la suite, ex\u00e9cutez \u00e0 nouveau le script avec l'option -c pour effectuer l'\u00e9tape de v\u00e9rification. Voir les avertissements avec les cartes SDIO Si le SPI logiciel est requis, le champ spi_bus doit \u00eatre r\u00e9gl\u00e9 sur swspi et le champ suppl\u00e9mentaire suivant doit \u00eatre sp\u00e9cifi\u00e9 : spi_pins : Ceci devrait \u00eatre 3 broches s\u00e9par\u00e9es par des virgules qui sont connect\u00e9es \u00e0 la carte SD dans le format de miso,mosi,sclk . Il devrait \u00eatre extr\u00eamement rare que le SPI logiciel soit n\u00e9cessaire, typiquement seules les cartes avec des erreurs de conception ou les cartes ne supportant que le mode SDIO pour leur carte SD en auront besoin. La d\u00e9finition de la carte btt-skr-pro fournit un exemple du premier cas, et la d\u00e9finition de la carte btt-octopus-f446-v1 fournit un exemple du second. Avant de cr\u00e9er une nouvelle d\u00e9finition de carte, il faut v\u00e9rifier si la d\u00e9finition d'une carte existante r\u00e9pond aux crit\u00e8res n\u00e9cessaires pour la nouvelle carte. Si c'est le cas, un BOARD_ALIAS peut \u00eatre utilis\u00e9. Par exemple, l'alias suivant peut \u00eatre ajout\u00e9 pour sp\u00e9cifier my-new-board comme alias de generic-lpc1768 : BOARD_ALIASES = { ...< previous aliases > , 'my-new-board' : BOARD_DEFS [ 'generic-lpc1768' ], } Si vous avez besoin d'une nouvelle d\u00e9finition de carte et que vous n'\u00eates pas \u00e0 l'aise avec la proc\u00e9dure d\u00e9crite ci-dessus, il est recommand\u00e9 d'en demander une sur le Discord de la communaut\u00e9 Klipper .","title":"D\u00e9finitions des cartes"},{"location":"SDCard_Updates.html#flashage-des-cartes-utilisant-sdio","text":"Comme mentionn\u00e9 dans les Caveats , les cartes dont le chargeur de d\u00e9marrage utilise le mode SDIO pour l'acc\u00e8s \u00e0 leur carte SD n\u00e9cessitent un power-cycle de la carte, et plus particuli\u00e8rement de la carte SD elle-m\u00eame, afin de passer du mode SPI utilis\u00e9 lors de l'\u00e9criture du fichier sur la carte SD au mode SDIO pour que le chargeur de d\u00e9marrage puisse le flasher sur la carte. Ces d\u00e9finitions de cartes utiliseront le drapeau skip_verify , qui indique \u00e0 l'outil de flashage de s'arr\u00eater apr\u00e8s l'\u00e9criture du firmware sur la carte SD afin que la carte puisse \u00eatre mise sous tension manuellement et que l'\u00e9tape de v\u00e9rification soit report\u00e9e jusqu'\u00e0 ce qu'elle soit termin\u00e9e. Il y a deux sc\u00e9narios : l'un avec l'h\u00f4te RPi fonctionnant sur une alimentation s\u00e9par\u00e9e et l'autre lorsque l'h\u00f4te RPi fonctionne sur la m\u00eame alimentation que la carte principale \u00e0 flasher. La diff\u00e9rence est de savoir s'il est n\u00e9cessaire ou non d'\u00e9teindre le RPi et ensuite ssh de nouveau apr\u00e8s que le flashage soit termin\u00e9 afin de faire l'\u00e9tape de v\u00e9rification, ou si la v\u00e9rification peut \u00eatre faite imm\u00e9diatement. Voici des exemples des deux sc\u00e9narios :","title":"Flashage des cartes utilisant SDIO"},{"location":"SDCard_Updates.html#programmation-sdio-avec-rpi-sur-alimentation-separee","text":"Une session typique avec le RPi sur une alimentation s\u00e9par\u00e9e ressemble \u00e0 ce qui suit. Vous devrez, bien s\u00fbr, utiliser le chemin du p\u00e9riph\u00e9rique et le nom de la carte : sudo service klipper stop cd ~/klipper git pull make clean make menuconfig make ./scripts/flash-sdcard.sh /dev/ttyACM0 btt-octopus-f446-v1 [[[\u00e9teindre-allumer manuellement la carte de l'imprimante quand vous y \u00eates invit\u00e9]]] ./scripts/flash-sdcard.sh -c /dev/ttyACM0 btt-octopus-f446-v1 sudo service klipper start","title":"Programmation SDIO avec RPi sur alimentation s\u00e9par\u00e9e"},{"location":"SDCard_Updates.html#programmation-sdio-avec-rpi-sur-la-meme-alimentation-electrique","text":"Une session typique avec le RPi sur la m\u00eame alimentation ressemble \u00e0 ce qui suit. Vous devrez, bien s\u00fbr, utiliser le chemin du p\u00e9riph\u00e9rique et le nom de la carte : sudo service klipper stop cd ~/klipper git pull make clean make menuconfig make ./scripts/flash-sdcard.sh /dev/ttyACM0 btt-octopus-f446-v1 sudo shutdown -h now [[[attendre que le RPi s'arr\u00eate, puis \u00e9teindre-allumer et ssh \u00e0 nouveau sur le RPi quand il a red\u00e9marr\u00e9]]] sudo service klipper stop cd ~/klipper ./scripts/flash-sdcard.sh -c /dev/ttyACM0 btt-octopus-f446-v1 sudo service klipper start Dans ce cas, puisque l'h\u00f4te RPi est en train d'\u00eatre red\u00e9marr\u00e9, ce qui va red\u00e9marrer le service klipper , il est n\u00e9cessaire d'arr\u00eater le service klipper avant de faire l'\u00e9tape de v\u00e9rification et de le red\u00e9marrer une fois la v\u00e9rification termin\u00e9e.","title":"Programmation SDIO avec RPi sur la m\u00eame alimentation \u00e9lectrique"},{"location":"SDCard_Updates.html#mappage-des-broches-sdio-vers-spi","text":"Si le sch\u00e9ma de votre carte utilise SDIO pour sa carte SD, vous pouvez mapper les broches comme d\u00e9crit dans le tableau ci-dessous pour d\u00e9terminer les broches SPI logicielles compatibles \u00e0 assigner dans le fichier board_defs.py : Broche de la carte SD Broche pour carte micro SD Nom de la broche SDIO Nom de la broche SPI 9 1 DATA2 None (PU)* 1 2 CD/DATA3 CS 2 3 CMD MOSI 4 4 +3.3V (VDD) +3.3V (VDD) 5 5 CLK SCLK 3 6 GND (VSS) GND (VSS) 7 7 DATA0 MISO 8 8 DATA1 None (PU)* N/A 9 Card Detect (CD) Card Detect (CD) 6 10 GND GND * None (PU) indique une broche inutilis\u00e9e avec une r\u00e9sistance de tirage haut","title":"Mappage des broches SDIO vers SPI"},{"location":"Skew_Correction.html","text":"Correction de l'\u00e9querrage \u00b6 La correction logicielle de l'\u00e9querrage peut aider \u00e0 r\u00e9soudre les inexactitudes dimensionnelles r\u00e9sultant d'un assemblage d'imprimante qui n'est pas parfaitement d'\u00e9querre. Notez que si votre imprimante est consid\u00e9rablement asym\u00e9trique, il est fortement recommand\u00e9 d'utiliser d'abord des moyens m\u00e9caniques pour obtenir une imprimante le plus d'\u00e9querre possible avant d'appliquer la correction bas\u00e9e sur le logiciel. Impression d'un objet de calibrage \u00b6 La premi\u00e8re \u00e9tape de la correction de l'\u00e9querrage consiste \u00e0 imprimer un objet d'\u00e9talonnage le long du plan que vous souhaitez corriger. Il existe \u00e9galement un objet d'\u00e9talonnage qui inclut tous les plans dans un seul mod\u00e8le. Veuillez \u00e0 orienter l'objet de sorte que le coin A soit vers l'origine du plan. Assurez-vous qu'aucune correction d'\u00e9querrage n'est appliqu\u00e9e pendant cette impression. Vous pouvez le faire en supprimant le module [skew_correction] du fichier printer.cfg ou en tapant un gcode SET_SKEW CLEAR=1 . Prenez vos mesures \u00b6 Le module [skew_correcton] n\u00e9cessite 3 mesures pour chaque plan que vous souhaitez corriger ; la longueur du coin A au coin C, la longueur du coin B au coin D et la longueur du coin A au coin D. Lors de la mesure de la longueur AD, n'incluez pas les plats sur les coins fournis par certains objets de test. Configurez votre \u00e9querrage \u00b6 Assurez-vous que [skew_correction] est bien dans le fichier printer.cfg. Vous pouvez maintenant utiliser le gcode SET_SKEW pour configurer skew_correcton. Par exemple, si vos longueurs mesur\u00e9es le long de XY sont les suivantes : Length AC = 140.4 Length BD = 142.8 Length AD = 99.8 SET_SKEW peut \u00eatre utilis\u00e9 pour configurer la correction d'\u00e9querrage pour le plan XY. SET_SKEW XY=140.4,142.8,99.8 Vous pouvez \u00e9galement ajouter des mesures pour XZ et YZ au gcode : SET_SKEW XY=140.4,142.8,99.8 XZ=141.6,141.4,99.8 YZ=142.4,140.5,99.5 Le module [skew_correction] prend \u00e9galement en charge la gestion des profils d'une mani\u00e8re similaire \u00e0 [bed_mesh] . Apr\u00e8s avoir d\u00e9fini la correction d'\u00e9querrage \u00e0 l'aide du gcode SET_SKEW , vous pouvez utiliser le gcode SKEW_PROFILE pour l'enregistrer : SKEW_PROFILE SAVE=my_skew_profile Apr\u00e8s cette commande, vous serez invit\u00e9 \u00e0 saisir un SAVE_CONFIG pour enregistrer le profil de mani\u00e8re permanente. Si aucun profil n'est nomm\u00e9 my_skew_profile alors un nouveau profil sera cr\u00e9\u00e9. Si le profil nomm\u00e9 existe, il sera \u00e9cras\u00e9. Une fois que vous avez un profil enregistr\u00e9, vous pouvez le charger : SKEW_PROFILE LOAD=my_skew_profile Il est \u00e9galement possible de supprimer un profil ancien ou obsol\u00e8te : SKEW_PROFILE REMOVE=my_skew_profile Apr\u00e8s avoir supprim\u00e9 un profil, vous serez invit\u00e9 \u00e0 saisir un SAVE_CONFIG pour que cette suppression soit sauvegard\u00e9e. V\u00e9rification de votre correction \u00b6 Une fois que skew_correction a \u00e9t\u00e9 configur\u00e9, vous pouvez r\u00e9imprimer l'objet de calibrage avec la correction activ\u00e9e. Utilisez le g-code suivant pour v\u00e9rifier votre \u00e9querrage sur chaque plan. Les r\u00e9sultats devraient \u00eatre inf\u00e9rieurs \u00e0 ceux rapport\u00e9s via GET_CURRENT_SKEW . CALC_MEASURED_SKEW AC=<ac_length> BD=<bd_length> AD=<ad_length> Avertissements \u00b6 En raison de la nature de la correction de l'\u00e9querrage, il est recommand\u00e9 de configurer la correction dans votre gcode de d\u00e9marrage, apr\u00e8s la mise \u00e0 l'origine et apr\u00e8s tout type de mouvement qui se d\u00e9place pr\u00e8s du bord de la zone d'impression, comme une purge ou un essuyage de buse. Vous pouvez utiliser les gcodes SET_SKEW ou SKEW_PROFILE pour le faire. Il est \u00e9galement recommand\u00e9 d'\u00e9mettre un SET_SKEW CLEAR=1 dans votre gcode final. Gardez \u00e0 l'esprit qu'il est possible que [skew_correction] g\u00e9n\u00e8re une correction qui d\u00e9place l'outil au-del\u00e0 des limites de l'imprimante sur les axes X et/ou Y. Il est recommand\u00e9 d'\u00e9loigner les pi\u00e8ces des bords lors de l'utilisation de [skew_correction] .","title":"Correction de l'\u00e9querrage"},{"location":"Skew_Correction.html#correction-de-lequerrage","text":"La correction logicielle de l'\u00e9querrage peut aider \u00e0 r\u00e9soudre les inexactitudes dimensionnelles r\u00e9sultant d'un assemblage d'imprimante qui n'est pas parfaitement d'\u00e9querre. Notez que si votre imprimante est consid\u00e9rablement asym\u00e9trique, il est fortement recommand\u00e9 d'utiliser d'abord des moyens m\u00e9caniques pour obtenir une imprimante le plus d'\u00e9querre possible avant d'appliquer la correction bas\u00e9e sur le logiciel.","title":"Correction de l'\u00e9querrage"},{"location":"Skew_Correction.html#impression-dun-objet-de-calibrage","text":"La premi\u00e8re \u00e9tape de la correction de l'\u00e9querrage consiste \u00e0 imprimer un objet d'\u00e9talonnage le long du plan que vous souhaitez corriger. Il existe \u00e9galement un objet d'\u00e9talonnage qui inclut tous les plans dans un seul mod\u00e8le. Veuillez \u00e0 orienter l'objet de sorte que le coin A soit vers l'origine du plan. Assurez-vous qu'aucune correction d'\u00e9querrage n'est appliqu\u00e9e pendant cette impression. Vous pouvez le faire en supprimant le module [skew_correction] du fichier printer.cfg ou en tapant un gcode SET_SKEW CLEAR=1 .","title":"Impression d'un objet de calibrage"},{"location":"Skew_Correction.html#prenez-vos-mesures","text":"Le module [skew_correcton] n\u00e9cessite 3 mesures pour chaque plan que vous souhaitez corriger ; la longueur du coin A au coin C, la longueur du coin B au coin D et la longueur du coin A au coin D. Lors de la mesure de la longueur AD, n'incluez pas les plats sur les coins fournis par certains objets de test.","title":"Prenez vos mesures"},{"location":"Skew_Correction.html#configurez-votre-equerrage","text":"Assurez-vous que [skew_correction] est bien dans le fichier printer.cfg. Vous pouvez maintenant utiliser le gcode SET_SKEW pour configurer skew_correcton. Par exemple, si vos longueurs mesur\u00e9es le long de XY sont les suivantes : Length AC = 140.4 Length BD = 142.8 Length AD = 99.8 SET_SKEW peut \u00eatre utilis\u00e9 pour configurer la correction d'\u00e9querrage pour le plan XY. SET_SKEW XY=140.4,142.8,99.8 Vous pouvez \u00e9galement ajouter des mesures pour XZ et YZ au gcode : SET_SKEW XY=140.4,142.8,99.8 XZ=141.6,141.4,99.8 YZ=142.4,140.5,99.5 Le module [skew_correction] prend \u00e9galement en charge la gestion des profils d'une mani\u00e8re similaire \u00e0 [bed_mesh] . Apr\u00e8s avoir d\u00e9fini la correction d'\u00e9querrage \u00e0 l'aide du gcode SET_SKEW , vous pouvez utiliser le gcode SKEW_PROFILE pour l'enregistrer : SKEW_PROFILE SAVE=my_skew_profile Apr\u00e8s cette commande, vous serez invit\u00e9 \u00e0 saisir un SAVE_CONFIG pour enregistrer le profil de mani\u00e8re permanente. Si aucun profil n'est nomm\u00e9 my_skew_profile alors un nouveau profil sera cr\u00e9\u00e9. Si le profil nomm\u00e9 existe, il sera \u00e9cras\u00e9. Une fois que vous avez un profil enregistr\u00e9, vous pouvez le charger : SKEW_PROFILE LOAD=my_skew_profile Il est \u00e9galement possible de supprimer un profil ancien ou obsol\u00e8te : SKEW_PROFILE REMOVE=my_skew_profile Apr\u00e8s avoir supprim\u00e9 un profil, vous serez invit\u00e9 \u00e0 saisir un SAVE_CONFIG pour que cette suppression soit sauvegard\u00e9e.","title":"Configurez votre \u00e9querrage"},{"location":"Skew_Correction.html#verification-de-votre-correction","text":"Une fois que skew_correction a \u00e9t\u00e9 configur\u00e9, vous pouvez r\u00e9imprimer l'objet de calibrage avec la correction activ\u00e9e. Utilisez le g-code suivant pour v\u00e9rifier votre \u00e9querrage sur chaque plan. Les r\u00e9sultats devraient \u00eatre inf\u00e9rieurs \u00e0 ceux rapport\u00e9s via GET_CURRENT_SKEW . CALC_MEASURED_SKEW AC=<ac_length> BD=<bd_length> AD=<ad_length>","title":"V\u00e9rification de votre correction"},{"location":"Skew_Correction.html#avertissements","text":"En raison de la nature de la correction de l'\u00e9querrage, il est recommand\u00e9 de configurer la correction dans votre gcode de d\u00e9marrage, apr\u00e8s la mise \u00e0 l'origine et apr\u00e8s tout type de mouvement qui se d\u00e9place pr\u00e8s du bord de la zone d'impression, comme une purge ou un essuyage de buse. Vous pouvez utiliser les gcodes SET_SKEW ou SKEW_PROFILE pour le faire. Il est \u00e9galement recommand\u00e9 d'\u00e9mettre un SET_SKEW CLEAR=1 dans votre gcode final. Gardez \u00e0 l'esprit qu'il est possible que [skew_correction] g\u00e9n\u00e8re une correction qui d\u00e9place l'outil au-del\u00e0 des limites de l'imprimante sur les axes X et/ou Y. Il est recommand\u00e9 d'\u00e9loigner les pi\u00e8ces des bords lors de l'utilisation de [skew_correction] .","title":"Avertissements"},{"location":"Slicers.html","text":"Slicers \u00b6 Ce document fournit certains conseils concernant la configuration d'une application \"Slicer\" pour une utilisation avec Klipper. Des slicers les plus courants utilis\u00e9s avec Klipper sont Sli3r, Cura, Simplify3D, etc. D\u00e9finissez le parfum g-code sur 'Marlin' \u00b6 De nombreux trancheurs ont une option pour configurer le \"Parfum G-Code\". La valeur par d\u00e9faut est souvent \"Marlin\" et cela fonctionne bien avec Klipper. La valeur \"Smoothieware\" fonctionne \u00e9galement bien avec Klipper. Les macros G-code de Klipper \u00b6 Les trancheurs permettent souvent de configurer les s\u00e9quences \"Start G-Code\" et \"End G-Code\". Il est souvent pratique de d\u00e9finir des macros personnalis\u00e9es dans le fichier de configuration de Klipper - telles que : [gcode_macro START_PRINT] et [gcode_macro END_PRINT] . Ensuite, on peut simplement indiquer START_PRINT et END_PRINT dans la configuration du slicer. La d\u00e9finition de ces actions dans la configuration de Klipper peut faciliter la modification des \u00e9tapes de d\u00e9but et de fin de l'imprimante, car les modifications ne n\u00e9cessitent pas de nouveau d\u00e9coupage. Voir sample-macros.cfg par exemple les macros START_PRINT et END_PRINT. Voir la r\u00e9f\u00e9rence de configuration pour plus de d\u00e9tails sur la d\u00e9finition de macros G-Code. Un r\u00e9glage de r\u00e9traction important peut n\u00e9cessiter un r\u00e9glage de Klipper \u00b6 La vitesse et l'acc\u00e9l\u00e9ration maximales des mouvements de r\u00e9traction sont contr\u00f4l\u00e9s dans Klipper par les param\u00e8tres de configuration max_extrude_only_velocity et max_extrude_only_accel . Ces param\u00e8tres ont une valeur par d\u00e9faut qui doit bien fonctionner sur de nombreuses imprimantes. Cependant, si l'on a configur\u00e9 une grande r\u00e9traction dans le trancheur (par exemple, 5 mm ou plus), on peut constater qu'ils limitent la vitesse de r\u00e9traction souhait\u00e9e. Si vous utilisez une grande distance r\u00e9traction, envisagez plut\u00f4t de r\u00e9gler le Pressure advance de Klipper. Dans la cas ou l'on trouve que la t\u00eate semble \"s'arr\u00eater\" pendant la r\u00e9traction et l'amor\u00e7age, d\u00e9finissez explicitement max_extrude_only_velocity et max_extrude_only_accel dans le fichier de configuration de Klipper. N'activez pas le mode \"roue libre\" \u00b6 Le mode \"roue libre\" est susceptible d'entra\u00eener des impressions de mauvaise qualit\u00e9 avec Klipper. Envisagez d'utiliser \u00e0 la place le pressure Advance de Klipper. Plus pr\u00e9cis\u00e9ment, si le slicer modifie consid\u00e9rablement le taux d'extrusion entre les mouvements, Klipper effectuera une d\u00e9c\u00e9l\u00e9ration et une acc\u00e9l\u00e9ration entre les mouvements. Cela risque d'aggraver les bavures, pas de les am\u00e9liorer. En revanche, il est possible (et souvent utile) d'utiliser le r\u00e9glage \u00ab r\u00e9tracter \u00bb, le r\u00e9glage \u00ab essuyer \u00bb et/ou le r\u00e9glage \u00ab essuyer lors de la r\u00e9tractation \u00bb d'un trancheur. Ne pas utiliser la \"distance de red\u00e9marrage suppl\u00e9mentaire\" sur Simplify3d \u00b6 Ce param\u00e8tre peut entra\u00eener de gros changements dans le taux d'extrusion, ce qui peut d\u00e9clencher la limite d'extrusion maximale de Klipper. Envisagez d'utiliser \u00e0 la place le pressure advance de Klipper (Pressure_Advance.md) ou le param\u00e8tre de r\u00e9tractation standard de Simplify3d. D\u00e9sactivez \"PreloadVE\" sur KISSlicer \u00b6 Si vous utilisez le trancheur KISSlicer, r\u00e9glez \"PreloadVE\" sur z\u00e9ro. Envisagez d'utiliser \u00e0 la place le Pressure Advance de Klipper. D\u00e9sactivez tous les param\u00e8tres de \"pression d'extrusion avanc\u00e9e\" \u00b6 Certains trancheurs pr\u00e9sentent une fonction de \"pression d'extrudeuse avanc\u00e9e\". Il est recommand\u00e9 de garder ces options d\u00e9sactiv\u00e9es lors de l'utilisation de Klipper car elles risquent d'entra\u00eener des impressions de mauvaise qualit\u00e9. Envisagez d'utiliser \u00e0 la place la Pressure Advance de Klipper. Ces param\u00e8tres de trancheur peuvent demander au micrologiciel d'apporter des modifications non contr\u00f4l\u00e9es au taux d'extrusion dans l'espoir que le micrologiciel se rapprochera de ces demandes et que l'imprimante obtiendra approximativement une pression d'extrudeuse souhaitable. Klipper, utilise des calculs cin\u00e9matiques et une synchronisation pr\u00e9cise. Lorsque Klipper re\u00e7oit l'ordre d'apporter des modifications importantes au taux d'extrusion, il planifiera les modifications correspondantes de la vitesse, de l'acc\u00e9l\u00e9ration et du mouvement de l'extrudeuse - ce qui n'est pas pr\u00e9vu par le trancheur. Le trancheur peut m\u00eame commander des taux d'extrusion excessifs au point de d\u00e9clencher la limite d'extrusion maximale de Klipper. En revanche, il est possible (et souvent utile) d'utiliser le r\u00e9glage \u00ab r\u00e9tracter \u00bb, le r\u00e9glage \u00ab essuyer \u00bb et/ou le r\u00e9glage \u00ab essuyer lors de la r\u00e9tractation \u00bb d'un trancheur. Macros START_PRINT \u00b6 Lors de l'utilisation d'une macro START_PRINT ou similaire, il est parfois utile de passer les param\u00e8tres des variables du trancheur \u00e0 la macro. Dans Cura, pour passer les temp\u00e9ratures, le gcode de d\u00e9marrage suivant serait utilis\u00e9 : START_PRINT BED_TEMP={material_bed_temperature_layer_0} EXTRUDER_TEMP={material_print_temperature_layer_0} Dans slic3r et ses d\u00e9riv\u00e9s tels que PrusaSlicer et SuperSlicer, les \u00e9l\u00e9ments suivants seraient utilis\u00e9s : START_PRINT EXTRUDER_TEMP=[first_layer_temperature] BED_TEMP=[first_layer_bed_temperature] Notez \u00e9galement que ces trancheurs ins\u00e8rent leurs propres codes de chauffe lorsque certaines conditions ne sont pas remplies. Dans Cura, l'existence des variables {material_bed_temperature_layer_0} et {material_print_temperature_layer_0} suffit \u00e0 supprimer ces code de chauffe. Dans les d\u00e9riv\u00e9s slic3r, vous utiliseriez : M140 S0 M104 S0 avant l'appel de la macro. Notez \u00e9galement que SuperSlicer a une option de bouton \"gcode personnalis\u00e9 uniquement\", qui permet d'obtenir le m\u00eame r\u00e9sultat. Un exemple de macro START_PRINT utilisant ces param\u00e8tres peut \u00eatre trouv\u00e9 dans config/sample-macros.cfg","title":"Slicers"},{"location":"Slicers.html#slicers","text":"Ce document fournit certains conseils concernant la configuration d'une application \"Slicer\" pour une utilisation avec Klipper. Des slicers les plus courants utilis\u00e9s avec Klipper sont Sli3r, Cura, Simplify3D, etc.","title":"Slicers"},{"location":"Slicers.html#definissez-le-parfum-g-code-sur-marlin","text":"De nombreux trancheurs ont une option pour configurer le \"Parfum G-Code\". La valeur par d\u00e9faut est souvent \"Marlin\" et cela fonctionne bien avec Klipper. La valeur \"Smoothieware\" fonctionne \u00e9galement bien avec Klipper.","title":"D\u00e9finissez le parfum g-code sur 'Marlin'"},{"location":"Slicers.html#les-macros-g-code-de-klipper","text":"Les trancheurs permettent souvent de configurer les s\u00e9quences \"Start G-Code\" et \"End G-Code\". Il est souvent pratique de d\u00e9finir des macros personnalis\u00e9es dans le fichier de configuration de Klipper - telles que : [gcode_macro START_PRINT] et [gcode_macro END_PRINT] . Ensuite, on peut simplement indiquer START_PRINT et END_PRINT dans la configuration du slicer. La d\u00e9finition de ces actions dans la configuration de Klipper peut faciliter la modification des \u00e9tapes de d\u00e9but et de fin de l'imprimante, car les modifications ne n\u00e9cessitent pas de nouveau d\u00e9coupage. Voir sample-macros.cfg par exemple les macros START_PRINT et END_PRINT. Voir la r\u00e9f\u00e9rence de configuration pour plus de d\u00e9tails sur la d\u00e9finition de macros G-Code.","title":"Les macros G-code de Klipper"},{"location":"Slicers.html#un-reglage-de-retraction-important-peut-necessiter-un-reglage-de-klipper","text":"La vitesse et l'acc\u00e9l\u00e9ration maximales des mouvements de r\u00e9traction sont contr\u00f4l\u00e9s dans Klipper par les param\u00e8tres de configuration max_extrude_only_velocity et max_extrude_only_accel . Ces param\u00e8tres ont une valeur par d\u00e9faut qui doit bien fonctionner sur de nombreuses imprimantes. Cependant, si l'on a configur\u00e9 une grande r\u00e9traction dans le trancheur (par exemple, 5 mm ou plus), on peut constater qu'ils limitent la vitesse de r\u00e9traction souhait\u00e9e. Si vous utilisez une grande distance r\u00e9traction, envisagez plut\u00f4t de r\u00e9gler le Pressure advance de Klipper. Dans la cas ou l'on trouve que la t\u00eate semble \"s'arr\u00eater\" pendant la r\u00e9traction et l'amor\u00e7age, d\u00e9finissez explicitement max_extrude_only_velocity et max_extrude_only_accel dans le fichier de configuration de Klipper.","title":"Un r\u00e9glage de r\u00e9traction important peut n\u00e9cessiter un r\u00e9glage de Klipper"},{"location":"Slicers.html#nactivez-pas-le-mode-roue-libre","text":"Le mode \"roue libre\" est susceptible d'entra\u00eener des impressions de mauvaise qualit\u00e9 avec Klipper. Envisagez d'utiliser \u00e0 la place le pressure Advance de Klipper. Plus pr\u00e9cis\u00e9ment, si le slicer modifie consid\u00e9rablement le taux d'extrusion entre les mouvements, Klipper effectuera une d\u00e9c\u00e9l\u00e9ration et une acc\u00e9l\u00e9ration entre les mouvements. Cela risque d'aggraver les bavures, pas de les am\u00e9liorer. En revanche, il est possible (et souvent utile) d'utiliser le r\u00e9glage \u00ab r\u00e9tracter \u00bb, le r\u00e9glage \u00ab essuyer \u00bb et/ou le r\u00e9glage \u00ab essuyer lors de la r\u00e9tractation \u00bb d'un trancheur.","title":"N'activez pas le mode \"roue libre\""},{"location":"Slicers.html#ne-pas-utiliser-la-distance-de-redemarrage-supplementaire-sur-simplify3d","text":"Ce param\u00e8tre peut entra\u00eener de gros changements dans le taux d'extrusion, ce qui peut d\u00e9clencher la limite d'extrusion maximale de Klipper. Envisagez d'utiliser \u00e0 la place le pressure advance de Klipper (Pressure_Advance.md) ou le param\u00e8tre de r\u00e9tractation standard de Simplify3d.","title":"Ne pas utiliser la \"distance de red\u00e9marrage suppl\u00e9mentaire\" sur Simplify3d"},{"location":"Slicers.html#desactivez-preloadve-sur-kisslicer","text":"Si vous utilisez le trancheur KISSlicer, r\u00e9glez \"PreloadVE\" sur z\u00e9ro. Envisagez d'utiliser \u00e0 la place le Pressure Advance de Klipper.","title":"D\u00e9sactivez \"PreloadVE\" sur KISSlicer"},{"location":"Slicers.html#desactivez-tous-les-parametres-de-pression-dextrusion-avancee","text":"Certains trancheurs pr\u00e9sentent une fonction de \"pression d'extrudeuse avanc\u00e9e\". Il est recommand\u00e9 de garder ces options d\u00e9sactiv\u00e9es lors de l'utilisation de Klipper car elles risquent d'entra\u00eener des impressions de mauvaise qualit\u00e9. Envisagez d'utiliser \u00e0 la place la Pressure Advance de Klipper. Ces param\u00e8tres de trancheur peuvent demander au micrologiciel d'apporter des modifications non contr\u00f4l\u00e9es au taux d'extrusion dans l'espoir que le micrologiciel se rapprochera de ces demandes et que l'imprimante obtiendra approximativement une pression d'extrudeuse souhaitable. Klipper, utilise des calculs cin\u00e9matiques et une synchronisation pr\u00e9cise. Lorsque Klipper re\u00e7oit l'ordre d'apporter des modifications importantes au taux d'extrusion, il planifiera les modifications correspondantes de la vitesse, de l'acc\u00e9l\u00e9ration et du mouvement de l'extrudeuse - ce qui n'est pas pr\u00e9vu par le trancheur. Le trancheur peut m\u00eame commander des taux d'extrusion excessifs au point de d\u00e9clencher la limite d'extrusion maximale de Klipper. En revanche, il est possible (et souvent utile) d'utiliser le r\u00e9glage \u00ab r\u00e9tracter \u00bb, le r\u00e9glage \u00ab essuyer \u00bb et/ou le r\u00e9glage \u00ab essuyer lors de la r\u00e9tractation \u00bb d'un trancheur.","title":"D\u00e9sactivez tous les param\u00e8tres de \"pression d'extrusion avanc\u00e9e\""},{"location":"Slicers.html#macros-start_print","text":"Lors de l'utilisation d'une macro START_PRINT ou similaire, il est parfois utile de passer les param\u00e8tres des variables du trancheur \u00e0 la macro. Dans Cura, pour passer les temp\u00e9ratures, le gcode de d\u00e9marrage suivant serait utilis\u00e9 : START_PRINT BED_TEMP={material_bed_temperature_layer_0} EXTRUDER_TEMP={material_print_temperature_layer_0} Dans slic3r et ses d\u00e9riv\u00e9s tels que PrusaSlicer et SuperSlicer, les \u00e9l\u00e9ments suivants seraient utilis\u00e9s : START_PRINT EXTRUDER_TEMP=[first_layer_temperature] BED_TEMP=[first_layer_bed_temperature] Notez \u00e9galement que ces trancheurs ins\u00e8rent leurs propres codes de chauffe lorsque certaines conditions ne sont pas remplies. Dans Cura, l'existence des variables {material_bed_temperature_layer_0} et {material_print_temperature_layer_0} suffit \u00e0 supprimer ces code de chauffe. Dans les d\u00e9riv\u00e9s slic3r, vous utiliseriez : M140 S0 M104 S0 avant l'appel de la macro. Notez \u00e9galement que SuperSlicer a une option de bouton \"gcode personnalis\u00e9 uniquement\", qui permet d'obtenir le m\u00eame r\u00e9sultat. Un exemple de macro START_PRINT utilisant ces param\u00e8tres peut \u00eatre trouv\u00e9 dans config/sample-macros.cfg","title":"Macros START_PRINT"},{"location":"Sponsors.html","text":"Sponsors \u00b6 Klipper est un logiciel libre. Nous d\u00e9pendons du g\u00e9n\u00e9reux soutien des sponsors. Merci de sponsoriser Klipper ou de soutenir nos sponsors. BIGTREETECH \u00b6 BIGTREETECH est le sponsor officiel de cartes m\u00e8res pour Klipper. BIGTREETECH s\u2019engage \u00e0 d\u00e9velopper des produits innovants et comp\u00e9titifs pour mieux servir la communaut\u00e9 de l\u2019impression 3D. Suivez-les sur Facebook ou Twitter . Sponsors \u00b6 D\u00e9veloppeurs Klipper \u00b6 Kevin O'Connor \u00b6 Kevin est l'auteur original et le mainteneur actuel de Klipper. Faites un don sur : https://ko-fi.com/koconnor ou https://www.patreon.com/koconnor Eric Callahan \u00b6 Eric est l'auteur de bed_mesh, spi_flash et de plusieurs autres modules Klipper. Eric a une page de dons sur : https://ko-fi.com/arksine Projets Klipper associ\u00e9s \u00b6 Klipper est fr\u00e9quemment utilis\u00e9 avec d'autres logiciels libres. Pensez \u00e0 utiliser ou \u00e0 soutenir ces projets. Moonraker Mainsail Fluidd OctoPrint KlipperScreen","title":"Sponsors"},{"location":"Sponsors.html#sponsors","text":"Klipper est un logiciel libre. Nous d\u00e9pendons du g\u00e9n\u00e9reux soutien des sponsors. Merci de sponsoriser Klipper ou de soutenir nos sponsors.","title":"Sponsors"},{"location":"Sponsors.html#bigtreetech","text":"BIGTREETECH est le sponsor officiel de cartes m\u00e8res pour Klipper. BIGTREETECH s\u2019engage \u00e0 d\u00e9velopper des produits innovants et comp\u00e9titifs pour mieux servir la communaut\u00e9 de l\u2019impression 3D. Suivez-les sur Facebook ou Twitter .","title":"BIGTREETECH"},{"location":"Sponsors.html#sponsors_1","text":"","title":"Sponsors"},{"location":"Sponsors.html#developpeurs-klipper","text":"","title":"D\u00e9veloppeurs Klipper"},{"location":"Sponsors.html#kevin-oconnor","text":"Kevin est l'auteur original et le mainteneur actuel de Klipper. Faites un don sur : https://ko-fi.com/koconnor ou https://www.patreon.com/koconnor","title":"Kevin O'Connor"},{"location":"Sponsors.html#eric-callahan","text":"Eric est l'auteur de bed_mesh, spi_flash et de plusieurs autres modules Klipper. Eric a une page de dons sur : https://ko-fi.com/arksine","title":"Eric Callahan"},{"location":"Sponsors.html#projets-klipper-associes","text":"Klipper est fr\u00e9quemment utilis\u00e9 avec d'autres logiciels libres. Pensez \u00e0 utiliser ou \u00e0 soutenir ces projets. Moonraker Mainsail Fluidd OctoPrint KlipperScreen","title":"Projets Klipper associ\u00e9s"},{"location":"Status_Reference.html","text":"R\u00e9f\u00e9rence des \u00e9tats \u00b6 Ce document est une r\u00e9f\u00e9rence aux informations de status de l'imprimante dans Klipper macros , display fields , et via l' API Server . Les champs de ce document sont susceptibles d'\u00eatre modifi\u00e9s - si vous utilisez un attribut, veillez \u00e0 consulter le document Modifications des configurations lors de la mise \u00e0 jour du logiciel Klipper. angle \u00b6 Les informations suivantes sont disponibles dans les objets angle votre_nom : temperature : la derni\u00e8re lecture de temp\u00e9rature (en degr\u00e9s Celsius) d'un capteur \u00e0 effet Hall magn\u00e9tique de type tle5012b. Cette valeur n'est disponible que si le capteur d'angle est une puce tle5012b et si des mesures sont en cours (sinon il signale None ). bed_mesh \u00b6 Les informations suivantes sont disponibles dans l'objet cartographie du lit (bed mash) : profile_name , mesh_min , mesh_max , probed_matrix , mesh_matrix : informations sur la cartographie du lit actuellement active. profiles : l'ensemble des profils actuellement d\u00e9finis tels que configur\u00e9s \u00e0 l'aide de BED_MESH_PROFILE. bed_screws \u00b6 Les informations suivantes sont disponibles dans l'objet Config_Reference.md#bed_screws : is_active : Renvoie True si le script de r\u00e9glage des vis du lit est en cours. state : L'\u00e9tat du script de r\u00e9glage des vis du lit. deux \u00e9taIl s'agit de l'une des cha\u00eenes suivantes : \"adjust\", \"fine\". current_screw : le num\u00e9ro de la vis en cours de r\u00e9glage. accepted_screws : nombre de vis qui ont \u00e9t\u00e9 accept\u00e9es (ndt donc marqu\u00e9es comme r\u00e9gl\u00e9es). fichier de configuration \u00b6 Les informations suivantes sont disponibles dans l'objet configfile (cet objet est toujours disponible) : settings.<section>.<option> : Renvoie les param\u00e9trages du fichier de configuration (ou la valeur par d\u00e9faut) lors du dernier d\u00e9marrage ou red\u00e9marrage du logiciel. (Tout param\u00e8tre modifi\u00e9 pendant l'ex\u00e9cution ne sera pas refl\u00e9t\u00e9 ici.) config.<section>.<option> : Renvoie le param\u00e8tre donn\u00e9 du fichier de configuration tel que lu par Klipper lors du dernier d\u00e9marrage ou red\u00e9marrage du logiciel. (Tout param\u00e8tre modifi\u00e9 au moment de l'ex\u00e9cution ne sera pas refl\u00e9t\u00e9 ici.) Toutes les valeurs sont renvoy\u00e9es sous forme de cha\u00eenes. save_config_pending : renvoie vrai s'il existe des mises \u00e0 jour en attente qu'une commande SAVE_CONFIG peut enregistrer sur le disque. save_config_pending_items : Contient les sections et les \u00e9l\u00e9ments qui ont \u00e9t\u00e9 modifi\u00e9es et qui peuvent \u00eatre sauvegard\u00e9es avec un SAVE_CONFIG . warnings : une liste d'avertissements concernant les options de configuration. Chaque entr\u00e9e de la liste sera un dictionnaire contenant un champ type et message (les deux cha\u00eenes). Des champs suppl\u00e9mentaires peuvent \u00eatre disponibles selon le type d'avertissement. display_status \u00b6 Les informations suivantes sont disponibles dans l\u2019objet display_status (cet objet est automatiquement disponible si une section de configuration affichage est d\u00e9finie) : progress : la valeur de progression de la derni\u00e8re commande G-Code M73 (ou virtual_sdcard.progress si aucune commande M73 r\u00e9cente n'a \u00e9t\u00e9 re\u00e7ue). message : Le message contenu dans la derni\u00e8re commande G-Code M117 . endstop_phase \u00b6 Les informations suivantes sont disponibles dans l'objet endstop_phase : last_home.<stepper name>.phase : La phase du moteur pas \u00e0 pas \u00e0 la fin de la derni\u00e8re tentative de retour \u00e0 l'origine. last_home.<stepper name>.phases : Le nombre total de phases disponibles sur le moteur pas \u00e0 pas. last_home.<stepper name>.mcu_position : La position (telle que suivie par le microcontr\u00f4leur) du moteur pas \u00e0 pas \u00e0 la fin de la derni\u00e8re tentative de retour \u00e0 l'origine. La position est le nombre total de pas effectu\u00e9s dans le sens avant moins le nombre total de pas effectu\u00e9s dans le sens inverse depuis le dernier red\u00e9marrage du microcontr\u00f4leur. exclude_object \u00b6 Les informations suivantes sont disponibles dans l'objet exclude_object : objects : Un tableau des objets connus tel que fourni par la commande EXCLUDE_OBJECT_DEFINE . Il s'agit des m\u00eames informations fournies par la commande EXCLUDE_OBJECT VERBOSE=1 . Les champs center et polygon ne seront pr\u00e9sents que s'ils sont fournis dans l'original EXCLUDE_OBJECT_DEFINE Voici un exemple JSON : [ { \"polygon\": [ [ 156.25, 146.2511675 ], [ 156.25, 153.7488325 ], [ 163.75, 153.7488325 ], [ 163.75, 146.2511675 ] ], \"name\": \"CYLINDER_2_STL_ID_2_COPY_0\", \"center\": [ 160, 150 ] }, { \"polygon\": [ [ 146.25, 146.2511675 ], [ 146.25, 153.7488325 ], [ 153.75, 153.7488325 ], [ 153.75, 146.2511675 ] ], \"name\": \"CYLINDER_2_STL_ID_1_COPY_0\", \"center\": [ 150, 150 ] } ] excluded_objects : un tableau de cha\u00eenes r\u00e9pertoriant les noms des objets exclus. current_object : Le nom de l'objet en cours d'impression. extruder_stepper \u00b6 Les informations suivantes sont disponibles pour les objets extruder_stepper (ainsi que les objets extruder ) : pressure_advance : la valeur actuelle de pressure advance . smooth_time : Le temps de lissage associ\u00e9 \u00e0 la valeur de \"pressure advance\" courante. motion_queue : Le nom de l'extrudeur avec lequel ce stepper d'extrudeur est actuellement synchronis\u00e9. Ceci est signal\u00e9 comme Aucun si le moteur pas \u00e0 pas de l'extrudeuse n'est pas associ\u00e9 \u00e0 un extrudeur. ventilateur \u00b6 Les informations suivantes sont disponibles dans les objets fan , heater_fan nom_du_ventilateur et controller_fan nom_du_ventilateur : speed : La vitesse du ventilateur nombre r\u00e9el entre 0,0 et 1,0. rpm : La vitesse du ventilateur mesur\u00e9e en rotations par minute si le ventilateur a un tachometer_pin d\u00e9fini (ndt : et si le ventilateur poss\u00e8de un tachym\u00e8tre). filament_switch_sensor \u00b6 Les informations suivantes sont disponibles dans les objets filament_switch_sensor nom_du_d\u00e9tecteur : enabled : renvoie True si le d\u00e9tecteur de fin de filament est activ\u00e9. filament_detected : renvoie True si le d\u00e9tecteur de fin de filament a d\u00e9tect\u00e9 la pr\u00e9sence d'un filament. filament_motion_sensor \u00b6 Les informations suivantes sont disponibles dans les objets filament_motion_sensor nom_du_detecteur : enabled : renvoie True si le d\u00e9tecteur de mouvement du filament est activ\u00e9. filament_detected : renvoie True si le d\u00e9tecteur de fin de filament a d\u00e9tect\u00e9 la pr\u00e9sence d'un filament. firmware_retraction \u00b6 Les informations suivantes sont disponibles dans l'objet firmware_retraction : retract_length , retract_speed , unretract_extra_length , unretract_speed : sont les param\u00e8tres du module firmware_retraction. Ces param\u00e8tres peuvent diff\u00e9rer du fichier de configuration si une commande SET_RETRACTION les modifie. gcode_button \u00b6 The following information is available in gcode_button some_name objects: state : The current button state returned as \"PRESSED\" or \"RELEASED\" gcode_macro \u00b6 Les informations suivantes sont disponibles dans les objets gcode_macro nom_de_la_macro : <variable> : la valeur actuelle d'une variable gcode_macro . gcode_move \u00b6 Les informations suivantes sont disponibles dans l'objet gcode_move (cet objet est toujours disponible) : gcode_position : La position actuelle de la t\u00eate d'outil par rapport \u00e0 l'origine actuelle du G-Code. C'est-\u00e0-dire des positions que l'on pourrait envoyer directement \u00e0 une commande G1 . Il est possible d'acc\u00e9der aux composants x, y, z et e de cette position (par exemple, gcode_position.x ). position : la derni\u00e8re position command\u00e9e de la t\u00eate d'outil \u00e0 l'aide du syst\u00e8me de coordonn\u00e9es sp\u00e9cifi\u00e9 dans le fichier de configuration. Il est possible d'acc\u00e9der aux composantes x, y, z et e de cette position (par exemple, position.x ). homing_origin : L'origine du syst\u00e8me de coordonn\u00e9es gcode (par rapport au syst\u00e8me de coordonn\u00e9es sp\u00e9cifi\u00e9 dans le fichier de configuration) \u00e0 utiliser apr\u00e8s une commande G28 . La commande SET_GCODE_OFFSET peut modifier cette position. Il est possible d'acc\u00e9der aux composantes x, y et z de cette position (par exemple, homing_origin.x ). vitesse : La derni\u00e8re vitesse d\u00e9finie dans une commande G1 (en mm/s). speed_factor : Le \u00ab remplacement du facteur de vitesse \u00bb tel que d\u00e9fini par une commande M220 . Il s'agit d'une valeur \u00e0 virgule flottante. 1,0 signifie qu'il n'y a pas de d\u00e9passement et, par exemple, 2,0 double la vitesse demand\u00e9e. extrude_factor : le \"remplacement du facteur d'extrusion\" tel que d\u00e9fini par une commande M221 . Il s'agit d'une valeur \u00e0 virgule flottante. 1,0 signifie qu'il n'y a pas de remplacement et, par exemple, 2,0 double le volume d'extrusion demand\u00e9. absolute_coordinates : Cela renvoie True si l'on est en mode de coordonn\u00e9es absolues G90 ou False si l'on est en mode relatif G91 . absolute_extrude : Ceci renvoie True si l'on est en mode d'extrusion absolue M82 ou False si l'on est en mode relatif M83 . hall_filament_width_sensor \u00b6 Les informations suivantes sont disponibles dans l'objet hall_filament_width_sensor : is_active : renvoie True si le capteur est actif. Diameter : La derni\u00e8re lecture du capteur en mm. Raw : La derni\u00e8re lecture brute du convertisseur AN du capteur. heater \u00b6 Les informations suivantes sont disponibles pour les objets de type 'chauffage' tels que extruder , heater_bed et heater_generic : temperature : la derni\u00e8re temp\u00e9rature indiqu\u00e9e (en degr\u00e9s Celsius sous forme de nombre r\u00e9el) pour l'\u00e9l\u00e9ment chauffant donn\u00e9. target : la temp\u00e9rature cible actuelle (en degr\u00e9s Celsius sous forme de nombre r\u00e9el) pour l'\u00e9l\u00e9ment chauffant donn\u00e9. power : le dernier r\u00e9glage de la broche PWM (une valeur comprise entre 0,0 et 1,0) associ\u00e9e \u00e0 l'\u00e9l\u00e9ment chauffant. can_extrude : si l'extrudeuse est \u00e0 la temp\u00e9rature minimum de fonctionnement (d\u00e9fini par min_extrude_temp ), disponible uniquement pour extruder heaters \u00b6 Les informations suivantes sont disponibles dans l'objet heaters (cet objet est disponible si un \u00e9l\u00e9ment chauffant est d\u00e9fini) : available_heaters : renvoie une liste de tous les \u00e9l\u00e9ments chauffants disponibles par leurs noms de section de configuration complets, par ex. [\"extruder\", \"heater_bed\", \"heater_generic my_custom_heater\"] . available_sensors : renvoie une liste de tous les capteurs de temp\u00e9rature actuellement disponibles par leurs noms de section de configuration complets, par ex. [\"extruder\", \"heater_bed\", \"heater_generic my_custom_heater\", \"temperature_sensor electronics_temp\"] . available_monitors : Returns a list of all currently available temperature monitors by their full config section names, e.g. [\"tmc2240 stepper_x\"] . While a temperature sensor is always available to read, a temperature monitor may not be available and will return null in such case. idle_timeout \u00b6 Les informations suivantes sont disponibles dans l'objet idle_timeout (cet objet est toujours disponible) : state : L'\u00e9tat actuel de l'imprimante tel qu'il est suivi par le module idle_timeout. Il s'agit de l'une des cha\u00eenes suivantes : \"Idle\", \"Printing\", \"Ready\". printing_time : la dur\u00e9e (en secondes) pendant laquelle l'imprimante est rest\u00e9e dans l'\u00e9tat \"Impression\" (telle que suivie par le module idle_timeout). led \u00b6 Les informations suivantes sont disponibles pour chaque sections [led nom_des_leds] , [neopixel nom_des_leds] , [dotstar nom_des_leds] , [pca9533 nom_des_leds] et [pca9632 nom_des_leds] d\u00e9finies dans printer.cfg : color_data : une liste de listes de couleurs contenant les valeurs RGBW pour une led de la cha\u00eene. Chaque valeur est repr\u00e9sent\u00e9e par un r\u00e9el de 0,0 \u00e0 1,0. Chaque liste de couleurs contient 4 \u00e9l\u00e9ments (rouge, vert, bleu, blanc) m\u00eame si la LED sous-jacente prend en charge moins de canaux de couleur. Par exemple, la valeur bleue (3e \u00e9l\u00e9ment de la liste des couleurs) du deuxi\u00e8me neopixel d'une cha\u00eene peut \u00eatre consult\u00e9e sur printer[\"neopixel <config_name>\"].color_data[1][2] . manual_probe \u00b6 Les informations suivantes sont disponibles dans l'objet manual_probe : is_active : renvoie True si un script d'assistance de sondage manuel est actuellement actif. z_position : La hauteur actuelle de la buse (telle que l'imprimante la situe). z_position_lower : Valeur de la derni\u00e8re tentative de d\u00e9tection mesur\u00e9e juste en dessous de la hauteur actuelle. z_position_upper : Valeur de la derni\u00e8re tentative de d\u00e9tection mesur\u00e9e juste au dessus de la hauteur actuelle. mcu \u00b6 Les informations suivantes sont disponibles dans les objets mcu et mcu nom_du_mcu : mcu_version : la version du code Klipper remont\u00e9e par le microcontr\u00f4leur. mcu_build_versions : informations sur les outils de construction utilis\u00e9s pour g\u00e9n\u00e9rer le code du microcontr\u00f4leur (tel que remont\u00e9 par le microcontr\u00f4leur). mcu_constants.<constant_name> : Compile les constantes de temps rapport\u00e9es par le microcontr\u00f4leur. Les constantes disponibles peuvent diff\u00e9rer entre les architectures de microcontr\u00f4leur et \u00e0 chaque r\u00e9vision de code. last_stats.<statistics_name> : informations statistiques sur la connexion du microcontr\u00f4leur. motion_report \u00b6 Les informations suivantes sont disponibles dans l'objet motion_report (cet objet est automatiquement disponible si une section de configuration 'stepper' est d\u00e9finie) : live_position : la position de la t\u00eate d'outil demand\u00e9e interpol\u00e9e \u00e0 l'instant T. live_velocity : la vitesse de la t\u00eate d'outil demand\u00e9e (en mm/s) \u00e0 l'instant T. live_extruder_velocity : la vitesse d'extrusion demand\u00e9e (en mm/s) \u00e0 l'instant T. output_pin \u00b6 Les informations suivantes sont disponibles dans les objets output_pin nom_de_la_sortie : value : la \"valeur\" de la broche, telle que d\u00e9finie par une commande SET_PIN . palette2 \u00b6 Les informations suivantes sont disponibles dans l'objet palette2 : ping : montant du dernier ping du \"Palette 2\" signal\u00e9 en pourcentage. remaining_load_length : lors du d\u00e9marrage d'une impression Palette 2, ce sera la quantit\u00e9 de filament \u00e0 charger dans l'extrudeuse. is_splicing : Vrai lorsque la Palette 2 soude le filament. pause_resume \u00b6 Les informations suivantes sont disponibles dans l'objet pause_resume : is_paused : Renvoie true si une commande PAUSE a \u00e9t\u00e9 ex\u00e9cut\u00e9e sans RESUME correspondant. print_stats \u00b6 Les informations suivantes sont disponibles dans l'objet print_stats (cet objet est automatiquement disponible si une section de configuration virtual_sdcard est d\u00e9finie) : filename , total_duration , print_duration , filament_used , state , message : informations estim\u00e9es sur l'impression en cours lorsqu'une impression virtual_sdcard est active. info.total_layer : La valeur totale de la couche de la derni\u00e8re commande SET_PRINT_STATS_INFO TOTAL_LAYER=<value> G-Code. info.current_layer : la valeur de la couche actuelle de la derni\u00e8re commande G-Code SET_PRINT_STATS_INFO CURRENT_LAYER=<valeur> . probe \u00b6 Les informations suivantes sont disponibles dans l'objet probe (cet objet est \u00e9galement disponible si une section de configuration bltouch est d\u00e9finie) : name : Renvoie le nom de la sonde en cours d'utilisation. last_query : renvoie True si la sonde a \u00e9t\u00e9 signal\u00e9e comme \"d\u00e9clench\u00e9e\" lors de la derni\u00e8re commande QUERY_PROBE. Notez que si cela est utilis\u00e9 dans une macro, en raison de l'ordre de d\u00e9veloppement du mod\u00e8le, la commande QUERY_PROBE doit \u00eatre ex\u00e9cut\u00e9e avant la macro contenant cette demande. last_z_result : Renvoie la valeur du Z de la derni\u00e8re commande PROBE. Notez que si cela est utilis\u00e9 dans une macro, en raison de l'ordre d'expansion du mod\u00e8le, la commande PROBE (ou similaire) doit \u00eatre ex\u00e9cut\u00e9e avant la macro contenant cette demande. quad_gantry_level \u00b6 Les informations suivantes sont disponibles dans l'objet quad_gantry_level (cet objet est disponible si quad_gantry_level est d\u00e9fini) : applied : Vrai si le processus de nivellement 4 points du portique a \u00e9t\u00e9 ex\u00e9cut\u00e9 et termin\u00e9 avec succ\u00e8s. query_endstops \u00b6 Les informations suivantes sont disponibles dans l'objet query_endstops (cet objet est disponible si au moins une fin de course est d\u00e9finie) : last_query[\"<endstop>\"] : renvoie True si l'endstop donn\u00e9 a \u00e9t\u00e9 signal\u00e9 comme \"d\u00e9clench\u00e9\" (triggered) lors de la derni\u00e8re commande QUERY_ENDSTOP. Notez que si cela est utilis\u00e9 dans une macro, en raison de l'ordre de d\u00e9veloppement du mod\u00e8le, la commande QUERY_ENDSTOP doit \u00eatre ex\u00e9cut\u00e9e avant la macro contenant cette demande. screws_tilt_adjust \u00b6 Les informations suivantes sont disponibles dans l'objet screws_tilt_adjust : error : renvoie True si la commande SCREWS_TILT_CALCULATE la plus r\u00e9cente incluait le param\u00e8tre MAX_DEVIATION et que l'un des sondages au niveau des vis de lit d\u00e9passait la valeur MAX_DEVIATION . max_deviation : Return the last MAX_DEVIATION value of the most recent SCREWS_TILT_CALCULATE command. results[\"<screw>\"] : Un dictionnaire contenant les cl\u00e9s suivantes : z : La hauteur Z mesur\u00e9e \u00e0 l'emplacement de la vis. sign : Une cha\u00eene sp\u00e9cifiant le sens de rotation des vis pour le r\u00e9glage. Soit \"CW\" pour le sens horaire ou \"CCW\" pour le sens antihoraire. adjust : le nombre de tours de vis pour ajuster la vis, donn\u00e9 au format \"HH:MM\", o\u00f9 \"HH\" est le nombre de tours de vis complets et \"MM\" est le nombre de \"minutes d'un cadran d'horloge\" repr\u00e9sentant un tour de vis partiel. (Par exemple, \"01:15\" signifierait de tourner la vis d'un tour et quart.) is_base : renvoie True s'il s'agit de la vis de base. servo \u00b6 Les informations suivantes sont disponibles dans les objets servo some_name : printer[\"servo <config_name>\"].value : le dernier r\u00e9glage de la broche PWM (une valeur comprise entre 0,0 et 1,0) associ\u00e9e au servo. stepper_enable \u00b6 Les informations suivantes sont disponibles dans l'objet stepper_enable (cet objet est disponible si un stepper est d\u00e9fini) : steppers[\"<stepper>\"] : renvoie True si le stepper donn\u00e9 est activ\u00e9. system_stats \u00b6 Les informations suivantes sont disponibles dans l'objet system_stats (cet objet est toujours disponible) : sysload , cputime , memavail : informations sur le syst\u00e8me d'exploitation h\u00f4te et la charge du processus. Capteurs de temp\u00e9rature \u00b6 Les informations suivantes sont disponibles dans bme280 config_section_name , htu21d config_section_name , lm75 config_section_name , temperature_host config_section_name and temperature_combined config_section_name objects: temperature : La derni\u00e8re temp\u00e9rature lue par le capteur. humidit\u00e9 , pression , gaz : les derni\u00e8res valeurs lues par le capteur (uniquement sur les capteurs bme280, htu21d et lm75). temperature_fan \u00b6 Les informations suivantes sont disponibles dans les objets temperature_fan nom_du_ventilateur : temperature : La derni\u00e8re temp\u00e9rature lue par le capteur. target : La temp\u00e9rature cible pour le ventilateur. temperature_sensor \u00b6 Les informations suivantes sont disponibles dans les objets temperature_sensor nom_du_capteur : temperature : La derni\u00e8re temp\u00e9rature lue par le capteur. measured_min_temp , measured_max_temp : la temp\u00e9rature la plus basse et la plus \u00e9lev\u00e9e observ\u00e9es par le capteur depuis le dernier red\u00e9marrage de Klipper. Pilotes TMC \u00b6 Les informations suivantes sont disponibles dans les objets pilote pas \u00e0 pas TMC (par exemple, [tmc2208 stepper_x] ) : mcu_phase_offset : la position du moteur pas \u00e0 pas du microcontr\u00f4leur correspondant \u00e0 la phase \"z\u00e9ro\" du pilote. Ce champ peut \u00eatre nul si le d\u00e9phasage n'est pas connu. phase_offset_position : La \"position command\u00e9e\" correspondant \u00e0 la phase \"z\u00e9ro\" du driver. Ce champ peut \u00eatre nul si le d\u00e9phasage n'est pas connu. drv_status : les r\u00e9sultats de la derni\u00e8re requ\u00eate d'\u00e9tat du pilote. (Seuls les champs non nuls sont signal\u00e9s.) Ce champ sera nul si le pilote n'est pas activ\u00e9 (et n'est donc pas interrog\u00e9 p\u00e9riodiquement). temperature : The internal temperature reported by the driver. This field will be null if the driver is not enabled or if the driver does not support temperature reporting. run_current : le courant de fonctionnement actuellement d\u00e9fini. hold_current : Le courant de maintien actuellement d\u00e9fini. toolhead \u00b6 Les informations suivantes sont disponibles dans l'objet toolhead (cet objet est toujours disponible) : position : la derni\u00e8re position command\u00e9e de la t\u00eate d'outil par rapport au syst\u00e8me de coordonn\u00e9es sp\u00e9cifi\u00e9 dans le fichier de configuration. Il est possible d'acc\u00e9der aux composantes x, y, z et e de cette position (par exemple, position.x ). extruder : le nom de l'extrudeur actuellement actif. Par exemple, dans une macro, on pourrait utiliser printer[printer.toolhead.extruder].target pour obtenir la temp\u00e9rature cible de l'extrudeuse actuelle. homed_axes : les axes consid\u00e9r\u00e9s comme \u00e9tant dans un \u00e9tat \"\u00e0 l'origine\". Il s'agit d'une cha\u00eene contenant un ou plusieurs \"x\", \"y\", \"z\". axis_minimum , axis_maximum : les limites de d\u00e9placement de l'axe (mm) apr\u00e8s la mise \u00e0 l'origine. Il est possible d'acc\u00e9der aux composantes x, y, z de cette valeur limite (par exemple, axis_minimum.x , axis_maximum.z ). Pour les imprimantes Delta, le cone_start_z est la hauteur z maximale au rayon maximal ( printer.toolhead.cone_start_z ). max_velocity , max_accel , max_accel_to_decel , square_corner_velocity : les limites d'impression actuelles en vigueur. Cela peut diff\u00e9rer des param\u00e8tres du fichier de configuration si une commande SET_VELOCITY_LIMIT (ou M204 ) les a modifi\u00e9es au moment de l'ex\u00e9cution. stalls : Le nombre total de fois (depuis le dernier red\u00e9marrage) o\u00f9 l'imprimante a d\u00fb \u00eatre mise en pause parce que la t\u00eate d'outil s'est d\u00e9plac\u00e9e plus vite que les mouvements ne pouvaient \u00eatre lus \u00e0 partir de l'entr\u00e9e G-Code. dual_carriage \u00b6 The following information is available in dual_carriage on a cartesian, hybrid_corexy or hybrid_corexz robot carriage_0 : The mode of the carriage 0. Possible values are: \"INACTIVE\" and \"PRIMARY\". carriage_1 : The mode of the carriage 1. Possible values are: \"INACTIVE\", \"PRIMARY\", \"COPY\", and \"MIRROR\". virtual_sdcard \u00b6 Les informations suivantes sont disponibles dans l'objet virtual_sdcard : is_active : renvoie True si une impression \u00e0 partir d'un fichier est actuellement active. progress : une estimation de la progression de l'impression actuelle (bas\u00e9e sur la taille et la position du fichier). file_path : un chemin d'acc\u00e8s complet au fichier actuellement charg\u00e9. file_position : la position actuelle (en octets) d'une impression active. file_size : taille (en octets) du fichier actuellement charg\u00e9. webhooks \u00b6 Les informations suivantes sont disponibles dans l'objet webhooks (cet objet est toujours disponible) : state : renvoie une cha\u00eene indiquant l'\u00e9tat actuel de Klipper. Les valeurs possibles sont : \"ready\", \"startup\", \"shutdown\", \"error\". state_message : une cha\u00eene donnant un contexte suppl\u00e9mentaire sur l'\u00e9tat actuel de Klipper. z_thermal_adjust \u00b6 Les informations suivantes sont disponibles dans l'objet z_thermal_adjust (cet objet est disponible si z_thermal_adjust est d\u00e9fini). enabled : renvoie True si le r\u00e9glage est activ\u00e9. temp\u00e9rature : Temp\u00e9rature actuelle (liss\u00e9e) du capteur d\u00e9fini. (en degr\u00e9s Centigrades) measured_min_temp : temp\u00e9rature minimale mesur\u00e9e. (en degr\u00e9s Centigrades) measured_max_temp : temp\u00e9rature maximale mesur\u00e9e. (En degr\u00e9s Centigrades) current_z_adjust : dernier ajustement Z calcul\u00e9 (en mm). z_adjust_ref_temperature : Temp\u00e9rature de r\u00e9f\u00e9rence actuelle utilis\u00e9e pour le calcul de Z current_z_adjust (En degr\u00e9s Centigrades). z_tilt \u00b6 Les informations suivantes sont disponibles dans l'objet z_tilt (cet objet est disponible si z_tilt est d\u00e9fini) : applied : Vrai si le processus de mise \u00e0 niveau z-tilt a \u00e9t\u00e9 ex\u00e9cut\u00e9 et termin\u00e9 avec succ\u00e8s.","title":"R\u00e9f\u00e9rence des \u00e9tats"},{"location":"Status_Reference.html#reference-des-etats","text":"Ce document est une r\u00e9f\u00e9rence aux informations de status de l'imprimante dans Klipper macros , display fields , et via l' API Server . Les champs de ce document sont susceptibles d'\u00eatre modifi\u00e9s - si vous utilisez un attribut, veillez \u00e0 consulter le document Modifications des configurations lors de la mise \u00e0 jour du logiciel Klipper.","title":"R\u00e9f\u00e9rence des \u00e9tats"},{"location":"Status_Reference.html#angle","text":"Les informations suivantes sont disponibles dans les objets angle votre_nom : temperature : la derni\u00e8re lecture de temp\u00e9rature (en degr\u00e9s Celsius) d'un capteur \u00e0 effet Hall magn\u00e9tique de type tle5012b. Cette valeur n'est disponible que si le capteur d'angle est une puce tle5012b et si des mesures sont en cours (sinon il signale None ).","title":"angle"},{"location":"Status_Reference.html#bed_mesh","text":"Les informations suivantes sont disponibles dans l'objet cartographie du lit (bed mash) : profile_name , mesh_min , mesh_max , probed_matrix , mesh_matrix : informations sur la cartographie du lit actuellement active. profiles : l'ensemble des profils actuellement d\u00e9finis tels que configur\u00e9s \u00e0 l'aide de BED_MESH_PROFILE.","title":"bed_mesh"},{"location":"Status_Reference.html#bed_screws","text":"Les informations suivantes sont disponibles dans l'objet Config_Reference.md#bed_screws : is_active : Renvoie True si le script de r\u00e9glage des vis du lit est en cours. state : L'\u00e9tat du script de r\u00e9glage des vis du lit. deux \u00e9taIl s'agit de l'une des cha\u00eenes suivantes : \"adjust\", \"fine\". current_screw : le num\u00e9ro de la vis en cours de r\u00e9glage. accepted_screws : nombre de vis qui ont \u00e9t\u00e9 accept\u00e9es (ndt donc marqu\u00e9es comme r\u00e9gl\u00e9es).","title":"bed_screws"},{"location":"Status_Reference.html#fichier-de-configuration","text":"Les informations suivantes sont disponibles dans l'objet configfile (cet objet est toujours disponible) : settings.<section>.<option> : Renvoie les param\u00e9trages du fichier de configuration (ou la valeur par d\u00e9faut) lors du dernier d\u00e9marrage ou red\u00e9marrage du logiciel. (Tout param\u00e8tre modifi\u00e9 pendant l'ex\u00e9cution ne sera pas refl\u00e9t\u00e9 ici.) config.<section>.<option> : Renvoie le param\u00e8tre donn\u00e9 du fichier de configuration tel que lu par Klipper lors du dernier d\u00e9marrage ou red\u00e9marrage du logiciel. (Tout param\u00e8tre modifi\u00e9 au moment de l'ex\u00e9cution ne sera pas refl\u00e9t\u00e9 ici.) Toutes les valeurs sont renvoy\u00e9es sous forme de cha\u00eenes. save_config_pending : renvoie vrai s'il existe des mises \u00e0 jour en attente qu'une commande SAVE_CONFIG peut enregistrer sur le disque. save_config_pending_items : Contient les sections et les \u00e9l\u00e9ments qui ont \u00e9t\u00e9 modifi\u00e9es et qui peuvent \u00eatre sauvegard\u00e9es avec un SAVE_CONFIG . warnings : une liste d'avertissements concernant les options de configuration. Chaque entr\u00e9e de la liste sera un dictionnaire contenant un champ type et message (les deux cha\u00eenes). Des champs suppl\u00e9mentaires peuvent \u00eatre disponibles selon le type d'avertissement.","title":"fichier de configuration"},{"location":"Status_Reference.html#display_status","text":"Les informations suivantes sont disponibles dans l\u2019objet display_status (cet objet est automatiquement disponible si une section de configuration affichage est d\u00e9finie) : progress : la valeur de progression de la derni\u00e8re commande G-Code M73 (ou virtual_sdcard.progress si aucune commande M73 r\u00e9cente n'a \u00e9t\u00e9 re\u00e7ue). message : Le message contenu dans la derni\u00e8re commande G-Code M117 .","title":"display_status"},{"location":"Status_Reference.html#endstop_phase","text":"Les informations suivantes sont disponibles dans l'objet endstop_phase : last_home.<stepper name>.phase : La phase du moteur pas \u00e0 pas \u00e0 la fin de la derni\u00e8re tentative de retour \u00e0 l'origine. last_home.<stepper name>.phases : Le nombre total de phases disponibles sur le moteur pas \u00e0 pas. last_home.<stepper name>.mcu_position : La position (telle que suivie par le microcontr\u00f4leur) du moteur pas \u00e0 pas \u00e0 la fin de la derni\u00e8re tentative de retour \u00e0 l'origine. La position est le nombre total de pas effectu\u00e9s dans le sens avant moins le nombre total de pas effectu\u00e9s dans le sens inverse depuis le dernier red\u00e9marrage du microcontr\u00f4leur.","title":"endstop_phase"},{"location":"Status_Reference.html#exclude_object","text":"Les informations suivantes sont disponibles dans l'objet exclude_object : objects : Un tableau des objets connus tel que fourni par la commande EXCLUDE_OBJECT_DEFINE . Il s'agit des m\u00eames informations fournies par la commande EXCLUDE_OBJECT VERBOSE=1 . Les champs center et polygon ne seront pr\u00e9sents que s'ils sont fournis dans l'original EXCLUDE_OBJECT_DEFINE Voici un exemple JSON : [ { \"polygon\": [ [ 156.25, 146.2511675 ], [ 156.25, 153.7488325 ], [ 163.75, 153.7488325 ], [ 163.75, 146.2511675 ] ], \"name\": \"CYLINDER_2_STL_ID_2_COPY_0\", \"center\": [ 160, 150 ] }, { \"polygon\": [ [ 146.25, 146.2511675 ], [ 146.25, 153.7488325 ], [ 153.75, 153.7488325 ], [ 153.75, 146.2511675 ] ], \"name\": \"CYLINDER_2_STL_ID_1_COPY_0\", \"center\": [ 150, 150 ] } ] excluded_objects : un tableau de cha\u00eenes r\u00e9pertoriant les noms des objets exclus. current_object : Le nom de l'objet en cours d'impression.","title":"exclude_object"},{"location":"Status_Reference.html#extruder_stepper","text":"Les informations suivantes sont disponibles pour les objets extruder_stepper (ainsi que les objets extruder ) : pressure_advance : la valeur actuelle de pressure advance . smooth_time : Le temps de lissage associ\u00e9 \u00e0 la valeur de \"pressure advance\" courante. motion_queue : Le nom de l'extrudeur avec lequel ce stepper d'extrudeur est actuellement synchronis\u00e9. Ceci est signal\u00e9 comme Aucun si le moteur pas \u00e0 pas de l'extrudeuse n'est pas associ\u00e9 \u00e0 un extrudeur.","title":"extruder_stepper"},{"location":"Status_Reference.html#ventilateur","text":"Les informations suivantes sont disponibles dans les objets fan , heater_fan nom_du_ventilateur et controller_fan nom_du_ventilateur : speed : La vitesse du ventilateur nombre r\u00e9el entre 0,0 et 1,0. rpm : La vitesse du ventilateur mesur\u00e9e en rotations par minute si le ventilateur a un tachometer_pin d\u00e9fini (ndt : et si le ventilateur poss\u00e8de un tachym\u00e8tre).","title":"ventilateur"},{"location":"Status_Reference.html#filament_switch_sensor","text":"Les informations suivantes sont disponibles dans les objets filament_switch_sensor nom_du_d\u00e9tecteur : enabled : renvoie True si le d\u00e9tecteur de fin de filament est activ\u00e9. filament_detected : renvoie True si le d\u00e9tecteur de fin de filament a d\u00e9tect\u00e9 la pr\u00e9sence d'un filament.","title":"filament_switch_sensor"},{"location":"Status_Reference.html#filament_motion_sensor","text":"Les informations suivantes sont disponibles dans les objets filament_motion_sensor nom_du_detecteur : enabled : renvoie True si le d\u00e9tecteur de mouvement du filament est activ\u00e9. filament_detected : renvoie True si le d\u00e9tecteur de fin de filament a d\u00e9tect\u00e9 la pr\u00e9sence d'un filament.","title":"filament_motion_sensor"},{"location":"Status_Reference.html#firmware_retraction","text":"Les informations suivantes sont disponibles dans l'objet firmware_retraction : retract_length , retract_speed , unretract_extra_length , unretract_speed : sont les param\u00e8tres du module firmware_retraction. Ces param\u00e8tres peuvent diff\u00e9rer du fichier de configuration si une commande SET_RETRACTION les modifie.","title":"firmware_retraction"},{"location":"Status_Reference.html#gcode_button","text":"The following information is available in gcode_button some_name objects: state : The current button state returned as \"PRESSED\" or \"RELEASED\"","title":"gcode_button"},{"location":"Status_Reference.html#gcode_macro","text":"Les informations suivantes sont disponibles dans les objets gcode_macro nom_de_la_macro : <variable> : la valeur actuelle d'une variable gcode_macro .","title":"gcode_macro"},{"location":"Status_Reference.html#gcode_move","text":"Les informations suivantes sont disponibles dans l'objet gcode_move (cet objet est toujours disponible) : gcode_position : La position actuelle de la t\u00eate d'outil par rapport \u00e0 l'origine actuelle du G-Code. C'est-\u00e0-dire des positions que l'on pourrait envoyer directement \u00e0 une commande G1 . Il est possible d'acc\u00e9der aux composants x, y, z et e de cette position (par exemple, gcode_position.x ). position : la derni\u00e8re position command\u00e9e de la t\u00eate d'outil \u00e0 l'aide du syst\u00e8me de coordonn\u00e9es sp\u00e9cifi\u00e9 dans le fichier de configuration. Il est possible d'acc\u00e9der aux composantes x, y, z et e de cette position (par exemple, position.x ). homing_origin : L'origine du syst\u00e8me de coordonn\u00e9es gcode (par rapport au syst\u00e8me de coordonn\u00e9es sp\u00e9cifi\u00e9 dans le fichier de configuration) \u00e0 utiliser apr\u00e8s une commande G28 . La commande SET_GCODE_OFFSET peut modifier cette position. Il est possible d'acc\u00e9der aux composantes x, y et z de cette position (par exemple, homing_origin.x ). vitesse : La derni\u00e8re vitesse d\u00e9finie dans une commande G1 (en mm/s). speed_factor : Le \u00ab remplacement du facteur de vitesse \u00bb tel que d\u00e9fini par une commande M220 . Il s'agit d'une valeur \u00e0 virgule flottante. 1,0 signifie qu'il n'y a pas de d\u00e9passement et, par exemple, 2,0 double la vitesse demand\u00e9e. extrude_factor : le \"remplacement du facteur d'extrusion\" tel que d\u00e9fini par une commande M221 . Il s'agit d'une valeur \u00e0 virgule flottante. 1,0 signifie qu'il n'y a pas de remplacement et, par exemple, 2,0 double le volume d'extrusion demand\u00e9. absolute_coordinates : Cela renvoie True si l'on est en mode de coordonn\u00e9es absolues G90 ou False si l'on est en mode relatif G91 . absolute_extrude : Ceci renvoie True si l'on est en mode d'extrusion absolue M82 ou False si l'on est en mode relatif M83 .","title":"gcode_move"},{"location":"Status_Reference.html#hall_filament_width_sensor","text":"Les informations suivantes sont disponibles dans l'objet hall_filament_width_sensor : is_active : renvoie True si le capteur est actif. Diameter : La derni\u00e8re lecture du capteur en mm. Raw : La derni\u00e8re lecture brute du convertisseur AN du capteur.","title":"hall_filament_width_sensor"},{"location":"Status_Reference.html#heater","text":"Les informations suivantes sont disponibles pour les objets de type 'chauffage' tels que extruder , heater_bed et heater_generic : temperature : la derni\u00e8re temp\u00e9rature indiqu\u00e9e (en degr\u00e9s Celsius sous forme de nombre r\u00e9el) pour l'\u00e9l\u00e9ment chauffant donn\u00e9. target : la temp\u00e9rature cible actuelle (en degr\u00e9s Celsius sous forme de nombre r\u00e9el) pour l'\u00e9l\u00e9ment chauffant donn\u00e9. power : le dernier r\u00e9glage de la broche PWM (une valeur comprise entre 0,0 et 1,0) associ\u00e9e \u00e0 l'\u00e9l\u00e9ment chauffant. can_extrude : si l'extrudeuse est \u00e0 la temp\u00e9rature minimum de fonctionnement (d\u00e9fini par min_extrude_temp ), disponible uniquement pour extruder","title":"heater"},{"location":"Status_Reference.html#heaters","text":"Les informations suivantes sont disponibles dans l'objet heaters (cet objet est disponible si un \u00e9l\u00e9ment chauffant est d\u00e9fini) : available_heaters : renvoie une liste de tous les \u00e9l\u00e9ments chauffants disponibles par leurs noms de section de configuration complets, par ex. [\"extruder\", \"heater_bed\", \"heater_generic my_custom_heater\"] . available_sensors : renvoie une liste de tous les capteurs de temp\u00e9rature actuellement disponibles par leurs noms de section de configuration complets, par ex. [\"extruder\", \"heater_bed\", \"heater_generic my_custom_heater\", \"temperature_sensor electronics_temp\"] . available_monitors : Returns a list of all currently available temperature monitors by their full config section names, e.g. [\"tmc2240 stepper_x\"] . While a temperature sensor is always available to read, a temperature monitor may not be available and will return null in such case.","title":"heaters"},{"location":"Status_Reference.html#idle_timeout","text":"Les informations suivantes sont disponibles dans l'objet idle_timeout (cet objet est toujours disponible) : state : L'\u00e9tat actuel de l'imprimante tel qu'il est suivi par le module idle_timeout. Il s'agit de l'une des cha\u00eenes suivantes : \"Idle\", \"Printing\", \"Ready\". printing_time : la dur\u00e9e (en secondes) pendant laquelle l'imprimante est rest\u00e9e dans l'\u00e9tat \"Impression\" (telle que suivie par le module idle_timeout).","title":"idle_timeout"},{"location":"Status_Reference.html#led","text":"Les informations suivantes sont disponibles pour chaque sections [led nom_des_leds] , [neopixel nom_des_leds] , [dotstar nom_des_leds] , [pca9533 nom_des_leds] et [pca9632 nom_des_leds] d\u00e9finies dans printer.cfg : color_data : une liste de listes de couleurs contenant les valeurs RGBW pour une led de la cha\u00eene. Chaque valeur est repr\u00e9sent\u00e9e par un r\u00e9el de 0,0 \u00e0 1,0. Chaque liste de couleurs contient 4 \u00e9l\u00e9ments (rouge, vert, bleu, blanc) m\u00eame si la LED sous-jacente prend en charge moins de canaux de couleur. Par exemple, la valeur bleue (3e \u00e9l\u00e9ment de la liste des couleurs) du deuxi\u00e8me neopixel d'une cha\u00eene peut \u00eatre consult\u00e9e sur printer[\"neopixel <config_name>\"].color_data[1][2] .","title":"led"},{"location":"Status_Reference.html#manual_probe","text":"Les informations suivantes sont disponibles dans l'objet manual_probe : is_active : renvoie True si un script d'assistance de sondage manuel est actuellement actif. z_position : La hauteur actuelle de la buse (telle que l'imprimante la situe). z_position_lower : Valeur de la derni\u00e8re tentative de d\u00e9tection mesur\u00e9e juste en dessous de la hauteur actuelle. z_position_upper : Valeur de la derni\u00e8re tentative de d\u00e9tection mesur\u00e9e juste au dessus de la hauteur actuelle.","title":"manual_probe"},{"location":"Status_Reference.html#mcu","text":"Les informations suivantes sont disponibles dans les objets mcu et mcu nom_du_mcu : mcu_version : la version du code Klipper remont\u00e9e par le microcontr\u00f4leur. mcu_build_versions : informations sur les outils de construction utilis\u00e9s pour g\u00e9n\u00e9rer le code du microcontr\u00f4leur (tel que remont\u00e9 par le microcontr\u00f4leur). mcu_constants.<constant_name> : Compile les constantes de temps rapport\u00e9es par le microcontr\u00f4leur. Les constantes disponibles peuvent diff\u00e9rer entre les architectures de microcontr\u00f4leur et \u00e0 chaque r\u00e9vision de code. last_stats.<statistics_name> : informations statistiques sur la connexion du microcontr\u00f4leur.","title":"mcu"},{"location":"Status_Reference.html#motion_report","text":"Les informations suivantes sont disponibles dans l'objet motion_report (cet objet est automatiquement disponible si une section de configuration 'stepper' est d\u00e9finie) : live_position : la position de la t\u00eate d'outil demand\u00e9e interpol\u00e9e \u00e0 l'instant T. live_velocity : la vitesse de la t\u00eate d'outil demand\u00e9e (en mm/s) \u00e0 l'instant T. live_extruder_velocity : la vitesse d'extrusion demand\u00e9e (en mm/s) \u00e0 l'instant T.","title":"motion_report"},{"location":"Status_Reference.html#output_pin","text":"Les informations suivantes sont disponibles dans les objets output_pin nom_de_la_sortie : value : la \"valeur\" de la broche, telle que d\u00e9finie par une commande SET_PIN .","title":"output_pin"},{"location":"Status_Reference.html#palette2","text":"Les informations suivantes sont disponibles dans l'objet palette2 : ping : montant du dernier ping du \"Palette 2\" signal\u00e9 en pourcentage. remaining_load_length : lors du d\u00e9marrage d'une impression Palette 2, ce sera la quantit\u00e9 de filament \u00e0 charger dans l'extrudeuse. is_splicing : Vrai lorsque la Palette 2 soude le filament.","title":"palette2"},{"location":"Status_Reference.html#pause_resume","text":"Les informations suivantes sont disponibles dans l'objet pause_resume : is_paused : Renvoie true si une commande PAUSE a \u00e9t\u00e9 ex\u00e9cut\u00e9e sans RESUME correspondant.","title":"pause_resume"},{"location":"Status_Reference.html#print_stats","text":"Les informations suivantes sont disponibles dans l'objet print_stats (cet objet est automatiquement disponible si une section de configuration virtual_sdcard est d\u00e9finie) : filename , total_duration , print_duration , filament_used , state , message : informations estim\u00e9es sur l'impression en cours lorsqu'une impression virtual_sdcard est active. info.total_layer : La valeur totale de la couche de la derni\u00e8re commande SET_PRINT_STATS_INFO TOTAL_LAYER=<value> G-Code. info.current_layer : la valeur de la couche actuelle de la derni\u00e8re commande G-Code SET_PRINT_STATS_INFO CURRENT_LAYER=<valeur> .","title":"print_stats"},{"location":"Status_Reference.html#probe","text":"Les informations suivantes sont disponibles dans l'objet probe (cet objet est \u00e9galement disponible si une section de configuration bltouch est d\u00e9finie) : name : Renvoie le nom de la sonde en cours d'utilisation. last_query : renvoie True si la sonde a \u00e9t\u00e9 signal\u00e9e comme \"d\u00e9clench\u00e9e\" lors de la derni\u00e8re commande QUERY_PROBE. Notez que si cela est utilis\u00e9 dans une macro, en raison de l'ordre de d\u00e9veloppement du mod\u00e8le, la commande QUERY_PROBE doit \u00eatre ex\u00e9cut\u00e9e avant la macro contenant cette demande. last_z_result : Renvoie la valeur du Z de la derni\u00e8re commande PROBE. Notez que si cela est utilis\u00e9 dans une macro, en raison de l'ordre d'expansion du mod\u00e8le, la commande PROBE (ou similaire) doit \u00eatre ex\u00e9cut\u00e9e avant la macro contenant cette demande.","title":"probe"},{"location":"Status_Reference.html#quad_gantry_level","text":"Les informations suivantes sont disponibles dans l'objet quad_gantry_level (cet objet est disponible si quad_gantry_level est d\u00e9fini) : applied : Vrai si le processus de nivellement 4 points du portique a \u00e9t\u00e9 ex\u00e9cut\u00e9 et termin\u00e9 avec succ\u00e8s.","title":"quad_gantry_level"},{"location":"Status_Reference.html#query_endstops","text":"Les informations suivantes sont disponibles dans l'objet query_endstops (cet objet est disponible si au moins une fin de course est d\u00e9finie) : last_query[\"<endstop>\"] : renvoie True si l'endstop donn\u00e9 a \u00e9t\u00e9 signal\u00e9 comme \"d\u00e9clench\u00e9\" (triggered) lors de la derni\u00e8re commande QUERY_ENDSTOP. Notez que si cela est utilis\u00e9 dans une macro, en raison de l'ordre de d\u00e9veloppement du mod\u00e8le, la commande QUERY_ENDSTOP doit \u00eatre ex\u00e9cut\u00e9e avant la macro contenant cette demande.","title":"query_endstops"},{"location":"Status_Reference.html#screws_tilt_adjust","text":"Les informations suivantes sont disponibles dans l'objet screws_tilt_adjust : error : renvoie True si la commande SCREWS_TILT_CALCULATE la plus r\u00e9cente incluait le param\u00e8tre MAX_DEVIATION et que l'un des sondages au niveau des vis de lit d\u00e9passait la valeur MAX_DEVIATION . max_deviation : Return the last MAX_DEVIATION value of the most recent SCREWS_TILT_CALCULATE command. results[\"<screw>\"] : Un dictionnaire contenant les cl\u00e9s suivantes : z : La hauteur Z mesur\u00e9e \u00e0 l'emplacement de la vis. sign : Une cha\u00eene sp\u00e9cifiant le sens de rotation des vis pour le r\u00e9glage. Soit \"CW\" pour le sens horaire ou \"CCW\" pour le sens antihoraire. adjust : le nombre de tours de vis pour ajuster la vis, donn\u00e9 au format \"HH:MM\", o\u00f9 \"HH\" est le nombre de tours de vis complets et \"MM\" est le nombre de \"minutes d'un cadran d'horloge\" repr\u00e9sentant un tour de vis partiel. (Par exemple, \"01:15\" signifierait de tourner la vis d'un tour et quart.) is_base : renvoie True s'il s'agit de la vis de base.","title":"screws_tilt_adjust"},{"location":"Status_Reference.html#servo","text":"Les informations suivantes sont disponibles dans les objets servo some_name : printer[\"servo <config_name>\"].value : le dernier r\u00e9glage de la broche PWM (une valeur comprise entre 0,0 et 1,0) associ\u00e9e au servo.","title":"servo"},{"location":"Status_Reference.html#stepper_enable","text":"Les informations suivantes sont disponibles dans l'objet stepper_enable (cet objet est disponible si un stepper est d\u00e9fini) : steppers[\"<stepper>\"] : renvoie True si le stepper donn\u00e9 est activ\u00e9.","title":"stepper_enable"},{"location":"Status_Reference.html#system_stats","text":"Les informations suivantes sont disponibles dans l'objet system_stats (cet objet est toujours disponible) : sysload , cputime , memavail : informations sur le syst\u00e8me d'exploitation h\u00f4te et la charge du processus.","title":"system_stats"},{"location":"Status_Reference.html#capteurs-de-temperature","text":"Les informations suivantes sont disponibles dans bme280 config_section_name , htu21d config_section_name , lm75 config_section_name , temperature_host config_section_name and temperature_combined config_section_name objects: temperature : La derni\u00e8re temp\u00e9rature lue par le capteur. humidit\u00e9 , pression , gaz : les derni\u00e8res valeurs lues par le capteur (uniquement sur les capteurs bme280, htu21d et lm75).","title":"Capteurs de temp\u00e9rature"},{"location":"Status_Reference.html#temperature_fan","text":"Les informations suivantes sont disponibles dans les objets temperature_fan nom_du_ventilateur : temperature : La derni\u00e8re temp\u00e9rature lue par le capteur. target : La temp\u00e9rature cible pour le ventilateur.","title":"temperature_fan"},{"location":"Status_Reference.html#temperature_sensor","text":"Les informations suivantes sont disponibles dans les objets temperature_sensor nom_du_capteur : temperature : La derni\u00e8re temp\u00e9rature lue par le capteur. measured_min_temp , measured_max_temp : la temp\u00e9rature la plus basse et la plus \u00e9lev\u00e9e observ\u00e9es par le capteur depuis le dernier red\u00e9marrage de Klipper.","title":"temperature_sensor"},{"location":"Status_Reference.html#pilotes-tmc","text":"Les informations suivantes sont disponibles dans les objets pilote pas \u00e0 pas TMC (par exemple, [tmc2208 stepper_x] ) : mcu_phase_offset : la position du moteur pas \u00e0 pas du microcontr\u00f4leur correspondant \u00e0 la phase \"z\u00e9ro\" du pilote. Ce champ peut \u00eatre nul si le d\u00e9phasage n'est pas connu. phase_offset_position : La \"position command\u00e9e\" correspondant \u00e0 la phase \"z\u00e9ro\" du driver. Ce champ peut \u00eatre nul si le d\u00e9phasage n'est pas connu. drv_status : les r\u00e9sultats de la derni\u00e8re requ\u00eate d'\u00e9tat du pilote. (Seuls les champs non nuls sont signal\u00e9s.) Ce champ sera nul si le pilote n'est pas activ\u00e9 (et n'est donc pas interrog\u00e9 p\u00e9riodiquement). temperature : The internal temperature reported by the driver. This field will be null if the driver is not enabled or if the driver does not support temperature reporting. run_current : le courant de fonctionnement actuellement d\u00e9fini. hold_current : Le courant de maintien actuellement d\u00e9fini.","title":"Pilotes TMC"},{"location":"Status_Reference.html#toolhead","text":"Les informations suivantes sont disponibles dans l'objet toolhead (cet objet est toujours disponible) : position : la derni\u00e8re position command\u00e9e de la t\u00eate d'outil par rapport au syst\u00e8me de coordonn\u00e9es sp\u00e9cifi\u00e9 dans le fichier de configuration. Il est possible d'acc\u00e9der aux composantes x, y, z et e de cette position (par exemple, position.x ). extruder : le nom de l'extrudeur actuellement actif. Par exemple, dans une macro, on pourrait utiliser printer[printer.toolhead.extruder].target pour obtenir la temp\u00e9rature cible de l'extrudeuse actuelle. homed_axes : les axes consid\u00e9r\u00e9s comme \u00e9tant dans un \u00e9tat \"\u00e0 l'origine\". Il s'agit d'une cha\u00eene contenant un ou plusieurs \"x\", \"y\", \"z\". axis_minimum , axis_maximum : les limites de d\u00e9placement de l'axe (mm) apr\u00e8s la mise \u00e0 l'origine. Il est possible d'acc\u00e9der aux composantes x, y, z de cette valeur limite (par exemple, axis_minimum.x , axis_maximum.z ). Pour les imprimantes Delta, le cone_start_z est la hauteur z maximale au rayon maximal ( printer.toolhead.cone_start_z ). max_velocity , max_accel , max_accel_to_decel , square_corner_velocity : les limites d'impression actuelles en vigueur. Cela peut diff\u00e9rer des param\u00e8tres du fichier de configuration si une commande SET_VELOCITY_LIMIT (ou M204 ) les a modifi\u00e9es au moment de l'ex\u00e9cution. stalls : Le nombre total de fois (depuis le dernier red\u00e9marrage) o\u00f9 l'imprimante a d\u00fb \u00eatre mise en pause parce que la t\u00eate d'outil s'est d\u00e9plac\u00e9e plus vite que les mouvements ne pouvaient \u00eatre lus \u00e0 partir de l'entr\u00e9e G-Code.","title":"toolhead"},{"location":"Status_Reference.html#dual_carriage","text":"The following information is available in dual_carriage on a cartesian, hybrid_corexy or hybrid_corexz robot carriage_0 : The mode of the carriage 0. Possible values are: \"INACTIVE\" and \"PRIMARY\". carriage_1 : The mode of the carriage 1. Possible values are: \"INACTIVE\", \"PRIMARY\", \"COPY\", and \"MIRROR\".","title":"dual_carriage"},{"location":"Status_Reference.html#virtual_sdcard","text":"Les informations suivantes sont disponibles dans l'objet virtual_sdcard : is_active : renvoie True si une impression \u00e0 partir d'un fichier est actuellement active. progress : une estimation de la progression de l'impression actuelle (bas\u00e9e sur la taille et la position du fichier). file_path : un chemin d'acc\u00e8s complet au fichier actuellement charg\u00e9. file_position : la position actuelle (en octets) d'une impression active. file_size : taille (en octets) du fichier actuellement charg\u00e9.","title":"virtual_sdcard"},{"location":"Status_Reference.html#webhooks","text":"Les informations suivantes sont disponibles dans l'objet webhooks (cet objet est toujours disponible) : state : renvoie une cha\u00eene indiquant l'\u00e9tat actuel de Klipper. Les valeurs possibles sont : \"ready\", \"startup\", \"shutdown\", \"error\". state_message : une cha\u00eene donnant un contexte suppl\u00e9mentaire sur l'\u00e9tat actuel de Klipper.","title":"webhooks"},{"location":"Status_Reference.html#z_thermal_adjust","text":"Les informations suivantes sont disponibles dans l'objet z_thermal_adjust (cet objet est disponible si z_thermal_adjust est d\u00e9fini). enabled : renvoie True si le r\u00e9glage est activ\u00e9. temp\u00e9rature : Temp\u00e9rature actuelle (liss\u00e9e) du capteur d\u00e9fini. (en degr\u00e9s Centigrades) measured_min_temp : temp\u00e9rature minimale mesur\u00e9e. (en degr\u00e9s Centigrades) measured_max_temp : temp\u00e9rature maximale mesur\u00e9e. (En degr\u00e9s Centigrades) current_z_adjust : dernier ajustement Z calcul\u00e9 (en mm). z_adjust_ref_temperature : Temp\u00e9rature de r\u00e9f\u00e9rence actuelle utilis\u00e9e pour le calcul de Z current_z_adjust (En degr\u00e9s Centigrades).","title":"z_thermal_adjust"},{"location":"Status_Reference.html#z_tilt","text":"Les informations suivantes sont disponibles dans l'objet z_tilt (cet objet est disponible si z_tilt est d\u00e9fini) : applied : Vrai si le processus de mise \u00e0 niveau z-tilt a \u00e9t\u00e9 ex\u00e9cut\u00e9 et termin\u00e9 avec succ\u00e8s.","title":"z_tilt"},{"location":"TMC_Drivers.html","text":"Pilotes de moteur pas \u00e0 pas TMC \u00b6 Ce document fournit des informations sur l'utilisation des pilotes de moteur pas \u00e0 pas Trinamic en mode SPI/UART sur Klipper. Klipper peut \u00e9galement utiliser les pilotes Trinamic dans leur \"mode autonome\". Cependant, lorsque les pilotes sont dans ce mode, aucune configuration sp\u00e9ciale de Klipper n'est n\u00e9cessaire et les fonctionnalit\u00e9s avanc\u00e9es de Klipper d\u00e9crites dans ce document ne sont pas disponibles. En plus de ce document, veillez \u00e0 consulter la r\u00e9f\u00e9rence de configuration du pilote TMC . R\u00e9glage du courant du moteur \u00b6 Un courant de commande plus \u00e9lev\u00e9 augmente la pr\u00e9cision de positionnement et le couple. Cependant, un courant plus \u00e9lev\u00e9 augmente \u00e9galement la chaleur produite par le moteur pas \u00e0 pas et le pilote du moteur pas \u00e0 pas. Si le pilote du moteur pas \u00e0 pas devient trop chaud, il se d\u00e9sactivera et Klipper signalera une erreur. Si le moteur pas \u00e0 pas devient trop chaud, il perd du couple et de la pr\u00e9cision de positionnement. (S'il devient tr\u00e8s chaud, il peut \u00e9galement faire fondre les pi\u00e8ces en plastique qui y sont attach\u00e9es ou \u00e0 proximit\u00e9.) Comme conseil de r\u00e9glage g\u00e9n\u00e9ral : pr\u00e9f\u00e9rez des valeurs de courant plus \u00e9lev\u00e9es tant que le moteur pas \u00e0 pas ne chauffe pas trop et que le pilote du moteur pas \u00e0 pas ne signale pas d'avertissements ou d'erreurs. En g\u00e9n\u00e9ral, il est normal que le moteur pas \u00e0 pas soit chaud, mais il ne doit pas devenir si chaud qu'il soit douloureux au toucher. Ne sp\u00e9cifiez pas de hold_current \u00b6 Si l'on configure un hold_current , le pilote TMC peut r\u00e9duire le courant vers le moteur pas \u00e0 pas lorsqu'il d\u00e9tecte que le moteur pas \u00e0 pas ne bouge pas. Cependant, la modification du courant du moteur peut elle-m\u00eame introduire un mouvement du moteur. Cela peut se produire en raison de \"forces de d\u00e9tente\" dans le moteur pas \u00e0 pas (l'aimant permanent du rotor tire vers les dents en fer du stator) ou en raison de forces externes sur le chariot d'axe. La plupart des moteurs pas \u00e0 pas ne fonctionneront pas mieux en r\u00e9duisant le courant pendant les impressions normales, car peu de mouvements d'impression laisseront un moteur pas \u00e0 pas inactif suffisamment longtemps pour activer la fonction hold_current . Et, il est peu probable que l'on veuille introduire des artefacts d'impression dans les quelques mouvements d'impression qui laissent un stepper inactif suffisamment longtemps. Si l'on souhaite r\u00e9duire le courant vers les moteurs pendant les routines de d\u00e9marrage d'impression, envisagez d'\u00e9mettre des commandes SET_TMC_CURRENT dans une MACRO START_PRINT pour ajuster le courant avant et apr\u00e8s les mouvements d'impression normaux. Certaines imprimantes avec des moteurs Z d\u00e9di\u00e9s qui sont inactifs pendant les mouvements d'impression normaux (pas de bed_mesh, pas de bed_tilt, pas de Z skew_correction, pas d'impressions en \"mode vase\", etc.) peuvent constater que les moteurs Z fonctionnent plus froid avec un hold_current . Si vous l'impl\u00e9mentez, assurez-vous de prendre en compte ce type de mouvement non command\u00e9 de l'axe Z pendant le nivellement du lit, le sondage du lit, l'\u00e9talonnage de la sonde, etc. Le driver_TPOWERDOWN et le driver_IHOLDDELAY doivent \u00e9galement \u00eatre calibr\u00e9s en cons\u00e9quence. En cas de doute, pr\u00e9f\u00e9rez ne pas sp\u00e9cifier de hold_current . R\u00e9glage du mode \"spreadCycle\" vs \"stealthChop\" \u00b6 Par d\u00e9faut, Klipper place les pilotes TMC en mode \"spreadCycle\". Si le pilote prend en charge \"stealthChop\", il peut \u00eatre activ\u00e9 en ajoutant stealthchop_threshold : 999999 \u00e0 la section de configuration TMC. Le mode spreadCycle fournit un couple sup\u00e9rieur et une plus grande pr\u00e9cision de positionnement que le mode stealthChop. Cependant, le mode StealthChop peut produire un bruit audible nettement plus faible sur certaines imprimantes. Les tests comparant les modes ont montr\u00e9 un \"d\u00e9calage de position\" accru d'environ 75 % d'un pas complet lors de mouvements \u00e0 vitesse constante lors de l'utilisation du mode StealthChop (par exemple, sur une imprimante avec une distance de rotation de 40 mm et 200 pas_par_rotation, l'\u00e9cart de position des mouvements \u00e0 vitesse constante a augment\u00e9 de ~0,150 mm). Cependant, ce \"retard dans l'obtention de la position demand\u00e9e\" peut ne pas se manifester par un d\u00e9faut d'impression significatif et on peut pr\u00e9f\u00e9rer le comportement plus silencieux du mode StealthChop. Il est recommand\u00e9 de toujours utiliser le mode \"spreadCycle\" (en ne sp\u00e9cifiant pas stealthchop_threshold ) ou de toujours utiliser le mode \"stealthChop\" (en r\u00e9glant stealthchop_threshold sur 999999). Malheureusement, les pilotes produisent souvent des r\u00e9sultats m\u00e9diocres et erron\u00e9s si le mode est chang\u00e9 alors que le moteur tourne. Le r\u00e9glage d'interpolation TMC introduit un petit \u00e9cart de position \u00b6 Le param\u00e8tre interpolation du pilote TMC peut r\u00e9duire le bruit audible du mouvement de l'imprimante au prix de l'introduction d'une petite erreur de position syst\u00e9mique. Cette erreur de position syst\u00e9mique r\u00e9sulte du retard du conducteur \u00e0 ex\u00e9cuter les \"\u00e9tapes\" que Klipper lui envoie. Pendant les d\u00e9placements \u00e0 vitesse constante, ce retard entra\u00eene une erreur de position de pr\u00e8s d'un demi-micropas configur\u00e9 (plus pr\u00e9cis\u00e9ment, l'erreur est d'une demi-distance de micropas moins un 512e de distance d'un pas complet). Par exemple, sur un axe avec une rotation_distance de 40 mm, 200 pas_par_rotation et 16 micropas, l'erreur syst\u00e9mique introduite lors des mouvements \u00e0 vitesse constante est d'environ 0,006 mm. Pour une meilleure pr\u00e9cision de positionnement, envisagez d'utiliser le mode spreadCycle et d\u00e9sactivez l'interpolation (d\u00e9finissez interpolate : False dans la configuration du pilote TMC). Lorsqu'il est configur\u00e9 de cette fa\u00e7on, on peut augmenter le param\u00e8tre microstep pour r\u00e9duire le bruit audible pendant le mouvement pas \u00e0 pas. En r\u00e8gle g\u00e9n\u00e9rale, un r\u00e9glage de micropas de 64 ou 128 aura un bruit audible similaire \u00e0 celui de l'interpolation, et ce, sans introduire d'erreur de position syst\u00e9mique. Si vous utilisez le mode StealthChop, l'impr\u00e9cision de position due \u00e0 l'interpolation est faible par rapport \u00e0 l'impr\u00e9cision de position introduite \u00e0 partir du mode StealthChop. Par cons\u00e9quent, le r\u00e9glage de l'interpolation n'est pas consid\u00e9r\u00e9e comme utile en mode StealthChop, et on peut laisser l'interpolation dans son \u00e9tat par d\u00e9faut. Mise \u00e0 l'origine sans capteur(s) \u00b6 La mise \u00e0 l'origine ans capteur permet de r\u00e9f\u00e9rencer un axe sans avoir besoin d'une fin de course physique. Au lieu de cela, le chariot sur l'axe est d\u00e9plac\u00e9 dans la limite m\u00e9canique, ce qui fait perdre des pas au moteur pas \u00e0 pas. Le pilote pas \u00e0 pas d\u00e9tecte les pas perdus et l'indique au MCU de contr\u00f4le (Klipper) en basculant une broche. Cette information peut \u00eatre utilis\u00e9e par Klipper comme fin de course pour l'axe. Ce guide couvre la configuration de la mise \u00e0 l'origine sans capteur pour l'axe X de votre imprimante (cart\u00e9sienne). Cependant, cela fonctionne de la m\u00eame mani\u00e8re avec tous les autres axes (qui n\u00e9cessitent une but\u00e9e fin de course). Vous devez le configurer et le r\u00e9gler pour un seul axe \u00e0 la fois. Limites \u00b6 Assurez-vous que vos composants m\u00e9caniques sont capables de supporter la charge du chariot heurtant \u00e0 plusieurs reprises la fin de course de l'axe. Les vis sans fin, en particulier, peuvent g\u00e9n\u00e9rer une force importante. La prise d'origine d'un axe Z en \u00e9crasant la buse dans la surface d'impression n'est peut-\u00eatre pas une bonne id\u00e9e. Pour de meilleurs r\u00e9sultats, v\u00e9rifiez que le chariot de l'axe \u00e9tablit un contact franc lors de la mise \u00e0 l'origine. De plus, la mise \u00e0 l'origine sans capteur peut ne pas \u00eatre suffisamment pr\u00e9cise pour votre imprimante. Bien que la mise \u00e0 l'origine des axes X et Y sur une machine cart\u00e9sienne puisse bien fonctionner, la prise d'origine de l'axe Z n'est g\u00e9n\u00e9ralement pas assez pr\u00e9cise et peut entra\u00eener une hauteur de premi\u00e8re couche incoh\u00e9rente. Le r\u00e9f\u00e9rencement d'une imprimante delta sans capteur n'est pas conseill\u00e9 en raison du manque de pr\u00e9cision. En outre, la d\u00e9tection de d\u00e9crochage du pilote pas \u00e0 pas d\u00e9pend de la charge m\u00e9canique sur le moteur, du courant du moteur et de la temp\u00e9rature du moteur (r\u00e9sistance de la bobine). La mise \u00e0 l'origine sans capteur fonctionne mieux \u00e0 des vitesses de moteur moyennes. Pour des vitesses tr\u00e8s lentes (moins de 10 tr/min), le moteur ne g\u00e9n\u00e8re pas de force contre-\u00e9lectromotrice significative et le TMC ne peut pas d\u00e9tecter de mani\u00e8re fiable les calages du moteur. A des vitesses tr\u00e8s \u00e9lev\u00e9es, la force contre-\u00e9lectromotrice du moteur se rapproche de la tension d'alimentation du moteur, de sorte que le TMC ne peut plus d\u00e9tecter les calages. Il est conseill\u00e9 de consulter la fiche technique de vos TMC sp\u00e9cifiques. Vous y trouverez \u00e9galement plus de d\u00e9tails sur les limites de cette configuration. Conditions pr\u00e9alables \u00b6 Quelques pr\u00e9requis sont n\u00e9cessaires pour utiliser la mise \u00e0 l'origine sans capteur : Un pilote pas \u00e0 pas TMC compatible stallGuard (tmc2130, tmc2209, tmc2660 ou tmc5160). Interface SPI/UART du driver TMC c\u00e2bl\u00e9 au micro-contr\u00f4leur (le mode autonome ne fonctionne pas). La broche \"DIAG\" ou \"SG_TST\" appropri\u00e9e du pilote TMC doit \u00eatre connect\u00e9e au microcontr\u00f4leur. Les \u00e9tapes du document v\u00e9rification de la configuration doivent \u00eatre ex\u00e9cut\u00e9es pour confirmer que les moteurs pas \u00e0 pas sont configur\u00e9s et fonctionnent correctement. R\u00e9glages \u00b6 La proc\u00e9dure d\u00e9crite ici comporte six \u00e9tapes principales : Choisissez une vitesse de mise \u00e0 l'origine. Configurez le fichier printer.cfg pour activer la mise \u00e0 l'origine sans capteur. Trouvez le meilleur r\u00e9glage anti-d\u00e9crochage avec la sensibilit\u00e9 la plus \u00e9lev\u00e9e. Trouvez le r\u00e9glage anti-d\u00e9crochage avec la sensibilit\u00e9 la plus faible qui fonctionne avec une seule touche en fin de course. Mettez \u00e0 jour le fichier printer.cfg avec le param\u00e8tre anti-d\u00e9crochage souhait\u00e9. Cr\u00e9ez ou mettez \u00e0 jour les macros dans printer.cfg pour une mise \u00e0 l'origine r\u00e9p\u00e9table. Choisir la vitesse de prise d'origine \u00b6 La vitesse de mise \u00e0 l'origine est importante lors de la r\u00e9alisation d'une mise \u00e0 l'origine sans capteur. Il est souhaitable d'utiliser une vitesse de prise d'origine lente afin que le chariot n'exerce pas de force excessive sur le ch\u00e2ssis lorsqu'il entre en contact avec l'extr\u00e9mit\u00e9 du rail. Cependant, les pilotes TMC ne peuvent pas d\u00e9tecter de mani\u00e8re fiable un d\u00e9crochage \u00e0 des vitesses tr\u00e8s lentes. Un bon point de d\u00e9part pour la vitesse de prise d'origine est que le moteur pas \u00e0 pas effectue une rotation compl\u00e8te toutes les deux secondes. Pour de nombreux axes, ce sera la distance rotation_distance divis\u00e9e par deux. Par example\u202f: [stepper_x] rotation_distance: 40 homing_speed: 20 ... Configurer 'printer.cfg' pour une mise \u00e0 l'origine sans capteur \u00b6 Le param\u00e8tre homing_retract_dist doit \u00eatre d\u00e9fini sur z\u00e9ro dans la section de configuration stepper_x pour d\u00e9sactiver le deuxi\u00e8me mouvement de mise \u00e0 l'origine. La deuxi\u00e8me tentative de mise \u00e0 l'origine n'ajoute pas de valeur lors de l'utilisation d'une mise \u00e0 l'origine sans capteur, elle ne fonctionnera pas de mani\u00e8re fiable et introduira des erreurs dans le processus de r\u00e9glage. Assurez-vous que le param\u00e8tre hold_current n\u2019est pas sp\u00e9cifi\u00e9 dans la section Pilote TMC de la configuration. (Si un hold_current est r\u00e9gl\u00e9, le moteur s\u2019arr\u00eate lorsque le chariot est appuy\u00e9 contre l\u2019extr\u00e9mit\u00e9 du rail, et la r\u00e9duction du courant dans cette position peut entra\u00eener le d\u00e9placement du chariot - ce qui entra\u00eenera de mauvaises performances et perturbera le processus de r\u00e9glage.) Il est n\u00e9cessaire de configurer les broches du TMC pour le mode sans capteur et de configurer les param\u00e8tres initiaux de \u00ab Stallguard \u00bb. Un exemple de configuration tmc2209 pour un axe X pourrait ressembler \u00e0 : [tmc2209 stepper_x] diag_pin: ^PA1 # D\u00e9finit pour le MCU, la broche TMC DIAG driver_SGTHRS: 255 # 255 est la valeur la plus sensible, 0 la moins sensible ... [stepper_x] endstop_pin: tmc2209_stepper_x:virtual_endstop homing_retract_dist: 0 ... Un exemple de configuration de tmc2130 ou tmc5160 pourrait ressembler \u00e0 : [tmc2130 stepper_x] diag1_pin: ^!PA1 # Broche connect\u00e9e \u00e0 TMC DIAG1 (ou utilisez diag0_pin / DIAG0 pin) driver_SGT: -64 # -64 est la valeur la plus sensible, 63 est moins sensible ... [stepper_x] endstop_pin: tmc2130_stepper_x:virtual_endstop homing_retract_dist: 0 ... Un exemple de configuration de tmc2660 pourrait ressembler \u00e0 : [tmc2660 stepper_x] driver_SGT: -64 # -64 est la valeur la plus sensible,, 63 est moins sensible ... [stepper_x] endstop_pin: ^PA1 # Broche connect\u00e9e \u00e0 TMC SG_TST homing_retract_dist: 0 ... Les exemples ci-dessus ne montrent que les param\u00e8tres sp\u00e9cifiques \u00e0 la mise \u00e0 l'origine sans capteur. Voir la r\u00e9f\u00e9rence de configuration pour toutes les options disponibles. Trouvez la sensibilit\u00e9 la plus \u00e9lev\u00e9e qui fonctionne avec succ\u00e8s \u00b6 Placez le chariot pr\u00e8s du centre du rail. Utilisez la commande SET_TMC_FIELD pour d\u00e9finir la sensibilit\u00e9 la plus \u00e9lev\u00e9e. Pour un tmc2209 : SET_TMC_FIELD STEPPER=stepper_x FIELD=SGTHRS VALUE=255 Pour un tmc2130, tmc5160 et tmc2660 : SET_TMC_FIELD STEPPER=stepper_x FIELD=sgt VALUE=-64 \u00c9mettez ensuite une commande G28 X0 et v\u00e9rifiez que l'axe ne bouge pas du tout ou s'arr\u00eate rapidement. Si l'axe ne s'arr\u00eate pas, \u00e9mettez un M112 pour arr\u00eater l'imprimante - quelque chose n'est pas correct avec le c\u00e2blage ou la configuration de la broche diag/sg_tst et ce doit \u00eatre corrig\u00e9 avant de continuer. Ensuite, diminuez continuellement la sensibilit\u00e9 du param\u00e8tre VALUE et ex\u00e9cutez \u00e0 nouveau les commandes SET_TMC_FIELD G28 X0 pour trouver la sensibilit\u00e9 la plus \u00e9lev\u00e9e qui permet au chariot de se d\u00e9placer et de s'arr\u00eater en but\u00e9e. (Pour les pilotes tmc2209, cela diminuera SGTHRS, pour les autres pilotes, cela augmentera sgt.). Il devrait \u00eatre possible de trouver la sensibilit\u00e9 la plus \u00e9lev\u00e9e et fiable (les r\u00e9glages avec une sensibilit\u00e9 plus \u00e9lev\u00e9e entra\u00eenant peu ou pas de mouvement). Notez la valeur trouv\u00e9e comme maximum_sensitivity . (Si la sensibilit\u00e9 minimale possible (SGTHRS = 0 ou sgt = 63) est obtenue sans aucun mouvement du chariot, alors quelque chose ne fonctionne pas aun niveau c\u00e2blage ou configuration de la broche diag/sg_tst et il faut corriger le probl\u00e8me avant de continuer.) Lors de la recherche de maximum_sensitivity, il peut \u00eatre pratique de passer \u00e0 diff\u00e9rents param\u00e8tres VALUE (travaillez le param\u00e8tre VALUE par dichotomie pour plus d'efficacit\u00e9). Si vous proc\u00e9dez ainsi, pr\u00e9parez-vous \u00e0 \u00e9mettre une commande M112 pour arr\u00eater l'imprimante, car un r\u00e9glage avec une sensibilit\u00e9 trop faible peut entra\u00eener un \"cognement\" r\u00e9p\u00e9t\u00e9 de l'axe contre l'extr\u00e9mit\u00e9 du rail. Assurez-vous d'attendre quelques secondes entre chaque tentative de prise d'origine. Une fois que le pilote TMC a d\u00e9tect\u00e9 un d\u00e9crochage, il peut lui falloir un peu de temps pour effacer son indicateur interne et \u00eatre capable de d\u00e9tecter un autre d\u00e9crochage. Au cours de ces tests de r\u00e9glage, si une commande G28 X0 ne se d\u00e9place pas jusqu'\u00e0 la limite d'axe, soyez prudent lorsque vous ex\u00e9cutez des commandes de mouvement 'normales' (par exemple, G1 ). Klipper ne sachant pas ou est le chariot, une commande de d\u00e9placement pourra entra\u00eener des r\u00e9sultats ind\u00e9sirables. Trouver la sensibilit\u00e9 la plus basse qui permette la mise \u00e0 l'origine en une seule fois \u00b6 Lors de la mise \u00e0 l'origine avec la valeur maximum_sensitivity , l'axe doit se d\u00e9placer jusqu'\u00e0 l'extr\u00e9mit\u00e9 du rail et s'arr\u00eater avec un \u00ab simple toucher \u00bb - c'est-\u00e0-dire qu'il ne doit pas y avoir de \u00ab clic \u00bb ou de \u00ab claquement \u00bb. (S'il y a un bruit de claquement ou de clic \u00e0 la sensibilit\u00e9 maximale, la vitesse de mise \u00e0 l'origine est peut-\u00eatre trop faible, le courant du pilote peut \u00eatre trop faible ou la mise \u00e0 l'origine sans capteur n'est peut-\u00eatre pas un bon choix pour cet axe.) L'\u00e9tape suivante consiste \u00e0 nouveau \u00e0 d\u00e9placer le chariot vers une position proche du centre du rail, \u00e0 diminuer la sensibilit\u00e9 et \u00e0 ex\u00e9cuter les commandes SET_TMC_FIELD G28 X0 - l'objectif est maintenant de trouver la sensibilit\u00e9 la plus faible qui permette au chariot de se mettre \u00e0 l'origine correctement avec une \"simple touche\". C'est-\u00e0-dire qu'il ne \"cogne\" pas ou ne \"clique\" pas lorsqu'il entre en contact avec l'extr\u00e9mit\u00e9 du rail. Notez la valeur trouv\u00e9e comme minimum_sensitivity . Mettez \u00e0 jour printer.cfg avec la valeur de sensibilit\u00e9 \u00b6 Apr\u00e8s avoir trouv\u00e9 maximum_sensitivity et minimum_sensitivity , utilisez une calculatrice pour obtenir la sensibilit\u00e9 recommand\u00e9e : minimum_sensitivity + (maximum_sensitivity - minimum_sensitivity)/3 . La sensibilit\u00e9 recommand\u00e9e doit \u00eatre comprise entre le minimum et le maximum, mais l\u00e9g\u00e8rement plus proche du minimum. Arrondissez la valeur finale \u00e0 la valeur enti\u00e8re la plus proche. Pour un tmc2209, d\u00e9finissez-le dans la configuration en tant que driver_SGTHRS , pour les autres pilotes TMC, d\u00e9finissez-le dans la configuration en tant que driver_SGT . Si la plage entre maximum_sensitivity et minimum_sensitivity est petite (par exemple, inf\u00e9rieure \u00e0 5), cela peut entra\u00eener une mise \u00e0 l'origine instable. Une vitesse de mise \u00e0 l'origine plus rapide peut rendre l'op\u00e9ration plus stable. Notez que si une modification est apport\u00e9e au courant du pilote, \u00e0 la vitesse de prise d'origine ou si une modification notable est apport\u00e9e au mat\u00e9riel de l'imprimante, il sera alors n\u00e9cessaire de refaire le processus de r\u00e9glage. Utilisation de macros lors de la mise \u00e0 l'origine \u00b6 Une fois la mise \u00e0 l'origine sans capteur termin\u00e9e, le chariot sera appuy\u00e9 contre l'extr\u00e9mit\u00e9 du rail et le stepper exercera une force sur le cadre tant que le chariot ne sera pas \u00e9loign\u00e9 de la fin de course. Il est pr\u00e9f\u00e9rable de cr\u00e9er une macro pour positionner l'axe en but\u00e9e et l'\u00e9loigner imm\u00e9diatement de l'extr\u00e9mit\u00e9 du rail. Il est pr\u00e9f\u00e9rable, dans la macro, de faire une pause d'au moins 2 secondes avant de commencer la prise d'origine sans capteur (ou de s'assurer qu'il n'y a eu aucun mouvement sur le moteur pas \u00e0 pas depuis au moins 2 secondes). Sans d\u00e9lai, il est possible que le drapeau de d\u00e9crochage interne du pilote de moteur pas \u00e0 pas soit toujours activ\u00e9 suite \u00e0 un mouvement pr\u00e9c\u00e9dent. Il peut \u00e9galement \u00eatre utile que cette macro d\u00e9finisse le courant du pilote avant la prise d'origine et d\u00e9finisse un nouveau courant apr\u00e8s que le chariot s'est \u00e9loign\u00e9. Un exemple de macro pourrait ressembler \u00e0 : [gcode_macro SENSORLESS_HOME_X] gcode: {% set HOME_CUR = 0.700 %} {% set driver_config = printer.configfile.settings['tmc2209 stepper_x'] %} {% set RUN_CUR = driver_config.run_current %} # D\u00e9finir le courant pour la mise \u00e0 l'origine sans capteur SET_TMC_CURRENT STEPPER=stepper_x CURRENT={HOME_CUR} # Petit pause pour attendre que le drapeau stall flag soit d\u00e9sactiv\u00e9 G4 P2000 # mise \u00e0 l'origine G28 X0 # D\u00e9placement G90 G1 X5 F1200 # Remise du courant d'impression SET_TMC_CURRENT STEPPER=stepper_x CURRENT={RUN_CUR} La macro peut \u00eatre appel\u00e9e depuis une section de configuration homing_override ou depuis une macro START_PRINT . Notez que si le courant du pilote pas \u00e0 pas lors de la mise \u00e0 l'origine est modifi\u00e9, le processus de r\u00e9glage doit \u00eatre enti\u00e8rement refait. Conseils pour la mise \u00e0 l'origine sans capteur sur CoreXY \u00b6 Il est possible d'utiliser la mise \u00e0 l'origine sans capteur sur les chariots X et Y d'une imprimante CoreXY. Klipper utilise le stepper [stepper_x] pour d\u00e9tecter les d\u00e9crochages lors de la mise \u00e0 l'origine du chariot X et utilise le stepper [stepper_y] pour d\u00e9tecter les d\u00e9crochages lors de la mise \u00e0 l'origine du chariot Y. Utilisez le guide de r\u00e9glage d\u00e9crit ci-dessus pour trouver la \"sensibilit\u00e9 au d\u00e9crochage\" appropri\u00e9e pour chaque chariot, mais soyez conscient des restrictions suivantes : Lors de l'utilisation de la prise d'origine sans capteur sur CoreXY, assurez-vous qu'aucun hold_current n'est configur\u00e9 pour l'un ou l'autre des moteurs pas \u00e0 pas. Pendant le r\u00e9glage, assurez-vous que les chariots X et Y sont proches du centre de leurs rails avant chaque tentative de mise \u00e0 l'origine. Une fois les r\u00e9glages termin\u00e9s, lors de la prise d'origine de X et Y, utilisez des macros pour vous assurer qu'un axe est pris en charge en premier, puis \u00e9loignez ce chariot de la fin de course de l'axe, faites une pause d'au moins 2 secondes, puis d\u00e9marrez la prise d'origine de l'autre axe. L'\u00e9loignement de l'axe \u00e9vite le r\u00e9f\u00e9rencement d'un axe alors que l'autre est plaqu\u00e9 contre la fin de course (ce qui peut fausser la d\u00e9tection de d\u00e9crochage). La pause est n\u00e9cessaire pour s'assurer que le drapeau de d\u00e9crochage du pilote pas \u00e0 pas est effac\u00e9 avant de se d\u00e9placer \u00e0 nouveau. Un exemple de macro de r\u00e9f\u00e9rencement CoreXY pourrait ressembler \u00e0 : [gcode_macro HOME] gcode: G90 # mise \u00e0 l'origine Z G28 Z0 G1 Z10 F1200 # mise \u00e0 l'origine Y G28 Y0 G1 Y5 F1200 # mise \u00e0 l'origine X G4 P2000 G28 X0 G1 X5 F1200 Interroger et diagnostiquer les informations du pilote pas \u00e0 pas \u00b6 La ` commande DUMP_TMC est un outil utile lors de la configuration et du diagnostic des pilotes. Il signalera tous les champs configur\u00e9s par Klipper ainsi que tous les champs pouvant \u00eatre interrog\u00e9s \u00e0 partir du pilote. Tous les champs signal\u00e9s sont d\u00e9finis dans la fiche technique de Trinamic pour chaque pilote. Ces fiches techniques sont disponibles sur le site Internet de Trinamic . Obtenez et examinez la fiche technique de Trinamic du pilote pas \u00e0 pas afin d'interpr\u00e9ter correctement les r\u00e9sultats d'un DUMP_TMC. Configuration des param\u00e8tres d'un 'driver_XXX' \u00b6 Klipper prend en charge la configuration de nombreux param\u00e8tres de bas niveau pour les pilotes de moteurs pas \u00e0 pas \u00e0 l'aide des param\u00e8tres de la section driver_XXX . La r\u00e9f\u00e9rence de configuration du pilote TMC contient la liste compl\u00e8te des param\u00e8tres disponibles pour chaque type de pilote. De plus, presque tous les champs peuvent \u00eatre modifi\u00e9s au moment de l'ex\u00e9cution \u00e0 l'aide de la commande SET_TMC_FIELD . Chacun de ces param\u00e8tres est d\u00e9fini dans la fiche technique de Trinamic pour chaque pilote. Ces fiches techniques sont disponibles sur le site Internet de Trinamic . Les fiches techniques de Trinamic utilisent parfois une formulation qui peut confondre un param\u00e8tre de haut niveau (tel que \"fin d'hyst\u00e9r\u00e9sis\") avec une valeur de param\u00e8tre de bas niveau (par exemple, \"HEND\"). Dans Klipper, driver_XXX et SET_TMC_FIELD d\u00e9finissent toujours la valeur de param\u00e8tres de bas niveau (celles qui sontt r\u00e9ellement \u00e9crite dans le pilote). Ainsi, par exemple, si la fiche technique Trinamic indique qu'une valeur de 3 doit \u00eatre \u00e9crite dans le champ HEND pour obtenir une \"fin d'hyst\u00e9r\u00e9sis\" de 0, alors d\u00e9finissez driver_HEND=3 pour obtenir une valeur de haut niveau de 0. Questions courantes \u00b6 Puis-je utiliser le mode StealthChop sur une extrudeuse avec avance de pression ? \u00b6 Beaucoup de gens utilisent avec succ\u00e8s le mode \"stealthChop\" avec l'avance de pression de Klipper. Klipper impl\u00e9mente avance de pression \"adoucie\" qui n'introduit aucun changement de vitesse instantan\u00e9. Cependant, le mode \"stealthChop\" peut produire un couple moteur plus faible et/ou produire une chaleur moteur plus \u00e9lev\u00e9e. Il peut s'agir ou non d'un mode utilisable avec votre imprimante. J'ai des erreurs \"Unable to read tmc uart 'stepper_x' register IFCNT\" ? \u00b6 Cela se produit lorsque Klipper est incapable de communiquer avec un pilote tmc2208 ou tmc2209. Assurez-vous que l'alimentation du moteur est activ\u00e9e, car le pilote du moteur pas \u00e0 pas a g\u00e9n\u00e9ralement besoin de l'alimentation du moteur avant de pouvoir communiquer avec le micro-contr\u00f4leur. Si cette erreur se produit apr\u00e8s avoir flash\u00e9 Klipper pour la premi\u00e8re fois, le pilote pas \u00e0 pas peut avoir \u00e9t\u00e9 pr\u00e9c\u00e9demment programm\u00e9 dans un \u00e9tat qui n'est pas compatible avec Klipper. Pour r\u00e9initialiser l'\u00e9tat, coupez toute alimentation de l'imprimante pendant plusieurs secondes (d\u00e9branchez physiquement les prises USB et d'alimentation). Sinon, cette erreur est souvent due \u00e0 un c\u00e2blage incorrect des broche UART ou d'une configuration incorrecte des param\u00e8tres de broche UART dans Klipper. J'ai des erreurs \"Unable to write tmc spi 'stepper_x' register ...\" ? \u00b6 Cela se produit lorsque Klipper est incapable de communiquer avec un pilote tmc2130 ou tmc5160. Assurez-vous que l'alimentation du moteur est activ\u00e9e, car le pilote du moteur pas \u00e0 pas a g\u00e9n\u00e9ralement besoin de l'alimentation du moteur avant de pouvoir communiquer avec le micro-contr\u00f4leur. Cette erreur est souvent due \u00e0 un c\u00e2blage SPI incorrect, \u00e0 une configuration incorrecte des param\u00e8tres SPI de Klipper ou d'une configuration incompl\u00e8te des p\u00e9riph\u00e9riques sur un bus SPI. Si le pilote se trouve sur un bus SPI partag\u00e9 avec plusieurs p\u00e9riph\u00e9riques, assurez-vous de configurer - dans Klipper - chaque p\u00e9riph\u00e9rique sur ce bus SPI. Si un appareil sur un bus SPI partag\u00e9 n'est pas configur\u00e9, il peut r\u00e9pondre de mani\u00e8re incorrecte \u00e0 des commandes qui ne lui sont pas destin\u00e9es et corrompre la communication avec l'appareil pr\u00e9vu. S'il y a un appareil sur un bus SPI partag\u00e9 qui ne peut pas \u00eatre configur\u00e9 dans Klipper, utilisez la section de configuration static_digital_output pour r\u00e9gler la broche CS de l'appareil inutilis\u00e9 \u00e0 un niveau \u00e9lev\u00e9 (afin qu'il n'essaie pas d'utiliser le bus SPI). Le sch\u00e9ma de la carte est une r\u00e9f\u00e9rence utile (ndt et n\u00e9cessaire) pour trouver les p\u00e9riph\u00e9riques qui se trouvent sur un bus SPI et leurs broches associ\u00e9es. Pourquoi ai-je une erreur \"TMC reports error\u202f: ...\"\u202f? \u00b6 Ce type d'erreur indique que le pilote TMC a d\u00e9tect\u00e9 un probl\u00e8me et s'est d\u00e9sactiv\u00e9. C'est-\u00e0-dire que le pilote de moteur pas \u00e0 pas a cess\u00e9 de maintenir sa position et a ignor\u00e9 les commandes de mouvement. Si Klipper d\u00e9tecte qu'un pilote actif s'est d\u00e9sactiv\u00e9, il fera passer l'imprimante dans un \u00e9tat \"arr\u00eat\". Il est \u00e9galement possible qu'un arr\u00eat TMC reports error se produise en raison d'erreurs SPI qui emp\u00eachent la communication avec le pilote (sur les tmc2130, tmc5160 ou tmc2660). Si cela se produit, il est fr\u00e9quent que l'\u00e9tat du pilote indiqu\u00e9 affiche 00000000 ou ffffffff - par exemple : TMC reports error : DRV_STATUS : ffffffff ... OU [ X316X]TMC reports error : READRSP@RDSEL2 : 00000000 ...`. Une telle d\u00e9faillance peut \u00eatre due \u00e0 un probl\u00e8me de c\u00e2blage SPI ou \u00e0 une r\u00e9initialisation automatique ou \u00e0 une d\u00e9faillance du pilote TMC. Quelques erreurs courantes et conseils pour les diagnostiquer : TMC signale une erreur : ... ot=1(OvertempError !) \u00b6 Cela indique que le pilote du moteur s'est d\u00e9sactiv\u00e9 car il est en surchauffe. Les solutions typiques consistent \u00e0 diminuer le courant du pilote de moteur pas \u00e0 pas, \u00e0 augmenter le refroidissement du pilote du moteur pas \u00e0 pas et/ou \u00e0 augmenter le refroidissement du pilote du moteur pas \u00e0 pas. TMC signale une erreur : ... ShortToGND OU ShortToSupply \u00b6 Cela indique que le pilote s'est d\u00e9sactiv\u00e9 car il a d\u00e9tect\u00e9 un courant tr\u00e8s \u00e9lev\u00e9 le traversant. Cela peut indiquer un fil desserr\u00e9 ou court-circuit\u00e9 vers le moteur pas \u00e0 pas ou dans le moteur pas \u00e0 pas lui-m\u00eame. Cette erreur peut \u00e9galement se produire si vous utilisez le mode StealthChop et que le pilote TMC n'est pas en mesure de pr\u00e9dire avec pr\u00e9cision la charge m\u00e9canique du moteur. (Si le pilote fait une mauvaise pr\u00e9diction, il peut envoyer trop de courant \u00e0 travers le moteur et d\u00e9clencher sa propre d\u00e9tection de surintensit\u00e9.) Pour tester cela, d\u00e9sactivez le mode StealthChop et v\u00e9rifiez si les erreurs continuent de se produire. TMC signale une erreur : ... reset=1(Reset) OR CS_ACTUAL=0(Reset ?) OR SE=0(Reset?) \u00b6 Cela indique que le pilote s'est r\u00e9initialis\u00e9 en cours d'impression. Cela peut \u00eatre d\u00fb \u00e0 des probl\u00e8mes de tension ou de c\u00e2blage. TMC signale une erreur : ... uv_cp=1(Sous-tension !) \u00b6 Cela indique que le pilote a d\u00e9tect\u00e9 un \u00e9v\u00e9nement de basse tension et s'est d\u00e9sactiv\u00e9. Cela peut \u00eatre d\u00fb \u00e0 des probl\u00e8mes de c\u00e2blage ou d'alimentation. Comment r\u00e9gler spreadCycle/coolStep/etc. mode sur mes pilotes ? \u00b6 Le site Web de Trinamic contient des guides sur la configuration des pilotes. Ces guides sont souvent techniques, de bas niveau et peuvent n\u00e9cessiter du mat\u00e9riel sp\u00e9cialis\u00e9. Quoi qu'il en soit, ils sont la meilleure source d'information.","title":"Pilotes de moteur pas \u00e0 pas TMC"},{"location":"TMC_Drivers.html#pilotes-de-moteur-pas-a-pas-tmc","text":"Ce document fournit des informations sur l'utilisation des pilotes de moteur pas \u00e0 pas Trinamic en mode SPI/UART sur Klipper. Klipper peut \u00e9galement utiliser les pilotes Trinamic dans leur \"mode autonome\". Cependant, lorsque les pilotes sont dans ce mode, aucune configuration sp\u00e9ciale de Klipper n'est n\u00e9cessaire et les fonctionnalit\u00e9s avanc\u00e9es de Klipper d\u00e9crites dans ce document ne sont pas disponibles. En plus de ce document, veillez \u00e0 consulter la r\u00e9f\u00e9rence de configuration du pilote TMC .","title":"Pilotes de moteur pas \u00e0 pas TMC"},{"location":"TMC_Drivers.html#reglage-du-courant-du-moteur","text":"Un courant de commande plus \u00e9lev\u00e9 augmente la pr\u00e9cision de positionnement et le couple. Cependant, un courant plus \u00e9lev\u00e9 augmente \u00e9galement la chaleur produite par le moteur pas \u00e0 pas et le pilote du moteur pas \u00e0 pas. Si le pilote du moteur pas \u00e0 pas devient trop chaud, il se d\u00e9sactivera et Klipper signalera une erreur. Si le moteur pas \u00e0 pas devient trop chaud, il perd du couple et de la pr\u00e9cision de positionnement. (S'il devient tr\u00e8s chaud, il peut \u00e9galement faire fondre les pi\u00e8ces en plastique qui y sont attach\u00e9es ou \u00e0 proximit\u00e9.) Comme conseil de r\u00e9glage g\u00e9n\u00e9ral : pr\u00e9f\u00e9rez des valeurs de courant plus \u00e9lev\u00e9es tant que le moteur pas \u00e0 pas ne chauffe pas trop et que le pilote du moteur pas \u00e0 pas ne signale pas d'avertissements ou d'erreurs. En g\u00e9n\u00e9ral, il est normal que le moteur pas \u00e0 pas soit chaud, mais il ne doit pas devenir si chaud qu'il soit douloureux au toucher.","title":"R\u00e9glage du courant du moteur"},{"location":"TMC_Drivers.html#ne-specifiez-pas-de-hold_current","text":"Si l'on configure un hold_current , le pilote TMC peut r\u00e9duire le courant vers le moteur pas \u00e0 pas lorsqu'il d\u00e9tecte que le moteur pas \u00e0 pas ne bouge pas. Cependant, la modification du courant du moteur peut elle-m\u00eame introduire un mouvement du moteur. Cela peut se produire en raison de \"forces de d\u00e9tente\" dans le moteur pas \u00e0 pas (l'aimant permanent du rotor tire vers les dents en fer du stator) ou en raison de forces externes sur le chariot d'axe. La plupart des moteurs pas \u00e0 pas ne fonctionneront pas mieux en r\u00e9duisant le courant pendant les impressions normales, car peu de mouvements d'impression laisseront un moteur pas \u00e0 pas inactif suffisamment longtemps pour activer la fonction hold_current . Et, il est peu probable que l'on veuille introduire des artefacts d'impression dans les quelques mouvements d'impression qui laissent un stepper inactif suffisamment longtemps. Si l'on souhaite r\u00e9duire le courant vers les moteurs pendant les routines de d\u00e9marrage d'impression, envisagez d'\u00e9mettre des commandes SET_TMC_CURRENT dans une MACRO START_PRINT pour ajuster le courant avant et apr\u00e8s les mouvements d'impression normaux. Certaines imprimantes avec des moteurs Z d\u00e9di\u00e9s qui sont inactifs pendant les mouvements d'impression normaux (pas de bed_mesh, pas de bed_tilt, pas de Z skew_correction, pas d'impressions en \"mode vase\", etc.) peuvent constater que les moteurs Z fonctionnent plus froid avec un hold_current . Si vous l'impl\u00e9mentez, assurez-vous de prendre en compte ce type de mouvement non command\u00e9 de l'axe Z pendant le nivellement du lit, le sondage du lit, l'\u00e9talonnage de la sonde, etc. Le driver_TPOWERDOWN et le driver_IHOLDDELAY doivent \u00e9galement \u00eatre calibr\u00e9s en cons\u00e9quence. En cas de doute, pr\u00e9f\u00e9rez ne pas sp\u00e9cifier de hold_current .","title":"Ne sp\u00e9cifiez pas de hold_current"},{"location":"TMC_Drivers.html#reglage-du-mode-spreadcycle-vs-stealthchop","text":"Par d\u00e9faut, Klipper place les pilotes TMC en mode \"spreadCycle\". Si le pilote prend en charge \"stealthChop\", il peut \u00eatre activ\u00e9 en ajoutant stealthchop_threshold : 999999 \u00e0 la section de configuration TMC. Le mode spreadCycle fournit un couple sup\u00e9rieur et une plus grande pr\u00e9cision de positionnement que le mode stealthChop. Cependant, le mode StealthChop peut produire un bruit audible nettement plus faible sur certaines imprimantes. Les tests comparant les modes ont montr\u00e9 un \"d\u00e9calage de position\" accru d'environ 75 % d'un pas complet lors de mouvements \u00e0 vitesse constante lors de l'utilisation du mode StealthChop (par exemple, sur une imprimante avec une distance de rotation de 40 mm et 200 pas_par_rotation, l'\u00e9cart de position des mouvements \u00e0 vitesse constante a augment\u00e9 de ~0,150 mm). Cependant, ce \"retard dans l'obtention de la position demand\u00e9e\" peut ne pas se manifester par un d\u00e9faut d'impression significatif et on peut pr\u00e9f\u00e9rer le comportement plus silencieux du mode StealthChop. Il est recommand\u00e9 de toujours utiliser le mode \"spreadCycle\" (en ne sp\u00e9cifiant pas stealthchop_threshold ) ou de toujours utiliser le mode \"stealthChop\" (en r\u00e9glant stealthchop_threshold sur 999999). Malheureusement, les pilotes produisent souvent des r\u00e9sultats m\u00e9diocres et erron\u00e9s si le mode est chang\u00e9 alors que le moteur tourne.","title":"R\u00e9glage du mode \"spreadCycle\" vs \"stealthChop\""},{"location":"TMC_Drivers.html#le-reglage-dinterpolation-tmc-introduit-un-petit-ecart-de-position","text":"Le param\u00e8tre interpolation du pilote TMC peut r\u00e9duire le bruit audible du mouvement de l'imprimante au prix de l'introduction d'une petite erreur de position syst\u00e9mique. Cette erreur de position syst\u00e9mique r\u00e9sulte du retard du conducteur \u00e0 ex\u00e9cuter les \"\u00e9tapes\" que Klipper lui envoie. Pendant les d\u00e9placements \u00e0 vitesse constante, ce retard entra\u00eene une erreur de position de pr\u00e8s d'un demi-micropas configur\u00e9 (plus pr\u00e9cis\u00e9ment, l'erreur est d'une demi-distance de micropas moins un 512e de distance d'un pas complet). Par exemple, sur un axe avec une rotation_distance de 40 mm, 200 pas_par_rotation et 16 micropas, l'erreur syst\u00e9mique introduite lors des mouvements \u00e0 vitesse constante est d'environ 0,006 mm. Pour une meilleure pr\u00e9cision de positionnement, envisagez d'utiliser le mode spreadCycle et d\u00e9sactivez l'interpolation (d\u00e9finissez interpolate : False dans la configuration du pilote TMC). Lorsqu'il est configur\u00e9 de cette fa\u00e7on, on peut augmenter le param\u00e8tre microstep pour r\u00e9duire le bruit audible pendant le mouvement pas \u00e0 pas. En r\u00e8gle g\u00e9n\u00e9rale, un r\u00e9glage de micropas de 64 ou 128 aura un bruit audible similaire \u00e0 celui de l'interpolation, et ce, sans introduire d'erreur de position syst\u00e9mique. Si vous utilisez le mode StealthChop, l'impr\u00e9cision de position due \u00e0 l'interpolation est faible par rapport \u00e0 l'impr\u00e9cision de position introduite \u00e0 partir du mode StealthChop. Par cons\u00e9quent, le r\u00e9glage de l'interpolation n'est pas consid\u00e9r\u00e9e comme utile en mode StealthChop, et on peut laisser l'interpolation dans son \u00e9tat par d\u00e9faut.","title":"Le r\u00e9glage d'interpolation TMC introduit un petit \u00e9cart de position"},{"location":"TMC_Drivers.html#mise-a-lorigine-sans-capteurs","text":"La mise \u00e0 l'origine ans capteur permet de r\u00e9f\u00e9rencer un axe sans avoir besoin d'une fin de course physique. Au lieu de cela, le chariot sur l'axe est d\u00e9plac\u00e9 dans la limite m\u00e9canique, ce qui fait perdre des pas au moteur pas \u00e0 pas. Le pilote pas \u00e0 pas d\u00e9tecte les pas perdus et l'indique au MCU de contr\u00f4le (Klipper) en basculant une broche. Cette information peut \u00eatre utilis\u00e9e par Klipper comme fin de course pour l'axe. Ce guide couvre la configuration de la mise \u00e0 l'origine sans capteur pour l'axe X de votre imprimante (cart\u00e9sienne). Cependant, cela fonctionne de la m\u00eame mani\u00e8re avec tous les autres axes (qui n\u00e9cessitent une but\u00e9e fin de course). Vous devez le configurer et le r\u00e9gler pour un seul axe \u00e0 la fois.","title":"Mise \u00e0 l'origine sans capteur(s)"},{"location":"TMC_Drivers.html#limites","text":"Assurez-vous que vos composants m\u00e9caniques sont capables de supporter la charge du chariot heurtant \u00e0 plusieurs reprises la fin de course de l'axe. Les vis sans fin, en particulier, peuvent g\u00e9n\u00e9rer une force importante. La prise d'origine d'un axe Z en \u00e9crasant la buse dans la surface d'impression n'est peut-\u00eatre pas une bonne id\u00e9e. Pour de meilleurs r\u00e9sultats, v\u00e9rifiez que le chariot de l'axe \u00e9tablit un contact franc lors de la mise \u00e0 l'origine. De plus, la mise \u00e0 l'origine sans capteur peut ne pas \u00eatre suffisamment pr\u00e9cise pour votre imprimante. Bien que la mise \u00e0 l'origine des axes X et Y sur une machine cart\u00e9sienne puisse bien fonctionner, la prise d'origine de l'axe Z n'est g\u00e9n\u00e9ralement pas assez pr\u00e9cise et peut entra\u00eener une hauteur de premi\u00e8re couche incoh\u00e9rente. Le r\u00e9f\u00e9rencement d'une imprimante delta sans capteur n'est pas conseill\u00e9 en raison du manque de pr\u00e9cision. En outre, la d\u00e9tection de d\u00e9crochage du pilote pas \u00e0 pas d\u00e9pend de la charge m\u00e9canique sur le moteur, du courant du moteur et de la temp\u00e9rature du moteur (r\u00e9sistance de la bobine). La mise \u00e0 l'origine sans capteur fonctionne mieux \u00e0 des vitesses de moteur moyennes. Pour des vitesses tr\u00e8s lentes (moins de 10 tr/min), le moteur ne g\u00e9n\u00e8re pas de force contre-\u00e9lectromotrice significative et le TMC ne peut pas d\u00e9tecter de mani\u00e8re fiable les calages du moteur. A des vitesses tr\u00e8s \u00e9lev\u00e9es, la force contre-\u00e9lectromotrice du moteur se rapproche de la tension d'alimentation du moteur, de sorte que le TMC ne peut plus d\u00e9tecter les calages. Il est conseill\u00e9 de consulter la fiche technique de vos TMC sp\u00e9cifiques. Vous y trouverez \u00e9galement plus de d\u00e9tails sur les limites de cette configuration.","title":"Limites"},{"location":"TMC_Drivers.html#conditions-prealables","text":"Quelques pr\u00e9requis sont n\u00e9cessaires pour utiliser la mise \u00e0 l'origine sans capteur : Un pilote pas \u00e0 pas TMC compatible stallGuard (tmc2130, tmc2209, tmc2660 ou tmc5160). Interface SPI/UART du driver TMC c\u00e2bl\u00e9 au micro-contr\u00f4leur (le mode autonome ne fonctionne pas). La broche \"DIAG\" ou \"SG_TST\" appropri\u00e9e du pilote TMC doit \u00eatre connect\u00e9e au microcontr\u00f4leur. Les \u00e9tapes du document v\u00e9rification de la configuration doivent \u00eatre ex\u00e9cut\u00e9es pour confirmer que les moteurs pas \u00e0 pas sont configur\u00e9s et fonctionnent correctement.","title":"Conditions pr\u00e9alables"},{"location":"TMC_Drivers.html#reglages","text":"La proc\u00e9dure d\u00e9crite ici comporte six \u00e9tapes principales : Choisissez une vitesse de mise \u00e0 l'origine. Configurez le fichier printer.cfg pour activer la mise \u00e0 l'origine sans capteur. Trouvez le meilleur r\u00e9glage anti-d\u00e9crochage avec la sensibilit\u00e9 la plus \u00e9lev\u00e9e. Trouvez le r\u00e9glage anti-d\u00e9crochage avec la sensibilit\u00e9 la plus faible qui fonctionne avec une seule touche en fin de course. Mettez \u00e0 jour le fichier printer.cfg avec le param\u00e8tre anti-d\u00e9crochage souhait\u00e9. Cr\u00e9ez ou mettez \u00e0 jour les macros dans printer.cfg pour une mise \u00e0 l'origine r\u00e9p\u00e9table.","title":"R\u00e9glages"},{"location":"TMC_Drivers.html#choisir-la-vitesse-de-prise-dorigine","text":"La vitesse de mise \u00e0 l'origine est importante lors de la r\u00e9alisation d'une mise \u00e0 l'origine sans capteur. Il est souhaitable d'utiliser une vitesse de prise d'origine lente afin que le chariot n'exerce pas de force excessive sur le ch\u00e2ssis lorsqu'il entre en contact avec l'extr\u00e9mit\u00e9 du rail. Cependant, les pilotes TMC ne peuvent pas d\u00e9tecter de mani\u00e8re fiable un d\u00e9crochage \u00e0 des vitesses tr\u00e8s lentes. Un bon point de d\u00e9part pour la vitesse de prise d'origine est que le moteur pas \u00e0 pas effectue une rotation compl\u00e8te toutes les deux secondes. Pour de nombreux axes, ce sera la distance rotation_distance divis\u00e9e par deux. Par example\u202f: [stepper_x] rotation_distance: 40 homing_speed: 20 ...","title":"Choisir la vitesse de prise d'origine"},{"location":"TMC_Drivers.html#configurer-printercfg-pour-une-mise-a-lorigine-sans-capteur","text":"Le param\u00e8tre homing_retract_dist doit \u00eatre d\u00e9fini sur z\u00e9ro dans la section de configuration stepper_x pour d\u00e9sactiver le deuxi\u00e8me mouvement de mise \u00e0 l'origine. La deuxi\u00e8me tentative de mise \u00e0 l'origine n'ajoute pas de valeur lors de l'utilisation d'une mise \u00e0 l'origine sans capteur, elle ne fonctionnera pas de mani\u00e8re fiable et introduira des erreurs dans le processus de r\u00e9glage. Assurez-vous que le param\u00e8tre hold_current n\u2019est pas sp\u00e9cifi\u00e9 dans la section Pilote TMC de la configuration. (Si un hold_current est r\u00e9gl\u00e9, le moteur s\u2019arr\u00eate lorsque le chariot est appuy\u00e9 contre l\u2019extr\u00e9mit\u00e9 du rail, et la r\u00e9duction du courant dans cette position peut entra\u00eener le d\u00e9placement du chariot - ce qui entra\u00eenera de mauvaises performances et perturbera le processus de r\u00e9glage.) Il est n\u00e9cessaire de configurer les broches du TMC pour le mode sans capteur et de configurer les param\u00e8tres initiaux de \u00ab Stallguard \u00bb. Un exemple de configuration tmc2209 pour un axe X pourrait ressembler \u00e0 : [tmc2209 stepper_x] diag_pin: ^PA1 # D\u00e9finit pour le MCU, la broche TMC DIAG driver_SGTHRS: 255 # 255 est la valeur la plus sensible, 0 la moins sensible ... [stepper_x] endstop_pin: tmc2209_stepper_x:virtual_endstop homing_retract_dist: 0 ... Un exemple de configuration de tmc2130 ou tmc5160 pourrait ressembler \u00e0 : [tmc2130 stepper_x] diag1_pin: ^!PA1 # Broche connect\u00e9e \u00e0 TMC DIAG1 (ou utilisez diag0_pin / DIAG0 pin) driver_SGT: -64 # -64 est la valeur la plus sensible, 63 est moins sensible ... [stepper_x] endstop_pin: tmc2130_stepper_x:virtual_endstop homing_retract_dist: 0 ... Un exemple de configuration de tmc2660 pourrait ressembler \u00e0 : [tmc2660 stepper_x] driver_SGT: -64 # -64 est la valeur la plus sensible,, 63 est moins sensible ... [stepper_x] endstop_pin: ^PA1 # Broche connect\u00e9e \u00e0 TMC SG_TST homing_retract_dist: 0 ... Les exemples ci-dessus ne montrent que les param\u00e8tres sp\u00e9cifiques \u00e0 la mise \u00e0 l'origine sans capteur. Voir la r\u00e9f\u00e9rence de configuration pour toutes les options disponibles.","title":"Configurer 'printer.cfg' pour une mise \u00e0 l'origine sans capteur"},{"location":"TMC_Drivers.html#trouvez-la-sensibilite-la-plus-elevee-qui-fonctionne-avec-succes","text":"Placez le chariot pr\u00e8s du centre du rail. Utilisez la commande SET_TMC_FIELD pour d\u00e9finir la sensibilit\u00e9 la plus \u00e9lev\u00e9e. Pour un tmc2209 : SET_TMC_FIELD STEPPER=stepper_x FIELD=SGTHRS VALUE=255 Pour un tmc2130, tmc5160 et tmc2660 : SET_TMC_FIELD STEPPER=stepper_x FIELD=sgt VALUE=-64 \u00c9mettez ensuite une commande G28 X0 et v\u00e9rifiez que l'axe ne bouge pas du tout ou s'arr\u00eate rapidement. Si l'axe ne s'arr\u00eate pas, \u00e9mettez un M112 pour arr\u00eater l'imprimante - quelque chose n'est pas correct avec le c\u00e2blage ou la configuration de la broche diag/sg_tst et ce doit \u00eatre corrig\u00e9 avant de continuer. Ensuite, diminuez continuellement la sensibilit\u00e9 du param\u00e8tre VALUE et ex\u00e9cutez \u00e0 nouveau les commandes SET_TMC_FIELD G28 X0 pour trouver la sensibilit\u00e9 la plus \u00e9lev\u00e9e qui permet au chariot de se d\u00e9placer et de s'arr\u00eater en but\u00e9e. (Pour les pilotes tmc2209, cela diminuera SGTHRS, pour les autres pilotes, cela augmentera sgt.). Il devrait \u00eatre possible de trouver la sensibilit\u00e9 la plus \u00e9lev\u00e9e et fiable (les r\u00e9glages avec une sensibilit\u00e9 plus \u00e9lev\u00e9e entra\u00eenant peu ou pas de mouvement). Notez la valeur trouv\u00e9e comme maximum_sensitivity . (Si la sensibilit\u00e9 minimale possible (SGTHRS = 0 ou sgt = 63) est obtenue sans aucun mouvement du chariot, alors quelque chose ne fonctionne pas aun niveau c\u00e2blage ou configuration de la broche diag/sg_tst et il faut corriger le probl\u00e8me avant de continuer.) Lors de la recherche de maximum_sensitivity, il peut \u00eatre pratique de passer \u00e0 diff\u00e9rents param\u00e8tres VALUE (travaillez le param\u00e8tre VALUE par dichotomie pour plus d'efficacit\u00e9). Si vous proc\u00e9dez ainsi, pr\u00e9parez-vous \u00e0 \u00e9mettre une commande M112 pour arr\u00eater l'imprimante, car un r\u00e9glage avec une sensibilit\u00e9 trop faible peut entra\u00eener un \"cognement\" r\u00e9p\u00e9t\u00e9 de l'axe contre l'extr\u00e9mit\u00e9 du rail. Assurez-vous d'attendre quelques secondes entre chaque tentative de prise d'origine. Une fois que le pilote TMC a d\u00e9tect\u00e9 un d\u00e9crochage, il peut lui falloir un peu de temps pour effacer son indicateur interne et \u00eatre capable de d\u00e9tecter un autre d\u00e9crochage. Au cours de ces tests de r\u00e9glage, si une commande G28 X0 ne se d\u00e9place pas jusqu'\u00e0 la limite d'axe, soyez prudent lorsque vous ex\u00e9cutez des commandes de mouvement 'normales' (par exemple, G1 ). Klipper ne sachant pas ou est le chariot, une commande de d\u00e9placement pourra entra\u00eener des r\u00e9sultats ind\u00e9sirables.","title":"Trouvez la sensibilit\u00e9 la plus \u00e9lev\u00e9e qui fonctionne avec succ\u00e8s"},{"location":"TMC_Drivers.html#trouver-la-sensibilite-la-plus-basse-qui-permette-la-mise-a-lorigine-en-une-seule-fois","text":"Lors de la mise \u00e0 l'origine avec la valeur maximum_sensitivity , l'axe doit se d\u00e9placer jusqu'\u00e0 l'extr\u00e9mit\u00e9 du rail et s'arr\u00eater avec un \u00ab simple toucher \u00bb - c'est-\u00e0-dire qu'il ne doit pas y avoir de \u00ab clic \u00bb ou de \u00ab claquement \u00bb. (S'il y a un bruit de claquement ou de clic \u00e0 la sensibilit\u00e9 maximale, la vitesse de mise \u00e0 l'origine est peut-\u00eatre trop faible, le courant du pilote peut \u00eatre trop faible ou la mise \u00e0 l'origine sans capteur n'est peut-\u00eatre pas un bon choix pour cet axe.) L'\u00e9tape suivante consiste \u00e0 nouveau \u00e0 d\u00e9placer le chariot vers une position proche du centre du rail, \u00e0 diminuer la sensibilit\u00e9 et \u00e0 ex\u00e9cuter les commandes SET_TMC_FIELD G28 X0 - l'objectif est maintenant de trouver la sensibilit\u00e9 la plus faible qui permette au chariot de se mettre \u00e0 l'origine correctement avec une \"simple touche\". C'est-\u00e0-dire qu'il ne \"cogne\" pas ou ne \"clique\" pas lorsqu'il entre en contact avec l'extr\u00e9mit\u00e9 du rail. Notez la valeur trouv\u00e9e comme minimum_sensitivity .","title":"Trouver la sensibilit\u00e9 la plus basse qui permette la mise \u00e0 l'origine en une seule fois"},{"location":"TMC_Drivers.html#mettez-a-jour-printercfg-avec-la-valeur-de-sensibilite","text":"Apr\u00e8s avoir trouv\u00e9 maximum_sensitivity et minimum_sensitivity , utilisez une calculatrice pour obtenir la sensibilit\u00e9 recommand\u00e9e : minimum_sensitivity + (maximum_sensitivity - minimum_sensitivity)/3 . La sensibilit\u00e9 recommand\u00e9e doit \u00eatre comprise entre le minimum et le maximum, mais l\u00e9g\u00e8rement plus proche du minimum. Arrondissez la valeur finale \u00e0 la valeur enti\u00e8re la plus proche. Pour un tmc2209, d\u00e9finissez-le dans la configuration en tant que driver_SGTHRS , pour les autres pilotes TMC, d\u00e9finissez-le dans la configuration en tant que driver_SGT . Si la plage entre maximum_sensitivity et minimum_sensitivity est petite (par exemple, inf\u00e9rieure \u00e0 5), cela peut entra\u00eener une mise \u00e0 l'origine instable. Une vitesse de mise \u00e0 l'origine plus rapide peut rendre l'op\u00e9ration plus stable. Notez que si une modification est apport\u00e9e au courant du pilote, \u00e0 la vitesse de prise d'origine ou si une modification notable est apport\u00e9e au mat\u00e9riel de l'imprimante, il sera alors n\u00e9cessaire de refaire le processus de r\u00e9glage.","title":"Mettez \u00e0 jour printer.cfg avec la valeur de sensibilit\u00e9"},{"location":"TMC_Drivers.html#utilisation-de-macros-lors-de-la-mise-a-lorigine","text":"Une fois la mise \u00e0 l'origine sans capteur termin\u00e9e, le chariot sera appuy\u00e9 contre l'extr\u00e9mit\u00e9 du rail et le stepper exercera une force sur le cadre tant que le chariot ne sera pas \u00e9loign\u00e9 de la fin de course. Il est pr\u00e9f\u00e9rable de cr\u00e9er une macro pour positionner l'axe en but\u00e9e et l'\u00e9loigner imm\u00e9diatement de l'extr\u00e9mit\u00e9 du rail. Il est pr\u00e9f\u00e9rable, dans la macro, de faire une pause d'au moins 2 secondes avant de commencer la prise d'origine sans capteur (ou de s'assurer qu'il n'y a eu aucun mouvement sur le moteur pas \u00e0 pas depuis au moins 2 secondes). Sans d\u00e9lai, il est possible que le drapeau de d\u00e9crochage interne du pilote de moteur pas \u00e0 pas soit toujours activ\u00e9 suite \u00e0 un mouvement pr\u00e9c\u00e9dent. Il peut \u00e9galement \u00eatre utile que cette macro d\u00e9finisse le courant du pilote avant la prise d'origine et d\u00e9finisse un nouveau courant apr\u00e8s que le chariot s'est \u00e9loign\u00e9. Un exemple de macro pourrait ressembler \u00e0 : [gcode_macro SENSORLESS_HOME_X] gcode: {% set HOME_CUR = 0.700 %} {% set driver_config = printer.configfile.settings['tmc2209 stepper_x'] %} {% set RUN_CUR = driver_config.run_current %} # D\u00e9finir le courant pour la mise \u00e0 l'origine sans capteur SET_TMC_CURRENT STEPPER=stepper_x CURRENT={HOME_CUR} # Petit pause pour attendre que le drapeau stall flag soit d\u00e9sactiv\u00e9 G4 P2000 # mise \u00e0 l'origine G28 X0 # D\u00e9placement G90 G1 X5 F1200 # Remise du courant d'impression SET_TMC_CURRENT STEPPER=stepper_x CURRENT={RUN_CUR} La macro peut \u00eatre appel\u00e9e depuis une section de configuration homing_override ou depuis une macro START_PRINT . Notez que si le courant du pilote pas \u00e0 pas lors de la mise \u00e0 l'origine est modifi\u00e9, le processus de r\u00e9glage doit \u00eatre enti\u00e8rement refait.","title":"Utilisation de macros lors de la mise \u00e0 l'origine"},{"location":"TMC_Drivers.html#conseils-pour-la-mise-a-lorigine-sans-capteur-sur-corexy","text":"Il est possible d'utiliser la mise \u00e0 l'origine sans capteur sur les chariots X et Y d'une imprimante CoreXY. Klipper utilise le stepper [stepper_x] pour d\u00e9tecter les d\u00e9crochages lors de la mise \u00e0 l'origine du chariot X et utilise le stepper [stepper_y] pour d\u00e9tecter les d\u00e9crochages lors de la mise \u00e0 l'origine du chariot Y. Utilisez le guide de r\u00e9glage d\u00e9crit ci-dessus pour trouver la \"sensibilit\u00e9 au d\u00e9crochage\" appropri\u00e9e pour chaque chariot, mais soyez conscient des restrictions suivantes : Lors de l'utilisation de la prise d'origine sans capteur sur CoreXY, assurez-vous qu'aucun hold_current n'est configur\u00e9 pour l'un ou l'autre des moteurs pas \u00e0 pas. Pendant le r\u00e9glage, assurez-vous que les chariots X et Y sont proches du centre de leurs rails avant chaque tentative de mise \u00e0 l'origine. Une fois les r\u00e9glages termin\u00e9s, lors de la prise d'origine de X et Y, utilisez des macros pour vous assurer qu'un axe est pris en charge en premier, puis \u00e9loignez ce chariot de la fin de course de l'axe, faites une pause d'au moins 2 secondes, puis d\u00e9marrez la prise d'origine de l'autre axe. L'\u00e9loignement de l'axe \u00e9vite le r\u00e9f\u00e9rencement d'un axe alors que l'autre est plaqu\u00e9 contre la fin de course (ce qui peut fausser la d\u00e9tection de d\u00e9crochage). La pause est n\u00e9cessaire pour s'assurer que le drapeau de d\u00e9crochage du pilote pas \u00e0 pas est effac\u00e9 avant de se d\u00e9placer \u00e0 nouveau. Un exemple de macro de r\u00e9f\u00e9rencement CoreXY pourrait ressembler \u00e0 : [gcode_macro HOME] gcode: G90 # mise \u00e0 l'origine Z G28 Z0 G1 Z10 F1200 # mise \u00e0 l'origine Y G28 Y0 G1 Y5 F1200 # mise \u00e0 l'origine X G4 P2000 G28 X0 G1 X5 F1200","title":"Conseils pour la mise \u00e0 l'origine sans capteur sur CoreXY"},{"location":"TMC_Drivers.html#interroger-et-diagnostiquer-les-informations-du-pilote-pas-a-pas","text":"La ` commande DUMP_TMC est un outil utile lors de la configuration et du diagnostic des pilotes. Il signalera tous les champs configur\u00e9s par Klipper ainsi que tous les champs pouvant \u00eatre interrog\u00e9s \u00e0 partir du pilote. Tous les champs signal\u00e9s sont d\u00e9finis dans la fiche technique de Trinamic pour chaque pilote. Ces fiches techniques sont disponibles sur le site Internet de Trinamic . Obtenez et examinez la fiche technique de Trinamic du pilote pas \u00e0 pas afin d'interpr\u00e9ter correctement les r\u00e9sultats d'un DUMP_TMC.","title":"Interroger et diagnostiquer les informations du pilote pas \u00e0 pas"},{"location":"TMC_Drivers.html#configuration-des-parametres-dun-driver_xxx","text":"Klipper prend en charge la configuration de nombreux param\u00e8tres de bas niveau pour les pilotes de moteurs pas \u00e0 pas \u00e0 l'aide des param\u00e8tres de la section driver_XXX . La r\u00e9f\u00e9rence de configuration du pilote TMC contient la liste compl\u00e8te des param\u00e8tres disponibles pour chaque type de pilote. De plus, presque tous les champs peuvent \u00eatre modifi\u00e9s au moment de l'ex\u00e9cution \u00e0 l'aide de la commande SET_TMC_FIELD . Chacun de ces param\u00e8tres est d\u00e9fini dans la fiche technique de Trinamic pour chaque pilote. Ces fiches techniques sont disponibles sur le site Internet de Trinamic . Les fiches techniques de Trinamic utilisent parfois une formulation qui peut confondre un param\u00e8tre de haut niveau (tel que \"fin d'hyst\u00e9r\u00e9sis\") avec une valeur de param\u00e8tre de bas niveau (par exemple, \"HEND\"). Dans Klipper, driver_XXX et SET_TMC_FIELD d\u00e9finissent toujours la valeur de param\u00e8tres de bas niveau (celles qui sontt r\u00e9ellement \u00e9crite dans le pilote). Ainsi, par exemple, si la fiche technique Trinamic indique qu'une valeur de 3 doit \u00eatre \u00e9crite dans le champ HEND pour obtenir une \"fin d'hyst\u00e9r\u00e9sis\" de 0, alors d\u00e9finissez driver_HEND=3 pour obtenir une valeur de haut niveau de 0.","title":"Configuration des param\u00e8tres d'un 'driver_XXX'"},{"location":"TMC_Drivers.html#questions-courantes","text":"","title":"Questions courantes"},{"location":"TMC_Drivers.html#puis-je-utiliser-le-mode-stealthchop-sur-une-extrudeuse-avec-avance-de-pression","text":"Beaucoup de gens utilisent avec succ\u00e8s le mode \"stealthChop\" avec l'avance de pression de Klipper. Klipper impl\u00e9mente avance de pression \"adoucie\" qui n'introduit aucun changement de vitesse instantan\u00e9. Cependant, le mode \"stealthChop\" peut produire un couple moteur plus faible et/ou produire une chaleur moteur plus \u00e9lev\u00e9e. Il peut s'agir ou non d'un mode utilisable avec votre imprimante.","title":"Puis-je utiliser le mode StealthChop sur une extrudeuse avec avance de pression\u00a0?"},{"location":"TMC_Drivers.html#jai-des-erreurs-unable-to-read-tmc-uart-stepper_x-register-ifcnt","text":"Cela se produit lorsque Klipper est incapable de communiquer avec un pilote tmc2208 ou tmc2209. Assurez-vous que l'alimentation du moteur est activ\u00e9e, car le pilote du moteur pas \u00e0 pas a g\u00e9n\u00e9ralement besoin de l'alimentation du moteur avant de pouvoir communiquer avec le micro-contr\u00f4leur. Si cette erreur se produit apr\u00e8s avoir flash\u00e9 Klipper pour la premi\u00e8re fois, le pilote pas \u00e0 pas peut avoir \u00e9t\u00e9 pr\u00e9c\u00e9demment programm\u00e9 dans un \u00e9tat qui n'est pas compatible avec Klipper. Pour r\u00e9initialiser l'\u00e9tat, coupez toute alimentation de l'imprimante pendant plusieurs secondes (d\u00e9branchez physiquement les prises USB et d'alimentation). Sinon, cette erreur est souvent due \u00e0 un c\u00e2blage incorrect des broche UART ou d'une configuration incorrecte des param\u00e8tres de broche UART dans Klipper.","title":"J'ai des erreurs \"Unable to read tmc uart 'stepper_x' register IFCNT\" ?"},{"location":"TMC_Drivers.html#jai-des-erreurs-unable-to-write-tmc-spi-stepper_x-register","text":"Cela se produit lorsque Klipper est incapable de communiquer avec un pilote tmc2130 ou tmc5160. Assurez-vous que l'alimentation du moteur est activ\u00e9e, car le pilote du moteur pas \u00e0 pas a g\u00e9n\u00e9ralement besoin de l'alimentation du moteur avant de pouvoir communiquer avec le micro-contr\u00f4leur. Cette erreur est souvent due \u00e0 un c\u00e2blage SPI incorrect, \u00e0 une configuration incorrecte des param\u00e8tres SPI de Klipper ou d'une configuration incompl\u00e8te des p\u00e9riph\u00e9riques sur un bus SPI. Si le pilote se trouve sur un bus SPI partag\u00e9 avec plusieurs p\u00e9riph\u00e9riques, assurez-vous de configurer - dans Klipper - chaque p\u00e9riph\u00e9rique sur ce bus SPI. Si un appareil sur un bus SPI partag\u00e9 n'est pas configur\u00e9, il peut r\u00e9pondre de mani\u00e8re incorrecte \u00e0 des commandes qui ne lui sont pas destin\u00e9es et corrompre la communication avec l'appareil pr\u00e9vu. S'il y a un appareil sur un bus SPI partag\u00e9 qui ne peut pas \u00eatre configur\u00e9 dans Klipper, utilisez la section de configuration static_digital_output pour r\u00e9gler la broche CS de l'appareil inutilis\u00e9 \u00e0 un niveau \u00e9lev\u00e9 (afin qu'il n'essaie pas d'utiliser le bus SPI). Le sch\u00e9ma de la carte est une r\u00e9f\u00e9rence utile (ndt et n\u00e9cessaire) pour trouver les p\u00e9riph\u00e9riques qui se trouvent sur un bus SPI et leurs broches associ\u00e9es.","title":"J'ai des erreurs \"Unable to write tmc spi 'stepper_x' register ...\" ?"},{"location":"TMC_Drivers.html#pourquoi-ai-je-une-erreur-tmc-reports-error","text":"Ce type d'erreur indique que le pilote TMC a d\u00e9tect\u00e9 un probl\u00e8me et s'est d\u00e9sactiv\u00e9. C'est-\u00e0-dire que le pilote de moteur pas \u00e0 pas a cess\u00e9 de maintenir sa position et a ignor\u00e9 les commandes de mouvement. Si Klipper d\u00e9tecte qu'un pilote actif s'est d\u00e9sactiv\u00e9, il fera passer l'imprimante dans un \u00e9tat \"arr\u00eat\". Il est \u00e9galement possible qu'un arr\u00eat TMC reports error se produise en raison d'erreurs SPI qui emp\u00eachent la communication avec le pilote (sur les tmc2130, tmc5160 ou tmc2660). Si cela se produit, il est fr\u00e9quent que l'\u00e9tat du pilote indiqu\u00e9 affiche 00000000 ou ffffffff - par exemple : TMC reports error : DRV_STATUS : ffffffff ... OU [ X316X]TMC reports error : READRSP@RDSEL2 : 00000000 ...`. Une telle d\u00e9faillance peut \u00eatre due \u00e0 un probl\u00e8me de c\u00e2blage SPI ou \u00e0 une r\u00e9initialisation automatique ou \u00e0 une d\u00e9faillance du pilote TMC. Quelques erreurs courantes et conseils pour les diagnostiquer :","title":"Pourquoi ai-je une erreur \"TMC reports error\u202f: ...\"\u202f?"},{"location":"TMC_Drivers.html#tmc-signale-une-erreur-ot1overtemperror","text":"Cela indique que le pilote du moteur s'est d\u00e9sactiv\u00e9 car il est en surchauffe. Les solutions typiques consistent \u00e0 diminuer le courant du pilote de moteur pas \u00e0 pas, \u00e0 augmenter le refroidissement du pilote du moteur pas \u00e0 pas et/ou \u00e0 augmenter le refroidissement du pilote du moteur pas \u00e0 pas.","title":"TMC signale une erreur\u00a0: ... ot=1(OvertempError\u00a0!)"},{"location":"TMC_Drivers.html#tmc-signale-une-erreur-shorttognd-ou-shorttosupply","text":"Cela indique que le pilote s'est d\u00e9sactiv\u00e9 car il a d\u00e9tect\u00e9 un courant tr\u00e8s \u00e9lev\u00e9 le traversant. Cela peut indiquer un fil desserr\u00e9 ou court-circuit\u00e9 vers le moteur pas \u00e0 pas ou dans le moteur pas \u00e0 pas lui-m\u00eame. Cette erreur peut \u00e9galement se produire si vous utilisez le mode StealthChop et que le pilote TMC n'est pas en mesure de pr\u00e9dire avec pr\u00e9cision la charge m\u00e9canique du moteur. (Si le pilote fait une mauvaise pr\u00e9diction, il peut envoyer trop de courant \u00e0 travers le moteur et d\u00e9clencher sa propre d\u00e9tection de surintensit\u00e9.) Pour tester cela, d\u00e9sactivez le mode StealthChop et v\u00e9rifiez si les erreurs continuent de se produire.","title":"TMC signale une erreur\u00a0: ... ShortToGND OU ShortToSupply"},{"location":"TMC_Drivers.html#tmc-signale-une-erreur-reset1reset-or-cs_actual0reset-or-se0reset","text":"Cela indique que le pilote s'est r\u00e9initialis\u00e9 en cours d'impression. Cela peut \u00eatre d\u00fb \u00e0 des probl\u00e8mes de tension ou de c\u00e2blage.","title":"TMC signale une erreur\u00a0: ... reset=1(Reset) OR CS_ACTUAL=0(Reset\u00a0?) OR SE=0(Reset?)"},{"location":"TMC_Drivers.html#tmc-signale-une-erreur-uv_cp1sous-tension","text":"Cela indique que le pilote a d\u00e9tect\u00e9 un \u00e9v\u00e9nement de basse tension et s'est d\u00e9sactiv\u00e9. Cela peut \u00eatre d\u00fb \u00e0 des probl\u00e8mes de c\u00e2blage ou d'alimentation.","title":"TMC signale une erreur\u00a0: ... uv_cp=1(Sous-tension\u00a0!)"},{"location":"TMC_Drivers.html#comment-regler-spreadcyclecoolstepetc-mode-sur-mes-pilotes","text":"Le site Web de Trinamic contient des guides sur la configuration des pilotes. Ces guides sont souvent techniques, de bas niveau et peuvent n\u00e9cessiter du mat\u00e9riel sp\u00e9cialis\u00e9. Quoi qu'il en soit, ils sont la meilleure source d'information.","title":"Comment r\u00e9gler spreadCycle/coolStep/etc. mode sur mes pilotes\u00a0?"},{"location":"TSL1401CL_Filament_Width_Sensor.html","text":"Capteur de largeur de filament TSL1401CL \u00b6 Ce document d\u00e9crit le module h\u00f4te du capteur de largeur de filament. Le mat\u00e9riel utilis\u00e9 pour d\u00e9velopper ce module h\u00f4te est bas\u00e9 sur le r\u00e9seau de capteurs lin\u00e9aires TSL1401CL, mais il peut fonctionner avec n'importe quel autre r\u00e9seau de capteurs ayant une sortie analogique. Vous pouvez trouver des r\u00e9alisations sur Thingiverse . Pour utiliser un r\u00e9seau de capteurs comme capteur de largeur de filament, consultez Config Reference et documentation G-Code . Comment cela fonctionne-t-il ? \u00b6 Le capteur g\u00e9n\u00e8re une sortie analogique bas\u00e9e sur la largeur calcul\u00e9e du filament. La tension de sortie est toujours \u00e9gale \u00e0 la largeur de filament d\u00e9tect\u00e9e (ex. 1,65v, 1,70v, 3,0v). Le module h\u00f4te surveille les changements de tension et ajuste le multiplicateur d'extrusion. Note : \u00b6 Les lectures du capteur sont effectu\u00e9es par d\u00e9faut avec des intervalles de 10 mm. Si n\u00e9cessaire, vous pouvez modifier ce param\u00e8tre en modifiant le param\u00e8tre MEASUREMENT_INTERVAL_MM dans le fichier filament_width_sensor.py .","title":"Capteur de largeur de filament TSL1401CL"},{"location":"TSL1401CL_Filament_Width_Sensor.html#capteur-de-largeur-de-filament-tsl1401cl","text":"Ce document d\u00e9crit le module h\u00f4te du capteur de largeur de filament. Le mat\u00e9riel utilis\u00e9 pour d\u00e9velopper ce module h\u00f4te est bas\u00e9 sur le r\u00e9seau de capteurs lin\u00e9aires TSL1401CL, mais il peut fonctionner avec n'importe quel autre r\u00e9seau de capteurs ayant une sortie analogique. Vous pouvez trouver des r\u00e9alisations sur Thingiverse . Pour utiliser un r\u00e9seau de capteurs comme capteur de largeur de filament, consultez Config Reference et documentation G-Code .","title":"Capteur de largeur de filament TSL1401CL"},{"location":"TSL1401CL_Filament_Width_Sensor.html#comment-cela-fonctionne-t-il","text":"Le capteur g\u00e9n\u00e8re une sortie analogique bas\u00e9e sur la largeur calcul\u00e9e du filament. La tension de sortie est toujours \u00e9gale \u00e0 la largeur de filament d\u00e9tect\u00e9e (ex. 1,65v, 1,70v, 3,0v). Le module h\u00f4te surveille les changements de tension et ajuste le multiplicateur d'extrusion.","title":"Comment cela fonctionne-t-il ?"},{"location":"TSL1401CL_Filament_Width_Sensor.html#note","text":"Les lectures du capteur sont effectu\u00e9es par d\u00e9faut avec des intervalles de 10 mm. Si n\u00e9cessaire, vous pouvez modifier ce param\u00e8tre en modifiant le param\u00e8tre MEASUREMENT_INTERVAL_MM dans le fichier filament_width_sensor.py .","title":"Note :"},{"location":"Using_PWM_Tools.html","text":"Utilisation des outils PWM \u00b6 Ce document d\u00e9crit comment configurer un laser ou une broche contr\u00f4l\u00e9e par PWM en utilisant output_pin et quelques macros. Comment cela fonctionne-t-il ? \u00b6 En r\u00e9-utilisant la sortie pwm du ventilateur de la t\u00eate d'impression, vous pouvez contr\u00f4ler des lasers ou des broches. Ceci est utile si vous utilisez des t\u00eates d'impression commutables, par exemple le changeur d'outils E3D ou une solution DIY. Habituellement, les outils \u00e0 came tels que LaserWeb peuvent \u00eatre configur\u00e9s pour utiliser les commandes M3-M5 , qui correspondent \u00e0 vitesse de broche CW ( M3 S[0-255] ), vitesse de broche CCW ( M4 S[0-255] ) et arr\u00eat de broche ( M5 ). Avertissement : Lorsque vous pilotez un laser, prenez toutes les pr\u00e9cautions de s\u00e9curit\u00e9 auxquelles vous pouvez penser ! Les lasers \u00e0 diodes sont g\u00e9n\u00e9ralement invers\u00e9s. Cela signifie que lorsque l'unit\u00e9 centrale red\u00e9marre, le laser sera compl\u00e8tement allum\u00e9 pendant le temps n\u00e9cessaire \u00e0 l'unit\u00e9 centrale pour red\u00e9marrer. Pour faire bonne mesure, il est recommand\u00e9 de toujours porter des lunettes laser appropri\u00e9es de la bonne longueur d'onde si le laser est aliment\u00e9 ; et de d\u00e9connecter le laser lorsqu'il n'est pas n\u00e9cessaire. Vous devriez \u00e9galement configurer un d\u00e9lai de s\u00e9curit\u00e9, de sorte que lorsque votre h\u00f4te ou votre MCU rencontre une erreur, l'outil s'arr\u00eate. Pour un exemple de configuration, voir config/sample-pwm-tool.cfg . Limites actuelles \u00b6 La fr\u00e9quence des mises \u00e0 jour PWM est limit\u00e9e. Bien qu'elle soit tr\u00e8s pr\u00e9cise, une mise \u00e0 jour PWM ne peut se produire que toutes les 0,1 seconde, ce qui la rend presque inutile pour la gravure tram\u00e9e. Cependant, il existe une branche exp\u00e9rimentale avec ses propres compromis. A long terme, il est pr\u00e9vu d'ajouter cette fonctionnalit\u00e9 au klipper principal. Commandes \u00b6 M3/M4 S<valeur> : D\u00e9finit le cycle de travail PWM. Valeurs comprises entre 0 et 255. M5 : Arr\u00eate la sortie PWM \u00e0 la valeur d'arr\u00eat. Configuration de Laserweb \u00b6 Si vous utilisez Laserweb, une configuration fonctionnelle serait la suivante : GCODE START : M5 ; D\u00e9sactiver le laser G21 ; D\u00e9finir les unit\u00e9s en mm G90 ; Positionnement absolu G0 Z0 F7000 ; R\u00e9gler la vitesse de non coupe GCODE END : M5 ; D\u00e9sactiver le laser G91 ; relatif G0 Z+20 F4000 ; G90 ; absolu GCODE HOMING : M5 ; D\u00e9sactiver le laser G28 ; D\u00e9placement sur tous les axes TOOL ON : M3 $INTENSIT\u00c9 TOOL OFF : M5 ; D\u00e9sactiver le laser INTENSIT\u00c9 DU LASER : S","title":"Utilisation des outils PWM"},{"location":"Using_PWM_Tools.html#utilisation-des-outils-pwm","text":"Ce document d\u00e9crit comment configurer un laser ou une broche contr\u00f4l\u00e9e par PWM en utilisant output_pin et quelques macros.","title":"Utilisation des outils PWM"},{"location":"Using_PWM_Tools.html#comment-cela-fonctionne-t-il","text":"En r\u00e9-utilisant la sortie pwm du ventilateur de la t\u00eate d'impression, vous pouvez contr\u00f4ler des lasers ou des broches. Ceci est utile si vous utilisez des t\u00eates d'impression commutables, par exemple le changeur d'outils E3D ou une solution DIY. Habituellement, les outils \u00e0 came tels que LaserWeb peuvent \u00eatre configur\u00e9s pour utiliser les commandes M3-M5 , qui correspondent \u00e0 vitesse de broche CW ( M3 S[0-255] ), vitesse de broche CCW ( M4 S[0-255] ) et arr\u00eat de broche ( M5 ). Avertissement : Lorsque vous pilotez un laser, prenez toutes les pr\u00e9cautions de s\u00e9curit\u00e9 auxquelles vous pouvez penser ! Les lasers \u00e0 diodes sont g\u00e9n\u00e9ralement invers\u00e9s. Cela signifie que lorsque l'unit\u00e9 centrale red\u00e9marre, le laser sera compl\u00e8tement allum\u00e9 pendant le temps n\u00e9cessaire \u00e0 l'unit\u00e9 centrale pour red\u00e9marrer. Pour faire bonne mesure, il est recommand\u00e9 de toujours porter des lunettes laser appropri\u00e9es de la bonne longueur d'onde si le laser est aliment\u00e9 ; et de d\u00e9connecter le laser lorsqu'il n'est pas n\u00e9cessaire. Vous devriez \u00e9galement configurer un d\u00e9lai de s\u00e9curit\u00e9, de sorte que lorsque votre h\u00f4te ou votre MCU rencontre une erreur, l'outil s'arr\u00eate. Pour un exemple de configuration, voir config/sample-pwm-tool.cfg .","title":"Comment cela fonctionne-t-il ?"},{"location":"Using_PWM_Tools.html#limites-actuelles","text":"La fr\u00e9quence des mises \u00e0 jour PWM est limit\u00e9e. Bien qu'elle soit tr\u00e8s pr\u00e9cise, une mise \u00e0 jour PWM ne peut se produire que toutes les 0,1 seconde, ce qui la rend presque inutile pour la gravure tram\u00e9e. Cependant, il existe une branche exp\u00e9rimentale avec ses propres compromis. A long terme, il est pr\u00e9vu d'ajouter cette fonctionnalit\u00e9 au klipper principal.","title":"Limites actuelles"},{"location":"Using_PWM_Tools.html#commandes","text":"M3/M4 S<valeur> : D\u00e9finit le cycle de travail PWM. Valeurs comprises entre 0 et 255. M5 : Arr\u00eate la sortie PWM \u00e0 la valeur d'arr\u00eat.","title":"Commandes"},{"location":"Using_PWM_Tools.html#configuration-de-laserweb","text":"Si vous utilisez Laserweb, une configuration fonctionnelle serait la suivante : GCODE START : M5 ; D\u00e9sactiver le laser G21 ; D\u00e9finir les unit\u00e9s en mm G90 ; Positionnement absolu G0 Z0 F7000 ; R\u00e9gler la vitesse de non coupe GCODE END : M5 ; D\u00e9sactiver le laser G91 ; relatif G0 Z+20 F4000 ; G90 ; absolu GCODE HOMING : M5 ; D\u00e9sactiver le laser G28 ; D\u00e9placement sur tous les axes TOOL ON : M3 $INTENSIT\u00c9 TOOL OFF : M5 ; D\u00e9sactiver le laser INTENSIT\u00c9 DU LASER : S","title":"Configuration de Laserweb"}]}